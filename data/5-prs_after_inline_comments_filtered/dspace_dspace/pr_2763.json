{"pr_number": 2763, "pr_title": "DS-4027: New user registration & forgot password", "pr_createdAt": "2020-05-20T07:19:56Z", "pr_url": "https://github.com/DSpace/DSpace/pull/2763", "timeline": [{"oid": "44d3d2bcc3c39c57cea29ed1ae9b158e0769f2be", "url": "https://github.com/DSpace/DSpace/commit/44d3d2bcc3c39c57cea29ed1ae9b158e0769f2be", "message": "[Task 70273] added POST endpoint for new registration creation and IT", "committedDate": "2020-04-14T09:58:50Z", "type": "commit"}, {"oid": "f07c3824412919b1760ee50acb966e8e3d4b037a", "url": "https://github.com/DSpace/DSpace/commit/f07c3824412919b1760ee50acb966e8e3d4b037a", "message": "[Task 70382] added the search findByToken method for Registrations and added ITs", "committedDate": "2020-04-15T08:31:29Z", "type": "commit"}, {"oid": "7da7ff03786802a4c707e2fb68e5c99079fa2bae", "url": "https://github.com/DSpace/DSpace/commit/7da7ff03786802a4c707e2fb68e5c99079fa2bae", "message": "[Task 70397] added EPersonRegistrationFeature and added ITs", "committedDate": "2020-04-15T10:57:51Z", "type": "commit"}, {"oid": "fee24e3f96dba9f2a21b97aabae29485915a3fca", "url": "https://github.com/DSpace/DSpace/commit/fee24e3f96dba9f2a21b97aabae29485915a3fca", "message": "[Task 70398] implementing change password with token patch and added ITs for the functionality", "committedDate": "2020-04-17T12:14:25Z", "type": "commit"}, {"oid": "cb8b5c8efc3baaa535b1545f31313c8a3364e02f", "url": "https://github.com/DSpace/DSpace/commit/cb8b5c8efc3baaa535b1545f31313c8a3364e02f", "message": "[Task 70399] created the POST EPerson endpoint with token and added tests", "committedDate": "2020-04-20T09:31:34Z", "type": "commit"}, {"oid": "94d9f623587bd0f48fb64ee8c62706dfd8031ac1", "url": "https://github.com/DSpace/DSpace/commit/94d9f623587bd0f48fb64ee8c62706dfd8031ac1", "message": "[Task 70399] added context authorizations modifications for eperson post with token and added its to verify functionality", "committedDate": "2020-04-27T12:52:00Z", "type": "commit"}, {"oid": "b59aeecf0e09f5d215fd8b583d27659bbe66a80a", "url": "https://github.com/DSpace/DSpace/commit/b59aeecf0e09f5d215fd8b583d27659bbe66a80a", "message": "Added extra cleanup to the EPersonRestRepositoryIT and optimized test in RegistrationRestControllerIT", "committedDate": "2020-04-29T12:03:03Z", "type": "commit"}, {"oid": "fc91b0b858a47519cb5e9aaab6738a259c1dab05", "url": "https://github.com/DSpace/DSpace/commit/fc91b0b858a47519cb5e9aaab6738a259c1dab05", "message": "Fixed checkstyle in the EPersonRestRepositoryIT class", "committedDate": "2020-05-05T09:59:05Z", "type": "commit"}, {"oid": "3dc9f511d4a8797079a8d08fa84b93a949401127", "url": "https://github.com/DSpace/DSpace/commit/3dc9f511d4a8797079a8d08fa84b93a949401127", "message": "[Task 70808] changed the link the mail to include the token in the url instead of as a parameter", "committedDate": "2020-05-08T13:43:18Z", "type": "commit"}, {"oid": "b18b52a621f9b75d92417c4a33730e56343a19b4", "url": "https://github.com/DSpace/DSpace/commit/b18b52a621f9b75d92417c4a33730e56343a19b4", "message": "[Task 70808] added javadocs", "committedDate": "2020-05-11T06:59:47Z", "type": "commit"}, {"oid": "ea47ef0c924f973aa4ec3090fac163e9881b142e", "url": "https://github.com/DSpace/DSpace/commit/ea47ef0c924f973aa4ec3090fac163e9881b142e", "message": "[Task 70808] applied feedback to the registration implementation", "committedDate": "2020-05-11T09:49:57Z", "type": "commit"}, {"oid": "8ff77a9e6d289e06e133d6e0dfd694337140f4a0", "url": "https://github.com/DSpace/DSpace/commit/8ff77a9e6d289e06e133d6e0dfd694337140f4a0", "message": "[Task 70808] added javadoc", "committedDate": "2020-05-11T09:51:38Z", "type": "commit"}, {"oid": "d3cc506b260470125c4690e73bd3f1fbca86f139", "url": "https://github.com/DSpace/DSpace/commit/d3cc506b260470125c4690e73bd3f1fbca86f139", "message": "[Task 70937] removed the canLogin parameter from the AuthorizeUtil#authorizeUpdatePassword method", "committedDate": "2020-05-19T11:42:24Z", "type": "commit"}, {"oid": "d75c9d3cae9ba165c604f30af26b24c65e9e188a", "url": "https://github.com/DSpace/DSpace/commit/d75c9d3cae9ba165c604f30af26b24c65e9e188a", "message": "Merge remote-tracking branch 'dspace/master' into w2p-70273_create-new-registration\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java", "committedDate": "2020-05-19T12:27:24Z", "type": "commit"}, {"oid": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "url": "https://github.com/DSpace/DSpace/commit/2a0971d8fbb4f27e07efe73476243c3e3c03133c", "message": "[Task 70937] fixes after merge", "committedDate": "2020-05-19T12:27:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MzY1Mg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428843652", "bodyText": "Shouldn't this call AuthenticateServiceFactory.getInstance().getAuthenticationService() .allowSetPassword(context, request, null); ?  It seems odd here that anyone can update a password as long as the EPerson exists and can login.", "author": "tdonohue", "createdAt": "2020-05-21T18:45:27Z", "path": "dspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java", "diffHunk": "@@ -601,4 +607,41 @@ public static void authorizeManageGroup(Context context, Group group) throws SQL\n \n         throw new AuthorizeException(\"not authorized to manage this group\");\n     }\n+\n+    /**\n+     * This method will return a boolean indicating whether the current user is allowed to register a new\n+     * account or not\n+     * @param context   The relevant DSpace context\n+     * @param request   The current request\n+     * @return          A boolean indicating whether the current user can register a new account or not\n+     * @throws SQLException If something goes wrong\n+     */\n+    public static boolean authorizeNewAccountRegistration(Context context, HttpServletRequest request)\n+        throws SQLException {\n+        if (DSpaceServicesFactory.getInstance().getConfigurationService()\n+                                 .getBooleanProperty(\"user.registration\", true)) {\n+            return AuthenticateServiceFactory.getInstance().getAuthenticationService()\n+                                             .allowSetPassword(context, request, null);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * This method will return a boolean indicating whether it's allowed to update the password for the EPerson\n+     * with the given email and canLogin property\n+     * @param context   The relevant DSpace context\n+     * @param email     The email to be checked\n+     * @return          A boolean indicating if the password can be updated or not\n+     */\n+    public static boolean authorizeUpdatePassword(Context context, String email) {\n+        try {\n+            EPerson eperson = EPersonServiceFactory.getInstance().getEPersonService().findByEmail(context, email);\n+            if (eperson != null && eperson.canLogIn()) {\n+                return true;", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxODM2OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r432418368", "bodyText": "This is indeed better, it would imply you can't change your password if password login is disabled. We'll update it", "author": "benbosman", "createdAt": "2020-05-29T11:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4Mjk3OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435182979", "bodyText": "This has been included now", "author": "benbosman", "createdAt": "2020-06-04T11:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0MzY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NDQwMQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428844401", "bodyText": "It's odd to me that this is using allowSetPassword instead of canSelfRegister.  It seems like it should use canSelfRegister method in the AuthenticationService", "author": "tdonohue", "createdAt": "2020-05-21T18:46:52Z", "path": "dspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java", "diffHunk": "@@ -601,4 +607,41 @@ public static void authorizeManageGroup(Context context, Group group) throws SQL\n \n         throw new AuthorizeException(\"not authorized to manage this group\");\n     }\n+\n+    /**\n+     * This method will return a boolean indicating whether the current user is allowed to register a new\n+     * account or not\n+     * @param context   The relevant DSpace context\n+     * @param request   The current request\n+     * @return          A boolean indicating whether the current user can register a new account or not\n+     * @throws SQLException If something goes wrong\n+     */\n+    public static boolean authorizeNewAccountRegistration(Context context, HttpServletRequest request)\n+        throws SQLException {\n+        if (DSpaceServicesFactory.getInstance().getConfigurationService()\n+                                 .getBooleanProperty(\"user.registration\", true)) {\n+            return AuthenticateServiceFactory.getInstance().getAuthenticationService()\n+                                             .allowSetPassword(context, request, null);", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwMDg3Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r432400876", "bodyText": "This won't work correctly because e.g. the LDAP canSelfRegister will return true due to auto-register, while that doesn't imply a new user can register explicitly. The allowSetPassword is currently the only method returning true only where expected. A new canSelfRegisterManually might be required instead", "author": "benbosman", "createdAt": "2020-05-29T10:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NDQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NDU1NQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r432674555", "bodyText": "@benbosman : I'm OK with us explaining this in more detail in a code comment. I was simply noting here that it's odd for a method named \"authorizeNewAccountRegistration\" to be checking whether you have permissions to set your password.  That jumped out as very odd to me, but it sounds like there's reasons for it.  Could we just describe those reasons in either the JavaDocs or in an inline comment here?", "author": "tdonohue", "createdAt": "2020-05-29T18:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NDQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxMzMxOQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r436813319", "bodyText": "This has been explained in code comments now", "author": "benbosman", "createdAt": "2020-06-08T15:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NDQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NTAzMw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428845033", "bodyText": "Silly thing but these two ifs can be collapsed...an empty password would have a length < 6 already.", "author": "tdonohue", "createdAt": "2020-05-21T18:48:04Z", "path": "dspace-api/src/main/java/org/dspace/eperson/AccountServiceImpl.java", "diffHunk": "@@ -155,6 +162,17 @@ public void deleteToken(Context context, String token)\n         registrationDataService.deleteByToken(context, token);\n     }\n \n+    @Override\n+    public boolean verifyPasswordStructure(String password) {\n+        if (StringUtils.isBlank(password)) {\n+            return false;\n+        }\n+        if (StringUtils.length(password) < 6) {\n+            return false;\n+        }", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NDUwOQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435184509", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjA5Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428846096", "bodyText": "We should check if registration is disabled at the very beginning.  There's no need to do any of the EPerson lookup or validation of fields if registration is disabled.  So, this should be moved towards the top of the method.", "author": "tdonohue", "createdAt": "2020-05-21T18:50:09Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/RegistrationRestController.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import javax.mail.MessagingException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.DSpaceBadRequestException;\n+import org.dspace.app.rest.exception.UnprocessableEntityException;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.AccountService;\n+import org.dspace.eperson.service.EPersonService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.rest.webmvc.ControllerUtils;\n+import org.springframework.hateoas.RepresentationModel;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+/**\n+ * This will be the Controller class that handles calls to the /api/eperson/registrations endpoints\n+ */\n+@RestController\n+@RequestMapping(\"/api/\" + RegistrationRest.CATEGORY + \"/\" + RegistrationRest.NAME_PLURAL)\n+public class RegistrationRestController {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n+    @Autowired\n+    private EPersonService ePersonService;\n+\n+    /**\n+     * This method will be used to either register a new user or to send forgotten password info in a mail.\n+     * It can be called by doing a POST request to the /api/eperson/registrations endpoint.\n+     * It'll create a RegistrationRest object from the inputstream in the request and it'll check whether the email\n+     * defined in that object is in the DB or not.\n+     * If it is in the db then we'll send the forgotten password info, if it wasn't in the database then we'll send\n+     * registration info.\n+     *\n+     * @param request   The current request\n+     * @param response  The current response\n+     * @return          An empty response containing a 201 status code\n+     * @throws SQLException If something goes wrong\n+     * @throws IOException  If something goes wrong\n+     * @throws MessagingException   If something goes wrong\n+     * @throws AuthorizeException   If something goes wrong\n+     */\n+    @RequestMapping(method = RequestMethod.POST)\n+    public ResponseEntity<RepresentationModel<?>> register(HttpServletRequest request, HttpServletResponse response)\n+        throws SQLException, IOException, MessagingException, AuthorizeException {\n+\n+        Context context = ContextUtil.obtainContext(request);\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest;\n+        try {\n+            ServletInputStream input = request.getInputStream();\n+            registrationRest = mapper.readValue(input, RegistrationRest.class);\n+        } catch (IOException e1) {\n+            throw new UnprocessableEntityException(\"Error parsing request body.\", e1);\n+        }\n+        if (StringUtils.isBlank(registrationRest.getEmail())) {\n+            throw new UnprocessableEntityException(\"The email cannot be omitted from the Registration endpoint\");\n+        }\n+        EPerson eperson = ePersonService.findByEmail(context, registrationRest.getEmail());\n+        if (eperson != null) {\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +\n+                                                        eperson.getEmail());\n+            }\n+            accountService.sendForgotPasswordInfo(context, registrationRest.getEmail());\n+        } else {\n+            if (!AuthorizeUtil.authorizeNewAccountRegistration(context, request)) {\n+                throw new AccessDeniedException(\n+                    \"Registration is disabled, you are not authorized to create a new Authorization\");", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyNjA1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r432426057", "bodyText": "We need to know whether the EPerson exists in order to identify whether it's a new registration or a password forgotten", "author": "benbosman", "createdAt": "2020-05-29T11:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NTE5Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r432675193", "bodyText": "Good point here. My mistake it seems. I'll mark this as resolved. Thanks!", "author": "tdonohue", "createdAt": "2020-05-29T18:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0NjA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0ODEyMQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428848121", "bodyText": "I don't think we need a custom Controller here.  From what I see in this class, it seems like we can do the same thing by implementing a RegistrationRestRepository that uses the createAndReturn() method for the POST action to create a new registration. If I've overlooked something, let me know.\nRemember, when possible please always use a RestRepository class...we are trying to avoid custom Controllers unless required.", "author": "tdonohue", "createdAt": "2020-05-21T18:53:53Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/RegistrationRestController.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import java.io.IOException;\n+import java.sql.SQLException;\n+import javax.mail.MessagingException;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.authorization.AuthorizationFeatureService;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.exception.DSpaceBadRequestException;\n+import org.dspace.app.rest.exception.UnprocessableEntityException;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.utils.ContextUtil;\n+import org.dspace.app.util.AuthorizeUtil;\n+import org.dspace.authorize.AuthorizeException;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.core.Context;\n+import org.dspace.eperson.EPerson;\n+import org.dspace.eperson.service.AccountService;\n+import org.dspace.eperson.service.EPersonService;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.rest.webmvc.ControllerUtils;\n+import org.springframework.hateoas.RepresentationModel;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+/**\n+ * This will be the Controller class that handles calls to the /api/eperson/registrations endpoints\n+ */\n+@RestController\n+@RequestMapping(\"/api/\" + RegistrationRest.CATEGORY + \"/\" + RegistrationRest.NAME_PLURAL)\n+public class RegistrationRestController {", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NDg5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435184891", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0ODEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0OTkzNw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428849937", "bodyText": "This log.error should match the below RuntimeException.  So, this should be:\nlog.error(\"Something went wrong in the creation of an EPerson with token: \" + token, e);\nNOTE: the RuntimeException below says \"with wrong\" when it should say \"went wrong\"", "author": "tdonohue", "createdAt": "2020-05-21T18:57:18Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -64,7 +90,23 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (IOException e1) {\n             throw new UnprocessableEntityException(\"error parsing the body... maybe this is not the right error code\");\n         }\n+        String token = req.getParameter(\"token\");\n+        // If a token is available, we'll swap to the execution that is token based\n+        if (StringUtils.isNotBlank(token)) {\n+            try {\n+                return createAndReturn(context, epersonRest, token);\n+            } catch (SQLException e) {\n+                log.error(e.getMessage(), e);", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NTIwOQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435185209", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg0OTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MDkxNQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428850915", "bodyText": "This is a large, important method.  It should have JavaDocs please.", "author": "tdonohue", "createdAt": "2020-05-21T18:59:01Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NTQxNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435185414", "bodyText": "The JavaDocs have been created", "author": "benbosman", "createdAt": "2020-06-04T11:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MDkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MTY1OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428851658", "bodyText": "Again, this should be moved to the top of the method.  No need to do all the checks above if registration is disabled altogether.", "author": "tdonohue", "createdAt": "2020-05-21T19:00:30Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NTgwMw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435185803", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MTY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjUyNg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428852526", "bodyText": "This if can be simplified by using StringUtils.isNotBlank as you have in other methods. It checks for both null and empty", "author": "tdonohue", "createdAt": "2020-05-21T19:02:09Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        // We'll turn off authorisation system because this call isn't admin based as it's token based\n+        context.turnOffAuthorisationSystem();\n+        EPerson ePerson = createEPersonFromRestObject(context, epersonRest);\n+        context.restoreAuthSystemState();\n+        // Restoring authorisation state right after the creation call\n+        accountService.deleteToken(context, token);\n+        return converter.toRest(ePerson, utils.obtainProjection());\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    private void checkRequiredProperties(EPersonRest epersonRest) {\n+        MetadataRest metadataRest = epersonRest.getMetadata();\n+        if (metadataRest != null) {\n+            List<MetadataValueRest> epersonFirstName = metadataRest.getMap().get(\"eperson.firstname\");\n+            List<MetadataValueRest> epersonLastName = metadataRest.getMap().get(\"eperson.lastname\");\n+            if (epersonFirstName == null || epersonLastName == null ||\n+                epersonFirstName.isEmpty() || epersonLastName.isEmpty()) {", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjM4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435186389", "bodyText": "epersonFirstName and epersonLastName is not a String, but rather List<MetadataValueRest>. The StringUtils.isNotBlank doesn't support that AFAIK", "author": "benbosman", "createdAt": "2020-06-04T11:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MzA2OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428853069", "bodyText": "This error should say the password is invalid.  It's not necessarily blank, as it's also invalid if it's < 6 characters (according to the verifyPasswordStructure() method)", "author": "tdonohue", "createdAt": "2020-05-21T19:03:07Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -82,8 +124,63 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n+\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        // We'll turn off authorisation system because this call isn't admin based as it's token based\n+        context.turnOffAuthorisationSystem();\n+        EPerson ePerson = createEPersonFromRestObject(context, epersonRest);\n+        context.restoreAuthSystemState();\n+        // Restoring authorisation state right after the creation call\n+        accountService.deleteToken(context, token);\n+        return converter.toRest(ePerson, utils.obtainProjection());\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    private void checkRequiredProperties(EPersonRest epersonRest) {\n+        MetadataRest metadataRest = epersonRest.getMetadata();\n+        if (metadataRest != null) {\n+            List<MetadataValueRest> epersonFirstName = metadataRest.getMap().get(\"eperson.firstname\");\n+            List<MetadataValueRest> epersonLastName = metadataRest.getMap().get(\"eperson.lastname\");\n+            if (epersonFirstName == null || epersonLastName == null ||\n+                epersonFirstName.isEmpty() || epersonLastName.isEmpty()) {\n+                throw new DSpaceBadRequestException(\"The eperson.firstname and eperson.lastname values need to be \" +\n+                                                    \"filled in\");\n+            }\n+        }\n+        String password = epersonRest.getPassword();\n+        if (!accountService.verifyPasswordStructure(password)) {\n+            throw new DSpaceBadRequestException(\"the password cannot be left blank\");", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjYwNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435186604", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MzA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTMxMw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428855313", "bodyText": "I think this error message needs improving.  But, I'm not sure how to reword it as I'm not sure I understand what is going on here.  Is this code trying to check if this is a self-registration & verify then that you must change your password?  Or am I misunderstanding why a Token requires a password change?", "author": "tdonohue", "createdAt": "2020-05-21T19:07:36Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -167,6 +264,18 @@ public EPersonRest findByEmail(@Parameter(value = \"email\", required = true) Stri\n     @PreAuthorize(\"hasPermission(#uuid, 'EPERSON', #patch)\")\n     protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, UUID uuid,\n                          Patch patch) throws AuthorizeException, SQLException {\n+        if (StringUtils.isNotBlank(request.getParameter(\"token\"))) {\n+            boolean passwordChangeFound = false;\n+            for (Operation operation : patch.getOperations()) {\n+                if (StringUtils.equalsIgnoreCase(operation.getPath(), \"/password\")) {\n+                    passwordChangeFound = true;\n+                }\n+            }\n+            if (!passwordChangeFound) {\n+                throw new AccessDeniedException(\"Couldn't perform the patch as a token with provided without \" +", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4Njg3Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435186877", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjcxMQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428856711", "bodyText": "Why does this authorization check happen after the patchWithToken()?  Shouldn't it be happening higher up in this method?  Or am I misunderstanding the code here? If I am misunderstanding, then we need to add inline comments to describe the new code...as currently it looks like if a token is included, then anyone can change the password (without checking authorization).", "author": "tdonohue", "createdAt": "2020-05-21T19:10:22Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/EPersonPasswordReplaceOperation.java", "diffHunk": "@@ -27,25 +37,59 @@\n @Component\n public class EPersonPasswordReplaceOperation<R> extends PatchOperation<R> {\n \n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+        .getLogger(EPersonPasswordReplaceOperation.class);\n+\n     /**\n      * Path in json body of patch that uses this operation\n      */\n     public static final String OPERATION_PASSWORD_CHANGE = \"/password\";\n     protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n \n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n     @Override\n     public R perform(Context context, R object, Operation operation) {\n         checkOperationValue(operation.getValue());\n         if (supports(object, operation)) {\n             EPerson eperson = (EPerson) object;\n+            String token = requestService.getCurrentRequest().getHttpServletRequest().getParameter(\"token\");\n             checkModelForExistingValue(eperson);\n+            if (StringUtils.isNotBlank(token)) {\n+                patchWithToken(context,eperson, token, operation);\n+            }\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzMwNg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435187306", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NjcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NzQ5NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428857494", "bodyText": "Please log a more descriptive message.  e.getMessage() gives no more information to the logs than what e already provides.", "author": "tdonohue", "createdAt": "2020-05-21T19:12:06Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/EPersonPasswordReplaceOperation.java", "diffHunk": "@@ -27,25 +37,59 @@\n @Component\n public class EPersonPasswordReplaceOperation<R> extends PatchOperation<R> {\n \n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+        .getLogger(EPersonPasswordReplaceOperation.class);\n+\n     /**\n      * Path in json body of patch that uses this operation\n      */\n     public static final String OPERATION_PASSWORD_CHANGE = \"/password\";\n     protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n \n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n     @Override\n     public R perform(Context context, R object, Operation operation) {\n         checkOperationValue(operation.getValue());\n         if (supports(object, operation)) {\n             EPerson eperson = (EPerson) object;\n+            String token = requestService.getCurrentRequest().getHttpServletRequest().getParameter(\"token\");\n             checkModelForExistingValue(eperson);\n+            if (StringUtils.isNotBlank(token)) {\n+                patchWithToken(context,eperson, token, operation);\n+            }\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +\n+                                                        eperson.getEmail());\n+            }\n             ePersonService.setPassword(eperson, (String) operation.getValue());\n             return object;\n         } else {\n             throw new DSpaceBadRequestException(\"EPersonPasswordReplaceOperation does not support this operation\");\n         }\n     }\n \n+    private void patchWithToken(Context context, EPerson eperson, String token, Operation operation) {\n+        try {\n+            EPerson ePersonFromToken = accountService.getEPerson(context, token);\n+            if (ePersonFromToken == null) {\n+                throw new AccessDeniedException(\"The token in the parameter: \" + token + \" couldn't\" +\n+                                                    \" be associated with an EPerson\");\n+            }\n+            if (!ePersonFromToken.getID().equals(eperson.getID())) {\n+                throw new AccessDeniedException(\"The token in the parameter belongs to a different EPerson\" +\n+                                                    \" than the uri indicates\");\n+            }\n+            accountService.deleteToken(context, token);\n+        } catch (SQLException | AuthorizeException e) {\n+            log.error(e.getMessage(), e);", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzQ5Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435187493", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NzQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NzY2NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428857664", "bodyText": "This method appears to be misnamed.  I don't see a patch going on here...it looks to just delete the token?", "author": "tdonohue", "createdAt": "2020-05-21T19:12:28Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/EPersonPasswordReplaceOperation.java", "diffHunk": "@@ -27,25 +37,59 @@\n @Component\n public class EPersonPasswordReplaceOperation<R> extends PatchOperation<R> {\n \n+    private static final Logger log = org.apache.logging.log4j.LogManager\n+        .getLogger(EPersonPasswordReplaceOperation.class);\n+\n     /**\n      * Path in json body of patch that uses this operation\n      */\n     public static final String OPERATION_PASSWORD_CHANGE = \"/password\";\n     protected EPersonService ePersonService = EPersonServiceFactory.getInstance().getEPersonService();\n \n+    @Autowired\n+    private RequestService requestService;\n+\n+    @Autowired\n+    private AccountService accountService;\n+\n     @Override\n     public R perform(Context context, R object, Operation operation) {\n         checkOperationValue(operation.getValue());\n         if (supports(object, operation)) {\n             EPerson eperson = (EPerson) object;\n+            String token = requestService.getCurrentRequest().getHttpServletRequest().getParameter(\"token\");\n             checkModelForExistingValue(eperson);\n+            if (StringUtils.isNotBlank(token)) {\n+                patchWithToken(context,eperson, token, operation);\n+            }\n+            if (!AuthorizeUtil.authorizeUpdatePassword(context, eperson.getEmail())) {\n+                throw new DSpaceBadRequestException(\"Password cannot be updated for the given EPerson with email: \" +\n+                                                        eperson.getEmail());\n+            }\n             ePersonService.setPassword(eperson, (String) operation.getValue());\n             return object;\n         } else {\n             throw new DSpaceBadRequestException(\"EPersonPasswordReplaceOperation does not support this operation\");\n         }\n     }\n \n+    private void patchWithToken(Context context, EPerson eperson, String token, Operation operation) {", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzU0Mg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435187542", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T11:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NzY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODMyMA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428858320", "bodyText": "This must be followed by a context.restoreAuthSystemState(); in this same method after you are done creating content", "author": "tdonohue", "createdAt": "2020-05-21T19:13:57Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -110,6 +135,34 @@ public void createTest() throws Exception {\n         // TODO cleanup the context!!!\n     }\n \n+    @Test\n+    public void createAnonAccessDeniedTest() throws Exception {\n+        context.turnOffAuthorisationSystem();", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4Nzk0Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435187946", "bodyText": "This has been included now", "author": "benbosman", "createdAt": "2020-06-04T11:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODQ4Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428858487", "bodyText": "After this POST, we should have a test to verify that the person was not created.", "author": "tdonohue", "createdAt": "2020-05-21T19:14:18Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -110,6 +135,34 @@ public void createTest() throws Exception {\n         // TODO cleanup the context!!!\n     }\n \n+    @Test\n+    public void createAnonAccessDeniedTest() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+        // we should check how to get it from Spring\n+        ObjectMapper mapper = new ObjectMapper();\n+        EPersonRest data = new EPersonRest();\n+        EPersonRest dataFull = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        data.setEmail(\"createtest@fake-email.com\");\n+        data.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        data.setMetadata(metadataRest);\n+        dataFull.setEmail(\"createtestFull@fake-email.com\");\n+        dataFull.setCanLogIn(true);\n+        dataFull.setMetadata(metadataRest);\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                         .content(mapper.writeValueAsBytes(data))\n+                                         .contentType(contentType)\n+                                         .param(\"projection\", \"full\"))\n+                            .andExpect(status().isUnauthorized());", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4ODE1Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435188156", "bodyText": "This is now verified", "author": "benbosman", "createdAt": "2020-06-04T11:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1ODQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MDAxNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428860014", "bodyText": "Maybe I'm misunderstanding something, but if the registration data is null, then shouldn't the token have been deleted already?  Why do we need to have the deleteByToken() here?", "author": "tdonohue", "createdAt": "2020-05-21T19:17:18Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4ODk1OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435188959", "bodyText": "It's indeed not necessary, it has now been replaced with a verification proving the token has been deleted", "author": "benbosman", "createdAt": "2020-06-04T11:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MDgxOA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428860818", "bodyText": "Just as a note, you can use assertNotEquals() here...it makes these tests much much easier to read/review...there's also an assertEquals() method.  You don't always need to only use assertFalse and assertTrue.\nSimilarly, the next line can just say assertNull()", "author": "tdonohue", "createdAt": "2020-05-21T19:18:50Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMTQ3MQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435201471", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T12:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MDgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MTk2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428861963", "bodyText": "I'm finding these asserts hard to read/understand.  I'd recommend these be assertEquals(), assertNotNull and assertEquals()", "author": "tdonohue", "createdAt": "2020-05-21T19:21:01Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMTU0Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435201546", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T12:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MTk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjU3OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428862579", "bodyText": "Again, can be assertEquals and assertNotNull", "author": "tdonohue", "createdAt": "2020-05-21T19:22:18Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMTYxNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435201614", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T12:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjgzNg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428862836", "bodyText": "Can be assertEquals, assertNotNull, and assertEquals", "author": "tdonohue", "createdAt": "2020-05-21T19:22:47Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMTY2Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435201666", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-04T12:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MjgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzQwNQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428863405", "bodyText": "Should the registration data simply be cleaned up by the EPersonBuilder?  That'd simplify having to do all this manual cleanup in every method.", "author": "tdonohue", "createdAt": "2020-05-21T19:23:58Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxOTI0Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r436819243", "bodyText": "The problem with that approach is that this would only work for the forgot password tokens\nThe new user registration tokens don't have an EPerson account", "author": "benbosman", "createdAt": "2020-06-08T16:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2MzQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDkxOQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428864919", "bodyText": "We should never create manual JSON in tests. Please look at examples from other ITs on how this is done.  You should be able to just fill out an EPersonRest object and call .content(mapper.writeValueAsBytes(epersonRest)).  See for example the createTest() in this same class.", "author": "tdonohue", "createdAt": "2020-05-21T19:26:59Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMzYwOQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435203609", "bodyText": "The reason why this is necessary for this test has been documented at 4ea4f91#diff-a256d3cb30e4b4ad847136e8ffedb15aR2067", "author": "benbosman", "createdAt": "2020-06-04T12:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjE4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428866189", "bodyText": "Please look at the newly updated createTest() method for the proper way to cleanup an EPerson after a POST.  The way you are doing this in this method has performance issues, which we cleaned up in #2759", "author": "tdonohue", "createdAt": "2020-05-21T19:29:32Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxNzM1Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r436817357", "bodyText": "This has been adjusted: fdaddd9#diff-a256d3cb30e4b4ad847136e8ffedb15aR2117", "author": "benbosman", "createdAt": "2020-06-08T15:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjMyMA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428866320", "bodyText": "Again, no manually created JSON please", "author": "tdonohue", "createdAt": "2020-05-21T19:29:47Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMzgzNQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435203835", "bodyText": "The reason why this is necessary for this test has been documented at 4ea4f91#diff-a256d3cb30e4b4ad847136e8ffedb15aR2119", "author": "benbosman", "createdAt": "2020-06-04T12:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjYwMw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428866603", "bodyText": "Again, look at the best practices of cleanup after a POST established in #2759", "author": "tdonohue", "createdAt": "2020-05-21T19:30:14Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(json)\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isCreated())\n+                                              .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                  hasJsonPath(\"$.uuid\", not(empty())),\n+                                                  // is it what you expect? EPerson.getName() returns the email...\n+                                                  //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                  hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                  hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                  hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                  hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                      matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                      matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                  ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgxNzkxMg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r436817912", "bodyText": "This has been adjusted: fdaddd9#diff-a256d3cb30e4b4ad847136e8ffedb15aR2171", "author": "benbosman", "createdAt": "2020-06-08T16:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NjYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY1OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r428867658", "bodyText": "Same in this method.  No manual JSON & correct the POST cleanup", "author": "tdonohue", "createdAt": "2020-05-21T19:32:16Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1773,4 +1826,668 @@ public void getDirectEpersonGroups() throws Exception {\n                             );\n \n     }\n+\n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertFalse(oldPassword.equals(newPasswordHash));\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(),\n+                                      tokenForEPerson));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"Johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertTrue(StringUtils.equalsIgnoreCase(ePerson.getEmail(), originalEmail));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        String token = getAuthToken(admin.getEmail(), password);\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient(token).perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isForbidden());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                .param(\"token\", newRegisterToken)\n+                                .content(json)\n+                                .contentType(MediaType.APPLICATION_JSON))\n+                                  .andExpect(status().isCreated())\n+                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                            hasJsonPath(\"$.uuid\", not(empty())),\n+                            // is it what you expect? EPerson.getName() returns the email...\n+                            //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                            hasJsonPath(\"$.type\", is(\"eperson\")),\n+                            hasJsonPath(\"$._links.self.href\", not(empty())),\n+                            hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                matchMetadata(\"eperson.firstname\", \"John\"),\n+                                matchMetadata(\"eperson.lastname\", \"Doe\")\n+                            ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        MvcResult mvcResult = getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(json)\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isCreated())\n+                                              .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                  hasJsonPath(\"$.uuid\", not(empty())),\n+                                                  // is it what you expect? EPerson.getName() returns the email...\n+                                                  //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                  hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                  hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                  hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                  hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                      matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                      matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                  ))))).andReturn();\n+\n+        String content = mvcResult.getResponse().getContentAsString();\n+        Map<String,Object> map = mapper.readValue(content, Map.class);\n+        String epersonUuid = String.valueOf(map.get(\"uuid\"));\n+        EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+        assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+        assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        ePersonService.delete(context, createdEPerson);\n+        context.restoreAuthSystemState();\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"selfRegistered\\\":true,\\\"email\\\":\\\"\" + newRegisterEmail +\n+            \"\\\",\\\"password\\\":\\\"somePassword\\\",\\\"type\\\":\\\"eperson\\\"}\";", "originalCommit": "2a0971d8fbb4f27e07efe73476243c3e3c03133c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwNzc2OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435207769", "bodyText": "The reason why this is necessary for this test has been documented at 4ea4f91#diff-a256d3cb30e4b4ad847136e8ffedb15aR2236", "author": "benbosman", "createdAt": "2020-06-04T12:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk3NTQ1MQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r435975451", "bodyText": "@benbosman : I don't understand this explanation for the manually created JSON.  The inline comment you linked to says:\nWhen using the mapper to write an EPersonRest object to JSON to pass it along, the password gets lost\nDoes this imply there's a bug in the how the Mapper is generating JSON from EPersonRest object?  Or maybe we need to have a different Mapper for our test environment which doesn't drop the password (if it's doing it on purpose for some reason).  I really don't like manually created JSON as it is very prone to typos that can cause major errors.  It's also very hard to read, as you cannot tell which brackets align with other brackets.\nSo, I'd like us to look more at why the mapper isn't functioning properly here and determine if maybe we need to fix it, or create a separate Mapper specifically for these tests.  Therefore, I'm going to unresolve this conversation for now.", "author": "tdonohue", "createdAt": "2020-06-05T14:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgyMjcxNQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r436822715", "bodyText": "This is due to https://github.com/atmire/DSpace/blob/w2p-70273_create-new-registration/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/EPersonRest.java#L46\nIt's WRITE_ONLY, so the IT will not include the password if you attach it to the EPersonRest object\nShould we add a link to that line to explain this in detail?", "author": "benbosman", "createdAt": "2020-06-08T16:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk0OTY2NQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r436949665", "bodyText": "@benbosman : Oh, I see what you mean now. In that case, I'd recommend we override this behavior just in our tests.  Here's a way to do that: https://stackoverflow.com/a/55064740\nEssentially, we can create that tiny JacksonAnnotationInstrospector class in our test classes. Then in this method, we should be able to still use a mapper, but call mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\nYou could always add a brief inline comment before that line to say \"We need to ignore the WRITE_ONLY annotation on the password property in order to use the mapper\"\nI think this approach would be cleaner than using manually created JSON, and it should be the new best practice if we encounter this issue again elsewhere in tests.", "author": "tdonohue", "createdAt": "2020-06-08T19:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2OTIyNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r438769224", "bodyText": "@tdonohue thanks for the suggestion, Raf has committed this for all parts where JSON was manually used in 3aba1b7", "author": "benbosman", "createdAt": "2020-06-11T13:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NzY1OA=="}], "type": "inlineReview"}, {"oid": "4ea4f9112948d28858fb9b8f727da75fe4312032", "url": "https://github.com/DSpace/DSpace/commit/4ea4f9112948d28858fb9b8f727da75fe4312032", "message": "[Task 71213] applied feedback to the new registration creation functionality", "committedDate": "2020-06-03T12:42:40Z", "type": "commit"}, {"oid": "9ccdff521c5f32a9d7404b061fcdbc85550f2943", "url": "https://github.com/DSpace/DSpace/commit/9ccdff521c5f32a9d7404b061fcdbc85550f2943", "message": "Merge remote-tracking branch 'dspace/master' into w2p-70273_create-new-registration\n\nConflicts:\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java\n\tdspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "committedDate": "2020-06-08T13:21:09Z", "type": "commit"}, {"oid": "fdaddd934fe140c60a3db77a1c79a363b369ecb6", "url": "https://github.com/DSpace/DSpace/commit/fdaddd934fe140c60a3db77a1c79a363b369ecb6", "message": "[Task 71271] applied fixes after merge and applied community feedback to the new registration endpoints", "committedDate": "2020-06-08T14:24:19Z", "type": "commit"}, {"oid": "80f7bad4944924b6644d02cfeb9e99e4529cce5b", "url": "https://github.com/DSpace/DSpace/commit/80f7bad4944924b6644d02cfeb9e99e4529cce5b", "message": "[Task 71348] fixed the patch replace password for eperson with a token to now be available to anonymous calls", "committedDate": "2020-06-11T08:23:50Z", "type": "commit"}, {"oid": "3aba1b7545546a068f311adf7f71695699df84d9", "url": "https://github.com/DSpace/DSpace/commit/3aba1b7545546a068f311adf7f71695699df84d9", "message": "Added a way to ignore write only properties in REST objects for tests and rewrote EPersonRestRepositoryIT tests to use this", "committedDate": "2020-06-11T13:08:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzMzYxNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439033614", "bodyText": "Looks like we still have one instance of manually created JSON.  Can we replace this one as well? (by using IgnoreJacksonWriteOnlyAccess())", "author": "tdonohue", "createdAt": "2020-06-11T19:57:02Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1787,6 +1846,793 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        // We need to create this json manually to support actually setting the password to a value.\n+        // When using the mapper to write an EPersonRest object to JSON to pass it along, the password gets lost\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxOTgzNg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r442919836", "bodyText": "This has been replaced", "author": "benbosman", "createdAt": "2020-06-19T15:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzMzYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNDI5MA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439034290", "bodyText": "These two context lines can be removed.  They aren't doing anything :)  Likely an accidental copy & paste mistake", "author": "tdonohue", "createdAt": "2020-06-11T19:58:23Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1787,6 +1846,793 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        // We need to create this json manually to support actually setting the password to a value.\n+        // When using the mapper to write an EPersonRest object to JSON to pass it along, the password gets lost\n+        String json = \"{\\\"metadata\\\":{\\\"eperson.firstname\\\":[{\\\"value\\\":\\\"John\\\"}],\" +\n+            \"\\\"eperson.lastname\\\":[{\\\"value\\\":\\\"Doe\\\"}]},\\\"password\\\":\\\"somePassword\\\",\" +\n+            \"\\\"type\\\":\\\"eperson\\\"}\";\n+\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(json)\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            context.restoreAuthSystemState();", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyMDAxNw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r442920017", "bodyText": "This has been removed", "author": "benbosman", "createdAt": "2020-06-19T15:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNjAwOA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439036008", "bodyText": "This looks like unrelated code.  I don't understand what this would have to do with user registration / forgot password.  Was this accidentally included in a recent commit?", "author": "tdonohue", "createdAt": "2020-06-11T20:02:08Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/ProcessRestRepositoryIT.java", "diffHunk": "@@ -43,6 +43,13 @@\n \n     @Before\n     public void setup() throws SQLException {\n+        CollectionUtils.emptyIfNull(processService.findAll(context)).stream().forEach(process -> {\n+            try {\n+                processService.delete(context, process);\n+            } catch (SQLException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyMzA3OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r442923079", "bodyText": "This has been removed", "author": "benbosman", "createdAt": "2020-06-19T16:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNjAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNzA0OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439037049", "bodyText": "Since you are now cleaning up the created registration data in each of the below tests (and in other tests in this PR), this entire setup() should be unnecessary & likely can be removed.  Each test should cleanup after itself instead of doing \"just in case\" cleanup before running each test.", "author": "tdonohue", "createdAt": "2020-06-11T20:04:26Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestControllerIT.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.sql.SQLException;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestControllerIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+\n+    @Before\n+    public void setup() throws SQLException {\n+        CollectionUtils.emptyIfNull(registrationDataDAO.findAll(context, RegistrationData.class)).stream()\n+                       .forEach(registrationData -> {\n+                           try {\n+                               registrationDataDAO.delete(context, registrationData);\n+                           } catch (SQLException e) {\n+                               throw new RuntimeException(e);\n+                           }\n+                       });\n+    }", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyMzg3OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r442923878", "bodyText": "This has been removed now", "author": "benbosman", "createdAt": "2020-06-19T16:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNzA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNzY0Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439037647", "bodyText": "Just a note, you don't need to make context changes to set a configuration properly.  So the two context lines can be removed here, they aren't doing anything.", "author": "tdonohue", "createdAt": "2020-06-11T20:05:42Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", false);\n+        context.restoreAuthSystemState();", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzODA0MA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439038040", "bodyText": "Same as above, the two context lines aren't doing anything.  As a sidenote too, the configurationService reloads between test classes, so you don't need to reset the configuration properly here if you don't want to.  In other words, these three lines could be removed", "author": "tdonohue", "createdAt": "2020-06-11T20:06:34Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", false);\n+        context.restoreAuthSystemState();\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isNoContent());\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", true);\n+        context.restoreAuthSystemState();", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4NzA4OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439487088", "bodyText": "Minor update / sidenote:  I noticed others making this same honest mistake with regards to changing configuration properties in tests. So, I added this to our Code Testing Guide: https://wiki.lyrasis.org/display/DSPACE/Code+Testing+Guide#CodeTestingGuide-Changingconfigurationpropertiesintests\nSo, just to clarify for the future.  Changing config values doesn't require messing with the context.  And you don't need to change them back to defaults (it'll happen automatically).  But, both of those notes are now in the testing guide!", "author": "tdonohue", "createdAt": "2020-06-12T15:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzODA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyNDEyNg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r442924126", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-19T16:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzODA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzODM3Mg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439038372", "bodyText": "Same here, context lines aren't doing anything. You can change configs without turning off authorization.", "author": "tdonohue", "createdAt": "2020-06-11T20:07:00Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", false);\n+        context.restoreAuthSystemState();\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isNoContent());\n+\n+        context.turnOffAuthorisationSystem();\n+        configurationService.setProperty(\"user.registration\", true);\n+        context.restoreAuthSystemState();\n+    }\n+\n+\n+    @Test\n+    public void userRegistrationEnabledShibTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+\n+        context.turnOffAuthorisationSystem();\n+        //Enable Shibboleth and password login\n+        configurationService.setProperty(\"plugin.sequence.org.dspace.authenticate.AuthenticationMethod\", SHIB_ONLY);\n+        context.restoreAuthSystemState();", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyNDIwMg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r442924202", "bodyText": "This has been adjusted", "author": "benbosman", "createdAt": "2020-06-19T16:03:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzODM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NDU4NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r439044584", "bodyText": "Can we add in JavaDocs here?  It should say something like:\nThis is a custom JacksonAnnotationIntrospector which allows us to ignore `@JsonProperty(access = Access.WRITE_ONLY)` annotations in our tests.\nNormally, this annotation allows the property to be written to (during deserialization),\nbut does NOT allow it to be read (during serialization).  \nIn some tests, we need to ignore this annotation so that the test can use/verify the property\nduring both serialization & deserialization.\n\nIn order to use this class in a test, assign it the the current mapper like this:\nmapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());", "author": "tdonohue", "createdAt": "2020-06-11T20:15:12Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/jackson/IgnoreJacksonWriteOnlyAccess.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.jackson;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class IgnoreJacksonWriteOnlyAccess extends JacksonAnnotationIntrospector {", "originalCommit": "3aba1b7545546a068f311adf7f71695699df84d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyNDU3Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r442924573", "bodyText": "The Javadocs have been included", "author": "benbosman", "createdAt": "2020-06-19T16:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NDU4NA=="}], "type": "inlineReview"}, {"oid": "d212a84a4e1d2739e958337258e94811c589d7d0", "url": "https://github.com/DSpace/DSpace/commit/d212a84a4e1d2739e958337258e94811c589d7d0", "message": "[Task 71442] applied feedback to the new registration endpoint", "committedDate": "2020-06-19T07:56:34Z", "type": "commit"}, {"oid": "e73686e05bf4ffcc7e5f1096a97f10121239d11f", "url": "https://github.com/DSpace/DSpace/commit/e73686e05bf4ffcc7e5f1096a97f10121239d11f", "message": "Merge remote-tracking branch 'dspace/master' into w2p-70273_create-new-registration\n\nConflicts:\n\tdspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java\n\tdspace-server-webapp/src/main/java/org/dspace/app/rest/security/EPersonRestPermissionEvaluatorPlugin.java\n\tdspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "committedDate": "2020-06-19T08:17:57Z", "type": "commit"}, {"oid": "de6bc7d8d024b88d9b69da5032c0ba7edb9c854c", "url": "https://github.com/DSpace/DSpace/commit/de6bc7d8d024b88d9b69da5032c0ba7edb9c854c", "message": "[Task 71442] fixed compile error after merge", "committedDate": "2020-06-19T08:18:28Z", "type": "commit"}, {"oid": "891ab3f3e261e8a78321091b8835fab413937899", "url": "https://github.com/DSpace/DSpace/commit/891ab3f3e261e8a78321091b8835fab413937899", "message": "[Task 71442] fixed the tests without the additional cleanup required", "committedDate": "2020-06-19T12:47:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MDI2Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r443640263", "bodyText": "This IT class can be removed. The RegistrationRestController was removed and refactored into RegistrationRestRepository.  So, these tests can also be moved if they don't already exist elsewhere or simply removed if they are duplicative.\nKeep in mind, if the tests here are kept, they need cleanup. They are not cleaning up after a POST properly (in both methods) and the forgotPasswordTest() test is strangely calling context.complete() and turning off authorization around a simple config change.\nI think these same functions are already tested elsewhere though, so I'd lean towards removing this IT class entirely as it looks duplicative.", "author": "tdonohue", "createdAt": "2020-06-22T15:23:46Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestControllerIT.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestControllerIT extends AbstractControllerIntegrationTest {", "originalCommit": "891ab3f3e261e8a78321091b8835fab413937899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU5NDk5NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445594994", "bodyText": "The tests have been moved, they were not duplicates\nThe test data is cleaned up, but as noted in #2763 (comment) the alternative mode for cleanup can't be used here", "author": "benbosman", "createdAt": "2020-06-25T14:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MDI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MTI3Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r443641277", "bodyText": "Needs to cleanup after POST. See https://wiki.lyrasis.org/display/DSPACE/Code+Testing+Guide#CodeTestingGuide-Cleaninguptestdata", "author": "tdonohue", "createdAt": "2020-06-22T15:25:08Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+    }\n+\n+    @Test\n+    public void findByTokenNotExistingTokenTest() throws Exception {\n+        getClient().perform(get(\"/api/eperson/registration/search/findByToken\")\n+                                .param(\"token\", \"ThisTokenDoesNotExist\"))\n+                   .andExpect(status().isNotFound());\n+    }\n+\n+    private void createTokenForEmail(String email) throws Exception {\n+        List<RegistrationData> registrationDatas;\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(email);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());", "originalCommit": "891ab3f3e261e8a78321091b8835fab413937899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3NDEwNQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445574105", "bodyText": "@tdonohue There's no builder for this, and the POST doesn't return an ID, so I think we'll need to keep the current cleanup (which is happening correctly)", "author": "benbosman", "createdAt": "2020-06-25T13:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MTI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjYxOA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732618", "bodyText": "yes I agree with @benbosman", "author": "abollini", "createdAt": "2020-06-25T17:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY0MTI3Nw=="}], "type": "inlineReview"}, {"oid": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "url": "https://github.com/DSpace/DSpace/commit/32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "message": "[Task 71604] moved RegistrationRestControllerIT tests to RegistrationRestRepositoryIT and added extra cleanup", "committedDate": "2020-06-25T14:17:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NTY5NQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445565695", "bodyText": "I have read the previous discussion but I still don't understand why we cannot simply rely only on the dspace.cfg property. Why should I put user.registration to true if I wan't allow user registration?", "author": "abollini", "createdAt": "2020-06-25T13:39:46Z", "path": "dspace-api/src/main/java/org/dspace/app/util/AuthorizeUtil.java", "diffHunk": "@@ -605,9 +612,53 @@ public static void authorizeManageGroup(Context context, Group group) throws SQL\n         throw new AuthorizeException(\"not authorized to manage this group\");\n     }\n \n+    /**\n+     * This method will return a boolean indicating whether the current user is allowed to register a new\n+     * account or not\n+     * @param context   The relevant DSpace context\n+     * @param request   The current request\n+     * @return          A boolean indicating whether the current user can register a new account or not\n+     * @throws SQLException If something goes wrong\n+     */\n+    public static boolean authorizeNewAccountRegistration(Context context, HttpServletRequest request)\n+        throws SQLException {\n+        if (DSpaceServicesFactory.getInstance().getConfigurationService()\n+                                 .getBooleanProperty(\"user.registration\", true)) {\n+            // This allowSetPassword is currently the only mthod that would return true only when it's\n+            // actually expected to be returning true.\n+            // For example the LDAP canSelfRegister will return true due to auto-register, while that\n+            // does not imply a new user can register explicitly\n+            return AuthenticateServiceFactory.getInstance().getAuthenticationService()\n+                                             .allowSetPassword(context, request, null);", "originalCommit": "891ab3f3e261e8a78321091b8835fab413937899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxMzM4Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446013387", "bodyText": "As discussed with Tim in https://github.com/DSpace/DSpace/pull/2763/files/891ab3f3e261e8a78321091b8835fab413937899#r428844401, there is no method in the authentication services which correctly verifies whether you can register a new account. A ticket can be created for that problem, but it was considered out of scope for this PR to fix that issue in the API", "author": "benbosman", "createdAt": "2020-06-26T07:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NTY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNDQzMg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446014432", "bodyText": "I've created #2793", "author": "benbosman", "createdAt": "2020-06-26T07:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NTY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc2OTc0Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r447769743", "bodyText": "I'm fine with moving this to a separate discussion", "author": "abollini", "createdAt": "2020-06-30T15:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NTY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NzA3NQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445567075", "bodyText": "this seems me to confirm that we only need to check the dspace.cfg parameter (see previous comment)", "author": "abollini", "createdAt": "2020-06-25T13:41:44Z", "path": "dspace-api/src/main/java/org/dspace/eperson/AccountServiceImpl.java", "diffHunk": "@@ -67,6 +71,9 @@ protected AccountServiceImpl() {\n     public void sendRegistrationInfo(Context context, String email)\n         throws SQLException, IOException, MessagingException,\n         AuthorizeException {\n+        if (!configurationService.getBooleanProperty(\"user.registration\", true)) {\n+            throw new IllegalStateException(\"The user.registration parameter was set to false\");\n+        }", "originalCommit": "891ab3f3e261e8a78321091b8835fab413937899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxMzcyOQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446013729", "bodyText": "A ticket can be created to deal with the lack of this detail in the API", "author": "benbosman", "createdAt": "2020-06-26T07:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NzA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNDQ5Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446014496", "bodyText": "I've created #2793", "author": "benbosman", "createdAt": "2020-06-26T07:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU2NzA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3MjcxNg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445572716", "bodyText": "this meet the current contract, I'm just thinking that a 422 would be more appropriate here as there is a semantic / status issue more than a formal error. But if you don't agree, ignore it and we can eventually open an issue to discuss it in future and apply later the changes (if agreed)", "author": "abollini", "createdAt": "2020-06-25T13:49:41Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -90,8 +132,81 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    /**\n+     * This method will perform checks on whether or not the given Request was valid for the creation of an EPerson\n+     * with a token or not.\n+     * It'll check that the token exists, that the token doesn't yet resolve to an actual eperson already,\n+     * that the email in the given json is equal to the email for the token and that other properties are set to\n+     * what we expect in this creation.\n+     * It'll check if all of those constraints hold true and if we're allowed to register new accounts.\n+     * If this is the case, we'll create an EPerson without any authorization checks and delete the token\n+     * @param context       The DSpace context\n+     * @param epersonRest   The EPersonRest given to be created\n+     * @param token         The token to be used\n+     * @return              The EPersonRest after the creation of the EPerson object\n+     * @throws AuthorizeException   If something goes wrong\n+     * @throws SQLException         If something goes wrong\n+     */\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");", "originalCommit": "891ab3f3e261e8a78321091b8835fab413937899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNTA5OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446015098", "bodyText": "The contract explicitly mentions status 400 for this use case, that would contradict the contract", "author": "benbosman", "createdAt": "2020-06-26T07:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3MjcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3NDQ4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445574489", "bodyText": "also in this case, as the issue is inside the json I would prefer a 422. It would be useful in any case note in the contract that this error is throw when the metadata are missing (it is noted that they are mandatory)", "author": "abollini", "createdAt": "2020-06-25T13:51:52Z", "path": "dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/EPersonRestRepository.java", "diffHunk": "@@ -90,8 +132,81 @@ protected EPersonRest createAndReturn(Context context)\n         } catch (SQLException e) {\n             throw new RuntimeException(e.getMessage(), e);\n         }\n+        return eperson;\n+    }\n \n-        return converter.toRest(eperson, utils.obtainProjection());\n+    /**\n+     * This method will perform checks on whether or not the given Request was valid for the creation of an EPerson\n+     * with a token or not.\n+     * It'll check that the token exists, that the token doesn't yet resolve to an actual eperson already,\n+     * that the email in the given json is equal to the email for the token and that other properties are set to\n+     * what we expect in this creation.\n+     * It'll check if all of those constraints hold true and if we're allowed to register new accounts.\n+     * If this is the case, we'll create an EPerson without any authorization checks and delete the token\n+     * @param context       The DSpace context\n+     * @param epersonRest   The EPersonRest given to be created\n+     * @param token         The token to be used\n+     * @return              The EPersonRest after the creation of the EPerson object\n+     * @throws AuthorizeException   If something goes wrong\n+     * @throws SQLException         If something goes wrong\n+     */\n+    private EPersonRest createAndReturn(Context context, EPersonRest epersonRest, String token)\n+        throws AuthorizeException, SQLException {\n+        if (!AuthorizeUtil.authorizeNewAccountRegistration(context, requestService\n+            .getCurrentRequest().getHttpServletRequest())) {\n+            throw new DSpaceBadRequestException(\n+                \"Registration is disabled, you are not authorized to create a new Authorization\");\n+        }\n+        RegistrationData registrationData = registrationDataService.findByToken(context, token);\n+        if (registrationData == null) {\n+            throw new DSpaceBadRequestException(\"The token given as parameter: \" + token + \" does not exist\" +\n+                                                \" in the database\");\n+        }\n+        if (es.findByEmail(context, registrationData.getEmail()) != null) {\n+            throw new DSpaceBadRequestException(\"The token given already contains an email address that resolves\" +\n+                                                \"to an eperson\");\n+        }\n+        String emailFromJson = epersonRest.getEmail();\n+        if (StringUtils.isNotBlank(emailFromJson)) {\n+            if (!StringUtils.equalsIgnoreCase(registrationData.getEmail(), emailFromJson)) {\n+                throw new DSpaceBadRequestException(\"The email resulting from the token does not match the email given\"\n+                                                        + \" in the json body. Email from token: \" +\n+                                                    registrationData.getEmail() + \" email from the json body: \"\n+                                                    + emailFromJson);\n+            }\n+        }\n+        if (epersonRest.isSelfRegistered() != null && !epersonRest.isSelfRegistered()) {\n+            throw new DSpaceBadRequestException(\"The self registered property cannot be set to false using this method\"\n+                                                    + \" with a token\");\n+        }\n+        checkRequiredProperties(epersonRest);\n+        // We'll turn off authorisation system because this call isn't admin based as it's token based\n+        context.turnOffAuthorisationSystem();\n+        EPerson ePerson = createEPersonFromRestObject(context, epersonRest);\n+        context.restoreAuthSystemState();\n+        // Restoring authorisation state right after the creation call\n+        accountService.deleteToken(context, token);\n+        if (context.getCurrentUser() == null) {\n+            context.setCurrentUser(ePerson);\n+        }\n+        return converter.toRest(ePerson, utils.obtainProjection());\n+    }\n+\n+    private void checkRequiredProperties(EPersonRest epersonRest) {\n+        MetadataRest metadataRest = epersonRest.getMetadata();\n+        if (metadataRest != null) {\n+            List<MetadataValueRest> epersonFirstName = metadataRest.getMap().get(\"eperson.firstname\");\n+            List<MetadataValueRest> epersonLastName = metadataRest.getMap().get(\"eperson.lastname\");\n+            if (epersonFirstName == null || epersonLastName == null ||\n+                epersonFirstName.isEmpty() || epersonLastName.isEmpty()) {\n+                throw new DSpaceBadRequestException(\"The eperson.firstname and eperson.lastname values need to be \" +\n+                                                    \"filled in\");", "originalCommit": "891ab3f3e261e8a78321091b8835fab413937899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNjQxMQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446016411", "bodyText": "This is not defined in the contract, 422 is fine for me. We'll update this in the code", "author": "benbosman", "createdAt": "2020-06-26T07:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3NDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3OTg5Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445579896", "bodyText": "small thing but I would appreciate if we can use the constant here", "author": "abollini", "createdAt": "2020-06-25T13:59:01Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestControllerIT.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestControllerIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void registrationFlowTest() throws Exception {\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+\n+        String newEmail = \"newEPersonTest@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertTrue(registrationDataList.size() == 2);\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) ||\n+                       StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        newEmail = \"newEPersonTestTwo@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().is(401));", "originalCommit": "891ab3f3e261e8a78321091b8835fab413937899", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNjk1OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446016959", "bodyText": "This code has been moved, but can indeed be adjusted", "author": "benbosman", "createdAt": "2020-06-26T07:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU3OTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyOTk0Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445729943", "bodyText": "this should go in a finally to be sure that it is executed also in case of test failure, otherwise a failure in this test due to a refactoring would produce a lot of unrelated failure due to a dirty testenv", "author": "abollini", "createdAt": "2020-06-25T17:43:23Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzI4NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017284", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyOTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDIyMA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730220", "bodyText": "mote in the finally part please", "author": "abollini", "createdAt": "2020-06-25T17:43:48Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzM1Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017353", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDU3Mg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730572", "bodyText": "put in the finally block", "author": "abollini", "createdAt": "2020-06-25T17:44:25Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzM5NQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017395", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDc4OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730788", "bodyText": "put in the finally block", "author": "abollini", "createdAt": "2020-06-25T17:44:47Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzQzNQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017435", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDk3NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445730974", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:45:05Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzQ2Nw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017467", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMDk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTMyMg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731322", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:45:36Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzUwNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017504", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:34:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTQ4Ng==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731486", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:45:52Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzU0MQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017541", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTYxMw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731613", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:46:07Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzU5Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017593", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTcyNQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731725", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:46:17Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzYxOA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017618", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTgwNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731804", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:46:25Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutPasswordProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzcxOA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017718", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg5MQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445731891", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:46:34Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutPasswordProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithWrongToken() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newEmail = \"new-email@fake-email.com\";\n+\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String forgotPasswordToken = registrationDataService.findByEmail(context, eperson.getEmail()).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", forgotPasswordToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, forgotPasswordToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, forgotPasswordToken);\n+        context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzc4Mw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017783", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:35:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjEyNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732124", "bodyText": "more to the finally block", "author": "abollini", "createdAt": "2020-06-25T17:47:03Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/EPersonRestRepositoryIT.java", "diffHunk": "@@ -1793,6 +1851,797 @@ public void getDirectEpersonGroups() throws Exception {\n \n     }\n \n+    @Test\n+    public void patchReplacePasswordWithToken() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isOk());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertNotEquals(oldPassword, newPasswordHash);\n+        assertTrue(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+\n+        assertNull(registrationDataService.findByToken(context, tokenForEPerson));\n+    }\n+\n+\n+    @Test\n+    public void patchReplacePasswordWithRandomTokenPatchFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", \"RandomToken\"))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(registrationDataService.findByEmail(context, ePerson.getEmail()).getToken(), tokenForEPerson);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplacePasswordWithOtherUserTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+\n+        EPerson ePersonTwo = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"Smith\", \"Donald\")\n+                                        .withEmail(\"donaldSmith@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        accountService.sendRegistrationInfo(context, ePersonTwo.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        String tokenForEPersonTwo = registrationDataService.findByEmail(context, ePersonTwo.getEmail()).getToken();\n+\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPersonTwo))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        registrationDataService.deleteByToken(context, tokenForEPersonTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void patchReplaceEmailWithTokenFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        String originalEmail = \"johndoe@fake-email.com\";\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(originalEmail)\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newEmail = \"johnyandmaria@fake-email.com\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/email\", newEmail);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String tokenForEPerson = registrationDataService.findByEmail(context, ePerson.getEmail()).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", tokenForEPerson))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertEquals(oldPassword.getHashString(),newPasswordHash.getHashString());\n+        assertNotNull(registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        assertEquals(ePerson.getEmail(), originalEmail);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, tokenForEPerson);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void registerNewAccountPatchUpdatePasswordRandomUserUuidFail() throws Exception {\n+        context.turnOffAuthorisationSystem();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                            .contentType(MediaType.APPLICATION_JSON)\n+                            .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+\n+        EPerson ePerson = EPersonBuilder.createEPerson(context)\n+                                        .withNameInMetadata(\"John\", \"Doe\")\n+                                        .withEmail(\"Johndoe@fake-email.com\")\n+                                        .withPassword(password)\n+                                        .build();\n+\n+        String newPassword = \"newpassword\";\n+\n+        context.restoreAuthSystemState();\n+\n+        List<Operation> ops = new ArrayList<Operation>();\n+        ReplaceOperation replaceOperation = new ReplaceOperation(\"/password\", newPassword);\n+        ops.add(replaceOperation);\n+        String patchBody = getPatchContent(ops);\n+        accountService.sendRegistrationInfo(context, ePerson.getEmail());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+        PasswordHash oldPassword = ePersonService.getPasswordHash(ePerson);\n+        // updates password\n+        getClient().perform(patch(\"/api/eperson/epersons/\" + ePerson.getID())\n+                                     .content(patchBody)\n+                                     .contentType(MediaType.APPLICATION_JSON_PATCH_JSON)\n+                                     .param(\"token\", newRegisterToken))\n+                        .andExpect(status().isUnauthorized());\n+\n+        PasswordHash newPasswordHash = ePersonService.getPasswordHash(ePerson);\n+        assertTrue(StringUtils.equalsIgnoreCase(oldPassword.getHashString(),newPasswordHash.getHashString()));\n+        assertFalse(registrationDataService.findByEmail(context, ePerson.getEmail()) == null);\n+        assertFalse(registrationDataService.findByEmail(context, newRegisterEmail) == null);\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.delete(context, registrationDataService.findByEmail(context, ePerson.getEmail()));\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                    .param(\"token\", newRegisterToken)\n+                                    .content(mapper.writeValueAsBytes(ePersonRest))\n+                                    .contentType(MediaType.APPLICATION_JSON))\n+                                      .andExpect(status().isCreated())\n+                                      .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                hasJsonPath(\"$.uuid\", not(empty())),\n+                                // is it what you expect? EPerson.getName() returns the email...\n+                                //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                    matchMetadata(\"eperson.firstname\", \"John\"),\n+                                    matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                )))))\n+                                .andDo(result -> idRef\n+                                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                            .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();\n+        } finally {\n+            EPersonBuilder.deleteEPerson(idRef.get());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithTwoTokensDifferentEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+        String newRegisterEmailTwo = \"new-register-two@fake-email.com\";\n+        RegistrationRest registrationRestTwo = new RegistrationRest();\n+        registrationRestTwo.setEmail(newRegisterEmailTwo);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRestTwo)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterTokenTwo = registrationDataService.findByEmail(context, newRegisterEmailTwo).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmailTwo);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmailTwo);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterTokenTwo));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        registrationDataService.deleteByToken(context, newRegisterTokenTwo);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithRandomTokenWithEmailProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", \"randomToken\")\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailAndSelfRegisteredFalseProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(false);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                                           .param(\"token\", newRegisterToken)\n+                                                           .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                           .contentType(MediaType.APPLICATION_JSON))\n+                                              .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutLastNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutFirstNameProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithoutPasswordProperty() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", newRegisterToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newRegisterEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, newRegisterToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithWrongToken() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String newEmail = \"new-email@fake-email.com\";\n+\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String forgotPasswordToken = registrationDataService.findByEmail(context, eperson.getEmail()).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+        ePersonRest.setSelfRegistered(true);\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        getClient().perform(post(\"/api/eperson/epersons\")\n+                                     .param(\"token\", forgotPasswordToken)\n+                                     .content(mapper.writeValueAsBytes(ePersonRest))\n+                                     .contentType(MediaType.APPLICATION_JSON))\n+                        .andExpect(status().isBadRequest());\n+\n+        EPerson createdEPerson = ePersonService.findByEmail(context, newEmail);\n+        assertNull(createdEPerson);\n+        assertNotNull(registrationDataService.findByToken(context, forgotPasswordToken));\n+\n+        context.turnOffAuthorisationSystem();\n+        registrationDataService.deleteByToken(context, forgotPasswordToken);\n+        context.restoreAuthSystemState();\n+\n+    }\n+\n+    @Test\n+    public void postEPersonWithTokenWithEmailPropertyAnonUser() throws Exception {\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String newRegisterEmail = \"new-register@fake-email.com\";\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(newRegisterEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .contentType(MediaType.APPLICATION_JSON)\n+                                .content(mapper.writeValueAsBytes(registrationRest)))\n+                   .andExpect(status().isCreated());\n+        String newRegisterToken = registrationDataService.findByEmail(context, newRegisterEmail).getToken();\n+\n+\n+        EPersonRest ePersonRest = new EPersonRest();\n+        MetadataRest metadataRest = new MetadataRest();\n+        ePersonRest.setEmail(newRegisterEmail);\n+        ePersonRest.setCanLogIn(true);\n+        MetadataValueRest surname = new MetadataValueRest();\n+        surname.setValue(\"Doe\");\n+        metadataRest.put(\"eperson.lastname\", surname);\n+        MetadataValueRest firstname = new MetadataValueRest();\n+        firstname.setValue(\"John\");\n+        metadataRest.put(\"eperson.firstname\", firstname);\n+        ePersonRest.setMetadata(metadataRest);\n+        ePersonRest.setPassword(\"somePassword\");\n+\n+        mapper.setAnnotationIntrospector(new IgnoreJacksonWriteOnlyAccess());\n+\n+        AtomicReference<UUID> idRef = new AtomicReference<UUID>();\n+\n+        try {\n+            getClient().perform(post(\"/api/eperson/epersons\")\n+                                                               .param(\"token\", newRegisterToken)\n+                                                               .content(mapper.writeValueAsBytes(ePersonRest))\n+                                                               .contentType(MediaType.APPLICATION_JSON))\n+                                                  .andExpect(status().isCreated())\n+                                                  .andExpect(jsonPath(\"$\", Matchers.allOf(\n+                                                      hasJsonPath(\"$.uuid\", not(empty())),\n+                                                      // is it what you expect? EPerson.getName() returns the email...\n+                                                      //hasJsonPath(\"$.name\", is(\"Doe John\")),\n+                                                      hasJsonPath(\"$.email\", is(newRegisterEmail)),\n+                                                      hasJsonPath(\"$.type\", is(\"eperson\")),\n+                                                      hasJsonPath(\"$._links.self.href\", not(empty())),\n+                                                      hasJsonPath(\"$.metadata\", Matchers.allOf(\n+                                                          matchMetadata(\"eperson.firstname\", \"John\"),\n+                                                          matchMetadata(\"eperson.lastname\", \"Doe\")\n+                                                      ))))).andDo(result -> idRef\n+                    .set(UUID.fromString(read(result.getResponse().getContentAsString(), \"$.id\"))));\n+\n+            String epersonUuid = String.valueOf(idRef.get());\n+            EPerson createdEPerson = ePersonService.find(context, UUID.fromString(epersonUuid));\n+            assertTrue(ePersonService.checkPassword(context, createdEPerson, \"somePassword\"));\n+            assertNull(registrationDataService.findByToken(context, newRegisterToken));\n+\n+            context.turnOffAuthorisationSystem();\n+            registrationDataService.deleteByToken(context, newRegisterToken);\n+            context.restoreAuthSystemState();", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzgzMg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017832", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjI4OQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732289", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:47:21Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzg2Mg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017862", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjMzNw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732337", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:47:26Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNzkwNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446017904", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjc4NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732784", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:48:20Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+    }\n+\n+    @Test\n+    public void findByTokenNotExistingTokenTest() throws Exception {\n+        getClient().perform(get(\"/api/eperson/registration/search/findByToken\")\n+                                .param(\"token\", \"ThisTokenDoesNotExist\"))\n+                   .andExpect(status().isNotFound());\n+    }\n+\n+    private void createTokenForEmail(String email) throws Exception {\n+        List<RegistrationData> registrationDatas;\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(email);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+    }\n+\n+    @Test\n+    public void registrationFlowTest() throws Exception {\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+\n+        String newEmail = \"newEPersonTest@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertTrue(registrationDataList.size() == 2);\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) ||\n+                       StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        newEmail = \"newEPersonTestTwo@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().is(401));\n+\n+        assertEquals(2, registrationDataList.size());\n+        assertTrue(!StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) &&\n+                       !StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+\n+        Iterator<RegistrationData> iterator = registrationDataList.iterator();\n+        while (iterator.hasNext()) {\n+            RegistrationData registrationData = iterator.next();\n+            registrationDataDAO.delete(context, registrationData);\n+        }", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxODI4NA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446018284", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjkwNg==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445732906", "bodyText": "put in a finally block", "author": "abollini", "createdAt": "2020-06-25T17:48:33Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/RegistrationRestRepositoryIT.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dspace.app.rest.matcher.RegistrationMatcher;\n+import org.dspace.app.rest.model.RegistrationRest;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.eperson.RegistrationData;\n+import org.dspace.eperson.dao.RegistrationDataDAO;\n+import org.dspace.services.ConfigurationService;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class RegistrationRestRepositoryIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private RegistrationDataDAO registrationDataDAO;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Test\n+    public void findByTokenTestExistingUserTest() throws Exception {\n+        String email = eperson.getEmail();\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, eperson.getID()))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+        email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+\n+    }\n+\n+    @Test\n+    public void findByTokenTestNewUserTest() throws Exception {\n+        String email = \"newUser@testnewuser.com\";\n+        createTokenForEmail(email);\n+        RegistrationData registrationData = registrationDataDAO.findByEmail(context, email);\n+\n+        getClient().perform(get(\"/api/eperson/registrations/search/findByToken\")\n+                                .param(\"token\", registrationData.getToken()))\n+                   .andExpect(status().isOk())\n+                   .andExpect(\n+                       jsonPath(\"$\", Matchers.is(RegistrationMatcher.matchRegistration(email, null))));\n+\n+        registrationDataDAO.delete(context, registrationData);\n+    }\n+\n+    @Test\n+    public void findByTokenNotExistingTokenTest() throws Exception {\n+        getClient().perform(get(\"/api/eperson/registration/search/findByToken\")\n+                                .param(\"token\", \"ThisTokenDoesNotExist\"))\n+                   .andExpect(status().isNotFound());\n+    }\n+\n+    private void createTokenForEmail(String email) throws Exception {\n+        List<RegistrationData> registrationDatas;\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(email);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+    }\n+\n+    @Test\n+    public void registrationFlowTest() throws Exception {\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+\n+        String newEmail = \"newEPersonTest@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertTrue(registrationDataList.size() == 2);\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) ||\n+                       StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        newEmail = \"newEPersonTestTwo@gmail.com\";\n+        registrationRest.setEmail(newEmail);\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().is(401));\n+\n+        assertEquals(2, registrationDataList.size());\n+        assertTrue(!StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), newEmail) &&\n+                       !StringUtils.equalsIgnoreCase(registrationDataList.get(1).getEmail(), newEmail));\n+\n+        Iterator<RegistrationData> iterator = registrationDataList.iterator();\n+        while (iterator.hasNext()) {\n+            RegistrationData registrationData = iterator.next();\n+            registrationDataDAO.delete(context, registrationData);\n+        }\n+    }\n+\n+    @Test\n+    public void forgotPasswordTest() throws Exception {\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        List<RegistrationData> registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(0, registrationDataList.size());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        RegistrationRest registrationRest = new RegistrationRest();\n+        registrationRest.setEmail(eperson.getEmail());\n+        getClient().perform(post(\"/api/eperson/registrations\")\n+                                .content(mapper.writeValueAsBytes(registrationRest))\n+                                .contentType(contentType))\n+                   .andExpect(status().isCreated());\n+        registrationDataList = registrationDataDAO.findAll(context, RegistrationData.class);\n+        assertEquals(1, registrationDataList.size());\n+        assertTrue(StringUtils.equalsIgnoreCase(registrationDataList.get(0).getEmail(), eperson.getEmail()));\n+        Iterator<RegistrationData> iterator = registrationDataList.iterator();\n+        while (iterator.hasNext()) {\n+            RegistrationData registrationData = iterator.next();\n+            registrationDataDAO.delete(context, registrationData);\n+        }", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxODMxNw==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446018317", "bodyText": "We'll move this to a finally", "author": "benbosman", "createdAt": "2020-06-26T07:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMjkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczNDQzNA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r445734434", "bodyText": "I don't think that this is sufficient to get shibboleth enabled as the plugins were already read and so cached", "author": "abollini", "createdAt": "2020-06-25T17:51:13Z", "path": "dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/EPersonRegistrationFeatureIT.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * The contents of this file are subject to the license and copyright\n+ * detailed in the LICENSE and NOTICE files at the root of the source\n+ * tree and available online at\n+ *\n+ * http://www.dspace.org/license/\n+ */\n+package org.dspace.app.rest.authorization;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.dspace.app.rest.authorization.impl.EPersonRegistrationFeature;\n+import org.dspace.app.rest.converter.ConverterService;\n+import org.dspace.app.rest.converter.SiteConverter;\n+import org.dspace.app.rest.model.SiteRest;\n+import org.dspace.app.rest.projection.Projection;\n+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;\n+import org.dspace.app.rest.utils.Utils;\n+import org.dspace.content.Site;\n+import org.dspace.content.service.SiteService;\n+import org.dspace.services.ConfigurationService;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+public class EPersonRegistrationFeatureIT extends AbstractControllerIntegrationTest {\n+\n+    @Autowired\n+    private AuthorizationFeatureService authorizationFeatureService;\n+\n+    @Autowired\n+    private ConverterService converterService;\n+\n+    @Autowired\n+    private ConfigurationService configurationService;\n+\n+    @Autowired\n+    private SiteService siteService;\n+\n+    @Autowired\n+    private SiteConverter siteConverter;\n+\n+    @Autowired\n+    private Utils utils;\n+\n+    private AuthorizationFeature epersonRegistrationFeature;\n+\n+    public static final String[] SHIB_ONLY = {\"org.dspace.authenticate.ShibAuthentication\"};\n+\n+    @Override\n+    @Before\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        epersonRegistrationFeature = authorizationFeatureService.find(EPersonRegistrationFeature.NAME);\n+    }\n+\n+    @Test\n+    public void userRegistrationEnabledSuccessTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+    }\n+\n+    @Test\n+    public void userRegistrationDisabledUnAuthorizedTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+        configurationService.setProperty(\"user.registration\", false);\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isNoContent());\n+\n+    }\n+\n+\n+    @Test\n+    public void userRegistrationEnabledShibTest() throws Exception {\n+\n+        Site site = siteService.findSite(context);\n+        SiteRest SiteRest = siteConverter.convert(site, Projection.DEFAULT);\n+        String siteUri = utils.linkToSingleResource(SiteRest, \"self\").getHref();\n+\n+\n+        getClient().perform(get(\"/api/authz/authorizations/search/objectAndFeature\")\n+                                          .param(\"uri\", siteUri)\n+                                          .param(\"feature\", epersonRegistrationFeature.getName()))\n+                             .andExpect(status().isOk());\n+\n+        //Enable Shibboleth and password login\n+        configurationService.setProperty(\"plugin.sequence.org.dspace.authenticate.AuthenticationMethod\", SHIB_ONLY);", "originalCommit": "32a03eed36a9fbe08e44d0bc6a945a4b5853a8d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxOTY2NQ==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r446019665", "bodyText": "If you compare the check on top and below, it does impact the behavior.\nhttps://github.com/DSpace/DSpace/blob/master/dspace-api/src/main/java/org/dspace/authenticate/AuthenticationServiceImpl.java#L70 doesn't seem to be cached either", "author": "benbosman", "createdAt": "2020-06-26T07:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczNDQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1MjM4OA==", "url": "https://github.com/DSpace/DSpace/pull/2763#discussion_r447052388", "bodyText": "you are right. Looking to the org.dspace.core.LegacyPluginServiceImpl#getPluginSequence it seems that there is a bug or at least the comments don't align with the implementation as there is no cache for the plugins sequence... cache that is indeed here for the other plugin types. I'm going to create a ticket for that but it is not related to this PR, so I'm flagging this thread as solved", "author": "abollini", "createdAt": "2020-06-29T15:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczNDQzNA=="}], "type": "inlineReview"}, {"oid": "0555644c9a8d1c15bbe71afb13068ba632eb6f9d", "url": "https://github.com/DSpace/DSpace/commit/0555644c9a8d1c15bbe71afb13068ba632eb6f9d", "message": "[Task 71627] addressed feedback on the new registration functionaliity", "committedDate": "2020-06-30T06:30:01Z", "type": "commit"}, {"oid": "2a6731297cc8c7c7f1387cf214800e42a9672071", "url": "https://github.com/DSpace/DSpace/commit/2a6731297cc8c7c7f1387cf214800e42a9672071", "message": "Fixed LGTM issue with an error String", "committedDate": "2020-06-30T08:27:47Z", "type": "commit"}]}