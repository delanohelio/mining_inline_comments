{"pr_number": 13136, "pr_title": "[FLINK-18878][python] Support dependency management for Python Stream\u2026", "pr_createdAt": "2020-08-13T07:13:15Z", "pr_url": "https://github.com/apache/flink/pull/13136", "timeline": [{"oid": "6098b6b0563eded5c97787f55094467b82a88593", "url": "https://github.com/apache/flink/commit/6098b6b0563eded5c97787f55094467b82a88593", "message": "[FLINK-18878][python] Support dependency management for Python StreamExecutionEnvironment.", "committedDate": "2020-08-13T06:45:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc3NjQzNw==", "url": "https://github.com/apache/flink/pull/13136#discussion_r469776437", "bodyText": "We don't need this config. Use the PythonConfig in DataStreamPythonStatelessFunctionOperator directly.", "author": "hequn8128", "createdAt": "2020-08-13T08:15:24Z", "path": "flink-python/src/main/java/org/apache/flink/datastream/runtime/operators/python/DataStreamPythonStatelessFunctionOperator.java", "diffHunk": "@@ -75,6 +75,8 @@\n \n \tprotected transient StreamRecordCollector streamRecordCollector;\n \n+\tprivate Configuration mergedEnvConfig;", "originalCommit": "6098b6b0563eded5c97787f55094467b82a88593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc4NjA5OQ==", "url": "https://github.com/apache/flink/pull/13136#discussion_r469786099", "bodyText": "Another method can be extracted to avoid code duplication.", "author": "hequn8128", "createdAt": "2020-08-13T08:32:06Z", "path": "flink-python/src/main/java/org/apache/flink/python/util/PythonConfigUtil.java", "diffHunk": "@@ -64,4 +82,103 @@ public static Configuration getEnvironmentConfig(StreamExecutionEnvironment env)\n \t\tConfiguration envConfiguration = (Configuration) getConfigurationMethod.invoke(env);\n \t\treturn envConfiguration;\n \t}\n+\n+\t/**\n+\t * Configure the {@link DataStreamPythonStatelessFunctionOperator} to be chained with the upstream/downstream\n+\t * operator by setting their parallelism, slot sharing group, co-location group to be the same, and applying a\n+\t * {@link ForwardPartitioner}.\n+\t * 1. operator with name \"_keyed_stream_values_operator\" should align with its downstream operator.\n+\t * 2. operator with name \"_stream_key_by_map_operator\" should align with its upstream operator.\n+\t */\n+\tprivate static void alignStreamNode(StreamNode streamNode, StreamGraph streamGraph) {\n+\t\tif (streamNode.getOperatorName().equals(KEYED_STREAM_VALUE_OPERATOR_NAME)) {\n+\t\t\tStreamEdge downStreamEdge = streamNode.getOutEdges().get(0);\n+\t\t\tStreamNode downStreamNode = streamGraph.getStreamNode(downStreamEdge.getTargetId());\n+\t\t\tdownStreamEdge.setPartitioner(new ForwardPartitioner());\n+\t\t\tstreamNode.setParallelism(downStreamNode.getParallelism());\n+\t\t\tstreamNode.setCoLocationGroup(downStreamNode.getCoLocationGroup());\n+\t\t\tstreamNode.setSlotSharingGroup(downStreamNode.getSlotSharingGroup());\n+\t\t}\n+\n+\t\tif (streamNode.getOperatorName().equals(STREAM_KEY_BY_MAP_OPERATOR_NAME)) {\n+\t\t\tStreamEdge upStreamEdge = streamNode.getInEdges().get(0);\n+\t\t\tStreamNode upStreamNode = streamGraph.getStreamNode(upStreamEdge.getSourceId());\n+\t\t\tupStreamEdge.setPartitioner(new ForwardPartitioner<>());\n+\t\t\tstreamNode.setParallelism(upStreamNode.getParallelism());\n+\t\t\tstreamNode.setSlotSharingGroup(upStreamNode.getSlotSharingGroup());\n+\t\t\tstreamNode.setCoLocationGroup(upStreamNode.getCoLocationGroup());", "originalCommit": "6098b6b0563eded5c97787f55094467b82a88593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NDk5OA==", "url": "https://github.com/apache/flink/pull/13136#discussion_r469794998", "bodyText": "These methods can be replaced by:\n\tprivate static PythonConfig generateNewPythonConfig(Configuration oldConfig, Configuration newConfig) {\n\t\tnewConfig.clone().addAll(oldConfig);\n\t\treturn new PythonConfig(oldConfig);\n\t}", "author": "hequn8128", "createdAt": "2020-08-13T08:45:31Z", "path": "flink-python/src/main/java/org/apache/flink/python/util/PythonConfigUtil.java", "diffHunk": "@@ -64,4 +82,103 @@ public static Configuration getEnvironmentConfig(StreamExecutionEnvironment env)\n \t\tConfiguration envConfiguration = (Configuration) getConfigurationMethod.invoke(env);\n \t\treturn envConfiguration;\n \t}\n+\n+\t/**\n+\t * Configure the {@link DataStreamPythonStatelessFunctionOperator} to be chained with the upstream/downstream\n+\t * operator by setting their parallelism, slot sharing group, co-location group to be the same, and applying a\n+\t * {@link ForwardPartitioner}.\n+\t * 1. operator with name \"_keyed_stream_values_operator\" should align with its downstream operator.\n+\t * 2. operator with name \"_stream_key_by_map_operator\" should align with its upstream operator.\n+\t */\n+\tprivate static void alignStreamNode(StreamNode streamNode, StreamGraph streamGraph) {\n+\t\tif (streamNode.getOperatorName().equals(KEYED_STREAM_VALUE_OPERATOR_NAME)) {\n+\t\t\tStreamEdge downStreamEdge = streamNode.getOutEdges().get(0);\n+\t\t\tStreamNode downStreamNode = streamGraph.getStreamNode(downStreamEdge.getTargetId());\n+\t\t\tdownStreamEdge.setPartitioner(new ForwardPartitioner());\n+\t\t\tstreamNode.setParallelism(downStreamNode.getParallelism());\n+\t\t\tstreamNode.setCoLocationGroup(downStreamNode.getCoLocationGroup());\n+\t\t\tstreamNode.setSlotSharingGroup(downStreamNode.getSlotSharingGroup());\n+\t\t}\n+\n+\t\tif (streamNode.getOperatorName().equals(STREAM_KEY_BY_MAP_OPERATOR_NAME)) {\n+\t\t\tStreamEdge upStreamEdge = streamNode.getInEdges().get(0);\n+\t\t\tStreamNode upStreamNode = streamGraph.getStreamNode(upStreamEdge.getSourceId());\n+\t\t\tupStreamEdge.setPartitioner(new ForwardPartitioner<>());\n+\t\t\tstreamNode.setParallelism(upStreamNode.getParallelism());\n+\t\t\tstreamNode.setSlotSharingGroup(upStreamNode.getSlotSharingGroup());\n+\t\t\tstreamNode.setCoLocationGroup(upStreamNode.getCoLocationGroup());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generate a {@link StreamGraph} for transformations maintained by current {@link StreamExecutionEnvironment}, and\n+\t * reset the merged env configurations with dependencies to every {@link DataStreamPythonStatelessFunctionOperator}.\n+\t * It is an idempotent operation that can be call multiple times. Remember that only when need to execute the\n+\t * StreamGraph can we set the clearTransformations to be True.\n+\t */\n+\tpublic static StreamGraph generateStreamGraphWithDependencies(\n+\t\tStreamExecutionEnvironment env, boolean clearTransformations) throws IllegalAccessException,\n+\t\tNoSuchMethodException, InvocationTargetException {\n+\n+\t\tConfiguration mergedConfig = getEnvConfigWithDependencies(env);\n+\t\tStreamGraph streamGraph = env.getStreamGraph(StreamExecutionEnvironment.DEFAULT_JOB_NAME, clearTransformations);\n+\t\tCollection<StreamNode> streamNodes = streamGraph.getStreamNodes();\n+\t\tfor (StreamNode streamNode : streamNodes) {\n+\n+\t\t\talignStreamNode(streamNode, streamGraph);\n+\n+\t\t\tStreamOperatorFactory streamOperatorFactory = streamNode.getOperatorFactory();\n+\t\t\tif (streamOperatorFactory instanceof SimpleOperatorFactory) {\n+\t\t\t\tStreamOperator streamOperator = ((SimpleOperatorFactory) streamOperatorFactory).getOperator();\n+\t\t\t\tif (streamOperator instanceof DataStreamPythonStatelessFunctionOperator) {\n+\t\t\t\t\tDataStreamPythonStatelessFunctionOperator dataStreamPythonStatelessFunctionOperator =\n+\t\t\t\t\t\t(DataStreamPythonStatelessFunctionOperator) streamOperator;\n+\t\t\t\t\tConfiguration oldConfig = dataStreamPythonStatelessFunctionOperator.getMergedEnvConfig();\n+\t\t\t\t\tdataStreamPythonStatelessFunctionOperator.setPythonConfig(generateNewPythonConfig(oldConfig,\n+\t\t\t\t\t\tmergedConfig));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn streamGraph;\n+\t}\n+\n+\t/**\n+\t * Generator a new {@link  PythonConfig} with the combined config which is derived from oldConfig.\n+\t */\n+\tprivate static PythonConfig generateNewPythonConfig(Configuration oldConfig, Configuration newConfig) {\n+\t\tsetIfNotExist(PythonOptions.MAX_BUNDLE_SIZE, oldConfig, newConfig);\n+\t\tsetIfNotExist(PythonOptions.MAX_BUNDLE_TIME_MILLS, oldConfig, newConfig);\n+\t\tsetIfNotExist(PythonOptions.MAX_BUNDLE_TIME_MILLS, oldConfig, newConfig);\n+\t\tsetIfNotExist(PythonOptions.PYTHON_FRAMEWORK_MEMORY_SIZE, oldConfig, newConfig);\n+\t\tsetIfNotExist(PythonOptions.PYTHON_DATA_BUFFER_MEMORY_SIZE, oldConfig, newConfig);\n+\t\tsetIfNotExist(PythonOptions.PYTHON_EXECUTABLE, oldConfig, newConfig);\n+\t\tsetIfNotExist(PythonOptions.PYTHON_METRIC_ENABLED, oldConfig, newConfig);\n+\t\tsetIfNotExist(PythonOptions.USE_MANAGED_MEMORY, oldConfig, newConfig);\n+\n+\t\tcombineConfigValue(PythonDependencyUtils.PYTHON_FILES, oldConfig, newConfig);\n+\t\tcombineConfigValue(PythonDependencyUtils.PYTHON_REQUIREMENTS_FILE, oldConfig, newConfig);\n+\t\tcombineConfigValue(PythonDependencyUtils.PYTHON_ARCHIVES, oldConfig, newConfig);\n+\n+\t\treturn new PythonConfig(oldConfig);\n+\t}\n+\n+\t/**\n+\t * Make sure new configuration not overriding the previously configured value. For example, the MAX_BUNDLE_SIZE of\n+\t * {@link org.apache.flink.datastream.runtime.operators.python.DataStreamPythonReduceFunctionOperator} is\n+\t * pre-configured to be 1, we must not to change it.\n+\t */\n+\tprivate static void setIfNotExist(ConfigOption configOption, Configuration oldConfig, Configuration newConfig) {\n+\t\tif (!oldConfig.containsKey(configOption.key())) {\n+\t\t\toldConfig.set(configOption, newConfig.get(configOption));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Dependency file information maintained by a Map in old config can be combined with new config.\n+\t */\n+\tprivate static void combineConfigValue(ConfigOption<Map<String, String>> configOption, Configuration oldConfig, Configuration newConfig) {\n+\t\tMap<String, String> oldConfigValue = oldConfig.getOptional(configOption).orElse(new HashMap<>());\n+\t\toldConfigValue.putAll(newConfig.getOptional(configOption).orElse(new HashMap<>()));\n+\t\toldConfig.set(configOption, oldConfigValue);\n+\t}", "originalCommit": "6098b6b0563eded5c97787f55094467b82a88593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTUwNQ==", "url": "https://github.com/apache/flink/pull/13136#discussion_r469795505", "bodyText": "Put the set method close to the corresponding get method.", "author": "hequn8128", "createdAt": "2020-08-13T08:46:24Z", "path": "flink-python/src/main/java/org/apache/flink/streaming/api/operators/python/AbstractPythonFunctionOperator.java", "diffHunk": "@@ -240,6 +240,14 @@ public void processWatermark(Watermark mark) throws Exception {\n \t\t}\n \t}\n \n+\t/**\n+\t * Reset the {@link PythonConfig} if needed.\n+\t * */\n+\t@Internal\n+\tpublic void setPythonConfig(PythonConfig pythonConfig) {", "originalCommit": "6098b6b0563eded5c97787f55094467b82a88593", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ccb177399810fc93aaa9b393e092245deaf6789e", "url": "https://github.com/apache/flink/commit/ccb177399810fc93aaa9b393e092245deaf6789e", "message": "[FLINK-18878][python] Simplified dependencies management and PythonConfig update.", "committedDate": "2020-08-13T10:03:29Z", "type": "commit"}]}