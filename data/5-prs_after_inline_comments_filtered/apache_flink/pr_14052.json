{"pr_number": 14052, "pr_title": "[FLINK-20030][network] Rewrite RemoteInputChannel#getInflightBuffersUnsafe to use sequence numbers", "pr_createdAt": "2020-11-12T16:45:20Z", "pr_url": "https://github.com/apache/flink/pull/14052", "timeline": [{"oid": "0d6c68e97c1c6d23ca2870932db0cdfeddebcafd", "url": "https://github.com/apache/flink/commit/0d6c68e97c1c6d23ca2870932db0cdfeddebcafd", "message": "[FLINK-20030][network] Introduce lastBarrierId in RemoteInputChannel\n\nThis allows to prevent overwriting of lastBarrierSqn from\nBarrierController when processing a newer barrier.", "committedDate": "2020-11-12T17:05:16Z", "type": "forcePushed"}, {"oid": "9f30c9730919038a0247cd4b7a2929df05ee669f", "url": "https://github.com/apache/flink/commit/9f30c9730919038a0247cd4b7a2929df05ee669f", "message": "[FLINK-20030][network] Introduce lastBarrierId in RemoteInputChannel\n\nThis allows to prevent overwriting of lastBarrierSqn from\nBarrierController when processing a newer barrier.", "committedDate": "2020-11-13T08:28:10Z", "type": "forcePushed"}, {"oid": "9b6d028dde24fc8fd21e3a3542756c813fca9c13", "url": "https://github.com/apache/flink/commit/9b6d028dde24fc8fd21e3a3542756c813fca9c13", "message": "[FLINK-20030][network] Introduce lastBarrierId in RemoteInputChannel\n\nThis allows to prevent overwriting of lastBarrierSqn from\nBarrierController when processing a newer barrier.", "committedDate": "2020-11-13T15:20:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NTI4NQ==", "url": "https://github.com/apache/flink/pull/14052#discussion_r523995285", "bodyText": "You wrote in the PR description that this PR will also avoid numBuffersOvertaken being overwritten, but I don't see a specific change in that regard here. I was assuming that one of the earlier PRs already helped with that by fixing checkForBarrier.", "author": "AHeise", "createdAt": "2020-11-16T09:05:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -481,7 +489,7 @@ private boolean addPriorityBuffer(SequenceBuffer sequenceBuffer) throws IOExcept\n \t\tif (channelStatePersister.checkForBarrier(sequenceBuffer.buffer)) {\n \t\t\t// checkpoint was not yet started by task thread,\n \t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n-\t\t\tnumBuffersOvertaken = receivedBuffers.getNumUnprioritizedElements();\n+\t\t\tlastOvertakenSequenceNumber = sequenceBuffer.sequenceNumber;", "originalCommit": "de43e752d21e95496aab69e13d9c007fa29d5b2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDMzMTAwNA==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524331004", "bodyText": "This is addressed in the next commit by adding lastBarrierId and checking it.", "author": "rkhachatryan", "createdAt": "2020-11-16T14:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg==", "url": "https://github.com/apache/flink/pull/14052#discussion_r523997432", "bodyText": "It should be possible to avoid iterating over all buffers by aborting on the first !shouldBeSpilled.", "author": "AHeise", "createdAt": "2020-11-16T09:07:04Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {", "originalCommit": "de43e752d21e95496aab69e13d9c007fa29d5b2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0NjI3Mg==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524346272", "bodyText": "I think it wouldn't work because of a possible sequence number overflow before overtaking.", "author": "rkhachatryan", "createdAt": "2020-11-16T15:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NDQyNg==", "url": "https://github.com/apache/flink/pull/14052#discussion_r525864426", "bodyText": "Is there a scenario where shouldBeSpilled returns [true, false, true] for any given buffer sequence? I don't see it happening even with overflow.", "author": "AHeise", "createdAt": "2020-11-18T07:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjIzMzU2NA==", "url": "https://github.com/apache/flink/pull/14052#discussion_r526233564", "bodyText": "I think you're right, I'll change it.", "author": "rkhachatryan", "createdAt": "2020-11-18T16:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzk5NzQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524002910", "bodyText": "Do we need to use similar code later for timeout at a different place? If so, I'd pull it in some Util (even flink-core?).\nAlternatively, we could also just switch to having long sequence numbers. I was originally writing this overflow check, but I'm now thinking that it might be easier to just add these 4 bytes to each buffer header.\nI guess the question is how often we actually reach Int.MAX in one execution attempt on one channel. With a 32kb buffer, it's ~70 Tb data on that channel, so rather unlikely in one attempt. On the other hand, if we ever persist the buffer id (for incremental state channel), we might reach it eventually.", "author": "AHeise", "createdAt": "2020-11-16T09:12:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -506,43 +514,75 @@ public void checkpointStarted(CheckpointBarrier barrier) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.startPersisting(\n \t\t\t\tbarrier.getId(),\n-\t\t\t\tgetInflightBuffers(numBuffersOvertaken == ALL ? receivedBuffers.getNumUnprioritizedElements() : numBuffersOvertaken));\n+\t\t\t\tgetInflightBuffers());\n \t\t}\n \t}\n \n \tpublic void checkpointStopped(long checkpointId) {\n \t\tsynchronized (receivedBuffers) {\n \t\t\tchannelStatePersister.stopPersisting(checkpointId);\n-\t\t\tnumBuffersOvertaken = ALL;\n+\t\t\tlastOvertakenSequenceNumber = null;\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tList<Buffer> getInflightBuffers() {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn getInflightBuffersUnsafe();\n \t\t}\n \t}\n \n \t/**\n \t * Returns a list of buffers, checking the first n non-priority buffers, and skipping all events.\n \t */\n-\tprivate List<Buffer> getInflightBuffers(int numBuffers) {\n+\tprivate List<Buffer> getInflightBuffersUnsafe() {\n \t\tassert Thread.holdsLock(receivedBuffers);\n \n-\t\tif (numBuffers == 0) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\n-\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(numBuffers);\n+\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>();\n \t\tIterator<SequenceBuffer> iterator = receivedBuffers.iterator();\n \t\t// skip all priority events (only buffers are stored anyways)\n \t\tIterators.advance(iterator, receivedBuffers.getNumPriorityElements());\n \n-\t\t// spill number of overtaken buffers or all of them if barrier has not been seen yet\n-\t\tfor (int pos = 0; pos < numBuffers; pos++) {\n-\t\t\tBuffer buffer = iterator.next().buffer;\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\tinflightBuffers.add(buffer.retainBuffer());\n+\t\twhile (iterator.hasNext()) {\n+\t\t\tSequenceBuffer sequenceBuffer = iterator.next();\n+\t\t\tif (sequenceBuffer.buffer.isBuffer() && shouldBeSpilled(sequenceBuffer.sequenceNumber)) {\n+\t\t\t\tinflightBuffers.add(sequenceBuffer.buffer.retainBuffer());\n \t\t\t}\n \t\t}\n \n+\t\tlastOvertakenSequenceNumber = null;\n+\n \t\treturn inflightBuffers;\n \t}\n \n+\t/**\n+\t * @return if given {@param sequenceNumber} should be spilled given {@link #lastOvertakenSequenceNumber}.\n+\t * We might not have yet received {@link CheckpointBarrier} and we might need to spill everything.\n+\t * If we have already received it, there is a bit nasty corner case of {@link SequenceBuffer#sequenceNumber}\n+\t * overflowing that needs to be handled as well.\n+\t */\n+\tprivate boolean shouldBeSpilled(int sequenceNumber) {\n+\t\tif (lastOvertakenSequenceNumber == null) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tcheckState(\n+\t\t\treceivedBuffers.size() < Integer.MAX_VALUE / 2,\n+\t\t\t\"Too many buffers for sequenceNumber overflow detection code to work correctly\");\n+\n+\t\tboolean possibleOverflowAfterOvertaking = Integer.MAX_VALUE / 2 < lastOvertakenSequenceNumber;\n+\t\tboolean possibleOverflowBeforeOvertaking = lastOvertakenSequenceNumber < -Integer.MAX_VALUE / 2;\n+\n+\t\tif (possibleOverflowAfterOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber && sequenceNumber > 0;\n+\t\t}\n+\t\telse if (possibleOverflowBeforeOvertaking) {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber || sequenceNumber > 0;\n+\t\t}\n+\t\telse {\n+\t\t\treturn sequenceNumber < lastOvertakenSequenceNumber;\n+\t\t}", "originalCommit": "de43e752d21e95496aab69e13d9c007fa29d5b2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NzU1NQ==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524357555", "bodyText": "As far as I can tell this is the only such place. AlignedController collects SQNs but eventually passes them to  AlignedController which uses them here.\nI think changing the buffer format would have a broader scope (and require a broad discussion), so I'd stick with the current approach.", "author": "rkhachatryan", "createdAt": "2020-11-16T15:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2MDY3Mw==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524360673", "bodyText": "I was originally writing this overflow check\n\nThen I pulled it from Piotr's PR, and now you are reviewing it. The circle is closed :)", "author": "rkhachatryan", "createdAt": "2020-11-16T15:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NTI4OQ==", "url": "https://github.com/apache/flink/pull/14052#discussion_r525865289", "bodyText": "If this is the only place, we can leave as is. We just need to be aware of the code in other places where we compare sequence numbers (other than the strict increment of RemoteInputChannel) and pull out on demand.", "author": "AHeise", "createdAt": "2020-11-18T07:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAwMjkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524016742", "bodyText": "I'm not sure if all of this particular refactoring makes the test more readable: How should I know which sequence number sequence to expect? The assertion at the end is easy to understand though.\nIt would be much easier to understand with:\nsendBuffer(0);\nsendBuffer(1);\nsendBarrier(2);\nsendBuffer(3);\nsendBuffer(4);\n\nThese building blocks should also be reusable for the other tests.", "author": "AHeise", "createdAt": "2020-11-16T09:24:36Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -1125,70 +1127,137 @@ public void testUnblockReleasedChannel() throws Exception {\n \n \t@Test\n \tpublic void testPrioritySequenceNumbers() throws Exception {\n-\t\tfinal NetworkBufferPool networkBufferPool = new NetworkBufferPool(4, 4096);\n-\t\tSingleInputGate inputGate = new SingleInputGateBuilder()\n-\t\t\t.setChannelFactory(InputChannelBuilder::buildRemoteChannel)\n-\t\t\t.setBufferPoolFactory(networkBufferPool.createBufferPool(1, 4))\n-\t\t\t.setSegmentProvider(networkBufferPool)\n-\t\t\t.build();\n-\t\tfinal RemoteInputChannel channel = (RemoteInputChannel) inputGate.getChannel(0);\n-\t\tinputGate.setup();\n-\t\tinputGate.requestPartitions();\n+\t\tfinal RemoteInputChannel channel = buildInputGateAndGetChannel();\n+\t\tsendBuffersAndBarrier(channel, 0);", "originalCommit": "de43e752d21e95496aab69e13d9c007fa29d5b2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQxNzk1Mw==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524417953", "bodyText": "I agree that this change doesn't make this test more readable.\nBut if you consider other tests, they have the same logic. Thus, it's easier to understand them if this logic is extracted.\nIf you insist I can inline these steps (sendXxx).", "author": "rkhachatryan", "createdAt": "2020-11-16T16:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NjM3NQ==", "url": "https://github.com/apache/flink/pull/14052#discussion_r525866375", "bodyText": "I'd like to see them inlined. I aim to always have a test structured in the given, when, then structure and I think with this change, you managed to get exactly that (much better than it was before).", "author": "AHeise", "createdAt": "2020-11-18T07:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwNzQ4Ng==", "url": "https://github.com/apache/flink/pull/14052#discussion_r526307486", "bodyText": "Inlined.", "author": "rkhachatryan", "createdAt": "2020-11-18T18:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAxNjc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524115378", "bodyText": "Ah that what I was missing in the first main commit.\nI propose to squash the 2 main commits or at least already use the final name/type in the first main commit, so that the two commits don't touch every piece of code twice.", "author": "AHeise", "createdAt": "2020-11-16T10:52:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -98,14 +100,11 @@\n \n \tprivate final BufferManager bufferManager;\n \n-\t/**\n-\t * Indicates the last overtaken sequence number by the most recent {@link CheckpointBarrier}\n-\t * before task thread started checkpoint, or {@code null} if {@link CheckpointBarrier} hasn't\n-\t * arrived yet.\n-\t */\n \t@GuardedBy(\"receivedBuffers\")\n-\t@Nullable\n-\tprivate Integer lastOvertakenSequenceNumber = null;\n+\tprivate int lastBarrierSequenceNumber = NONE;", "originalCommit": "9b6d028dde24fc8fd21e3a3542756c813fca9c13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM5MTg5Mg==", "url": "https://github.com/apache/flink/pull/14052#discussion_r524391892", "bodyText": "The name of this field is also changed, so migrating the type change to the older commit will only eliminate two changes in the 2nd commit.\nBesides that, I'd like to keep the first commit (from the other PR) separate and untouched to avoid confusion.", "author": "rkhachatryan", "createdAt": "2020-11-16T16:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg2NzE0OA==", "url": "https://github.com/apache/flink/pull/14052#discussion_r525867148", "bodyText": "As a reviewer of this PR, I'm more confused by separation. I think Piotr is also not a big fan of touching the same code in multiple commits. The question is which confusion you want to avoid? Is it about code ownership? Then, I wouldn't mind keeping it separate.", "author": "AHeise", "createdAt": "2020-11-18T07:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwOTQyNQ==", "url": "https://github.com/apache/flink/pull/14052#discussion_r526309425", "bodyText": "It would be easier I think for us to unroll the history later if needed.\nBut I don't insist, moved type change to Piotr's commit.", "author": "rkhachatryan", "createdAt": "2020-11-18T18:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDExNTM3OA=="}], "type": "inlineReview"}, {"oid": "4965e2e5cb1a2baebdb7e2f516df106a4a3f523f", "url": "https://github.com/apache/flink/commit/4965e2e5cb1a2baebdb7e2f516df106a4a3f523f", "message": "[FLINK-20030][network] Introduce lastBarrierId in RemoteInputChannel\n\nThis allows to prevent overwriting of lastBarrierSqn from\nBarrierController when processing a newer barrier.", "committedDate": "2020-11-17T09:30:45Z", "type": "forcePushed"}, {"oid": "854da081b822a73282ae05bdeb890d3e87b9e7cb", "url": "https://github.com/apache/flink/commit/854da081b822a73282ae05bdeb890d3e87b9e7cb", "message": "[FLINK-20030][network] Introduce lastBarrierId in RemoteInputChannel\n\nThis allows to prevent overwriting of lastBarrierSqn from\nBarrierController when processing a newer barrier.", "committedDate": "2020-11-18T17:58:49Z", "type": "forcePushed"}, {"oid": "88671ad26ad07b78ee2819c919c4e96f789f9437", "url": "https://github.com/apache/flink/commit/88671ad26ad07b78ee2819c919c4e96f789f9437", "message": "[FLINK-20030][network] Rewrite RemoteInputChannel#getInflightBuffersUnsafe to use sequence numbers\n\nThis will make this method more stable for changes of the internal state of the RemoteInputChannel\nwhen timeouting aligned checkpoints.", "committedDate": "2020-11-18T18:05:20Z", "type": "commit"}, {"oid": "a24deacbf6d88b856faba8add3a470e425451f7b", "url": "https://github.com/apache/flink/commit/a24deacbf6d88b856faba8add3a470e425451f7b", "message": "[FLINK-20030][network] Introduce lastBarrierId in RemoteInputChannel\n\nThis allows to prevent overwriting of lastBarrierSqn from\nBarrierController when processing a newer barrier.", "committedDate": "2020-11-18T18:05:20Z", "type": "commit"}, {"oid": "a24deacbf6d88b856faba8add3a470e425451f7b", "url": "https://github.com/apache/flink/commit/a24deacbf6d88b856faba8add3a470e425451f7b", "message": "[FLINK-20030][network] Introduce lastBarrierId in RemoteInputChannel\n\nThis allows to prevent overwriting of lastBarrierSqn from\nBarrierController when processing a newer barrier.", "committedDate": "2020-11-18T18:05:20Z", "type": "forcePushed"}]}