{"pr_number": 13307, "pr_title": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "pr_createdAt": "2020-09-02T13:54:33Z", "pr_url": "https://github.com/apache/flink/pull/13307", "timeline": [{"oid": "da1db6af426818bc3bd0224c244dd201bd81799a", "url": "https://github.com/apache/flink/commit/da1db6af426818bc3bd0224c244dd201bd81799a", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-09-03T01:57:56Z", "type": "forcePushed"}, {"oid": "b9f1d43f8e46a0c79d2741c4d6061443ef9be599", "url": "https://github.com/apache/flink/commit/b9f1d43f8e46a0c79d2741c4d6061443ef9be599", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-09-05T09:16:55Z", "type": "forcePushed"}, {"oid": "7dc326d54c5ac31c352ac06c35d918f444d9bd40", "url": "https://github.com/apache/flink/commit/7dc326d54c5ac31c352ac06c35d918f444d9bd40", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-18T15:07:00Z", "type": "forcePushed"}, {"oid": "3aae457c54d028a1c526a32e059b0836df8105c7", "url": "https://github.com/apache/flink/commit/3aae457c54d028a1c526a32e059b0836df8105c7", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-18T17:22:29Z", "type": "forcePushed"}, {"oid": "4174635af1c0de52685df1ffb1b2adc869256d18", "url": "https://github.com/apache/flink/commit/4174635af1c0de52685df1ffb1b2adc869256d18", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-19T02:00:20Z", "type": "forcePushed"}, {"oid": "7ad79c6528d529ebd03e87a78f92d79d8cb6d91f", "url": "https://github.com/apache/flink/commit/7ad79c6528d529ebd03e87a78f92d79d8cb6d91f", "message": "[FLINK-19078][table-runtime] Import rowtime join temporal operator", "committedDate": "2020-10-22T15:49:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0MzIyOA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511843228", "bodyText": "I would suggest not deprecate this interface for now, as we don't provide equivalent functionality yet.", "author": "wuchong", "createdAt": "2020-10-26T10:03:47Z", "path": "flink-table/flink-table-api-java/src/main/java/org/apache/flink/table/api/Table.java", "diffHunk": "@@ -168,7 +168,9 @@\n \t *        It takes one single argument, the {@code timeAttribute}, for which it returns\n \t *        matching version of the {@link Table}, from which {@link TemporalTableFunction}\n \t *        was created.\n+\t * @deprecated please temporal DDL to define a temporal table.", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0ODM3OA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511848378", "bodyText": "It would be better to not mix insertRecord and record(RowKind.INSERT, ...).", "author": "wuchong", "createdAt": "2020-10-26T10:12:17Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperatorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.streaming.api.watermark.Watermark;\n+import org.apache.flink.streaming.util.KeyedTwoInputStreamOperatorTestHarness;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.types.RowKind;\n+\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.insertRecord;\n+import static org.apache.flink.table.runtime.util.StreamRecordUtils.record;\n+\n+/**\n+ * Harness tests for {@link TemporalRowTimeJoinOperatorTest}.\n+ */\n+public class TemporalRowTimeJoinOperatorTest extends TemporalTimeJoinOperatorTestBase {\n+\t/**\n+\t * Test rowtime temporal join.\n+\t */\n+\t@Test\n+\tpublic void testRowTimeTemporalJoin() throws Exception {\n+\t\tList<Object> expectedOutput = new ArrayList<>();\n+\t\texpectedOutput.add(new Watermark(1));\n+\t\texpectedOutput.add(new Watermark(2));\n+\t\texpectedOutput.add(insertRecord(3L, \"k1\", \"1a3\", 2L, \"k1\", \"1a2\"));\n+\t\texpectedOutput.add(new Watermark(5));\n+\t\texpectedOutput.add(insertRecord(6L, \"k2\", \"2a3\", 4L, \"k2\", \"2a4\"));\n+\t\texpectedOutput.add(new Watermark(8));\n+\t\texpectedOutput.add(new Watermark(9));\n+\t\texpectedOutput.add(insertRecord(11L, \"k2\", \"5a12\", 10L, \"k2\", \"2a6\"));\n+\t\texpectedOutput.add(new Watermark(13));\n+\n+\t\ttestRowTimeTemporalJoin(false, expectedOutput);\n+\t}\n+\n+\t/**\n+\t * Test rowtime left temporal join.\n+\t */\n+\t@Test\n+\tpublic void testRowTimeLeftTemporalJoin() throws Exception {\n+\t\tList<Object> expectedOutput = new ArrayList<>();\n+\t\texpectedOutput.add(new Watermark(1));\n+\t\texpectedOutput.add(insertRecord(1L, \"k1\", \"1a1\", null, null, null));\n+\t\texpectedOutput.add(new Watermark(2));\n+\t\texpectedOutput.add(insertRecord(1L, \"k1\", \"1a1\", null, null, null));\n+\t\texpectedOutput.add(insertRecord(3L, \"k1\", \"1a3\", 2L, \"k1\", \"1a2\"));\n+\t\texpectedOutput.add(new Watermark(5));\n+\t\texpectedOutput.add(insertRecord(6L, \"k2\", \"2a3\", 4L, \"k2\", \"2a4\"));\n+\t\texpectedOutput.add(new Watermark(8));\n+\t\texpectedOutput.add(insertRecord(9L, \"k2\", \"5a11\", null, null, null));\n+\t\texpectedOutput.add(new Watermark(9));\n+\t\texpectedOutput.add(insertRecord(11L, \"k2\", \"5a12\", 10L, \"k2\", \"2a6\"));\n+\t\texpectedOutput.add(new Watermark(13));\n+\n+\t\ttestRowTimeTemporalJoin(true, expectedOutput);\n+\t}\n+\n+\tprivate void testRowTimeTemporalJoin(boolean isLeftOuterJoin, List<Object> expectedOutput) throws Exception {\n+\t\tTemporalRowTimeJoinOperator joinOperator = new TemporalRowTimeJoinOperator(\n+\t\t\t\trowType,\n+\t\t\t\trowType,\n+\t\t\t\tjoinCondition,\n+\t\t\t\t0,\n+\t\t\t\t0,\n+\t\t\t\t0,\n+\t\t\t\t0,\n+\t\t\t\tisLeftOuterJoin);\n+\t\tKeyedTwoInputStreamOperatorTestHarness<RowData, RowData, RowData, RowData> testHarness = createTestHarness(\n+\t\t\t\tjoinOperator);\n+\n+\t\ttestHarness.open();\n+\n+\t\ttestHarness.processWatermark1(new Watermark(1));\n+\t\ttestHarness.processWatermark2(new Watermark(1));\n+\n+\t\ttestHarness.processElement1(insertRecord(1L, \"k1\", \"1a1\"));\n+\t\ttestHarness.processElement2(record(RowKind.INSERT, 2L, \"k1\", \"1a2\"));", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0ODY1MQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511848651", "bodyText": "Convert this class to an abstract class.", "author": "wuchong", "createdAt": "2020-10-26T10:12:47Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalTimeJoinOperatorTestBase.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.table.runtime.util.BinaryRowDataKeySelector;\n+import org.apache.flink.table.runtime.util.RowDataHarnessAssertor;\n+import org.apache.flink.table.types.logical.BigIntType;\n+import org.apache.flink.table.types.logical.VarCharType;\n+\n+/**\n+ * Base test class for TemporalJoinOperator.\n+ */\n+public class TemporalTimeJoinOperatorTestBase {", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkwMDA3Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511900076", "bodyText": "I don't think we can skip all -U messages here, because the -U message might be useful. The optimizer has already  tried to not send -U to temporal join, if the temporal join still receives -U, that means the -U is necessary. For example, filter after changelog source.\nYou can add a test for temporal join a changelog source with filter, and having a currency whose currency changes from 90 to 110. E.g.\nSELECT *\nFROM orders  AS O\nLEFT JOIN (SELECT * FROM currency WHERE rate > 100)  FOR SYSTEM_TIME AS OF O.rowtime AS C\nON O.currency_id = C.currency_id", "author": "wuchong", "createdAt": "2020-10-26T11:45:38Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.state.MapState;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.Types;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.types.RowKind;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * The operator for temporal join (FOR SYSTEM_TIME AS OF o.rowtime) on row time, it has no limitation\n+ * about message types of the left input and right input, this means the operator deals changelog well.\n+ *\n+ * <p>For Event-time temporal join, its probe side is a regular table, its build side is a versioned\n+ * table, the version of versioned table can extract from the build side state. This operator works by\n+ * keeping on the state collection of probe and build records to process on next watermark. The idea\n+ * is that between watermarks we are collecting those elements and once we are sure that there will be\n+ * no updates we emit the correct result and clean up the expired data in state.\n+ *\n+ * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n+ * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n+ * we sort all \"old\" values with row time and row kind and then clean up the old values, when clean up\n+ * the \"old\" values, if the latest record of all \"old\" values is retract message which means the version\n+ * end, we clean all \"old\" values, if the the latest record is accumulate message which means the version\n+ * start, we keep the latest one, and clear other \"old\" values.\n+ *\n+ * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n+ * by registering timers for the keys. We could register a timer for every probe and build\n+ * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n+ * cleaning up the state). However this would cause huge number of registered timers. For example\n+ * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n+ * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n+ * we always keep only one single registered timer for any given key, registered for the minimal\n+ * value. Upon triggering it, we process all records with event times older then or equal to\n+ * currentWatermark.\n+ */\n+public class TemporalRowTimeJoinOperator\n+\textends BaseTwoInputStreamOperatorWithStateRetention {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final String NEXT_LEFT_INDEX_STATE_NAME = \"next-index\";\n+\tprivate static final String LEFT_STATE_NAME = \"left\";\n+\tprivate static final String RIGHT_STATE_NAME = \"right\";\n+\tprivate static final String REGISTERED_TIMER_STATE_NAME = \"timer\";\n+\tprivate static final String TIMERS_STATE_NAME = \"timers\";\n+\n+\tprivate final boolean isLeftOuterJoin;\n+\tprivate final InternalTypeInfo<RowData> leftType;\n+\tprivate final InternalTypeInfo<RowData> rightType;\n+\tprivate final GeneratedJoinCondition generatedJoinCondition;\n+\tprivate final int leftTimeAttribute;\n+\tprivate final int rightTimeAttribute;\n+\n+\t/**\n+\t * The comparator to get ordered elements of right state.\n+\t */\n+\tprivate final ChangelogOrderComparator rightChangelogOrderComparator;\n+\n+\t/**\n+\t * Incremental index generator for {@link #leftState}'s keys.\n+\t */\n+\tprivate transient ValueState<Long> nextLeftIndex;\n+\n+\t/**\n+\t * Mapping from artificial row index (generated by `nextLeftIndex`) into the left side `Row`.\n+\t * We can not use List to accumulate Rows, because we need efficient deletes of the oldest rows.\n+\t */\n+\tprivate transient MapState<Long, RowData> leftState;\n+\n+\t/**\n+\t * Mapping from timestamp to right side `Row`.\n+\t **/\n+\tprivate transient MapState<RowData, Long> rightState;\n+\n+\tprivate transient ValueState<Long> registeredEventTimer;\n+\tprivate transient TimestampedCollector<RowData> collector;\n+\tprivate transient InternalTimerService<VoidNamespace> timerService;\n+\n+\tprivate transient JoinCondition joinCondition;\n+\tprivate transient JoinedRowData outRow;\n+\tprivate transient GenericRowData rightNullRow;\n+\n+\tpublic TemporalRowTimeJoinOperator(\n+\t\t\tInternalTypeInfo<RowData> leftType,\n+\t\t\tInternalTypeInfo<RowData> rightType,\n+\t\t\tGeneratedJoinCondition generatedJoinCondition,\n+\t\t\tint leftTimeAttribute,\n+\t\t\tint rightTimeAttribute,\n+\t\t\tlong minRetentionTime,\n+\t\t\tlong maxRetentionTime,\n+\t\t\tboolean isLeftOuterJoin) {\n+\t\tsuper(minRetentionTime, maxRetentionTime);\n+\t\tthis.leftType = leftType;\n+\t\tthis.rightType = rightType;\n+\t\tthis.generatedJoinCondition = generatedJoinCondition;\n+\t\tthis.leftTimeAttribute = leftTimeAttribute;\n+\t\tthis.rightTimeAttribute = rightTimeAttribute;\n+\t\tthis.rightChangelogOrderComparator = new ChangelogOrderComparator(rightTimeAttribute);\n+\t\tthis.isLeftOuterJoin = isLeftOuterJoin;\n+\t}\n+\n+\t@Override\n+\tpublic void open() throws Exception {\n+\t\tsuper.open();\n+\t\tjoinCondition = generatedJoinCondition.newInstance(getRuntimeContext().getUserCodeClassLoader());\n+\t\tjoinCondition.setRuntimeContext(getRuntimeContext());\n+\t\tjoinCondition.open(new Configuration());\n+\n+\t\tnextLeftIndex = getRuntimeContext().getState(\n+\t\t\tnew ValueStateDescriptor<>(NEXT_LEFT_INDEX_STATE_NAME, Types.LONG));\n+\t\tleftState = getRuntimeContext().getMapState(\n+\t\t\tnew MapStateDescriptor<>(LEFT_STATE_NAME, Types.LONG, leftType));\n+\t\trightState = getRuntimeContext().getMapState(\n+\t\t\tnew MapStateDescriptor<>(RIGHT_STATE_NAME, rightType, Types.LONG));\n+\t\tregisteredEventTimer = getRuntimeContext().getState(\n+\t\t\tnew ValueStateDescriptor<>(REGISTERED_TIMER_STATE_NAME, Types.LONG));\n+\n+\t\ttimerService = getInternalTimerService(\n+\t\t\tTIMERS_STATE_NAME, VoidNamespaceSerializer.INSTANCE, this);\n+\n+\t\toutRow = new JoinedRowData();\n+\t\trightNullRow = new GenericRowData(rightType.toRowType().getFieldCount());\n+\t\tcollector = new TimestampedCollector<>(output);\n+\t}\n+\n+\t@Override\n+\tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n+\t\tRowData row = element.getValue();\n+\t\tleftState.put(getNextLeftIndex(), row);\n+\t\tregisterSmallestTimer(getLeftTime(row)); // Timer to emit and clean up the state\n+\n+\t\tregisterProcessingCleanupTimer();\n+\t}\n+\n+\t/**\n+\t * We skip all -U message here, currently -U message is useless in versioned table.\n+\t * case 1: the -U message may use update message's time, for example: rightState = [1(+I), 4(-U), 4(+U)],\n+\t * case 2: the -U message may use insert message's time, for example: rightState = [1(+I), 1(-U), 4(+U)],\n+\t * the valid period of them should be [1, 4) and [4, Long.MaxValue).\n+\t */\n+\t@Override\n+\tpublic void processElement2(StreamRecord<RowData> element) throws Exception {\n+\t\tRowData row = element.getValue();\n+\t\tif (row.getRowKind() == RowKind.UPDATE_BEFORE) {\n+\t\t\treturn;", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk3MzAxNQ==", "url": "https://github.com/apache/flink/pull/13307#discussion_r511973015", "bodyText": "This can be MapState<Long, RowData> to have better performance as we discussed.", "author": "wuchong", "createdAt": "2020-10-26T13:49:19Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -0,0 +1,437 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.runtime.operators.join.temporal;\n+\n+import org.apache.flink.api.common.state.MapState;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ValueState;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.Types;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.api.operators.InternalTimer;\n+import org.apache.flink.streaming.api.operators.InternalTimerService;\n+import org.apache.flink.streaming.api.operators.TimestampedCollector;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.JoinedRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.data.util.RowDataUtil;\n+import org.apache.flink.table.runtime.generated.GeneratedJoinCondition;\n+import org.apache.flink.table.runtime.generated.JoinCondition;\n+import org.apache.flink.table.runtime.typeutils.InternalTypeInfo;\n+import org.apache.flink.types.RowKind;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+/**\n+ * The operator for temporal join (FOR SYSTEM_TIME AS OF o.rowtime) on row time, it has no limitation\n+ * about message types of the left input and right input, this means the operator deals changelog well.\n+ *\n+ * <p>For Event-time temporal join, its probe side is a regular table, its build side is a versioned\n+ * table, the version of versioned table can extract from the build side state. This operator works by\n+ * keeping on the state collection of probe and build records to process on next watermark. The idea\n+ * is that between watermarks we are collecting those elements and once we are sure that there will be\n+ * no updates we emit the correct result and clean up the expired data in state.\n+ *\n+ * <p>Cleaning up the state drops all of the \"old\" values from the probe side, where \"old\" is defined\n+ * as older then the current watermark. Build side is also cleaned up in the similar fashion,\n+ * we sort all \"old\" values with row time and row kind and then clean up the old values, when clean up\n+ * the \"old\" values, if the latest record of all \"old\" values is retract message which means the version\n+ * end, we clean all \"old\" values, if the the latest record is accumulate message which means the version\n+ * start, we keep the latest one, and clear other \"old\" values.\n+ *\n+ * <p>One more trick is how the emitting results and cleaning up is triggered. It is achieved\n+ * by registering timers for the keys. We could register a timer for every probe and build\n+ * side element's event time (when watermark exceeds this timer, that's when we are emitting and/or\n+ * cleaning up the state). However this would cause huge number of registered timers. For example\n+ * with following evenTimes of probe records accumulated: {1, 2, 5, 8, 9}, if we\n+ * had received Watermark(10), it would trigger 5 separate timers for the same key. To avoid that\n+ * we always keep only one single registered timer for any given key, registered for the minimal\n+ * value. Upon triggering it, we process all records with event times older then or equal to\n+ * currentWatermark.\n+ */\n+public class TemporalRowTimeJoinOperator\n+\textends BaseTwoInputStreamOperatorWithStateRetention {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final String NEXT_LEFT_INDEX_STATE_NAME = \"next-index\";\n+\tprivate static final String LEFT_STATE_NAME = \"left\";\n+\tprivate static final String RIGHT_STATE_NAME = \"right\";\n+\tprivate static final String REGISTERED_TIMER_STATE_NAME = \"timer\";\n+\tprivate static final String TIMERS_STATE_NAME = \"timers\";\n+\n+\tprivate final boolean isLeftOuterJoin;\n+\tprivate final InternalTypeInfo<RowData> leftType;\n+\tprivate final InternalTypeInfo<RowData> rightType;\n+\tprivate final GeneratedJoinCondition generatedJoinCondition;\n+\tprivate final int leftTimeAttribute;\n+\tprivate final int rightTimeAttribute;\n+\n+\t/**\n+\t * The comparator to get ordered elements of right state.\n+\t */\n+\tprivate final ChangelogOrderComparator rightChangelogOrderComparator;\n+\n+\t/**\n+\t * Incremental index generator for {@link #leftState}'s keys.\n+\t */\n+\tprivate transient ValueState<Long> nextLeftIndex;\n+\n+\t/**\n+\t * Mapping from artificial row index (generated by `nextLeftIndex`) into the left side `Row`.\n+\t * We can not use List to accumulate Rows, because we need efficient deletes of the oldest rows.\n+\t */\n+\tprivate transient MapState<Long, RowData> leftState;\n+\n+\t/**\n+\t * Mapping from timestamp to right side `Row`.\n+\t **/\n+\tprivate transient MapState<RowData, Long> rightState;", "originalCommit": "62bb7f7e511775b0b65003e65aa13b27c760da27", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0edbb09cea1b10a677b91c17b889ec74ef8dfbed", "url": "https://github.com/apache/flink/commit/0edbb09cea1b10a677b91c17b889ec74ef8dfbed", "message": "19078 base on 19077", "committedDate": "2020-10-27T16:46:48Z", "type": "forcePushed"}, {"oid": "20fe41449f841cfbbb155c1f1c842c5d814ca934", "url": "https://github.com/apache/flink/commit/20fe41449f841cfbbb155c1f1c842c5d814ca934", "message": "19078 base on 19077", "committedDate": "2020-10-28T02:25:08Z", "type": "forcePushed"}, {"oid": "85867d4ab920f571c1dcad56fea6a89c3b717b13", "url": "https://github.com/apache/flink/commit/85867d4ab920f571c1dcad56fea6a89c3b717b13", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator", "committedDate": "2020-10-28T03:57:11Z", "type": "forcePushed"}, {"oid": "dee9ebd0a1947e6580064910a0dace6f5e349c52", "url": "https://github.com/apache/flink/commit/dee9ebd0a1947e6580064910a0dace6f5e349c52", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator", "committedDate": "2020-10-28T04:12:51Z", "type": "forcePushed"}, {"oid": "a558cb0fd984dc5f256d7710f67239d0851204b3", "url": "https://github.com/apache/flink/commit/a558cb0fd984dc5f256d7710f67239d0851204b3", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator", "committedDate": "2020-10-28T08:12:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI4NTgwNA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513285804", "bodyText": "This comment is not correct any more, remove them?", "author": "wuchong", "createdAt": "2020-10-28T09:14:36Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -153,28 +161,30 @@ public void open() throws Exception {\n \n \t\ttimerService = getInternalTimerService(\n \t\t\tTIMERS_STATE_NAME, VoidNamespaceSerializer.INSTANCE, this);\n-\t\tcollector = new TimestampedCollector<>(output);\n+\n \t\toutRow = new JoinedRowData();\n-\t\t// all the output records should be INSERT only,\n-\t\t// because current temporal join only supports INSERT only left stream\n-\t\toutRow.setRowKind(RowKind.INSERT);\n+\t\trightNullRow = new GenericRowData(rightType.toRowType().getFieldCount());\n+\t\tcollector = new TimestampedCollector<>(output);\n \t}\n \n \t@Override\n \tpublic void processElement1(StreamRecord<RowData> element) throws Exception {\n \t\tRowData row = element.getValue();\n-\t\tcheckNotRetraction(row);\n-\n \t\tleftState.put(getNextLeftIndex(), row);\n \t\tregisterSmallestTimer(getLeftTime(row)); // Timer to emit and clean up the state\n \n \t\tregisterProcessingCleanupTimer();\n \t}\n \n+\t/**\n+\t * We skip all -U message here, currently -U message is useless in versioned table.\n+\t * case 1: the -U message may use update message's time, for example: rightState = [1(+I), 4(-U), 4(+U)],\n+\t * case 2: the -U message may use insert message's time, for example: rightState = [1(+I), 1(-U), 4(+U)],\n+\t * the valid period of them should be [1, 4) and [4, Long.MaxValue).", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI5MzYxNw==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513293617", "bodyText": "I don't think this is a trick...", "author": "wuchong", "createdAt": "2020-10-28T09:26:48Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -236,21 +253,30 @@ private long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n \t\t\t}\n \t\t}\n \n-\t\tcleanupState(timerTimestamp, rightRowsSorted);\n+\t\tcleanupExpiredVersionInState(currentWatermark, rightRowsSorted);\n \t\treturn lastUnprocessedTime;\n \t}\n \n+\tprivate void collectJoinedRow(RowData leftSideRow, RowData rightRow) {\n+\t\toutRow.setRowKind(leftSideRow.getRowKind());\n+\t\toutRow.replace(leftSideRow, rightRow);\n+\t\tcollector.collect(outRow);\n+\t}\n+\n \t/**\n-\t * Removes all right entries older then the watermark, except the latest one. For example with:\n-\t * rightState = [1, 5, 9]\n-\t * and\n-\t * watermark = 6\n-\t * we can not remove \"5\" from rightState, because left elements with rowtime of 7 or 8 could\n-\t * be joined with it later\n+\t * Removes all expired version in the versioned table's state according to current watermark.\n+\t * For example with: rightState = [1(+I), 4(-U), 4(+U), 7(-U), 7(+U), 9(-D), 12(I)],\n+\t *\n+\t * <p>If watermark = 6 we can not remove \"4(+U)\" from rightState because accumulate message means\n+\t * the start of version, the left elements with row time of 5 or 6 could be joined with (+U,4) later.\n+\t *\n+\t * <p>If watermark = 10 we can remove \"9(-D)\" from rightState because retract message means the\n+\t * end of version, a trick is we do not remove it but do not correlate it if it is a retract message.", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwMTQ2Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513301466", "bodyText": "I think we can't store both 4(-U) and 4(+U) in state, because they have the same map key 4.\nAn improvement here is we don't store the RowData into state for retraction, but just store null. This can be better for performance if the RowData is large. We can use TreeMap<Long, RowData> or List<Tuple2<Long, RowData> to replace the current List<RowData>.", "author": "wuchong", "createdAt": "2020-10-28T09:38:49Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -294,6 +320,13 @@ private int indexOfFirstElementNewerThanTimer(long timerTimestamp, List<RowData>\n \t/**\n \t * Binary search {@code rightRowsSorted} to find the latest right row to join with {@code leftTime}.\n \t * Latest means a right row with largest time that is still smaller or equal to {@code leftTime}.\n+\t * For example with: rightState = [1(+I), 4(-U), 4(+U), 7(-U), 7(+U), 9(-D), 12(I)],", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0Nzc0Mg==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513547742", "bodyText": "I did not get the improvement point, could you explain more ? other comments has addressed", "author": "leonardBang", "createdAt": "2020-10-28T15:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwMTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NjUxNw==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513556517", "bodyText": "Got your point, maybe this performance improvement is minor because (1) it only saves retraction records storage not all records (2) many retraction records between two watermarks  is not common, So I tend to improve it later if it's very important for performance", "author": "leonardBang", "createdAt": "2020-10-28T15:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwMTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMwNDYwMA==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513304600", "bodyText": "Two UB for the same key k2? Should this be UA?", "author": "wuchong", "createdAt": "2020-10-28T09:43:29Z", "path": "flink-table/flink-table-runtime-blink/src/test/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperatorTest.java", "diffHunk": "@@ -85,31 +101,28 @@ public void testRowTimeTemporalJoin() throws Exception {\n \t\ttestHarness.processWatermark1(new Watermark(2));\n \t\ttestHarness.processWatermark2(new Watermark(2));\n \n-\t\ttestHarness.processElement1(insertRecord(1L, \"k1\", \"2a1\"));\n-\t\ttestHarness.processElement1(insertRecord(3L, \"k1\", \"2a3\"));\n+\t\ttestHarness.processElement1(insertRecord(1L, \"k1\", \"1a1\"));\n+\t\ttestHarness.processElement1(insertRecord(3L, \"k1\", \"1a3\"));\n \t\ttestHarness.processElement2(insertRecord(4L, \"k2\", \"2a4\"));\n \n \t\ttestHarness.processWatermark1(new Watermark(5));\n \t\ttestHarness.processWatermark2(new Watermark(5));\n \n-\t\ttestHarness.processElement1(insertRecord(6L, \"k2\", \"5a6\"));\n-\t\ttestHarness.processElement2(insertRecord(8L, \"k2\", \"5a8\"));\n-\t\ttestHarness.processElement1(insertRecord(11L, \"k2\", \"5a11\"));\n-\t\ttestHarness.processElement1(insertRecord(7L, \"k2\", \"5a7\"));\n+\t\ttestHarness.processElement1(insertRecord(6L, \"k2\", \"2a3\"));\n+\t\ttestHarness.processElement2(updateBeforeRecord(7L, \"k2\", \"2a4\"));\n+\t\ttestHarness.processElement2(updateBeforeRecord(7L, \"k2\", \"2a5\"));", "originalCommit": "a558cb0fd984dc5f256d7710f67239d0851204b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f8a62099663b658669488af7f0ecd5087d1e5da6", "url": "https://github.com/apache/flink/commit/f8a62099663b658669488af7f0ecd5087d1e5da6", "message": "address comments", "committedDate": "2020-10-28T15:51:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkwNDc3Mg==", "url": "https://github.com/apache/flink/pull/13307#discussion_r513904772", "bodyText": "We can store left row data to avoid copy joined result.", "author": "wuchong", "createdAt": "2020-10-29T03:04:07Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -212,22 +221,32 @@ public void close() throws Exception {\n \t * @return a row time of the oldest unprocessed probe record or Long.MaxValue, if all records\n \t *         have been processed.\n \t */\n-\tprivate long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n+\tprivate long emitResultAndCleanUpState(long currentWatermark) throws Exception {\n \t\tList<RowData> rightRowsSorted = getRightRowSorted(rightRowtimeComparator);\n \t\tlong lastUnprocessedTime = Long.MAX_VALUE;\n \n \t\tIterator<Map.Entry<Long, RowData>> leftIterator = leftState.entries().iterator();\n+\t\t// keep the the output records' order same with left input records order\n+\t\tMap<Long, RowData> orderedOutputs = new TreeMap<>();", "originalCommit": "9f912a17d777463b856a19b64a03c16adadb8a73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "url": "https://github.com/apache/flink/commit/a45a5a527afc2aae477c89ebf0dc047cc45a201d", "message": "address comments", "committedDate": "2020-10-29T09:19:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyNjY2Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r514126666", "bodyText": "nit: would be better to declare it as final TreeMap<Long, RowData> orderedLeftRecords to guarantee it must be a TreeMap and not changed.", "author": "wuchong", "createdAt": "2020-10-29T09:43:17Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -212,45 +217,63 @@ public void close() throws Exception {\n \t * @return a row time of the oldest unprocessed probe record or Long.MaxValue, if all records\n \t *         have been processed.\n \t */\n-\tprivate long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n+\tprivate long emitResultAndCleanUpState(long currentWatermark) throws Exception {\n \t\tList<RowData> rightRowsSorted = getRightRowSorted(rightRowtimeComparator);\n \t\tlong lastUnprocessedTime = Long.MAX_VALUE;\n \n \t\tIterator<Map.Entry<Long, RowData>> leftIterator = leftState.entries().iterator();\n+\t\t// the output records's  order should keep same with left input records order\n+\t\tMap<Long, RowData> orderedLeftRecords = new TreeMap<>();", "originalCommit": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyNzk4Ng==", "url": "https://github.com/apache/flink/pull/13307#discussion_r514127986", "bodyText": "Add a comment that iterator the triggered left records in the ascending order of the sequence key, i.e. the arrival order.", "author": "wuchong", "createdAt": "2020-10-29T09:45:18Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/runtime/operators/join/temporal/TemporalRowTimeJoinOperator.java", "diffHunk": "@@ -212,45 +217,63 @@ public void close() throws Exception {\n \t * @return a row time of the oldest unprocessed probe record or Long.MaxValue, if all records\n \t *         have been processed.\n \t */\n-\tprivate long emitResultAndCleanUpState(long timerTimestamp) throws Exception {\n+\tprivate long emitResultAndCleanUpState(long currentWatermark) throws Exception {\n \t\tList<RowData> rightRowsSorted = getRightRowSorted(rightRowtimeComparator);\n \t\tlong lastUnprocessedTime = Long.MAX_VALUE;\n \n \t\tIterator<Map.Entry<Long, RowData>> leftIterator = leftState.entries().iterator();\n+\t\t// the output records's  order should keep same with left input records order\n+\t\tMap<Long, RowData> orderedLeftRecords = new TreeMap<>();\n+\n \t\twhile (leftIterator.hasNext()) {\n \t\t\tMap.Entry<Long, RowData> entry = leftIterator.next();\n+\t\t\tLong leftSeq = entry.getKey();\n \t\t\tRowData leftRow = entry.getValue();\n \t\t\tlong leftTime = getLeftTime(leftRow);\n-\n-\t\t\tif (leftTime <= timerTimestamp) {\n-\t\t\t\tOptional<RowData> rightRow = latestRightRowToJoin(rightRowsSorted, leftTime);\n-\t\t\t\tif (rightRow.isPresent()) {\n-\t\t\t\t\tif (joinCondition.apply(leftRow, rightRow.get())) {\n-\t\t\t\t\t\toutRow.replace(leftRow, rightRow.get());\n-\t\t\t\t\t\tcollector.collect(outRow);\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\tif (leftTime <= currentWatermark) {\n+\t\t\t\torderedLeftRecords.put(leftSeq, leftRow);\n \t\t\t\tleftIterator.remove();\n \t\t\t} else {\n \t\t\t\tlastUnprocessedTime = Math.min(lastUnprocessedTime, leftTime);\n \t\t\t}\n \t\t}\n \n-\t\tcleanupState(timerTimestamp, rightRowsSorted);\n+\t\torderedLeftRecords.forEach((leftSeq, leftRow) -> {", "originalCommit": "a45a5a527afc2aae477c89ebf0dc047cc45a201d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "896661af5940a86cd9fba9526aaf57a553d388cb", "url": "https://github.com/apache/flink/commit/896661af5940a86cd9fba9526aaf57a553d388cb", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator.", "committedDate": "2020-10-29T11:54:51Z", "type": "commit"}, {"oid": "896661af5940a86cd9fba9526aaf57a553d388cb", "url": "https://github.com/apache/flink/commit/896661af5940a86cd9fba9526aaf57a553d388cb", "message": "[FLINK-19078][table-runtime] Introduce row time temporal join operator.", "committedDate": "2020-10-29T11:54:51Z", "type": "forcePushed"}]}