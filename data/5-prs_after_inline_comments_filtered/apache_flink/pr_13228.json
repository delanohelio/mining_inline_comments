{"pr_number": 13228, "pr_title": "[FLINK-19026][network] Improve threading model of CheckpointBarrierUnaligner", "pr_createdAt": "2020-08-24T12:21:10Z", "pr_url": "https://github.com/apache/flink/pull/13228", "timeline": [{"oid": "249424b93f4963ef5875798dacb3f73f8ed18b0b", "url": "https://github.com/apache/flink/commit/249424b93f4963ef5875798dacb3f73f8ed18b0b", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-08-24T12:21:53Z", "type": "forcePushed"}, {"oid": "f0bb8a255816919a6578a6994499757075ab371b", "url": "https://github.com/apache/flink/commit/f0bb8a255816919a6578a6994499757075ab371b", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-08-24T12:23:30Z", "type": "forcePushed"}, {"oid": "67942d0ea538985ec25cecf7cefdc1bec0c1b53b", "url": "https://github.com/apache/flink/commit/67942d0ea538985ec25cecf7cefdc1bec0c1b53b", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-08-24T19:27:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg3NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476465875", "bodyText": "nit: it was a bit confusing for me for a moment which code paths are doing what. IMO it would be easier to follow it, if the shorter branch would be first, and if the more complicated part would have one lever of nesting less:\nif (!insertAsHead) {\n  buffers.add(bufferConsumer);\n  return;\n}\n//rest of the code\n\nin that case it's more obvious that !insertAsHead is a trivial case and that it doesn't interact with the other branch at all.", "author": "pnowojski", "createdAt": "2020-08-25T13:53:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tbuffers.add(bufferConsumer);", "originalCommit": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1NzIzMQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476657231", "bodyText": "Yes, good idea. In general that change looks a bit odd, because it's isolated from the upcoming changes (I had to split somewhere and probably didn't hit the sweet spot everywhere).", "author": "AHeise", "createdAt": "2020-08-25T18:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODc5Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476468797", "bodyText": "Why do we need this change? In what scenarios are you expecting more than one priority event in the output buffer?  (if there is a reason that I'm forgetting about, please add it to the commit message)\nedit: (after reading commit message a couple of times) Or you are just re-using here a class, that you are mostly intending to use later in the future (on the inputs?)? If so maybe it needs some more explanation in the commit message?", "author": "pnowojski", "createdAt": "2020-08-25T13:56:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -171,19 +175,42 @@ private void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAs\n \t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n \t\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\t\tif (unalignedCheckpoint) {\n+\t\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\treturn;\n+\t\t}", "originalCommit": "37360a5244cf5d438c5f6e0c67a16bcabe0f166f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1OTY2OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476659669", "bodyText": "In general, I wanted to drop the assumption that there is only one priority event going on at any given time. That's especially true when we make cancellation events also a priority and we have a more or less fully blocked channel.\nSpecifically, this change had following motivations:\n\ndrop the assumption that all priority events are unaligned checkpoints.\ndrop the assumption that the new priority event is always at position 0.\na small performance improvement where buffers are only copied after it's clear that they are not containing an event.", "author": "AHeise", "createdAt": "2020-08-25T18:40:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MDg2Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476480862", "bodyText": "nit: add a javadoc explaining the returned value?", "author": "pnowojski", "createdAt": "2020-08-25T14:12:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -133,14 +136,14 @@ public boolean isAvailable() {\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\t@Nullable", "originalCommit": "f944eae8129d84d25b81e1d97ef573c15456ccb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MTY4MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476481681", "bodyText": "hmmm, maybe add another enum type for this purpose, instead of having null? (I'm not sure, just brain storming)", "author": "pnowojski", "createdAt": "2020-08-25T14:13:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -133,14 +136,14 @@ public boolean isAvailable() {\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\t@Nullable\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!\n-\t\tif (numCreditsAvailable > 0) {\n-\t\t\treturn bufferAndBacklog.isDataAvailable();\n-\t\t}\n-\t\telse {\n-\t\t\treturn bufferAndBacklog.isEventAvailable();\n+\t\tfinal Buffer.DataType nextDataType = bufferAndBacklog.getNextDataType();\n+\t\tif (numCreditsAvailable > 0 || (nextDataType != null && nextDataType.isEvent())) {\n+\t\t\treturn nextDataType;\n \t\t}\n+\t\treturn null;", "originalCommit": "f944eae8129d84d25b81e1d97ef573c15456ccb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MDc1OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476660758", "bodyText": "An enum type NONE would work for me and might make the code a bit clearer. However, be aware that this is mostly a copy&replace; I don't think it would simplify any code path.", "author": "AHeise", "createdAt": "2020-08-25T18:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MTY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5ODQ5NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476498494", "bodyText": "maybe if the result variable rename and adding continue branch had happened in an independent \"refactor\" commit, It would have saved me a couple of minutes while reading this code while I was trying to understand the change :(\nmaybe not, as I can see how the changes are a bit interconnected.", "author": "pnowojski", "createdAt": "2020-08-25T14:35:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -621,61 +626,84 @@ public boolean isFinished() {\n \t\treturn Optional.of(transformToBufferOrEvent(\n \t\t\tinputWithData.data.buffer(),\n \t\t\tinputWithData.moreAvailable,\n-\t\t\tinputWithData.input));\n+\t\t\tinputWithData.input,\n+\t\t\tinputWithData.morePriorityEvents));\n \t}\n \n \tprivate Optional<InputWithData<InputChannel, BufferAndAvailability>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<InputChannel> inputChannel = getChannel(blocking);\n-\t\t\tif (!inputChannel.isPresent()) {\n+\t\t\tOptional<InputChannel> inputChannelOpt = getChannel(blocking);\n+\t\t\tif (!inputChannelOpt.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n \n \t\t\t// Do not query inputChannel under the lock, to avoid potential deadlocks coming from\n \t\t\t// notifications.\n-\t\t\tOptional<BufferAndAvailability> result = inputChannel.get().getNextBuffer();\n+\t\t\tfinal InputChannel inputChannel = inputChannelOpt.get();\n+\t\t\tOptional<BufferAndAvailability> bufferAndAvailabilityOpt = inputChannel.getNextBuffer();\n \n \t\t\tsynchronized (inputChannelsWithData) {\n-\t\t\t\tif (result.isPresent() && result.get().moreAvailable()) {\n+\t\t\t\tif (!bufferAndAvailabilityOpt.isPresent()) {\n+\t\t\t\t\tif (inputChannelsWithData.isEmpty()) {\n+\t\t\t\t\t\tavailabilityHelper.resetUnavailable();\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue;", "originalCommit": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MDkyMQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476660921", "bodyText": "Sry, I will split.", "author": "AHeise", "createdAt": "2020-08-25T18:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5ODQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwODcyNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476508727", "bodyText": "Heh, there are quite a bit more of corner/edge cases now.\nI wonder if there is maybe some other way to express the priority events, that would simplify the input gates code?", "author": "pnowojski", "createdAt": "2020-08-25T14:48:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -770,34 +808,50 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {", "originalCommit": "aba2e9bf850a5dc249bdc4e000e51b3317cc7409", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2MjE5Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476662192", "bodyText": "Well this change is less about expressing priority events and more about making sure that channels with priority events are always polled first. It's some kind of potential double notification, where the priority notification overrides the normal data available notification.", "author": "AHeise", "createdAt": "2020-08-25T18:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwODcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjIxNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476522216", "bodyText": "shouldn't we remove also obsolete values from this map? (to prevent a potential memory leak?)", "author": "pnowojski", "createdAt": "2020-08-25T15:06:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2NTY0MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476665640", "bodyText": "Good catch, a leak could happen when the checkpoint is cancelled through another channel. The map itself is rather small, but it could add up over all channels and gates.\nI don't have a good idea on how to properly abstract this cleanup except by adding some kind of checkpoint-cancelled hook though.\nAlternatively, checkpoint barrier handler becomes more aware of the buffers to be spilled. So instead of calling channel.spillInflightBuffers, it could be channel.getSpilledBuffers().forEach(channelStateWriter::write) on a good checkpoint and channel.getSpilledBuffers().forEach(Buffer::recycle) on cancelled checkpoints, where getSpilledBuffers always cleans up this map.", "author": "AHeise", "createdAt": "2020-08-25T18:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNDQwOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476524408", "bodyText": "numRecordsOvertaken -> numBuffersOvertaken?", "author": "pnowojski", "createdAt": "2020-08-25T15:09:13Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNzI5Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476527296", "bodyText": "Do I understand it correctly? Currently there is a fragile contract, that numRecordsOvertaken value wouldn't change between onBuffer(...) where we are setting it and this spillInflightBuffers(...) call? In other words, it assumes that between enqueueing of the priority event and the spillInflightBuffers(...), task thread is not allowed to process any buffers?\nMaybe it would be better to embed the numRecordsOvertaken value in the priority event that would be processed by the task thread?", "author": "pnowojski", "createdAt": "2020-08-25T15:13:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -195,28 +193,27 @@ void retriggerSubpartitionRequest(int subpartitionIndex) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) throws IOException {\n+\tpublic void spillInflightBuffers(long checkpointId, ChannelStateWriter channelStateWriter) {\n \t\tsynchronized (receivedBuffers) {\n-\t\t\tcheckState(checkpointId > lastRequestedCheckpointId, \"Need to request the next checkpointId\");\n-\n-\t\t\tfinal List<Buffer> inflightBuffers = new ArrayList<>(receivedBuffers.size());\n-\t\t\tfor (Buffer buffer : receivedBuffers) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\t\t\tif (checkpointBarrier != null && checkpointBarrier.getId() >= checkpointId) {\n-\t\t\t\t\tbreak;\n+\t\t\tfinal Integer numRecords = numRecordsOvertaken.remove(checkpointId);", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2ODM5MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476668391", "bodyText": "It's not a fragile contract if you think about it. We are setting the values under buffer lock and we will poll the barrier as the first thing under buffer lock. Any buffer that has been pulled by the task before the barrier cannot be overtaken. The buffer after the barrier overtakes is always the barrier itself.\nHowever, now that I think about it. It is not working correctly when there is another priority event being inserted between the barrier and the overtaken buffers. The fix is simple though thanks to the simpler threading model: only count non-priority buffers.", "author": "AHeise", "createdAt": "2020-08-25T18:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNzI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzMwNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476547304", "bodyText": "Again, do I understand this correctly? Is this assuming that nobody polls anything between completing getPriorityEventAvailableFuture and executing this::processPriorityEvents? Isn't that a bit fragile?\n\n\nWhat was the motivation for no passing the priority events to the StreamTaskNetworkInput?\n\n\nWhat about processing priority events as part of pollNext()?", "author": "pnowojski", "createdAt": "2020-08-25T15:40:43Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+\n+\t\t// re-enqueue mail to process priority events\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\tprivate void waitForPriorityEvents(InputGate inputGate, MailboxExecutor mailboxExecutor) {\n+\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputGate.getPriorityEventAvailableFuture();\n+\t\tpriorityEventAvailableFuture.thenRun(() -> {\n+\t\t\tmailboxExecutor.execute(this::processPriorityEvents, \"process priority even @ gate %s\", inputGate);\n+\t\t});", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3MzM1NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476673355", "bodyText": "Nope, this assumption does not hold. That's why the first thing that processPriorityEvents does is to check if the future is still completed. If the task polled the only priority event in the meantime, the future has been reset. During the execution of processPriorityEvents in the task thread, the task cannot concurrently pull the priority event, so this is safe.\n2.+3. The basic idea of not involving StreamTaskNetworkInput#emitNext or using pollNext() is to not make non-blocking output more complicated. Currently, emitNext or pollNext are only called when an output buffer is available. In the meantime only mails are processed. Hence, I used a mail to perform processPriorityEvents.\nNote that the assumption here is that no priority event ever need to be handled in emitNext (which currently only handles EndOfPartitionEvent)", "author": "AHeise", "createdAt": "2020-08-25T19:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0NzMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTY3Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476551677", "bodyText": "Isn't it changing the semantic slightly? Am I right, that the only case on the master branch which actually causes another iteration of this loop is\nbarrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());\n\nand all of the other cases were exiting the loop? Are now all of the cases exiting always?", "author": "pnowojski", "createdAt": "2020-08-25T15:47:16Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NDAwNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476674004", "bodyText": "Yes, it's changing semantics (as I had written in commit message). I have not found a good reason why it's not always exited and it makes things easier especially since this method can now be used to process priority events.\nBtw I think it also changes semantics for all event that are not handled at all, but I'm not sure which events survive at this point (Superstep?).", "author": "AHeise", "createdAt": "2020-08-25T19:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1MTY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476557492", "bodyText": "As I understand it, it assumes that this pollNext() can not return anything else besides a priority event?", "author": "pnowojski", "createdAt": "2020-08-25T15:55:53Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -63,9 +66,38 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tfinal boolean hasPriorityEvents = inputGate.getPriorityEventAvailableFuture().isDone();\n+\t\tif (hasPriorityEvents) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NTA5Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476675096", "bodyText": "Yes, first this method checks if there is at least one priority event (priority future completed). If there is at least one, it starts processing the first one. At this point, it relies on BufferOrEvent::morePriorityEvents to be correct in both directions (no false positives or negatives; although a false negative would just be a tad slower).", "author": "AHeise", "createdAt": "2020-08-25T19:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MDM5MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492840391", "bodyText": "maybe add a checkState, that we are not loosing some unexpected data?", "author": "pnowojski", "createdAt": "2020-09-22T15:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476559505", "bodyText": "Is this spit into processBuffer and processEvent relevant?", "author": "pnowojski", "createdAt": "2020-08-25T15:58:48Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -159,10 +158,12 @@ public InputStatus emitNext(DataOutput<T> output) throws Exception {\n \t\t\tif (bufferOrEvent.isPresent()) {\n \t\t\t\t// return to the mailbox after receiving a checkpoint barrier to avoid processing of\n \t\t\t\t// data after the barrier before checkpoint is performed for unaligned checkpoint mode\n-\t\t\t\tif (bufferOrEvent.get().isEvent() && bufferOrEvent.get().getEvent() instanceof CheckpointBarrier) {\n+\t\t\t\tif (bufferOrEvent.get().isBuffer()) {\n+\t\t\t\t\tprocessBuffer(bufferOrEvent.get());\n+\t\t\t\t} else {\n+\t\t\t\t\tprocessEvent(bufferOrEvent.get());", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3ODkwMw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476678903", "bodyText": "Nope, it's a refactoring that I should move out. We could also revert back. I had an intermediate version where processEvent signaled if the loop should be broken or not and there the split made more sense.", "author": "AHeise", "createdAt": "2020-08-25T19:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzkzMA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487967930", "bodyText": "Could you ether pull it to another commit or revert? This\n\nUse futures to listen to priority events and handle them in StreamTaskNetworkInput.\n\ncommit has a couple of other irrelevant changes", "author": "pnowojski", "createdAt": "2020-09-14T14:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwMzYxNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489203616", "bodyText": "Sorry I haven't pulled that change out, since it's more than a refactoring; it's the core change that modifies the semantics to always return on events.\nExcept for that change, everything else is more or less directly related to passing the priority future, so I'm not sure what to pull out.", "author": "AHeise", "createdAt": "2020-09-16T06:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1OTUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2MTE2NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476561164", "bodyText": "for now in this commit, this is just a NO-OP call?", "author": "pnowojski", "createdAt": "2020-08-25T16:01:00Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -74,34 +106,34 @@ public CheckpointedInputGate(\n \t}\n \n \t@Override\n-\tpublic Optional<BufferOrEvent> pollNext() throws Exception {\n-\t\twhile (true) {\n-\t\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n+\tpublic Optional<BufferOrEvent> pollNext() throws IOException, InterruptedException {\n+\t\tOptional<BufferOrEvent> next = inputGate.pollNext();\n \n-\t\t\tif (!next.isPresent()) {\n-\t\t\t\treturn handleEmptyBuffer();\n-\t\t\t}\n+\t\tif (!next.isPresent()) {\n+\t\t\treturn handleEmptyBuffer();\n+\t\t}\n \n-\t\t\tBufferOrEvent bufferOrEvent = next.get();\n-\t\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n+\t\tBufferOrEvent bufferOrEvent = next.get();\n+\t\tcheckState(!barrierHandler.isBlocked(bufferOrEvent.getChannelInfo()));\n \n-\t\t\tif (bufferOrEvent.isBuffer()) {\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CheckpointBarrier.class) {\n-\t\t\t\tCheckpointBarrier checkpointBarrier = (CheckpointBarrier) bufferOrEvent.getEvent();\n-\t\t\t\tbarrierHandler.processBarrier(checkpointBarrier, bufferOrEvent.getChannelInfo());\n-\t\t\t\treturn next;\n-\t\t\t}\n-\t\t\telse if (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker.class) {\n-\t\t\t\tbarrierHandler.processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif (bufferOrEvent.getEvent().getClass() == EndOfPartitionEvent.class) {\n-\t\t\t\t\tbarrierHandler.processEndOfPartition();\n-\t\t\t\t}\n-\t\t\t\treturn next;\n-\t\t\t}\n+\t\tif (bufferOrEvent.isEvent()) {\n+\t\t\thandleEvent(bufferOrEvent);\n+\t\t} else {\n+\t\t\tbarrierHandler.processBuffer(bufferOrEvent.getBuffer(), bufferOrEvent.getChannelInfo());", "originalCommit": "907b87b7688a21dabe672aae6ba18bb9db4bfb4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NzkyNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476677925", "bodyText": "Yes, it's used in the next commit to persist in-flight data (replaces notifyBufferReceived).", "author": "AHeise", "createdAt": "2020-08-25T19:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2MTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NDkwNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476564905", "bodyText": "Here, we are persisting in-flight buffers, only as they are being processed? Doesn't it mean, that unaligned checkpoint will be completed only after we process all of the buffers, making unaligned checkpoint just as quick as aligned?", "author": "pnowojski", "createdAt": "2020-08-25T16:06:23Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -92,306 +90,173 @@\n \t\tsuper(toNotifyOnCheckpoint);\n \n \t\tthis.taskName = taskName;\n-\t\thasInflightBuffers = Arrays.stream(inputGates)\n+\t\tthis.inputGates = inputGates;\n+\t\tstoreNewBuffers = Arrays.stream(inputGates)\n \t\t\t.flatMap(gate -> gate.getChannelInfos().stream())\n \t\t\t.collect(Collectors.toMap(Function.identity(), info -> false));\n-\t\tthreadSafeUnaligner = new ThreadSafeUnaligner(checkNotNull(checkpointCoordinator), this, inputGates);\n+\t\tnumOpenChannels = storeNewBuffers.size();\n+\t\tthis.checkpointCoordinator = checkpointCoordinator;\n \t}\n \n-\t/**\n-\t * We still need to trigger checkpoint via {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}\n-\t * while reading the first barrier from one channel, because this might happen\n-\t * earlier than the previous async trigger via mailbox by netty thread.\n-\t *\n-\t * <p>Note this is also suitable for the trigger case of local input channel.\n-\t */\n \t@Override\n-\tpublic void processBarrier(CheckpointBarrier receivedBarrier, InputChannelInfo channelInfo) throws IOException {\n-\t\tlong barrierId = receivedBarrier.getId();\n-\t\tif (currentConsumedCheckpointId > barrierId || (currentConsumedCheckpointId == barrierId && !isCheckpointPending())) {\n+\tpublic void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelInfo) throws IOException {\n+\t\tlong barrierId = barrier.getId();\n+\t\tif (currentCheckpointId > barrierId || (currentCheckpointId == barrierId && !isCheckpointPending())) {\n \t\t\t// ignore old and cancelled barriers\n \t\t\treturn;\n \t\t}\n-\t\tif (currentConsumedCheckpointId < barrierId) {\n-\t\t\tcurrentConsumedCheckpointId = barrierId;\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(true));\n+\t\tif (currentCheckpointId < barrierId) {\n+\t\t\thandleNewCheckpoint(barrier);\n+\t\t\tnotifyCheckpoint(barrier, 0);\n \t\t}\n-\t\tif (currentConsumedCheckpointId == barrierId) {\n-\t\t\thasInflightBuffers.put(channelInfo, false);\n-\t\t\tnumBarrierConsumed++;\n+\t\tif (currentCheckpointId == barrierId) {\n+\t\t\tif (storeNewBuffers.put(channelInfo, false)) {\n+\t\t\t\tLOG.debug(\"{}: Received barrier from channel {} @ {}.\", taskName, channelInfo, barrierId);\n+\n+\t\t\t\tinputGates[channelInfo.getGateIdx()].getChannel(channelInfo.getInputChannelIdx())\n+\t\t\t\t\t.spillInflightBuffers(barrierId, checkpointCoordinator.getChannelStateWriter());\n+\n+\t\t\t\tif (++numBarriersReceived == numOpenChannels) {\n+\t\t\t\t\tallBarriersReceivedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tthreadSafeUnaligner.notifyBarrierReceived(receivedBarrier, channelInfo);\n \t}\n \n \t@Override\n \tpublic void abortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {\n-\t\tthreadSafeUnaligner.tryAbortPendingCheckpoint(checkpointId, exception);\n+\t\ttryAbortPendingCheckpoint(checkpointId, exception);\n \n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(checkpointId);\n+\t\tif (checkpointId > currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws IOException {\n \t\tfinal long cancelledId = cancelBarrier.getCheckpointId();\n-\t\tboolean shouldAbort = threadSafeUnaligner.setCancelledCheckpointId(cancelledId);\n+\t\tboolean shouldAbort = setCancelledCheckpointId(cancelledId);\n \t\tif (shouldAbort) {\n \t\t\tnotifyAbort(\n \t\t\t\tcancelledId,\n \t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_ON_CANCELLATION_BARRIER));\n \t\t}\n \n-\t\tif (cancelledId >= currentConsumedCheckpointId) {\n-\t\t\tresetPendingCheckpoint(cancelledId);\n-\t\t\tcurrentConsumedCheckpointId = cancelledId;\n+\t\tif (cancelledId >= currentCheckpointId) {\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentCheckpointId = cancelledId;\n \t\t}\n \t}\n \n \t@Override\n \tpublic void processEndOfPartition() throws IOException {\n-\t\tthreadSafeUnaligner.onChannelClosed();\n-\t\tresetPendingCheckpoint(-1L);\n+\t\tnumOpenChannels--;\n+\n+\t\tresetPendingCheckpoint();\n+\t\tnotifyAbort(\n+\t\t\tcurrentCheckpointId,\n+\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n \t}\n \n-\tprivate void resetPendingCheckpoint(long checkpointId) {\n-\t\tif (isCheckpointPending()) {\n-\t\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) {} before completing current checkpoint {}. \" +\n-\t\t\t\t\t\"Skipping current checkpoint.\",\n-\t\t\t\ttaskName,\n-\t\t\t\tcheckpointId,\n-\t\t\t\tcurrentConsumedCheckpointId);\n+\tprivate void resetPendingCheckpoint() {\n+\t\tLOG.warn(\"{}: Received barrier or EndOfPartition(-1) before completing current checkpoint {}. \" +\n+\t\t\t\t\"Skipping current checkpoint.\",\n+\t\t\ttaskName,\n+\t\t\tcurrentCheckpointId);\n \n-\t\t\thasInflightBuffers.entrySet().forEach(hasInflightBuffer -> hasInflightBuffer.setValue(false));\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t}\n+\t\tstoreNewBuffers.entrySet().forEach(storeNewBuffer -> storeNewBuffer.setValue(false));\n+\t\tnumBarriersReceived = 0;\n \t}\n \n \t@Override\n \tpublic long getLatestCheckpointId() {\n-\t\treturn currentConsumedCheckpointId;\n+\t\treturn currentCheckpointId;\n \t}\n \n \t@Override\n \tpublic String toString() {\n-\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentConsumedCheckpointId);\n+\t\treturn String.format(\"%s: last checkpoint: %d\", taskName, currentCheckpointId);\n \t}\n \n \t@Override\n \tpublic void close() throws IOException {\n \t\tsuper.close();\n-\t\tthreadSafeUnaligner.close();\n-\t}\n-\n-\t@Override\n-\tpublic boolean hasInflightData(long checkpointId, InputChannelInfo channelInfo) {\n-\t\tif (checkpointId < currentConsumedCheckpointId) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (checkpointId > currentConsumedCheckpointId) {\n-\t\t\treturn true;\n-\t\t}\n-\t\treturn hasInflightBuffers.get(channelInfo);\n-\t}\n-\n-\t@Override\n-\tpublic CompletableFuture<Void> getAllBarriersReceivedFuture(long checkpointId) {\n-\t\treturn threadSafeUnaligner.getAllBarriersReceivedFuture(checkpointId);\n-\t}\n-\n-\t@Override\n-\tpublic Optional<BufferReceivedListener> getBufferReceivedListener() {\n-\t\treturn Optional.of(threadSafeUnaligner);\n+\t\tallBarriersReceivedFuture.cancel(false);\n \t}\n \n \t@Override\n \tprotected boolean isCheckpointPending() {\n-\t\treturn numBarrierConsumed > 0;\n-\t}\n-\n-\t@VisibleForTesting\n-\tint getNumOpenChannels() {\n-\t\treturn threadSafeUnaligner.getNumOpenChannels();\n-\t}\n-\n-\t@VisibleForTesting\n-\tThreadSafeUnaligner getThreadSafeUnaligner() {\n-\t\treturn threadSafeUnaligner;\n+\t\treturn numBarriersReceived > 0;\n \t}\n \n-\tprivate void notifyCheckpoint(CheckpointBarrier barrier) throws IOException {\n-\t\t// ignore the previous triggered checkpoint by netty thread if it was already canceled or aborted before.\n-\t\tif (barrier.getId() >= threadSafeUnaligner.getCurrentCheckpointId()) {\n-\t\t\tsuper.notifyCheckpoint(barrier, 0);\n+\t@Override\n+\tpublic void processBuffer(Buffer buffer, InputChannelInfo channelInfo) {\n+\t\tif (storeNewBuffers.get(channelInfo)) {\n+\t\t\tcheckpointCoordinator.getChannelStateWriter().addInputData(\n+\t\t\t\tcurrentCheckpointId,\n+\t\t\t\tchannelInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "originalCommit": "9836d4919062fa63212d16bc88a071cc31fc3977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY4MzQxNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r476683415", "bodyText": "Let me sketch the most general data flow:\n\nWe have couple of buffers in our input channel.\nCheckpoint is triggered by another channel. *\nAll buffers that are now pulled by CheckpointedInputGate from the first channel get persisted by above function.\nThen the barrier comes in. *\nIt overtakes all buffers and is now at the head. *\nCheckpointedInputGate gets priority notification and polls the barrier.\nUpon dispatching, it calls Unaligner, which spills additionally all overtaken buffers.\nFurther buffers are not persisted.\n\nAll steps marked with * are performed in a different thread (other task thread / netty).\nFor me this is equivalent to the current behavior, but maybe I missed something.", "author": "AHeise", "createdAt": "2020-08-25T19:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2NDkwNQ=="}], "type": "inlineReview"}, {"oid": "273cc6bf445b4a44daca0e98d49aa0745a36a534", "url": "https://github.com/apache/flink/commit/273cc6bf445b4a44daca0e98d49aa0745a36a534", "message": "WIP", "committedDate": "2020-09-04T16:28:18Z", "type": "forcePushed"}, {"oid": "f1bfd2b98e8665739bd07ae828d2ca73e2e927fc", "url": "https://github.com/apache/flink/commit/f1bfd2b98e8665739bd07ae828d2ca73e2e927fc", "message": "[FLINK-19026][tests] Reintroduce sleep throttle in UnalignedCheckpointITCase", "committedDate": "2020-09-04T20:19:03Z", "type": "forcePushed"}, {"oid": "234449f5731ecab6a2ed3ed2db2739d919c56398", "url": "https://github.com/apache/flink/commit/234449f5731ecab6a2ed3ed2db2739d919c56398", "message": "ChannelStateHolder", "committedDate": "2020-09-07T11:59:56Z", "type": "forcePushed"}, {"oid": "fce9f56a12b7c28a827c85669ce4bb0a8d31a48b", "url": "https://github.com/apache/flink/commit/fce9f56a12b7c28a827c85669ce4bb0a8d31a48b", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T12:14:42Z", "type": "forcePushed"}, {"oid": "d141f10ef060063162dc073b1cd66729f5f75a3b", "url": "https://github.com/apache/flink/commit/d141f10ef060063162dc073b1cd66729f5f75a3b", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T12:51:48Z", "type": "forcePushed"}, {"oid": "ef2c7ecea91a30e4d721efa759ca1b15728a24cb", "url": "https://github.com/apache/flink/commit/ef2c7ecea91a30e4d721efa759ca1b15728a24cb", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T13:28:33Z", "type": "forcePushed"}, {"oid": "755c3410f798bf7b3fffef91b7f2349b021613a9", "url": "https://github.com/apache/flink/commit/755c3410f798bf7b3fffef91b7f2349b021613a9", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T14:13:47Z", "type": "forcePushed"}, {"oid": "4af565f8d262b2ed2ebfb7614e0f24494eb22186", "url": "https://github.com/apache/flink/commit/4af565f8d262b2ed2ebfb7614e0f24494eb22186", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-07T19:48:00Z", "type": "forcePushed"}, {"oid": "b3a1520089c241fc74837902b6440d84a9636c14", "url": "https://github.com/apache/flink/commit/b3a1520089c241fc74837902b6440d84a9636c14", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-08T08:34:26Z", "type": "forcePushed"}, {"oid": "16c32eb1e2d49fa3c84cd4a82380fd72d5dcf5c0", "url": "https://github.com/apache/flink/commit/16c32eb1e2d49fa3c84cd4a82380fd72d5dcf5c0", "message": "[FLINK-19026][task] Pulling from input with priority events first.\n\nStreamTask pulls data if either input+output are available or a priority event happens. This commit ensures that StreamTask pulls from the correct input in the latter case to not block on output (and process priority events first).", "committedDate": "2020-09-08T16:53:26Z", "type": "forcePushed"}, {"oid": "11cb1939f8a98340acab9b795c6f1894808fb606", "url": "https://github.com/apache/flink/commit/11cb1939f8a98340acab9b795c6f1894808fb606", "message": "[FLINK-19026][task] Pulling from input with priority events first.\n\nStreamTask pulls data if either input+output are available or a priority event happens. This commit ensures that StreamTask pulls from the correct input in the latter case to not block on output (and process priority events first).", "committedDate": "2020-09-08T18:47:59Z", "type": "forcePushed"}, {"oid": "19c4f0d1d1710b829946a78cb58aff768baab684", "url": "https://github.com/apache/flink/commit/19c4f0d1d1710b829946a78cb58aff768baab684", "message": "[hotfix][source] Remove null-check from SourceCoordinatorContext#unregisterSourceReader.\n\nIf an error happens during startup, the reader may not be registered (yet), but cleanup is triggered anyways.", "committedDate": "2020-09-09T06:57:41Z", "type": "forcePushed"}, {"oid": "40c76a4ce74a5bbc800cf9833b96bb0156cacc41", "url": "https://github.com/apache/flink/commit/40c76a4ce74a5bbc800cf9833b96bb0156cacc41", "message": "[hotfix][source] Remove null-check from SourceCoordinatorContext#unregisterSourceReader.\n\nIf an error happens during startup, the reader may not be registered (yet), but cleanup is triggered anyways.", "committedDate": "2020-09-09T08:15:30Z", "type": "forcePushed"}, {"oid": "407169bc192b5d05bfba2c264849f1a6e7b81415", "url": "https://github.com/apache/flink/commit/407169bc192b5d05bfba2c264849f1a6e7b81415", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-09T14:38:18Z", "type": "forcePushed"}, {"oid": "89b0550c7b223f304b67a6f64dfc4252509eb76e", "url": "https://github.com/apache/flink/commit/89b0550c7b223f304b67a6f64dfc4252509eb76e", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-10T11:40:45Z", "type": "forcePushed"}, {"oid": "a6a2d36afcce1758e885f0751359ccf035ae2378", "url": "https://github.com/apache/flink/commit/a6a2d36afcce1758e885f0751359ccf035ae2378", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-10T12:17:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r486930588", "bodyText": "Is this a fix for an existing bug on the master branch? Or are you changing the behaviour/contract of this unregisterSourceReader call in some later commit?\nWould it be worthwhile/easy adding a test?", "author": "pnowojski", "createdAt": "2020-09-11T09:52:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/source/coordinator/SourceCoordinatorContext.java", "diffHunk": "@@ -261,8 +260,7 @@ void registerSourceReader(ReaderInfo readerInfo) {\n \t * @param subtaskId the subtask id of the source reader.\n \t */\n \tvoid unregisterSourceReader(int subtaskId) {\n-\t\tPreconditions.checkNotNull(registeredReaders.remove(subtaskId), String.format(\n-\t\t\t\t\"Failed to unregister source reader of id %s because it is not registered.\", subtaskId));\n+\t\tregisteredReaders.remove(subtaskId);", "originalCommit": "2286a09f24b69151445a0c75c52d83f9e6dd5120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDc3OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489230779", "bodyText": "It's a bug that I discovered in my UC ITCase and confirmed with Becket and Stephan. I added a small (trivial) test case.", "author": "AHeise", "createdAt": "2020-09-16T07:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4MTcyOQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492481729", "bodyText": "Added a ticket and referenced it properly https://issues.apache.org/jira/browse/FLINK-19338 .", "author": "AHeise", "createdAt": "2020-09-22T05:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMDU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTg5Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487029893", "bodyText": "nit: maybe it's worth keeping this comment?", "author": "pnowojski", "createdAt": "2020-09-11T13:03:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMzY3MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489233671", "bodyText": "Moved the removal to the commit that spills immediately.", "author": "AHeise", "createdAt": "2020-09-16T07:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAyOTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzMDgyOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487030828", "bodyText": "nit: pos -> numberOfPriorityEvents? It would make the following line:\nIterators.advance(iterator, pos + 1);\n\nmore readable.", "author": "pnowojski", "createdAt": "2020-09-11T13:05:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n+\t\tfinal int pos = buffers.getNumPriorityElements();", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMyNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487038327", "bodyText": "this method is only isCheckpointBarrier and it seems to not care if it's aligned or not, right?\nBesides, do we really need to deserialise the event? Previously we were snapshotting in-flight data every time we were inserting buffer as a head. I think it was just as not elegant, but simpler.\nI guess this is currently a dead code, but would change if we ever want to have priority cancelation markers? If that's a sole motivation, I would revisit this problem in the future. Who knows if we will need this with checkpoint abort RPC. And if we will do, there is also another option:\nInserting priority UC barrier, could go through a separate method , that would return overtaken in-flight data:\nCollection<Buffer> insertAsHeadAndGetInFlightData(checkpointBarrier)\n\nwhich would also eliminate the currently existing assumption/hack that requestInflightBufferSnapshot has to be always called immediately after inserting as a head.", "author": "pnowojski", "createdAt": "2020-09-11T13:17:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -167,23 +171,46 @@ private boolean add(BufferConsumer bufferConsumer, boolean finish, boolean inser\n \n \tprivate void handleAddingBarrier(BufferConsumer bufferConsumer, boolean insertAsHead) {\n \t\tassert Thread.holdsLock(buffers);\n-\t\tif (insertAsHead) {\n-\t\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\t\"checkpoints\");\n+\t\tif (!insertAsHead) {\n+\t\t\tbuffers.add(bufferConsumer);\n+\t\t\treturn;\n+\t\t}\n+\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n+\t\t\t\"checkpoints\");\n \n-\t\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\t\tfor (BufferConsumer buffer : buffers) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tif (bc.isBuffer()) {\n+\t\tfinal int pos = buffers.getNumPriorityElements();\n+\t\tbuffers.addPriorityElement(bufferConsumer);\n+\n+\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n+\t\tif (unalignedCheckpoint) {\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n \t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t}\n+\t}\n \n-\t\t\tbuffers.addFirst(bufferConsumer);\n-\t\t} else {\n-\t\t\tbuffers.add(bufferConsumer);\n+\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n+\t\tboolean unalignedCheckpoint;\n+\t\ttry (BufferConsumer bc = bufferConsumer.copy()) {\n+\t\t\tBuffer buffer = bc.build();\n+\t\t\ttry {\n+\t\t\t\tfinal AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t\tunalignedCheckpoint = event instanceof CheckpointBarrier;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new IllegalStateException(\"Should always be able to deserialize in-memory event\", e);\n+\t\t\t} finally {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n \t\t}\n+\t\treturn unalignedCheckpoint;", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNTUyMQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489235521", "bodyText": "Moved this method to the commit that spills immediately. We need it in that method to retrieve the checkpoint id to spill correctly.\nDeserialization is only necessary for priority events, which are very rare and rather cheap (30 bytes). I'd argue that adding a new call chain just to optimize it is not warranted.", "author": "AHeise", "createdAt": "2020-09-16T07:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAzODMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI1OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487040259", "bodyText": "is this method being used? I think at least not in this commit", "author": "pnowojski", "createdAt": "2020-09-11T13:21:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PrioritizedDeque.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition;\n+\n+import org.apache.flink.annotation.Internal;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.Iterator;\n+import java.util.Objects;\n+\n+/**\n+ * A deque-like data structure that supports prioritization of elements, such they will be polled before any\n+ * non-priority elements.\n+ *\n+ * <p>{@implNote The current implementation deliberately does not implement the respective interface to minimize the maintenance\n+ * effort. Furthermore, it's optimized for handling non-priority elements, such that all operations for adding priority\n+ * elements are much slower than the non-priority counter-parts.}\n+ *\n+ * <p>Note that all element tests are performed by identity.\n+ *\n+ * @param <T> the element type.\n+ */\n+@Internal\n+public final class PrioritizedDeque<T> implements Iterable<T> {\n+\tprivate final Deque<T> deque = new ArrayDeque<>();\n+\tprivate int numPriorityElements;\n+\n+\t/**\n+\t * Adds a priority element to this deque, such that it will be polled after all existing priority elements but\n+\t * before any non-priority element.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void addPriorityElement(T element) {\n+\t\t// priority elements are rather rare and short-lived, so most of there are none\n+\t\tif (numPriorityElements == 0) {\n+\t\t\tdeque.addFirst(element);\n+\t\t} else if (numPriorityElements == deque.size()) {\n+\t\t\t// no non-priority elements\n+\t\t\tdeque.add(element);\n+\t\t} else {\n+\t\t\t// remove all priority elements\n+\t\t\tfinal ArrayDeque<T> priorPriority = new ArrayDeque<>(numPriorityElements);\n+\t\t\tfor (int index = 0; index < numPriorityElements; index++) {\n+\t\t\t\tpriorPriority.addFirst(deque.poll());\n+\t\t\t}\n+\t\t\tdeque.addFirst(element);\n+\t\t\t// readd them before the newly added element\n+\t\t\tfor (final T priorityEvent : priorPriority) {\n+\t\t\t\tdeque.addFirst(priorityEvent);\n+\t\t\t}\n+\t\t}\n+\t\tnumPriorityElements++;\n+\t}\n+\n+\t/**\n+\t * Adds a non-priority element to this deque, which will be polled last.\n+\t *\n+\t * @param element the element to add\n+\t */\n+\tpublic void add(T element) {\n+\t\tdeque.add(element);\n+\t}\n+\n+\t/**\n+\t * Convenience method for adding an element with optional priority and prior removal.\n+\t *\n+\t * @param element the element to add\n+\t * @param priority flag indicating if it's a priority or non-priority element\n+\t * @param alreadyContained flag that hints that the element is already in this deque, potentially as non-priority element.\n+\t */\n+\tpublic void add(T element, boolean priority, boolean alreadyContained) {", "originalCommit": "2da72acf839999a2d722325913e033c3b606f149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjYzNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489236637", "bodyText": "I'm moving it to the commit that starts using it.", "author": "AHeise", "createdAt": "2020-09-16T07:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0MDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjE0OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487046148", "bodyText": "nit: you've broken a comment reference (L125):\n#isAvailable(BufferAndBacklog)\n\nreplace it with javadoc's {@link}?", "author": "pnowojski", "createdAt": "2020-09-11T13:30:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTE2Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489245166", "bodyText": "I added an implNote in the javadoc.", "author": "AHeise", "createdAt": "2020-09-16T08:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0NjgwNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487046805", "bodyText": "or {@link DataType.NONE}", "author": "pnowojski", "createdAt": "2020-09-11T13:31:50Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0ODIyMA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487048220", "bodyText": "It's hard to say now, what does it mean it should be kept in sync, as they return very different things. On the other hand, this comment is valuable, so would be nice to keep it?", "author": "pnowojski", "createdAt": "2020-09-11T13:34:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -124,23 +127,22 @@ public boolean isAvailable() {\n \t}\n \n \t/**\n-\t * Check whether this reader is available or not (internal use, in sync with\n-\t * {@link #isAvailable()}, but slightly faster).\n+\t * Returns the {@link org.apache.flink.runtime.io.network.buffer.Buffer.DataType} of the next buffer in line.\n \t *\n-\t * <p>Returns true only if the next buffer is an event or the reader has both available\n+\t * <p>Returns the next data type only if the next buffer is an event or the reader has both available\n \t * credits and buffers.\n \t *\n \t * @param bufferAndBacklog\n \t * \t\tcurrent buffer and backlog including information about the next buffer\n+\t * @return the next data type if the next buffer can be pulled immediately or null\n \t */\n-\tprivate boolean isAvailable(BufferAndBacklog bufferAndBacklog) {\n+\tprivate Buffer.DataType getNextDataType(BufferAndBacklog bufferAndBacklog) {\n \t\t// BEWARE: this must be in sync with #isAvailable()!", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjczNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489246737", "bodyText": "I expanded the comment (now javadoc) to clearly state the contract.", "author": "AHeise", "createdAt": "2020-09-16T08:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA0ODIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MzcxMg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487053712", "bodyText": "nit: whitespace?", "author": "pnowojski", "createdAt": "2020-09-11T13:43:11Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java", "diffHunk": "@@ -109,14 +113,14 @@ private void setupInputChannels() {\n \t\t\t\t\tbufferBuilder.finish();\n \n \t\t\t\t\t// Call getCurrentBuffer to ensure size is set\n-\t\t\t\t\treturn Optional.of(new BufferAndAvailability(bufferConsumer.build(), moreAvailable, 0));\n+\t\t\t\t\treturn Optional.of(new BufferAndAvailability(bufferConsumer.build(), nextType, 0));\n \t\t\t\t} else if (input != null && input.isEvent()) {\n \t\t\t\t\tAbstractEvent event = input.getEvent();\n \t\t\t\t\tif (event instanceof EndOfPartitionEvent) {\n \t\t\t\t\t\tinputChannels[channelIndex].setReleased();\n \t\t\t\t\t}\n \n-\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), moreAvailable, 0));\n+\t\t\t\t\treturn Optional.of(new BufferAndAvailability(EventSerializer.toBuffer(event, false), nextType,\t0));", "originalCommit": "f16a0d23693561aaa75940915aae90f08d1e3633", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NjEyNQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487056125", "bodyText": "good to know that it returns something :)", "author": "pnowojski", "createdAt": "2020-09-11T13:46:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -290,6 +294,7 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \t/**\n \t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n \t * returns null in all other cases.\n+\t * @return", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2NTQ3MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487065471", "bodyText": "add java doc what does it return?", "author": "pnowojski", "createdAt": "2020-09-11T14:01:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -779,34 +820,56 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {\n \n+\t\tCompletableFuture<?> toNotifyPriority = null;\n \t\tCompletableFuture<?> toNotify = null;\n \n \t\tsynchronized (inputChannelsWithData) {\n-\t\t\tif (enqueuedInputChannelsWithData.get(channel.getChannelIndex())) {\n+\t\t\t// do not enqueue if the channel is currently polled because priority event could have been polled already\n+\t\t\t// let #waitAndGetNextData re-enqueue the channel correctly instead\n+\t\t\tif (priority && selectedChannel == channel) {\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\tavailableChannels = inputChannelsWithData.size();\n \n-\t\t\tinputChannelsWithData.add(channel);\n-\t\t\tenqueuedInputChannelsWithData.set(channel.getChannelIndex());\n+\t\t\tif (!queueChannelUnsafe(channel, priority)) {\n+\t\t\t\treturn;\n+\t\t\t}\n \n-\t\t\tif (availableChannels == 0) {\n+\t\t\tif (priority && inputChannelsWithData.getNumPriorityElements() == 1) {\n+\t\t\t\ttoNotifyPriority = priorityAvailabilityHelper.getUnavailableToResetAvailable();\n+\t\t\t}\n+\t\t\tif (inputChannelsWithData.size() == 1) {\n \t\t\t\tinputChannelsWithData.notifyAll();\n \t\t\t\ttoNotify = availabilityHelper.getUnavailableToResetAvailable();\n \t\t\t}\n \t\t}\n \n+\t\tif (toNotifyPriority != null) {\n+\t\t\ttoNotifyPriority.complete(null);\n+\t\t}\n \t\tif (toNotify != null) {\n \t\t\ttoNotify.complete(null);\n \t\t}\n \t}\n \n+\tprivate boolean queueChannelUnsafe(InputChannel channel, boolean priority) {", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA2ODQzNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487068437", "bodyText": "nit: extract everything below to:\nreturn Optional.of(processBufferOrEvent(nextOpt.get()));\n\n?", "author": "pnowojski", "createdAt": "2020-09-11T14:06:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -186,34 +203,47 @@ public boolean isFinished() {\n \tprivate Optional<InputWithData<IndexedInputGate, BufferOrEvent>> waitAndGetNextData(boolean blocking)\n \t\t\tthrows IOException, InterruptedException {\n \t\twhile (true) {\n-\t\t\tOptional<IndexedInputGate> inputGate = getInputGate(blocking);\n-\t\t\tif (!inputGate.isPresent()) {\n+\t\t\tOptional<IndexedInputGate> inputGateOpt = getInputGate(blocking);\n+\t\t\tif (!inputGateOpt.isPresent()) {\n \t\t\t\treturn Optional.empty();\n \t\t\t}\n+\t\t\tfinal IndexedInputGate inputGate = inputGateOpt.get();\n \n \t\t\t// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.\n \t\t\t// Do not poll the gate under inputGatesWithData lock, since this can trigger notifications\n \t\t\t// that could deadlock because of wrong locks taking order.\n-\t\t\tOptional<BufferOrEvent> bufferOrEvent = inputGate.get().pollNext();\n+\t\t\tOptional<BufferOrEvent> nextOpt = inputGate.pollNext();\n+\t\t\tif (!nextOpt.isPresent()) {\n+\t\t\t\tinputGate.getAvailableFuture().thenRun(() -> queueInputGate(inputGate, false));\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tfinal BufferOrEvent bufferOrEvent = nextOpt.get();", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MTI2Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487071263", "bodyText": "optional nit:\nextract toNotify and toNotifyPriority pair to some simple inner class `\npublic static class DataNotification() {\n  @Nullable\n  CompletableFuture<?> toNotifyPriority = null;\n  @Nullable\n  CompletableFuture<?> toNotify = null;\n\n  // two setters\n  setXYZ(...);\n\n  void complete() {\n \t\tif (toNotifyPriority != null) {\n\t\t\ttoNotifyPriority.complete(null);\n\t\t}\n\t\tif (toNotify != null) {\n\t\t\ttoNotify.complete(null);\n\t\t}\n  }\n}\n\nand re-use in UnionInputGate as well?", "author": "pnowojski", "createdAt": "2020-09-11T14:10:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -779,34 +820,56 @@ void triggerPartitionStateCheck(ResultPartitionID partitionId) {\n \t\t\t}));\n \t}\n \n-\tprivate void queueChannel(InputChannel channel) {\n-\t\tint availableChannels;\n+\tprivate void queueChannel(InputChannel channel, boolean priority) {\n \n+\t\tCompletableFuture<?> toNotifyPriority = null;", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU2OTk2MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492569960", "bodyText": "Extracted into GateNotificationHelper, please check if it's actually helping to reduce complexity.", "author": "AHeise", "createdAt": "2020-09-22T08:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA3MTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODk5NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487148994", "bodyText": "I haven't fully understood this part yet. Maybe let's sync later off-line?", "author": "pnowojski", "createdAt": "2020-09-11T16:15:10Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/UnionInputGate.java", "diffHunk": "@@ -89,6 +92,14 @@\n \t */\n \tprivate final int[] inputGateChannelIndexOffsets;\n \n+\t/**\n+\t * The channel from which is currently polled, which allows interleaving of\n+\t * {@link #queueInputGate(IndexedInputGate, boolean)} and {@link #pollNext()} (FLINK-12510 (Deadlock when reading from InputGates)).\n+\t */\n+\t@GuardedBy(\"inputGatesWithData\")\n+\t@Nullable\n+\tprivate IndexedInputGate currentInputGate;\n+", "originalCommit": "0ca6de6b7301067733c435729a078f5b5f0a89fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0NjAwNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r489746007", "bodyText": "Removed thanks to alternative fix of FLINK-12510 (see previous commit now).", "author": "AHeise", "createdAt": "2020-09-16T20:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0ODk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487150383", "bodyText": "could you elaborate a bit more in the commit message, what has been simplified, why and what are the benefits?", "author": "pnowojski", "createdAt": "2020-09-11T16:17:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BufferAvailabilityListener.java", "diffHunk": "@@ -34,11 +30,8 @@\n \tvoid notifyDataAvailable();\n \n \t/**\n-\t * Allows the listener to react to a priority event before it is added to the outgoing buffer queue.\n-\t *\n-\t * @return true if the event has been fully processed and should not be added to the buffer queue.\n+\t * Called when the first priority event is added to the head of the buffer queue.\n \t */\n-\tdefault boolean notifyPriorityEvent(BufferConsumer eventBufferConsumer) throws IOException {\n-\t\treturn false;\n+\tdefault void notifyPriorityEvent() {", "originalCommit": "5f1a1448b0654865a3dfd404b7027ad764790d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MDMzNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492570334", "bodyText": "Added a few thoughts. Let me know if it makes things clearer.", "author": "AHeise", "createdAt": "2020-09-22T08:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NTc0NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487965745", "bodyText": "This is an intermediate code that is being replaced later. Can you squash those changes?", "author": "pnowojski", "createdAt": "2020-09-14T14:17:32Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -147,6 +148,14 @@ else if (configuredInput instanceof SourceInputConfig) {\n \t\treturn anyInputAvailable;\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n+\t\treturn CompletableFuture.anyOf(\n+\t\t\tArrays.stream(inputProcessors)\n+\t\t\t\t.map(inputProcessor -> inputProcessor.taskInput.getPriorityEventAvailableFuture())\n+\t\t\t\t.toArray(CompletableFuture[]::new));", "originalCommit": "0b9fe248c39645e93e5210430417cef3bdc2ed6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MTk1Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492571952", "bodyText": "Commit is removed.", "author": "AHeise", "createdAt": "2020-09-22T08:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2OTcwOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487969708", "bodyText": "As we discussed online there is a bit of duplicated code here.", "author": "pnowojski", "createdAt": "2020-09-14T14:21:06Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -371,12 +371,16 @@ protected void processInput(MailboxDefaultAction.Controller controller) throws E\n \t */\n \t@VisibleForTesting\n \tCompletableFuture<?> getInputOutputJointFuture(InputStatus status) {\n+\t\tfinal CompletableFuture<?> priorityEventAvailableFuture = inputProcessor.getPriorityEventAvailableFuture();\n \t\tif (status == InputStatus.NOTHING_AVAILABLE && !recordWriter.isAvailable()) {\n-\t\t\treturn CompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture());\n+\t\t\treturn CompletableFuture.anyOf(\n+\t\t\t\tpriorityEventAvailableFuture,\n+\t\t\t\tCompletableFuture.allOf(inputProcessor.getAvailableFuture(), recordWriter.getAvailableFuture()));\n \t\t} else if (status == InputStatus.NOTHING_AVAILABLE) {\n-\t\t\treturn inputProcessor.getAvailableFuture();\n+\t\t\treturn CompletableFuture.anyOf(inputProcessor.getAvailableFuture(),\n+\t\t\t\tpriorityEventAvailableFuture);\n \t\t} else {\n-\t\t\treturn recordWriter.getAvailableFuture();\n+\t\t\treturn CompletableFuture.anyOf(priorityEventAvailableFuture, recordWriter.getAvailableFuture());", "originalCommit": "0b9fe248c39645e93e5210430417cef3bdc2ed6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjE2Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487986163", "bodyText": "Again I would point to the previous comment:\n#13228 (comment)\nCollection<Buffer> insertAsHeadAndGetInFlightData(checkpointBarrier)\n\nmight be a better option. (It might not, as I haven't tried to implement it)", "author": "pnowojski", "createdAt": "2020-09-14T14:41:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTQ3OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492591478", "bodyText": "Not relevant in the final version where the channel spills by itself (no return value on this method). I can make it clearer in the commit message if you want.", "author": "AHeise", "createdAt": "2020-09-22T09:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjQ4MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487986481", "bodyText": "This is again modifying code that I have already reviewed in the previous commit :(", "author": "pnowojski", "createdAt": "2020-09-14T14:41:39Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -173,50 +181,51 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tfinal int pos = buffers.getNumPriorityElements();\n \t\tbuffers.addPriorityElement(bufferConsumer);\n \n-\t\tboolean unalignedCheckpoint = isUnalignedCheckpoint(bufferConsumer);\n-\t\tif (unalignedCheckpoint) {\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n \t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n \t\t\tIterators.advance(iterator, pos + 1);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n \t\t\twhile (iterator.hasNext()) {\n \t\t\t\tBufferConsumer buffer = iterator.next();\n \n \t\t\t\tif (buffer.isBuffer()) {\n \t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\tbarrier.getId(),\n+\t\t\t\tsubpartitionInfo,\n+\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n \t\t}\n \t\treturn pos == 0;\n \t}\n \n-\tprivate boolean isUnalignedCheckpoint(BufferConsumer bufferConsumer) {\n-\t\tboolean unalignedCheckpoint;\n+\t@Nullable\n+\tprivate CheckpointBarrier parseCheckpointBarrier(BufferConsumer bufferConsumer) {", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NDIxNA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492484214", "bodyText": "Hm I have a hard time coming up with a better code structure. I could add checkpoint parsing and the if in addBuffer already in the first commit [FLINK-19026][network] Adding PrioritizedDeque and use it in PipelinedSubpartition.. Then this diff would be only about persisting itself.\nBut I was convinced that you would be confused why we need to parse the barrier at that commit.", "author": "AHeise", "createdAt": "2020-09-22T05:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4NjQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk5OTk0Mw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r487999943", "bodyText": "Are you sure it's going in the right direction this change? Previously spilling was explicit on demand, now it's happening magically (implicitly) inside LocalInputChannel.", "author": "pnowojski", "createdAt": "2020-09-14T14:59:01Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInput.java", "diffHunk": "@@ -232,19 +232,16 @@ public int getInputIndex() {\n \t\t\tChannelStateWriter channelStateWriter,\n \t\t\tlong checkpointId) throws IOException {\n \t\tfor (int channelIndex = 0; channelIndex < recordDeserializers.length; channelIndex++) {\n-\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n-\n-\t\t\t// Assumption for retrieving buffers = one concurrent checkpoint\n \t\t\tRecordDeserializer<?> deserializer = recordDeserializers[channelIndex];\n \t\t\tif (deserializer != null) {\n+\t\t\t\tfinal InputChannel channel = checkpointedInputGate.getChannel(channelIndex);\n+\n \t\t\t\tchannelStateWriter.addInputData(\n \t\t\t\t\tcheckpointId,\n \t\t\t\t\tchannel.getChannelInfo(),\n \t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n \t\t\t\t\tdeserializer.getUnconsumedBuffer());\n \t\t\t}\n-\n-\t\t\tcheckpointedInputGate.spillInflightBuffers(checkpointId, channelIndex, channelStateWriter);", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NzA3OQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492487079", "bodyText": "We discussed offline, but let me summarize the main point. When spilling in main thread, buffers would be spilled rather late as you pointed out initially.\nOne solution is to trigger the channel spilling in task thread as soon as possible and then resume spilling from netty until barrier arrives. However, that results in a complex threading model with lots of race condition as we found out in the version in master.\nAnother solution is to spill in task thread and use any poll to discover new buffers and spill them. It's slightly slower and also requires lots of internal knowledge at the Unaligner about the channels to work well (mark all spilled channels). It's probably also suboptimal as new buffers are usually enqueued right after the head is polled, so one buffer is enqueued in the channel but not persisted until the new head is polled.\nThe proposed solution is to spill in netty thread entirely. That's the fastest possible solution with an comparably easy threading model. Downside is the added complexity on channel-side, but the general idea is that upstream and downstream side of a channel is now self-contained.", "author": "AHeise", "createdAt": "2020-09-22T05:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk5OTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMDI2MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488010260", "bodyText": "Are you spilling only on polling the buffer? (I think RemoteInputChannel is working better in this regard)", "author": "pnowojski", "createdAt": "2020-09-14T15:11:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -210,15 +221,25 @@ public void spillInflightBuffers(long checkpointId, ChannelStateWriter channelSt\n \t\t}\n \n \t\tBuffer buffer = next.buffer();\n-\t\tCheckpointBarrier notifyReceivedBarrier = parseCheckpointBarrierOrNull(buffer);\n-\t\tif (notifyReceivedBarrier != null) {\n-\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t} else if (receivedCheckpointId < lastRequestedCheckpointId && buffer.isBuffer()) {\n-\t\t\tinputGate.getBufferReceivedListener().notifyBufferReceived(buffer.retainBuffer(), channelInfo);\n-\t\t}\n \n \t\tnumBytesIn.inc(buffer.getSize());\n \t\tnumBuffersIn.inc();\n+\t\tif (buffer.isBuffer()) {\n+\t\t\tfor (final long barrierId : pendingCheckpointBarriers) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MzgwOQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492593809", "bodyText": "LocalInputChannel only spills when it awaits barrier. So it spills the buffer on first sight and it cannot be better on downsteam level. We could of course also move spilling lingering buffers to the upstream. It might also be an improvement for later, but it adds quite a bit of complexity as barriers also need to be propagated upstream.", "author": "AHeise", "createdAt": "2020-09-22T09:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMDI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxODQ3NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488018474", "bodyText": "I don't think it's worth complicating the code with support for multiple concurrent checkpoints. It's not likely to be implemented soon, if ever.", "author": "pnowojski", "createdAt": "2020-09-14T15:22:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -89,17 +96,15 @@\n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/**\n-\t * The latest already triggered checkpoint id which would be updated during\n-\t * {@link #spillInflightBuffers(long, ChannelStateWriter)}.\n-\t */\n-\t@GuardedBy(\"receivedBuffers\")\n-\tprivate long lastRequestedCheckpointId = -1;\n+\tprivate final BufferManager bufferManager;\n \n-\t/** The current received checkpoint id from the network. */\n-\tprivate long receivedCheckpointId = -1;\n+\t/** Stores #overtaken buffers when a checkpoint barrier is received before task thread started checkpoint. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Map<Long, Integer> numBuffersOvertaken = new HashMap<>();\n \n-\tprivate final BufferManager bufferManager;\n+\t/** All started checkpoints where a barrier has not been received yet. */\n+\t@GuardedBy(\"receivedBuffers\")\n+\tprivate Deque<Long> pendingCheckpointBarriers = new ArrayDeque<>(2);", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTMxMw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492595313", "bodyText": "Changed it to support only one concurrent checkpoint. I also extracted the whole logic into one helper class that can be used by both LocalInputChannel and RemoteInputChannel (with syncrhonization).", "author": "AHeise", "createdAt": "2020-09-22T09:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxODQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyMDgyOQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488020829", "bodyText": "This method has grown too large.", "author": "pnowojski", "createdAt": "2020-09-14T15:25:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NTQ3Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492595477", "bodyText": "Much smaller now thanks to the helper class.", "author": "AHeise", "createdAt": "2020-09-22T09:26:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyMDgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNzc3NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488027775", "bodyText": "nitty nit: writeInFlightBuffers? (write as Romand picked writer for the \"spilling\" nomenclature)", "author": "pnowojski", "createdAt": "2020-09-14T15:32:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -454,42 +431,106 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n \t\t\t\t}\n \n \t\t\t\twasEmpty = receivedBuffers.isEmpty();\n-\t\t\t\treceivedBuffers.add(buffer);\n \n-\t\t\t\tif (listener != null && buffer.isBuffer() && receivedCheckpointId < lastRequestedCheckpointId) {\n-\t\t\t\t\tnotifyReceivedBuffer = buffer.retainBuffer();\n+\t\t\t\tAbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\t\tif (priorityEvent != null) {\n+\t\t\t\t\treceivedBuffers.addPriorityElement(buffer);\n+\t\t\t\t\tfinal int pos = receivedBuffers.getNumPriorityElements();\n+\t\t\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\t\t\tfinal long barrierId = ((CheckpointBarrier) priorityEvent).getId();\n+\t\t\t\t\t\t// don't spill future buffers for this checkpoint\n+\t\t\t\t\t\tif (!pendingCheckpointBarriers.remove(barrierId)) {\n+\t\t\t\t\t\t\t// checkpoint was not yet started by task thread,\n+\t\t\t\t\t\t\t// so remember the numbers of buffers to spill for the time when it will be started\n+\t\t\t\t\t\t\tnumBuffersOvertaken.put(barrierId, receivedBuffers.size() - pos);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tfirstPriorityEvent = pos == 1;\n \t\t\t\t} else {\n-\t\t\t\t\tnotifyReceivedBuffer = null;\n+\t\t\t\t\treceivedBuffers.add(buffer);\n+\t\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\t\tfor (final long checkpointId : pendingCheckpointBarriers) {\n+\t\t\t\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\t\t\t\tcheckpointId,\n+\t\t\t\t\t\t\t\tchannelInfo,\n+\t\t\t\t\t\t\t\tsequenceNumber,\n+\t\t\t\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tnotifyReceivedBarrier = listener != null ? parseCheckpointBarrierOrNull(buffer) : null;\n \t\t\t}\n \t\t\trecycleBuffer = false;\n \n \t\t\t++expectedSequenceNumber;\n \n+\t\t\tif (firstPriorityEvent) {\n+\t\t\t\tnotifyPriorityEvent();\n+\t\t\t}\n \t\t\tif (wasEmpty) {\n \t\t\t\tnotifyChannelNonEmpty();\n \t\t\t}\n \n \t\t\tif (backlog >= 0) {\n \t\t\t\tonSenderBacklog(backlog);\n \t\t\t}\n-\n-\t\t\tif (notifyReceivedBarrier != null) {\n-\t\t\t\treceivedCheckpointId = notifyReceivedBarrier.getId();\n-\t\t\t\tif (notifyReceivedBarrier.isCheckpoint()) {\n-\t\t\t\t\tlistener.notifyBarrierReceived(notifyReceivedBarrier, channelInfo);\n-\t\t\t\t}\n-\t\t\t} else if (notifyReceivedBuffer != null) {\n-\t\t\t\tlistener.notifyBufferReceived(notifyReceivedBuffer, channelInfo);\n-\t\t\t}\n \t\t} finally {\n \t\t\tif (recycleBuffer) {\n \t\t\t\tbuffer.recycleBuffer();\n \t\t\t}\n \t\t}\n \t}\n \n+\t/**\n+\t * Spills all queued buffers on checkpoint start. If barrier has already been received (and reordered), spill only\n+\t * the overtaken buffers.\n+\t */\n+\tpublic void checkpointStarted(CheckpointBarrier barrier) {\n+\t\tcheckState(channelStateWriter != null, \"Channel state writer not injected\");\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tfinal Integer numBuffers = numBuffersOvertaken.get(barrier.getId());\n+\t\t\tif (numBuffers != null) {\n+\t\t\t\t// already received barrier before the task thread picked up the barrier of this or another channel\n+\t\t\t\tspillBuffers(barrier.getId(), numBuffers);\n+\t\t\t} else {\n+\t\t\t\t// barrier not yet received, spill all current and future buffers\n+\t\t\t\tspillBuffers(barrier.getId(), receivedBuffers.getNumUnprioritizedElements());\n+\t\t\t\tpendingCheckpointBarriers.add(barrier.getId());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void checkpointStopped(long checkpointId) {\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\tnumBuffersOvertaken.remove(checkpointId);\n+\t\t\tpendingCheckpointBarriers.remove(checkpointId);\n+\t\t}\n+\t}\n+\n+\tprivate void spillBuffers(long checkpointId, int numBuffers) {", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NjQ2Mg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492596462", "bodyText": "I added a helper class ChannelStatePersister and used persist everywhere to have a clear separation of the two names. Persister is more on the logical level and Writer on the physical implementation.", "author": "AHeise", "createdAt": "2020-09-22T09:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyNzc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyODEyMg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488028122", "bodyText": "\u2764\ufe0f", "author": "pnowojski", "createdAt": "2020-09-14T15:33:20Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -314,6 +315,21 @@ protected StreamTask(\n \t\t}\n \n \t\tthis.channelIOExecutor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(\"channel-state-unspilling\"));\n+\n+\t\tinjectChannelStateWriterIntoChannels();\n+\t}\n+\n+\tprivate void injectChannelStateWriterIntoChannels() {\n+\t\tfinal Environment env = getEnvironment();\n+\t\tfinal ChannelStateWriter channelStateWriter = subtaskCheckpointCoordinator.getChannelStateWriter();\n+\t\tfor (final InputGate gate : env.getAllInputGates()) {\n+\t\t\tgate.setChannelStateWriter(channelStateWriter);\n+\t\t}\n+\t\tfor (ResultPartitionWriter writer : env.getAllWriters()) {\n+\t\t\tif (writer instanceof ChannelStateHolder) {\n+\t\t\t\t((ChannelStateHolder) writer).setChannelStateWriter(channelStateWriter);\n+\t\t\t}\n+\t\t}", "originalCommit": "d06c7130a74dc1259994a7abb91296a6893361c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4NzMxNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492487317", "bodyText": "Happy for any other suggestion. I think the cast itself is in line with recent changes done by Stephan.\nThe proper solution would be to inject in ctor but that will not happen until we merge runtime and streaming.", "author": "AHeise", "createdAt": "2020-09-22T05:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyODEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyOTYwNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488029606", "bodyText": "Is the code in a working state before:\n\nRemove synchronization from CheckpointBarrierUnaligner.\n\ncommit? It looks like data are spilled in two places, right?", "author": "pnowojski", "createdAt": "2020-09-14T15:35:22Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -22,13 +22,10 @@\n import org.apache.flink.annotation.VisibleForTesting;", "originalCommit": "6e3eafcdf62ecbe7e67f2b50b66f12a3b56af99e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4OTI1OA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492489258", "bodyText": "I admit that it's an awkward cut.\nHowever, it's only spilled in one place as the BufferReceivedListener methods are effectively not called in the previous commits anymore. I will make a later pass to see that all tests pass though.", "author": "AHeise", "createdAt": "2020-09-22T05:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAyOTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMTQzOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488031438", "bodyText": "A minor rebasing/squashing mistake?", "author": "pnowojski", "createdAt": "2020-09-14T15:37:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskmanager/InputGateWithMetrics.java", "diffHunk": "@@ -122,8 +121,8 @@ public void close() throws Exception {\n \t}\n \n \t@Override\n-\tpublic void registerBufferReceivedListener(BufferReceivedListener listener) {\n-\t\tinputGate.registerBufferReceivedListener(listener);\n+\tpublic CompletableFuture<?> getPriorityEventAvailableFuture() {\n+\t\treturn inputGate.getPriorityEventAvailableFuture();", "originalCommit": "d47325cba6cafc4b69e300f56261f6c8157d7cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjY1NQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488032655", "bodyText": "Why has this test and CheckpointBarrierTrackerTest.java changed in this commit? Rebasing/squashing mistake, or am I missing something about this commit (I thought it's a pure clean up without functional changes).", "author": "pnowojski", "createdAt": "2020-09-14T15:39:41Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierAlignerTestBase.java", "diffHunk": "@@ -369,9 +369,7 @@ public void testMissingCancellationBarriers() throws Exception {\n \t\tinputGate = createBarrierBuffer(2, sequence, validator);", "originalCommit": "d47325cba6cafc4b69e300f56261f6c8157d7cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ4ODcwMg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492488702", "bodyText": "A side-effect of this commit is that all events are handed over from CheckpointedInputGate to StreamTaskNetworkInput and break up the poll loop. However, since events are rare, it should have no visible impact on the throughput.\n\nThe changes to the tests are now handling the additionally emitted events. Imho tests are easier to read now (no magically disappearing buffers in the sequence).", "author": "AHeise", "createdAt": "2020-09-22T05:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzMjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNzg5Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488037897", "bodyText": "nit: add StreamMultipleInputProcessor to the mail's name?", "author": "pnowojski", "createdAt": "2020-09-14T15:47:05Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);\n+\t\t\t}, \"priority event {}\", index);", "originalCommit": "a6a2d36afcce1758e885f0751359ccf035ae2378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMTA4MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492601080", "bodyText": "Commit removed; on CheckpointedInputGate, I'm adding the gate.toString().", "author": "AHeise", "createdAt": "2020-09-22T09:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzNzg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDAxMA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488040010", "bodyText": "Can not you maybe handle the priority message directly here, in this mail? Instead of relaying on the processDefaultAction to pick this up?\n(I'm asking/loudly thinking)", "author": "pnowojski", "createdAt": "2020-09-14T15:50:08Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/StreamMultipleInputProcessor.java", "diffHunk": "@@ -171,10 +183,36 @@ public InputStatus processInput() throws Exception {\n \t\t}\n \n \t\tInputStatus inputStatus = inputProcessors[readingInputIndex].processInput();\n+\t\tupdatePriorityAvailability();\n \t\tcheckFinished(inputStatus, readingInputIndex);\n \t\treturn inputSelectionHandler.updateStatus(inputStatus, readingInputIndex);\n \t}\n \n+\tprivate void updatePriorityAvailability() {\n+\t\tif (lastPriorityInputIndex != InputSelection.NONE_AVAILABLE) {\n+\t\t\tfinal CompletableFuture<?> priorityEventAvailableFuture =\n+\t\t\t\tinputProcessors[lastPriorityInputIndex].taskInput.getPriorityEventAvailableFuture();\n+\t\t\t// no more priority events for the input\n+\t\t\tif (!priorityEventAvailableFuture.isDone()) {\n+\t\t\t\tprioritySelectionHandler.setUnavailableInput(lastPriorityInputIndex);\n+\t\t\t\tif (!prioritySelectionHandler.isAnyInputAvailable()) {\n+\t\t\t\t\tpriorityAvailability.resetUnavailable();\n+\t\t\t\t}\n+\t\t\t\tpriorityEventAvailableFuture.thenRun(onPriorityEvent(lastPriorityInputIndex));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Runnable onPriorityEvent(int index) {\n+\t\treturn () -> {\n+\t\t\t// set the priority flag in a mail before notifying StreamTask of availability\n+\t\t\tmainMailboxExecutor.execute(() -> {\n+\t\t\t\tprioritySelectionHandler.setAvailableInput(index);\n+\t\t\t\tpriorityAvailability.getUnavailableToResetAvailable().complete(null);", "originalCommit": "a6a2d36afcce1758e885f0751359ccf035ae2378", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMTU5NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492601594", "bodyText": "Moved it even further up towards CheckpointedInputGate. At this point, we need to make sure that a priority event is really at the top (hence the optimistic lock protocol for notification).", "author": "AHeise", "createdAt": "2020-09-22T09:37:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MDAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MzU0MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r488043540", "bodyText": "What's the story behind this change?\n\nit seems it differs only by a single line numBarriersReceived = 0;, so at the very least we should deduplicate some code here\ncan you explain what's the functional change?\naren't we missing a unit test for that? It would help answer point 2., and if there was a bug discovered in e2e test, it would be nice to have a faster unit test for that as well.", "author": "pnowojski", "createdAt": "2020-09-14T15:55:10Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -113,7 +113,11 @@ public void processBarrier(CheckpointBarrier barrier, InputChannelInfo channelIn\n \n \t\t\tif (++numBarriersReceived == numOpenChannels) {\n \t\t\t\tallBarriersReceivedFuture.complete(null);\n-\t\t\t\tresetPendingCheckpoint(barrierId);\n+\t\t\t\tfor (final InputGate gate : inputGates) {\n+\t\t\t\t\tfor (int index = 0, numChannels = gate.getNumberOfInputChannels(); index < numChannels; index++) {\n+\t\t\t\t\t\tgate.getChannel(index).checkpointStopped(currentCheckpointId);\n+\t\t\t\t\t}\n+\t\t\t\t}", "originalCommit": "fa3e495b6ba201769d908adea420e4944ddd7643", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjQ0Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492602447", "bodyText": "Sorry that was just a test commit to see if the stuck e2e failed because of this change. I removed it. The original change is covered by a few unit tests already.", "author": "AHeise", "createdAt": "2020-09-22T09:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MzU0MA=="}], "type": "inlineReview"}, {"oid": "4fb30d405835251b799f70e28a39f31fb9678700", "url": "https://github.com/apache/flink/commit/4fb30d405835251b799f70e28a39f31fb9678700", "message": "[temp] Debug e2e", "committedDate": "2020-09-16T06:01:16Z", "type": "forcePushed"}, {"oid": "a1fb1c3114305ed5fce898dfcc03abed4d6963d4", "url": "https://github.com/apache/flink/commit/a1fb1c3114305ed5fce898dfcc03abed4d6963d4", "message": "[FLINK-19026][network] Revert FLINK-12510.", "committedDate": "2020-09-16T06:01:16Z", "type": "forcePushed"}, {"oid": "834c28da93d4b24e562e017979b483e288db02a2", "url": "https://github.com/apache/flink/commit/834c28da93d4b24e562e017979b483e288db02a2", "message": "[FLINK-19026][task] Pulling from input with priority events first.", "committedDate": "2020-09-16T21:14:05Z", "type": "forcePushed"}, {"oid": "a22657562a42dda270f89c176e5c260ee73c6698", "url": "https://github.com/apache/flink/commit/a22657562a42dda270f89c176e5c260ee73c6698", "message": "fixup! [FLINK-19026][network] Moving priority event handling from BufferReceivedListener to CheckpointedInputGate.", "committedDate": "2020-09-21T09:40:43Z", "type": "forcePushed"}, {"oid": "f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "url": "https://github.com/apache/flink/commit/f23e2a14cbbbf4c7ced3d66eea8073eb1d8c4acc", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-21T22:50:12Z", "type": "forcePushed"}, {"oid": "8f18616dbfce97d0fd6e1f442f7a3db892a6cf1e", "url": "https://github.com/apache/flink/commit/8f18616dbfce97d0fd6e1f442f7a3db892a6cf1e", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T05:08:46Z", "type": "forcePushed"}, {"oid": "5e442492671ac6d0557e8e8e158a693aaec4daa4", "url": "https://github.com/apache/flink/commit/5e442492671ac6d0557e8e8e158a693aaec4daa4", "message": "fix generalize", "committedDate": "2020-09-22T07:46:19Z", "type": "forcePushed"}, {"oid": "1a86b34a3cd22d0ae34d16e9fa96036650dd6323", "url": "https://github.com/apache/flink/commit/1a86b34a3cd22d0ae34d16e9fa96036650dd6323", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T08:19:19Z", "type": "forcePushed"}, {"oid": "35673098a49bdf2c6bc665cf8ec2abbf71fdc546", "url": "https://github.com/apache/flink/commit/35673098a49bdf2c6bc665cf8ec2abbf71fdc546", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:32:11Z", "type": "forcePushed"}, {"oid": "7b29e64308905545d3c9bab68c1322e69d89d23d", "url": "https://github.com/apache/flink/commit/7b29e64308905545d3c9bab68c1322e69d89d23d", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:45:45Z", "type": "forcePushed"}, {"oid": "a76104444a39646376ec0d6d5f761ec8cbcbe868", "url": "https://github.com/apache/flink/commit/a76104444a39646376ec0d6d5f761ec8cbcbe868", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:52:48Z", "type": "forcePushed"}, {"oid": "355fecafd9215ef93471360f84be51e0520ce1bc", "url": "https://github.com/apache/flink/commit/355fecafd9215ef93471360f84be51e0520ce1bc", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T10:56:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyOTg1MQ==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492829851", "bodyText": "nit: move to a separate processCheckpointBarrier method?\nor maybe also one step further:\n\tprivate boolean addBuffer(BufferConsumer bufferConsumer) {\n\t\tassert Thread.holdsLock(buffers);\t\n\t\tif (bufferConsumer.getDataType().hasPriority()) {\n\t\t\tprocessPriorityBuffer(bufferConsumer);\n\t\t}\n\t\tbuffers.add(bufferConsumer);\n\t\treturn false;\n\t}\n\nto highlight that on the hot path, (without priority) we are skipping this whole code?", "author": "pnowojski", "createdAt": "2020-09-22T15:27:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -177,32 +187,53 @@ private boolean addBuffer(BufferConsumer bufferConsumer) {\n \t\t\tbuffers.add(bufferConsumer);\n \t\t\treturn false;\n \t\t}\n-\t\tcheckState(inflightBufferSnapshot.isEmpty(), \"Supporting only one concurrent checkpoint in unaligned \" +\n-\t\t\t\"checkpoints\");\n \n \t\tbuffers.addPriorityElement(bufferConsumer);\n \t\tfinal int numPriorityElements = buffers.getNumPriorityElements();\n \n-\t\t// Meanwhile prepare the collection of in-flight buffers which would be fetched in the next step later.\n-\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n-\t\tIterators.advance(iterator, numPriorityElements);\n-\t\twhile (iterator.hasNext()) {\n-\t\t\tBufferConsumer buffer = iterator.next();\n-\n-\t\t\tif (buffer.isBuffer()) {\n-\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n-\t\t\t\t\tinflightBufferSnapshot.add(bc.build());\n+\t\tCheckpointBarrier barrier = parseCheckpointBarrier(bufferConsumer);\n+\t\tif (barrier != null) {\n+\t\t\tcheckState(\n+\t\t\t\tbarrier.getCheckpointOptions().isUnalignedCheckpoint(),\n+\t\t\t\t\"Only unaligned checkpoints should be priority events\");\n+\t\t\tfinal Iterator<BufferConsumer> iterator = buffers.iterator();\n+\t\t\tIterators.advance(iterator, numPriorityElements);\n+\t\t\tList<Buffer> inflightBuffers = new ArrayList<>();\n+\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\tBufferConsumer buffer = iterator.next();\n+\n+\t\t\t\tif (buffer.isBuffer()) {\n+\t\t\t\t\ttry (BufferConsumer bc = buffer.copy()) {\n+\t\t\t\t\t\tinflightBuffers.add(bc.build());\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t\tif (!inflightBuffers.isEmpty()) {\n+\t\t\t\tchannelStateWriter.addOutputData(\n+\t\t\t\t\tbarrier.getId(),\n+\t\t\t\t\tsubpartitionInfo,\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tinflightBuffers.toArray(new Buffer[0]));\n+\t\t\t}\n \t\t}", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTcwNw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492835707", "bodyText": "This doesn't seem to fit in the ChannelStatePersister interface. Maybe move those methods somewhere else? As static methods to InputChannel?\nAlso, aren't they duplicating the same logic as somewhere on the output sides?", "author": "pnowojski", "createdAt": "2020-09-22T15:35:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -361,4 +360,89 @@ public String toString() {\n \t\t\t\t'}';\n \t\t}\n \t}\n+\n+\t/**\n+\t * Helper class for persisting channel state via {@link ChannelStateWriter}.\n+\t */\n+\t@NotThreadSafe\n+\tprotected final class ChannelStatePersister {\n+\t\tprivate static final long CHECKPOINT_COMPLETED = -1;\n+\n+\t\tprivate static final long BARRIER_RECEIVED = -2;\n+\n+\t\t/** All started checkpoints where a barrier has not been received yet. */\n+\t\tprivate long pendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\n+\t\t/** Writer must be initialized before usage. {@link #startPersisting(long, List)} enforces this invariant. */\n+\t\t@Nullable\n+\t\tprivate final ChannelStateWriter channelStateWriter;\n+\n+\t\tpublic ChannelStatePersister(@Nullable ChannelStateWriter channelStateWriter) {\n+\t\t\tthis.channelStateWriter = channelStateWriter;\n+\t\t}\n+\n+\t\tprotected void startPersisting(long barrierId, List<Buffer> knownBuffers) {\n+\t\t\tcheckState(isInitialized(), \"Channel state writer not injected\");\n+\n+\t\t\tif (pendingCheckpointBarrierId != BARRIER_RECEIVED) {\n+\t\t\t\tpendingCheckpointBarrierId = barrierId;\n+\t\t\t}\n+\t\t\tif (knownBuffers.size() > 0) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tbarrierId,\n+\t\t\t\t\tchannelInfo,\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.fromList(knownBuffers, Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean isInitialized() {\n+\t\t\treturn channelStateWriter != null;\n+\t\t}\n+\n+\t\tprotected void stopPersisting() {\n+\t\t\tpendingCheckpointBarrierId = CHECKPOINT_COMPLETED;\n+\t\t}\n+\n+\t\tprotected void maybePersist(Buffer buffer) {\n+\t\t\tif (pendingCheckpointBarrierId >= 0 && buffer.isBuffer()) {\n+\t\t\t\tchannelStateWriter.addInputData(\n+\t\t\t\t\tpendingCheckpointBarrierId,\n+\t\t\t\t\tgetChannelInfo(),\n+\t\t\t\t\tChannelStateWriter.SEQUENCE_NUMBER_UNKNOWN,\n+\t\t\t\t\tCloseableIterator.ofElement(buffer.retainBuffer(), Buffer::recycleBuffer));\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected boolean checkForBarrier(Buffer buffer) throws IOException {\n+\t\t\tfinal AbstractEvent priorityEvent = parsePriorityEvent(buffer);\n+\t\t\tif (priorityEvent instanceof CheckpointBarrier) {\n+\t\t\t\tpendingCheckpointBarrierId = BARRIER_RECEIVED;\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Parses the buffer as an event and returns the {@link CheckpointBarrier} if the event is indeed a barrier or\n+\t\t * returns null in all other cases.\n+\t\t */\n+\t\t@Nullable\n+\t\tprotected AbstractEvent parsePriorityEvent(Buffer buffer) throws IOException {\n+\t\t\tif (buffer.isBuffer() || !buffer.getDataType().hasPriority()) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\n+\t\t\tAbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());\n+\t\t\t// reset the buffer because it would be deserialized again in SingleInputGate while getting next buffer.\n+\t\t\t// we can further improve to avoid double deserialization in the future.\n+\t\t\tbuffer.setReaderIndex(0);\n+\t\t\treturn event;\n+\t\t}", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAyNTQ2NA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493025464", "bodyText": "It's only used in this class and thus I inlined it. As is, it really looks like an interface of the Persister.\nThere is similar code for BufferConsumer on output side, but the implementation is too different to align (copy buffer vs. reader index reset, different EventSerializer.fromBuffer overloads).", "author": "AHeise", "createdAt": "2020-09-22T20:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNTcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNjkwOA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492836908", "bodyText": "why was this test removed?", "author": "pnowojski", "createdAt": "2020-09-22T15:36:39Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/StreamTaskNetworkInputTest.java", "diffHunk": "@@ -120,67 +112,10 @@ public void testNoDataProcessedAfterCheckpointBarrier() throws Exception {\n \t\tassertEquals(0, output.getNumberOfEmittedRecords());\n \t}\n \n-\t@Test\n-\tpublic void testSnapshotWithTwoInputGates() throws Exception {", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNTg2Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493035866", "bodyText": "I added this test for FLINK-18139 - input gate index issues in Unaligner#hasInflightData, which is called by StreamTaskNetworkInput, hence the test here.\nHowever, in this commit, hasInflightData is removed. Spilling is fully encapsulated in InputChannel + CheckpointBarrierUnaligner/CheckpointedInputGate and this interaction is already covered in tests at CheckpointBarrierUnalignerTest.", "author": "AHeise", "createdAt": "2020-09-22T21:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzNjkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODMwNg==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492838306", "bodyText": "Can you double check if indeed all of those test should be removed? I don't see how things like testPartitionNotFoundExceptionWhileGetNextBuffer should be related to this commit/PR?", "author": "pnowojski", "createdAt": "2020-09-22T15:38:24Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateTest.java", "diffHunk": "@@ -812,242 +788,13 @@ public void testQueuedBuffers() throws Exception {\n \t\t}\n \t}\n \n-\t@Test\n-\tpublic void testBufferReceivedListener() throws Exception {", "originalCommit": "51273f0b1235e5f095014ef1243d6776e297e225", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzOTg1Ng==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493039856", "bodyText": "Good catch, my intent was to delete testBufferReceivedListener and testPartitionNotFoundExceptionWhileGetNextBuffer but not the test in between them.\ntestBufferReceivedListener tests BufferReceivedListener which this commits renders useless (and is later removed).\ntestPartitionNotFoundExceptionWhileGetNextBuffer tests concurrent spilling of lingering buffers and receiving of such lingering buffers. Both now happens in the same thread, so the test does not make any sense.", "author": "AHeise", "createdAt": "2020-09-22T21:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzODMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MzM4Nw==", "url": "https://github.com/apache/flink/pull/13228#discussion_r492843387", "bodyText": "add checkState(!inputGate.getPriorityEventAvailableFuture().isDone())?", "author": "pnowojski", "createdAt": "2020-09-22T15:45:08Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointedInputGate.java", "diffHunk": "@@ -62,9 +65,37 @@\n \t */\n \tpublic CheckpointedInputGate(\n \t\t\tInputGate inputGate,\n-\t\t\tCheckpointBarrierHandler barrierHandler) {\n+\t\t\tCheckpointBarrierHandler barrierHandler,\n+\t\t\tMailboxExecutor mailboxExecutor) {\n \t\tthis.inputGate = inputGate;\n \t\tthis.barrierHandler = barrierHandler;\n+\t\tthis.mailboxExecutor = mailboxExecutor;\n+\n+\t\twaitForPriorityEvents(inputGate, mailboxExecutor);\n+\t}\n+\n+\t/**\n+\t * Eagerly pulls and processes all priority events. Must be called from task thread.\n+\t *\n+\t * <p>Basic assumption is that no priority event needs to be handled by the {@link StreamTaskNetworkInput}.\n+\t */\n+\tprivate void processPriorityEvents() throws IOException, InterruptedException {\n+\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n+\t\tif (inputGate.getPriorityEventAvailableFuture().isDone()) {\n+\t\t\t// process as many priority events as possible\n+\t\t\twhile (pollNext().map(BufferOrEvent::morePriorityEvents).orElse(false)) {\n+\t\t\t}\n+\t\t}\n+", "originalCommit": "69cd2be36ce52a0de0be43602ebce454644897a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0NDQ3MA==", "url": "https://github.com/apache/flink/pull/13228#discussion_r493044470", "bodyText": "Good idea, I solved it in the following way:\n\t\t// check if the priority event is still not processed (could have been pulled before mail was being executed)\n\t\tboolean hasPriorityEvent = inputGate.getPriorityEventAvailableFuture().isDone();\n\t\twhile (hasPriorityEvent) {\n\t\t\t// process as many priority events as possible\n\t\t\tfinal Optional<BufferOrEvent> bufferOrEventOpt = pollNext();\n\t\t\tbufferOrEventOpt.ifPresent(bufferOrEvent ->\n\t\t\t\tcheckState(bufferOrEvent.hasPriority(), \"Should only poll priority events\"));\n\t\t\thasPriorityEvent = bufferOrEventOpt.map(BufferOrEvent::morePriorityEvents).orElse(false);\n\t\t}\n\ncheckState(!inputGate.getPriorityEventAvailableFuture().isDone()) might be failing if netty receives a new priority event and triggers this available future while the task thread polled the last priority event. This case should happen quite often when the first barrier arrives (at that time the only priority event, morePriorityEvents = false) and triggers the whole checkpointing process. The second barrier would then complete the getPriorityEventAvailableFuture causing a more or less immediate re-execution of this method.", "author": "AHeise", "createdAt": "2020-09-22T21:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0MzM4Nw=="}], "type": "inlineReview"}, {"oid": "74094b3c0206de0bad49bdb7526534a8c43a5934", "url": "https://github.com/apache/flink/commit/74094b3c0206de0bad49bdb7526534a8c43a5934", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T20:09:44Z", "type": "forcePushed"}, {"oid": "ea5c6962348cf666b6b787eb7fad0cbec497b9af", "url": "https://github.com/apache/flink/commit/ea5c6962348cf666b6b787eb7fad0cbec497b9af", "message": "fixup! [FLINK-19026][network] Moving priority event handling from BufferReceivedListener to CheckpointedInputGate.", "committedDate": "2020-09-22T21:23:28Z", "type": "forcePushed"}, {"oid": "ef87978fc0d3da0134ccf57eb144aeb456a5d345", "url": "https://github.com/apache/flink/commit/ef87978fc0d3da0134ccf57eb144aeb456a5d345", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-22T21:23:58Z", "type": "forcePushed"}, {"oid": "0f60b006208d03b78878334579ef2906951d9e36", "url": "https://github.com/apache/flink/commit/0f60b006208d03b78878334579ef2906951d9e36", "message": "[hotfix][network] Annotate NetworkSequenceViewReader#getNextBuffer as Nullable.", "committedDate": "2020-09-23T09:47:39Z", "type": "commit"}, {"oid": "3af229cf0709fecf357b9c91369c9f3e64c0696b", "url": "https://github.com/apache/flink/commit/3af229cf0709fecf357b9c91369c9f3e64c0696b", "message": "[FLINK-19338][connectors/common] Remove null-check from SourceCoordinatorContext#unregisterSourceReader.\n\nIf an error happens during startup, the reader may not be registered (yet), but cleanup is triggered anyways.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "2078a6dcf165d4ed7769af2b5d67697c4cd2a19c", "url": "https://github.com/apache/flink/commit/2078a6dcf165d4ed7769af2b5d67697c4cd2a19c", "message": "[hotfix][datastream] Chaining serialization exception during job graph generation.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "6a1cb4ca50c2629e9ae10b0d0c73414db7c574c2", "url": "https://github.com/apache/flink/commit/6a1cb4ca50c2629e9ae10b0d0c73414db7c574c2", "message": "[FLINK-19026][network] Adding priority events to buffer data type.\n\nIt generalizes the current special treatment of unaligned checkpoints and will allow a consistent treatment of priority events on both input and output.\nThe new type facilitates detection of priority events without the need to inspect the contents of a buffer on input side.\nIt also eases the special treatment of priority event on output side as the contextual priority flag is now inlined after the buffer has been created.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "24b8a5df5fe63fb9eaaf3753f691077e69f100b4", "url": "https://github.com/apache/flink/commit/24b8a5df5fe63fb9eaaf3753f691077e69f100b4", "message": "[FLINK-19026][network] Adding PrioritizedDeque and use it in PipelinedSubpartition.\n\nPrioritizedDeque supports enqueue elements with priority such that it will be polled after all existing priority elements but before any non-priority element.\nIt is a building block for fair scheduling with priority elevation that will be used also on input side in the next commits.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "d5cbd3e9bd08f311f53272b67c0935ab8cf28107", "url": "https://github.com/apache/flink/commit/d5cbd3e9bd08f311f53272b67c0935ab8cf28107", "message": "[FLINK-19026][network] Removing unnecessary priority flag on output side.\n\nThe priority information is fully incorporated in Buffer.DataType now.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "6f706554b8ee1db58b579bc4d4d6e1379b67a6d6", "url": "https://github.com/apache/flink/commit/6f706554b8ee1db58b579bc4d4d6e1379b67a6d6", "message": "[FLINK-19026][network] Generalizing BufferAndAvailability and BufferAndBacklog to capture the DataType of the next record.\n\nThe data type of the next record allows to check for availability, whether it's an event, and whether the event has a priority.\nIt also will allow handling future data types more smoothly.", "committedDate": "2020-09-23T09:47:40Z", "type": "commit"}, {"oid": "7ed17f2f8d8b67b72b0d453a006e7d26bfa54eaa", "url": "https://github.com/apache/flink/commit/7ed17f2f8d8b67b72b0d453a006e7d26bfa54eaa", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T09:47:42Z", "type": "forcePushed"}, {"oid": "3333fd4ca67be7345172128322ff1cf17951808f", "url": "https://github.com/apache/flink/commit/3333fd4ca67be7345172128322ff1cf17951808f", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T10:57:08Z", "type": "forcePushed"}, {"oid": "71efb8e87a3cd8adca13bf34dae610817136aa3f", "url": "https://github.com/apache/flink/commit/71efb8e87a3cd8adca13bf34dae610817136aa3f", "message": "[FLINK-19026][network] Move sequence number into PipelinedSubpartition and relay through BufferAndAvailability and BufferAndBacklog.\n\nThe sequence number will be used in input side to avoid spurious priority notification in later commits.", "committedDate": "2020-09-23T11:06:35Z", "type": "commit"}, {"oid": "3e46cb29622d4cff5a381afd90f68818d41c8004", "url": "https://github.com/apache/flink/commit/3e46cb29622d4cff5a381afd90f68818d41c8004", "message": "[FLINK-19026][network] Refactor SingleInputGate#waitAndGetNextData.\n\nBetter distinguishes between optional and non-optional variables. Add short cut for empty buffers.\nNext commit will build on this refactoring to incorporate priority events.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "99572b30742b436ca44cd9aa28578a0489b0534b", "url": "https://github.com/apache/flink/commit/99572b30742b436ca44cd9aa28578a0489b0534b", "message": "[hotfix][network] De-mockitofy InputGateFairnessTest.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "fa38f2e9e04564a67408961b74807eb8c97aa7c1", "url": "https://github.com/apache/flink/commit/fa38f2e9e04564a67408961b74807eb8c97aa7c1", "message": "[FLINK-19026][network] Simplify lock acquisition in InputGates while polling.\n\nThis is an alternative fix for FLINK-12510, where a cyclic deadlock can happen when a subpartition is being requested, another subpartition is freed, and data is being polled at the same time on an UnionInputGate. This fix avoids double-lock acquisition on polling by moving the availability notification for a newly acquired subpartitions outside of the lock of ResultPartitionManager. This change may trigger a availability notification on Subpartition without data being available, however, all relevant components are guarded against spurious wakeups.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "7bc29c9766689ee5ed9b7e62ecb9c4dfce70b7d0", "url": "https://github.com/apache/flink/commit/7bc29c9766689ee5ed9b7e62ecb9c4dfce70b7d0", "message": "[FLINK-19026][network] Using PrioritizedDeque on input side.\n\nPriorityDeque is also used in InputGates. BufferOrEvent and InputWithData are enriched with a flag indicating that there are more priority events.\n(Note relaying the DataType as on the output side would require lock acquisitions which are not warranted at this point in time)", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "76ea751d6d15829d8ed2e4717684aad81f5fc9ce", "url": "https://github.com/apache/flink/commit/76ea751d6d15829d8ed2e4717684aad81f5fc9ce", "message": "[FLINK-19026][network] Simplify output priority notification.\n\nBufferAvailabilityListener#notifyPriorityEvent now is a simple notification to avoid any kind of secondary data flow on output side as it was originally intended before.\nFor remote channels, notifyPriorityEvent behaves like an extra notifyDataAvailable call as an event is always pollable. For local channels, notifyPriorityEvent ultimately informs InputGate that the respective channel has a priority event.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "012c9a215468ad7f09605c618ffc9fc0d3b72f06", "url": "https://github.com/apache/flink/commit/012c9a215468ad7f09605c618ffc9fc0d3b72f06", "message": "[hotfix][network] Use IOExceptions where possible in CheckpointBarrierHandler.", "committedDate": "2020-09-23T11:06:37Z", "type": "commit"}, {"oid": "e126028005bbf5888aeff9eaa2346bc5afb67867", "url": "https://github.com/apache/flink/commit/e126028005bbf5888aeff9eaa2346bc5afb67867", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T11:07:00Z", "type": "forcePushed"}, {"oid": "bb6186d0fe5512241da664c3ce52e5104da77c12", "url": "https://github.com/apache/flink/commit/bb6186d0fe5512241da664c3ce52e5104da77c12", "message": "[FLINK-19026][network] Move spilling into channels.\n\nA future commit moves the Unaligner completely into task thread, which would result in late spilling of in-flight data during polling and potentially delay un\nBecause channels are now responsible for spilling in-flight data during unaligned checkpoint, in-flight data can be spilled as soon as the checkpoint has been.", "committedDate": "2020-09-23T11:09:02Z", "type": "commit"}, {"oid": "d509b2efe3603f3521ccb82a45096a4e1719ffd6", "url": "https://github.com/apache/flink/commit/d509b2efe3603f3521ccb82a45096a4e1719ffd6", "message": "[FLINK-19026][network] Moving priority event handling from BufferReceivedListener to CheckpointedInputGate.\n\nThis commit renders BufferReceivedListener obsolete and will allow a following commit to remove it entirely.\nA side-effect of this commit is that all events are handed over from CheckpointedInputGate to StreamTaskNetworkInput and break up the poll loop. However, since events are rare, it should have no visible impact on the throughput.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "7bd2390c24241e05cce6105927178584a208936c", "url": "https://github.com/apache/flink/commit/7bd2390c24241e05cce6105927178584a208936c", "message": "[FLINK-19026][checkpointing] Remove synchronization from CheckpointBarrierUnaligner.\n\nThis concludes the refactoring: All priority events use the same buffer hand-over as normal events; the buffers are just reordered.\nNotification of priority event bypasses CheckpointBarrierHandler and directly triggers CheckpointedInputGate#processPriorityEvents.\nNote that checkpoints are not cancelled anymore if Unaligner received all barriers. This behavior is now in line with Aligner.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "073b9f0e84b6823e8138985bdbf783838ca3c7ed", "url": "https://github.com/apache/flink/commit/073b9f0e84b6823e8138985bdbf783838ca3c7ed", "message": "[FLINK-19026][network/task] Remove unused BufferReceivedListener and\n\n AbstractInvokable#executeInTaskThread.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "url": "https://github.com/apache/flink/commit/36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T11:09:18Z", "type": "commit"}, {"oid": "36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "url": "https://github.com/apache/flink/commit/36c366400126cb68f0a8c8cf14b5c5e98ef2b58d", "message": "[FLINK-19026][tests] Rewritten UnalignedCheckpointITCase to use new source interface.\n\nThe rewritten test induces heavy backpressure which would not work at all with aligned checkpoints or legacy sources during the timeout period.", "committedDate": "2020-09-23T11:09:18Z", "type": "forcePushed"}]}