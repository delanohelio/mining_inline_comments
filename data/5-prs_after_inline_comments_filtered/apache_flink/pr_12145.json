{"pr_number": 12145, "pr_title": "[FLINK-17428] [table-planner-blink] supports projection push down on new table source interface in blink planner", "pr_createdAt": "2020-05-14T08:18:42Z", "pr_url": "https://github.com/apache/flink/pull/12145", "timeline": [{"oid": "700825f14b6128048bf2aec22947f30eaef40100", "url": "https://github.com/apache/flink/commit/700825f14b6128048bf2aec22947f30eaef40100", "message": "[FLINK-17428] [table-planner-blink] supports projection push down on new table source interface in blink planner", "committedDate": "2020-05-16T05:40:00Z", "type": "commit"}, {"oid": "700825f14b6128048bf2aec22947f30eaef40100", "url": "https://github.com/apache/flink/commit/700825f14b6128048bf2aec22947f30eaef40100", "message": "[FLINK-17428] [table-planner-blink] supports projection push down on new table source interface in blink planner", "committedDate": "2020-05-16T05:40:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTY3Ng==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426121676", "bodyText": "check false condition here and we can save one level of indent", "author": "KurtYoung", "createdAt": "2020-05-16T05:45:36Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {", "originalCommit": "700825f14b6128048bf2aec22947f30eaef40100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTcyMw==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426121723", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n          \n          \n            \n            \n          \n          \n            \n            \t\tDynamicTableSource newTableSource = oldTableSource.copy();\n          \n          \n            \n            \t\tDynamicTableSource newTableSource = oldTableSourceTable.tableSource().copy();", "author": "KurtYoung", "createdAt": "2020-05-16T05:46:23Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();", "originalCommit": "700825f14b6128048bf2aec22947f30eaef40100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMTc2Ng==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426121766", "bodyText": "no need to declare this as local variable because it only been used once", "author": "KurtYoung", "createdAt": "2020-05-16T05:47:14Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;", "originalCommit": "700825f14b6128048bf2aec22947f30eaef40100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMjAyNg==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426122026", "bodyText": "how about change select to project?", "author": "KurtYoung", "createdAt": "2020-05-16T05:50:29Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);\n+\t\tFlinkTypeFactory flinkTypeFactory = (FlinkTypeFactory) oldTableSourceTable.getRelOptSchema().getTypeFactory();\n+\t\tRelDataType newRowType = flinkTypeFactory.projectStructType(oldTableSourceTable.getRowType(), usedFields);\n+\n+\t\tString[] newExtraDigests = Arrays.copyOf(\n+\t\t\t\toldTableSourceTable.extraDigests(), oldTableSourceTable.extraDigests().length + 1);\n+\t\tnewExtraDigests[oldTableSourceTable.extraDigests().length] = \"select(\" + String.join(\", \", fieldNames) + \")\";", "originalCommit": "700825f14b6128048bf2aec22947f30eaef40100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMjA2Nw==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426122067", "bodyText": "create a copy method just like the legacy one does", "author": "KurtYoung", "createdAt": "2020-05-16T05:51:02Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);\n+\t\tFlinkTypeFactory flinkTypeFactory = (FlinkTypeFactory) oldTableSourceTable.getRelOptSchema().getTypeFactory();\n+\t\tRelDataType newRowType = flinkTypeFactory.projectStructType(oldTableSourceTable.getRowType(), usedFields);\n+\n+\t\tString[] newExtraDigests = Arrays.copyOf(\n+\t\t\t\toldTableSourceTable.extraDigests(), oldTableSourceTable.extraDigests().length + 1);\n+\t\tnewExtraDigests[oldTableSourceTable.extraDigests().length] = \"select(\" + String.join(\", \", fieldNames) + \")\";\n+\t\t// project push down does not change the statistic, we can reuse origin statistic\n+\t\tTableSourceTable newTableSourceTable = new TableSourceTable(", "originalCommit": "700825f14b6128048bf2aec22947f30eaef40100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyMjEyMA==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426122120", "bodyText": "use a non-deprecated constructor", "author": "KurtYoung", "createdAt": "2020-05-16T05:52:05Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable != null && tableSourceTable.tableSource() instanceof SupportsProjectionPushDown) {\n+\t\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t\t} else {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource oldTableSource = oldTableSourceTable.tableSource();\n+\n+\t\tDynamicTableSource newTableSource = oldTableSource.copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);\n+\t\tFlinkTypeFactory flinkTypeFactory = (FlinkTypeFactory) oldTableSourceTable.getRelOptSchema().getTypeFactory();\n+\t\tRelDataType newRowType = flinkTypeFactory.projectStructType(oldTableSourceTable.getRowType(), usedFields);\n+\n+\t\tString[] newExtraDigests = Arrays.copyOf(\n+\t\t\t\toldTableSourceTable.extraDigests(), oldTableSourceTable.extraDigests().length + 1);\n+\t\tnewExtraDigests[oldTableSourceTable.extraDigests().length] = \"select(\" + String.join(\", \", fieldNames) + \")\";\n+\t\t// project push down does not change the statistic, we can reuse origin statistic\n+\t\tTableSourceTable newTableSourceTable = new TableSourceTable(\n+\t\t\t\toldTableSourceTable.getRelOptSchema(),\n+\t\t\t\toldTableSourceTable.tableIdentifier(),\n+\t\t\t\tnewRowType,\n+\t\t\t\toldTableSourceTable.getStatistic(),\n+\t\t\t\tnewTableSource,\n+\t\t\t\toldTableSourceTable.isStreamingMode(),\n+\t\t\t\toldTableSourceTable.catalogTable(),\n+\t\t\t\toldTableSourceTable.dynamicOptions(),\n+\t\t\t\tnewExtraDigests\n+\t\t);\n+\n+\t\tLogicalTableScan newScan = new LogicalTableScan(scan.getCluster(), scan.getTraitSet(), newTableSourceTable);", "originalCommit": "700825f14b6128048bf2aec22947f30eaef40100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEyNDUzNQ==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426124535", "bodyText": "getFieldDataTypes has been deleted", "author": "KurtYoung", "createdAt": "2020-05-16T06:29:05Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestProjectableValuesTableFactory.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.factories;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.java.io.CollectionInputFormat;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.configuration.ConfigOption;\n+import org.apache.flink.configuration.ConfigOptions;\n+import org.apache.flink.streaming.api.functions.source.FromElementsFunction;\n+import org.apache.flink.table.api.DataTypes;\n+import org.apache.flink.table.connector.ChangelogMode;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.InputFormatProvider;\n+import org.apache.flink.table.connector.source.ScanTableSource;\n+import org.apache.flink.table.connector.source.SourceFunctionProvider;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.DynamicTableSourceFactory;\n+import org.apache.flink.table.factories.FactoryUtil;\n+import org.apache.flink.table.planner.utils.JavaScalaConversionUtil;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.FieldsDataType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.types.Row;\n+import org.apache.flink.types.RowKind;\n+import org.apache.flink.util.Preconditions;\n+\n+import javax.annotation.Nullable;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import scala.collection.Seq;\n+\n+/**\n+ * Test implementation of {@link DynamicTableSourceFactory} that supports projection push down.\n+ */\n+public class TestProjectableValuesTableFactory implements DynamicTableSourceFactory {\n+\n+\t// --------------------------------------------------------------------------------------------\n+\t// Data Registration\n+\t// --------------------------------------------------------------------------------------------\n+\n+\tprivate static final AtomicInteger idCounter = new AtomicInteger(0);\n+\tprivate static final Map<String, Collection<Tuple2<RowKind, Row>>> registeredData = new HashMap<>();\n+\n+\t/**\n+\t * Register the given data into the data factory context and return the data id.\n+\t * The data id can be used as a reference to the registered data in data connector DDL.\n+\t */\n+\tpublic static String registerData(Collection<Row> data) {\n+\t\tList<Tuple2<RowKind, Row>> dataWithKinds = new ArrayList<>();\n+\t\tfor (Row row : data) {\n+\t\t\tdataWithKinds.add(Tuple2.of(RowKind.INSERT, row));\n+\t\t}\n+\t\treturn registerChangelogData(dataWithKinds);\n+\t}\n+\n+\t/**\n+\t * Register the given data into the data factory context and return the data id.\n+\t * The data id can be used as a reference to the registered data in data connector DDL.\n+\t */\n+\tpublic static String registerData(Seq<Row> data) {\n+\t\treturn registerData(JavaScalaConversionUtil.toJava(data));\n+\t}\n+\n+\t/**\n+\t * Register the given data with RowKind into the data factory context and return the data id.\n+\t * The data id can be used as a reference to the registered data in data connector DDL.\n+\t * TODO: remove this utility once Row supports RowKind.\n+\t */\n+\tpublic static String registerChangelogData(Collection<Tuple2<RowKind, Row>> data) {\n+\t\tString id = String.valueOf(idCounter.incrementAndGet());\n+\t\tregisteredData.put(id, data);\n+\t\treturn id;\n+\t}\n+\n+\t/**\n+\t * Removes the registered data under the given data id.\n+\t */\n+\tpublic static void clearAllRegisteredData() {\n+\t\tregisteredData.clear();\n+\t}\n+\n+\t// --------------------------------------------------------------------------------------------\n+\t// Factory\n+\t// --------------------------------------------------------------------------------------------\n+\n+\tprivate static final String IDENTIFIER = \"projectable-values\";\n+\n+\tprivate static final ConfigOption<String> DATA_ID = ConfigOptions\n+\t\t\t.key(\"data-id\")\n+\t\t\t.stringType()\n+\t\t\t.defaultValue(null);\n+\n+\tprivate static final ConfigOption<Boolean> BOUNDED = ConfigOptions\n+\t\t\t.key(\"bounded\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false);\n+\n+\tprivate static final ConfigOption<String> CHANGELOG_MODE = ConfigOptions\n+\t\t\t.key(\"changelog-mode\")\n+\t\t\t.stringType()\n+\t\t\t.defaultValue(\"I\"); // all available \"I,UA,UB,D\"\n+\n+\tprivate static final ConfigOption<String> RUNTIME_SOURCE = ConfigOptions\n+\t\t\t.key(\"runtime-source\")\n+\t\t\t.stringType()\n+\t\t\t.defaultValue(\"SourceFunction\"); // another is \"InputFormat\"\n+\n+\tprivate static final ConfigOption<Boolean> NESTED_PROJECTION_SUPPORTED = ConfigOptions\n+\t\t\t.key(\"nested-projection-supported\")\n+\t\t\t.booleanType()\n+\t\t\t.defaultValue(false);\n+\n+\t@Override\n+\tpublic String factoryIdentifier() {\n+\t\treturn IDENTIFIER;\n+\t}\n+\n+\t@Override\n+\tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tFactoryUtil.TableFactoryHelper helper = FactoryUtil.createTableFactoryHelper(this, context);\n+\t\thelper.validate();\n+\t\tChangelogMode changelogMode = parseChangelogMode(helper.getOptions().get(CHANGELOG_MODE));\n+\t\tString runtimeSource = helper.getOptions().get(RUNTIME_SOURCE);\n+\t\tboolean isBounded = helper.getOptions().get(BOUNDED);\n+\t\tString dataId = helper.getOptions().get(DATA_ID);\n+\t\tboolean nestedProjectionSupported = helper.getOptions().get(NESTED_PROJECTION_SUPPORTED);\n+\n+\t\tCollection<Tuple2<RowKind, Row>> data = registeredData.getOrDefault(dataId, Collections.emptyList());\n+\t\tDataType rowDataType = context.getCatalogTable().getSchema().toPhysicalRowDataType();\n+\t\treturn new TestProjectableValuesTableSource(\n+\t\t\t\tchangelogMode,\n+\t\t\t\tisBounded,\n+\t\t\t\truntimeSource,\n+\t\t\t\trowDataType,\n+\t\t\t\tdata,\n+\t\t\t\tnestedProjectionSupported);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ConfigOption<?>> requiredOptions() {\n+\t\treturn Collections.emptySet();\n+\t}\n+\n+\t@Override\n+\tpublic Set<ConfigOption<?>> optionalOptions() {\n+\t\treturn new HashSet<>(Arrays.asList(\n+\t\t\t\tDATA_ID,\n+\t\t\t\tCHANGELOG_MODE,\n+\t\t\t\tBOUNDED,\n+\t\t\t\tRUNTIME_SOURCE,\n+\t\t\t\tNESTED_PROJECTION_SUPPORTED));\n+\t}\n+\n+\tprivate ChangelogMode parseChangelogMode(String string) {\n+\t\tChangelogMode.Builder builder = ChangelogMode.newBuilder();\n+\t\tfor (String split : string.split(\",\")) {\n+\t\t\tswitch (split.trim()) {\n+\t\t\t\tcase \"I\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.INSERT);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"UB\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.UPDATE_BEFORE);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"UA\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.UPDATE_AFTER);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase \"D\":\n+\t\t\t\t\tbuilder.addContainedKind(RowKind.DELETE);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid ChangelogMode string: \" + string);\n+\t\t\t}\n+\t\t}\n+\t\treturn builder.build();\n+\t}\n+\n+\t// --------------------------------------------------------------------------------------------\n+\t// Table source\n+\t// --------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Values {@link DynamicTableSource} for testing.\n+\t */\n+\tprivate static class TestProjectableValuesTableSource implements ScanTableSource, SupportsProjectionPushDown {\n+\n+\t\tprivate final ChangelogMode changelogMode;\n+\t\tprivate final boolean bounded;\n+\t\tprivate final String runtimeSource;\n+\t\tprivate DataType physicalRowDataType;\n+\t\tprivate final Collection<Tuple2<RowKind, Row>> data;\n+\t\tprivate final boolean nestedProjectionSupported;\n+\t\tprivate int[] projectedFields = null;\n+\n+\t\tprivate TestProjectableValuesTableSource(\n+\t\t\t\tChangelogMode changelogMode,\n+\t\t\t\tboolean bounded, String runtimeSource,\n+\t\t\t\tDataType physicalRowDataType,\n+\t\t\t\tCollection<Tuple2<RowKind, Row>> data,\n+\t\t\t\tboolean nestedProjectionSupported) {\n+\t\t\tthis.changelogMode = changelogMode;\n+\t\t\tthis.bounded = bounded;\n+\t\t\tthis.runtimeSource = runtimeSource;\n+\t\t\tthis.physicalRowDataType = physicalRowDataType;\n+\t\t\tthis.data = data;\n+\t\t\tthis.nestedProjectionSupported = nestedProjectionSupported;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic ChangelogMode getChangelogMode() {\n+\t\t\treturn changelogMode;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\t@Override\n+\t\tpublic ScanRuntimeProvider getScanRuntimeProvider(ScanTableSource.Context runtimeProviderContext) {\n+\t\t\tTypeSerializer<RowData> serializer = (TypeSerializer<RowData>) runtimeProviderContext\n+\t\t\t\t\t.createTypeInformation(physicalRowDataType)\n+\t\t\t\t\t.createSerializer(new ExecutionConfig());\n+\t\t\tDataStructureConverter converter = runtimeProviderContext.createDataStructureConverter(physicalRowDataType);\n+\t\t\tCollection<RowData> values = convertToRowData(data, projectedFields, converter);\n+\n+\t\t\tif (runtimeSource.equals(\"SourceFunction\")) {\n+\t\t\t\ttry {\n+\t\t\t\t\treturn SourceFunctionProvider.of(\n+\t\t\t\t\t\t\tnew FromElementsFunction<>(serializer, values),\n+\t\t\t\t\t\t\tbounded);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tthrow new RuntimeException(e);\n+\t\t\t\t}\n+\t\t\t} else if (runtimeSource.equals(\"InputFormat\")) {\n+\t\t\t\treturn InputFormatProvider.of(new CollectionInputFormat<>(values, serializer));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Unsupported runtime source class: \" + runtimeSource);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic DynamicTableSource copy() {\n+\t\t\tTestProjectableValuesTableSource newTableSource = new TestProjectableValuesTableSource(\n+\t\t\t\t\tchangelogMode, bounded, runtimeSource, physicalRowDataType, data, nestedProjectionSupported);\n+\t\t\tnewTableSource.projectedFields = projectedFields;\n+\t\t\treturn newTableSource;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String asSummaryString() {\n+\t\t\treturn \"TestProjectableValues\";\n+\t\t}\n+\n+\t\tprivate static Collection<RowData> convertToRowData(\n+\t\t\t\tCollection<Tuple2<RowKind, Row>> data,\n+\t\t\t\t@Nullable int[] projectedFields,\n+\t\t\t\tDataStructureConverter converter) {\n+\t\t\tList<RowData> result = new ArrayList<>();\n+\t\t\tfor (Tuple2<RowKind, Row> value : data) {\n+\t\t\t\tRow projectedRow;\n+\t\t\t\tif (projectedFields == null) {\n+\t\t\t\t\tprojectedRow = value.f1;\n+\t\t\t\t} else {\n+\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n+\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n+\t\t\t\t\t\tnewValues[i] = value.f1.getField(projectedFields[i]);\n+\t\t\t\t\t}\n+\t\t\t\t\tprojectedRow = Row.of(newValues);\n+\t\t\t\t}\n+\t\t\t\tRowData rowData = (RowData) converter.toInternal(projectedRow);\n+\t\t\t\tif (rowData != null) {\n+\t\t\t\t\trowData.setRowKind(value.f0);\n+\t\t\t\t\tresult.add(rowData);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsNestedProjection() {\n+\t\t\treturn nestedProjectionSupported;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void applyProjection(int[][] projectedFields) {\n+\t\t\tthis.projectedFields = new int[projectedFields.length];\n+\t\t\tFieldsDataType dataType = (FieldsDataType) physicalRowDataType;\n+\t\t\tRowType rowType = ((RowType) physicalRowDataType.getLogicalType());\n+\t\t\tDataTypes.Field[] fields = new DataTypes.Field[projectedFields.length];\n+\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n+\t\t\t\tint[] projection = projectedFields[i];\n+\t\t\t\tPreconditions.checkArgument(projection.length == 1);\n+\t\t\t\tint index = projection[0];\n+\t\t\t\tthis.projectedFields[i] = index;\n+\t\t\t\tString fieldName = rowType.getFieldNames().get(index);\n+\t\t\t\tfields[i] = DataTypes.FIELD(fieldName, dataType.getFieldDataTypes().get(fieldName));", "originalCommit": "700825f14b6128048bf2aec22947f30eaef40100", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d8ecd23a5b6cc71010f40335d1eb7adac97a5cf", "url": "https://github.com/apache/flink/commit/7d8ecd23a5b6cc71010f40335d1eb7adac97a5cf", "message": "address comments", "committedDate": "2020-05-16T07:37:45Z", "type": "commit"}, {"oid": "dbdd467d3a700bdb64a57209e8ed1fe1c4c33887", "url": "https://github.com/apache/flink/commit/dbdd467d3a700bdb64a57209e8ed1fe1c4c33887", "message": "fix failed test and add more tests", "committedDate": "2020-05-16T09:40:36Z", "type": "commit"}, {"oid": "daeb6250b59f34a7e2de7494feea195812465435", "url": "https://github.com/apache/flink/commit/daeb6250b59f34a7e2de7494feea195812465435", "message": "fix failed tests", "committedDate": "2020-05-16T10:09:15Z", "type": "commit"}, {"oid": "3747e17ecf18448088dcb467d8bea240b00f12b6", "url": "https://github.com/apache/flink/commit/3747e17ecf18448088dcb467d8bea240b00f12b6", "message": "fix checkstyle error", "committedDate": "2020-05-16T12:54:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU0MQ==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426211541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tnewProjectPushDownSource.applyProjection(projectedFields);\n          \n          \n            \n            \t\t((SupportsProjectionPushDown) newTableSource).applyProjection(projectedFields);", "author": "KurtYoung", "createdAt": "2020-05-17T03:00:32Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null || !(tableSourceTable.tableSource() instanceof SupportsProjectionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t} else {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource newTableSource = oldTableSourceTable.tableSource().copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;\n+\n+\t\tint[][] projectedFields = new int[usedFields.length][];\n+\t\tList<String> fieldNames = new ArrayList<>();\n+\t\tfor (int i = 0; i < usedFields.length; ++i) {\n+\t\t\tint usedField = usedFields[i];\n+\t\t\tprojectedFields[i] = new int[] { usedField };\n+\t\t\tfieldNames.add(scan.getRowType().getFieldNames().get(usedField));\n+\t\t}\n+\t\tnewProjectPushDownSource.applyProjection(projectedFields);", "originalCommit": "3747e17ecf18448088dcb467d8bea240b00f12b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIxMTU1NA==", "url": "https://github.com/apache/flink/pull/12145#discussion_r426211554", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;", "author": "KurtYoung", "createdAt": "2020-05-17T03:00:43Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushProjectIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsProjectionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeRewriter;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.logical.LogicalProject;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.rules.ProjectRemoveRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Planner rule that pushes a {@link LogicalProject} into a {@link LogicalTableScan}\n+ * which wraps a {@link SupportsProjectionPushDown} dynamic table source.\n+ *\n+ * <p>NOTES: This rule does not support nested fields push down now,\n+ * instead it will push the top-level column down just like non-nested fields.\n+ */\n+public class PushProjectIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushProjectIntoTableSourceScanRule INSTANCE = new PushProjectIntoTableSourceScanRule();\n+\n+\tpublic PushProjectIntoTableSourceScanRule() {\n+\t\tsuper(operand(LogicalProject.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\t\"PushProjectIntoTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null || !(tableSourceTable.tableSource() instanceof SupportsProjectionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tSupportsProjectionPushDown pushDownSource = (SupportsProjectionPushDown) tableSourceTable.tableSource();\n+\t\tif (pushDownSource.supportsNestedProjection()) {\n+\t\t\tthrow new TableException(\"Nested projection push down is unsupported now. \\n\" +\n+\t\t\t\t\t\"Please disable nested projection (SupportsProjectionPushDown#supportsNestedProjection returns false), \" +\n+\t\t\t\t\t\"planner will push down the top-level columns.\");\n+\t\t} else {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tLogicalProject project = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\n+\t\tint[] usedFields = RexNodeExtractor.extractRefInputFields(project.getProjects());\n+\t\t// if no fields can be projected, we keep the original plan.\n+\t\tif (scan.getRowType().getFieldCount() == usedFields.length) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tTableSourceTable oldTableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource newTableSource = oldTableSourceTable.tableSource().copy();\n+\t\tSupportsProjectionPushDown newProjectPushDownSource = (SupportsProjectionPushDown) newTableSource;", "originalCommit": "3747e17ecf18448088dcb467d8bea240b00f12b6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "597608bb0ab2af04ee3143a6e82e5b3a5001cf48", "url": "https://github.com/apache/flink/commit/597608bb0ab2af04ee3143a6e82e5b3a5001cf48", "message": "fix checkstyle error", "committedDate": "2020-05-17T03:29:27Z", "type": "commit"}]}