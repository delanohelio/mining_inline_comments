{"pr_number": 13735, "pr_title": "[FLINK-19533][checkpoint] Add channel state reassignment for unaligned checkpoints.", "pr_createdAt": "2020-10-22T00:09:31Z", "pr_url": "https://github.com/apache/flink/pull/13735", "timeline": [{"oid": "ee73393a13c999be626f7b8b98a170be88a093d9", "url": "https://github.com/apache/flink/commit/ee73393a13c999be626f7b8b98a170be88a093d9", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-22T06:06:43Z", "type": "forcePushed"}, {"oid": "c20d917f5ac0c8c3d932d0c0ba1ca1c7535c0b47", "url": "https://github.com/apache/flink/commit/c20d917f5ac0c8c3d932d0c0ba1ca1c7535c0b47", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-22T13:37:30Z", "type": "forcePushed"}, {"oid": "fc4b0f9b93bf136f02fb2c617e1c9e450c90f371", "url": "https://github.com/apache/flink/commit/fc4b0f9b93bf136f02fb2c617e1c9e450c90f371", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-23T09:12:54Z", "type": "forcePushed"}, {"oid": "458aee4e1d6779beb640f563c7c9b5a65e645237", "url": "https://github.com/apache/flink/commit/458aee4e1d6779beb640f563c7c9b5a65e645237", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-23T09:21:24Z", "type": "forcePushed"}, {"oid": "7c42ceb0f3c54b0ab63f053ce91a20c4866119d1", "url": "https://github.com/apache/flink/commit/7c42ceb0f3c54b0ab63f053ce91a20c4866119d1", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-23T09:40:34Z", "type": "forcePushed"}, {"oid": "1b1a34de33af36c301266d175cb72151b1bc51c4", "url": "https://github.com/apache/flink/commit/1b1a34de33af36c301266d175cb72151b1bc51c4", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-23T10:29:09Z", "type": "forcePushed"}, {"oid": "6bfcf5914a2742ce41f05b2b77b70f7df85fc696", "url": "https://github.com/apache/flink/commit/6bfcf5914a2742ce41f05b2b77b70f7df85fc696", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-23T13:09:04Z", "type": "forcePushed"}, {"oid": "470d466cfe4455aefd5a302cedd92b57750f2c57", "url": "https://github.com/apache/flink/commit/470d466cfe4455aefd5a302cedd92b57750f2c57", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-23T18:44:06Z", "type": "forcePushed"}, {"oid": "5e5340241b5811243463f96dda7455b2869cf268", "url": "https://github.com/apache/flink/commit/5e5340241b5811243463f96dda7455b2869cf268", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-24T10:31:51Z", "type": "forcePushed"}, {"oid": "cbc3b0ca32cfbfbf57ab34f85ae12e4f8c0ee4aa", "url": "https://github.com/apache/flink/commit/cbc3b0ca32cfbfbf57ab34f85ae12e4f8c0ee4aa", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-24T11:23:36Z", "type": "forcePushed"}, {"oid": "88a90896e0cf1c7bf27fe1aa40158c7280c5fa58", "url": "https://github.com/apache/flink/commit/88a90896e0cf1c7bf27fe1aa40158c7280c5fa58", "message": "Test fix for failing job submissions.", "committedDate": "2020-10-24T18:15:36Z", "type": "forcePushed"}, {"oid": "25b0c065fae8c72fa607c5b6f47376ff3e6f8568", "url": "https://github.com/apache/flink/commit/25b0c065fae8c72fa607c5b6f47376ff3e6f8568", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-10-24T20:22:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE1NDAxOQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r512154019", "bodyText": "Removal of @Nonnull is controversial by some. Some people prefer it as cheap, debug mode only assertion. This is because as far as I know, @Nonnull in debug mode, is adding checkNonNull(...) equivalents.\nI personally would be fine by not using them, and I personally I'm not adding them in a new code, but because of the above reason, I would be actually against removing them from a code that someone added (otherwise, we can end up in a ping pong situation when you are removing them and someone else re-adding).", "author": "pnowojski", "createdAt": "2020-10-26T17:47:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -63,31 +61,25 @@\n \t/**\n \t * Snapshot from the {@link org.apache.flink.runtime.state.OperatorStateBackend}.\n \t */\n-\t@Nonnull", "originalCommit": "4915d3dded86843b8cfd204433e71c0b6f82c138", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk0Mzk1MA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516943950", "bodyText": "I like the change. Especially given that there are already checkNotNull in the constructor.\n(we don't have to remove again it if someone re-adds it)\nP.S.: is checkNotNull missing for the new fields?", "author": "rkhachatryan", "createdAt": "2020-11-03T20:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE1NDAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE1ODE0Mw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r512158143", "bodyText": "What is the relation between this method/interface and #rescaleIntersections from the Partitioner? Why one returns  int[] and the other BitSet?", "author": "pnowojski", "createdAt": "2020-10-26T17:53:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/ChannelRescaler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.api.writer;\n+\n+import org.apache.flink.annotation.Internal;\n+\n+import java.io.Serializable;\n+import java.util.BitSet;\n+\n+/**\n+ * The {@link ChannelRescaler} narrows down the channels that need to be read during rescaling to recover from a\n+ * particular channel when in-flight data has been stored in the checkpoint.\n+ */\n+@Internal\n+public interface ChannelRescaler extends Serializable {\n+\t/**\n+\t * Returns all old channel indexes that need to be read to restore all buffers for the given new channel index on\n+\t * rescale.\n+\t */\n+\tBitSet rescaleIntersections(int newChannelIndex, int oldNumberOfChannels, int newNumberOfChannels);", "originalCommit": "51ced4ccaf306b05185f5332983c378cecf73330", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyODE0NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518128144", "bodyText": "Removed from Partitioner", "author": "AHeise", "createdAt": "2020-11-05T15:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE1ODE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MzI4Ng==", "url": "https://github.com/apache/flink/pull/13735#discussion_r512163286", "bodyText": "We need this to support CustomPartitionerWrapper, right? This is @Public interface :( I think we need to think twice before we commit ourselves to such change. Let's sync offline again whether this is really the best/the only way of solving our problem.", "author": "pnowojski", "createdAt": "2020-10-26T18:01:26Z", "path": "flink-core/src/main/java/org/apache/flink/api/common/functions/Partitioner.java", "diffHunk": "@@ -37,4 +40,20 @@\n \t * @return The partition index.\n \t */\n \tint partition(K key, int numPartitions);\n+\n+\t/**\n+\t * Returns all partitions that need to be read to restore the given new partition. The partitioner is then\n+\t * applied on the key of the restored record to filter all irrelevant records.\n+\t *\n+\t * <p>In particular, to create a partition X after rescaling, all partitions returned by this method are fully read\n+\t * and the key of each record is then fed into {@link #partition(Object, int)} to check if it belongs to X.\n+\t *\n+\t * <p>The default implementation states that all partitions need to be scanned and should be overwritten to improve\n+\t * performance.\n+\t */\n+\t@PublicEvolving\n+\tdefault int[] rescaleIntersections(int newPartition, int oldNumPartitions, int newNumPartitions) {\n+\t\t// any old partition may contain a record that should be in the new partition after rescaling\n+\t\treturn IntStream.range(0, oldNumPartitions).toArray();\n+\t}", "originalCommit": "51ced4ccaf306b05185f5332983c378cecf73330", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyODc4NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518128784", "bodyText": "Removed from CustomerPartitioner. We officially do not support it (and inofficially just use full replication and downstream filtering).", "author": "AHeise", "createdAt": "2020-11-05T15:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MzI4Ng=="}], "type": "inlineReview"}, {"oid": "7c5fcf177b0d1441ab94fa46cf1591f47a9bc7a6", "url": "https://github.com/apache/flink/commit/7c5fcf177b0d1441ab94fa46cf1591f47a9bc7a6", "message": "fixup! [FLINK-19533][runtime/streaming] Add ChannelRescaler to the JobEdge to determine mapping between old and new partitions.", "committedDate": "2020-11-03T12:04:45Z", "type": "forcePushed"}, {"oid": "626fed37b9dec18c343e10e65308088c532c0dd5", "url": "https://github.com/apache/flink/commit/626fed37b9dec18c343e10e65308088c532c0dd5", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-11-03T12:05:08Z", "type": "forcePushed"}, {"oid": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "url": "https://github.com/apache/flink/commit/9cbbcb24751268c0b5289b86606eb28baa1287eb", "message": "[FLINK-19533][checkpoint] Add channel state reassignment during rescaling.\n\nThis also calculates virtual channels that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recover with virtual channel will be added in a follow-up PR.", "committedDate": "2020-11-03T12:10:47Z", "type": "forcePushed"}, {"oid": "0ee428f903154ba04b7e68378252710181d6ea50", "url": "https://github.com/apache/flink/commit/0ee428f903154ba04b7e68378252710181d6ea50", "message": "[hotfix][deployment] Fix exceptional control flow in TaskDeploymentDescriptorFactory.", "committedDate": "2020-11-03T20:18:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjk1MQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516902951", "bodyText": "Is it actually channel mapping? I think it actually remaps operator state, doesn't it?\nserialVersionUID?\nI'd rather move this class to a separate file", "author": "rkhachatryan", "createdAt": "2020-11-03T19:23:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1MjY0NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517152644", "bodyText": "hm, it's all about channel state as part of the operator state. How about ChannelStateMapping?", "author": "AHeise", "createdAt": "2020-11-04T07:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4OTY3OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517389678", "bodyText": "I think ChannelStateMapping wouldn't be consistent with a field:\n/**\n * Set when several operator instances are merged into one.\n */\nprivate final BitSet oldTaskInstances;\n\nMaybe something like EdgeRescalingDescriptor?", "author": "rkhachatryan", "createdAt": "2020-11-04T14:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjk1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY2MzE3OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517663178", "bodyText": "I went with InflightDataRescalingDescriptor for now.", "author": "AHeise", "createdAt": "2020-11-04T22:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNDc2OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516904768", "bodyText": "Why bitsets are used here and throughout the PR?\nI think just Set<Integer> would be\na) more readable\nb) more efficient (no need for extra words if only high bits are sets)", "author": "rkhachatryan", "createdAt": "2020-11-03T19:27:11Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE1Mzg0OQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517153849", "bodyText": "I used it for memory optimization but it might have been prematurely:\nSet<Integer> uses 16 bytes per entry + 4 bytes for boxing + hash table overhead\nBitSet would be more efficient at least for all entries up to 24 bytes (so 24 channels).\nBut I see that it's not scaling well, especially since Set<Integer> should be mostly 1 or 2 entries (so ~50 bytes).", "author": "AHeise", "createdAt": "2020-11-04T07:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNDc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjU1MQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516906551", "bodyText": "To me, list isn't an obvious choice to provide index-based access.\nArray or hashtable would be more readable to me and guarantee O(1) time.", "author": "rkhachatryan", "createdAt": "2020-11-03T19:30:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;\n+\n+\t\t/**\n+\t\t * Set when channels are merged because the connected operator has been rescaled.\n+\t\t */\n+\t\tprivate final List<PartitionMapping> partitionMappings;", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNDE3NQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517334175", "bodyText": "Isn't array and array-list the same in complexity? I usually use a map for sparse data and list when it's dense (ideally consecutive), since it's much better on the memory consumption.\nBut I could go for array. At some point, I didn't have PartitionMapping and used generics which don't mix well with arrays.", "author": "AHeise", "createdAt": "2020-11-04T13:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM4NTA0MA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517385040", "bodyText": "Isn't array and array-list the same in complexity?\n\nYes, but here it is List, which can be a LinkedList.\nIf not arrays, then I'd go with Map, just because it makes obvious how elements are indexed and accessed. I don't think overhead will be visible here.", "author": "rkhachatryan", "createdAt": "2020-11-04T14:31:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNjU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwODE1OQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516908159", "bodyText": "PartitionMapping associates with the ResultPartition, but this class maps input channels and subPartitions, right? How about RescaledChannelsMapping?\nserialVersionUID?\nnit: I'd extract this class too", "author": "rkhachatryan", "createdAt": "2020-11-03T19:33:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;\n+\n+\t\t/**\n+\t\t * Set when channels are merged because the connected operator has been rescaled.\n+\t\t */\n+\t\tprivate final List<PartitionMapping> partitionMappings;\n+\n+\t\tpublic VirtualChannelMapping(BitSet oldTaskInstances, List<PartitionMapping> partitionMappings) {\n+\t\t\tthis.oldTaskInstances = oldTaskInstances;\n+\t\t\tthis.partitionMappings = partitionMappings;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tfinal VirtualChannelMapping that = (VirtualChannelMapping) o;\n+\t\t\treturn oldTaskInstances.equals(that.oldTaskInstances) &&\n+\t\t\t\tpartitionMappings.equals(that.partitionMappings);\n+\t\t}\n+\n+\t\tpublic int[] getOldTaskInstances(int defaultSubtask) {\n+\t\t\treturn oldTaskInstances.equals(NO_SUBTASKS) ?\n+\t\t\t\tnew int[] {defaultSubtask} :\n+\t\t\t\toldTaskInstances.stream().toArray();\n+\t\t}\n+\n+\t\tpublic PartitionMapping getPartitionMapping(int partitionIndex) {\n+\t\t\tif (partitionMappings.isEmpty()) {\n+\t\t\t\treturn NO_CHANNEL_MAPPING;\n+\t\t\t}\n+\t\t\treturn partitionMappings.get(partitionIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn Objects.hash(oldTaskInstances, partitionMappings);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"VirtualChannelMapping{\" +\n+\t\t\t\t\"oldTaskInstances=\" + oldTaskInstances +\n+\t\t\t\t\", partitionMappings=\" + partitionMappings +\n+\t\t\t\t'}';\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Contains the fine-grain channel mappings that occur when a connected operator has been rescaled.\n+\t */\n+\tpublic static class PartitionMapping implements Serializable {", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTI2Ng==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516909266", "bodyText": "Again, the choice of data structures isn't obvious. Why not Map<Int, Int>?\n(ditto oldToNewChannelIndexes)", "author": "rkhachatryan", "createdAt": "2020-11-03T19:35:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -327,4 +289,252 @@ public boolean hasState() {\n \t\t\t|| inputChannelState.hasState()\n \t\t\t|| resultSubpartitionState.hasState();\n \t}\n+\n+\tpublic static Builder builder() {\n+\t\treturn new Builder();\n+\t}\n+\n+\t/**\n+\t * The builder for a new {@link OperatorSubtaskState} which can be obtained by {@link #builder()}.\n+\t */\n+\tpublic static class Builder {\n+\t\tprivate StateObjectCollection<OperatorStateHandle> managedOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<OperatorStateHandle> rawOperatorState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> managedKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<KeyedStateHandle> rawKeyedState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<InputChannelStateHandle> inputChannelState = StateObjectCollection.empty();\n+\t\tprivate StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState = StateObjectCollection.empty();\n+\t\tprivate VirtualChannelMapping inputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\t\tprivate VirtualChannelMapping outputChannelMappings = VirtualChannelMapping.NO_MAPPING;\n+\n+\t\tprivate Builder() {\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(StateObjectCollection<OperatorStateHandle> managedOperatorState) {\n+\t\t\tthis.managedOperatorState = checkNotNull(managedOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedOperatorState(OperatorStateHandle managedOperatorState) {\n+\t\t\treturn setManagedOperatorState(StateObjectCollection.singleton(checkNotNull(managedOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(StateObjectCollection<OperatorStateHandle> rawOperatorState) {\n+\t\t\tthis.rawOperatorState = checkNotNull(rawOperatorState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawOperatorState(OperatorStateHandle rawOperatorState) {\n+\t\t\treturn setRawOperatorState(StateObjectCollection.singleton(checkNotNull(rawOperatorState)));\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(StateObjectCollection<KeyedStateHandle> managedKeyedState) {\n+\t\t\tthis.managedKeyedState = checkNotNull(managedKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setManagedKeyedState(KeyedStateHandle managedKeyedState) {\n+\t\t\treturn setManagedKeyedState(StateObjectCollection.singleton(checkNotNull(managedKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(StateObjectCollection<KeyedStateHandle> rawKeyedState) {\n+\t\t\tthis.rawKeyedState = checkNotNull(rawKeyedState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setRawKeyedState(KeyedStateHandle rawKeyedState) {\n+\t\t\treturn setRawKeyedState(StateObjectCollection.singleton(checkNotNull(rawKeyedState)));\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelState(StateObjectCollection<InputChannelStateHandle> inputChannelState) {\n+\t\t\tthis.inputChannelState = checkNotNull(inputChannelState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setResultSubpartitionState(StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState) {\n+\t\t\tthis.resultSubpartitionState = checkNotNull(resultSubpartitionState);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setInputChannelMappings(VirtualChannelMapping inputChannelMappings) {\n+\t\t\tthis.inputChannelMappings = checkNotNull(inputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic Builder setOutputChannelMappings(VirtualChannelMapping outputChannelMappings) {\n+\t\t\tthis.outputChannelMappings = checkNotNull(outputChannelMappings);\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\tpublic OperatorSubtaskState build() {\n+\t\t\treturn new OperatorSubtaskState(\n+\t\t\t\tmanagedOperatorState,\n+\t\t\t\trawOperatorState,\n+\t\t\t\tmanagedKeyedState,\n+\t\t\t\trawKeyedState,\n+\t\t\t\tinputChannelState,\n+\t\t\t\tresultSubpartitionState,\n+\t\t\t\tinputChannelMappings,\n+\t\t\t\toutputChannelMappings);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Captures ambiguous mappings of old channels to new channels.\n+\t *\n+\t * <p>For inputs, this mapping implies the following:\n+\t * <li>\n+\t *     <ul>{@link #oldTaskInstances} is set when there is a rescale on this task potentially leading to different\n+\t *     key groups. Upstream task has a corresponding {@link #partitionMappings} where it sends data over\n+\t *     virtual channel while specifying the channel index in the VirtualChannelSelector. This subtask then\n+\t *     demultiplexes over the virtual subtask index.</ul>\n+\t *     <ul>{@link #partitionMappings} is set when there is a downscale of the upstream task. Upstream task has\n+\t *     a corresponding {@link #oldTaskInstances} where it sends data over virtual channel while specifying the\n+\t *     subtask index in the VirtualChannelSelector. This subtask then demultiplexes over channel indexes.</ul>\n+\t * </li>\n+\t *\n+\t * <p>For outputs, it's vice-versa. The information must be kept in sync but they are used in opposite ways for\n+\t * multiplexing/demultiplexing.\n+\t *\n+\t * <p>Note that in the common rescaling case both information is set and need to be simultaneously used. If the\n+\t * input subtask subsumes the state of 3 old subtasks and a channel corresponds to 2 old channels, then there are\n+\t * 6 virtual channels to be demultiplexed.\n+\t */\n+\tpublic static class VirtualChannelMapping implements Serializable {\n+\t\tpublic static final PartitionMapping NO_CHANNEL_MAPPING = new PartitionMapping(emptyList());\n+\t\tpublic static final List<PartitionMapping> NO_PARTITIONS = emptyList();\n+\t\tpublic static final BitSet NO_SUBTASKS = new BitSet();\n+\t\tpublic static final VirtualChannelMapping NO_MAPPING = new VirtualChannelMapping(NO_SUBTASKS, NO_PARTITIONS);\n+\n+\t\t/**\n+\t\t * Set when several operator instances are merged into one.\n+\t\t */\n+\t\tprivate final BitSet oldTaskInstances;\n+\n+\t\t/**\n+\t\t * Set when channels are merged because the connected operator has been rescaled.\n+\t\t */\n+\t\tprivate final List<PartitionMapping> partitionMappings;\n+\n+\t\tpublic VirtualChannelMapping(BitSet oldTaskInstances, List<PartitionMapping> partitionMappings) {\n+\t\t\tthis.oldTaskInstances = oldTaskInstances;\n+\t\t\tthis.partitionMappings = partitionMappings;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tfinal VirtualChannelMapping that = (VirtualChannelMapping) o;\n+\t\t\treturn oldTaskInstances.equals(that.oldTaskInstances) &&\n+\t\t\t\tpartitionMappings.equals(that.partitionMappings);\n+\t\t}\n+\n+\t\tpublic int[] getOldTaskInstances(int defaultSubtask) {\n+\t\t\treturn oldTaskInstances.equals(NO_SUBTASKS) ?\n+\t\t\t\tnew int[] {defaultSubtask} :\n+\t\t\t\toldTaskInstances.stream().toArray();\n+\t\t}\n+\n+\t\tpublic PartitionMapping getPartitionMapping(int partitionIndex) {\n+\t\t\tif (partitionMappings.isEmpty()) {\n+\t\t\t\treturn NO_CHANNEL_MAPPING;\n+\t\t\t}\n+\t\t\treturn partitionMappings.get(partitionIndex);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn Objects.hash(oldTaskInstances, partitionMappings);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"VirtualChannelMapping{\" +\n+\t\t\t\t\"oldTaskInstances=\" + oldTaskInstances +\n+\t\t\t\t\", partitionMappings=\" + partitionMappings +\n+\t\t\t\t'}';\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Contains the fine-grain channel mappings that occur when a connected operator has been rescaled.\n+\t */\n+\tpublic static class PartitionMapping implements Serializable {\n+\n+\t\t/**\n+\t\t * For each new channel (=index), all old channels are set.\n+\t\t */\n+\t\tprivate final List<BitSet> newToOldChannelIndexes;", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0ODk5NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517348994", "bodyText": "If we have consecutive indexes from 0..n, what's wrong with List<Set<Integer>>? (I got the BitSet part)\nbtw it would be Map<Int, Set<Int>>.", "author": "AHeise", "createdAt": "2020-11-04T13:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5Mzg4Nw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517393887", "bodyText": "Nothing wrong performance-wise, but Map<Int, ...> just better captures the purpose:\nnewToOldChannelIndexes.get(newChannelIndex)\n\nFor the list I'd assume some iteration.", "author": "rkhachatryan", "createdAt": "2020-11-04T14:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwOTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzE4Mw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516913183", "bodyText": "IIUC, this is a cache, right?\nI doubt that we really need it: it's only used on re/starts and can save maybe hundreds of ms with DOP=1K. And without it, the code would be much simpler.\nWDYT?", "author": "rkhachatryan", "createdAt": "2020-11-03T19:42:34Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -67,29 +83,33 @@\n \tprivate final long restoreCheckpointId;\n \tprivate final boolean allowNonRestoredState;\n \n+\tprivate final Map<IntermediateResult, TaskStateAssignment> consumerAssignment = new HashMap<>();\n+\tprivate final Map<ChannelStateRescaler, ChannelRescalerRepartitioner<Object>> rescalerRepartitioners =", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNTUzNQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517335535", "bodyText": "rescalerRepartitioners would save much more as ChannelRescalerRepartitioner internally caches as well.\nBut I can take it out for now and we first measure before optimizing.", "author": "AHeise", "createdAt": "2020-11-04T13:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDc3OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516914778", "bodyText": "I wonder if this put can override existing assignment (e.g. with a UnionGate).\nIntermediateResult use as a key doesn't override equals/hashCode - is it intentional?", "author": "rkhachatryan", "createdAt": "2020-11-03T19:45:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -99,32 +119,40 @@ public void assignStates() {\n \t\t\t\t\t\toperatorID,\n \t\t\t\t\t\texecutionJobVertex.getParallelism(),\n \t\t\t\t\t\texecutionJobVertex.getMaxParallelism());\n-\t\t\t\t} else if (operatorState.getNumberCollectedStates() > 0) {\n-\t\t\t\t\tstatelessSubTasks = false;\n \t\t\t\t}\n-\t\t\t\toperatorStates.add(operatorState);\n+\t\t\t\toperatorStates.put(operatorIDPair.getGeneratedOperatorID(), operatorState);\n \t\t\t}\n-\t\t\tif (!statelessSubTasks) { // skip tasks where no operator has any state\n-\t\t\t\tassignAttemptState(executionJobVertex, operatorStates);\n+\n+\t\t\tfinal TaskStateAssignment stateAssignment = new TaskStateAssignment(executionJobVertex,\toperatorStates);\n+\t\t\tvertexAssignments.put(executionJobVertex, stateAssignment);\n+\t\t\tfor (final IntermediateResult producedDataSet : executionJobVertex.getInputs()) {\n+\t\t\t\tconsumerAssignment.put(producedDataSet, stateAssignment);", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzNzU1Mg==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517337552", "bodyText": "UnionGate reads two or more different IntermediateResult. IntermediateResult translates directly into subpartition/gate.\nHowever, it's a good point that IntermediateResult doesn't override equals/hashCode. It currently works, because the JobGraph is a graph where the objects are connected, but I don't know if we can rely on the assumption. I'm switching to IntermediateDataSetID.", "author": "AHeise", "createdAt": "2020-11-04T13:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM5NTE4NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517395184", "bodyText": "I see, thanks for the clarification and update.", "author": "rkhachatryan", "createdAt": "2020-11-04T14:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNDc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjU2OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516916568", "bodyText": "It would ease review if this class was introduced in a separate refactoring commit (though it's probably too difficult at this stage)\nCan we extract this class to a separate file?", "author": "rkhachatryan", "createdAt": "2020-11-03T19:48:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -620,18 +758,112 @@ private static void checkStateMappingCompleteness(\n \t\t\tchainOpParallelStates,\n \t\t\toldParallelism,\n \t\t\tnewParallelism);\n+\t}\n+\n+\tstatic class TaskStateAssignment {", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3MjMzNA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517372334", "bodyText": "Isn't it introduced by the two-pass refactoring commit?\nIt's a purely internal class of StateAssignmentOperation. Would it be easier because of side-by-side view or is there a different reason?", "author": "AHeise", "createdAt": "2020-11-04T14:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwMzY3Mg==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517403672", "bodyText": "Yes, but IIUC TaskStateAssignment could be added before\nReviewing is one reason, but also in general why some helper code shouldn't reside in a separate file? Member lookup would be easier for example\n\nHowever, it's probably a matter of taste.", "author": "rkhachatryan", "createdAt": "2020-11-04T14:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNzUxMA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517717510", "bodyText": "I split the two pass commit into two, but they are strongly related, so I'm not sure if the should exist on their own.", "author": "AHeise", "createdAt": "2020-11-05T00:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxNjYwMQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518416601", "bodyText": "Thanks a lot! To me, it's easier to understand changes now.", "author": "rkhachatryan", "createdAt": "2020-11-05T22:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNjU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxODU2Mw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516918563", "bodyText": "This doesn't compile (cannot find symbol getInputChannelMappings)\nProbably makes sense to extract testing methods (unless it's a temporary method)", "author": "rkhachatryan", "createdAt": "2020-11-03T19:52:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -725,6 +727,15 @@ public void deploy() throws JobException {\n \t\t\tLOG.info(\"Deploying {} (attempt #{}) with attempt id {} to {} with allocation id {}\", vertex.getTaskNameWithSubtaskIndex(),\n \t\t\t\tattemptNumber, vertex.getCurrentExecutionAttempt().getAttemptId(), getAssignedResourceLocation(), slot.getAllocationId());\n \n+\t\t\tif (taskRestore != null) {\n+\t\t\t\tcheckState(taskRestore.getTaskStateSnapshot().getSubtaskStateMappings().stream().allMatch(entry ->\n+\t\t\t\t\tentry.getValue().getInputChannelMappings().stream()\n+\t\t\t\t\t\t.allMatch(mapping -> mapping.equals(OperatorSubtaskState.VirtualChannelMapping.NO_MAPPING)) &&\n+\t\t\t\t\t\tentry.getValue().getOutputChannelMappings().stream()\n+\t\t\t\t\t\t\t.allMatch(mapping -> mapping.equals(OperatorSubtaskState.VirtualChannelMapping.NO_MAPPING))\n+\t\t\t\t), \"Rescaling from unaligned checkpoint is not yet supported.\");", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzODgzOA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517338838", "bodyText": "This is only temporary and could be avoided by having the second PR merged into the first PR. I needed a point to cancel while still allowing tests to run on the different pieces.", "author": "AHeise", "createdAt": "2020-11-04T13:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxODU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMzg1NQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516923855", "bodyText": "You probably should serialize this field and add it to the equals/hashCode.", "author": "rkhachatryan", "createdAt": "2020-11-03T20:02:09Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/state/AbstractChannelStateHandle.java", "diffHunk": "@@ -46,6 +46,11 @@\n \tprivate final List<Long> offsets;\n \tprivate final long size;\n \n+\t/**\n+\t * The original subtask index before rescaling recovery.\n+\t */\n+\tprivate int originalSubtaskIndex;", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0MDE2OQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517340169", "bodyText": "It is serialized when transferring the OperatorSubtaskState through Serializable. It's currently not needed in the checkpoints (as the information can be easily inferred). Is it still necessary from your perspective?\nI'd add it to equals/hashCode anyways.", "author": "AHeise", "createdAt": "2020-11-04T13:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwNjc0Nw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517406747", "bodyText": "That means that after recovery it's not valid until explicitly set, right?\nI think it's quite error-prone. I'd at least document this behavior and mark it deprecated to give a warning.", "author": "rkhachatryan", "createdAt": "2020-11-04T15:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEyOTU2NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518129564", "bodyText": "I made it part of the handle and it's fully serialized now. It's renamed to subtaskIndex.", "author": "AHeise", "createdAt": "2020-11-05T15:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyMzg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNTgwOA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516925808", "bodyText": "Why isn't channel state distributed to the same subtask as before (or 1st if out of range)?\n(ditto upstream)\nShouldn't recovered buffers sent from the upstream match what is on the downstream?", "author": "rkhachatryan", "createdAt": "2020-11-03T20:05:55Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/ForwardPartitioner.java", "diffHunk": "@@ -43,4 +44,14 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \tpublic String toString() {\n \t\treturn \"FORWARD\";\n \t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getUpstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.FIRST_CHANNEL;\n+\t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.ROUND_ROBIN;", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMzMjY2NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517332664", "bodyText": "You are right that things should match. However, for channel state there are two dimensions on how to scale: on subtask-level and on channel-level. If you think of a keyed exchange, a rescale on downstream means that the key ranges are changing. A rescale on upstream just means that we need to redistribute the channel state to an arbitrary other subtask.\nThat's true for all exchanges except broadcast (where we need to discard extra state). I could also opt to just have a boolean shouldRedistributeUpstreamState instead of using ChannelStateRescaler. WDYT?", "author": "AHeise", "createdAt": "2020-11-04T13:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNTgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNDE3MA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517414170", "bodyText": "I agree about using ROUND_ROBIN for the upstream.\nMy concern was mostly about the dowstream (which should be resolved by addressing the comment below).\nAs for boolean, I'd prefer ChannelStateRescaler as it's more flexible and consistent (with downstream).", "author": "rkhachatryan", "createdAt": "2020-11-04T15:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyNTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyODk1Nw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516928957", "bodyText": "How about storing a reference to the downstream/upstream TaskStateAssignment and get the mappings from there?\nI think it would be more readable.", "author": "rkhachatryan", "createdAt": "2020-11-03T20:12:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/StateAssignmentOperation.java", "diffHunk": "@@ -620,18 +758,112 @@ private static void checkStateMappingCompleteness(\n \t\t\tchainOpParallelStates,\n \t\t\toldParallelism,\n \t\t\tnewParallelism);\n+\t}\n+\n+\tstatic class TaskStateAssignment {\n+\t\tfinal ExecutionJobVertex executionJobVertex;\n+\t\tfinal Map<OperatorID, OperatorState> oldState;\n+\t\tfinal boolean hasState;\n+\t\tfinal int newParallelism;\n+\t\tfinal OperatorID inputOperatorID;\n+\t\tfinal OperatorID outputOperatorID;\n+\n+\t\tfinal Map<OperatorInstanceID, List<OperatorStateHandle>> subManagedOperatorState;\n+\t\tfinal Map<OperatorInstanceID, List<OperatorStateHandle>> subRawOperatorState;\n+\t\tfinal Map<OperatorInstanceID, List<KeyedStateHandle>> subManagedKeyedState;\n+\t\tfinal Map<OperatorInstanceID, List<KeyedStateHandle>> subRawKeyedState;\n+\n+\t\tfinal Map<OperatorInstanceID, List<InputChannelStateHandle>> inputChannelStates;\n+\t\tfinal Map<OperatorInstanceID, List<ResultSubpartitionStateHandle>> resultSubpartitionStates;\n+\t\t/** The subpartitions mappings per partition set when the output operator for a partition was rescaled. */\n+\t\tList<BitSet> outputOperatorInstanceMappings = emptyList();\n+\t\t/** The input channel mappings per input set when the input operator for a gate was rescaled. */\n+\t\tList<BitSet> inputOperatorInstanceMappings = emptyList();\n+\t\t/** The subpartitions mappings of the upstream task per input set when its output operator was rescaled. */\n+\t\tfinal Map<Integer, List<BitSet>> upstreamVirtualChannels;\n+\t\t/** The input channel mappings of the downstream task per partition set when its input operator was rescaled. */\n+\t\tfinal Map<Integer, List<BitSet>> downStreamVirtualChannels;", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwMzA0NQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517203045", "bodyText": "I like it!", "author": "AHeise", "createdAt": "2020-11-04T09:24:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkyODk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMDYzNQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516930635", "bodyText": "I'm probably misunderstanding it, but it seems it should be the opposite:\nupstream: ROUND_ROBING (or both FIRST)\ndownstream: FIRST_CHANNEL", "author": "rkhachatryan", "createdAt": "2020-11-03T20:15:26Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/GlobalPartitioner.java", "diffHunk": "@@ -40,6 +41,16 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \t\treturn this;\n \t}\n \n+\t@Override\n+\tpublic ChannelStateRescaler getUpstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.FIRST_CHANNEL;\n+\t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.ROUND_ROBIN;", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NjUxOQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517176519", "bodyText": "Yes changed that (see comment below). On upstream it should be almost always round robin (broadcasting partitioner is the only exception where we drop extra state).", "author": "AHeise", "createdAt": "2020-11-04T08:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMDYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMjU2Ng==", "url": "https://github.com/apache/flink/pull/13735#discussion_r516932566", "bodyText": "OK now I see why the Rescalers used seemed inverted to me :)\nSo why is it inverted here? (maybe add a comment?)", "author": "rkhachatryan", "createdAt": "2020-11-03T20:19:34Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -692,6 +692,8 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \t\t}\n \t\t// set strategy name so that web interface can show it.\n \t\tjobEdge.setShipStrategyName(partitioner.toString());\n+\t\tjobEdge.setDownstreamChannelStateRescaler(partitioner.getUpstreamChannelStateRescaler());\n+\t\tjobEdge.setUpstreamChannelStateRescaler(partitioner.getDownstreamChannelStateRescaler());", "originalCommit": "9cbbcb24751268c0b5289b86606eb28baa1287eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NjEwNg==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517176106", "bodyText": "There is no good reason except me screwing up. I did a couple of renamings prior to republishing PR and apparently renamed things asymetrically. I adjusted it (so upstream is now set to upstream).\nSorry for the confusion and good catch.", "author": "AHeise", "createdAt": "2020-11-04T08:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMjU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxNTg4MA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517415880", "bodyText": "No worries, thanks for updating.", "author": "rkhachatryan", "createdAt": "2020-11-04T15:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMjU2Ng=="}], "type": "inlineReview"}, {"oid": "0f3def2083865476155570e53910962f3ecd1b56", "url": "https://github.com/apache/flink/commit/0f3def2083865476155570e53910962f3ecd1b56", "message": "[hotfix][tests] Remove unused methods in ChannelPersistenceITCase.", "committedDate": "2020-11-03T20:51:36Z", "type": "commit"}, {"oid": "cbbf00c155253f4b646d529186533bbb0a9b97d6", "url": "https://github.com/apache/flink/commit/cbbf00c155253f4b646d529186533bbb0a9b97d6", "message": "[hotfix][util] Fix Precondition#checkNotNull annotations.", "committedDate": "2020-11-03T20:51:39Z", "type": "commit"}, {"oid": "6e28739d48218fe1c085a4eb6aee8c52e2b08fd9", "url": "https://github.com/apache/flink/commit/6e28739d48218fe1c085a4eb6aee8c52e2b08fd9", "message": "[hotfix][tests] Chain unexpected exception to assertion error.", "committedDate": "2020-11-03T20:51:39Z", "type": "commit"}, {"oid": "7139e2595f2dd3415c5cc30877fc9dd1aa003a43", "url": "https://github.com/apache/flink/commit/7139e2595f2dd3415c5cc30877fc9dd1aa003a43", "message": "[hotfix][core] InstantiationUtil#serializeObject creates ObjectOutputStream only when necessary.", "committedDate": "2020-11-03T20:51:39Z", "type": "commit"}, {"oid": "59aa5bcf5e346746b68ca08d7bf7c9f1b94bd08a", "url": "https://github.com/apache/flink/commit/59aa5bcf5e346746b68ca08d7bf7c9f1b94bd08a", "message": "[hotfix][checkpoint/test] Don't swallow the original exception when cleanup fails as well.", "committedDate": "2020-11-04T23:56:36Z", "type": "commit"}, {"oid": "2ee4d7726fedfffea6c37939111ab5bfe09d41d7", "url": "https://github.com/apache/flink/commit/2ee4d7726fedfffea6c37939111ab5bfe09d41d7", "message": "[FLINK-19533][checkpoint] Rewrite StateAssignmentOperation to only use generated OperatorID.", "committedDate": "2020-11-04T23:56:49Z", "type": "commit"}, {"oid": "261321d5f60428d1375f824f8cf368acef43542e", "url": "https://github.com/apache/flink/commit/261321d5f60428d1375f824f8cf368acef43542e", "message": "[FLINK-19533][checkpoint] Introduce builder for OperatorSubtaskState.\n\nThe builder will make it easier to add more fields to OperatorSubtaskState in future commits.", "committedDate": "2020-11-04T23:56:49Z", "type": "commit"}, {"oid": "0842a69cf1832599e0259c456398b18577137dc1", "url": "https://github.com/apache/flink/commit/0842a69cf1832599e0259c456398b18577137dc1", "message": "[hotfix][checkpoint] Remove NonNull annotations and remove trivial doc in OperatorSubtaskState.", "committedDate": "2020-11-04T23:56:49Z", "type": "commit"}, {"oid": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "url": "https://github.com/apache/flink/commit/bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR.", "committedDate": "2020-11-05T00:50:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk2NjY5MQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517966691", "bodyText": "This will not distribute state to the newer tasks in case of up-scaling, right?\nI think it can cause problems if the user-supplied partitioner relies on the new DOP.\nOTH, if not supported officially, we can leave it as it.\nWDYT?", "author": "rkhachatryan", "createdAt": "2020-11-05T11:03:35Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/CustomPartitionerWrapper.java", "diffHunk": "@@ -55,6 +56,14 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \t\treturn partitioner.partition(key, numberOfChannels);\n \t}\n \n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\t// fully rely on filtering downstream\n+\t\t// note that custom partitioners are not officially supported - the user has to force rescaling\n+\t\t// in that case, we assume that the custom partitioner is deterministic\n+\t\treturn ChannelStateRescaler.BROADCAST;", "originalCommit": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzMzEzNw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518033137", "bodyText": "BROADCAST would replicate each channel state to each subtask (very costly) including all new states. All superfluous replicas are filtered out downstream by the partitioner.\nNote that I will extend your check for cyclic graphs to customer partitioners for disabling UC. So the user has to force it to make it work. However, I do not see a reason to then fail on the second level again.", "author": "AHeise", "createdAt": "2020-11-05T13:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk2NjY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQxNzU5OQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518417599", "bodyText": "Yes, you are right.", "author": "rkhachatryan", "createdAt": "2020-11-05T22:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk2NjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3MzczMA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517973730", "bodyText": "Is FIRST_CHANNEL here (i.e. during the assignment) the same as in selectChannel (i.e. during sending the data)?\nIn other words, I think this will put all InputChannel state into a single subtask, while it should go to the same subtasks as before the rescaling.\nWDYT?", "author": "rkhachatryan", "createdAt": "2020-11-05T11:16:05Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/partitioner/ForwardPartitioner.java", "diffHunk": "@@ -43,4 +44,9 @@ public int selectChannel(SerializationDelegate<StreamRecord<T>> record) {\n \tpublic String toString() {\n \t\treturn \"FORWARD\";\n \t}\n+\n+\t@Override\n+\tpublic ChannelStateRescaler getDownstreamChannelStateRescaler() {\n+\t\treturn ChannelStateRescaler.FIRST_CHANNEL;", "originalCommit": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE3NTQwOA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518175408", "bodyText": "Really good catch. I was confused by the selection process of ForwardPartitioner always selecting 0. But what we want is to have a round robin distribution (so assign same as before in case of upscaling), redistribute on downscale to avoid data loss.\nI used this find to rethink the nomenclature and actually everything that is related to ChannelStateRescaler is actually about subtask instance mapping, so I renamed to SubtaskStateMapper. Then it becomes immediately apparent that choosing the first task is plain wrong here.", "author": "AHeise", "createdAt": "2020-11-05T16:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3MzczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQyODY5OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518428698", "bodyText": "Yes, ROUND_ROBIN makes sense here and the new naming looks good!", "author": "rkhachatryan", "createdAt": "2020-11-05T23:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3MzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NDY3Mw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517974673", "bodyText": "I think this field needs to be (de)serialized by MetadataSerializer as other fields are.\n(ditto outputRescalingDescriptor)", "author": "rkhachatryan", "createdAt": "2020-11-05T11:17:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/OperatorSubtaskState.java", "diffHunk": "@@ -64,81 +61,64 @@\n \t/**\n \t * Snapshot from the {@link org.apache.flink.runtime.state.OperatorStateBackend}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<OperatorStateHandle> managedOperatorState;\n \n \t/**\n \t * Snapshot written using {@link org.apache.flink.runtime.state.OperatorStateCheckpointOutputStream}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<OperatorStateHandle> rawOperatorState;\n \n \t/**\n \t * Snapshot from {@link org.apache.flink.runtime.state.KeyedStateBackend}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<KeyedStateHandle> managedKeyedState;\n \n \t/**\n \t * Snapshot written using {@link org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream}.\n \t */\n-\t@Nonnull\n \tprivate final StateObjectCollection<KeyedStateHandle> rawKeyedState;\n \n-\t@Nonnull\n \tprivate final StateObjectCollection<InputChannelStateHandle> inputChannelState;\n \n-\t@Nonnull\n \tprivate final StateObjectCollection<ResultSubpartitionStateHandle> resultSubpartitionState;\n \n \t/**\n-\t * The state size. This is also part of the deserialized state handle.\n-\t * We store it here in order to not deserialize the state handle when\n-\t * gathering stats.\n+\t * The subpartitions mappings per partition set when the output operator for a partition was rescaled. The key is\n+\t * the partition id and the value contains all subtask indexes of the output operator before rescaling.\n \t */\n-\tprivate final long stateSize;\n+\tprivate final InflightDataRescalingDescriptor inputRescalingDescriptor;", "originalCommit": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE3ODQ1Mw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518178453", "bodyText": "Hm in the serialized form it would always be empty, so I'm not sure what the advantage is (it can only be filled when you know the post-scale parallelism, which you wouldn't know in a checkpoint).", "author": "AHeise", "createdAt": "2020-11-05T16:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NDY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQyNTk4MQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518425981", "bodyText": "Yes, you are right (nit: maybe comment that it's only computed upon assignment?)", "author": "rkhachatryan", "createdAt": "2020-11-05T23:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NDY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1NTg4OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518555888", "bodyText": "Added a comment.\nNote that this field is only set by {@link StateAssignmentOperation} and will not be persisted in the checkpoint itself as it can only be calculated if the the post-recovery scale factor is known.", "author": "AHeise", "createdAt": "2020-11-06T06:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NDY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NTg0MA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517975840", "bodyText": "nit:\nThis field makes this class non-thread-safe, which is not obvious for a pre-computed mapping.\nSo I'd mark this class @NotThreadSafe.", "author": "rkhachatryan", "createdAt": "2020-11-05T11:19:59Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/RescaledChannelsMapping.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Contains the fine-grain channel mappings that occur when a connected operator has been rescaled.\n+ */\n+public class RescaledChannelsMapping implements Serializable {\n+\tpublic static final RescaledChannelsMapping NO_CHANNEL_MAPPING = new RescaledChannelsMapping(emptyMap());\n+\n+\tprivate static final long serialVersionUID = -8719670050630674631L;\n+\n+\t/**\n+\t * For each new channel (=index), all old channels are set.\n+\t */\n+\tprivate final Map<Integer, Set<Integer>> newToOldChannelIndexes;\n+\n+\t/**\n+\t * For each old channel (=index), all new channels are set. Lazily calculated to keep {@link OperatorSubtaskState}\n+\t * small in terms of serialization cost.\n+\t */\n+\tprivate transient Map<Integer, Set<Integer>> oldToNewChannelIndexes;", "originalCommit": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE3OTAyOQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518179029", "bodyText": "Actually I made it quasi-thread safe, where no fields are updated anymore (see your other suggestion). I refrain from doing defensive copies as it's purely internal.", "author": "AHeise", "createdAt": "2020-11-05T16:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NTg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NzQxMw==", "url": "https://github.com/apache/flink/pull/13735#discussion_r517977413", "bodyText": "nit:\nAfter removing the higher level cache, this field can also be computed eagerly think (as it will be used anyways if the is being object is constructed).", "author": "rkhachatryan", "createdAt": "2020-11-05T11:22:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ChannelRescalerRepartitioner.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.io.network.api.writer.ChannelStateRescaler;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * A repartitioner that assigns the same channel state to multiple subtasks according to some mapping.\n+ *\n+ * <p>The replicated data will then be filtered before processing the record.\n+ *\n+ * <p>Note that channel mappings are cached for the same parallelism changes.\n+ */\n+public class ChannelRescalerRepartitioner<T> implements OperatorStateRepartitioner<T> {\n+\tprivate final ChannelStateRescaler channelStateRescaler;\n+\tprivate final Map<Tuple2<Integer, Integer>, Map<Integer, Set<Integer>>> newToOldMappingCache = new HashMap<>(2);", "originalCommit": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1MjUxOQ==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518152519", "bodyText": "You are right. I needed to adjust abstractions a bit (and I think it's more logical now):\n\ncreateNewToOldMapping is now part of ChannelStateRescaler (which is now named SubtaskStateMapper).\nChannelRescalerRepartitioner is renamed to MappingBasedRepartitioner. It's an pseudo-immutable class that simply applies the mapping to the state.", "author": "AHeise", "createdAt": "2020-11-05T15:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NzQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA2MTc2Ng==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518061766", "bodyText": "(nit) I was a bit confused by this method. Maybe this version would be more readable:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal Map<Integer, Set<Integer>> newToOldMapping = getNewToOldMapping(oldParallelism, newParallelism);\n          \n          \n            \n            \t\treturn IntStream.range(0, newParallelism)\n          \n          \n            \n            \t\t\t.mapToObj(newIndex -> getOldState(previousParallelSubtaskStates, newToOldMapping.get(newIndex)))\n          \n          \n            \n            \t\t\t.collect(Collectors.toList());\n          \n          \n            \n            \t\treturn getNewToOldMapping(oldParallelism, newParallelism)\n          \n          \n            \n            \t\t\t.entrySet().stream()\n          \n          \n            \n            \t\t\t.sorted(Comparator.comparingInt(Map.Entry::getKey)).map(Map.Entry::getValue)\n          \n          \n            \n            \t\t\t.map(oldIndices -> getOldState(previousParallelSubtaskStates, oldIndices))\n          \n          \n            \n            \t\t\t.collect(Collectors.toList());", "author": "rkhachatryan", "createdAt": "2020-11-05T13:46:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/ChannelRescalerRepartitioner.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.io.network.api.writer.ChannelStateRescaler;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+/**\n+ * A repartitioner that assigns the same channel state to multiple subtasks according to some mapping.\n+ *\n+ * <p>The replicated data will then be filtered before processing the record.\n+ *\n+ * <p>Note that channel mappings are cached for the same parallelism changes.\n+ */\n+public class ChannelRescalerRepartitioner<T> implements OperatorStateRepartitioner<T> {\n+\tprivate final ChannelStateRescaler channelStateRescaler;\n+\tprivate final Map<Tuple2<Integer, Integer>, Map<Integer, Set<Integer>>> newToOldMappingCache = new HashMap<>(2);\n+\n+\tpublic ChannelRescalerRepartitioner(ChannelStateRescaler channelStateRescaler) {\n+\t\tthis.channelStateRescaler = channelStateRescaler;\n+\t}\n+\n+\tprivate static <T> List<T> getOldState(List<List<T>> previousParallelSubtaskStates, Set<Integer> oldIndexes) {\n+\t\tswitch (oldIndexes.size()) {\n+\t\t\tcase 0:\n+\t\t\t\treturn Collections.emptyList();\n+\t\t\tcase 1:\n+\t\t\t\treturn previousParallelSubtaskStates.get(Iterables.getOnlyElement(oldIndexes));\n+\t\t\tdefault:\n+\t\t\t\treturn oldIndexes.stream()\n+\t\t\t\t\t.flatMap(oldIndex -> previousParallelSubtaskStates.get(oldIndex).stream())\n+\t\t\t\t\t.collect(Collectors.toList());\n+\t\t}\n+\t}\n+\n+\tprotected Map<Integer, Set<Integer>> createNewToOldMapping(int oldParallelism, int newParallelism) {\n+\t\treturn IntStream.range(0, newParallelism).boxed().\n+\t\t\tcollect(Collectors.toMap(\n+\t\t\t\tFunction.identity(),\n+\t\t\t\tchannelIndex -> channelStateRescaler.getOldChannels(\n+\t\t\t\t\tchannelIndex,\n+\t\t\t\t\toldParallelism,\n+\t\t\t\t\tnewParallelism)));\n+\t}\n+\n+\t@Override\n+\tpublic List<List<T>> repartitionState(\n+\t\t\tList<List<T>> previousParallelSubtaskStates,\n+\t\t\tint oldParallelism,\n+\t\t\tint newParallelism) {\n+\t\tfinal Map<Integer, Set<Integer>> newToOldMapping = getNewToOldMapping(oldParallelism, newParallelism);\n+\t\treturn IntStream.range(0, newParallelism)\n+\t\t\t.mapToObj(newIndex -> getOldState(previousParallelSubtaskStates, newToOldMapping.get(newIndex)))\n+\t\t\t.collect(Collectors.toList());", "originalCommit": "bfd138a5fda6a4eeb4544cc88f9e5660063ab084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE2Mzk4OA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518163988", "bodyText": "It's good feedback if stuff is confusing. I'll offer an alternative that avoids using streams:\n\t\tList<List<T>> repartitioned = new ArrayList<>();\n\t\tfor (int newIndex = 0; newIndex < newParallelism; newIndex++) {\n\t\t\trepartitioned.add(getOldState(previousParallelSubtaskStates, newToOldSubtasksMapping.get(newIndex)));\n\t\t}\n\t\treturn repartitioned;", "author": "AHeise", "createdAt": "2020-11-05T15:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA2MTc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQyMzk0NA==", "url": "https://github.com/apache/flink/pull/13735#discussion_r518423944", "bodyText": "Even better!", "author": "rkhachatryan", "createdAt": "2020-11-05T23:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA2MTc2Ng=="}], "type": "inlineReview"}, {"oid": "406c9c98283632db5387f39783cab997c1a7e39c", "url": "https://github.com/apache/flink/commit/406c9c98283632db5387f39783cab997c1a7e39c", "message": "[FLINK-19533][runtime/streaming] Add SubtaskStateMapper to determine mapping between old and new subtasks.\n\nEach partitioner has a unique way to partition data. Only the partitioner can narrow down the state of old subtasks needed to recover the data on upstream and downstream side.\n\nNote that the mapper may create non-unique mappings during unaligned checkpoint rescaling. The replicated data will then be filtered by the partitioner downstream during recovery.", "committedDate": "2020-11-05T16:37:14Z", "type": "commit"}, {"oid": "7575c9ee7672e5ea2eed72d6ca035e78720a662c", "url": "https://github.com/apache/flink/commit/7575c9ee7672e5ea2eed72d6ca035e78720a662c", "message": "[FLINK-19533][checkpoint] Adding subtask index to channel state handles.\n\nDuring downscaled recovery of in-flight data, multiple channel state handles are recovered at the same subtask and the subtask index is needed to distinguish between them.", "committedDate": "2020-11-05T16:37:14Z", "type": "commit"}, {"oid": "8af2e7d13178bc0cfebbbb98d9768cc03095a9a6", "url": "https://github.com/apache/flink/commit/8af2e7d13178bc0cfebbbb98d9768cc03095a9a6", "message": "[FLINK-19533][checkpoint] Add TaskStateAssignment to capture all intermediate state of StateAssignmentOperation.\n\nTaskStateAssignment encapsulates the state of one task and is ultimately transformed into an OperatorSubtaskState.\n\nNote this commit also removes ChannelStateNoRescalingPartitionerTest since it's not valid at the end of the PR anymore.", "committedDate": "2020-11-05T16:37:14Z", "type": "commit"}, {"oid": "8777cdb0c35cd13da2c8688959a177cb2f668513", "url": "https://github.com/apache/flink/commit/8777cdb0c35cd13da2c8688959a177cb2f668513", "message": "[FLINK-19533][checkpoint] Add multipass StateAssignmentOperation.\n\nThis change allows StateAssignmentOperation to update the state assignment of one task while processing another task. The next commit will use it to set rescaling descriptor of upstream/downstream nodes.", "committedDate": "2020-11-05T16:37:14Z", "type": "commit"}, {"oid": "c95db355becc1079be6287aa7d165e7590f9fcf6", "url": "https://github.com/apache/flink/commit/c95db355becc1079be6287aa7d165e7590f9fcf6", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR.", "committedDate": "2020-11-05T16:37:14Z", "type": "forcePushed"}, {"oid": "031ba1603f4a06de8a7f22aa44c1413eed29d342", "url": "https://github.com/apache/flink/commit/031ba1603f4a06de8a7f22aa44c1413eed29d342", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR.", "committedDate": "2020-11-06T07:02:41Z", "type": "commit"}, {"oid": "031ba1603f4a06de8a7f22aa44c1413eed29d342", "url": "https://github.com/apache/flink/commit/031ba1603f4a06de8a7f22aa44c1413eed29d342", "message": "[FLINK-19533][checkpoint] Add InflightDataRescalingDescriptor during rescaling.\n\nThe descriptor contains virtual channel mappings that are used to restore spanning records while physical channels have been ambiguously rearranged (up- or downstream DOP changes).\nNote that the actual recovery with virtual channel will be added in a follow-up PR.", "committedDate": "2020-11-06T07:02:41Z", "type": "forcePushed"}]}