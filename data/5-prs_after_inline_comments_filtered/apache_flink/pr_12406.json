{"pr_number": 12406, "pr_title": " [FLINK-17994][checkpointing] Fix the race condition between CheckpointBarrierUnaligner#processBarrier and #notifyBarrierReceived", "pr_createdAt": "2020-05-29T10:20:01Z", "pr_url": "https://github.com/apache/flink/pull/12406", "timeline": [{"oid": "4cf5e8e7e8855ed96b77cef16b6f96c66ef7eed5", "url": "https://github.com/apache/flink/commit/4cf5e8e7e8855ed96b77cef16b6f96c66ef7eed5", "message": "[hotfix][checkpointing] Fix the formatting of CheckpointBarrierUnaligner", "committedDate": "2020-05-29T10:56:55Z", "type": "commit"}, {"oid": "7f43de47342c79294e9e7b05c088b44e2112fe2e", "url": "https://github.com/apache/flink/commit/7f43de47342c79294e9e7b05c088b44e2112fe2e", "message": "[FLINK-17994][checkpointing] Fix the race condition between CheckpointBarrierUnaligner#processBarrier and #notifyBarrierReceived\n\nThe race condition happens as following:\n1. CheckpointBarrierUnaligner#notifyBarrierReceived triggers an async checkpoint(ch1) in mailbox by netty thread.\n2. CheckpointBarrierUnaligner#processBarrier also triggers a sync checkpoint(ch2) by task thread and executes immediately.\n3. When ch1 is taken from mailbox by task thread to execute, it will cause illegal argument exception because it is smaller than the previous executed ch2.\n\nFor async checkpoint action, before it is actual executing, we can compare its id with previous executed checkpoint id. If it is not larger than the previous\none, we should ignore it to exit directly.", "committedDate": "2020-05-29T11:04:24Z", "type": "forcePushed"}, {"oid": "f8cd1eac843c85418434db3f82cc1c8f97de3392", "url": "https://github.com/apache/flink/commit/f8cd1eac843c85418434db3f82cc1c8f97de3392", "message": "[FLINK-17994][checkpointing] Fix the race condition between CheckpointBarrierUnaligner#processBarrier and #notifyBarrierReceived\n\nThe race condition happens as following:\n1. CheckpointBarrierUnaligner#notifyBarrierReceived triggers an async checkpoint(ch1) in mailbox by netty thread.\n2. CheckpointBarrierUnaligner#processBarrier also triggers a sync checkpoint(ch2) by task thread and executes immediately.\n3. When ch1 is taken from mailbox by task thread to execute, it will cause illegal argument exception because it is smaller than the previous executed ch2.\n\nFor async checkpoint action, before it is actual executing, we can compare its id with previous executed checkpoint id. If it is not larger than the previous\none, we should ignore it to exit directly.", "committedDate": "2020-05-29T11:09:35Z", "type": "forcePushed"}, {"oid": "bee02498f028f38676813dde3b99d318ace084aa", "url": "https://github.com/apache/flink/commit/bee02498f028f38676813dde3b99d318ace084aa", "message": "[FLINK-17994][checkpointing] Fix the race condition between CheckpointBarrierUnaligner#processBarrier and #notifyBarrierReceived\n\nThe race condition happens as following:\n1. CheckpointBarrierUnaligner#notifyBarrierReceived triggers an async checkpoint(ch1) in mailbox by netty thread.\n2. CheckpointBarrierUnaligner#processBarrier also triggers a sync checkpoint(ch2) by task thread and executes immediately.\n3. When ch1 is taken from mailbox by task thread to execute, it will cause illegal argument exception because it is smaller than the previous executed ch2.\n\nFor async checkpoint action, before it is actual executing, we can compare its id with previous executed checkpoint id. If it is not larger than the previous\none, we should ignore it to exit directly.", "committedDate": "2020-05-29T11:11:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxMzU2Nw==", "url": "https://github.com/apache/flink/pull/12406#discussion_r432413567", "bodyText": "nit: isn't this comment still valid and worth keeping?", "author": "pnowojski", "createdAt": "2020-05-29T11:07:23Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -164,33 +158,32 @@ public void processBarrier(\n \t\t\thasInflightBuffers[channelIndex] = false;\n \t\t\tnumBarrierConsumed++;\n \t\t}\n-\t\t// processBarrier is called from task thread and can actually happen before notifyBarrierReceived on empty\n-\t\t// buffer queues\n-\t\t// to avoid replicating any logic, we simply call notifyBarrierReceived here as well", "originalCommit": "4cf5e8e7e8855ed96b77cef16b6f96c66ef7eed5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2MTMzMw==", "url": "https://github.com/apache/flink/pull/12406#discussion_r432561333", "bodyText": "It indeed provides a bit richer information than the javadoc of this method, and i can consider to retain it.", "author": "zhijiangW", "createdAt": "2020-05-29T15:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxMzU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxNDU2Mw==", "url": "https://github.com/apache/flink/pull/12406#discussion_r432414563", "bodyText": "nit: just drop the comment as it only adds words \"the\" and \"of\" to the variable name", "author": "pnowojski", "createdAt": "2020-05-29T11:09:41Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -284,21 +280,18 @@ private int getFlattenedChannelIndex(InputChannelInfo channelInfo) {\n \t\t */\n \t\tprivate long currentReceivedCheckpointId = -1L;\n \n-\t\t/** The number of opened channels. */\n+\t\t/** The number of open channels. */", "originalCommit": "4cf5e8e7e8855ed96b77cef16b6f96c66ef7eed5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MjIyNQ==", "url": "https://github.com/apache/flink/pull/12406#discussion_r432462225", "bodyText": "I think this is not the best way to test this race condition. It's dubious to override a class that we want to test here (ValidatingCheckpointBarrierUnaligner). Also this is a very tight coupling and depending on the private implementation details, which assumes executeInTaskThread will be called only once. More over it brakes an assumption that mails should be executed in order.\nI think it would be much better to do in the following manner:\n\n\nstraighten up threading model a bit and do not enqueue any emails in CheckpointBarrierUnaligner#processBarrier call, as this is already happening inside mailbox thread. It introduces unnecessary possibility for the race conditions and makes our live so much more difficult in this test. Currently by going through mailbox in processBarrier we are avoiding a bit of code duplication/simplifing a bit notifyBarrierReceived method, in an exchange of bad threading model and actually IMO more complicated code. We should fix this either way.\n\n\npass an AbstractInvokable instance that would be using SteppingMailboxProcessor to implement org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable#executeInTaskThread\n\n\ninside the testConcurrentProcessBarrierAndNotifyBarrierReceived test do the following sequence:\n\n\nhandler.getThreadSafeUnaligner().notifyBarrierReceived(buildCheckpointBarrier(0), channelInfo); // (a)\nhandler.processBarrier(buildCheckpointBarrier(1), 0); // (b)\nsteppingMailboxExecutor.runMailboxStep(); // (c)\n\n(c) would execute mailbox action from (a).\nThis would test the race condition without braking any contracts (like out of order mail execution) and without overriding CheckpointBarrierUnaligner.", "author": "pnowojski", "createdAt": "2020-05-29T12:53:35Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -639,4 +673,79 @@ public long getLastCanceledCheckpointId() {\n \t\t\treturn lastCanceledCheckpointId;\n \t\t}\n \t}\n+\n+\t/**\n+\t * Specific {@link AbstractInvokable} implementation to record and validate which checkpoint\n+\t * id is executed and how many checkpoints are executed.\n+\t */\n+\tprivate static final class ValidatingCheckpointInvokable extends AbstractInvokable {\n+\n+\t\tprivate long expectedCheckpointId;\n+\n+\t\tprivate int totalNumCheckpoints;\n+\n+\t\tValidatingCheckpointInvokable() {\n+\t\t\tsuper(new DummyEnvironment(\"test\", 1, 0));\n+\t\t}\n+\n+\t\tpublic void invoke() {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\n+\t\tpublic void triggerCheckpointOnBarrier(\n+\t\t\t\tCheckpointMetaData checkpointMetaData,\n+\t\t\t\tCheckpointOptions checkpointOptions,\n+\t\t\t\tCheckpointMetrics checkpointMetrics) {\n+\t\t\texpectedCheckpointId = checkpointMetaData.getCheckpointId();\n+\t\t\ttotalNumCheckpoints++;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic <E extends Exception> void executeInTaskThread(\n+\t\t\t\tThrowingRunnable<E> runnable,\n+\t\t\t\tString descriptionFormat,\n+\t\t\t\tObject... descriptionArgs) throws E {\n+\t\t\trunnable.run();\n+\t\t}\n+\n+\t\tlong getTriggeredCheckpointId() {\n+\t\t\treturn expectedCheckpointId;\n+\t\t}\n+\n+\t\tint getTotalTriggeredCheckpoints() {\n+\t\t\treturn totalNumCheckpoints;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Specific {@link CheckpointBarrierUnaligner} implementation to mock the scenario that the later triggered\n+\t * checkpoint executes before the preceding triggered checkpoint.\n+\t */\n+\tprivate static final class ValidatingCheckpointBarrierUnaligner extends CheckpointBarrierUnaligner {\n+\n+\t\tprivate ThrowingRunnable waitingRunnable;\n+\t\tprivate boolean firstRunnable = true;\n+\n+\t\tValidatingCheckpointBarrierUnaligner(AbstractInvokable invokable) {\n+\t\t\tsuper(\n+\t\t\t\tnew int[]{1},\n+\t\t\t\tnew ChannelStateWriter.NoOpChannelStateWriter(),\n+\t\t\t\t\"test\",\n+\t\t\t\tinvokable);\n+\t\t}\n+\n+\t\t@Override\n+\t\tprotected <E extends Exception> void executeInTaskThread(\n+\t\t\t\tThrowingRunnable<E> runnable,\n+\t\t\t\tString descriptionFormat,\n+\t\t\t\tObject... descriptionArgs) throws E {\n+\t\t\tif (firstRunnable) {\n+\t\t\t\twaitingRunnable = runnable;\n+\t\t\t\tfirstRunnable = false;\n+\t\t\t} else {\n+\t\t\t\tsuper.executeInTaskThread(runnable, \"checkpoint\");\n+\t\t\t\tsuper.executeInTaskThread(waitingRunnable, \"checkpoint\");\n+\t\t\t}\n+\t\t}\n+\t}", "originalCommit": "bee02498f028f38676813dde3b99d318ace084aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU1OTUzMg==", "url": "https://github.com/apache/flink/pull/12406#discussion_r432559532", "bodyText": "I indeed considered the way of verifying the race condition via somehow real AbstractInvokable with TaskMailbox, but also thought that these two components are a bit far away from CheckpointBarrierHandler and they are also a bit heavy-weight components from themselves.\nFrom the aspect of touching less external components in unit tests, i chose the current way. Actually I bypassed the mailbox implementation and simulate the race condition via executing the runnable in mis-order way. The propose for introducing ValidatingCheckpointInvokable and ValidatingCheckpointBarrierUnaligner is just for avoiding relying on external components of AbstractInvokable and TaskMailbox in unit tests.\nAnd this test is for verifying the processes of CheckpointBarrierUnaligner#processBarrier and #notifyBarrierReceived, to confirm the new introduced method CheckpointBarrierUnaligner#notifyCheckpoint really effect in these interactions. All these three methods would be really touched in this test.\nFrom another aspect, for the interaction between two components it is better to verify the real interactions using two real components without re-implementing either sides. Then any internal core changes in either component will be reflected in the test. For this case, actually the CheckpointBarrierUnaligner component will interact with AbstractInvokable with internal TaskMailbox model.  SteppingMailboxProcessor is also a re-implemented model to replace the real component inside AbstractInvokable, so it somehow still relies on the private implementation inside SteppingMailboxProcessor.\nAll in all, it might be better than my current way, and i can try out to use the real model AMAP in this test.", "author": "zhijiangW", "createdAt": "2020-05-29T15:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MjIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgxNTI2NQ==", "url": "https://github.com/apache/flink/pull/12406#discussion_r432815265", "bodyText": "I wasn't meaning to pass a real AbstractInvocable, but an equivalent of DummyInvokable that has a SteppingMailboxProcessor (SteppingMailboxProcessor already exists in the code base and I'm not even sure if you could just use plain MailboxProcessor)\n\nFor this case, actually the CheckpointBarrierUnaligner component will interact with AbstractInvokable with internal TaskMailbox model. SteppingMailboxProcessor is also a re-implemented model to replace the real component inside AbstractInvokable, so it somehow still relies on the private implementation inside SteppingMailboxProcessor.\n\nIt's not the same.\n\n\nIn your case, you are modifying the class that you are testing, which invalidates the test to some extent. To some extent you are testing your test implementation and you have to assume by looking at the code, that it doesn't affect the purpose of the test.\n\n\nThe idea of mocking (for example passing DummyInvokable with SteppingMailboxProcessor) is that you provide a mock implementation of some interface, that adheres to the contract of those interfaces (maybe in limited/restricted scope, but it shouldn't be braking them) and you pass them to real production code that you intend to test.\n\n\nFor example imagine a change, if CheckpointBarrierUnaligner changes and enqueues one more mail in one of the calls. Or that it starts relying on the fact, that order of enqueued emails guarantees their execution order - both of those refactorings would be valid but wouldn't work with your current implementation, giving false failing test.", "author": "pnowojski", "createdAt": "2020-05-30T06:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MjIyNQ=="}], "type": "inlineReview"}, {"oid": "1eb3132c8bab5097d5f7f0f02760e109122915ea", "url": "https://github.com/apache/flink/commit/1eb3132c8bab5097d5f7f0f02760e109122915ea", "message": "[FLINK-17994][checkpointing] Fix the race condition between CheckpointBarrierUnaligner#processBarrier and #notifyBarrierReceived\n\nThe race condition happens as following:\n1. CheckpointBarrierUnaligner#notifyBarrierReceived triggers an async checkpoint(ch1) in mailbox by netty thread.\n2. CheckpointBarrierUnaligner#processBarrier also triggers a sync checkpoint(ch2) by task thread and executes immediately.\n3. When ch1 is taken from mailbox by task thread to execute, it will cause illegal argument exception because it is smaller than the previous executed ch2.\n\nFor async checkpoint action, before it is actual executing, we can compare its id with previous executed checkpoint id. If it is not larger than the previous\none, we should ignore it to exit directly.\n\nThis closes #12406.", "committedDate": "2020-06-01T08:35:34Z", "type": "commit"}, {"oid": "1eb3132c8bab5097d5f7f0f02760e109122915ea", "url": "https://github.com/apache/flink/commit/1eb3132c8bab5097d5f7f0f02760e109122915ea", "message": "[FLINK-17994][checkpointing] Fix the race condition between CheckpointBarrierUnaligner#processBarrier and #notifyBarrierReceived\n\nThe race condition happens as following:\n1. CheckpointBarrierUnaligner#notifyBarrierReceived triggers an async checkpoint(ch1) in mailbox by netty thread.\n2. CheckpointBarrierUnaligner#processBarrier also triggers a sync checkpoint(ch2) by task thread and executes immediately.\n3. When ch1 is taken from mailbox by task thread to execute, it will cause illegal argument exception because it is smaller than the previous executed ch2.\n\nFor async checkpoint action, before it is actual executing, we can compare its id with previous executed checkpoint id. If it is not larger than the previous\none, we should ignore it to exit directly.\n\nThis closes #12406.", "committedDate": "2020-06-01T08:35:34Z", "type": "forcePushed"}]}