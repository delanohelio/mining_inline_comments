{"pr_number": 12966, "pr_title": "[FLINK-17427][table sql/planner]Support SupportsPartitionPushDown in \u2026", "pr_createdAt": "2020-07-23T07:08:48Z", "pr_url": "https://github.com/apache/flink/pull/12966", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYzMTE2NA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460631164", "bodyText": "!Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\")) can be simplified as Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"source: [partitions=\"))", "author": "godfreyhe", "createdAt": "2020-07-27T03:43:55Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwMDk2OA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460900968", "bodyText": "I think we can return false if partitioned field names is empty", "author": "godfreyhe", "createdAt": "2020-07-27T13:46:12Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwMTg1Ng==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460901856", "bodyText": "listPartitions  is a very heavy operation, the onMatch method will also use the partition values. so it's better we get the result once. We can remove the validation whether the partitions is present.", "author": "godfreyhe", "createdAt": "2020-07-27T13:47:28Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwMzAxNg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460903016", "bodyText": "nit: replace argument of toArray with empty array", "author": "godfreyhe", "createdAt": "2020-07-27T13:49:10Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkwMzM3Nw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460903377", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-07-27T13:49:39Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMDc1MA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460910750", "bodyText": "rename partitionFieldType to partitionFieldTypes ?\nchange the type definition to LogicalType[]? since prunePartitions method use Array[LogicalType] as argument type.", "author": "godfreyhe", "createdAt": "2020-07-27T13:59:48Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMTIxNg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460911216", "bodyText": "Context context -> FlinkContext context", "author": "godfreyhe", "createdAt": "2020-07-27T14:00:28Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMTM0Mw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460911343", "bodyText": "remove the cast", "author": "godfreyhe", "createdAt": "2020-07-27T14:00:38Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMTc4Nw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460911787", "bodyText": "nit: move to the last line?", "author": "godfreyhe", "createdAt": "2020-07-27T14:01:19Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMzA0NA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460913044", "bodyText": "please throw TableException instead", "author": "godfreyhe", "createdAt": "2020-07-27T14:03:12Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxMzY2NA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460913664", "bodyText": "reuse the validation logic with line 117-120 ?", "author": "godfreyhe", "createdAt": "2020-07-27T14:04:05Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()\n+\t\t\t\t.get()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(partition -> partition.toString())\n+\t\t\t\t.collect(Collectors.toList())\n+\t\t\t\t.toArray(new String[1])) +\n+\t\t\t\"]\";\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, statistic, new String[]{extraDigest});\n+\t\tLogicalTableScan newScan = new LogicalTableScan(\n+\t\t\tscan.getCluster(), scan.getTraitSet(), scan.getHints(), newTableSourceTable);\n+\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tcall.transformTo(filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate));\n+\t\t}\n+\t}\n+\n+\tprivate RexNode adjustPartitionPredicate(List<String> inputFieldNames, List<String> partitionFieldNames, RexNode partitionPredicate) {\n+\t\treturn partitionPredicate.accept(new RexShuttle(){\n+\t\t\t@Override\n+\t\t\tpublic RexNode visitInputRef(RexInputRef inputRef) {\n+\t\t\t\tint index = inputRef.getIndex();\n+\t\t\t\tString fieldName = inputFieldNames.get(index);\n+\t\t\t\tint newIndex = partitionFieldNames.indexOf(fieldName);\n+\t\t\t\tif (newIndex < 0) {\n+\t\t\t\t\tthrow new RuntimeException(String.format(\"Field name '%s' isn't found in partitioned columns.\" +\n+\t\t\t\t\t\t\" Validator should have checked that.\", fieldName));\n+\t\t\t\t}", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxNDg2Ng==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460914866", "bodyText": "please copy the comments from PushPartitionIntoLegacyTableSourceScanRule#adjustPartitionPredicate", "author": "godfreyhe", "createdAt": "2020-07-27T14:05:43Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()\n+\t\t\t\t.get()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(partition -> partition.toString())\n+\t\t\t\t.collect(Collectors.toList())\n+\t\t\t\t.toArray(new String[1])) +\n+\t\t\t\"]\";\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, statistic, new String[]{extraDigest});\n+\t\tLogicalTableScan newScan = new LogicalTableScan(\n+\t\t\tscan.getCluster(), scan.getTraitSet(), scan.getHints(), newTableSourceTable);\n+\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tcall.transformTo(filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate));\n+\t\t}\n+\t}\n+\n+\tprivate RexNode adjustPartitionPredicate(List<String> inputFieldNames, List<String> partitionFieldNames, RexNode partitionPredicate) {", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxNTkwNg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460915906", "bodyText": "please reuse the listPartitions result", "author": "godfreyhe", "createdAt": "2020-07-27T14:07:14Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxNjIyOQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460916229", "bodyText": "use Object::toString instead", "author": "godfreyhe", "createdAt": "2020-07-27T14:07:43Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()\n+\t\t\t\t.get()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(partition -> partition.toString())", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxNjkyNA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460916924", "bodyText": "The statistic should be updated", "author": "godfreyhe", "createdAt": "2020-07-27T14:08:44Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()\n+\t\t\t\t.get()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(partition -> partition.toString())\n+\t\t\t\t.collect(Collectors.toList())\n+\t\t\t\t.toArray(new String[1])) +\n+\t\t\t\"]\";\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, statistic, new String[]{extraDigest});", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxNzQxNA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460917414", "bodyText": "\"source: [partitions=\" -> \"partitions=[\" ?", "author": "godfreyhe", "createdAt": "2020-07-27T14:09:23Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxODA2Mg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460918062", "bodyText": "give a proper name for predicate ?", "author": "godfreyhe", "createdAt": "2020-07-27T14:10:22Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkxOTk0Mg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460919942", "bodyText": "move filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate) into a new line for more easy debugging", "author": "godfreyhe", "createdAt": "2020-07-27T14:13:00Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()\n+\t\t\t\t.get()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(partition -> partition.toString())\n+\t\t\t\t.collect(Collectors.toList())\n+\t\t\t\t.toArray(new String[1])) +\n+\t\t\t\"]\";\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, statistic, new String[]{extraDigest});\n+\t\tLogicalTableScan newScan = new LogicalTableScan(\n+\t\t\tscan.getCluster(), scan.getTraitSet(), scan.getHints(), newTableSourceTable);\n+\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tcall.transformTo(filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate));", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkyMDMzMw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460920333", "bodyText": "it's better to use LogicalTableScan.create method", "author": "godfreyhe", "createdAt": "2020-07-27T14:13:36Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()\n+\t\t\t\t.get()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(partition -> partition.toString())\n+\t\t\t\t.collect(Collectors.toList())\n+\t\t\t\t.toArray(new String[1])) +\n+\t\t\t\"]\";\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, statistic, new String[]{extraDigest});\n+\t\tLogicalTableScan newScan = new LogicalTableScan(", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkyMDU1NA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460920554", "bodyText": "new String[0]", "author": "godfreyhe", "createdAt": "2020-07-27T14:13:54Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tRelDataType inputFieldType = filter.getInput().getRowType();\n+\t\tList<String> inputFieldName = inputFieldType.getFieldNames();\n+\n+\t\tList<String> partitionedFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> predicate = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldName.toArray(new String[inputFieldName.size()]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(predicate._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldType = partitionedFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldName.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new RuntimeException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldType.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// checked in matches(call) and listPartitions() is not empty.\n+\t\tList<Map<String, String>> allPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions().get();\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldName, partitionedFieldNames, partitionPredicate);\n+\t\t// get partitions\n+\t\tList<Map<String, String>> remainingPartitions = PartitionPruner.prunePartitions(\n+\t\t\t((FlinkContext) context).getTableConfig(),\n+\t\t\tpartitionedFieldNames.toArray(new String[partitionedFieldNames.size()]),\n+\t\t\tpartitionFieldType.toArray(new LogicalType[partitionFieldType.size()]),\n+\t\t\tallPartitions,\n+\t\t\tfinalPartitionPredicate\n+\t\t\t);\n+\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\n+\t\t// build new table scan\n+\t\tFlinkStatistic statistic = tableSourceTable.getStatistic();\n+\t\tString extraDigest = \"source: [partitions=\" +\n+\t\t\tString.join(\", \", ((SupportsPartitionPushDown) dynamicTableSource).listPartitions()\n+\t\t\t\t.get()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(partition -> partition.toString())\n+\t\t\t\t.collect(Collectors.toList())\n+\t\t\t\t.toArray(new String[1])) +", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkyMzA3NQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460923075", "bodyText": "we must copy a new table source here, because we should create a new DynamicTableSource instance to hold the partition info and the original DynamicTableSource instance should not changed", "author": "godfreyhe", "createdAt": "2020-07-27T14:17:11Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.Context;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tOptional<List<Map<String, String>>> partitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\treturn partitions.isPresent()\n+\t\t\t&& !partitions.get().isEmpty()\n+\t\t\t&& !Arrays.stream(tableSourceTable.extraDigests()).anyMatch(digest -> digest.startsWith(\"source: [partitions=\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkyNjE1OQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r460926159", "bodyText": "please update the convertToRowData method based on the values of remainingPartitions", "author": "godfreyhe", "createdAt": "2020-07-27T14:21:24Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -644,6 +670,16 @@ public String asSummaryString() {\n \t\t\t}\n \t\t\treturn result;\n \t\t}\n+\n+\t\t@Override\n+\t\tpublic Optional<List<Map<String, String>>> listPartitions() {\n+\t\t\treturn Optional.of(allPartitions);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void applyPartitions(List<Map<String, String>> remainingPartitions) {\n+\t\t\tthis.allPartitions = remainingPartitions;", "originalCommit": "0f19df4d1fcbb4093b69d772628b67b81ebb443a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a7642bdac005f00819c76a444478d43cbaf6b43", "url": "https://github.com/apache/flink/commit/6a7642bdac005f00819c76a444478d43cbaf6b43", "message": "[FLINK-17427][table sql/planner]Support SupportsPartitionPushDown in planner.", "committedDate": "2020-08-01T15:11:09Z", "type": "commit"}, {"oid": "6697110fb14fef778707f74b66227df2953c487c", "url": "https://github.com/apache/flink/commit/6697110fb14fef778707f74b66227df2953c487c", "message": "fix godfrey's comment:\n1. refactor PushPartitionIntoSourceScanRule:\n  1.1 read partitions from catalog if tablesource doesn't support listPartitions;\n  1.2 build new flink statsitic\n  1.3 fix digest with suggestion\n2. adjust TestValuesTableFactory and use partition2row as source data\n3. add planner test and itcase", "committedDate": "2020-08-03T04:26:13Z", "type": "commit"}, {"oid": "6697110fb14fef778707f74b66227df2953c487c", "url": "https://github.com/apache/flink/commit/6697110fb14fef778707f74b66227df2953c487c", "message": "fix godfrey's comment:\n1. refactor PushPartitionIntoSourceScanRule:\n  1.1 read partitions from catalog if tablesource doesn't support listPartitions;\n  1.2 build new flink statsitic\n  1.3 fix digest with suggestion\n2. adjust TestValuesTableFactory and use partition2row as source data\n3. add planner test and itcase", "committedDate": "2020-08-03T04:26:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzMDM5MA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r464230390", "bodyText": "nit: catalogTable.getPartitionKeys().isEmpty() ?", "author": "godfreyhe", "createdAt": "2020-08-03T07:06:19Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableConfig;\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().size() == 0) {", "originalCommit": "6697110fb14fef778707f74b66227df2953c487c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIzOTEzOA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r464239138", "bodyText": "Initialize variables as close as possible to the point where you use them, please refer to The Principle of Proximity for more detailes", "author": "godfreyhe", "createdAt": "2020-08-03T07:28:19Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableConfig;\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().size() == 0) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\t// use new dynamic table source to push down\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();", "originalCommit": "6697110fb14fef778707f74b66227df2953c487c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0MDE4Mw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r464240183", "bodyText": "nit: move them into one line ?", "author": "godfreyhe", "createdAt": "2020-08-03T07:30:44Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableConfig;\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().size() == 0) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\t// use new dynamic table source to push down\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\t// fields used to prune\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);", "originalCommit": "6697110fb14fef778707f74b66227df2953c487c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI1MDM3Mw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r464250373", "bodyText": "I think it's better we can split the logic to different sub-methods, and simplify this part logic as:\n\nget partition from TableSource, if succeed, do partition pruning and build new table scan, else fallback to step 2\ncheck whether the catalog exists. if not existing, return. else go to step 2.1\n2.1. try to get partitions through listPartitionsByFilter method. if succeed, build new table scan. else go to step 2.2\n2.2. try to get partitions through listPartitions method. if failed, return. else do partition pruning and build new table scan.", "author": "godfreyhe", "createdAt": "2020-08-03T07:53:31Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableConfig;\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().size() == 0) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\t\t// use new dynamic table source to push down\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\t// fields used to prune\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {\n+\t\t\tint index = inputFieldNames.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\n+\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\t// get partitions from table source and prune\n+\t\tList<Map<String, String>> remainingPartitions = null;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions = null;\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// read partitions from catalog if table source doesn't support listPartitions operation.\n+\t\t\tif (!catalogOptional.isPresent()){\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t}\n+\t\tif (optionalPartitions != null) {\n+\t\t\tif (!optionalPartitions.isPresent() || optionalPartitions.get().size() == 0) {\n+\t\t\t\t// return if no partitions\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t// get remaining partitions\n+\t\t\tremainingPartitions = internalPrunePartitions(\n+\t\t\t\toptionalPartitions.get(),\n+\t\t\t\tinputFieldNames,\n+\t\t\t\tpartitionFieldNames,\n+\t\t\t\tpartitionFieldTypes,\n+\t\t\t\tpartitionPredicate,\n+\t\t\t\tcontext.getTableConfig());\n+\t\t} else {\n+\t\t\tRexNodeToExpressionConverter converter = new RexNodeToExpressionConverter(\n+\t\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\t\tcontext.getFunctionCatalog(),\n+\t\t\t\tcontext.getCatalogManager(),\n+\t\t\t\tTimeZone.getTimeZone(context.getTableConfig().getLocalTimeZone()));\n+\t\t\tArrayList<Expression> exprs = new ArrayList<>();\n+\t\t\tOption<ResolvedExpression> subExpr;\n+\t\t\tfor (RexNode node: JavaConversions.seqAsJavaList(allPredicates._1)) {\n+\t\t\t\tsubExpr = node.accept(converter);\n+\t\t\t\tif (!subExpr.isEmpty()) {\n+\t\t\t\t\texprs.add(subExpr.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tif (exprs.size() > 0) {\n+\t\t\t\t\tremainingPartitions = catalogOptional.get().listPartitionsByFilter(tablePath, exprs)\n+\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t.map(CatalogPartitionSpec::getPartitionSpec)\n+\t\t\t\t\t\t.collect(Collectors.toList());\n+\t\t\t\t} else {\n+\t\t\t\t\t// no filter and get all partitions\n+\t\t\t\t\tList<Map<String, String>> partitions = catalogOptional.get().listPartitions(tablePath)\n+\t\t\t\t\t\t.stream()\n+\t\t\t\t\t\t.map(CatalogPartitionSpec::getPartitionSpec)\n+\t\t\t\t\t\t.collect(Collectors.toList());\n+\t\t\t\t\t// prune partitions\n+\t\t\t\t\tif (partitions.size() > 0) {\n+\t\t\t\t\t\tremainingPartitions = internalPrunePartitions(\n+\t\t\t\t\t\t\tpartitions,\n+\t\t\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\t\t\tpartitionFieldNames,\n+\t\t\t\t\t\t\tpartitionFieldTypes,\n+\t\t\t\t\t\t\tpartitionPredicate,\n+\t\t\t\t\t\t\tcontext.getTableConfig());\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} catch (TableNotExistException e) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException e) {\n+\t\t\t\t// no partitions in table source\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}", "originalCommit": "6697110fb14fef778707f74b66227df2953c487c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1790d93b79cfdfc3f65a7805e444699736f80d93", "url": "https://github.com/apache/flink/commit/1790d93b79cfdfc3f65a7805e444699736f80d93", "message": "fix with godfrey's comment:\n1. split the logic into sub methods and simplify onMatch logic\n2. use functional interface rather than method(it can reuse local variable)\n3. keep pushing even if remainingPartitions is null", "committedDate": "2020-08-03T12:11:26Z", "type": "commit"}, {"oid": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "url": "https://github.com/apache/flink/commit/9a05a030c661def4a45b36370dbcfa5e786ed8dc", "message": "use java.util.function.Function and some minor style fix.", "committedDate": "2020-08-04T02:27:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMDc0NA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467720744", "bodyText": "what if the subExpr is empty ?", "author": "godfreyhe", "createdAt": "2020-08-10T07:06:54Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\t// build pruner\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {\n+\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes.toArray(new LogicalType[0]),\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions = null;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = defaultPruner.apply(optionalPartitions.get());\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()){\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\toptionalPartitions = readPartitionFromCatalogAndPrune(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tcatalogOptional.get(),\n+\t\t\t\t\tidentifier,\n+\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\tallPredicates._1(),\n+\t\t\t\t\tdefaultPruner\n+\t\t\t\t);\n+\t\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\t\tremainingPartitions = optionalPartitions.get();\n+\t\t\t\t}\n+\t\t\t} catch (TableNotExistException tableNotExistException) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException tableNotPartitionedException) {\n+\t\t\t\tremainingPartitions = null;\n+\t\t\t}\n+\t\t}\n+\t\tif (remainingPartitions != null) {\n+\t\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\t\t}\n+\n+\t\t// build new statistic\n+\t\tTableStats newTableStat = null;\n+\t\tOptional<TableStats> partitionStats;\n+\t\tif (remainingPartitions != null && catalogOptional.isPresent()) {\n+\t\t\tfor (Map<String, String> partition: remainingPartitions) {\n+\t\t\t\tpartitionStats = getPartitionStats(catalogOptional.get(), tablePath, partition);\n+\t\t\t\tif (!partitionStats.isPresent()) {\n+\t\t\t\t\t// clear all information before\n+\t\t\t\t\tnewTableStat = null;\n+\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\tnewTableStat = newTableStat == null ? partitionStats.get() : newTableStat.merge(partitionStats.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tFlinkStatistic newStatistic = FlinkStatistic.builder()\n+\t\t\t.statistic(tableSourceTable.getStatistic())\n+\t\t\t.tableStats(newTableStat)\n+\t\t\t.build();\n+\n+\t\tString extraDigest = remainingPartitions == null ? \"partitions=[]\" :\n+\t\t\t(\"partitions=[\" +\n+\t\t\t\tString.join(\", \", remainingPartitions\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.map(Object::toString)\n+\t\t\t\t\t.toArray(String[]::new)) +\n+\t\t\t\t\"]\");\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, newStatistic, new String[]{extraDigest});\n+\n+\t\tLogicalTableScan newScan = LogicalTableScan.create(scan.getCluster(), newTableSourceTable, scan.getHints());\n+\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tFilter newFilter = filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate);\n+\t\t\tcall.transformTo(newFilter);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * adjust the partition field reference index to evaluate the partition values.\n+\t * e.g. the original input fields is: a, b, c, p, and p is partition field. the partition values\n+\t * are: List(Map(\"p\"->\"1\"), Map(\"p\" -> \"2\"), Map(\"p\" -> \"3\")). If the original partition\n+\t * predicate is $3 > 1. after adjusting, the new predicate is ($0 > 1).\n+\t * and use ($0 > 1) to evaluate partition values (row(1), row(2), row(3)).\n+\t */\n+\tprivate RexNode adjustPartitionPredicate(List<String> inputFieldNames, List<String> partitionFieldNames, RexNode partitionPredicate) {\n+\t\treturn partitionPredicate.accept(new RexShuttle(){\n+\t\t\t@Override\n+\t\t\tpublic RexNode visitInputRef(RexInputRef inputRef) {\n+\t\t\t\tint index = inputRef.getIndex();\n+\t\t\t\tString fieldName = inputFieldNames.get(index);\n+\t\t\t\tint newIndex = partitionFieldNames.indexOf(fieldName);\n+\t\t\t\tif (newIndex < 0) {\n+\t\t\t\t\tthrow new TableException(String.format(\"Field name '%s' isn't found in partitioned columns.\" +\n+\t\t\t\t\t\t\" Validator should have checked that.\", fieldName));\n+\t\t\t\t}\n+\t\t\t\tif (newIndex == index){\n+\t\t\t\t\treturn inputRef;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new RexInputRef(newIndex, inputRef.getType());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogAndPrune(\n+\t\t\tFlinkContext context,\n+\t\t\tCatalog catalog,\n+\t\t\tObjectIdentifier tableIdentifier,\n+\t\t\tList<String> allFieldNames,\n+\t\t\tSeq<RexNode> partitionPredicate,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner) throws TableNotExistException, TableNotPartitionedException{\n+\t\tRexNodeToExpressionConverter converter = new RexNodeToExpressionConverter(\n+\t\t\tallFieldNames.toArray(new String[0]),\n+\t\t\tcontext.getFunctionCatalog(),\n+\t\t\tcontext.getCatalogManager(),\n+\t\t\tTimeZone.getTimeZone(context.getTableConfig().getLocalTimeZone()));\n+\t\tArrayList<Expression> partitionFilters = new ArrayList<>();\n+\t\tOption<ResolvedExpression> subExpr;\n+\t\tfor (RexNode node: JavaConversions.seqAsJavaList(partitionPredicate)) {\n+\t\t\tsubExpr = node.accept(converter);\n+\t\t\tif (!subExpr.isEmpty()) {", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc0NTQ4Nw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467745487", "bodyText": "we only use subExpr to accept value that is calculated from node. we have checked whether subExpr isEmpty in line 276", "author": "fsk119", "createdAt": "2020-08-10T08:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMDc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc1MjEyMA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467752120", "bodyText": "if subExpr is empty, its corresponding sub-filter is dropped, then the result is incorrect. There is no test coverage...", "author": "godfreyhe", "createdAt": "2020-08-10T08:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMDc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMjAyMw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467722023", "bodyText": "extract those code to a method, then the logic of onMatch  will be more clean, including 4 steps:\n\nextract partition predicate\ndo partition prune, and return the remaining partitions\nre-build statistic\nbuild new table scan and transform the result", "author": "godfreyhe", "createdAt": "2020-08-10T07:10:29Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\t// build pruner\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {\n+\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes.toArray(new LogicalType[0]),\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions = null;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = defaultPruner.apply(optionalPartitions.get());\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()){\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\toptionalPartitions = readPartitionFromCatalogAndPrune(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tcatalogOptional.get(),\n+\t\t\t\t\tidentifier,\n+\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\tallPredicates._1(),\n+\t\t\t\t\tdefaultPruner\n+\t\t\t\t);\n+\t\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\t\tremainingPartitions = optionalPartitions.get();\n+\t\t\t\t}\n+\t\t\t} catch (TableNotExistException tableNotExistException) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException tableNotPartitionedException) {\n+\t\t\t\tremainingPartitions = null;\n+\t\t\t}\n+\t\t}\n+\t\tif (remainingPartitions != null) {\n+\t\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyMzU1Ng==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467723556", "bodyText": "ditto", "author": "godfreyhe", "createdAt": "2020-08-10T07:14:48Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\t// build pruner\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {\n+\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes.toArray(new LogicalType[0]),\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions = null;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = defaultPruner.apply(optionalPartitions.get());\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()){\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\toptionalPartitions = readPartitionFromCatalogAndPrune(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tcatalogOptional.get(),\n+\t\t\t\t\tidentifier,\n+\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\tallPredicates._1(),\n+\t\t\t\t\tdefaultPruner\n+\t\t\t\t);\n+\t\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\t\tremainingPartitions = optionalPartitions.get();\n+\t\t\t\t}\n+\t\t\t} catch (TableNotExistException tableNotExistException) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException tableNotPartitionedException) {\n+\t\t\t\tremainingPartitions = null;\n+\t\t\t}\n+\t\t}\n+\t\tif (remainingPartitions != null) {\n+\t\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\t\t}\n+\n+\t\t// build new statistic\n+\t\tTableStats newTableStat = null;\n+\t\tOptional<TableStats> partitionStats;\n+\t\tif (remainingPartitions != null && catalogOptional.isPresent()) {\n+\t\t\tfor (Map<String, String> partition: remainingPartitions) {\n+\t\t\t\tpartitionStats = getPartitionStats(catalogOptional.get(), tablePath, partition);\n+\t\t\t\tif (!partitionStats.isPresent()) {\n+\t\t\t\t\t// clear all information before\n+\t\t\t\t\tnewTableStat = null;\n+\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\tnewTableStat = newTableStat == null ? partitionStats.get() : newTableStat.merge(partitionStats.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tFlinkStatistic newStatistic = FlinkStatistic.builder()\n+\t\t\t.statistic(tableSourceTable.getStatistic())\n+\t\t\t.tableStats(newTableStat)\n+\t\t\t.build();\n+\n+\t\tString extraDigest = remainingPartitions == null ? \"partitions=[]\" :\n+\t\t\t(\"partitions=[\" +\n+\t\t\t\tString.join(\", \", remainingPartitions\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.map(Object::toString)\n+\t\t\t\t\t.toArray(String[]::new)) +\n+\t\t\t\t\"]\");\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, newStatistic, new String[]{extraDigest});\n+\n+\t\tLogicalTableScan newScan = LogicalTableScan.create(scan.getCluster(), newTableSourceTable, scan.getHints());\n+\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tFilter newFilter = filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate);\n+\t\t\tcall.transformTo(newFilter);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * adjust the partition field reference index to evaluate the partition values.\n+\t * e.g. the original input fields is: a, b, c, p, and p is partition field. the partition values\n+\t * are: List(Map(\"p\"->\"1\"), Map(\"p\" -> \"2\"), Map(\"p\" -> \"3\")). If the original partition\n+\t * predicate is $3 > 1. after adjusting, the new predicate is ($0 > 1).\n+\t * and use ($0 > 1) to evaluate partition values (row(1), row(2), row(3)).\n+\t */\n+\tprivate RexNode adjustPartitionPredicate(List<String> inputFieldNames, List<String> partitionFieldNames, RexNode partitionPredicate) {\n+\t\treturn partitionPredicate.accept(new RexShuttle(){\n+\t\t\t@Override\n+\t\t\tpublic RexNode visitInputRef(RexInputRef inputRef) {\n+\t\t\t\tint index = inputRef.getIndex();\n+\t\t\t\tString fieldName = inputFieldNames.get(index);\n+\t\t\t\tint newIndex = partitionFieldNames.indexOf(fieldName);\n+\t\t\t\tif (newIndex < 0) {\n+\t\t\t\t\tthrow new TableException(String.format(\"Field name '%s' isn't found in partitioned columns.\" +\n+\t\t\t\t\t\t\" Validator should have checked that.\", fieldName));\n+\t\t\t\t}\n+\t\t\t\tif (newIndex == index){\n+\t\t\t\t\treturn inputRef;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new RexInputRef(newIndex, inputRef.getType());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogAndPrune(\n+\t\t\tFlinkContext context,\n+\t\t\tCatalog catalog,\n+\t\t\tObjectIdentifier tableIdentifier,\n+\t\t\tList<String> allFieldNames,\n+\t\t\tSeq<RexNode> partitionPredicate,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner) throws TableNotExistException, TableNotPartitionedException{\n+\t\tRexNodeToExpressionConverter converter = new RexNodeToExpressionConverter(\n+\t\t\tallFieldNames.toArray(new String[0]),\n+\t\t\tcontext.getFunctionCatalog(),\n+\t\t\tcontext.getCatalogManager(),\n+\t\t\tTimeZone.getTimeZone(context.getTableConfig().getLocalTimeZone()));\n+\t\tArrayList<Expression> partitionFilters = new ArrayList<>();\n+\t\tOption<ResolvedExpression> subExpr;\n+\t\tfor (RexNode node: JavaConversions.seqAsJavaList(partitionPredicate)) {\n+\t\t\tsubExpr = node.accept(converter);\n+\t\t\tif (!subExpr.isEmpty()) {\n+\t\t\t\tpartitionFilters.add(subExpr.get());\n+\t\t\t}\n+\t\t}\n+\t\tObjectPath tablePath = tableIdentifier.toObjectPath();\n+\t\tif (partitionFilters.size() > 0) {\n+\t\t\ttry {\n+\t\t\t\tList<Map<String, String>> remainingPartitions = catalog.listPartitionsByFilter(tablePath, partitionFilters)\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.map(CatalogPartitionSpec::getPartitionSpec)\n+\t\t\t\t\t.collect(Collectors.toList());\n+\t\t\t\treturn Optional.of(remainingPartitions);\n+\t\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogWithoutFilterAndPrune(\n+\t\t\tCatalog catalog,\n+\t\t\tObjectPath tablePath,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner) throws TableNotExistException, TableNotPartitionedException, CatalogException {\n+\t\tList<Map<String, String>> remainingPartitions;\n+\t\tList<Map<String, String>> partitions = catalog.listPartitions(tablePath)\n+\t\t\t.stream()\n+\t\t\t.map(CatalogPartitionSpec::getPartitionSpec)\n+\t\t\t.collect(Collectors.toList());\n+\t\t// prune partitions\n+\t\tif (partitions.size() > 0) {\n+\t\t\tremainingPartitions = pruner.apply(partitions);\n+\t\t\treturn Optional.of(remainingPartitions);\n+\t\t} else {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\tprivate Optional<TableStats> getPartitionStats(Catalog catalog, ObjectPath tablePath, Map<String, String> partition) {\n+\t\ttry {\n+\t\t\tCatalogPartitionSpec spec = new CatalogPartitionSpec(partition);\n+\t\t\tCatalogTableStatistics partitionStat = catalog.getPartitionStatistics(tablePath, spec);\n+\t\t\tCatalogColumnStatistics\tpartitionColStat = catalog.getPartitionColumnStatistics(tablePath, spec);\n+\t\t\tTableStats\tstats = CatalogTableStatisticsConverter.convertToTableStats(partitionStat, partitionColStat);", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyNTAyNQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467725025", "bodyText": "we should not throw TableNotPartitionedException because we had check whether the table is partitioned", "author": "godfreyhe", "createdAt": "2020-08-10T07:18:49Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\t// build pruner\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {\n+\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes.toArray(new LogicalType[0]),\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions = null;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = defaultPruner.apply(optionalPartitions.get());\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()){\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\toptionalPartitions = readPartitionFromCatalogAndPrune(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tcatalogOptional.get(),\n+\t\t\t\t\tidentifier,\n+\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\tallPredicates._1(),\n+\t\t\t\t\tdefaultPruner\n+\t\t\t\t);\n+\t\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\t\tremainingPartitions = optionalPartitions.get();\n+\t\t\t\t}\n+\t\t\t} catch (TableNotExistException tableNotExistException) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException tableNotPartitionedException) {\n+\t\t\t\tremainingPartitions = null;", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyNjc2Mw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467726763", "bodyText": "nit: please add a blank between )and {, there are many similar case: line 240, line 250, etc", "author": "godfreyhe", "createdAt": "2020-08-10T07:23:12Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\t// build pruner\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {\n+\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes.toArray(new LogicalType[0]),\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions = null;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = defaultPruner.apply(optionalPartitions.get());\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()){", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyNjk5NA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467726994", "bodyText": "nit: tab -> blank", "author": "godfreyhe", "createdAt": "2020-08-10T07:23:45Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\t// build pruner\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {\n+\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\tif (index < 0) {\n+\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t}\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType).collect(Collectors.toList());\n+\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes.toArray(new LogicalType[0]),\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions = null;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\t\t// fields to read partitions from catalog and build new statistic\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = defaultPruner.apply(optionalPartitions.get());\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()){\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\toptionalPartitions = readPartitionFromCatalogAndPrune(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tcatalogOptional.get(),\n+\t\t\t\t\tidentifier,\n+\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\tallPredicates._1(),\n+\t\t\t\t\tdefaultPruner\n+\t\t\t\t);\n+\t\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\t\tremainingPartitions = optionalPartitions.get();\n+\t\t\t\t}\n+\t\t\t} catch (TableNotExistException tableNotExistException) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException tableNotPartitionedException) {\n+\t\t\t\tremainingPartitions = null;\n+\t\t\t}\n+\t\t}\n+\t\tif (remainingPartitions != null) {\n+\t\t\t((SupportsPartitionPushDown) dynamicTableSource).applyPartitions(remainingPartitions);\n+\t\t}\n+\n+\t\t// build new statistic\n+\t\tTableStats newTableStat = null;\n+\t\tOptional<TableStats> partitionStats;\n+\t\tif (remainingPartitions != null && catalogOptional.isPresent()) {\n+\t\t\tfor (Map<String, String> partition: remainingPartitions) {\n+\t\t\t\tpartitionStats = getPartitionStats(catalogOptional.get(), tablePath, partition);\n+\t\t\t\tif (!partitionStats.isPresent()) {\n+\t\t\t\t\t// clear all information before\n+\t\t\t\t\tnewTableStat = null;\n+\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\tnewTableStat = newTableStat == null ? partitionStats.get() : newTableStat.merge(partitionStats.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tFlinkStatistic newStatistic = FlinkStatistic.builder()\n+\t\t\t.statistic(tableSourceTable.getStatistic())\n+\t\t\t.tableStats(newTableStat)\n+\t\t\t.build();\n+\n+\t\tString extraDigest = remainingPartitions == null ? \"partitions=[]\" :\n+\t\t\t(\"partitions=[\" +\n+\t\t\t\tString.join(\", \", remainingPartitions\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.map(Object::toString)\n+\t\t\t\t\t.toArray(String[]::new)) +\n+\t\t\t\t\"]\");\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, newStatistic, new String[]{extraDigest});\n+\n+\t\tLogicalTableScan newScan = LogicalTableScan.create(scan.getCluster(), newTableSourceTable, scan.getHints());\n+\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tFilter newFilter = filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate);\n+\t\t\tcall.transformTo(newFilter);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * adjust the partition field reference index to evaluate the partition values.\n+\t * e.g. the original input fields is: a, b, c, p, and p is partition field. the partition values\n+\t * are: List(Map(\"p\"->\"1\"), Map(\"p\" -> \"2\"), Map(\"p\" -> \"3\")). If the original partition\n+\t * predicate is $3 > 1. after adjusting, the new predicate is ($0 > 1).\n+\t * and use ($0 > 1) to evaluate partition values (row(1), row(2), row(3)).\n+\t */\n+\tprivate RexNode adjustPartitionPredicate(List<String> inputFieldNames, List<String> partitionFieldNames, RexNode partitionPredicate) {\n+\t\treturn partitionPredicate.accept(new RexShuttle(){\n+\t\t\t@Override\n+\t\t\tpublic RexNode visitInputRef(RexInputRef inputRef) {\n+\t\t\t\tint index = inputRef.getIndex();\n+\t\t\t\tString fieldName = inputFieldNames.get(index);\n+\t\t\t\tint newIndex = partitionFieldNames.indexOf(fieldName);\n+\t\t\t\tif (newIndex < 0) {\n+\t\t\t\t\tthrow new TableException(String.format(\"Field name '%s' isn't found in partitioned columns.\" +\n+\t\t\t\t\t\t\" Validator should have checked that.\", fieldName));\n+\t\t\t\t}\n+\t\t\t\tif (newIndex == index){\n+\t\t\t\t\treturn inputRef;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new RexInputRef(newIndex, inputRef.getType());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogAndPrune(\n+\t\t\tFlinkContext context,\n+\t\t\tCatalog catalog,\n+\t\t\tObjectIdentifier tableIdentifier,\n+\t\t\tList<String> allFieldNames,\n+\t\t\tSeq<RexNode> partitionPredicate,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner) throws TableNotExistException, TableNotPartitionedException{\n+\t\tRexNodeToExpressionConverter converter = new RexNodeToExpressionConverter(\n+\t\t\tallFieldNames.toArray(new String[0]),\n+\t\t\tcontext.getFunctionCatalog(),\n+\t\t\tcontext.getCatalogManager(),\n+\t\t\tTimeZone.getTimeZone(context.getTableConfig().getLocalTimeZone()));\n+\t\tArrayList<Expression> partitionFilters = new ArrayList<>();\n+\t\tOption<ResolvedExpression> subExpr;\n+\t\tfor (RexNode node: JavaConversions.seqAsJavaList(partitionPredicate)) {\n+\t\t\tsubExpr = node.accept(converter);\n+\t\t\tif (!subExpr.isEmpty()) {\n+\t\t\t\tpartitionFilters.add(subExpr.get());\n+\t\t\t}\n+\t\t}\n+\t\tObjectPath tablePath = tableIdentifier.toObjectPath();\n+\t\tif (partitionFilters.size() > 0) {\n+\t\t\ttry {\n+\t\t\t\tList<Map<String, String>> remainingPartitions = catalog.listPartitionsByFilter(tablePath, partitionFilters)\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.map(CatalogPartitionSpec::getPartitionSpec)\n+\t\t\t\t\t.collect(Collectors.toList());\n+\t\t\t\treturn Optional.of(remainingPartitions);\n+\t\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogWithoutFilterAndPrune(\n+\t\t\tCatalog catalog,\n+\t\t\tObjectPath tablePath,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner) throws TableNotExistException, TableNotPartitionedException, CatalogException {\n+\t\tList<Map<String, String>> remainingPartitions;\n+\t\tList<Map<String, String>> partitions = catalog.listPartitions(tablePath)\n+\t\t\t.stream()\n+\t\t\t.map(CatalogPartitionSpec::getPartitionSpec)\n+\t\t\t.collect(Collectors.toList());\n+\t\t// prune partitions\n+\t\tif (partitions.size() > 0) {\n+\t\t\tremainingPartitions = pruner.apply(partitions);\n+\t\t\treturn Optional.of(remainingPartitions);\n+\t\t} else {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t}\n+\n+\tprivate Optional<TableStats> getPartitionStats(Catalog catalog, ObjectPath tablePath, Map<String, String> partition) {\n+\t\ttry {\n+\t\t\tCatalogPartitionSpec spec = new CatalogPartitionSpec(partition);\n+\t\t\tCatalogTableStatistics partitionStat = catalog.getPartitionStatistics(tablePath, spec);\n+\t\t\tCatalogColumnStatistics\tpartitionColStat = catalog.getPartitionColumnStatistics(tablePath, spec);", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcyNzkwOQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467727909", "bodyText": "change List<LogicalType> to LogicalType[] ?", "author": "godfreyhe", "createdAt": "2020-08-10T07:25:55Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,325 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule(){\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null){\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\t// build pruner\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0])\n+\t\t\t);\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()){\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tList<LogicalType> partitionFieldTypes = partitionFieldNames.stream().map(name -> {", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczMTA1OQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467731059", "bodyText": "It seems a lot of logic in PushPartitionIntoTableSourceScanRule is not covered, such as: listing partitions by filter, listing partition without filter, etc", "author": "godfreyhe", "createdAt": "2020-08-10T07:33:41Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRuleTest.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.planner.calcite.CalciteConfig;\n+import org.apache.flink.table.planner.plan.optimize.program.BatchOptimizeContext;\n+import org.apache.flink.table.planner.plan.optimize.program.FlinkBatchProgram;\n+import org.apache.flink.table.planner.plan.optimize.program.FlinkHepRuleSetProgramBuilder;\n+import org.apache.flink.table.planner.plan.optimize.program.HEP_RULES_EXECUTION_TYPE;\n+import org.apache.flink.table.planner.utils.TableConfigUtils;\n+\n+import org.apache.calcite.plan.hep.HepMatchOrder;\n+import org.apache.calcite.rel.rules.FilterProjectTransposeRule;\n+import org.apache.calcite.tools.RuleSets;\n+\n+/**\n+ * Test for {@link PushPartitionIntoTableSourceScanRule}.\n+ */\n+public class PushPartitionIntoTableSourceScanRuleTest extends PushPartitionIntoLegacyTableSourceScanRuleTest{", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczNDU4NQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467734585", "bodyText": "move this line to line#394", "author": "godfreyhe", "createdAt": "2020-08-10T07:42:03Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -328,7 +357,59 @@ public DynamicTableSink createDynamicTableSink(Context context) {\n \t\t\tRUNTIME_SINK,\n \t\t\tSINK_EXPECTED_MESSAGES_NUM,\n \t\t\tNESTED_PROJECTION_SUPPORTED,\n-\t\t\tFILTERABLE_FIELDS));\n+\t\t\tFILTERABLE_FIELDS,\n+\t\t\tUSE_PARTITION_PUSH_DOWN,\n+\t\t\tPARTITION_LIST));\n+\t}\n+\n+\tprivate List<Map<String, String>> parsePartitionList(String partitionString) {\n+\t\treturn Arrays.stream(partitionString.split(\";\")).map(\n+\t\t\tpartition -> {\n+\t\t\t\tMap<String, String> spec = new HashMap<>();\n+\t\t\t\tArrays.stream(partition.split(\",\")).forEach(pair -> {\n+\t\t\t\t\tString[] split = pair.split(\":\");\n+\t\t\t\t\tspec.put(split[0].trim(), split[1].trim());\n+\t\t\t\t});\n+\t\t\t\treturn spec;\n+\t\t\t}\n+\t\t).collect(Collectors.toList());\n+\t}\n+\n+\tprivate Map<Map<String, String>, Collection<Row>> mapRowsToPartitions(\n+\t\t\tTableSchema schema,\n+\t\t\tCollection<Row> rows,\n+\t\t\tList<Map<String, String>> partitions) {\n+\t\tif (!rows.isEmpty() && partitions.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"Please add partition list if use partition push down. Currently TestValuesTableSource doesn't support create partition list automatically.\");\n+\t\t}\n+\t\tMap<Map<String, String>, Collection<Row>> map = new HashMap<>();\n+\t\tfor (Map<String, String> partition: partitions) {\n+\t\t\tmap.put(partition, new ArrayList<>());\n+\t\t}\n+\t\tString[] fieldnames = schema.getFieldNames();\n+\t\tboolean match = true;", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczNjA5Mg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467736092", "bodyText": "Map.Entry<?, ?> -> Map.Entry<String, String>", "author": "godfreyhe", "createdAt": "2020-08-10T07:45:36Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -328,7 +357,59 @@ public DynamicTableSink createDynamicTableSink(Context context) {\n \t\t\tRUNTIME_SINK,\n \t\t\tSINK_EXPECTED_MESSAGES_NUM,\n \t\t\tNESTED_PROJECTION_SUPPORTED,\n-\t\t\tFILTERABLE_FIELDS));\n+\t\t\tFILTERABLE_FIELDS,\n+\t\t\tUSE_PARTITION_PUSH_DOWN,\n+\t\t\tPARTITION_LIST));\n+\t}\n+\n+\tprivate List<Map<String, String>> parsePartitionList(String partitionString) {\n+\t\treturn Arrays.stream(partitionString.split(\";\")).map(\n+\t\t\tpartition -> {\n+\t\t\t\tMap<String, String> spec = new HashMap<>();\n+\t\t\t\tArrays.stream(partition.split(\",\")).forEach(pair -> {\n+\t\t\t\t\tString[] split = pair.split(\":\");\n+\t\t\t\t\tspec.put(split[0].trim(), split[1].trim());\n+\t\t\t\t});\n+\t\t\t\treturn spec;\n+\t\t\t}\n+\t\t).collect(Collectors.toList());\n+\t}\n+\n+\tprivate Map<Map<String, String>, Collection<Row>> mapRowsToPartitions(\n+\t\t\tTableSchema schema,\n+\t\t\tCollection<Row> rows,\n+\t\t\tList<Map<String, String>> partitions) {\n+\t\tif (!rows.isEmpty() && partitions.isEmpty()) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\"Please add partition list if use partition push down. Currently TestValuesTableSource doesn't support create partition list automatically.\");\n+\t\t}\n+\t\tMap<Map<String, String>, Collection<Row>> map = new HashMap<>();\n+\t\tfor (Map<String, String> partition: partitions) {\n+\t\t\tmap.put(partition, new ArrayList<>());\n+\t\t}\n+\t\tString[] fieldnames = schema.getFieldNames();\n+\t\tboolean match = true;\n+\t\tfor (Row row: rows) {\n+\t\t\tfor (Map<String, String> partition: partitions) {\n+\t\t\t\tmatch = true;\n+\t\t\t\tfor (Map.Entry<?, ?> entry: partition.entrySet()) {", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczNjc3MQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467736771", "bodyText": "Collections.EMPTY_LIST.equals(allPartitions) -> allPartitions.isEmpty()", "author": "godfreyhe", "createdAt": "2020-08-10T07:47:25Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -629,35 +728,53 @@ public String asSummaryString() {\n \t\t}\n \n \t\tprivate Collection<RowData> convertToRowData(\n-\t\t\t\tCollection<Row> data,\n+\t\t\t\tMap<Map<String, String>, Collection<Row>> data,\n \t\t\t\tint[] projectedFields,\n \t\t\t\tDataStructureConverter converter) {\n \t\t\tList<RowData> result = new ArrayList<>();\n-\t\t\tfor (Row value : data) {\n-\t\t\t\tif (result.size() >= limit) {\n-\t\t\t\t\treturn result;\n-\t\t\t\t}\n-\t\t\t\tif (isRetainedAfterApplyingFilterPredicates(value)) {\n-\t\t\t\t\tRow projectedRow;\n-\t\t\t\t\tif (projectedFields == null) {\n-\t\t\t\t\t\tprojectedRow = value;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n-\t\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n-\t\t\t\t\t\t\tnewValues[i] = value.getField(projectedFields[i]);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tprojectedRow = Row.of(newValues);\n+\t\t\tList<Map<String, String>> keys = Collections.EMPTY_LIST.equals(allPartitions) ?", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczNzYzMA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467737630", "bodyText": "nit: .stream() is unnecessary", "author": "godfreyhe", "createdAt": "2020-08-10T07:49:41Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -459,7 +547,15 @@ public LookupRuntimeProvider getLookupRuntimeProvider(LookupContext context) {\n \t\t\t\t.mapToInt(k -> k[0])\n \t\t\t\t.toArray();\n \t\t\tMap<Row, List<Row>> mapping = new HashMap<>();\n-\t\t\tdata.forEach(record -> {\n+\t\t\tCollection<Row> rows;\n+\t\t\tif (allPartitions.equals(Collections.EMPTY_LIST)) {\n+\t\t\t\trows = data.getOrDefault(Collections.EMPTY_MAP, Collections.EMPTY_LIST);\n+\t\t\t} else {\n+\t\t\t\trows = new ArrayList<>();\n+\t\t\t\tallPartitions.stream()", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzczODU2Mw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r467738563", "bodyText": "whether we can use PARTITION_LIST is not empty (including null) to represent use-partition-push-down=true ? then this config can be removed", "author": "godfreyhe", "createdAt": "2020-08-10T07:52:00Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -243,6 +245,19 @@ private static RowKind parseRowKind(String rowKindShortString) {\n \t\t.asList()\n \t\t.noDefaultValue();\n \n+\tprivate static final ConfigOption<Boolean> USE_PARTITION_PUSH_DOWN = ConfigOptions", "originalCommit": "9a05a030c661def4a45b36370dbcfa5e786ed8dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "97bb191e646a7ddc62d105e08a7473c8e5561160", "url": "https://github.com/apache/flink/commit/97bb191e646a7ddc62d105e08a7473c8e5561160", "message": "fix with godfrey's comment:\n1. add test for other 2 branch:\n  1.1. add a catalog for filter partitions and list partitions\n  1.2. add test when read partitions from catalog using filter;\n  1.3. add test when catalog can't push down partitions using filter;\n  1.4. add test when catalog can't push down when fail to convert predicate;\n  1.5. add test when read catalog without filter;\n2. fix logic when fail to convert predicate to filters will continue use filter to read partitions from catalog;\n3. delete config option 'use-partition-push-down' and use empty partition list to represent whether we can push down partitions;\n4. some minor fix", "committedDate": "2020-08-12T11:53:51Z", "type": "commit"}, {"oid": "eea5ebcd848bd4e554134096073cbd88d9725395", "url": "https://github.com/apache/flink/commit/eea5ebcd848bd4e554134096073cbd88d9725395", "message": "fix tab problem", "committedDate": "2020-08-12T12:05:36Z", "type": "commit"}, {"oid": "50079cc5a0bbe71de746f78a22180febf9a35e57", "url": "https://github.com/apache/flink/commit/50079cc5a0bbe71de746f78a22180febf9a35e57", "message": "delete some modification", "committedDate": "2020-08-12T15:37:08Z", "type": "commit"}, {"oid": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "url": "https://github.com/apache/flink/commit/b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "message": "add license and rollback irrelevant file", "committedDate": "2020-08-12T15:59:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgxMTEwOQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469811109", "bodyText": "\"PushPartitionTableSourceScanRule\" -> \"PushPartitionIntoTableSourceScanRule\"", "author": "godfreyhe", "createdAt": "2020-08-13T09:12:08Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule() {\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgyNDI5Nw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469824297", "bodyText": "partitionFilters.size() should not be empty, because line#128 has checked it", "author": "godfreyhe", "createdAt": "2020-08-13T09:34:16Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule() {\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\t// extract partition predicates\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0]));\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()) {\n+\t\t\treturn;\n+\t\t}\n+\t\t// build pruner\n+\t\tLogicalType[] partitionFieldTypes = partitionFieldNames.stream()\n+\t\t\t.map(name -> {\n+\t\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\t\tif (index < 0) {\n+\t\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t\t}\n+\t\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType)\n+\t\t\t.toArray(LogicalType[]::new);\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes,\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\t\t// prune partitions\n+\t\tOptional<List<Map<String, String>>> remainingPartitions =\n+\t\t\treadPartitionsAndPrune(context, tableSourceTable, defaultPruner, allPredicates._1(), inputFieldNames);\n+\t\t// apply push down\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tremainingPartitions.ifPresent(((SupportsPartitionPushDown) dynamicTableSource)::applyPartitions);\n+\n+\t\t// build new statistic\n+\t\tTableStats newTableStat = null;\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(identifier.getCatalogName());\n+\t\tOptional<TableStats> partitionStats;\n+\t\tif (remainingPartitions.isPresent() && catalogOptional.isPresent()) {\n+\t\t\tfor (Map<String, String> partition: remainingPartitions.get()) {\n+\t\t\t\tpartitionStats = getPartitionStats(catalogOptional.get(), tablePath, partition);\n+\t\t\t\tif (!partitionStats.isPresent()) {\n+\t\t\t\t\t// clear all information before\n+\t\t\t\t\tnewTableStat = null;\n+\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\tnewTableStat = newTableStat == null ? partitionStats.get() : newTableStat.merge(partitionStats.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tFlinkStatistic newStatistic = FlinkStatistic.builder()\n+\t\t\t.statistic(tableSourceTable.getStatistic())\n+\t\t\t.tableStats(newTableStat)\n+\t\t\t.build();\n+\n+\t\tString extraDigest = remainingPartitions.map(partition -> (\"partitions=[\" +\n+\t\t\tString.join(\", \", partition\n+\t\t\t\t.stream()\n+\t\t\t\t.map(Object::toString)\n+\t\t\t\t.toArray(String[]::new)) +\n+\t\t\t\"]\")).orElse(\"partitions=[]\");\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, newStatistic, new String[]{extraDigest});\n+\t\tLogicalTableScan newScan = LogicalTableScan.create(scan.getCluster(), newTableSourceTable, scan.getHints());\n+\n+\t\t// transform to new node\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tFilter newFilter = filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate);\n+\t\t\tcall.transformTo(newFilter);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * adjust the partition field reference index to evaluate the partition values.\n+\t * e.g. the original input fields is: a, b, c, p, and p is partition field. the partition values\n+\t * are: List(Map(\"p\"->\"1\"), Map(\"p\" -> \"2\"), Map(\"p\" -> \"3\")). If the original partition\n+\t * predicate is $3 > 1. after adjusting, the new predicate is ($0 > 1).\n+\t * and use ($0 > 1) to evaluate partition values (row(1), row(2), row(3)).\n+\t */\n+\tprivate RexNode adjustPartitionPredicate(List<String> inputFieldNames, List<String> partitionFieldNames, RexNode partitionPredicate) {\n+\t\treturn partitionPredicate.accept(new RexShuttle() {\n+\t\t\t@Override\n+\t\t\tpublic RexNode visitInputRef(RexInputRef inputRef) {\n+\t\t\t\tint index = inputRef.getIndex();\n+\t\t\t\tString fieldName = inputFieldNames.get(index);\n+\t\t\t\tint newIndex = partitionFieldNames.indexOf(fieldName);\n+\t\t\t\tif (newIndex < 0) {\n+\t\t\t\t\tthrow new TableException(String.format(\"Field name '%s' isn't found in partitioned columns.\" +\n+\t\t\t\t\t\t\" Validator should have checked that.\", fieldName));\n+\t\t\t\t}\n+\t\t\t\tif (newIndex == index) {\n+\t\t\t\t\treturn inputRef;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new RexInputRef(newIndex, inputRef.getType());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionsAndPrune(\n+\t\t\tFlinkContext context,\n+\t\t\tTableSourceTable tableSourceTable,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner,\n+\t\t\tSeq<RexNode> partitionPredicate,\n+\t\t\tList<String> inputFieldNames) {\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = pruner.apply(optionalPartitions.get());\n+\t\t\t\treturn remainingPartitions != null ? Optional.of(remainingPartitions) : Optional.empty();\n+\t\t\t} else {\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()) {\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\treturn readPartitionFromCatalogAndPrune(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tcatalogOptional.get(),\n+\t\t\t\t\tidentifier,\n+\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\tpartitionPredicate,\n+\t\t\t\t\tpruner);\n+\t\t\t} catch (TableNotExistException tableNotExistException) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException tableNotPartitionedException) {\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s is not a partitionable source. Validator should have checked it.\", identifier.asSummaryString()),\n+\t\t\t\t\ttableNotPartitionedException);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogAndPrune(\n+\t\t\tFlinkContext context,\n+\t\t\tCatalog catalog,\n+\t\t\tObjectIdentifier tableIdentifier,\n+\t\t\tList<String> allFieldNames,\n+\t\t\tSeq<RexNode> partitionPredicate,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner)\n+\t\t\tthrows TableNotExistException, TableNotPartitionedException {\n+\t\tObjectPath tablePath = tableIdentifier.toObjectPath();\n+\t\t// build filters\n+\t\tRexNodeToExpressionConverter converter = new RexNodeToExpressionConverter(\n+\t\t\tallFieldNames.toArray(new String[0]),\n+\t\t\tcontext.getFunctionCatalog(),\n+\t\t\tcontext.getCatalogManager(),\n+\t\t\tTimeZone.getTimeZone(context.getTableConfig().getLocalTimeZone()));\n+\t\tArrayList<Expression> partitionFilters = new ArrayList<>();\n+\t\tOption<ResolvedExpression> subExpr;\n+\t\tfor (RexNode node: JavaConversions.seqAsJavaList(partitionPredicate)) {\n+\t\t\tsubExpr = node.accept(converter);\n+\t\t\tif (!subExpr.isEmpty()) {\n+\t\t\t\tpartitionFilters.add(subExpr.get());\n+\t\t\t} else {\n+\t\t\t\t// if part of expr is unresolved, we read all partitions and prune.\n+\t\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t\t}\n+\t\t}\n+\t\tif (partitionFilters.size() > 0) {", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgyNTc1NQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469825755", "bodyText": "nit:  wrap the line at throws  ?", "author": "godfreyhe", "createdAt": "2020-08-13T09:36:42Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRule.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.catalog.Catalog;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectIdentifier;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.PartitionNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.catalog.stats.CatalogColumnStatistics;\n+import org.apache.flink.table.catalog.stats.CatalogTableStatistics;\n+import org.apache.flink.table.connector.source.DynamicTableSource;\n+import org.apache.flink.table.connector.source.abilities.SupportsPartitionPushDown;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.plan.stats.TableStats;\n+import org.apache.flink.table.planner.calcite.FlinkContext;\n+import org.apache.flink.table.planner.calcite.FlinkTypeFactory;\n+import org.apache.flink.table.planner.plan.schema.TableSourceTable;\n+import org.apache.flink.table.planner.plan.stats.FlinkStatistic;\n+import org.apache.flink.table.planner.plan.utils.FlinkRelOptUtil;\n+import org.apache.flink.table.planner.plan.utils.PartitionPruner;\n+import org.apache.flink.table.planner.plan.utils.RexNodeExtractor;\n+import org.apache.flink.table.planner.plan.utils.RexNodeToExpressionConverter;\n+import org.apache.flink.table.planner.utils.CatalogTableStatisticsConverter;\n+import org.apache.flink.table.types.logical.LogicalType;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.logical.LogicalTableScan;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexShuttle;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TimeZone;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import scala.Option;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+/**\n+ * Planner rule that tries to push partition evaluated by filter condition into a {@link LogicalTableScan}.\n+*/\n+public class PushPartitionIntoTableSourceScanRule extends RelOptRule {\n+\tpublic static final PushPartitionIntoTableSourceScanRule INSTANCE = new PushPartitionIntoTableSourceScanRule();\n+\n+\tpublic PushPartitionIntoTableSourceScanRule() {\n+\t\tsuper(operand(Filter.class,\n+\t\t\t\toperand(LogicalTableScan.class, none())),\n+\t\t\t\"PushPartitionTableSourceScanRule\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean matches(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tif (filter.getCondition() == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTableSourceTable tableSourceTable = call.rel(1).getTable().unwrap(TableSourceTable.class);\n+\t\tif (tableSourceTable == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tif (!(dynamicTableSource instanceof SupportsPartitionPushDown)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCatalogTable catalogTable = tableSourceTable.catalogTable();\n+\t\tif (!catalogTable.isPartitioned() || catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn Arrays.stream(tableSourceTable.extraDigests()).noneMatch(digest -> digest.startsWith(\"partitions=[\"));\n+\t}\n+\n+\t@Override\n+\tpublic void onMatch(RelOptRuleCall call) {\n+\t\tFilter filter = call.rel(0);\n+\t\tLogicalTableScan scan = call.rel(1);\n+\t\tTableSourceTable tableSourceTable = scan.getTable().unwrap(TableSourceTable.class);\n+\n+\t\tRelDataType inputFieldTypes = filter.getInput().getRowType();\n+\t\tList<String> inputFieldNames = inputFieldTypes.getFieldNames();\n+\t\tList<String> partitionFieldNames = tableSourceTable.catalogTable().getPartitionKeys();\n+\t\t// extract partition predicates\n+\t\tRelBuilder relBuilder = call.builder();\n+\t\tRexBuilder rexBuilder = relBuilder.getRexBuilder();\n+\t\tTuple2<Seq<RexNode>, Seq<RexNode>> allPredicates = RexNodeExtractor.extractPartitionPredicateList(\n+\t\t\tfilter.getCondition(),\n+\t\t\tFlinkRelOptUtil.getMaxCnfNodeCount(scan),\n+\t\t\tinputFieldNames.toArray(new String[0]),\n+\t\t\trexBuilder,\n+\t\t\tpartitionFieldNames.toArray(new String[0]));\n+\t\tRexNode partitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._1));\n+\n+\t\tif (partitionPredicate.isAlwaysTrue()) {\n+\t\t\treturn;\n+\t\t}\n+\t\t// build pruner\n+\t\tLogicalType[] partitionFieldTypes = partitionFieldNames.stream()\n+\t\t\t.map(name -> {\n+\t\t\t\tint index  = inputFieldNames.indexOf(name);\n+\t\t\t\tif (index < 0) {\n+\t\t\t\t\tthrow new TableException(String.format(\"Partitioned key '%s' isn't found in input columns. \" +\n+\t\t\t\t\t\t\"Validator should have checked that.\", name));\n+\t\t\t\t}\n+\t\t\t\treturn inputFieldTypes.getFieldList().get(index).getType(); })\n+\t\t\t.map(FlinkTypeFactory::toLogicalType)\n+\t\t\t.toArray(LogicalType[]::new);\n+\t\tRexNode finalPartitionPredicate = adjustPartitionPredicate(inputFieldNames, partitionFieldNames, partitionPredicate);\n+\t\tFlinkContext context = call.getPlanner().getContext().unwrap(FlinkContext.class);\n+\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> defaultPruner = partitions -> PartitionPruner.prunePartitions(\n+\t\t\tcontext.getTableConfig(),\n+\t\t\tpartitionFieldNames.toArray(new String[0]),\n+\t\t\tpartitionFieldTypes,\n+\t\t\tpartitions,\n+\t\t\tfinalPartitionPredicate);\n+\t\t// prune partitions\n+\t\tOptional<List<Map<String, String>>> remainingPartitions =\n+\t\t\treadPartitionsAndPrune(context, tableSourceTable, defaultPruner, allPredicates._1(), inputFieldNames);\n+\t\t// apply push down\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource().copy();\n+\t\tremainingPartitions.ifPresent(((SupportsPartitionPushDown) dynamicTableSource)::applyPartitions);\n+\n+\t\t// build new statistic\n+\t\tTableStats newTableStat = null;\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\tObjectPath tablePath = identifier.toObjectPath();\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(identifier.getCatalogName());\n+\t\tOptional<TableStats> partitionStats;\n+\t\tif (remainingPartitions.isPresent() && catalogOptional.isPresent()) {\n+\t\t\tfor (Map<String, String> partition: remainingPartitions.get()) {\n+\t\t\t\tpartitionStats = getPartitionStats(catalogOptional.get(), tablePath, partition);\n+\t\t\t\tif (!partitionStats.isPresent()) {\n+\t\t\t\t\t// clear all information before\n+\t\t\t\t\tnewTableStat = null;\n+\t\t\t\t\tbreak;\n+\t\t\t\t} else {\n+\t\t\t\t\tnewTableStat = newTableStat == null ? partitionStats.get() : newTableStat.merge(partitionStats.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tFlinkStatistic newStatistic = FlinkStatistic.builder()\n+\t\t\t.statistic(tableSourceTable.getStatistic())\n+\t\t\t.tableStats(newTableStat)\n+\t\t\t.build();\n+\n+\t\tString extraDigest = remainingPartitions.map(partition -> (\"partitions=[\" +\n+\t\t\tString.join(\", \", partition\n+\t\t\t\t.stream()\n+\t\t\t\t.map(Object::toString)\n+\t\t\t\t.toArray(String[]::new)) +\n+\t\t\t\"]\")).orElse(\"partitions=[]\");\n+\t\tTableSourceTable newTableSourceTable = tableSourceTable.copy(dynamicTableSource, newStatistic, new String[]{extraDigest});\n+\t\tLogicalTableScan newScan = LogicalTableScan.create(scan.getCluster(), newTableSourceTable, scan.getHints());\n+\n+\t\t// transform to new node\n+\t\tRexNode nonPartitionPredicate = RexUtil.composeConjunction(rexBuilder, JavaConversions.seqAsJavaList(allPredicates._2()));\n+\t\tif (nonPartitionPredicate.isAlwaysTrue()) {\n+\t\t\tcall.transformTo(newScan);\n+\t\t} else {\n+\t\t\tFilter newFilter = filter.copy(filter.getTraitSet(), newScan, nonPartitionPredicate);\n+\t\t\tcall.transformTo(newFilter);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * adjust the partition field reference index to evaluate the partition values.\n+\t * e.g. the original input fields is: a, b, c, p, and p is partition field. the partition values\n+\t * are: List(Map(\"p\"->\"1\"), Map(\"p\" -> \"2\"), Map(\"p\" -> \"3\")). If the original partition\n+\t * predicate is $3 > 1. after adjusting, the new predicate is ($0 > 1).\n+\t * and use ($0 > 1) to evaluate partition values (row(1), row(2), row(3)).\n+\t */\n+\tprivate RexNode adjustPartitionPredicate(List<String> inputFieldNames, List<String> partitionFieldNames, RexNode partitionPredicate) {\n+\t\treturn partitionPredicate.accept(new RexShuttle() {\n+\t\t\t@Override\n+\t\t\tpublic RexNode visitInputRef(RexInputRef inputRef) {\n+\t\t\t\tint index = inputRef.getIndex();\n+\t\t\t\tString fieldName = inputFieldNames.get(index);\n+\t\t\t\tint newIndex = partitionFieldNames.indexOf(fieldName);\n+\t\t\t\tif (newIndex < 0) {\n+\t\t\t\t\tthrow new TableException(String.format(\"Field name '%s' isn't found in partitioned columns.\" +\n+\t\t\t\t\t\t\" Validator should have checked that.\", fieldName));\n+\t\t\t\t}\n+\t\t\t\tif (newIndex == index) {\n+\t\t\t\t\treturn inputRef;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn new RexInputRef(newIndex, inputRef.getType());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionsAndPrune(\n+\t\t\tFlinkContext context,\n+\t\t\tTableSourceTable tableSourceTable,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner,\n+\t\t\tSeq<RexNode> partitionPredicate,\n+\t\t\tList<String> inputFieldNames) {\n+\t\t// get partitions from table/catalog and prune\n+\t\tOptional<Catalog> catalogOptional = context.getCatalogManager().getCatalog(tableSourceTable.tableIdentifier().getCatalogName());\n+\t\tList<Map<String, String>> remainingPartitions;\n+\t\tOptional<List<Map<String, String>>> optionalPartitions;\n+\n+\t\tDynamicTableSource dynamicTableSource = tableSourceTable.tableSource();\n+\t\tObjectIdentifier identifier = tableSourceTable.tableIdentifier();\n+\t\ttry {\n+\t\t\toptionalPartitions = ((SupportsPartitionPushDown) dynamicTableSource).listPartitions();\n+\t\t\tif (optionalPartitions.isPresent() && !optionalPartitions.get().isEmpty()) {\n+\t\t\t\tremainingPartitions = pruner.apply(optionalPartitions.get());\n+\t\t\t\treturn remainingPartitions != null ? Optional.of(remainingPartitions) : Optional.empty();\n+\t\t\t} else {\n+\t\t\t\treturn Optional.empty();\n+\t\t\t}\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// check catalog whether is available\n+\t\t\t// we will read partitions from catalog if table doesn't support listPartitions.\n+\t\t\tif (!catalogOptional.isPresent()) {\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s must from a catalog, but %s is not a catalog\",\n+\t\t\t\t\t\tidentifier.asSummaryString(), identifier.getCatalogName()), e);\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\treturn readPartitionFromCatalogAndPrune(\n+\t\t\t\t\tcontext,\n+\t\t\t\t\tcatalogOptional.get(),\n+\t\t\t\t\tidentifier,\n+\t\t\t\t\tinputFieldNames,\n+\t\t\t\t\tpartitionPredicate,\n+\t\t\t\t\tpruner);\n+\t\t\t} catch (TableNotExistException tableNotExistException) {\n+\t\t\t\tthrow new TableException(String.format(\"Table %s is not found in catalog.\", identifier.asSummaryString()), e);\n+\t\t\t} catch (TableNotPartitionedException tableNotPartitionedException) {\n+\t\t\t\tthrow new TableException(\n+\t\t\t\t\tString.format(\"Table %s is not a partitionable source. Validator should have checked it.\", identifier.asSummaryString()),\n+\t\t\t\t\ttableNotPartitionedException);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogAndPrune(\n+\t\t\tFlinkContext context,\n+\t\t\tCatalog catalog,\n+\t\t\tObjectIdentifier tableIdentifier,\n+\t\t\tList<String> allFieldNames,\n+\t\t\tSeq<RexNode> partitionPredicate,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner)\n+\t\t\tthrows TableNotExistException, TableNotPartitionedException {\n+\t\tObjectPath tablePath = tableIdentifier.toObjectPath();\n+\t\t// build filters\n+\t\tRexNodeToExpressionConverter converter = new RexNodeToExpressionConverter(\n+\t\t\tallFieldNames.toArray(new String[0]),\n+\t\t\tcontext.getFunctionCatalog(),\n+\t\t\tcontext.getCatalogManager(),\n+\t\t\tTimeZone.getTimeZone(context.getTableConfig().getLocalTimeZone()));\n+\t\tArrayList<Expression> partitionFilters = new ArrayList<>();\n+\t\tOption<ResolvedExpression> subExpr;\n+\t\tfor (RexNode node: JavaConversions.seqAsJavaList(partitionPredicate)) {\n+\t\t\tsubExpr = node.accept(converter);\n+\t\t\tif (!subExpr.isEmpty()) {\n+\t\t\t\tpartitionFilters.add(subExpr.get());\n+\t\t\t} else {\n+\t\t\t\t// if part of expr is unresolved, we read all partitions and prune.\n+\t\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t\t}\n+\t\t}\n+\t\tif (partitionFilters.size() > 0) {\n+\t\t\ttry {\n+\t\t\t\tList<Map<String, String>> remainingPartitions = catalog.listPartitionsByFilter(tablePath, partitionFilters)\n+\t\t\t\t\t.stream()\n+\t\t\t\t\t.map(CatalogPartitionSpec::getPartitionSpec)\n+\t\t\t\t\t.collect(Collectors.toList());\n+\t\t\t\treturn Optional.of(remainingPartitions);\n+\t\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn readPartitionFromCatalogWithoutFilterAndPrune(catalog, tablePath, pruner);\n+\t\t}\n+\t}\n+\n+\tprivate Optional<List<Map<String, String>>> readPartitionFromCatalogWithoutFilterAndPrune(\n+\t\t\tCatalog catalog,\n+\t\t\tObjectPath tablePath,\n+\t\t\tFunction<List<Map<String, String>>, List<Map<String, String>>> pruner) throws TableNotExistException, CatalogException, TableNotPartitionedException {", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgyOTg1MQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469829851", "bodyText": "move this class to org.apache.flink.table.planner.utils ? which could make TestValuesTableFactory more lightweight.", "author": "godfreyhe", "createdAt": "2020-08-13T09:43:55Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -821,4 +848,125 @@ public String asSummaryString() {\n \t\t}\n \t}\n \n+\t// --------------------------------------------------------------------------------------------\n+\t// Table utils\n+\t// --------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Utils for catalog and source to filter partition or row.\n+\t * */\n+\tpublic static class FilterUtil {", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgzMDUwOQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469830509", "bodyText": "just make these utility methods static ? then we can remove this field.", "author": "godfreyhe", "createdAt": "2020-08-13T09:45:01Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -821,4 +848,125 @@ public String asSummaryString() {\n \t\t}\n \t}\n \n+\t// --------------------------------------------------------------------------------------------\n+\t// Table utils\n+\t// --------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Utils for catalog and source to filter partition or row.\n+\t * */\n+\tpublic static class FilterUtil {\n+\t\tpublic static final FilterUtil INSTANCE = new FilterUtil();", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgzMzY1Nw==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469833657", "bodyText": "nit: use Collections.emptyMap() to make IDE happy ?", "author": "godfreyhe", "createdAt": "2020-08-13T09:50:23Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -629,35 +618,73 @@ public String asSummaryString() {\n \t\t}\n \n \t\tprivate Collection<RowData> convertToRowData(\n-\t\t\t\tCollection<Row> data,\n+\t\t\t\tMap<Map<String, String>, Collection<Row>> data,\n \t\t\t\tint[] projectedFields,\n \t\t\t\tDataStructureConverter converter) {\n \t\t\tList<RowData> result = new ArrayList<>();\n-\t\t\tfor (Row value : data) {\n-\t\t\t\tif (result.size() >= limit) {\n-\t\t\t\t\treturn result;\n-\t\t\t\t}\n-\t\t\t\tif (isRetainedAfterApplyingFilterPredicates(value)) {\n-\t\t\t\t\tRow projectedRow;\n-\t\t\t\t\tif (projectedFields == null) {\n-\t\t\t\t\t\tprojectedRow = value;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n-\t\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n-\t\t\t\t\t\t\tnewValues[i] = value.getField(projectedFields[i]);\n+\t\t\tList<Map<String, String>> keys = allPartitions.isEmpty() ?\n+\t\t\t\tCollections.singletonList(Collections.EMPTY_MAP) :", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgzNzc4NQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469837785", "bodyText": "it's better isRetainedAfterApplyingFilterPredicates can accept multiple predicates as parameter, because both parts who use this method are predicate list", "author": "godfreyhe", "createdAt": "2020-08-13T09:57:35Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -629,35 +618,73 @@ public String asSummaryString() {\n \t\t}\n \n \t\tprivate Collection<RowData> convertToRowData(\n-\t\t\t\tCollection<Row> data,\n+\t\t\t\tMap<Map<String, String>, Collection<Row>> data,\n \t\t\t\tint[] projectedFields,\n \t\t\t\tDataStructureConverter converter) {\n \t\t\tList<RowData> result = new ArrayList<>();\n-\t\t\tfor (Row value : data) {\n-\t\t\t\tif (result.size() >= limit) {\n-\t\t\t\t\treturn result;\n-\t\t\t\t}\n-\t\t\t\tif (isRetainedAfterApplyingFilterPredicates(value)) {\n-\t\t\t\t\tRow projectedRow;\n-\t\t\t\t\tif (projectedFields == null) {\n-\t\t\t\t\t\tprojectedRow = value;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n-\t\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n-\t\t\t\t\t\t\tnewValues[i] = value.getField(projectedFields[i]);\n+\t\t\tList<Map<String, String>> keys = allPartitions.isEmpty() ?\n+\t\t\t\tCollections.singletonList(Collections.EMPTY_MAP) :\n+\t\t\t\tallPartitions;\n+\t\t\tFilterUtil util = FilterUtil.INSTANCE;\n+\t\t\tboolean isRetained = true;\n+\t\t\tfor (Map<String, String> partition: keys) {\n+\t\t\t\tfor (Row value : data.get(partition)) {\n+\t\t\t\t\tif (result.size() >= limit) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (filterPredicates != null && !filterPredicates.isEmpty()) {\n+\t\t\t\t\t\tfor (ResolvedExpression predicate: filterPredicates) {\n+\t\t\t\t\t\t\tisRetained = util.isRetainedAfterApplyingFilterPredicates(predicate, getGetter(value));", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgzODA4MA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469838080", "bodyText": "nit: move this variable into for loop ?", "author": "godfreyhe", "createdAt": "2020-08-13T09:58:06Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -629,35 +618,73 @@ public String asSummaryString() {\n \t\t}\n \n \t\tprivate Collection<RowData> convertToRowData(\n-\t\t\t\tCollection<Row> data,\n+\t\t\t\tMap<Map<String, String>, Collection<Row>> data,\n \t\t\t\tint[] projectedFields,\n \t\t\t\tDataStructureConverter converter) {\n \t\t\tList<RowData> result = new ArrayList<>();\n-\t\t\tfor (Row value : data) {\n-\t\t\t\tif (result.size() >= limit) {\n-\t\t\t\t\treturn result;\n-\t\t\t\t}\n-\t\t\t\tif (isRetainedAfterApplyingFilterPredicates(value)) {\n-\t\t\t\t\tRow projectedRow;\n-\t\t\t\t\tif (projectedFields == null) {\n-\t\t\t\t\t\tprojectedRow = value;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n-\t\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n-\t\t\t\t\t\t\tnewValues[i] = value.getField(projectedFields[i]);\n+\t\t\tList<Map<String, String>> keys = allPartitions.isEmpty() ?\n+\t\t\t\tCollections.singletonList(Collections.EMPTY_MAP) :\n+\t\t\t\tallPartitions;\n+\t\t\tFilterUtil util = FilterUtil.INSTANCE;\n+\t\t\tboolean isRetained = true;", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg0MDI1Mg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469840252", "bodyText": "getValueGetter ?", "author": "godfreyhe", "createdAt": "2020-08-13T10:01:52Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesCatalog.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.factories;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.catalog.CatalogBaseTable;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.GenericInMemoryCatalog;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.CharType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.VarCharType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+\n+/**\n+ * Use TestValuesCatalog to test partition push down.\n+ * */\n+public class TestValuesCatalog extends GenericInMemoryCatalog {\n+\tprivate boolean supportListPartitionByFilter;\n+\tpublic TestValuesCatalog(String name, String defaultDatabase, boolean supportListPartitionByFilter) {\n+\t\tsuper(name, defaultDatabase);\n+\t\tthis.supportListPartitionByFilter = supportListPartitionByFilter;\n+\t}\n+\n+\t@Override\n+\tpublic List<CatalogPartitionSpec> listPartitionsByFilter(ObjectPath tablePath, List<Expression> filters)\n+\t\t\tthrows TableNotExistException, TableNotPartitionedException, CatalogException {\n+\t\tif (!supportListPartitionByFilter) {\n+\t\t\tthrow new UnsupportedOperationException(\"TestValuesCatalog doesn't support list partition by filters\");\n+\t\t}\n+\n+\t\tList<CatalogPartitionSpec> partitions = listPartitions(tablePath);\n+\t\tif (partitions.isEmpty()) {\n+\t\t\treturn partitions;\n+\t\t}\n+\n+\t\tCatalogBaseTable table = this.getTable(tablePath);\n+\t\tTableSchema schema = table.getSchema();\n+\t\tTestValuesTableFactory.FilterUtil util = TestValuesTableFactory.FilterUtil.INSTANCE;\n+\t\tList<CatalogPartitionSpec> remainingPartitions = new ArrayList<>();\n+\t\tfor (CatalogPartitionSpec partition : partitions) {\n+\t\t\tboolean isRetained = true;\n+\t\t\tFunction<String, Comparable<?>> gettter = getGetter(partition.getPartitionSpec(), schema);\n+\t\t\tfor (Expression predicate : filters) {\n+\t\t\t\tisRetained = util.isRetainedAfterApplyingFilterPredicates((ResolvedExpression) predicate, gettter);\n+\t\t\t\tif (!isRetained) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (isRetained) {\n+\t\t\t\tremainingPartitions.add(partition);\n+\t\t\t}\n+\t\t}\n+\t\treturn remainingPartitions;\n+\t}\n+\n+\tprivate Function<String, Comparable<?>> getGetter(Map<String, String> spec, TableSchema schema) {", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg0MTYxNA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469841614", "bodyText": "what if remainingPartitions  is empty ?", "author": "godfreyhe", "createdAt": "2020-08-13T10:04:25Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -629,35 +618,73 @@ public String asSummaryString() {\n \t\t}\n \n \t\tprivate Collection<RowData> convertToRowData(\n-\t\t\t\tCollection<Row> data,\n+\t\t\t\tMap<Map<String, String>, Collection<Row>> data,\n \t\t\t\tint[] projectedFields,\n \t\t\t\tDataStructureConverter converter) {\n \t\t\tList<RowData> result = new ArrayList<>();\n-\t\t\tfor (Row value : data) {\n-\t\t\t\tif (result.size() >= limit) {\n-\t\t\t\t\treturn result;\n-\t\t\t\t}\n-\t\t\t\tif (isRetainedAfterApplyingFilterPredicates(value)) {\n-\t\t\t\t\tRow projectedRow;\n-\t\t\t\t\tif (projectedFields == null) {\n-\t\t\t\t\t\tprojectedRow = value;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n-\t\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n-\t\t\t\t\t\t\tnewValues[i] = value.getField(projectedFields[i]);\n+\t\t\tList<Map<String, String>> keys = allPartitions.isEmpty() ?\n+\t\t\t\tCollections.singletonList(Collections.EMPTY_MAP) :\n+\t\t\t\tallPartitions;\n+\t\t\tFilterUtil util = FilterUtil.INSTANCE;\n+\t\t\tboolean isRetained = true;\n+\t\t\tfor (Map<String, String> partition: keys) {\n+\t\t\t\tfor (Row value : data.get(partition)) {\n+\t\t\t\t\tif (result.size() >= limit) {\n+\t\t\t\t\t\treturn result;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (filterPredicates != null && !filterPredicates.isEmpty()) {\n+\t\t\t\t\t\tfor (ResolvedExpression predicate: filterPredicates) {\n+\t\t\t\t\t\t\tisRetained = util.isRetainedAfterApplyingFilterPredicates(predicate, getGetter(value));\n+\t\t\t\t\t\t\tif (!isRetained) {\n+\t\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tprojectedRow = Row.of(newValues);\n \t\t\t\t\t}\n-\t\t\t\t\tRowData rowData = (RowData) converter.toInternal(projectedRow);\n-\t\t\t\t\tif (rowData != null) {\n-\t\t\t\t\t\trowData.setRowKind(value.getKind());\n-\t\t\t\t\t\tresult.add(rowData);\n+\t\t\t\t\tif (isRetained) {\n+\t\t\t\t\t\tRow projectedRow;\n+\t\t\t\t\t\tif (projectedFields == null) {\n+\t\t\t\t\t\t\tprojectedRow = value;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tObject[] newValues = new Object[projectedFields.length];\n+\t\t\t\t\t\t\tfor (int i = 0; i < projectedFields.length; ++i) {\n+\t\t\t\t\t\t\t\tnewValues[i] = value.getField(projectedFields[i]);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tprojectedRow = Row.of(newValues);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tRowData rowData = (RowData) converter.toInternal(projectedRow);\n+\t\t\t\t\t\tif (rowData != null) {\n+\t\t\t\t\t\t\trowData.setRowKind(value.getKind());\n+\t\t\t\t\t\t\tresult.add(rowData);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn result;\n \t\t}\n \n+\t\t@Override\n+\t\tpublic Optional<List<Map<String, String>>> listPartitions() {\n+\t\t\tif (allPartitions.isEmpty()) {\n+\t\t\t\tthrow new UnsupportedOperationException(\"Please use catalog to read partitions\");\n+\t\t\t}\n+\t\t\treturn Optional.of(allPartitions);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void applyPartitions(List<Map<String, String>> remainingPartitions) {\n+\t\t\t// remainingPartition is non-nullable.\n+\t\t\tif (allPartitions.isEmpty()) {\n+\t\t\t\t// read partitions from catalog\n+\t\t\t\tif (!remainingPartitions.isEmpty()) {", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg0MjExMQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469842111", "bodyText": "these lines can be simpler", "author": "godfreyhe", "createdAt": "2020-08-13T10:05:15Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesTableFactory.java", "diffHunk": "@@ -821,4 +848,125 @@ public String asSummaryString() {\n \t\t}\n \t}\n \n+\t// --------------------------------------------------------------------------------------------\n+\t// Table utils\n+\t// --------------------------------------------------------------------------------------------\n+\n+\t/**\n+\t * Utils for catalog and source to filter partition or row.\n+\t * */\n+\tpublic static class FilterUtil {\n+\t\tpublic static final FilterUtil INSTANCE = new FilterUtil();\n+\n+\t\tprivate FilterUtil() {}\n+\n+\t\tpublic boolean shouldPushDown(ResolvedExpression expr, Set<String> filterableFields) {\n+\t\t\tif (expr instanceof CallExpression && expr.getChildren().size() == 2) {\n+\t\t\t\treturn shouldPushDownUnaryExpression(expr.getResolvedChildren().get(0), filterableFields)\n+\t\t\t\t\t&& shouldPushDownUnaryExpression(expr.getResolvedChildren().get(1), filterableFields);\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tpublic boolean isRetainedAfterApplyingFilterPredicates(ResolvedExpression predicate, Function<String, Comparable<?>> getter) {\n+\t\t\tif (predicate instanceof CallExpression) {\n+\t\t\t\tFunctionDefinition definition = ((CallExpression) predicate).getFunctionDefinition();\n+\t\t\t\tif (definition.equals(BuiltInFunctionDefinitions.OR)) {\n+\t\t\t\t\t// nested filter, such as (key1 > 2 or key2 > 3)\n+\t\t\t\t\tboolean result = false;\n+\t\t\t\t\tfor (Expression expr: predicate.getChildren()) {\n+\t\t\t\t\t\tif (!(expr instanceof CallExpression && expr.getChildren().size() == 2)) {\n+\t\t\t\t\t\t\tthrow new TableException(expr + \" not supported!\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tresult |= binaryFilterApplies((CallExpression) expr, getter);\n+\t\t\t\t\t\tif (result) {\n+\t\t\t\t\t\t\treturn result;\n+\t\t\t\t\t\t}", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg0MzE5OA==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469843198", "bodyText": "nit: make supportListPartitionByFilter final?", "author": "godfreyhe", "createdAt": "2020-08-13T10:07:14Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesCatalog.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.factories;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.catalog.CatalogBaseTable;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.GenericInMemoryCatalog;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.CharType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.VarCharType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+\n+/**\n+ * Use TestValuesCatalog to test partition push down.\n+ * */\n+public class TestValuesCatalog extends GenericInMemoryCatalog {\n+\tprivate boolean supportListPartitionByFilter;", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg0MzYxMg==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469843612", "bodyText": "typo", "author": "godfreyhe", "createdAt": "2020-08-13T10:08:00Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/factories/TestValuesCatalog.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.factories;\n+\n+import org.apache.flink.table.api.TableException;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.catalog.CatalogBaseTable;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.GenericInMemoryCatalog;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.exceptions.CatalogException;\n+import org.apache.flink.table.catalog.exceptions.TableNotExistException;\n+import org.apache.flink.table.catalog.exceptions.TableNotPartitionedException;\n+import org.apache.flink.table.expressions.Expression;\n+import org.apache.flink.table.expressions.ResolvedExpression;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.BooleanType;\n+import org.apache.flink.table.types.logical.CharType;\n+import org.apache.flink.table.types.logical.DoubleType;\n+import org.apache.flink.table.types.logical.IntType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.VarCharType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+\n+/**\n+ * Use TestValuesCatalog to test partition push down.\n+ * */\n+public class TestValuesCatalog extends GenericInMemoryCatalog {\n+\tprivate boolean supportListPartitionByFilter;\n+\tpublic TestValuesCatalog(String name, String defaultDatabase, boolean supportListPartitionByFilter) {\n+\t\tsuper(name, defaultDatabase);\n+\t\tthis.supportListPartitionByFilter = supportListPartitionByFilter;\n+\t}\n+\n+\t@Override\n+\tpublic List<CatalogPartitionSpec> listPartitionsByFilter(ObjectPath tablePath, List<Expression> filters)\n+\t\t\tthrows TableNotExistException, TableNotPartitionedException, CatalogException {\n+\t\tif (!supportListPartitionByFilter) {\n+\t\t\tthrow new UnsupportedOperationException(\"TestValuesCatalog doesn't support list partition by filters\");\n+\t\t}\n+\n+\t\tList<CatalogPartitionSpec> partitions = listPartitions(tablePath);\n+\t\tif (partitions.isEmpty()) {\n+\t\t\treturn partitions;\n+\t\t}\n+\n+\t\tCatalogBaseTable table = this.getTable(tablePath);\n+\t\tTableSchema schema = table.getSchema();\n+\t\tTestValuesTableFactory.FilterUtil util = TestValuesTableFactory.FilterUtil.INSTANCE;\n+\t\tList<CatalogPartitionSpec> remainingPartitions = new ArrayList<>();\n+\t\tfor (CatalogPartitionSpec partition : partitions) {\n+\t\t\tboolean isRetained = true;\n+\t\t\tFunction<String, Comparable<?>> gettter = getGetter(partition.getPartitionSpec(), schema);", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg0NjU3MQ==", "url": "https://github.com/apache/flink/pull/12966#discussion_r469846571", "bodyText": "just register a new catalog, and change it as default ?", "author": "godfreyhe", "createdAt": "2020-08-13T10:13:41Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/rules/logical/PushPartitionIntoTableSourceScanRuleTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.rules.logical;\n+\n+import org.apache.flink.table.catalog.CatalogPartition;\n+import org.apache.flink.table.catalog.CatalogPartitionImpl;\n+import org.apache.flink.table.catalog.CatalogPartitionSpec;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.planner.calcite.CalciteConfig;\n+import org.apache.flink.table.planner.factories.TestValuesCatalog;\n+import org.apache.flink.table.planner.plan.optimize.program.BatchOptimizeContext;\n+import org.apache.flink.table.planner.plan.optimize.program.FlinkBatchProgram;\n+import org.apache.flink.table.planner.plan.optimize.program.FlinkHepRuleSetProgramBuilder;\n+import org.apache.flink.table.planner.plan.optimize.program.HEP_RULES_EXECUTION_TYPE;\n+import org.apache.flink.table.planner.utils.TableConfigUtils;\n+\n+import org.apache.calcite.plan.hep.HepMatchOrder;\n+import org.apache.calcite.rel.rules.FilterProjectTransposeRule;\n+import org.apache.calcite.tools.RuleSets;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Test for {@link PushPartitionIntoTableSourceScanRule}.\n+ */\n+public class PushPartitionIntoTableSourceScanRuleTest extends PushPartitionIntoLegacyTableSourceScanRuleTest{\n+\tpublic PushPartitionIntoTableSourceScanRuleTest(boolean sourceFetchPartitions, boolean useFilter) {\n+\t\tsuper(sourceFetchPartitions, useFilter);\n+\t}\n+\n+\t@Override\n+\tpublic void setup() throws Exception {\n+\t\tutil().buildBatchProgram(FlinkBatchProgram.DEFAULT_REWRITE());\n+\t\tCalciteConfig calciteConfig = TableConfigUtils.getCalciteConfig(util().tableEnv().getConfig());\n+\t\tcalciteConfig.getBatchProgram().get().addLast(\n+\t\t\t\"rules\",\n+\t\t\tFlinkHepRuleSetProgramBuilder.<BatchOptimizeContext>newBuilder()\n+\t\t\t\t.setHepRulesExecutionType(HEP_RULES_EXECUTION_TYPE.RULE_SEQUENCE())\n+\t\t\t\t.setHepMatchOrder(HepMatchOrder.BOTTOM_UP)\n+\t\t\t\t.add(RuleSets.ofList(FilterProjectTransposeRule.INSTANCE,\n+\t\t\t\t\tPushPartitionIntoTableSourceScanRule.INSTANCE))\n+\t\t\t\t.build());\n+\n+\t\t// define ddl\n+\t\tString ddlTemp =\n+\t\t\t\"CREATE TABLE MyTable (\\n\" +\n+\t\t\t\t\"  id int,\\n\" +\n+\t\t\t\t\"  name string,\\n\" +\n+\t\t\t\t\"  part1 string,\\n\" +\n+\t\t\t\t\"  part2 int)\\n\" +\n+\t\t\t\t\"  partitioned by (part1, part2)\\n\" +\n+\t\t\t\t\"  WITH (\\n\" +\n+\t\t\t\t\" 'connector' = 'values',\\n\" +\n+\t\t\t\t\" 'bounded' = 'true',\\n\" +\n+\t\t\t\t\" 'partition-list' = '%s'\" +\n+\t\t\t\t\")\";\n+\n+\t\tString ddlTempWithVirtualColumn =\n+\t\t\t\"CREATE TABLE VirtualTable (\\n\" +\n+\t\t\t\t\"  id int,\\n\" +\n+\t\t\t\t\"  name string,\\n\" +\n+\t\t\t\t\"  part1 string,\\n\" +\n+\t\t\t\t\"  part2 int,\\n\" +\n+\t\t\t\t\"  virtualField AS part2 + 1)\\n\" +\n+\t\t\t\t\"  partitioned by (part1, part2)\\n\" +\n+\t\t\t\t\"  WITH (\\n\" +\n+\t\t\t\t\" 'connector' = 'values',\\n\" +\n+\t\t\t\t\" 'bounded' = 'true',\\n\" +\n+\t\t\t\t\" 'partition-list' = '%s'\" +\n+\t\t\t\t\")\";\n+\n+\t\tif (sourceFetchPartitions()) {\n+\t\t\tString partitionString = \"part1:A,part2:1;part1:A,part2:2;part1:B,part2:3;part1:C,part2:1\";\n+\t\t\tutil().tableEnv().executeSql(String.format(ddlTemp, partitionString));\n+\t\t\tutil().tableEnv().executeSql(String.format(ddlTempWithVirtualColumn, partitionString));\n+\t\t} else {\n+\t\t\t// replace catalog with TestValuesCatalog\n+\t\t\tutil().tableEnv().executeSql(\"drop catalog default_catalog\");\n+\t\t\tTestValuesCatalog catalog =\n+\t\t\t\tnew TestValuesCatalog(\"default_catalog\", \"default_database\", useCatalogFilter());\n+\t\t\tutil().tableEnv().registerCatalog(\"default_catalog\", catalog);\n+\t\t\tutil().tableEnv().useCatalog(\"default_catalog\");", "originalCommit": "b1b4efe76749cd0dfa6b4aea94ca2ce9f0d15be1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4642a985cde81555583a17880cd2462399338310", "url": "https://github.com/apache/flink/commit/4642a985cde81555583a17880cd2462399338310", "message": "fix godfrey's comment:\n1. fix some typos;\n2. simplify setup logic in single plan test by building a catalog with a different name;\n3. some minor fix with suggestions", "committedDate": "2020-08-13T12:03:18Z", "type": "commit"}, {"oid": "984744723761b8124aa003f23e65d4bb484a73c7", "url": "https://github.com/apache/flink/commit/984744723761b8124aa003f23e65d4bb484a73c7", "message": "fix godfrey's comment:\n1. move filter utils under org.apache.flink.table.planner.utils;\n2. add static for methods;\n3. fix logic in applyPartitions by clear data manually;\n4. fix logic when map row to partitions", "committedDate": "2020-08-13T13:14:43Z", "type": "commit"}, {"oid": "5f342dc43ec04db9a4d7b63c37dd0107c91d7d3e", "url": "https://github.com/apache/flink/commit/5f342dc43ec04db9a4d7b63c37dd0107c91d7d3e", "message": "fix godfrey's comment:\n1. simplify setup in test;\n2. use predicates to filter partition or row;", "committedDate": "2020-08-14T08:00:15Z", "type": "commit"}, {"oid": "e91a84cc20e3655749b8cf9b69ed79d855aaedaf", "url": "https://github.com/apache/flink/commit/e91a84cc20e3655749b8cf9b69ed79d855aaedaf", "message": "minor fix", "committedDate": "2020-08-14T08:04:56Z", "type": "commit"}, {"oid": "d02272061d2264ee74d67da5d9f0e1524f1c7d52", "url": "https://github.com/apache/flink/commit/d02272061d2264ee74d67da5d9f0e1524f1c7d52", "message": "minor fix: reorder the imports.", "committedDate": "2020-08-18T07:31:57Z", "type": "commit"}]}