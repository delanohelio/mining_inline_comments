{"pr_number": 12460, "pr_title": " [FLINK-18063][checkpointing] Fix the race condition for aborting current checkpoint in CheckpointBarrierUnaligner", "pr_createdAt": "2020-06-03T09:39:08Z", "pr_url": "https://github.com/apache/flink/pull/12460", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODk2MA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434518960", "bodyText": "Are you sure this is a safe delete? AlternatingCheckpointBarrierHandler is for example using this method to clean up state of the previous handler before switching to another.", "author": "pnowojski", "createdAt": "2020-06-03T12:10:36Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -117,17 +117,6 @@\n \t\tthreadSafeUnaligner = new ThreadSafeUnaligner(totalNumChannels,\tcheckNotNull(channelStateWriter), this);\n \t}\n \n-\t@Override\n-\tpublic void releaseBlocksAndResetBarriers() {\n-\t\tif (isCheckpointPending()) {\n-\t\t\t// make sure no additional data is persisted\n-\t\t\tArrays.fill(hasInflightBuffers, false);\n-\t\t\t// the next barrier that comes must assume it is the first\n-\t\t\tnumBarrierConsumed = 0;\n-\t\t}\n-\t\tthreadSafeUnaligner.resetReceivedBarriers(currentConsumedCheckpointId);\n-\t}\n-", "originalCommit": "2c474b2b93166fff8a2cbcb635480a2dcda9202a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY3NjI5OA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434676298", "bodyText": "I also found the  issues caused by AlternatingCheckpointBarrierHandler via the failed unit tests. I will consider how to refactor it to make AlternatingCheckpointBarrierHandler go through.", "author": "zhijiangW", "createdAt": "2020-06-03T15:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDg0NQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435734845", "bodyText": "If we change how this method is used, I'd consider it more than a hotfix. Then I'd also like to see the reason for the removal in the commit message (I don't understand it from this commit's perspective).", "author": "AHeise", "createdAt": "2020-06-05T07:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMTI0NA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434521244", "bodyText": "Have we lost this log message?", "author": "pnowojski", "createdAt": "2020-06-03T12:15:00Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -154,46 +154,51 @@ public void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex)\n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tlong cancelledId = cancelBarrier.getCheckpointId();\n-\t\tif (LOG.isDebugEnabled()) {\n-\t\t\tLOG.debug(\"{}: Checkpoint {} canceled, aborting alignment.\", taskName, cancelledId);\n-\t\t}", "originalCommit": "c3f3aca669da2619d58190e684479c3fadd7026f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY3NTM1Nw==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434675357", "bodyText": "I guess this log message is not always valuable and the message aborting alignment might be misleading especially in the case of cancellation id less than the current checkpoint id, because we actually ignore it in that case. I will consider add this debug log under the below condition.", "author": "zhijiangW", "createdAt": "2020-06-03T15:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMTI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyNzI4NQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434527285", "bodyText": "I don't fully understand this boolean shouldAbort2. What are the conditions when it's set to true while shouldAbort1 is false? Why do we have those two sources of truth?", "author": "pnowojski", "createdAt": "2020-06-03T12:25:55Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -154,46 +154,51 @@ public void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex)\n \t@Override\n \tpublic void processCancellationBarrier(CancelCheckpointMarker cancelBarrier) throws Exception {\n \t\tlong cancelledId = cancelBarrier.getCheckpointId();\n-\t\tif (LOG.isDebugEnabled()) {\n-\t\t\tLOG.debug(\"{}: Checkpoint {} canceled, aborting alignment.\", taskName, cancelledId);\n-\t\t}\n-\n-\t\tif (currentConsumedCheckpointId >= cancelledId && !isCheckpointPending()) {\n-\t\t\treturn;\n-\t\t}\n+\t\t// tag whether we should abort checkpoint from task thread view\n+\t\tboolean shouldAbort1 = false;\n \n-\t\tif (isCheckpointPending()) {\n+\t\tif (cancelledId > currentConsumedCheckpointId) {\n+\t\t\tcurrentConsumedCheckpointId = cancelledId;\n+\t\t\tshouldAbort1 = true;\n+\t\t} else if (cancelledId == currentConsumedCheckpointId && isCheckpointPending()) {\n \t\t\tLOG.warn(\"{}: Received cancellation barrier for checkpoint {} before completing current checkpoint {}. \" +\n \t\t\t\t\t\"Skipping current checkpoint.\",\n \t\t\t\ttaskName,\n \t\t\t\tcancelledId,\n \t\t\t\tcurrentConsumedCheckpointId);\n \n \t\t\tresetConsumedBarriers();\n+\t\t\tshouldAbort1 = true;\n+\t\t}\n+\n+\t\t// tag whether we should abort checkpoint from threadSafeUnaligner view\n+\t\tboolean shouldAbort2 = threadSafeUnaligner.setCancelledCheckpointId(cancelledId);", "originalCommit": "c3f3aca669da2619d58190e684479c3fadd7026f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4Njg4MA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434686880", "bodyText": "The checkpoint might happen either by netty thread via notifyBarrierReceived or by task thread via processBarrier, and we are not sure which one would happen earlier in the race condition, so we need to compare both currentReceivedCheckpointId and currentConsumedCheckpointId with canceled id to abort checkpoint properly.\nIf shouldAbort2 true and shouldAbort1 false, that means the notifyBarrierReceived triggered by netty thread happen earlier. E.g. the netty thread receives the ch2 from channel1, and the task thread processes the ch1 from channel2, then the task thread processes the cancellation ch2 from channel3. In this case, shouldAbort1 will be false and shouldAbort2 will be true.\nNo matter which tag is true, we should abort the checkpoint.", "author": "zhijiangW", "createdAt": "2020-06-03T16:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyNzI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4ODgwMQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435188801", "bodyText": "If shouldAbort2 true and shouldAbort1 false, that means the notifyBarrierReceived triggered by netty thread happen earlier.\n\nBut this notifyBarrierReceived from netty thread, would enqueue mailbox action.\nIf the mailbox action hasn't yet been executed, we could mark this checkpoint as aborted here, in this method (task thread), and prevent mail from executing (task thread).\nIf the mailbox action has already executed (task thread), it could have left the currentConsumedCheckpointId field already up to date, so this method would already know whether to abort or not from shouldAbort1.\nOr is it about aborting the checkpoint after notifyBarrierReceived from netty thread, but before enqueued mailbox action was executed?", "author": "pnowojski", "createdAt": "2020-06-04T11:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyNzI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMDExNA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435200114", "bodyText": "If the mailbox action hasn't yet been executed, we could mark this checkpoint as aborted here, in this method (task thread), and prevent mail from executing (task thread).\n\nYes, we already did it in this PR. If the cancelled checkpoint id is larger than current id, the current id would be updated both in CheckpointBarrierUnaligner and ThreadSafeUnaligner. And when the triggered checkpoint prepares to execute from mailbox action, it would be exit directly by comparing the triggered id with current id.\n\nIf the mailbox action has already executed (task thread), it could have left the currentConsumedCheckpointId field already up to date, so this method would already know whether to abort or not from shouldAbort1.\n\nNot alway the case. If the checkpoint 1 triggered by netty thread and then executed by task thread, that does not mean the task thread already processed the respective triggered barrier in advance, so the currentConsumedCheckpointId might still out of date when checkpoint 1 was executed.\nIn the async process of checkpointing, the task thread might continue processing from other channels, then it might process cancellation checkpoint to abort the current executing checkpoint.\n\nOr is it about aborting the checkpoint after notifyBarrierReceived from netty thread, but before enqueued mailbox action was executed?\n\nYes, it can cover this case as well. All in all, it can abort the un-executed checkpoint which was enqueued into mailbox already and also abort the going checkpoint which might be in async process.", "author": "zhijiangW", "createdAt": "2020-06-04T12:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyNzI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwMTQxNw==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435201417", "bodyText": "The key problem here is that we actually maintain two suits of states in CheckpointBarrierUnaligner and ThreadSafeUnaligner separately, and we are not sure which states are up to date in race condition case. Therefore we need to judge both of them to give a final decision.", "author": "zhijiangW", "createdAt": "2020-06-04T12:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyNzI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0Mjc0MA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434542740", "bodyText": "I'm not sure if this is working properly and even if it is, I'm not sure if it's a good way to solve the problem.\nAs far as I understand it works like this:\n\nwe trigger checkpoint from netty thread and enqueue notifyCheckpoint in the mailbox\nwe receive channel closed/end of partition event before notifyCheckpoint starts executing in the task thread from mailbox. This will lead us to this method and enqueuing notifyAbort after notifyCheckpoint in the mailbox\nwe are still going to execute notifyCheckpoint callback and trigger the checkpoint, despite it was already (partially?) aborted (for example resetReceivedBarriers() has already been called.\nnotifyAbort will clean up the checkpoint started in 3.\n\nBesides being quite complicated and hard to reason about, I'm not sure if it's correct and what could be the side effects of doing this in so many stages. It also might be unnecessarily using resources for starting a checkpoint that we already know will not happen.\nWhy can not it work like that:\n\nas before\nwe receive channel closed/end of partition event before notifyCheckpoint starts executing in the task thread from mailbox. We mark the correct checkpoints as cancelled (by bumping the cancelled/current checkpoint ids) in the ThreadSafeUnaligner and we abort the checkpoint immediately (assuming we are in the task thead, but I think we are always).\nif notifyCheckpoint starts executing it should check if the checkpoint it's suppose to notify wasn't cancelled.", "author": "pnowojski", "createdAt": "2020-06-03T12:52:24Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -409,5 +416,15 @@ synchronized long getCurrentCheckpointId() {\n \t\tboolean isCheckpointPending() {\n \t\t\treturn numBarriersReceived > 0;\n \t\t}\n+\n+\t\tprivate void resetReceivedBarriers() {\n+\t\t\tArrays.fill(storeNewBuffers, false);\n+\t\t\tnumBarriersReceived = 0;\n+\t\t}\n+\n+\t\tprivate void notifyAbort(CheckpointException exception) throws IOException {\n+\t\t\tlong currentCheckpointId = currentReceivedCheckpointId;\n+\t\t\thandler.executeInTaskThread(() -> handler.notifyAbort(currentCheckpointId, exception), \"notifyAbort\");\n+\t\t}", "originalCommit": "c3f3aca669da2619d58190e684479c3fadd7026f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwODAxOQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434708019", "bodyText": "Yeah, I get your point here.\nnotifyAbort actually be used in two places ATM, one case is that the netty thread firstly receive the ch1 from one channel and triggered it into mailbox, then it receives the ch2 from another input channel and should abort the previous ch1. But we do not know whether the previous triggered cha1 was executing or not. If not executed, it would be skipped via comparing the current checkpoint id. Otherwise it would be aborted during execution.\nAnother case is for processing end of partition (eof) as you said above. My previous thought was that in the process of async checkpoint, the task thread can still process input (eof). If so, we can not always assume the previous triggered checkpoint has not started when processing eof.\nIf my assumption is wrong, your suggestion should be an improvement in this case. But it might have some concerns to couple eof with current checkpoint ids. Because the current semantic of eof only aborts the current pending checkpoint, that means it can still trigger new checkpoint afterwards. So it might destroy the normal checkpoint/cancellation id judgment for the following checkpoints even though some channels are already ended.\nE.g. when the eof is processed and the current checkpoint id is 3, we should abort the current ch3. But when we receive ch4 from one channel, we should also trigger ch4 in normal way from the perspective of CheckpointBarrierHandler. If we bump the current checkpoint id to 4  or larger id when processing eof, that would break the following new received ids. Unless we make the assumption that CheckpointCoordinator would never trigger new checkpoint after processing eof, but we actually did not have such assumption in the past from CheckpointBarrierHandler view.", "author": "zhijiangW", "createdAt": "2020-06-03T16:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0Mjc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczOTk3OQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435739979", "bodyText": "I think adding a guard in handler.executeInTaskThread(() -> handler.notifyCheckpoint(barrier), \"notifyCheckpoint\"); against executing a cancelled checkpoint is always a good idea. But I'm also seeing that it is not enough.", "author": "AHeise", "createdAt": "2020-06-05T07:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0Mjc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4Mjg0Ng==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435782846", "bodyText": "Yeah, we already had this guard in #notifyCheckpoint method. So are there any concerns for #notifyAbort method?", "author": "zhijiangW", "createdAt": "2020-06-05T08:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0Mjc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0NDQ1MA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434544450", "bodyText": "I think something is missing in the:\n\tprivate void notifyCheckpoint(CheckpointBarrier barrier) throws IOException {\n\t\t// ignore the previous triggered checkpoint by netty thread if it was already canceled or aborted before.\n\t\tif (barrier.getId() >= threadSafeUnaligner.getCurrentCheckpointId()) {\n\t\t\tsuper.notifyCheckpoint(barrier, 0);\n\t\t}\n\t}\n\n? As it is now, after cancelling/closing checkpoint, the above method would still trigger the checkpoint, as barrier.getId() would be equal to currentReceivedCheckpointId", "author": "pnowojski", "createdAt": "2020-06-03T12:55:09Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -387,12 +378,28 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n \t\t}\n \n-\t\tsynchronized void setCurrentReceivedCheckpointId(long currentReceivedCheckpointId) {\n-\t\t\tthis.currentReceivedCheckpointId = Math.max(currentReceivedCheckpointId, this.currentReceivedCheckpointId);\n+\t\tsynchronized boolean setCancelledCheckpointId(long canceledCheckpointId) {\n+\t\t\tboolean shouldAbort = false;\n+\t\t\tif (canceledCheckpointId > currentReceivedCheckpointId) {\n+\t\t\t\tcurrentReceivedCheckpointId = canceledCheckpointId;\n+\t\t\t\tshouldAbort = true;\n+\n+\t\t\t} else if (canceledCheckpointId == currentReceivedCheckpointId && isCheckpointPending()) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tshouldAbort = true;\n+\t\t\t}\n+\t\t\treturn shouldAbort;", "originalCommit": "c3f3aca669da2619d58190e684479c3fadd7026f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMTcwMA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r434711700", "bodyText": "For cancellation checkpoint case, it is still valid because the the currentReceivedCheckpointId from threadSafeUnaligner.getCurrentCheckpointId() would be updated via #setCancelledCheckpointId().\nFor end of partition case, we did not couple it with specific checkpoint id as explained in above comment. And we only abort the current pending checkpoint if have, and allow the following new checkpoint happen afterwards.", "author": "zhijiangW", "createdAt": "2020-06-03T16:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0NDQ1MA=="}], "type": "inlineReview"}, {"oid": "1d838c03d2b9f9744cae6fc03a919db72cc0efd9", "url": "https://github.com/apache/flink/commit/1d838c03d2b9f9744cae6fc03a919db72cc0efd9", "message": "fix the issues for AlternatingCheckpointBarrierHandler", "committedDate": "2020-06-04T05:32:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTg4Ng==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435735886", "bodyText": "A bit unrelated to your change, but shouldn't that also be synchronized?\nAlso is it necessary to move the method?", "author": "AHeise", "createdAt": "2020-06-05T07:23:50Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -404,8 +400,14 @@ synchronized int getNumOpenChannels() {\n \t\t\treturn numOpenChannels;\n \t\t}\n \n+\t\t@VisibleForTesting\n \t\tsynchronized long getCurrentCheckpointId() {\n \t\t\treturn currentReceivedCheckpointId;\n \t\t}\n+\n+\t\t@VisibleForTesting\n+\t\tboolean isCheckpointPending() {", "originalCommit": "8d714d44e2c2dd271baeec7cc9a7519ce7eb309e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MTg2OQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435761869", "bodyText": "The only purpose of retaining this method now is for unit tests. For the main codes, all the callers are already in synchronized, and for test usages it has no race condition issues. So I am a bit torn whether to add synchronized for it, WDYT?", "author": "zhijiangW", "createdAt": "2020-06-05T08:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjA5MQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435856091", "bodyText": "okay, fair enough. let's keep it this way.", "author": "AHeise", "createdAt": "2020-06-05T11:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1OTQ2MQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435859461", "bodyText": "Actually I already refactored the main codes to not use this method which only touched by tests now.", "author": "zhijiangW", "createdAt": "2020-06-05T11:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNzk2Ng==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437217966", "bodyText": "I'd prefer to use this method in main code instead of spreading the knowledge in many places. If I read isCheckpointPending, I understand it much quicker than numBarriersReceived > 0.\nBut it's more a personal taste, so up to you.", "author": "AHeise", "createdAt": "2020-06-09T08:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNzMzOA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435737338", "bodyText": "Can't we move this abort always to the caller side? Then the return value of onChannelClosed is more like shouldBeAborted and would be symmetric to processCancellationBarrier.", "author": "AHeise", "createdAt": "2020-06-05T07:26:52Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -387,12 +378,28 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));", "originalCommit": "c3f3aca669da2619d58190e684479c3fadd7026f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2NDUxMA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435764510", "bodyText": "Good thought and actually I also considered this way while refactoring. The only concern was that from the caller side, it would add currentConsumedCheckpointId in the abort message, but this message might not be consistent with the currentReceivedCheckpointId inside ThreadSafeUnaligner.\nBut I think we might remove this info from #notifyAbort to unify them in the caller.", "author": "zhijiangW", "createdAt": "2020-06-05T08:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNzMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MzQ5Mg==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435853492", "bodyText": "After double checking, we can not remove checkpointId from #notifyAbort method, and since the currentReceivedCheckpointId and currentConsumedCheckpointId might not be consistent always, so I think it is better to place the #notifyAbort in different components to get the proper id, otherwise we might confuse users to see the log info.", "author": "zhijiangW", "createdAt": "2020-06-05T11:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNzMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjM3Mw==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435856373", "bodyText": "Okay, I haven't considered the different checkpoint ids, so leave as is.", "author": "AHeise", "createdAt": "2020-06-05T11:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNzMzOA=="}], "type": "inlineReview"}, {"oid": "31da2083df6221fd36c6ed5674927eed1cc68088", "url": "https://github.com/apache/flink/commit/31da2083df6221fd36c6ed5674927eed1cc68088", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-05T11:10:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1ODE2MQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435858161", "bodyText": "nit: weird newline", "author": "AHeise", "createdAt": "2020-06-05T11:24:46Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -379,12 +376,38 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long canceledCheckpointId) {\n+\t\t\tboolean shouldAbort = false;\n+\t\t\tif (canceledCheckpointId > currentReceivedCheckpointId) {\n+\t\t\t\tcurrentReceivedCheckpointId = canceledCheckpointId;\n+\t\t\t\tshouldAbort = true;\n+", "originalCommit": "31da2083df6221fd36c6ed5674927eed1cc68088", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1ODQ2MQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435858461", "bodyText": "nit: shouldAbort can be inlined for improved readability (in my eyes).", "author": "AHeise", "createdAt": "2020-06-05T11:25:23Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -379,12 +376,38 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized boolean onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (numBarriersReceived > 0) {\n+\t\t\t\tresetReceivedBarriers();\n+\t\t\t\tnotifyAbort(new CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long canceledCheckpointId) {\n+\t\t\tboolean shouldAbort = false;", "originalCommit": "31da2083df6221fd36c6ed5674927eed1cc68088", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1OTc5OQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435859799", "bodyText": "nit: extract DEFAULT_CHECKPOINT_ID?", "author": "AHeise", "createdAt": "2020-06-05T11:28:30Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -512,6 +512,123 @@ public void testConcurrentProcessBarrierAndNotifyBarrierReceived() throws Except\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint() throws Exception {\n+\t\tfinal long checkpointId = 0L;", "originalCommit": "31da2083df6221fd36c6ed5674927eed1cc68088", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MDk0Mg==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435860942", "bodyText": "Would it make sense to extract these assertions in separate test cases? There might be a bias in the implementation, when the checkpoint has already been canceled. It would only add two test cases afaik.", "author": "AHeise", "createdAt": "2020-06-05T11:31:13Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -512,6 +512,123 @@ public void testConcurrentProcessBarrierAndNotifyBarrierReceived() throws Except\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint() throws Exception {\n+\t\tfinal long checkpointId = 0L;\n+\t\tfinal ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n+\t\tfinal CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(\n+\t\t\tnew int[] { 1 }, ChannelStateWriter.NO_OP, \"test\", invokable);\n+\n+\t\tThreadSafeUnaligner unaligner = handler.getThreadSafeUnaligner();\n+\t\t// should trigger respective checkpoint\n+\t\tunaligner.notifyBarrierReceived(buildCheckpointBarrier(checkpointId), new InputChannelInfo(0, 0));\n+\n+\t\tassertFalse(handler.isCheckpointPending());\n+\t\tassertTrue(unaligner.isCheckpointPending());\n+\t\tassertEquals(-1L, handler.getLatestCheckpointId());\n+\t\tassertEquals(checkpointId, unaligner.getCurrentCheckpointId());\n+\n+\t\ttestProcessCancellationBarrier(handler, invokable, checkpointId);\n+\t}\n+\n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link CheckpointBarrierUnaligner#processBarrier(CheckpointBarrier, int)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint2() throws Exception {\n+\t\tfinal long checkpointId = 0L;\n+\t\tfinal ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n+\t\tfinal CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(\n+\t\t\tnew int[] { 1 }, ChannelStateWriter.NO_OP, \"test\", invokable);\n+\n+\t\t// should trigger respective checkpoint\n+\t\thandler.processBarrier(buildCheckpointBarrier(checkpointId), 0);\n+\n+\t\tassertTrue(handler.isCheckpointPending());\n+\t\tassertTrue(handler.getThreadSafeUnaligner().isCheckpointPending());\n+\t\tassertEquals(checkpointId, handler.getLatestCheckpointId());\n+\t\tassertEquals(checkpointId, handler.getThreadSafeUnaligner().getCurrentCheckpointId());\n+\n+\t\ttestProcessCancellationBarrier(handler, invokable, checkpointId);\n+\t}\n+\n+\t@Test\n+\tpublic void testProcessCancellationBarrierBeforeProcessAndReceiveBarrier() throws Exception {\n+\t\tfinal long checkpointId = 0L;\n+\t\tfinal ValidatingCheckpointInvokable invokable = new ValidatingCheckpointInvokable();\n+\t\tfinal CheckpointBarrierUnaligner handler = new CheckpointBarrierUnaligner(\n+\t\t\tnew int[] { 1 }, ChannelStateWriter.NO_OP, \"test\", invokable);\n+\n+\t\thandler.processCancellationBarrier(new CancelCheckpointMarker(checkpointId));\n+\n+\t\tverifyTriggeredCheckpoint(handler, invokable, checkpointId);\n+\n+\t\t// it would not trigger checkpoint since the respective cancellation barrier already happened before\n+\t\thandler.processBarrier(buildCheckpointBarrier(checkpointId), 0);\n+\t\thandler.getThreadSafeUnaligner().notifyBarrierReceived(buildCheckpointBarrier(checkpointId), new InputChannelInfo(0, 0));\n+\n+\t\tverifyTriggeredCheckpoint(handler, invokable, checkpointId);\n+\t}\n+\n+\tprivate void testProcessCancellationBarrier(\n+\t\t\tCheckpointBarrierUnaligner handler,\n+\t\t\tValidatingCheckpointInvokable invokable,\n+\t\t\tlong currentCheckpointId) throws Exception {\n+\n+\t\t// should abort current checkpoint while processing CancelCheckpointMarker\n+\t\thandler.processCancellationBarrier(new CancelCheckpointMarker(currentCheckpointId));\n+\t\tverifyTriggeredCheckpoint(handler, invokable, currentCheckpointId);\n+\n+\t\tfinal long canceledCheckpointId = 1L;\n+\t\t// should update current checkpoint id and abort notification while processing CancelCheckpointMarker\n+\t\thandler.processCancellationBarrier(new CancelCheckpointMarker(canceledCheckpointId));\n+\t\tverifyTriggeredCheckpoint(handler, invokable, canceledCheckpointId);", "originalCommit": "31da2083df6221fd36c6ed5674927eed1cc68088", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3MTg3Ng==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435871876", "bodyText": "Makes sense.", "author": "zhijiangW", "createdAt": "2020-06-05T11:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NTA0MQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r436055041", "bodyText": "FYI: I take a random way to cover both cases for avoiding some duplicated codes.", "author": "zhijiangW", "createdAt": "2020-06-05T17:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MDk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTU2OA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435861568", "bodyText": "typo: witch -> with", "author": "AHeise", "createdAt": "2020-06-05T11:32:40Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnalignerTest.java", "diffHunk": "@@ -512,6 +512,123 @@ public void testConcurrentProcessBarrierAndNotifyBarrierReceived() throws Except\n \t\t}\n \t}\n \n+\t/**\n+\t * Tests {@link CheckpointBarrierUnaligner#processCancellationBarrier(CancelCheckpointMarker)}\n+\t * abort the current pending checkpoint triggered by\n+\t * {@link ThreadSafeUnaligner#notifyBarrierReceived(CheckpointBarrier, InputChannelInfo)}.\n+\t */\n+\t@Test\n+\tpublic void testProcessCancellationBarrierWitchPendingCheckpoint() throws Exception {", "originalCommit": "31da2083df6221fd36c6ed5674927eed1cc68088", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTkzNw==", "url": "https://github.com/apache/flink/pull/12460#discussion_r435861937", "bodyText": "How about naming it testProcessCancellationBarrierAfterNotifyBarrierReceived and the other test testProcessCancellationBarrierAfterProcessBarrier?", "author": "AHeise", "createdAt": "2020-06-05T11:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTU2OA=="}], "type": "inlineReview"}, {"oid": "5729182fd15a074bebba7f878113781c2b119fd3", "url": "https://github.com/apache/flink/commit/5729182fd15a074bebba7f878113781c2b119fd3", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-05T15:49:45Z", "type": "forcePushed"}, {"oid": "cb3e18c9230f0e924acd2fd5066aba096e8c5efc", "url": "https://github.com/apache/flink/commit/cb3e18c9230f0e924acd2fd5066aba096e8c5efc", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-06T14:43:16Z", "type": "forcePushed"}, {"oid": "b54a3e206b35974b2c5bc8046a9f65d58b3e10e9", "url": "https://github.com/apache/flink/commit/b54a3e206b35974b2c5bc8046a9f65d58b3e10e9", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-08T08:47:55Z", "type": "forcePushed"}, {"oid": "4e9a8fe1fd21982c769c435bd82579d09ee3db40", "url": "https://github.com/apache/flink/commit/4e9a8fe1fd21982c769c435bd82579d09ee3db40", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-08T12:27:28Z", "type": "forcePushed"}, {"oid": "2c4ec033b0c3870b7235dc5f595eb453eee3f634", "url": "https://github.com/apache/flink/commit/2c4ec033b0c3870b7235dc5f595eb453eee3f634", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-08T15:15:14Z", "type": "forcePushed"}, {"oid": "6778e65c398f92632a811a5ac5cea1989cc9d970", "url": "https://github.com/apache/flink/commit/6778e65c398f92632a811a5ac5cea1989cc9d970", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-09T04:30:28Z", "type": "forcePushed"}, {"oid": "d69d47ccb7715f55ce6a285179ea7a3754d31197", "url": "https://github.com/apache/flink/commit/d69d47ccb7715f55ce6a285179ea7a3754d31197", "message": "[hotfix][checkpointing] Add VisibleForTesting annotation for related methods", "committedDate": "2020-06-09T04:47:15Z", "type": "commit"}, {"oid": "4e1eff24e36073ea1028a9029d14c77a7cf5336e", "url": "https://github.com/apache/flink/commit/4e1eff24e36073ea1028a9029d14c77a7cf5336e", "message": "[FLINK-18063][checkpointing][refactoring] Implement default #isBlocked method in CheckpointBarrierHandler\n\nSimplify the implementations of CheckpointBarrierTracker and CheckpointBarrierUnaligner to reuse the parent default implementation.\n\nThis closes #12460.", "committedDate": "2020-06-09T04:47:21Z", "type": "commit"}, {"oid": "111011af4265cbf4c61fefcf7f5014a2e37c19e9", "url": "https://github.com/apache/flink/commit/111011af4265cbf4c61fefcf7f5014a2e37c19e9", "message": "[FLINK-18063][checkpointing] Fix the invalid implementation of AlternatingCheckpointBarrierHandler#getAlignmentDurationNanos\n\nWe should take the value from active handler instead of aligned handler, because aligned handler is only used for savepoint and in\nmost cases the unaligned alignment duration should always be 0.\n\nThis cloese #12460.", "committedDate": "2020-06-09T04:47:27Z", "type": "commit"}, {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425", "url": "https://github.com/apache/flink/commit/edfd5e47336b6a9b3339db90946cc580d6c23425", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-09T04:47:33Z", "type": "commit"}, {"oid": "edfd5e47336b6a9b3339db90946cc580d6c23425", "url": "https://github.com/apache/flink/commit/edfd5e47336b6a9b3339db90946cc580d6c23425", "message": "[FLINK-18063][checkpointing] Fix the race condition of aborting checkpoint in CheckpointBarrierUnaligner\n\nThere are three aborting scenarios which might encounter race condition:\n\n1. CheckpointBarrierUnaligner#processCancellationBarrier\n2. CheckpointBarrierUnaligner#processEndOfPartition\n3. AlternatingCheckpointBarrierHandler#processBarrier\n\nThey only consider the pending checkpoint triggered by #processBarrier from task thread to abort it. Actually the checkpoint might\nalso be triggered by #notifyBarrierReceived from netty thread in race condition, so we should also handle properly to abort it.\n\nThis closes #12460.", "committedDate": "2020-06-09T04:47:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNTA1NQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437215055", "bodyText": "&& numBarriersReceived == 0 -> !isCheckpointPending()?", "author": "AHeise", "createdAt": "2020-06-09T08:06:42Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -396,21 +364,55 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized void onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(\n+\t\t\t\t\tcurrentReceivedCheckpointId,\n+\t\t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t}\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long cancelledId) {\n+\t\t\tif (currentReceivedCheckpointId > cancelledId || (currentReceivedCheckpointId == cancelledId && numBarriersReceived == 0)) {", "originalCommit": "edfd5e47336b6a9b3339db90946cc580d6c23425", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyNjY0Mg==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437226642", "bodyText": "My intention to not rely on isCheckpointPending() for new methods, also tried to get ride of it in previous core codes and make isCheckpointPending() only for test purpose.", "author": "zhijiangW", "createdAt": "2020-06-09T08:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNTA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzMjYzMw==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437232633", "bodyText": "I think it also makes sense to use isCheckpointPending() considering this comment reason #12460 (comment).\nMaybe I want to refactor it next time when touching this code, since I do not want to re-execute the azure to block something. :)", "author": "zhijiangW", "createdAt": "2020-06-09T08:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNTA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNTM5OA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437215398", "bodyText": "!isCheckpointPending()?", "author": "AHeise", "createdAt": "2020-06-09T08:07:18Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -396,21 +364,55 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized void onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(\n+\t\t\t\t\tcurrentReceivedCheckpointId,\n+\t\t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t}\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long cancelledId) {\n+\t\t\tif (currentReceivedCheckpointId > cancelledId || (currentReceivedCheckpointId == cancelledId && numBarriersReceived == 0)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentReceivedCheckpointId = cancelledId;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tsynchronized void tryAbortPendingCheckpoint(long checkpointId, CheckpointException exception) throws IOException {\n+\t\t\tif (checkpointId > currentReceivedCheckpointId && resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(currentReceivedCheckpointId, exception);\n+\t\t\t}\n \t\t}\n \n-\t\tsynchronized void setCurrentReceivedCheckpointId(long currentReceivedCheckpointId) {\n-\t\t\tthis.currentReceivedCheckpointId = Math.max(currentReceivedCheckpointId, this.currentReceivedCheckpointId);\n+\t\tprivate boolean resetPendingCheckpoint() {\n+\t\t\tif (numBarriersReceived == 0) {", "originalCommit": "edfd5e47336b6a9b3339db90946cc580d6c23425", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyNjg2NA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437226864", "bodyText": "ditto", "author": "zhijiangW", "createdAt": "2020-06-09T08:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNTM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNjc0OQ==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437216749", "bodyText": "Would it make sense to return the value of resetPendingCheckpoint instead of always true?", "author": "AHeise", "createdAt": "2020-06-09T08:09:41Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierUnaligner.java", "diffHunk": "@@ -396,21 +364,55 @@ synchronized void resetReceivedBarriers(long checkpointId) {\n \t\t\treturn allBarriersReceivedFuture;\n \t\t}\n \n-\t\tsynchronized void onChannelClosed() {\n+\t\tsynchronized void onChannelClosed() throws IOException {\n \t\t\tnumOpenChannels--;\n+\n+\t\t\tif (resetPendingCheckpoint()) {\n+\t\t\t\thandler.notifyAbort(\n+\t\t\t\t\tcurrentReceivedCheckpointId,\n+\t\t\t\t\tnew CheckpointException(CheckpointFailureReason.CHECKPOINT_DECLINED_INPUT_END_OF_STREAM));\n+\t\t\t}\n+\t\t}\n+\n+\t\tsynchronized boolean setCancelledCheckpointId(long cancelledId) {\n+\t\t\tif (currentReceivedCheckpointId > cancelledId || (currentReceivedCheckpointId == cancelledId && numBarriersReceived == 0)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\n+\t\t\tresetPendingCheckpoint();\n+\t\t\tcurrentReceivedCheckpointId = cancelledId;\n+\t\t\treturn true;", "originalCommit": "edfd5e47336b6a9b3339db90946cc580d6c23425", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyOTQ5OA==", "url": "https://github.com/apache/flink/pull/12460#discussion_r437229498", "bodyText": "I guess not, because if numBarriersReceived == 0 the resetPendingCheckpoint will return false, but actually we also need to call abort as long as the canceled id is larger than current checkpoint id.", "author": "zhijiangW", "createdAt": "2020-06-09T08:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxNjc0OQ=="}], "type": "inlineReview"}]}