{"pr_number": 12375, "pr_title": "[FLINK-17017][runtime] Implements bulk allocation for physical slots", "pr_createdAt": "2020-05-28T07:49:38Z", "pr_url": "https://github.com/apache/flink/pull/12375", "timeline": [{"oid": "4fe765587c0423b2d29d5dde946b94edff79398b", "url": "https://github.com/apache/flink/commit/4fe765587c0423b2d29d5dde946b94edff79398b", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks", "committedDate": "2020-05-28T07:49:08Z", "type": "forcePushed"}, {"oid": "c0483c6347992b8c4412da489b5584879834c396", "url": "https://github.com/apache/flink/commit/c0483c6347992b8c4412da489b5584879834c396", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks", "committedDate": "2020-05-28T08:14:33Z", "type": "forcePushed"}, {"oid": "395c6cba8c463cffe2cf3cc70d91e6c6ff0dbb9f", "url": "https://github.com/apache/flink/commit/395c6cba8c463cffe2cf3cc70d91e6c6ff0dbb9f", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-05-29T03:38:04Z", "type": "forcePushed"}, {"oid": "40df0ed6d44b0e9cd11faa7707490045b48151b0", "url": "https://github.com/apache/flink/commit/40df0ed6d44b0e9cd11faa7707490045b48151b0", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-06-01T08:22:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxNDI4OQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r431914289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class PhysicalSlotRequestBulk {\n          \n          \n            \n            class PhysicalSlotRequestBulk {", "author": "azagrebin", "createdAt": "2020-05-28T15:12:04Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulk.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a bulk of physical slot requests.\n+ */\n+public class PhysicalSlotRequestBulk {", "originalCommit": "c0483c6347992b8c4412da489b5584879834c396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwMjU3MA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434402570", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-03T08:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxNDI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxNzYxNQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r431917615", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class BulkSlotAllocationTest extends TestLogger {\n          \n          \n            \n            public class BulkSlotProviderImplTest extends TestLogger {", "author": "azagrebin", "createdAt": "2020-05-28T15:16:35Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotAllocationTest.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.AllocatedSlotOccupationTest.allocateSingleLogicalSlotFromPhysicalSlot;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests whether bulk slot allocation works correctly.\n+ */\n+public class BulkSlotAllocationTest extends TestLogger {", "originalCommit": "c0483c6347992b8c4412da489b5584879834c396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwMjUzMg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434402532", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-03T08:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxNzYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyOTgyMA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r431929820", "bodyText": "can this be a separate test?", "author": "azagrebin", "createdAt": "2020-05-28T15:33:09Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate ManualClock clock = new ManualClock();\n+\n+\tprivate PhysicalSlotRequestBulkTracker bulkTracker;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tbulkTracker = new PhysicalSlotRequestBulkTracker(clock);\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkTracking() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\n+\t\tbulkTracker.track(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(true));\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(clock.relativeTimeMillis()));\n+\n+\t\tbulkTracker.untrack(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testUnfulfillableTimestampWillNotBeOverriddenByFollowingUnfulfillableTimestamp() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\t\tbulkTracker.track(bulk);\n+\n+\t\tfinal long unfulfillableSince = clock.relativeTimeMillis();\n+\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(unfulfillableSince));\n+\n+\t\tclock.advanceTime(456, TimeUnit.MILLISECONDS);\n+\t\tbulkTracker.markBulkUnfulfillable(bulk, clock.relativeTimeMillis());\n+\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(unfulfillableSince));\n+\n+\t\tbulkTracker.markBulkFulfillable(bulk);\n+\t\tbulkTracker.markBulkUnfulfillable(bulk, clock.relativeTimeMillis());\n+\n+\t\tassertThat(bulkTracker.getBulkUnfulfillableSince(bulk), is(clock.relativeTimeMillis()));", "originalCommit": "c0483c6347992b8c4412da489b5584879834c396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwMDIyOQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434400229", "bodyText": "Ok. Added a test testMarkBulkUnfulfillable", "author": "zhuzhurk", "createdAt": "2020-06-03T08:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyOTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0MjA4MA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r431942080", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n          \n          \n            \n            \t\tassertThat(physicalSlot.willBeOccupiedIndefinitely(), is(true));\n          \n      \n    \n    \n  \n\nalso in other places", "author": "azagrebin", "createdAt": "2020-05-28T15:50:39Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation state of {@link AllocatedSlot} is correctly.\n+ */\n+public class AllocatedSlotOccupationTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testSingleTaskOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());", "originalCommit": "d4f7f62d23744dd58ceb0e0018a03b39a8ba556a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwNDg4Mw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434404883", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-03T08:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0MjA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0OTY5OA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433749698", "bodyText": "nit: We have this logic in some places in production as well.\nMaybe, this could factored out into SingleLogicalSlot#allocateFromPhysicalSlot?", "author": "azagrebin", "createdAt": "2020-06-02T09:39:05Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/AllocatedSlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation state of {@link AllocatedSlot} is correctly.\n+ */\n+public class AllocatedSlotOccupationTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testSingleTaskOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n+\t}\n+\n+\t@Test\n+\tpublic void testSingleTaskNotOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, false);\n+\n+\t\tassertFalse(physicalSlot.willBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate static PhysicalSlot createPhysicalSlot() {\n+\t\treturn new AllocatedSlot(\n+\t\t\tnew AllocationID(),\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\t0,\n+\t\t\tResourceProfile.ANY,\n+\t\t\tnew SimpleAckingTaskManagerGateway());\n+\t}\n+\n+\tstatic LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal PhysicalSlot physicalSlot,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely) {\n+\n+\t\treturn allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tnew SlotRequestId(),\n+\t\t\tphysicalSlot,\n+\t\t\tnew TestingSlotOwner(),\n+\t\t\tslotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tstatic LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(", "originalCommit": "40df0ed6d44b0e9cd11faa7707490045b48151b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNTgzOQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435125839", "bodyText": "sure. It's good to do this.", "author": "zhuzhurk", "createdAt": "2020-06-04T09:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0OTY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5ODUxMQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435198511", "bodyText": "done via cafd808", "author": "zhuzhurk", "createdAt": "2020-06-04T11:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0OTY5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NzQyNg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433787426", "bodyText": "What do you think about BulkSlotProviderImpl#createWithSystemClock()?", "author": "azagrebin", "createdAt": "2020-06-02T10:50:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.Clock;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {", "originalCommit": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NjQxMQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434966411", "bodyText": "I think it's not needed since this is the only valid entry for production. The other construtor is for testing purpose only.", "author": "zhuzhurk", "createdAt": "2020-06-04T03:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIzMTA1Ng==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435231056", "bodyText": "it is fine. Generally, I think we could keep the constructors for pure field assignments of actual dependencies (injections) to simplify mocking dependencies in tests. I mean having no logic in constructors. If some construction logic is required, I think it is more readable to use factory methods which names reflect what they do as constructor cannot have a more descriptive name.", "author": "azagrebin", "createdAt": "2020-06-04T12:56:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NzQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTM2OA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433801368", "bodyText": "Generally, making methods VisibleForTesting looks like we have one more concern to test internally.\nCould we factor out this concern to test separately?\nWhat if we create a PhysicalSlotRequestBulkTracker(requests, slotPool) for each bulk by merging it with PhysicalSlotRequestBulk?\nor PhysicalSlotRequestBulk could have the unfulfillableSinceTimestamp internally.\nNot sure, why we need the existing PhysicalSlotRequestBulkTracker for all bulk timestamps.\nAll methods here, related to timeout/fulfilablity check, could also go into the PhysicalSlotRequestBulkTracker.\nBulkSlotProviderImpl could schedule PhysicalSlotRequestBulkTracker#checkPhysicalSlotRequestBulkTimeout for each bulk.\nPhysicalSlotRequestBulkTracker#checkPhysicalSlotRequestBulkTimeout could return FINISHED/FULFILLABLE/TIMEOUT.\nThen PhysicalSlotRequestBulkTracker#checkPhysicalSlotRequestBulkTimeout could be tested separately.", "author": "azagrebin", "createdAt": "2020-06-02T11:19:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.Clock;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis(slotSelectionStrategy, slotPool, SystemClock.getInstance());\n+\t}\n+\n+\t@VisibleForTesting\n+\tBulkSlotProviderImpl(\n+\t\t\tfinal SlotSelectionStrategy slotSelectionStrategy,\n+\t\t\tfinal SlotPool slotPool,\n+\t\t\tfinal Clock clock) {\n+\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\t\tthis.clock = checkNotNull(clock);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(clock);\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlotWithoutTimeout(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile,\n+\t\t\t\t!physicalSlotRequest.willSlotBeOccupiedIndefinitely());\n+\t\t}\n+\n+\t\treturn slotFuture.thenApply(physicalSlot -> new PhysicalSlotRequest.Result(slotRequestId, physicalSlot));\n+\t}\n+\n+\tprivate Optional<PhysicalSlot> tryAllocateFromAvailable(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\n+\t\tfinal Collection<SlotSelectionStrategy.SlotInfoAndResources> slotInfoList =\n+\t\t\tslotPool.getAvailableSlotsInformation()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(SlotSelectionStrategy.SlotInfoAndResources::fromSingleSlot)\n+\t\t\t\t.collect(Collectors.toList());\n+\n+\t\tfinal Optional<SlotSelectionStrategy.SlotInfoAndLocality> selectedAvailableSlot =\n+\t\t\tslotSelectionStrategy.selectBestSlotForProfile(slotInfoList, slotProfile);\n+\n+\t\treturn selectedAvailableSlot.flatMap(\n+\t\t\tslotInfoAndLocality -> slotPool.allocateAvailableSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tslotInfoAndLocality.getSlotInfo().getAllocationId())\n+\t\t);\n+\t}\n+\n+\tprivate void schedulePendingRequestBulkTimeoutCheck(\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk,\n+\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.schedule(() -> {\n+\t\t\tif (!checkPhysicalSlotRequestBulkTimeout(slotRequestBulk, timeout)) {\n+\t\t\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\t\t\t}\n+\t\t}, timeout.getSize(), timeout.getUnit());\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n+\t * @param slotRequestBulk bulk of slot requests\n+\t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable\n+\t * @return true if the slot request bulk is done or timed out, otherwise false\n+\t */\n+\t@VisibleForTesting\n+\tprotected boolean checkPhysicalSlotRequestBulkTimeout(", "originalCommit": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5NDk2OQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435194969", "bodyText": "Sounds good to me. Let me take another look.", "author": "zhuzhurk", "createdAt": "2020-06-04T11:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NTMwMQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435845301", "bodyText": "done in a59c25e.\nmain changes are:\n\nunfulfillableSinceTimestamp and related methods are moved into PhysicalSlotRequestBulk. Related tests moved to PhysicalSlotRequestBulkTest.\nbulk timeout check methods are moved into PhysicalSlotRequestBulkTracker. Tests are reworked.\nkept tests for PhysicalSlotRequestBulkTracker#isSlotRequestBulkFulfillable but made this method static\nPhysicalSlotRequestBulkTracker#checkPhysicalSlotRequestBulkTimeout is reworked to return FULFILLED/PENDING/TIMEOUT. The slot releasing on TIMEOUT will invoked in schedulePendingRequestBulkTimeoutCheck.", "author": "zhuzhurk", "createdAt": "2020-06-05T10:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NTc2OQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435845769", "bodyText": "BulkSlotProvider#cancelSlotRequest(...) is added", "author": "zhuzhurk", "createdAt": "2020-06-05T10:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MDkxNw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435880917", "bodyText": "Is the main use case of cancelSlotRequest in BulkSlotProvider to release the slot after its task is done? It is indeed used also to interrupt the request in SchedulerImpl, as I understand, but I would consider renaming it to releaseSlot in BulkSlotProvider when possible.", "author": "azagrebin", "createdAt": "2020-06-05T12:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTM2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3NDQxMw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437974413", "bodyText": "cancelSlotRequest are possible to cancel pending physical slots requests. So I think it is better than releaseSlot.", "author": "zhuzhurk", "createdAt": "2020-06-10T09:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTY3OQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433801679", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid markRequestFulfilled(final SlotRequestId slotRequestId, final AllocationID allocationID) {\n          \n          \n            \n            \tvoid fulfillPendingSlotRequest(final SlotRequestId slotRequestId, final AllocationID allocationID) {", "author": "azagrebin", "createdAt": "2020-06-02T11:20:22Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulk.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a bulk of physical slot requests.\n+ */\n+public class PhysicalSlotRequestBulk {\n+\n+\tprivate final Map<SlotRequestId, ResourceProfile> pendingRequests;\n+\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests = new HashMap<>();\n+\n+\tPhysicalSlotRequestBulk(final Collection<PhysicalSlotRequest> physicalSlotRequests) {\n+\t\tthis.pendingRequests = physicalSlotRequests.stream()\n+\t\t\t.collect(Collectors.toMap(\n+\t\t\t\tPhysicalSlotRequest::getSlotRequestId,\n+\t\t\t\tr -> r.getSlotProfile().getPhysicalSlotResourceProfile()));\n+\t}\n+\n+\tvoid markRequestFulfilled(final SlotRequestId slotRequestId, final AllocationID allocationID) {", "originalCommit": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NTUzOA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434965538", "bodyText": "I think markRequestFulfilled is more accurate since this method does not fulfill requests. It is more alike a callback on slot request fulfilled.", "author": "zhuzhurk", "createdAt": "2020-06-04T03:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwMTY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNTc2Nw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433805767", "bodyText": "Maybe, SlotProvider could just extend BulkSlotProvider?", "author": "azagrebin", "createdAt": "2020-06-02T11:28:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotProvider.java", "diffHunk": "@@ -91,6 +92,20 @@\n \t\t\tallocationTimeout);\n \t}\n \n+\t/**\n+\t * Allocates a bulk of physical slots. The allocation will be completed\n+\t * normally only when all the requests are fulfilled.\n+\t *\n+\t * @param physicalSlotRequests requests for physical slots\n+\t * @param timeout indicating how long it is accepted that the slot requests can be unfulfillable\n+\t * @return future of the results of slot requests\n+\t */\n+\tdefault CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(", "originalCommit": "40df0ed6d44b0e9cd11faa7707490045b48151b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NDczMA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434964730", "bodyText": "I think that might not be good since we will still need to declare the default body here to avoid implement this method for all SlotProvider implementations .", "author": "zhuzhurk", "createdAt": "2020-06-04T02:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNTc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIzMjE1OA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435232158", "bodyText": "I think having default method is fine in BulkSlotProvider, it should be inherited by SlotProvider, right? and then no need to implement it everywhere. It is also related to making OneSlotPerExecutionSlotAllocator depending only on BulkSlotProvider in #12256.", "author": "azagrebin", "createdAt": "2020-06-04T12:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNTc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MDUyMw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435840523", "bodyText": "Ok. It would be good to limit OneSlotPerExecutionSlotAllocator to only use methods of the new interface.", "author": "zhuzhurk", "createdAt": "2020-06-05T10:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNTc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0MDU1NA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435840554", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-05T10:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzgwNTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTQ5OQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433909499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tdisableBatchSlotTimeoutCheck();\n          \n          \n            \n            \t\tbatchSlotTimeoutCheckEnabled = false;\n          \n      \n    \n    \n  \n\ndo we need a method for this?", "author": "azagrebin", "createdAt": "2020-06-02T14:13:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -447,12 +452,40 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \n \t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n \n+\t\tcheckState(batchSlotTimeoutCheckEnabled, \"batch slot timeout check is disabled unexpectedly.\");\n+\n \t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n \n \t\treturn requestNewAllocatedSlotInternal(pendingRequest)\n \t\t\t.thenApply(Function.identity());\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlotWithoutTimeout(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal ResourceProfile resourceProfile,\n+\t\t\tfinal boolean isBatchRequest) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\t// a slot pool can serve either this kind of request or requestNewAllocatedBatchSlot(...), never both\n+\t\tdisableBatchSlotTimeoutCheck();", "originalCommit": "991e7d77e2e35e51f4f2784cb64bddacf50eff4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NzQ0OA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434967448", "bodyText": "we can remove this method.", "author": "zhuzhurk", "createdAt": "2020-06-04T03:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5ODk5Mg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435198992", "bodyText": "no more requestNewAllocatedSlotWithoutTimeout() anymore so no change is needed.", "author": "zhuzhurk", "createdAt": "2020-06-04T12:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODg1MQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433918851", "bodyText": "I am wondering whether it would be more clear just to add  disableBatchSlotTimeoutCheck explicitly to the public interface.\nWe could also make timeout Nullable in requestNewAllocatedSlot then FutureUtils.orTimeout can be conditional in requestNewAllocatedSlot.\nThe we do not need requestNewAllocatedSlotWithoutTimeout and make any assumptions in it about batchSlotTimeoutCheckEnabled.", "author": "azagrebin", "createdAt": "2020-06-02T14:25:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -447,12 +452,40 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \n \t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n \n+\t\tcheckState(batchSlotTimeoutCheckEnabled, \"batch slot timeout check is disabled unexpectedly.\");\n+\n \t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n \n \t\treturn requestNewAllocatedSlotInternal(pendingRequest)\n \t\t\t.thenApply(Function.identity());\n \t}\n \n+\t@Override\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlotWithoutTimeout(", "originalCommit": "991e7d77e2e35e51f4f2784cb64bddacf50eff4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNjU1OQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435126559", "bodyText": "Agreed it would be better to explicitly disable the timeout check.", "author": "zhuzhurk", "createdAt": "2020-06-04T09:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5OTQ4MQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435199481", "bodyText": "done via 9b5ca3d and 54bd461", "author": "zhuzhurk", "createdAt": "2020-06-04T12:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkxODk2OA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437918968", "bodyText": "I do not see where we call disableBatchSlotTimeoutCheck now.\nShould we add it to BulkSlotProviderImpl#start?\nAlso a test?", "author": "azagrebin", "createdAt": "2020-06-10T07:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk1ODY0Mg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437958642", "bodyText": "Yeah my stupid mistake.\nWill call it in BulkSlotProviderImpl#start and add a test", "author": "zhuzhurk", "createdAt": "2020-06-10T08:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODg1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3MjczNQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437972735", "bodyText": "done. Added testIndividualBatchSlotRequestTimeoutCheckIsDisabled.", "author": "zhuzhurk", "createdAt": "2020-06-10T09:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxODg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMjE2Nw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r433922167", "bodyText": "maybe no immediate action now, but I find it quite hard to judge about failures in SlotPoolImpl , especially for bulk allocation.\nWith this new concept of fulfil-ability, maybe we should simplify SlotPoolImpl and let BulkSlotProviderImpl judge about how to interpret external request failures and when to fulfil the requests, it could be a follow-up.\nWe might want to note that new slot allocation has failed but there are often chances that the pending request can be fulfilled by allocated slots.", "author": "azagrebin", "createdAt": "2020-06-02T14:30:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.Clock;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis(slotSelectionStrategy, slotPool, SystemClock.getInstance());\n+\t}\n+\n+\t@VisibleForTesting\n+\tBulkSlotProviderImpl(\n+\t\t\tfinal SlotSelectionStrategy slotSelectionStrategy,\n+\t\t\tfinal SlotPool slotPool,\n+\t\t\tfinal Clock clock) {\n+\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\t\tthis.clock = checkNotNull(clock);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(clock);\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlotWithoutTimeout(", "originalCommit": "e5f6cea6a4516e0ffd04078c0b22c0b8da36714d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4NzM4NQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434987385", "bodyText": "I'm thinking whether we should treat slot pool more a like a pool, and thus to split concerns of bulk allocation failures and external request failures.\n\nbulk allocation fails because it is not fulfillable, we can print debug level logs of desc of slot requests  and state of available/allocated slots in the slot pool.\nexternal request failures should be exposed in logs to demonstrate that Flink fails to extend the pool, which can be the deep reason that why a bulk of slot requests fails. However, external sot request failures does not mean that the internal slot request is definitely to fail.\n\nI'm even thinking to enable auto-retry for failed external sot requests rather than fail the initiating internal slot request to make slot pool more a like a pool. (related to this comment)", "author": "zhuzhurk", "createdAt": "2020-06-04T04:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4ODM2MQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r434988361", "bodyText": "Anyhow I totally agreed that we should make it easier for users to debug bulk slot allocation failures.\nOpened a ticket FLINK-18114 to track it.", "author": "zhuzhurk", "createdAt": "2020-06-04T04:40:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2NjgzNA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435366834", "bodyText": "The problem may be in UnfulfillableSlotRequestException when there is no point in retrying, see also comment. It looks this might need more thinking and simplification of design if possible.", "author": "azagrebin", "createdAt": "2020-06-04T15:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMjE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY3NDk1Mg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r435674952", "bodyText": "Agreed. The design should take both \"fail-fast on UnfulfillableSlotRequestException\" and \"not fail streaming slot request if it is fulfillable\" into consideration. And related error messages should be enabled for troubleshooting.", "author": "zhuzhurk", "createdAt": "2020-06-05T03:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyMjE2Nw=="}], "type": "inlineReview"}, {"oid": "35ef82ee0bf1d008719a52e8182f9b63f3eddb11", "url": "https://github.com/apache/flink/commit/35ef82ee0bf1d008719a52e8182f9b63f3eddb11", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-06-04T11:57:56Z", "type": "forcePushed"}, {"oid": "98a78bfe1cc44663287997d145b5bee0bf9ac6ec", "url": "https://github.com/apache/flink/commit/98a78bfe1cc44663287997d145b5bee0bf9ac6ec", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-06-05T10:22:29Z", "type": "forcePushed"}, {"oid": "cd3fc98c034fdc61235d9109c05b4f55d7423746", "url": "https://github.com/apache/flink/commit/cd3fc98c034fdc61235d9109c05b4f55d7423746", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-06-05T10:42:43Z", "type": "forcePushed"}, {"oid": "a8902557952ea70746d27e88a392c74724784605", "url": "https://github.com/apache/flink/commit/a8902557952ea70746d27e88a392c74724784605", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-06-05T16:49:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMDc5Mw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437920793", "bodyText": "nit: maybe one more method slotFuture = requestNewSlot(willSlotBeOccupiedIndefinitely, slotRequestId, resourceProfile)?", "author": "azagrebin", "createdAt": "2020-06-10T07:39:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(\n+\t\t\tthis::getAllSlotInfos,\n+\t\t\tSystemClock.getInstance());\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic void cancelSlotRequest(SlotRequestId slotRequestId, Throwable cause) {\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tslotPool.releaseSlot(slotRequestId, cause);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else if (physicalSlotRequest.willSlotBeOccupiedIndefinitely()) {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile,\n+\t\t\t\tnull);\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedBatchSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile);\n+\t\t}", "originalCommit": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2NjUwMg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437966502", "bodyText": "Maybe not right now given that it is not required by this change.\nThe only difference that requestNewAllocatedSlot and requestNewAllocatedBatchSlot make is whether the request will fail-fast on normal allocation failures (i.e. failures that are not UnfulfillableSlotRequestException).\nI think we can remove the method requestNewAllocatedBatchSlot and do not differentiate batch/streaming requests in SlotPool anymore once when we are to disable the fail-fast for streaming slot requests on normal allocation failures. This will however lead to behavior changes and will need a discussion in community ML in think.", "author": "zhuzhurk", "createdAt": "2020-06-10T08:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMDc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNjc1Ng==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438636756", "bodyText": "I meant only a private helper method in BulkSlotProviderImpl :)\nit is a nit anyways", "author": "azagrebin", "createdAt": "2020-06-11T08:48:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMDc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1Mjk0NQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438652945", "bodyText": "Understood. Sure we can do it.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMDc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1NzI5OA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438657298", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMDc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjI2Nw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437926267", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n          \n          \n            \n            \t * Check the slot request bulk and timeout its requests if it has been unfulfillable for too long.", "author": "azagrebin", "createdAt": "2020-06-10T07:46:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;\n+\n+\tPhysicalSlotRequestBulkTracker(final Supplier<Set<SlotInfo>> slotsRetriever, final Clock clock) {\n+\t\tthis.slotsRetriever = checkNotNull(slotsRetriever);\n+\t\tthis.clock = checkNotNull(clock);\n+\t\tthis.slotRequestBulks = Collections.newSetFromMap(new IdentityHashMap<>());\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.add(bulk);\n+\n+\t\tbulk.markUnfulfillable(clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.remove(bulk);\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn slotRequestBulks.contains(bulk);\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.", "originalCommit": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3MjAwMg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437972002", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-10T09:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjQwMw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437926403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable\n          \n          \n            \n            \t * @param slotRequestTimeout indicates how long a pending request can be unfulfillable", "author": "azagrebin", "createdAt": "2020-06-10T07:47:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;\n+\n+\tPhysicalSlotRequestBulkTracker(final Supplier<Set<SlotInfo>> slotsRetriever, final Clock clock) {\n+\t\tthis.slotsRetriever = checkNotNull(slotsRetriever);\n+\t\tthis.clock = checkNotNull(clock);\n+\t\tthis.slotRequestBulks = Collections.newSetFromMap(new IdentityHashMap<>());\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.add(bulk);\n+\n+\t\tbulk.markUnfulfillable(clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.remove(bulk);\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn slotRequestBulks.contains(bulk);\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n+\t * @param slotRequestBulk bulk of slot requests\n+\t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable", "originalCommit": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3MTk2MA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437971960", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-10T09:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNjQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTM2MQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437935361", "bodyText": "Why do we need to expose isSlotRequestBulkFulfillable?\nCould we not test the same with checkPhysicalSlotRequestBulkTimeout and e.g. PhysicalSlotRequestBulk.isFulfillable?", "author": "azagrebin", "createdAt": "2020-06-10T08:02:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;\n+\n+\tPhysicalSlotRequestBulkTracker(final Supplier<Set<SlotInfo>> slotsRetriever, final Clock clock) {\n+\t\tthis.slotsRetriever = checkNotNull(slotsRetriever);\n+\t\tthis.clock = checkNotNull(clock);\n+\t\tthis.slotRequestBulks = Collections.newSetFromMap(new IdentityHashMap<>());\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.add(bulk);\n+\n+\t\tbulk.markUnfulfillable(clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tslotRequestBulks.remove(bulk);\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn slotRequestBulks.contains(bulk);\n+\t}\n+\n+\t/**\n+\t * Check the slot request bulk and timeout its requests if it has been unfilfillable for too long.\n+\t * @param slotRequestBulk bulk of slot requests\n+\t * @param slotRequestTimeout indicates how long a pending request can be unfilfillable\n+\t * @return result of the check, indicating the bulk is fulfilled, still pending, or timed out\n+\t */\n+\tTimeoutCheckResult checkPhysicalSlotRequestBulkTimeout(\n+\t\t\tfinal PhysicalSlotRequestBulk slotRequestBulk,\n+\t\t\tfinal Time slotRequestTimeout) {\n+\n+\t\tcheckState(isTracked(slotRequestBulk));\n+\n+\t\tif (slotRequestBulk.getPendingRequests().isEmpty()) {\n+\t\t\treturn TimeoutCheckResult.FULFILLED;\n+\t\t}\n+\n+\t\tfinal boolean fulfillable = isSlotRequestBulkFulfillable(slotRequestBulk, slotsRetriever);\n+\t\tif (fulfillable) {\n+\t\t\tslotRequestBulk.markFulfillable();\n+\t\t} else {\n+\t\t\tfinal long currentTimestamp = clock.relativeTimeMillis();\n+\n+\t\t\tslotRequestBulk.markUnfulfillable(currentTimestamp);\n+\n+\t\t\tfinal long unfulfillableSince = slotRequestBulk.getUnfulfillableSince();\n+\t\t\tif (unfulfillableSince + slotRequestTimeout.toMilliseconds() <= currentTimestamp) {\n+\t\t\t\treturn TimeoutCheckResult.TIMEOUT;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn TimeoutCheckResult.PENDING;\n+\t}\n+\n+\t/**\n+\t * Returns whether the given bulk of slot requests are possible to be fulfilled at the same time\n+\t * with all the reusable slots in the slot pool. A reusable slot means the slot is available or\n+\t * will not be occupied indefinitely.\n+\t *\n+\t * @param slotRequestBulk bulk of slot requests to check\n+\t * @param slotsRetriever supplies slots to be used for the fulfill-ability check\n+\t * @return true if the slot requests are possible to be fulfilled, otherwise false\n+\t */\n+\t@VisibleForTesting\n+\tstatic boolean isSlotRequestBulkFulfillable(", "originalCommit": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk5Mzc2NQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437993765", "bodyText": "Yes it's possible to test isSlotRequestBulkFulfillable with checkPhysicalSlotRequestBulkTimeout but it will complicate the tests for understanding and maintenance.\nisSlotRequestBulkFulfillable is a static utility method so I think it's fine to test it separately.", "author": "zhuzhurk", "createdAt": "2020-06-10T09:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNTM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437936600", "bodyText": "Not sure I understand why we need slotRequestBulks/track/untrack/isTracked.\nLooks only for tests. Can we remove it?", "author": "azagrebin", "createdAt": "2020-06-10T08:04:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks. Once a bulk is registered, a fulfill-ability check for it will be scheduled.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\tprivate final Clock clock;\n+\n+\tprivate final Set<PhysicalSlotRequestBulk> slotRequestBulks;", "originalCommit": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxNTIyMw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438015223", "bodyText": "Yes we can remove them. I had wanted to keep the bulks tracked for sanity check and diagnostic but of course it is not necessary.", "author": "zhuzhurk", "createdAt": "2020-06-10T10:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODAxNjE0NA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438016144", "bodyText": "Done via d3f81cb.\nPhysicalSlotRequestBulkTracker#createPhysicalSlotRequestBulk is introduced so that we can reset the unfulfillable timestamp for a newly created bulk with the clock of PhysicalSlotRequestBulkTracker.", "author": "zhuzhurk", "createdAt": "2020-06-10T10:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYwMzk1Ng==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438603956", "bodyText": "What do you think of rename PhysicalSlotRequestBulkTracker to PhysicalSlotRequestBulkHelper since it does not track the bulks but provides several methods which helps with bulk creation, initialization and checking?", "author": "zhuzhurk", "createdAt": "2020-06-11T07:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0NDMyNQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438644325", "bodyText": "Maybe then PhysicalSlotRequestBulkChecker?", "author": "azagrebin", "createdAt": "2020-06-11T09:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MzE2OQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438653169", "bodyText": "PhysicalSlotRequestBulkChecker sounds good to me.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1NzI1Ng==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438657256", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzNjYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzOTkzOQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437939939", "bodyText": "I thought we could actually move timeoutSlotRequestBulk/getAllSlotInfos and pass slotPool to PhysicalSlotRequestBulkTracker. Would this simplify multithreading in tests?\nFor multithreading, we would only need to check whether BulkSlotProviderImpl properly schedules checkPhysicalSlotRequestBulkTimeout.", "author": "azagrebin", "createdAt": "2020-06-10T08:10:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImpl.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Default implementation of {@link BulkSlotProvider}.\n+ */\n+class BulkSlotProviderImpl implements BulkSlotProvider {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(BulkSlotProviderImpl.class);\n+\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\tprivate final SlotSelectionStrategy slotSelectionStrategy;\n+\n+\tprivate final SlotPool slotPool;\n+\n+\tprivate final PhysicalSlotRequestBulkTracker slotRequestBulkTracker;\n+\n+\tBulkSlotProviderImpl(final SlotSelectionStrategy slotSelectionStrategy, final SlotPool slotPool) {\n+\t\tthis.slotSelectionStrategy = checkNotNull(slotSelectionStrategy);\n+\t\tthis.slotPool = checkNotNull(slotPool);\n+\n+\t\tthis.slotRequestBulkTracker = new PhysicalSlotRequestBulkTracker(\n+\t\t\tthis::getAllSlotInfos,\n+\t\t\tSystemClock.getInstance());\n+\n+\t\tthis.componentMainThreadExecutor = new ComponentMainThreadExecutor.DummyComponentMainThreadExecutor(\n+\t\t\t\"Scheduler is not initialized with proper main thread executor. \" +\n+\t\t\t\t\"Call to BulkSlotProvider.start(...) required.\");\n+\t}\n+\n+\t@Override\n+\tpublic void start(final ComponentMainThreadExecutor mainThreadExecutor) {\n+\t\tthis.componentMainThreadExecutor = mainThreadExecutor;\n+\t}\n+\n+\t@Override\n+\tpublic void cancelSlotRequest(SlotRequestId slotRequestId, Throwable cause) {\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tslotPool.releaseSlot(slotRequestId, cause);\n+\t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.assertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Received {} slot requests.\", physicalSlotRequests.size());\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\t\tfinal ResourceProfile resourceProfile = slotProfile.getPhysicalSlotResourceProfile();\n+\n+\t\tLOG.debug(\"Received slot request [{}] with resource requirements: {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal Optional<PhysicalSlot> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get());\n+\t\t} else if (physicalSlotRequest.willSlotBeOccupiedIndefinitely()) {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile,\n+\t\t\t\tnull);\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedBatchSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tresourceProfile);\n+\t\t}\n+\n+\t\treturn slotFuture.thenApply(physicalSlot -> new PhysicalSlotRequest.Result(slotRequestId, physicalSlot));\n+\t}\n+\n+\tprivate Optional<PhysicalSlot> tryAllocateFromAvailable(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\n+\t\tfinal Collection<SlotSelectionStrategy.SlotInfoAndResources> slotInfoList =\n+\t\t\tslotPool.getAvailableSlotsInformation()\n+\t\t\t\t.stream()\n+\t\t\t\t.map(SlotSelectionStrategy.SlotInfoAndResources::fromSingleSlot)\n+\t\t\t\t.collect(Collectors.toList());\n+\n+\t\tfinal Optional<SlotSelectionStrategy.SlotInfoAndLocality> selectedAvailableSlot =\n+\t\t\tslotSelectionStrategy.selectBestSlotForProfile(slotInfoList, slotProfile);\n+\n+\t\treturn selectedAvailableSlot.flatMap(\n+\t\t\tslotInfoAndLocality -> slotPool.allocateAvailableSlot(\n+\t\t\t\tslotRequestId,\n+\t\t\t\tslotInfoAndLocality.getSlotInfo().getAllocationId())\n+\t\t);\n+\t}\n+\n+\tprivate void schedulePendingRequestBulkTimeoutCheck(\n+\t\t\tfinal PhysicalSlotRequestBulk slotRequestBulk,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tcomponentMainThreadExecutor.schedule(() -> {\n+\t\t\tfinal PhysicalSlotRequestBulkTracker.TimeoutCheckResult result =\n+\t\t\t\tslotRequestBulkTracker.checkPhysicalSlotRequestBulkTimeout(slotRequestBulk, timeout);\n+\n+\t\t\tswitch (result) {\n+\t\t\t\tcase PENDING:\n+\t\t\t\t\t//re-schedule the timeout check\n+\t\t\t\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase TIMEOUT:\n+\t\t\t\t\ttimeoutSlotRequestBulk(slotRequestBulk);\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault: // no action to take\n+\t\t\t}\n+\t\t}, timeout.getSize(), timeout.getUnit());\n+\t}\n+\n+\tprivate void timeoutSlotRequestBulk(final PhysicalSlotRequestBulk slotRequestBulk) {\n+\t\tfinal Exception cause = new TimeoutException(\"Slot request bulk is not fulfillable!\");\n+\t\t// pending requests must be canceled first otherwise they might be fulfilled by\n+\t\t// allocated slots released from this bulk\n+\t\tfor (SlotRequestId slotRequestId : slotRequestBulk.getPendingRequests().keySet()) {\n+\t\t\tcancelSlotRequest(slotRequestId, cause);\n+\t\t}\n+\t\tfor (SlotRequestId slotRequestId : slotRequestBulk.getFulfilledRequests().keySet()) {\n+\t\t\tcancelSlotRequest(slotRequestId, cause);\n+\t\t}\n+\t}\n+\n+\tprivate Set<SlotInfo> getAllSlotInfos() {\n+\t\treturn Stream\n+\t\t\t.concat(\n+\t\t\t\tslotPool.getAvailableSlotsInformation().stream(),\n+\t\t\t\tslotPool.getAllocatedSlotsInformation().stream())\n+\t\t\t.collect(Collectors.toSet());\n+\t}", "originalCommit": "6f8c5a2f6511c1b62f83cb3e6d05554cdcf3eb04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4MTczNQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r437981735", "bodyText": "Sorry I do not quite understand what do you mean by 'simplify multithreading'?\nCurrently we are a slotsRetriever to PhysicalSlotRequestBulkTracker. It simplifies testing and hides actions methods of SlotPool that a PhysicalSlotRequestBulkTracker should not know.\nSchedulerImpl invokes checkPhysicalSlotRequestBulkTimeout and I think it's better to let it decide how to deal with the check results. That's why I put timeoutSlotRequestBulk in SchedulerImpl.", "author": "zhuzhurk", "createdAt": "2020-06-10T09:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzOTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYwNjE4NA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438606184", "bodyText": "PhysicalSlotRequestBulkTracker does not contains actions on slot requests. All actions (allocating/canceling) take place in BulkSlotProviderImpl. I think this makes it easier to reasoning the slot request status.", "author": "zhuzhurk", "createdAt": "2020-06-11T07:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzOTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0MzYwMw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438643603", "bodyText": "I thought to separate slot request submission (BulkSlotProviderImpl) and tracking (PhysicalSlotRequestBulkTracker). On the other hand, it is easier to test the current PhysicalSlotRequestBulkTracker w/o SlotPool. Thanks for explanation.", "author": "azagrebin", "createdAt": "2020-06-11T09:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkzOTkzOQ=="}], "type": "inlineReview"}, {"oid": "a9a9a40e5fedb82c5602b84f59894d8e0ee5b679", "url": "https://github.com/apache/flink/commit/a9a9a40e5fedb82c5602b84f59894d8e0ee5b679", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks", "committedDate": "2020-06-11T01:16:31Z", "type": "forcePushed"}, {"oid": "b4e5423c675bdba622a953af780487ac2031b5a9", "url": "https://github.com/apache/flink/commit/b4e5423c675bdba622a953af780487ac2031b5a9", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks", "committedDate": "2020-06-11T03:15:59Z", "type": "forcePushed"}, {"oid": "d3f81cb67e5924bfc9d3e7bbba25af281e6b3102", "url": "https://github.com/apache/flink/commit/d3f81cb67e5924bfc9d3e7bbba25af281e6b3102", "message": "Fixup! [FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks", "committedDate": "2020-06-11T03:27:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0NzMxMQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438647311", "bodyText": "Can slotOwner be a local variable?", "author": "azagrebin", "createdAt": "2020-06-11T09:07:07Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImplTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for {@link BulkSlotProviderImpl}.\n+ */\n+public class BulkSlotProviderImplTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(1000L);\n+\n+\tprivate static ScheduledExecutorService singleThreadScheduledExecutorService;\n+\n+\tprivate static ComponentMainThreadExecutor mainThreadExecutor;\n+\n+\tprivate TestingSlotPoolImpl slotPool;\n+\n+\tprivate BulkSlotProviderImpl bulkSlotProvider;\n+\n+\tprivate TestingSlotOwner slotOwner;\n+\n+\tprivate ManualClock clock;\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\tsingleThreadScheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+\t\tmainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forSingleThreadExecutor(singleThreadScheduledExecutorService);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void teardownClass() {\n+\t\tif (singleThreadScheduledExecutorService != null) {\n+\t\t\tsingleThreadScheduledExecutorService.shutdownNow();\n+\t\t}\n+\t}\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tclock = new ManualClock();\n+\n+\t\tslotPool = new SlotPoolBuilder(mainThreadExecutor).build();\n+\n+\t\tbulkSlotProvider = new BulkSlotProviderImpl(LocationPreferenceSlotSelectionStrategy.createDefault(), slotPool);\n+\t\tbulkSlotProvider.start(mainThreadExecutor);\n+\n+\t\tslotOwner = new TestingSlotOwner();", "originalCommit": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MDUzMw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438660533", "bodyText": "It can be removed.\nIt was for creating logical slot to occupy a physical slot, but it is not needed anymore since we refactored the bulk check logic into the checker class.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0NzMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2OTExMg==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438669112", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY0NzMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDE5MA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438650190", "bodyText": "Could this be a private helper method Exception  allocateSlotsAndWaitForTimeout() to deduplicate with other tests?\nprivate Exception allocateSlotsAndWaitForTimeout() {\n\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n\t\t\tcreatePhysicalSlotRequest(),\n\t\t\tcreatePhysicalSlotRequest());\n\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n\n\t\taddSlotToSlotPool();\n\n\t\tassertThat(slotPool.getAllocatedSlots().listSlotInfo(), hasSize(1));\n\n\t\tclock.advanceTime(TIMEOUT.toMilliseconds() + 1L, TimeUnit.MILLISECONDS);\n\n\t\ttry {\n\t\t\t// wait util the requests timed out\n\t\t\tslotFutures.get();\n\t\t} catch (Exception e) {\n\t\t\t// expected\n\t\t\treturn e;\n\t\t}\n\t\tfail(\"Expected that the slot futures time out.\");\n\t\treturn new Exception(\"Unexpected\");\n\t}", "author": "azagrebin", "createdAt": "2020-06-11T09:12:29Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/BulkSlotProviderImplTest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for {@link BulkSlotProviderImpl}.\n+ */\n+public class BulkSlotProviderImplTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(1000L);\n+\n+\tprivate static ScheduledExecutorService singleThreadScheduledExecutorService;\n+\n+\tprivate static ComponentMainThreadExecutor mainThreadExecutor;\n+\n+\tprivate TestingSlotPoolImpl slotPool;\n+\n+\tprivate BulkSlotProviderImpl bulkSlotProvider;\n+\n+\tprivate TestingSlotOwner slotOwner;\n+\n+\tprivate ManualClock clock;\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\tsingleThreadScheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+\t\tmainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forSingleThreadExecutor(singleThreadScheduledExecutorService);\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void teardownClass() {\n+\t\tif (singleThreadScheduledExecutorService != null) {\n+\t\t\tsingleThreadScheduledExecutorService.shutdownNow();\n+\t\t}\n+\t}\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tclock = new ManualClock();\n+\n+\t\tslotPool = new SlotPoolBuilder(mainThreadExecutor).build();\n+\n+\t\tbulkSlotProvider = new BulkSlotProviderImpl(LocationPreferenceSlotSelectionStrategy.createDefault(), slotPool);\n+\t\tbulkSlotProvider.start(mainThreadExecutor);\n+\n+\t\tslotOwner = new TestingSlotOwner();\n+\t\tslotOwner.setReturnAllocatedSlotConsumer(\n+\t\t\tlogicalSlot ->\n+\t\t\t\tslotPool.releaseSlot(\n+\t\t\t\t\tlogicalSlot.getSlotRequestId(),\n+\t\t\t\t\tnew FlinkException(\"Slot is being returned to the SlotPool.\")));\n+\t}\n+\n+\t@After\n+\tpublic void teardown() {\n+\t\tCompletableFuture.runAsync(() -> slotPool.close(), mainThreadExecutor).join();\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkSlotAllocationFulfilledWithAvailableSlots() throws Exception {\n+\t\tfinal PhysicalSlotRequest request1 = createPhysicalSlotRequest();\n+\t\tfinal PhysicalSlotRequest request2 = createPhysicalSlotRequest();\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(request1, request2);\n+\n+\t\taddSlotToSlotPool();\n+\t\taddSlotToSlotPool();\n+\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\tfinal Collection<PhysicalSlotRequest.Result> results = slotFutures.get(TIMEOUT.getSize(), TIMEOUT.getUnit());\n+\t\tfinal Collection<SlotRequestId> resultRequestIds = results.stream()\n+\t\t\t.map(PhysicalSlotRequest.Result::getSlotRequestId)\n+\t\t\t.collect(Collectors.toList());\n+\n+\t\tassertThat(resultRequestIds, containsInAnyOrder(request1.getSlotRequestId(), request2.getSlotRequestId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkSlotAllocationFulfilledWithNewSlots() {\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n+\t\t\tcreatePhysicalSlotRequest(),\n+\t\t\tcreatePhysicalSlotRequest());\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotFutures.isDone(), is(false));\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotFutures.isDone(), is(true));\n+\t\tassertThat(slotFutures.isCompletedExceptionally(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkSlotAllocationTimeoutsIfUnfulfillable() {\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n+\t\t\tcreatePhysicalSlotRequest(),\n+\t\t\tcreatePhysicalSlotRequest());\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotPool.getAllocatedSlots().listSlotInfo(), hasSize(1));\n+\n+\t\tclock.advanceTime(TIMEOUT.toMilliseconds() + 1L, TimeUnit.MILLISECONDS);\n+\n+\t\ttry {\n+\t\t\t// wait util the requests timed out\n+\t\t\tslotFutures.get();\n+\t\t\tfail(\"Expected that the slot futures time out.\");\n+\t\t} catch (Exception e) {\n+\t\t\tfinal Optional<Throwable> cause = ExceptionUtils.findThrowableWithMessage(\n+\t\t\t\te,\n+\t\t\t\t\"Slot request bulk is not fulfillable!\");\n+\t\t\tassertThat(cause.isPresent(), is(true));\n+\t\t\tassertThat(cause.get(), instanceOf(TimeoutException.class));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testFailedBulkSlotAllocationReleasesAllocatedSlot() {\n+\t\tfinal List<PhysicalSlotRequest> requests = Arrays.asList(\n+\t\t\tcreatePhysicalSlotRequest(),\n+\t\t\tcreatePhysicalSlotRequest());\n+\t\tfinal CompletableFuture<Collection<PhysicalSlotRequest.Result>> slotFutures = allocateSlots(requests);\n+\n+\t\taddSlotToSlotPool();\n+\n+\t\tassertThat(slotPool.getAllocatedSlots().listSlotInfo(), hasSize(1));\n+\n+\t\tclock.advanceTime(TIMEOUT.toMilliseconds() + 1L, TimeUnit.MILLISECONDS);\n+\n+\t\ttry {\n+\t\t\t// wait util the requests timed out\n+\t\t\tslotFutures.get();\n+\t\t\tfail(\"Expected that the slot futures time out.\");\n+\t\t} catch (Exception e) {\n+\t\t\t// expected\n+\t\t}", "originalCommit": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2OTA0MQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438669041", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDkxOQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438650919", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Arrays.asList(request));\n          \n          \n            \n            \t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.singletonList(request));", "author": "azagrebin", "createdAt": "2020-06-11T09:13:46Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(5000L);\n+\n+\tprivate ManualClock clock = new ManualClock();\n+\n+\tprivate PhysicalSlotRequestBulkTracker bulkTracker;\n+\n+\tprivate Set<PhysicalSlot> slots;\n+\n+\tprivate Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tslots = new HashSet<>();\n+\t\tslotsRetriever = () -> slots.stream().collect(Collectors.toSet());\n+\t\tbulkTracker = new PhysicalSlotRequestBulkTracker(slotsRetriever, clock);\n+\t}\n+\n+\t@Test\n+\tpublic void testTrackBulk() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\n+\t\tbulkTracker.track(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(true));\n+\t\tassertThat(bulk.getUnfulfillableSince(), is(clock.relativeTimeMillis()));\n+\t}\n+\n+\t@Test\n+\tpublic void testUntrackBulk() {\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Collections.emptyList());\n+\n+\t\tbulkTracker.track(bulk);\n+\t\tbulkTracker.untrack(bulk);\n+\n+\t\tassertThat(bulkTracker.isTracked(bulk), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testBulkFulfilledOnCheck() {\n+\t\tfinal PhysicalSlotRequest request = createPhysicalSlotRequest();\n+\t\tfinal PhysicalSlotRequestBulk bulk = new PhysicalSlotRequestBulk(Arrays.asList(request));", "originalCommit": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MjM5Mw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438652393", "bodyText": "Also other places", "author": "azagrebin", "createdAt": "2020-06-11T09:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NDUxNw==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438664517", "bodyText": "Fine.\nI just felt this looks more aligned to other tests which create bulks with multiple requests.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2ODk5NA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438668994", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MTg2OA==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438651868", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate ManualClock clock = new ManualClock();\n          \n          \n            \n            \tprivate final ManualClock clock = new ManualClock();", "author": "azagrebin", "createdAt": "2020-06-11T09:15:34Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(5000L);\n+\n+\tprivate ManualClock clock = new ManualClock();", "originalCommit": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2ODkzNQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438668935", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MTg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MjE3MQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438652171", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tslotsRetriever = () -> slots.stream().collect(Collectors.toSet());\n          \n          \n            \n            \t\tslotsRetriever = () -> new HashSet<>(slots);", "author": "azagrebin", "createdAt": "2020-06-11T09:16:07Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTrackerTest.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.ManualClock;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link PhysicalSlotRequestBulkTracker}.\n+ */\n+public class PhysicalSlotRequestBulkTrackerTest extends TestLogger {\n+\n+\tprivate static final Time TIMEOUT = Time.milliseconds(5000L);\n+\n+\tprivate ManualClock clock = new ManualClock();\n+\n+\tprivate PhysicalSlotRequestBulkTracker bulkTracker;\n+\n+\tprivate Set<PhysicalSlot> slots;\n+\n+\tprivate Supplier<Set<SlotInfo>> slotsRetriever;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\tslots = new HashSet<>();\n+\t\tslotsRetriever = () -> slots.stream().collect(Collectors.toSet());", "originalCommit": "a8bc99f02a437f55de822d34be3f4b4a2d29b71c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2ODg5MQ==", "url": "https://github.com/apache/flink/pull/12375#discussion_r438668891", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T09:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1MjE3MQ=="}], "type": "inlineReview"}, {"oid": "d523391334dc2997456daf500db5f1ffdd96e441", "url": "https://github.com/apache/flink/commit/d523391334dc2997456daf500db5f1ffdd96e441", "message": "[hotfix] Fix checkstyle violations in AllocatedSlot", "committedDate": "2020-06-11T09:53:10Z", "type": "commit"}, {"oid": "0c61b135c655d84b7cc34f446a19bd486b4a61cf", "url": "https://github.com/apache/flink/commit/0c61b135c655d84b7cc34f446a19bd486b4a61cf", "message": "[hotfix][runtime] Set root cause to pending request released exception", "committedDate": "2020-06-11T09:53:11Z", "type": "commit"}, {"oid": "01f1e1b1e91a6be933e9dc5279c4e48cc7cce6a8", "url": "https://github.com/apache/flink/commit/01f1e1b1e91a6be933e9dc5279c4e48cc7cce6a8", "message": "[FLINK-17017][runtime] Allow to set whether a physical slot payload will occupy the slot indefinitely", "committedDate": "2020-06-11T09:53:11Z", "type": "commit"}, {"oid": "ec95b8db6f13165f72364b1798e3722875a10fe6", "url": "https://github.com/apache/flink/commit/ec95b8db6f13165f72364b1798e3722875a10fe6", "message": "[FLINK-17017][runtime] Add SingleLogicalSlot#allocateFromPhysicalSlot(\u2026) for physical slot assignment", "committedDate": "2020-06-11T09:53:11Z", "type": "commit"}, {"oid": "f2a403dd330545f874bc4e38e0968841ca08b00c", "url": "https://github.com/apache/flink/commit/f2a403dd330545f874bc4e38e0968841ca08b00c", "message": "[FLINK-17017][runtime] Enable to get whether a physical slot will be occupied indefinitely", "committedDate": "2020-06-11T09:53:11Z", "type": "commit"}, {"oid": "a1f8b757e5f186921b1358809b6d4f544ab43bb6", "url": "https://github.com/apache/flink/commit/a1f8b757e5f186921b1358809b6d4f544ab43bb6", "message": "[FLINK-17017][runtime] Enable to get allocated slots information of a slot pool", "committedDate": "2020-06-11T09:53:12Z", "type": "commit"}, {"oid": "dfafa9d4646349ffd02e51ac0d10911663831fb9", "url": "https://github.com/apache/flink/commit/dfafa9d4646349ffd02e51ac0d10911663831fb9", "message": "[FLINK-17017][runtime] Allow to disable batch slot request timeout check", "committedDate": "2020-06-11T09:53:12Z", "type": "commit"}, {"oid": "7c2a90b7f59616d93f77c973042e372e53116dd2", "url": "https://github.com/apache/flink/commit/7c2a90b7f59616d93f77c973042e372e53116dd2", "message": "[FLINK-17017][runtime] Allow nullable timeout for streaming slot request in slot pool", "committedDate": "2020-06-11T09:53:12Z", "type": "commit"}, {"oid": "c0d21d8dd0aa2dc37abc6fad0d61d6e5b5a34b17", "url": "https://github.com/apache/flink/commit/c0d21d8dd0aa2dc37abc6fad0d61d6e5b5a34b17", "message": "[FLINK-17017][runtime] Introduce BulkSlotProvider which allocates physical slots in bulks", "committedDate": "2020-06-11T09:53:12Z", "type": "commit"}, {"oid": "bdf970c21e07f96589b85949ea7b697ac5c64c36", "url": "https://github.com/apache/flink/commit/bdf970c21e07f96589b85949ea7b697ac5c64c36", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-06-11T09:53:13Z", "type": "commit"}, {"oid": "bdf970c21e07f96589b85949ea7b697ac5c64c36", "url": "https://github.com/apache/flink/commit/bdf970c21e07f96589b85949ea7b697ac5c64c36", "message": "[FLINK-17017][runtime] SchedulerImpl supports bulk slot allocation", "committedDate": "2020-06-11T09:53:13Z", "type": "forcePushed"}]}