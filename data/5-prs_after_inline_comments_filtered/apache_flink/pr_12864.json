{"pr_number": 12864, "pr_title": "[FLINK-18487][table] Datagen and Blackhole factory omits unrecognized properties silently", "pr_createdAt": "2020-07-10T06:02:23Z", "pr_url": "https://github.com/apache/flink/pull/12864", "timeline": [{"oid": "dc885404cf1343b8316b8574208a2ed9f862673e", "url": "https://github.com/apache/flink/commit/dc885404cf1343b8316b8574208a2ed9f862673e", "message": "Minor", "committedDate": "2020-07-20T03:57:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxOTA4OA==", "url": "https://github.com/apache/flink/pull/12864#discussion_r457819088", "bodyText": "make the default value a static member?", "author": "lirui-apache", "createdAt": "2020-07-21T03:48:19Z", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);\n+\n \t\tConfiguration options = new Configuration();\n \t\tcontext.getCatalogTable().getOptions().forEach(options::setString);\n \n-\t\tTableSchema tableSchema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tTableSchema schema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tDataGenerator[] fieldGenerators = new DataGenerator[schema.getFieldCount()];\n+\t\tSet<ConfigOption<?>> optionalOptions = new HashSet<>();\n \n-\t\tDataGenerator[] fieldGenerators = new DataGenerator[tableSchema.getFieldCount()];\n \t\tfor (int i = 0; i < fieldGenerators.length; i++) {\n-\t\t\tfieldGenerators[i] = createDataGenerator(\n-\t\t\t\t\ttableSchema.getFieldName(i).get(),\n-\t\t\t\t\ttableSchema.getFieldDataType(i).get(),\n-\t\t\t\t\toptions);\n+\t\t\tString name = schema.getFieldNames()[i];\n+\t\t\tDataType type = schema.getFieldDataTypes()[i];\n+\n+\t\t\tConfigOption<String> kind = key(FIELDS + \".\" + name + \".\" + KIND)\n+\t\t\t\t\t.stringType().defaultValue(RANDOM);\n+\t\t\tDataGeneratorContainer container = createContainer(name, type, options.get(kind), options);\n+\t\t\tfieldGenerators[i] = container.generator;\n+\n+\t\t\toptionalOptions.add(kind);\n+\t\t\toptionalOptions.addAll(container.options);\n \t\t}\n \n-\t\treturn new DataGenTableSource(fieldGenerators, tableSchema, options.get(ROWS_PER_SECOND));\n+\t\tFactoryUtil.validateFactoryOptions(new HashSet<>(), optionalOptions, options);\n+\n+\t\tSet<String> consumedOptionKeys = new HashSet<>();\n+\t\tconsumedOptionKeys.add(CONNECTOR.key());\n+\t\tconsumedOptionKeys.add(ROWS_PER_SECOND.key());\n+\t\toptionalOptions.stream().map(ConfigOption::key).forEach(consumedOptionKeys::add);\n+\t\tFactoryUtil.validateUnconsumedKeys(factoryIdentifier(), options.keySet(), consumedOptionKeys);\n+\n+\t\treturn new DataGenTableSource(fieldGenerators, schema, options.get(ROWS_PER_SECOND));\n \t}\n \n-\tprivate DataGenerator createDataGenerator(String name, DataType type, ReadableConfig options) {\n-\t\tString genType = options.get(\n-\t\t\t\tkey(FIELDS + \".\" + name + \".\" + KIND).stringType().defaultValue(RANDOM));\n-\t\tswitch (genType) {\n+\tprivate DataGeneratorContainer createContainer(\n+\t\t\tString name, DataType type, String kind, ReadableConfig options) {\n+\t\tswitch (kind) {\n \t\t\tcase RANDOM:\n-\t\t\t\treturn createRandomGenerator(name, type, options);\n+\t\t\t\treturn createRandomContainer(name, type, options);\n \t\t\tcase SEQUENCE:\n-\t\t\t\treturn createSequenceGenerator(name, type, options);\n+\t\t\t\treturn createSequenceContainer(name, type, options);\n \t\t\tdefault:\n-\t\t\t\tthrow new ValidationException(\"Unsupported generator type: \" + genType);\n+\t\t\t\tthrow new ValidationException(\"Unsupported generator kind: \" + kind);\n \t\t}\n \t}\n \n-\tprivate DataGenerator createRandomGenerator(String name, DataType type, ReadableConfig options) {\n-\t\tConfigOption<Integer> lenKey = key(FIELDS + \".\" + name + \".\" + LENGTH)\n-\t\t\t\t.intType().defaultValue(100);\n+\tprivate DataGeneratorContainer createRandomContainer(String name, DataType type, ReadableConfig config) {\n \t\tOptionBuilder minKey = key(FIELDS + \".\" + name + \".\" + MIN);\n \t\tOptionBuilder maxKey = key(FIELDS + \".\" + name + \".\" + MAX);\n \t\tswitch (type.getLogicalType().getTypeRoot()) {\n-\t\t\tcase BOOLEAN:\n-\t\t\t\treturn RandomGenerator.booleanGenerator();\n+\t\t\tcase BOOLEAN: {\n+\t\t\t\treturn DataGeneratorContainer.of(RandomGenerator.booleanGenerator());\n+\t\t\t}\n \t\t\tcase CHAR:\n-\t\t\tcase VARCHAR:\n-\t\t\t\tint length = options.get(lenKey);\n-\t\t\t\treturn getRandomStringGenerator(length);\n-\t\t\tcase TINYINT:\n-\t\t\t\treturn RandomGenerator.byteGenerator(\n-\t\t\t\t\t\toptions.get(minKey.intType().defaultValue((int) Byte.MIN_VALUE)).byteValue(),\n-\t\t\t\t\t\toptions.get(maxKey.intType().defaultValue((int) Byte.MAX_VALUE)).byteValue());\n-\t\t\tcase SMALLINT:\n-\t\t\t\treturn RandomGenerator.shortGenerator(\n-\t\t\t\t\t\toptions.get(minKey.intType().defaultValue((int) Short.MIN_VALUE)).shortValue(),\n-\t\t\t\t\t\toptions.get(maxKey.intType().defaultValue((int) Short.MAX_VALUE)).shortValue());\n-\t\t\tcase INTEGER:\n-\t\t\t\treturn RandomGenerator.intGenerator(\n-\t\t\t\t\t\toptions.get(minKey.intType().defaultValue(Integer.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.intType().defaultValue(Integer.MAX_VALUE)));\n-\t\t\tcase BIGINT:\n-\t\t\t\treturn RandomGenerator.longGenerator(\n-\t\t\t\t\t\toptions.get(minKey.longType().defaultValue(Long.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.longType().defaultValue(Long.MAX_VALUE)));\n-\t\t\tcase FLOAT:\n-\t\t\t\treturn RandomGenerator.floatGenerator(\n-\t\t\t\t\t\toptions.get(minKey.floatType().defaultValue(Float.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.floatType().defaultValue(Float.MAX_VALUE)));\n-\t\t\tcase DOUBLE:\n-\t\t\t\treturn RandomGenerator.doubleGenerator(\n-\t\t\t\t\t\toptions.get(minKey.doubleType().defaultValue(Double.MIN_VALUE)),\n-\t\t\t\t\t\toptions.get(maxKey.doubleType().defaultValue(Double.MAX_VALUE)));\n+\t\t\tcase VARCHAR: {\n+\t\t\t\tConfigOption<Integer> lenOption = key(FIELDS + \".\" + name + \".\" + LENGTH)\n+\t\t\t\t\t\t.intType()\n+\t\t\t\t\t\t.defaultValue(100);", "originalCommit": "dc885404cf1343b8316b8574208a2ed9f862673e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NjY5MA==", "url": "https://github.com/apache/flink/pull/12864#discussion_r457856690", "bodyText": "Call requiredOptions() instead of new HashSet<>()?", "author": "lirui-apache", "createdAt": "2020-07-21T06:04:18Z", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);\n+\n \t\tConfiguration options = new Configuration();\n \t\tcontext.getCatalogTable().getOptions().forEach(options::setString);\n \n-\t\tTableSchema tableSchema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tTableSchema schema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tDataGenerator[] fieldGenerators = new DataGenerator[schema.getFieldCount()];\n+\t\tSet<ConfigOption<?>> optionalOptions = new HashSet<>();\n \n-\t\tDataGenerator[] fieldGenerators = new DataGenerator[tableSchema.getFieldCount()];\n \t\tfor (int i = 0; i < fieldGenerators.length; i++) {\n-\t\t\tfieldGenerators[i] = createDataGenerator(\n-\t\t\t\t\ttableSchema.getFieldName(i).get(),\n-\t\t\t\t\ttableSchema.getFieldDataType(i).get(),\n-\t\t\t\t\toptions);\n+\t\t\tString name = schema.getFieldNames()[i];\n+\t\t\tDataType type = schema.getFieldDataTypes()[i];\n+\n+\t\t\tConfigOption<String> kind = key(FIELDS + \".\" + name + \".\" + KIND)\n+\t\t\t\t\t.stringType().defaultValue(RANDOM);\n+\t\t\tDataGeneratorContainer container = createContainer(name, type, options.get(kind), options);\n+\t\t\tfieldGenerators[i] = container.generator;\n+\n+\t\t\toptionalOptions.add(kind);\n+\t\t\toptionalOptions.addAll(container.options);\n \t\t}\n \n-\t\treturn new DataGenTableSource(fieldGenerators, tableSchema, options.get(ROWS_PER_SECOND));\n+\t\tFactoryUtil.validateFactoryOptions(new HashSet<>(), optionalOptions, options);", "originalCommit": "dc885404cf1343b8316b8574208a2ed9f862673e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MTY0Mg==", "url": "https://github.com/apache/flink/pull/12864#discussion_r457861642", "bodyText": "Is this necessary, given that we'll call FactoryUtil.validateFactoryOptions and FactoryUtil.validateUnconsumedKeys later on?", "author": "lirui-apache", "createdAt": "2020-07-21T06:18:39Z", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);", "originalCommit": "dc885404cf1343b8316b8574208a2ed9f862673e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyNjU1Ng==", "url": "https://github.com/apache/flink/pull/12864#discussion_r459326556", "bodyText": "Yes, No necessary.", "author": "JingsongLi", "createdAt": "2020-07-23T09:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MjM2Nw==", "url": "https://github.com/apache/flink/pull/12864#discussion_r457862367", "bodyText": "Do we also need to add PROPERTY_VERSION to consumedOptionKeys?", "author": "lirui-apache", "createdAt": "2020-07-21T06:20:31Z", "path": "flink-table/flink-table-api-java-bridge/src/main/java/org/apache/flink/table/factories/DataGenTableSourceFactory.java", "diffHunk": "@@ -94,128 +97,176 @@ public String factoryIdentifier() {\n \n \t@Override\n \tpublic DynamicTableSource createDynamicTableSource(Context context) {\n+\t\tcreateTableFactoryHelper(this, context).validateExcept(FIELDS);\n+\n \t\tConfiguration options = new Configuration();\n \t\tcontext.getCatalogTable().getOptions().forEach(options::setString);\n \n-\t\tTableSchema tableSchema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tTableSchema schema = TableSchemaUtils.getPhysicalSchema(context.getCatalogTable().getSchema());\n+\t\tDataGenerator[] fieldGenerators = new DataGenerator[schema.getFieldCount()];\n+\t\tSet<ConfigOption<?>> optionalOptions = new HashSet<>();\n \n-\t\tDataGenerator[] fieldGenerators = new DataGenerator[tableSchema.getFieldCount()];\n \t\tfor (int i = 0; i < fieldGenerators.length; i++) {\n-\t\t\tfieldGenerators[i] = createDataGenerator(\n-\t\t\t\t\ttableSchema.getFieldName(i).get(),\n-\t\t\t\t\ttableSchema.getFieldDataType(i).get(),\n-\t\t\t\t\toptions);\n+\t\t\tString name = schema.getFieldNames()[i];\n+\t\t\tDataType type = schema.getFieldDataTypes()[i];\n+\n+\t\t\tConfigOption<String> kind = key(FIELDS + \".\" + name + \".\" + KIND)\n+\t\t\t\t\t.stringType().defaultValue(RANDOM);\n+\t\t\tDataGeneratorContainer container = createContainer(name, type, options.get(kind), options);\n+\t\t\tfieldGenerators[i] = container.generator;\n+\n+\t\t\toptionalOptions.add(kind);\n+\t\t\toptionalOptions.addAll(container.options);\n \t\t}\n \n-\t\treturn new DataGenTableSource(fieldGenerators, tableSchema, options.get(ROWS_PER_SECOND));\n+\t\tFactoryUtil.validateFactoryOptions(new HashSet<>(), optionalOptions, options);\n+\n+\t\tSet<String> consumedOptionKeys = new HashSet<>();\n+\t\tconsumedOptionKeys.add(CONNECTOR.key());\n+\t\tconsumedOptionKeys.add(ROWS_PER_SECOND.key());", "originalCommit": "dc885404cf1343b8316b8574208a2ed9f862673e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyNjQyNQ==", "url": "https://github.com/apache/flink/pull/12864#discussion_r459326425", "bodyText": "No need. We don't have another version.", "author": "JingsongLi", "createdAt": "2020-07-23T09:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg2MjM2Nw=="}], "type": "inlineReview"}, {"oid": "8f18217e8a2134a571e890220bf6e98d82cc82b9", "url": "https://github.com/apache/flink/commit/8f18217e8a2134a571e890220bf6e98d82cc82b9", "message": "[FLINK-18487][table] Datagen and Blackhole factory omits unrecognized properties silently", "committedDate": "2020-07-23T09:27:52Z", "type": "commit"}, {"oid": "c62a9848c6ccb44cd084a75af78fcd049e6c3950", "url": "https://github.com/apache/flink/commit/c62a9848c6ccb44cd084a75af78fcd049e6c3950", "message": "Minor", "committedDate": "2020-07-23T09:27:52Z", "type": "commit"}, {"oid": "35741991260d790492bc338e11ef0d4912b6484d", "url": "https://github.com/apache/flink/commit/35741991260d790492bc338e11ef0d4912b6484d", "message": "Minor", "committedDate": "2020-07-23T09:27:52Z", "type": "commit"}, {"oid": "88f7eacc4536eecfd7149cceab463597682945fb", "url": "https://github.com/apache/flink/commit/88f7eacc4536eecfd7149cceab463597682945fb", "message": "Fix comments", "committedDate": "2020-07-23T09:35:18Z", "type": "commit"}, {"oid": "88f7eacc4536eecfd7149cceab463597682945fb", "url": "https://github.com/apache/flink/commit/88f7eacc4536eecfd7149cceab463597682945fb", "message": "Fix comments", "committedDate": "2020-07-23T09:35:18Z", "type": "forcePushed"}]}