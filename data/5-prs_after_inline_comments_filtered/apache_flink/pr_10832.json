{"pr_number": 10832, "pr_title": "[FLINK-14163][runtime]Enforce synchronous registration of Execution#producedPartitions", "pr_createdAt": "2020-01-11T03:20:28Z", "pr_url": "https://github.com/apache/flink/pull/10832", "timeline": [{"oid": "5eb1599945f1bee35c342f762cc25684013d2d83", "url": "https://github.com/apache/flink/commit/5eb1599945f1bee35c342f762cc25684013d2d83", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, hence this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-11T03:26:36Z", "type": "forcePushed"}, {"oid": "73579bbc6b556fe42e55e21581c5994f84480843", "url": "https://github.com/apache/flink/commit/73579bbc6b556fe42e55e21581c5994f84480843", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-12T01:51:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMDM1MA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365720350", "bodyText": "We are trying to get rid of Mockito in flink tests.\nIf we are touching this part, I'd prefer to introduce a mock ExecutionEdge class for this purpose.", "author": "zhuzhurk", "createdAt": "2020-01-13T10:02:22Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java", "diffHunk": "@@ -431,6 +433,18 @@ public static ExecutionJobVertex getExecutionVertex(JobVertexID id) throws Excep\n \t\treturn getExecutionVertex(id, new DirectScheduledExecutorService());\n \t}\n \n+\tpublic static ExecutionEdge createMockExecutionEdge(int maxParallelism) {", "originalCommit": "73579bbc6b556fe42e55e21581c5994f84480843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0OTg2MQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365749861", "bodyText": "This is reused from ExecutionVertexDeploymentTest.\nLet me have a try to see whether I can avoid Mockito and at the same time not to make the code too complicated.", "author": "curcur", "createdAt": "2020-01-13T11:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMDM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjIxNDk5NA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366214994", "bodyText": "Removed Mockito.", "author": "curcur", "createdAt": "2020-01-14T08:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMTE4NQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365721185", "bodyText": "I'd prefer to state that \"one must return a completed future at the moment\". It is clear enough so the user do need to refer to NettyShuffleMaster for the implementation.", "author": "zhuzhurk", "createdAt": "2020-01-13T10:04:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/ShuffleMaster.java", "diffHunk": "@@ -31,6 +31,10 @@\n \t/**\n \t * Asynchronously register a partition and its producer with the shuffle service.\n \t *\n+\t * <p>IMPORTANT: Please implement the asynchronous interface in a synchronous way.\n+\t * The default scheduler only supports synchronous registration for now.\n+\t * Please refer to {@link NettyShuffleMaster#registerPartitionWithProducer} for example.", "originalCommit": "73579bbc6b556fe42e55e21581c5994f84480843", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMzYxMA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365723610", "bodyText": "This is a temporary fix. So we'd better have a TODO here as a reminder for follow up fixes.", "author": "zhuzhurk", "createdAt": "2020-01-13T10:09:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.\n+\t *\n+\t * <p>{@link Execution#producedPartitions} are registered through an asynchronous interface\n+\t * {@link ShuffleMaster#registerPartitionWithProducer} to {@link ShuffleMaster}, however they are not always\n+\t * accessed through callbacks. So, it is possible that {@link Execution#producedPartitions}\n+\t * have not been available yet when accessed (in {@link Execution#deploy} for example).\n+\t *\n+\t * <p>Since the only implementation of {@link ShuffleMaster} is {@link NettyShuffleMaster},\n+\t * which indeed registers producedPartition in a synchronous way, hence this method enforces\n+\t * synchronous registration under an asynchronous interface for now.\n+\t *\n+\t * <p>If asynchronous registration is needed in the future, use callbacks to access {@link Execution#producedPartitions}.", "originalCommit": "73579bbc6b556fe42e55e21581c5994f84480843", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTUzNw==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365729537", "bodyText": "Could we extend ExecutionGraphTestUtils#getExecutionVertex(...) to customize shuffleMaster and reuse it?", "author": "zhuzhurk", "createdAt": "2020-01-13T10:23:10Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +557,65 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tExecutionJobVertex jobVertex = getExecutionVertex(\n+\t\t\t\tnew JobVertexID(),\n+\t\t\t\tnew DirectScheduledExecutorService(),\n+\t\t\t\tEAGER);\n+\t\tIntermediateResult result =\n+\t\t\t\tnew IntermediateResult(new IntermediateDataSetID(), jobVertex, 1, ResultPartitionType.PIPELINED);\n+\t\tExecutionVertex vertex =\n+\t\t\t\tnew ExecutionVertex(jobVertex, 0, new IntermediateResult[]{result}, Time.minutes(1));\n+\t\tExecutionEdge edge = createMockExecutionEdge(1);\n+\t\tresult.getPartitions()[0].addConsumerGroup();\n+\t\tresult.getPartitions()[0].addConsumer(edge, 0);\n+\t\tTaskManagerLocation location =\n+\t\t\t\tnew TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 1);\n+\t\tExecutionAttemptID attemptID = new ExecutionAttemptID();\n+\t\tExecution.registerProducedPartitions(vertex, location, attemptID, EAGER.allowLazyDeployment());\n+\t}\n+\n+\t@Nonnull\n+\tprivate ExecutionJobVertex getExecutionVertex(", "originalCommit": "73579bbc6b556fe42e55e21581c5994f84480843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NTc1NA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365745754", "bodyText": "that's a good idea, will do it.", "author": "curcur", "createdAt": "2020-01-13T11:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMjAyMA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365732020", "bodyText": "Are these lines necessary?", "author": "zhuzhurk", "createdAt": "2020-01-13T10:28:56Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +557,65 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tExecutionJobVertex jobVertex = getExecutionVertex(\n+\t\t\t\tnew JobVertexID(),\n+\t\t\t\tnew DirectScheduledExecutorService(),\n+\t\t\t\tEAGER);\n+\t\tIntermediateResult result =\n+\t\t\t\tnew IntermediateResult(new IntermediateDataSetID(), jobVertex, 1, ResultPartitionType.PIPELINED);\n+\t\tExecutionVertex vertex =\n+\t\t\t\tnew ExecutionVertex(jobVertex, 0, new IntermediateResult[]{result}, Time.minutes(1));\n+\t\tExecutionEdge edge = createMockExecutionEdge(1);\n+\t\tresult.getPartitions()[0].addConsumerGroup();\n+\t\tresult.getPartitions()[0].addConsumer(edge, 0);", "originalCommit": "73579bbc6b556fe42e55e21581c5994f84480843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NTE4Mg==", "url": "https://github.com/apache/flink/pull/10832#discussion_r365745182", "bodyText": "Yep, this part is needed, there has to be one consumer.", "author": "curcur", "createdAt": "2020-01-13T10:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMjAyMA=="}], "type": "inlineReview"}, {"oid": "e303d84258f1e63edd45867f6c4e89e181307ee5", "url": "https://github.com/apache/flink/commit/e303d84258f1e63edd45867f6c4e89e181307ee5", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-14T09:38:21Z", "type": "forcePushed"}, {"oid": "426112c59a86ec127040178efda1085231f1988f", "url": "https://github.com/apache/flink/commit/426112c59a86ec127040178efda1085231f1988f", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-14T12:41:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MTQwNQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366681405", "bodyText": "I know that ExecutionGraphTestUtils did have several getExecutionVertex (...) methods to map JobVertexID to ExecutionJobVertex , but I think it's better we rename the old and newly added ones to getExecutionJobVertex (...). Because ExecutionVertex is a structure different from ExecutionJobVertex.", "author": "zhuzhurk", "createdAt": "2020-01-15T03:26:53Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java", "diffHunk": "@@ -398,6 +401,10 @@ public static JobVertex createJobVertex(String task1, int numTasks, Class<NoOpIn\n \t\treturn groupVertex;\n \t}\n \n+\tpublic static ExecutionJobVertex getExecutionVertex(JobVertexID id) throws Exception {", "originalCommit": "426112c59a86ec127040178efda1085231f1988f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MzI2OA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366683268", "bodyText": "Yeah, I think that a good idea to make the naming consistent.\nHowever, there might be too many places to change, and might be good to open a separate (hot fix) PR for this purpose.", "author": "curcur", "createdAt": "2020-01-15T03:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4NTE0NQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366685145", "bodyText": "I did a try and seems the change is not that large.\nI'm fine you keep it as is for now since it is out of the scope of this PR. I can apply a patch to rename it later.", "author": "zhuzhurk", "createdAt": "2020-01-15T03:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MTQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MTU3MA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366681570", "bodyText": "One indentation from the initial line is expected here.", "author": "zhuzhurk", "createdAt": "2020-01-15T03:28:05Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionGraphTestUtils.java", "diffHunk": "@@ -416,20 +431,17 @@ public static ExecutionJobVertex getExecutionVertex(\n \t\tjobGraph.setScheduleMode(scheduleMode);\n \n \t\tExecutionGraph graph = TestingExecutionGraphBuilder\n-\t\t\t.newBuilder()\n-\t\t\t.setJobGraph(jobGraph)\n-\t\t\t.setIoExecutor(executor)\n-\t\t\t.setFutureExecutor(executor)\n-\t\t\t.build();\n+\t\t\t\t.newBuilder()", "originalCommit": "426112c59a86ec127040178efda1085231f1988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY4MjA4OQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366682089", "bodyText": "This is not a must, but I'd still suggest to try to mark the variables final if possible, like we do in other parts in this test class.", "author": "zhuzhurk", "createdAt": "2020-01-15T03:31:03Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +553,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tScheduledExecutorService executor = new DirectScheduledExecutorService();", "originalCommit": "426112c59a86ec127040178efda1085231f1988f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fe731e4a039fba606be83a9535841c157a048d58", "url": "https://github.com/apache/flink/commit/fe731e4a039fba606be83a9535841c157a048d58", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-15T05:52:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjczNDY4Nw==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366734687", "bodyText": "I think we should create an ExecutionGraph and get the vertices from it rather than using this getExecutionVertex(...) to create vertices. Otherwise these 2 vertices are actually from 2 different ExecutionGraphs.\nIn this way you do not need to create edges manually. You can leverage TestingExecutionGraphBuilder to build an ExecutionGraph and set the wanted shuffle master.", "author": "zhuzhurk", "createdAt": "2020-01-15T07:57:39Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +553,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tfinal ScheduledExecutorService executor = new DirectScheduledExecutorService();\n+\t\tfinal ShuffleMaster<ShuffleDescriptor> shuffleMaster = new TestingShuffleMaster();\n+\n+\t\tfinal ExecutionJobVertex sourceJobVertex = getExecutionVertex(new JobVertexID(), executor, EAGER, shuffleMaster);", "originalCommit": "fe731e4a039fba606be83a9535841c157a048d58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgzMDE3NQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366830175", "bodyText": "I am kind of thinking it is an overkill to use the TestingExecutionGraphBuilder, which translate a JobGraph -> ExecutionGraph.\nIn this particular case, I need to test two ExecutionVertex with one having partition registered and verify if the registration is done in an asynchronous way, throw an exception otherwise. It is not testing the entire workflow, so whether to construct a complete graph does not matter that much.\nMore specifically, I need to retain the topological relationship between source and target for ExecutionVertex. But in an ExecutionGraph, I only have access to ExecutionVertex through Iterable<ExecutionVertex> getAllExecutionVertices(). Then I have to reconstruct the topological relation.\nDown to code level, by using TestingExecutionGraphBuilder, which builds ExecutionGraph from JobGraph similar like this:\n  JobGraph jobGraph = new JobGraph(\"The graph\");\n  JobVertex source = new JobVertex(\"source\");\n  JobVertex target = new JobVertex(\"target\");\n  target.connectNewDataSetAsInput(source, POINTWISE, PIPELINED);\n  jobGraph.addVertex(source);\n  jobGraph.addVertex(target);\n  ExecutionGraph eg = TestingExecutionGraphBuilder\n    .newBuilder()\n    .setJobGraph(jobGraph)\n    .setShuffleMaster(shuffleMaster)\n    .build();\n\nThen I have to identify which one is the source and which one is the target, and register with responding Execution.\nThe previous implementation looks more clean to me. What do you think? Or you have a better way to do this.\n\nI think we should create an ExecutionGraph and get the vertices from it rather than using this getExecutionVertex(...) to create vertices. Otherwise these 2 vertices are actually from 2 different ExecutionGraphs.\nIn this way you do not need to create edges manually. You can leverage TestingExecutionGraphBuilder to build an ExecutionGraph and set the wanted shuffle master.", "author": "curcur", "createdAt": "2020-01-15T11:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjczNDY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NDA5Nw==", "url": "https://github.com/apache/flink/pull/10832#discussion_r366844097", "bodyText": "Currently we we have no other way to create an ExecutionVertex without creating an ExecutionGraph. So even if you use ExecutionGraphTestUtils#getExecutionVertex(...), it still creates an ExecutionGraph for each vertex to achieve the goal, which is tricky that we are operating vertices on 2 different graphs and connect them with edges.", "author": "zhuzhurk", "createdAt": "2020-01-15T12:14:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjczNDY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyMzI4Mg==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367223282", "bodyText": "synced up offline and resolved.", "author": "curcur", "createdAt": "2020-01-16T04:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjczNDY4Nw=="}], "type": "inlineReview"}, {"oid": "1278b4488cb8bc05addaf359458ed4bae6c1967b", "url": "https://github.com/apache/flink/commit/1278b4488cb8bc05addaf359458ed4bae6c1967b", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-16T04:13:02Z", "type": "forcePushed"}, {"oid": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "url": "https://github.com/apache/flink/commit/3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-16T05:22:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2NjIzOA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367466238", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n          \n          \n            \n            \t * Tests that we reject incompleted futures returned by {@link ShuffleMaster#registerPartitionWithProducer...}.", "author": "zentol", "createdAt": "2020-01-16T15:00:55Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2NzU1Nw==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367467557", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n          \n          \n            \n            \tpublic void testIncompletePartitionRegistrationFutureIsRejected() throws Exception {", "author": "zentol", "createdAt": "2020-01-16T15:03:12Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2ODY5OQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367468699", "bodyText": "I prefer try/catch blocks since they guarantee the exception occurs where we want it to.", "author": "zentol", "createdAt": "2020-01-16T15:05:08Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc4Mzk2OQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367783969", "bodyText": "by try/catch\nI guess you mean something like this?\nboolean incompletePartitionRegistrationFuture = false;\ntry {\n\tExecution.registerProducedPartitions(sourceVertex, new LocalTaskManagerLocation(), new ExecutionAttemptID(), false);\n} catch (IllegalStateException e) {\n\tincompletePartitionRegistrationFuture = true;\n}\n\nassertTrue(incompletePartitionRegistrationFuture);", "author": "curcur", "createdAt": "2020-01-17T06:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2ODY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4OTk1NQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367889955", "bodyText": "try {\n\tExecution.registerProducedPartitions(sourceVertex, new LocalTaskManagerLocation(), new ExecutionAttemptID(), false);\n\tAssert.fail(\"expected exception\");\n} catch (IllegalStateException e) {\n\t// expected\n}", "author": "zentol", "createdAt": "2020-01-17T11:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2ODY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4ODY0NQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r368188645", "bodyText": "I see, thanks!", "author": "curcur", "createdAt": "2020-01-18T00:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ2ODY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MTcyNg==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367471726", "bodyText": "use LocalTaskManagerLocation instead", "author": "zentol", "createdAt": "2020-01-16T15:10:09Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tfinal ShuffleMaster<ShuffleDescriptor> shuffleMaster = new TestingShuffleMaster();\n+\t\tfinal JobGraph jobGraph = new JobGraph(\"job graph\");\n+\t\tfinal JobVertex source = new JobVertex(\"source\");\n+\t\tfinal JobVertex target = new JobVertex(\"target\");\n+\n+\t\tsource.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.connectNewDataSetAsInput(source, POINTWISE, PIPELINED);\n+\t\tjobGraph.addVertex(source);\n+\t\tjobGraph.addVertex(target);\n+\t\tExecutionGraph executionGraph = TestingExecutionGraphBuilder\n+\t\t\t.newBuilder()\n+\t\t\t.setJobGraph(jobGraph)\n+\t\t\t.setShuffleMaster(shuffleMaster)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionVertex sourceVertex = executionGraph.getAllVertices().get(source.getID()).getTaskVertices()[0];\n+\t\tfinal TaskManagerLocation location =\n+\t\t\tnew TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 1);", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3Mjg0Nw==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367472847", "bodyText": "Pretty roundabout way of defining the deployment mode; is it even relevant for this test?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tExecution.registerProducedPartitions(sourceVertex, location, attemptID, EAGER.allowLazyDeployment());\n          \n          \n            \n            \t\tExecution.registerProducedPartitions(sourceVertex, new LocalTaskManagerLocation(), new ExecutionAttemptID(), false);", "author": "zentol", "createdAt": "2020-01-16T15:11:52Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/executiongraph/ExecutionTest.java", "diffHunk": "@@ -540,6 +551,46 @@ public void testSlotReleaseAtomicallyReleasesExecution() throws Exception {\n \t\t});\n \t}\n \n+\t/**\n+\t * Tests that producedPartitions are registered synchronously under an asynchronous interface.\n+\t */\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testSynchronousRegisterProducedPartitions() throws Exception {\n+\t\tfinal ShuffleMaster<ShuffleDescriptor> shuffleMaster = new TestingShuffleMaster();\n+\t\tfinal JobGraph jobGraph = new JobGraph(\"job graph\");\n+\t\tfinal JobVertex source = new JobVertex(\"source\");\n+\t\tfinal JobVertex target = new JobVertex(\"target\");\n+\n+\t\tsource.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.setInvokableClass(AbstractInvokable.class);\n+\t\ttarget.connectNewDataSetAsInput(source, POINTWISE, PIPELINED);\n+\t\tjobGraph.addVertex(source);\n+\t\tjobGraph.addVertex(target);\n+\t\tExecutionGraph executionGraph = TestingExecutionGraphBuilder\n+\t\t\t.newBuilder()\n+\t\t\t.setJobGraph(jobGraph)\n+\t\t\t.setShuffleMaster(shuffleMaster)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionVertex sourceVertex = executionGraph.getAllVertices().get(source.getID()).getTaskVertices()[0];\n+\t\tfinal TaskManagerLocation location =\n+\t\t\tnew TaskManagerLocation(ResourceID.generate(), InetAddress.getLoopbackAddress(), 1);\n+\t\tfinal ExecutionAttemptID attemptID = new ExecutionAttemptID();\n+\t\tExecution.registerProducedPartitions(sourceVertex, location, attemptID, EAGER.allowLazyDeployment());", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MzE5MA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367473190", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * is done immediately.\n          \n          \n            \n            \t * is completed immediately.", "author": "zentol", "createdAt": "2020-01-16T15:12:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MzQxOQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367473419", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * which indeed registers producedPartition in a synchronous way, hence this method enforces\n          \n          \n            \n            \t * which indeed registers producedPartition in a synchronous way, this method enforces", "author": "zentol", "createdAt": "2020-01-16T15:12:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.\n+\t *\n+\t * <p>{@link Execution#producedPartitions} are registered through an asynchronous interface\n+\t * {@link ShuffleMaster#registerPartitionWithProducer} to {@link ShuffleMaster}, however they are not always\n+\t * accessed through callbacks. So, it is possible that {@link Execution#producedPartitions}\n+\t * have not been available yet when accessed (in {@link Execution#deploy} for example).\n+\t *\n+\t * <p>Since the only implementation of {@link ShuffleMaster} is {@link NettyShuffleMaster},\n+\t * which indeed registers producedPartition in a synchronous way, hence this method enforces", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1OTgxMA==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367759810", "bodyText": "good catch :-)", "author": "curcur", "createdAt": "2020-01-17T03:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3MzQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NDMyMw==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367474323", "bodyText": "Replace block with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p>IMPORTANT: Please implement the asynchronous interface in a synchronous way.\n          \n          \n            \n            \t * <p>IMPORTANT: The returned future must be completed due to limitations in the current scheduler.", "author": "zentol", "createdAt": "2020-01-16T15:14:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/ShuffleMaster.java", "diffHunk": "@@ -31,6 +31,10 @@\n \t/**\n \t * Asynchronously register a partition and its producer with the shuffle service.\n \t *\n+\t * <p>IMPORTANT: Please implement the asynchronous interface in a synchronous way.", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NDc3Mg==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367474772", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tPreconditions.checkState(shuffleDescriptorFuture.isDone(), \"ProducedPartitions are expected to be registered and accessible\");\n          \n          \n            \n            \t\t\tPreconditions.checkState(shuffleDescriptorFuture.isDone(), \"ShuffleDescriptor future was incomplete.\");", "author": "zentol", "createdAt": "2020-01-16T15:15:04Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -626,6 +647,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t\t.getShuffleMaster()\n \t\t\t\t.registerPartitionWithProducer(partitionDescriptor, producerDescriptor);\n \n+\t\t\tPreconditions.checkState(shuffleDescriptorFuture.isDone(), \"ProducedPartitions are expected to be registered and accessible\");", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NTQ5OQ==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367475499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return a CompletableFuture for registered producedPartitions. In the current version, the CompletableFuture has already completed.\n          \n          \n            \n            \t * @return a completed future of partition deployment descriptors", "author": "zentol", "createdAt": "2020-01-16T15:16:22Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -605,6 +606,26 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t});\n \t}\n \n+\t/**\n+\t * Register producedPartitions to {@link ShuffleMaster}\n+\t *\n+\t * <p>HACK: Please notice that this method simulates asynchronous registration in a synchronous way\n+\t * by making sure the returned {@link CompletableFuture} from {@link ShuffleMaster#registerPartitionWithProducer}\n+\t * is done immediately.\n+\t *\n+\t * <p>{@link Execution#producedPartitions} are registered through an asynchronous interface\n+\t * {@link ShuffleMaster#registerPartitionWithProducer} to {@link ShuffleMaster}, however they are not always\n+\t * accessed through callbacks. So, it is possible that {@link Execution#producedPartitions}\n+\t * have not been available yet when accessed (in {@link Execution#deploy} for example).\n+\t *\n+\t * <p>Since the only implementation of {@link ShuffleMaster} is {@link NettyShuffleMaster},\n+\t * which indeed registers producedPartition in a synchronous way, hence this method enforces\n+\t * synchronous registration under an asynchronous interface for now.\n+\t *\n+\t * <p>TODO: If asynchronous registration is needed in the future, use callbacks to access {@link Execution#producedPartitions}.\n+\t *\n+\t * @return a CompletableFuture for registered producedPartitions. In the current version, the CompletableFuture has already completed.", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ3NjQzMg==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367476432", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            \t\t\t// temporary hack; the scheduler does not handle incomplete futures properly", "author": "zentol", "createdAt": "2020-01-16T15:17:59Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -626,6 +647,8 @@ public void setInitialState(@Nullable JobManagerTaskRestore taskRestore) {\n \t\t\t\t.getShuffleMaster()\n \t\t\t\t.registerPartitionWithProducer(partitionDescriptor, producerDescriptor);\n ", "originalCommit": "3eba7e89df2c0b5ad6ba098aaabbab42be37df2f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66afb2a54d5da715b3d59bdf58a4de12af833c2f", "url": "https://github.com/apache/flink/commit/66afb2a54d5da715b3d59bdf58a4de12af833c2f", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-17T06:21:16Z", "type": "forcePushed"}, {"oid": "f2d45fd25663092d9a11e0798900fb886ed46ba3", "url": "https://github.com/apache/flink/commit/f2d45fd25663092d9a11e0798900fb886ed46ba3", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-17T06:31:37Z", "type": "forcePushed"}, {"oid": "65dacfec0ce1dd50c778865b9a91c7b2d2268eb6", "url": "https://github.com/apache/flink/commit/65dacfec0ce1dd50c778865b9a91c7b2d2268eb6", "message": "[FLINK-14163][runtime]Enforce synchronous registration of producedPartitions\n\n`Execution#producedPartitions` are registered through an asynchronous interface `ShuffleMaster#registerPartitionWithProducer` to `ShuffleMaster`, however they are not always accessed through callbacks. So, it is possible that `Execution#producedPartitions` have not been available yet when accessed (in `Execution#deploy` for example). Since the only implementation of `ShuffleMaster` is `NettyShuffleMaster`, which indeed registers producedPartition in a synchronous way, this PR enforces synchronous registrations under an asynchronous interface as a temporary fix to prevent future misuses.", "committedDate": "2020-01-17T07:33:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MTY5Nw==", "url": "https://github.com/apache/flink/pull/10832#discussion_r367891697", "bodyText": "This line and the one below effectively do not provide any new information; I'd remove them.", "author": "zentol", "createdAt": "2020-01-17T11:29:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/shuffle/ShuffleMaster.java", "diffHunk": "@@ -31,6 +31,10 @@\n \t/**\n \t * Asynchronously register a partition and its producer with the shuffle service.\n \t *\n+\t * <p>IMPORTANT: the returned future must be completed due to limitations in the default scheduler.\n+\t * The default scheduler only supports synchronous registration at the moment.", "originalCommit": "65dacfec0ce1dd50c778865b9a91c7b2d2268eb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "url": "https://github.com/apache/flink/commit/ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "message": "[FLINK-14163][runtime] Enforce synchronous registration of produced partitions", "committedDate": "2020-01-17T14:32:27Z", "type": "commit"}, {"oid": "ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "url": "https://github.com/apache/flink/commit/ab4a3a3101c8b97cec25f7b241bd7024f3cc177a", "message": "[FLINK-14163][runtime] Enforce synchronous registration of produced partitions", "committedDate": "2020-01-17T14:32:27Z", "type": "forcePushed"}]}