{"pr_number": 12004, "pr_title": "[FLINK-17434][core][hive] Hive partitioned source support streaming read", "pr_createdAt": "2020-05-06T04:55:15Z", "pr_url": "https://github.com/apache/flink/pull/12004", "timeline": [{"oid": "b58f7edc422cb37d1fdbd2f0c7cee9bbc7b391fd", "url": "https://github.com/apache/flink/commit/b58f7edc422cb37d1fdbd2f0c7cee9bbc7b391fd", "message": "[FLINK-17434][hive] Hive partitioned source support streaming read", "committedDate": "2020-05-06T06:23:00Z", "type": "forcePushed"}, {"oid": "a9a2c659b1693752361aaf3cf6f67e8251032983", "url": "https://github.com/apache/flink/commit/a9a2c659b1693752361aaf3cf6f67e8251032983", "message": "[FLINK-17434][hive] Hive partitioned source support streaming read", "committedDate": "2020-05-06T06:47:21Z", "type": "forcePushed"}, {"oid": "4223a26640c7243a61135e803aa1dd21888114a5", "url": "https://github.com/apache/flink/commit/4223a26640c7243a61135e803aa1dd21888114a5", "message": "[FLINK-17434][hive] Hive partitioned source support streaming read", "committedDate": "2020-05-06T07:55:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc0MjIzMQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r420742231", "bodyText": "I think these properties are user-facing right? Need to add descriptions for them.", "author": "lirui-apache", "createdAt": "2020-05-06T12:13:33Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/HiveOptions.java", "diffHunk": "@@ -45,4 +47,34 @@\n \t\t\tkey(\"table.exec.hive.infer-source-parallelism.max\")\n \t\t\t\t\t.defaultValue(1000)\n \t\t\t\t\t.withDescription(\"Sets max infer parallelism for source operator.\");\n+\n+\tpublic static final ConfigOption<Boolean> HIVE_STREAMING_SOURCE_ENABLE =\n+\t\t\tkey(\"hive.streaming-source.enable\")\n+\t\t\t\t\t.booleanType()\n+\t\t\t\t\t.defaultValue(false)\n+\t\t\t\t\t.withDescription(\"\");", "originalCommit": "4223a26640c7243a61135e803aa1dd21888114a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4MDQyMw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r420780423", "bodyText": "Need to close the HMS client somewhere.", "author": "lirui-apache", "createdAt": "2020-05-06T13:15:28Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.connectors.hive.read.PartitionStrategy.PartitionStrategyFactory;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * This is the single (non-parallel) monitoring task which takes a {@link HiveTableInputFormat},\n+ * it is responsible for:\n+ *\n+ * <ol>\n+ *     <li>Monitoring partitions of hive meta store.</li>\n+ *     <li>Deciding which partitions should be further read and processed.</li>\n+ *     <li>Creating the {@link HiveTableInputSplit splits} corresponding to those partitions.</li>\n+ *     <li>Assigning them to downstream tasks for further processing.</li>\n+ * </ol>\n+ *\n+ * <p>The splits to be read are forwarded to the downstream {@link ContinuousFileReaderOperator}\n+ * which can have parallelism greater than one.\n+ *\n+ * <p><b>IMPORTANT NOTE: </b> Splits are forwarded downstream for reading in ascending partition time order,\n+ * based on the partition time of the partitions they belong to.\n+ */\n+public class HiveContinuousMonitoringFunction\n+\t\textends RichSourceFunction<TimestampedHiveInputSplit>\n+\t\timplements CheckpointedFunction {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(HiveContinuousMonitoringFunction.class);\n+\n+\t/** The parallelism of the downstream readers. */\n+\tprivate final int readerParallelism;\n+\n+\t/** The interval between consecutive path scans. */\n+\tprivate final long interval;\n+\n+\tprivate final HiveShim hiveShim;\n+\n+\tprivate final JobConfWrapper conf;\n+\n+\tprivate final ObjectPath tablePath;\n+\n+\tprivate final List<String> partitionKeys;\n+\n+\tprivate final String[] fieldNames;\n+\n+\tprivate final DataType[] fieldTypes;\n+\n+\tprivate final long startupTimestampMillis;\n+\n+\tprivate final PartitionStrategyFactory partStrategyFactory;\n+\n+\tprivate volatile boolean isRunning = true;\n+\n+\t/** The maximum partition read time seen so far. */\n+\tprivate volatile long currentReadTime;\n+\n+\tprivate transient PartitionStrategy strategy;\n+\n+\tprivate transient Object checkpointLock;\n+\n+\tprivate transient ListState<Long> currReadTimeState;\n+\n+\tprivate transient ListState<List<List<String>>> distinctPartsState;\n+\n+\tprivate transient IMetaStoreClient client;\n+\n+\tprivate transient Properties tableProps;\n+\n+\tprivate transient String defaultPartitionName;\n+\n+\tprivate transient Set<List<String>> distinctPartitions;\n+\n+\tpublic HiveContinuousMonitoringFunction(\n+\t\t\tHiveShim hiveShim,\n+\t\t\tJobConf conf,\n+\t\t\tObjectPath tablePath,\n+\t\t\tCatalogTable catalogTable,\n+\t\t\tlong startupTimestampMillis,\n+\t\t\tPartitionStrategyFactory partStrategyFactory,\n+\t\t\tint readerParallelism,\n+\t\t\tlong interval) {\n+\t\tthis.hiveShim = hiveShim;\n+\t\tthis.conf = new JobConfWrapper(conf);\n+\t\tthis.tablePath = tablePath;\n+\t\tthis.partitionKeys = catalogTable.getPartitionKeys();\n+\t\tthis.fieldNames = catalogTable.getSchema().getFieldNames();\n+\t\tthis.fieldTypes = catalogTable.getSchema().getFieldDataTypes();\n+\t\tthis.startupTimestampMillis = startupTimestampMillis;\n+\t\tthis.partStrategyFactory = partStrategyFactory;\n+\n+\t\tthis.interval = interval;\n+\t\tthis.readerParallelism = Math.max(readerParallelism, 1);\n+\t\tthis.currentReadTime = Long.MIN_VALUE;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeState(FunctionInitializationContext context) throws Exception {\n+\t\tthis.strategy = partStrategyFactory.createStrategy(getRuntimeContext().getUserCodeClassLoader());\n+\n+\t\tthis.currReadTimeState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tLongSerializer.INSTANCE\n+\t\t\t)\n+\t\t);\n+\t\tthis.distinctPartsState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tnew ListSerializer<>(new ListSerializer<>(StringSerializer.INSTANCE))\n+\t\t\t)\n+\t\t);\n+\n+\t\tthis.client = this.hiveShim.getHiveMetastoreClient(new HiveConf(conf.conf(), HiveConf.class));\n+\n+\t\tTable hiveTable = client.getTable(tablePath.getDatabaseName(), tablePath.getObjectName());\n+\t\tthis.tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, hiveTable);\n+\t\tthis.defaultPartitionName = conf.conf().get(HiveConf.ConfVars.DEFAULTPARTITIONNAME.varname,\n+\t\t\t\tHiveConf.ConfVars.DEFAULTPARTITIONNAME.defaultStrVal);\n+\n+\t\tthis.distinctPartitions = new HashSet<>();\n+\t\tif (context.isRestored()) {\n+\t\t\tLOG.info(\"Restoring state for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.currReadTimeState.get().iterator().next();\n+\t\t\tthis.distinctPartitions.addAll(this.distinctPartsState.get().iterator().next());\n+\t\t} else {\n+\t\t\tLOG.info(\"No state to restore for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.startupTimestampMillis;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void run(SourceContext<TimestampedHiveInputSplit> context) throws Exception {\n+\t\tcheckpointLock = context.getCheckpointLock();\n+\t\twhile (isRunning) {\n+\t\t\tsynchronized (checkpointLock) {\n+\t\t\t\tmonitorAndForwardSplits(context);\n+\t\t\t}\n+\t\t\tThread.sleep(interval);\n+\t\t}\n+\t}\n+\n+\tprivate void monitorAndForwardSplits(\n+\t\t\tSourceContext<TimestampedHiveInputSplit> context) throws IOException, TException {\n+\t\tassert (Thread.holdsLock(checkpointLock));\n+\n+\t\tList<Partition> partitions = client.listPartitionsByFilter(\n+\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\tstrategy.generateFetchFilter(partitionKeys, currentReadTime),\n+\t\t\t\t(short) -1);\n+\n+\t\tif (partitions.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tlong maxTime = Long.MIN_VALUE;\n+\t\tfor (Partition partition : partitions) {\n+\t\t\tList<String> partSpec = partition.getValues();\n+\t\t\tif (!this.distinctPartitions.contains(partSpec)) {\n+\t\t\t\tthis.distinctPartitions.add(partition.getValues());\n+\t\t\t\tlong time = this.strategy.extractPartTime(partitionKeys, partition.getValues());\n+\t\t\t\tif (time > maxTime) {\n+\t\t\t\t\tmaxTime = time;\n+\t\t\t\t}\n+\t\t\t\tHiveTableInputSplit[] splits = HiveTableInputFormat.createInputSplits(\n+\t\t\t\t\t\tthis.readerParallelism,\n+\t\t\t\t\t\tCollections.singletonList(toHiveTablePartition(partition)),\n+\t\t\t\t\t\tthis.conf.conf());\n+\t\t\t\tfor (HiveTableInputSplit split : splits) {\n+\t\t\t\t\tcontext.collect(new TimestampedHiveInputSplit(time, split));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tthis.currentReadTime = maxTime;\n+\n+\t\tthis.distinctPartitions.removeIf(partSpec -> this.strategy.canExpireForDistinct(\n+\t\t\t\tthis.strategy.extractPartTime(partitionKeys, partSpec),\n+\t\t\t\tthis.currentReadTime));\n+\t}\n+\n+\tprivate HiveTablePartition toHiveTablePartition(Partition p) {\n+\t\treturn HiveTableSource.toHiveTablePartition(\n+\t\t\t\tpartitionKeys, fieldNames, fieldTypes, hiveShim, tableProps, defaultPartitionName, p);\n+\t}\n+\n+\t@Override\n+\tpublic void snapshotState(FunctionSnapshotContext context) throws Exception {\n+\t\tPreconditions.checkState(this.currReadTimeState != null,\n+\t\t\t\t\"The \" + getClass().getSimpleName() + \" state has not been properly initialized.\");\n+\n+\t\tthis.currReadTimeState.clear();\n+\t\tthis.currReadTimeState.add(this.currentReadTime);\n+\n+\t\tthis.distinctPartsState.clear();\n+\t\tthis.distinctPartsState.add(new ArrayList<>(this.distinctPartitions));\n+\n+\t\tif (LOG.isDebugEnabled()) {\n+\t\t\tLOG.debug(\"{} checkpointed {}.\", getClass().getSimpleName(), currentReadTime);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tsuper.close();", "originalCommit": "4223a26640c7243a61135e803aa1dd21888114a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4NjM1Mg==", "url": "https://github.com/apache/flink/pull/12004#discussion_r420786352", "bodyText": "The checkpointLock  is assigned in run(). So if cancel is called before run, the checkpointLock  should always be null?", "author": "lirui-apache", "createdAt": "2020-05-06T13:24:01Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.connectors.hive.read.PartitionStrategy.PartitionStrategyFactory;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * This is the single (non-parallel) monitoring task which takes a {@link HiveTableInputFormat},\n+ * it is responsible for:\n+ *\n+ * <ol>\n+ *     <li>Monitoring partitions of hive meta store.</li>\n+ *     <li>Deciding which partitions should be further read and processed.</li>\n+ *     <li>Creating the {@link HiveTableInputSplit splits} corresponding to those partitions.</li>\n+ *     <li>Assigning them to downstream tasks for further processing.</li>\n+ * </ol>\n+ *\n+ * <p>The splits to be read are forwarded to the downstream {@link ContinuousFileReaderOperator}\n+ * which can have parallelism greater than one.\n+ *\n+ * <p><b>IMPORTANT NOTE: </b> Splits are forwarded downstream for reading in ascending partition time order,\n+ * based on the partition time of the partitions they belong to.\n+ */\n+public class HiveContinuousMonitoringFunction\n+\t\textends RichSourceFunction<TimestampedHiveInputSplit>\n+\t\timplements CheckpointedFunction {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(HiveContinuousMonitoringFunction.class);\n+\n+\t/** The parallelism of the downstream readers. */\n+\tprivate final int readerParallelism;\n+\n+\t/** The interval between consecutive path scans. */\n+\tprivate final long interval;\n+\n+\tprivate final HiveShim hiveShim;\n+\n+\tprivate final JobConfWrapper conf;\n+\n+\tprivate final ObjectPath tablePath;\n+\n+\tprivate final List<String> partitionKeys;\n+\n+\tprivate final String[] fieldNames;\n+\n+\tprivate final DataType[] fieldTypes;\n+\n+\tprivate final long startupTimestampMillis;\n+\n+\tprivate final PartitionStrategyFactory partStrategyFactory;\n+\n+\tprivate volatile boolean isRunning = true;\n+\n+\t/** The maximum partition read time seen so far. */\n+\tprivate volatile long currentReadTime;\n+\n+\tprivate transient PartitionStrategy strategy;\n+\n+\tprivate transient Object checkpointLock;\n+\n+\tprivate transient ListState<Long> currReadTimeState;\n+\n+\tprivate transient ListState<List<List<String>>> distinctPartsState;\n+\n+\tprivate transient IMetaStoreClient client;\n+\n+\tprivate transient Properties tableProps;\n+\n+\tprivate transient String defaultPartitionName;\n+\n+\tprivate transient Set<List<String>> distinctPartitions;\n+\n+\tpublic HiveContinuousMonitoringFunction(\n+\t\t\tHiveShim hiveShim,\n+\t\t\tJobConf conf,\n+\t\t\tObjectPath tablePath,\n+\t\t\tCatalogTable catalogTable,\n+\t\t\tlong startupTimestampMillis,\n+\t\t\tPartitionStrategyFactory partStrategyFactory,\n+\t\t\tint readerParallelism,\n+\t\t\tlong interval) {\n+\t\tthis.hiveShim = hiveShim;\n+\t\tthis.conf = new JobConfWrapper(conf);\n+\t\tthis.tablePath = tablePath;\n+\t\tthis.partitionKeys = catalogTable.getPartitionKeys();\n+\t\tthis.fieldNames = catalogTable.getSchema().getFieldNames();\n+\t\tthis.fieldTypes = catalogTable.getSchema().getFieldDataTypes();\n+\t\tthis.startupTimestampMillis = startupTimestampMillis;\n+\t\tthis.partStrategyFactory = partStrategyFactory;\n+\n+\t\tthis.interval = interval;\n+\t\tthis.readerParallelism = Math.max(readerParallelism, 1);\n+\t\tthis.currentReadTime = Long.MIN_VALUE;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeState(FunctionInitializationContext context) throws Exception {\n+\t\tthis.strategy = partStrategyFactory.createStrategy(getRuntimeContext().getUserCodeClassLoader());\n+\n+\t\tthis.currReadTimeState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tLongSerializer.INSTANCE\n+\t\t\t)\n+\t\t);\n+\t\tthis.distinctPartsState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tnew ListSerializer<>(new ListSerializer<>(StringSerializer.INSTANCE))\n+\t\t\t)\n+\t\t);\n+\n+\t\tthis.client = this.hiveShim.getHiveMetastoreClient(new HiveConf(conf.conf(), HiveConf.class));\n+\n+\t\tTable hiveTable = client.getTable(tablePath.getDatabaseName(), tablePath.getObjectName());\n+\t\tthis.tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, hiveTable);\n+\t\tthis.defaultPartitionName = conf.conf().get(HiveConf.ConfVars.DEFAULTPARTITIONNAME.varname,\n+\t\t\t\tHiveConf.ConfVars.DEFAULTPARTITIONNAME.defaultStrVal);\n+\n+\t\tthis.distinctPartitions = new HashSet<>();\n+\t\tif (context.isRestored()) {\n+\t\t\tLOG.info(\"Restoring state for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.currReadTimeState.get().iterator().next();\n+\t\t\tthis.distinctPartitions.addAll(this.distinctPartsState.get().iterator().next());\n+\t\t} else {\n+\t\t\tLOG.info(\"No state to restore for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.startupTimestampMillis;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void run(SourceContext<TimestampedHiveInputSplit> context) throws Exception {\n+\t\tcheckpointLock = context.getCheckpointLock();\n+\t\twhile (isRunning) {\n+\t\t\tsynchronized (checkpointLock) {\n+\t\t\t\tmonitorAndForwardSplits(context);\n+\t\t\t}\n+\t\t\tThread.sleep(interval);\n+\t\t}\n+\t}\n+\n+\tprivate void monitorAndForwardSplits(\n+\t\t\tSourceContext<TimestampedHiveInputSplit> context) throws IOException, TException {\n+\t\tassert (Thread.holdsLock(checkpointLock));\n+\n+\t\tList<Partition> partitions = client.listPartitionsByFilter(\n+\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\tstrategy.generateFetchFilter(partitionKeys, currentReadTime),\n+\t\t\t\t(short) -1);\n+\n+\t\tif (partitions.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tlong maxTime = Long.MIN_VALUE;\n+\t\tfor (Partition partition : partitions) {\n+\t\t\tList<String> partSpec = partition.getValues();\n+\t\t\tif (!this.distinctPartitions.contains(partSpec)) {\n+\t\t\t\tthis.distinctPartitions.add(partition.getValues());\n+\t\t\t\tlong time = this.strategy.extractPartTime(partitionKeys, partition.getValues());\n+\t\t\t\tif (time > maxTime) {\n+\t\t\t\t\tmaxTime = time;\n+\t\t\t\t}\n+\t\t\t\tHiveTableInputSplit[] splits = HiveTableInputFormat.createInputSplits(\n+\t\t\t\t\t\tthis.readerParallelism,\n+\t\t\t\t\t\tCollections.singletonList(toHiveTablePartition(partition)),\n+\t\t\t\t\t\tthis.conf.conf());\n+\t\t\t\tfor (HiveTableInputSplit split : splits) {\n+\t\t\t\t\tcontext.collect(new TimestampedHiveInputSplit(time, split));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tthis.currentReadTime = maxTime;\n+\n+\t\tthis.distinctPartitions.removeIf(partSpec -> this.strategy.canExpireForDistinct(\n+\t\t\t\tthis.strategy.extractPartTime(partitionKeys, partSpec),\n+\t\t\t\tthis.currentReadTime));\n+\t}\n+\n+\tprivate HiveTablePartition toHiveTablePartition(Partition p) {\n+\t\treturn HiveTableSource.toHiveTablePartition(\n+\t\t\t\tpartitionKeys, fieldNames, fieldTypes, hiveShim, tableProps, defaultPartitionName, p);\n+\t}\n+\n+\t@Override\n+\tpublic void snapshotState(FunctionSnapshotContext context) throws Exception {\n+\t\tPreconditions.checkState(this.currReadTimeState != null,\n+\t\t\t\t\"The \" + getClass().getSimpleName() + \" state has not been properly initialized.\");\n+\n+\t\tthis.currReadTimeState.clear();\n+\t\tthis.currReadTimeState.add(this.currentReadTime);\n+\n+\t\tthis.distinctPartsState.clear();\n+\t\tthis.distinctPartsState.add(new ArrayList<>(this.distinctPartitions));\n+\n+\t\tif (LOG.isDebugEnabled()) {\n+\t\t\tLOG.debug(\"{} checkpointed {}.\", getClass().getSimpleName(), currentReadTime);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tsuper.close();\n+\n+\t\tif (checkpointLock != null) {\n+\t\t\tsynchronized (checkpointLock) {\n+\t\t\t\tcurrentReadTime = Long.MAX_VALUE;\n+\t\t\t\tisRunning = false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void cancel() {\n+\t\tif (checkpointLock != null) {\n+\t\t\t// this is to cover the case where cancel() is called before the run()", "originalCommit": "4223a26640c7243a61135e803aa1dd21888114a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NDQzMg==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422454432", "bodyText": "this is from another thread.", "author": "JingsongLi", "createdAt": "2020-05-09T05:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4NjM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4MzI3MQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422483271", "bodyText": "Let's move this comment to the outside of the if block, so that it's easier to understand.", "author": "lirui-apache", "createdAt": "2020-05-09T11:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4NjM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4ODY4Ng==", "url": "https://github.com/apache/flink/pull/12004#discussion_r420788686", "bodyText": "The java doc mentions the splits should be forwarded in a specific order. But it seems we're not sorting the partitions here?", "author": "lirui-apache", "createdAt": "2020-05-06T13:27:11Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.connectors.hive.read.PartitionStrategy.PartitionStrategyFactory;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * This is the single (non-parallel) monitoring task which takes a {@link HiveTableInputFormat},\n+ * it is responsible for:\n+ *\n+ * <ol>\n+ *     <li>Monitoring partitions of hive meta store.</li>\n+ *     <li>Deciding which partitions should be further read and processed.</li>\n+ *     <li>Creating the {@link HiveTableInputSplit splits} corresponding to those partitions.</li>\n+ *     <li>Assigning them to downstream tasks for further processing.</li>\n+ * </ol>\n+ *\n+ * <p>The splits to be read are forwarded to the downstream {@link ContinuousFileReaderOperator}\n+ * which can have parallelism greater than one.\n+ *\n+ * <p><b>IMPORTANT NOTE: </b> Splits are forwarded downstream for reading in ascending partition time order,\n+ * based on the partition time of the partitions they belong to.\n+ */\n+public class HiveContinuousMonitoringFunction\n+\t\textends RichSourceFunction<TimestampedHiveInputSplit>\n+\t\timplements CheckpointedFunction {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(HiveContinuousMonitoringFunction.class);\n+\n+\t/** The parallelism of the downstream readers. */\n+\tprivate final int readerParallelism;\n+\n+\t/** The interval between consecutive path scans. */\n+\tprivate final long interval;\n+\n+\tprivate final HiveShim hiveShim;\n+\n+\tprivate final JobConfWrapper conf;\n+\n+\tprivate final ObjectPath tablePath;\n+\n+\tprivate final List<String> partitionKeys;\n+\n+\tprivate final String[] fieldNames;\n+\n+\tprivate final DataType[] fieldTypes;\n+\n+\tprivate final long startupTimestampMillis;\n+\n+\tprivate final PartitionStrategyFactory partStrategyFactory;\n+\n+\tprivate volatile boolean isRunning = true;\n+\n+\t/** The maximum partition read time seen so far. */\n+\tprivate volatile long currentReadTime;\n+\n+\tprivate transient PartitionStrategy strategy;\n+\n+\tprivate transient Object checkpointLock;\n+\n+\tprivate transient ListState<Long> currReadTimeState;\n+\n+\tprivate transient ListState<List<List<String>>> distinctPartsState;\n+\n+\tprivate transient IMetaStoreClient client;\n+\n+\tprivate transient Properties tableProps;\n+\n+\tprivate transient String defaultPartitionName;\n+\n+\tprivate transient Set<List<String>> distinctPartitions;\n+\n+\tpublic HiveContinuousMonitoringFunction(\n+\t\t\tHiveShim hiveShim,\n+\t\t\tJobConf conf,\n+\t\t\tObjectPath tablePath,\n+\t\t\tCatalogTable catalogTable,\n+\t\t\tlong startupTimestampMillis,\n+\t\t\tPartitionStrategyFactory partStrategyFactory,\n+\t\t\tint readerParallelism,\n+\t\t\tlong interval) {\n+\t\tthis.hiveShim = hiveShim;\n+\t\tthis.conf = new JobConfWrapper(conf);\n+\t\tthis.tablePath = tablePath;\n+\t\tthis.partitionKeys = catalogTable.getPartitionKeys();\n+\t\tthis.fieldNames = catalogTable.getSchema().getFieldNames();\n+\t\tthis.fieldTypes = catalogTable.getSchema().getFieldDataTypes();\n+\t\tthis.startupTimestampMillis = startupTimestampMillis;\n+\t\tthis.partStrategyFactory = partStrategyFactory;\n+\n+\t\tthis.interval = interval;\n+\t\tthis.readerParallelism = Math.max(readerParallelism, 1);\n+\t\tthis.currentReadTime = Long.MIN_VALUE;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeState(FunctionInitializationContext context) throws Exception {\n+\t\tthis.strategy = partStrategyFactory.createStrategy(getRuntimeContext().getUserCodeClassLoader());\n+\n+\t\tthis.currReadTimeState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tLongSerializer.INSTANCE\n+\t\t\t)\n+\t\t);\n+\t\tthis.distinctPartsState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tnew ListSerializer<>(new ListSerializer<>(StringSerializer.INSTANCE))\n+\t\t\t)\n+\t\t);\n+\n+\t\tthis.client = this.hiveShim.getHiveMetastoreClient(new HiveConf(conf.conf(), HiveConf.class));\n+\n+\t\tTable hiveTable = client.getTable(tablePath.getDatabaseName(), tablePath.getObjectName());\n+\t\tthis.tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, hiveTable);\n+\t\tthis.defaultPartitionName = conf.conf().get(HiveConf.ConfVars.DEFAULTPARTITIONNAME.varname,\n+\t\t\t\tHiveConf.ConfVars.DEFAULTPARTITIONNAME.defaultStrVal);\n+\n+\t\tthis.distinctPartitions = new HashSet<>();\n+\t\tif (context.isRestored()) {\n+\t\t\tLOG.info(\"Restoring state for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.currReadTimeState.get().iterator().next();\n+\t\t\tthis.distinctPartitions.addAll(this.distinctPartsState.get().iterator().next());\n+\t\t} else {\n+\t\t\tLOG.info(\"No state to restore for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.startupTimestampMillis;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void run(SourceContext<TimestampedHiveInputSplit> context) throws Exception {\n+\t\tcheckpointLock = context.getCheckpointLock();\n+\t\twhile (isRunning) {\n+\t\t\tsynchronized (checkpointLock) {\n+\t\t\t\tmonitorAndForwardSplits(context);\n+\t\t\t}\n+\t\t\tThread.sleep(interval);\n+\t\t}\n+\t}\n+\n+\tprivate void monitorAndForwardSplits(\n+\t\t\tSourceContext<TimestampedHiveInputSplit> context) throws IOException, TException {\n+\t\tassert (Thread.holdsLock(checkpointLock));\n+\n+\t\tList<Partition> partitions = client.listPartitionsByFilter(\n+\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\tstrategy.generateFetchFilter(partitionKeys, currentReadTime),\n+\t\t\t\t(short) -1);\n+\n+\t\tif (partitions.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tlong maxTime = Long.MIN_VALUE;\n+\t\tfor (Partition partition : partitions) {", "originalCommit": "4223a26640c7243a61135e803aa1dd21888114a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjQzMQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422462431", "bodyText": "Good point, yes, will sort.", "author": "JingsongLi", "createdAt": "2020-05-09T07:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4ODY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEwODkwNw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422108907", "bodyText": "not -> does not .", "author": "openinx", "createdAt": "2020-05-08T12:13:52Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/HiveTableSource.java", "diffHunk": "@@ -150,6 +164,25 @@ public boolean isBounded() {\n \t\t\t\tallHivePartitions,\n \t\t\t\tflinkConf.get(HiveOptions.TABLE_EXEC_HIVE_FALLBACK_MAPRED_READER));\n \n+\t\tif (isStreamingSource()) {\n+\t\t\tif (catalogTable.getPartitionKeys().isEmpty()) {\n+\t\t\t\tthrow new UnsupportedOperationException(\n+\t\t\t\t\t\t\"Non-partition table not support streaming read now.\");", "originalCommit": "42953325bb1d6a447ef53e020d3cc311a8c986c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEyMTgwMQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422121801", "bodyText": "I've one question here, what's the parallelism of the ContinuousFileReaderOperator will be ?   should we use the default  parallelism in ExecutionConfig ?\nOK, seems the InputFormat will generate the expected parallelism...", "author": "openinx", "createdAt": "2020-05-08T12:44:53Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/HiveTableSource.java", "diffHunk": "@@ -181,6 +214,47 @@ public boolean isBounded() {\n \t\treturn source.name(explainSource());\n \t}\n \n+\tprivate DataStream<RowData> createStreamSource(\n+\t\t\tStreamExecutionEnvironment execEnv,\n+\t\t\tTypeInformation<RowData> typeInfo,\n+\t\t\tHiveTableInputFormat inputFormat) {\n+\t\tfinal Map<String, String> properties = catalogTable.getProperties();\n+\t\tPartitionFetcherFactory strategyFactory = cl -> PartitionFetcher.createStrategy(\n+\t\t\t\tproperties.get(HIVE_STREAMING_SOURCE_PARTITION_STRATEGY.key()),\n+\t\t\t\tproperties.get(HIVE_STREAMING_SOURCE_PARTITION_STRATEGY_CLASS.key()),\n+\t\t\t\tcl);\n+\n+\t\tString monitorIntervalStr = properties.get(HIVE_STREAMING_SOURCE_MONITOR_INTERVAL.key());\n+\t\tDuration monitorInterval = monitorIntervalStr != null ?\n+\t\t\t\tTimeUtils.parseDuration(monitorIntervalStr) :\n+\t\t\t\tHIVE_STREAMING_SOURCE_MONITOR_INTERVAL.defaultValue();\n+\n+\t\tHiveContinuousMonitoringFunction monitoringFunction = new HiveContinuousMonitoringFunction(\n+\t\t\t\thiveShim,\n+\t\t\t\tjobConf,\n+\t\t\t\ttablePath,\n+\t\t\t\tcatalogTable,\n+\t\t\t\tgetStartupPartition(),\n+\t\t\t\tstrategyFactory,\n+\t\t\t\texecEnv.getParallelism(),\n+\t\t\t\tmonitorInterval.toMillis());\n+\n+\t\tContinuousFileReaderOperatorFactory<RowData, TimestampedHiveInputSplit> factory =\n+\t\t\t\tnew ContinuousFileReaderOperatorFactory<>(inputFormat);", "originalCommit": "42953325bb1d6a447ef53e020d3cc311a8c986c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEyNDMyNQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422124325", "bodyText": "Besides  seems we don't do any split inside the file which may introduce the unbalanced data consuming in the upstream operator ?  Iceberg seems handle this well because it will split the larger data file into small balanced tasks  and dispatch to the executing task..", "author": "openinx", "createdAt": "2020-05-08T12:50:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEyMTgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjcyNw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422462727", "bodyText": "we don't do any split inside the file\n\nWe will split one file to many splits.", "author": "JingsongLi", "createdAt": "2020-05-09T07:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEyMTgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEyNzg5NA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422127894", "bodyText": "Seems the useless imported class can be removed", "author": "openinx", "createdAt": "2020-05-08T12:58:14Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.connectors.hive.read.PartitionFetcher.PartitionFetcherFactory;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;", "originalCommit": "42953325bb1d6a447ef53e020d3cc311a8c986c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE0MTE5MA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422141190", "bodyText": "Just ask the similar question as @lirui-apache said,   if the partitions is not sorted by timestamp ascending, then it seems have problems,  say we have partitions with timestamp like [(p0, 5), (p1, 1), (p2, 3)] ( the first part of (p0, 5) is partition name and the second is timestamp ),   now we have emitted the timestamp=5 successfully, then we will update the currentReadTime = 5   I think. Once the operator restored, we will just start from the timestamp = 5 to read the following partitions...it mistakenly skipped other timestamps such as 1 and 3 , finally we will lost part of the data to consume....\nPls correct me if I'm wrong.", "author": "openinx", "createdAt": "2020-05-08T13:25:45Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.connectors.hive.read.PartitionFetcher.PartitionFetcherFactory;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import static org.apache.flink.table.filesystem.PartitionPathUtils.escapePathName;\n+\n+/**\n+ * This is the single (non-parallel) monitoring task which takes a {@link HiveTableInputFormat},\n+ * it is responsible for:\n+ *\n+ * <ol>\n+ *     <li>Monitoring partitions of hive meta store.</li>\n+ *     <li>Deciding which partitions should be further read and processed.</li>\n+ *     <li>Creating the {@link HiveTableInputSplit splits} corresponding to those partitions.</li>\n+ *     <li>Assigning them to downstream tasks for further processing.</li>\n+ * </ol>\n+ *\n+ * <p>The splits to be read are forwarded to the downstream {@link ContinuousFileReaderOperator}\n+ * which can have parallelism greater than one.\n+ *\n+ * <p><b>IMPORTANT NOTE: </b> Splits are forwarded downstream for reading in ascending partition time order,\n+ * based on the partition time of the partitions they belong to.\n+ */\n+public class HiveContinuousMonitoringFunction\n+\t\textends RichSourceFunction<TimestampedHiveInputSplit>\n+\t\timplements CheckpointedFunction {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(HiveContinuousMonitoringFunction.class);\n+\n+\t/** The parallelism of the downstream readers. */\n+\tprivate final int readerParallelism;\n+\n+\t/** The interval between consecutive path scans. */\n+\tprivate final long interval;\n+\n+\tprivate final HiveShim hiveShim;\n+\n+\tprivate final JobConfWrapper conf;\n+\n+\tprivate final ObjectPath tablePath;\n+\n+\tprivate final List<String> partitionKeys;\n+\n+\tprivate final String[] fieldNames;\n+\n+\tprivate final DataType[] fieldTypes;\n+\n+\tprivate final String startupPartition;\n+\n+\tprivate final PartitionFetcherFactory fetcherFactory;\n+\n+\tprivate volatile boolean isRunning = true;\n+\n+\t/** The maximum partition read time seen so far. */\n+\tprivate volatile long currentReadTime;\n+\n+\tprivate transient PartitionFetcher.Context fetcherContext;\n+\n+\tprivate transient PartitionFetcher fetcher;\n+\n+\tprivate transient Object checkpointLock;\n+\n+\tprivate transient ListState<Long> currReadTimeState;\n+\n+\tprivate transient ListState<List<List<String>>> distinctPartsState;\n+\n+\tprivate transient IMetaStoreClient client;\n+\n+\tprivate transient Properties tableProps;\n+\n+\tprivate transient String defaultPartitionName;\n+\n+\tprivate transient Set<List<String>> distinctPartitions;\n+\n+\tpublic HiveContinuousMonitoringFunction(\n+\t\t\tHiveShim hiveShim,\n+\t\t\tJobConf conf,\n+\t\t\tObjectPath tablePath,\n+\t\t\tCatalogTable catalogTable,\n+\t\t\tString startupPartition,\n+\t\t\tPartitionFetcherFactory fetcherFactory,\n+\t\t\tint readerParallelism,\n+\t\t\tlong interval) {\n+\t\tthis.hiveShim = hiveShim;\n+\t\tthis.conf = new JobConfWrapper(conf);\n+\t\tthis.tablePath = tablePath;\n+\t\tthis.partitionKeys = catalogTable.getPartitionKeys();\n+\t\tthis.fieldNames = catalogTable.getSchema().getFieldNames();\n+\t\tthis.fieldTypes = catalogTable.getSchema().getFieldDataTypes();\n+\t\tthis.startupPartition = startupPartition;\n+\t\tthis.fetcherFactory = fetcherFactory;\n+\n+\t\tthis.interval = interval;\n+\t\tthis.readerParallelism = Math.max(readerParallelism, 1);\n+\t\tthis.currentReadTime = 0;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeState(FunctionInitializationContext context) throws Exception {\n+\t\tthis.currReadTimeState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tLongSerializer.INSTANCE\n+\t\t\t)\n+\t\t);\n+\t\tthis.distinctPartsState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tnew ListSerializer<>(new ListSerializer<>(StringSerializer.INSTANCE))\n+\t\t\t)\n+\t\t);\n+\n+\t\tthis.client = this.hiveShim.getHiveMetastoreClient(new HiveConf(conf.conf(), HiveConf.class));\n+\n+\t\tTable hiveTable = client.getTable(tablePath.getDatabaseName(), tablePath.getObjectName());\n+\t\tthis.tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, hiveTable);\n+\t\tthis.defaultPartitionName = conf.conf().get(HiveConf.ConfVars.DEFAULTPARTITIONNAME.varname,\n+\t\t\t\tHiveConf.ConfVars.DEFAULTPARTITIONNAME.defaultStrVal);\n+\n+\t\tthis.fetcher = fetcherFactory.createStrategy(getRuntimeContext().getUserCodeClassLoader());\n+\n+\t\tPath location = new Path(hiveTable.getSd().getLocation());\n+\t\tFileSystem fs = location.getFileSystem(conf.conf());\n+\t\tthis.fetcherContext = new PartitionFetcher.Context() {\n+\n+\t\t\t@Override\n+\t\t\tpublic List<String> partitionKeys() {\n+\t\t\t\treturn partitionKeys;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Partition getPartition(String escapeName) throws TException {\n+\t\t\t\treturn client.getPartition(\n+\t\t\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\t\t\tescapeName);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic List<Partition> listPartitionsByFilter(String filter) throws TException {\n+\t\t\t\treturn client.listPartitionsByFilter(\n+\t\t\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\t\t\tfilter,\n+\t\t\t\t\t\t(short) -1);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic FileSystem fileSystem() {\n+\t\t\t\treturn fs;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Path tableLocation() {\n+\t\t\t\treturn new Path(hiveTable.getSd().getLocation());\n+\t\t\t}\n+\t\t};\n+\n+\t\tthis.distinctPartitions = new HashSet<>();\n+\t\tif (context.isRestored()) {\n+\t\t\tLOG.info(\"Restoring state for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.currReadTimeState.get().iterator().next();\n+\t\t\tthis.distinctPartitions.addAll(this.distinctPartsState.get().iterator().next());\n+\t\t} else {\n+\t\t\tLOG.info(\"No state to restore for the {}.\", getClass().getSimpleName());\n+\t\t\tif (startupPartition != null) {\n+\t\t\t\tthis.currentReadTime = fetcher.extractTimestamp(\n+\t\t\t\t\t\tfetcherContext,\n+\t\t\t\t\t\tclient.getPartition(\n+\t\t\t\t\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\t\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\t\t\t\t\tescapePathName(startupPartition)));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void run(SourceContext<TimestampedHiveInputSplit> context) throws Exception {\n+\t\tcheckpointLock = context.getCheckpointLock();\n+\t\twhile (isRunning) {\n+\t\t\tsynchronized (checkpointLock) {\n+\t\t\t\tmonitorAndForwardSplits(context);\n+\t\t\t}\n+\t\t\tThread.sleep(interval);\n+\t\t}\n+\t}\n+\n+\tprivate void monitorAndForwardSplits(\n+\t\t\tSourceContext<TimestampedHiveInputSplit> context) throws Exception {\n+\t\tassert (Thread.holdsLock(checkpointLock));\n+\n+\t\tList<Partition> partitions = fetcher.fetchPartitions(fetcherContext, currentReadTime);\n+\n+\t\tif (partitions.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tlong maxTimestamp = Long.MIN_VALUE;\n+\t\tSet<List<String>> nextDistinctParts = new HashSet<>();\n+\t\tfor (Partition partition : partitions) {\n+\t\t\tList<String> partSpec = partition.getValues();\n+\t\t\tif (!this.distinctPartitions.contains(partSpec)) {\n+\t\t\t\tthis.distinctPartitions.add(partition.getValues());\n+\t\t\t\tlong timestamp = this.fetcher.extractTimestamp(fetcherContext, partition);\n+\t\t\t\tif (timestamp > currentReadTime) {\n+\t\t\t\t\tnextDistinctParts.add(partSpec);\n+\t\t\t\t}\n+\t\t\t\tif (timestamp > maxTimestamp) {\n+\t\t\t\t\tmaxTimestamp = timestamp;\n+\t\t\t\t}\n+\t\t\t\tHiveTableInputSplit[] splits = HiveTableInputFormat.createInputSplits(\n+\t\t\t\t\t\tthis.readerParallelism,\n+\t\t\t\t\t\tCollections.singletonList(toHiveTablePartition(partition)),\n+\t\t\t\t\t\tthis.conf.conf());\n+\t\t\t\tfor (HiveTableInputSplit split : splits) {\n+\t\t\t\t\tcontext.collect(new TimestampedHiveInputSplit(timestamp, split));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (maxTimestamp > currentReadTime) {", "originalCommit": "42953325bb1d6a447ef53e020d3cc311a8c986c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjUyNw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422462527", "bodyText": "First, will sort this list.", "author": "JingsongLi", "createdAt": "2020-05-09T07:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE0MTE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjYzNw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422462637", "bodyText": "we will lost part of the data to consume\n\nNo, these partitions will be all emitted to downstream, there is no checkpoint in them.", "author": "JingsongLi", "createdAt": "2020-05-09T07:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE0MTE5MA=="}], "type": "inlineReview"}, {"oid": "8747027ad6aa257da2ba859581637361f653e716", "url": "https://github.com/apache/flink/commit/8747027ad6aa257da2ba859581637361f653e716", "message": "Refactor", "committedDate": "2020-05-09T07:42:42Z", "type": "forcePushed"}, {"oid": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "url": "https://github.com/apache/flink/commit/44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "message": "[FLINK-17434][hive] Hive partitioned source support streaming read", "committedDate": "2020-05-09T07:44:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNjE2Ng==", "url": "https://github.com/apache/flink/pull/12004#discussion_r421206166", "bodyText": "What's the difference between close and closeInputFormat? And can we have some comments explaining why we don't have to do anything in close?", "author": "lirui-apache", "createdAt": "2020-05-07T02:43:41Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveTableInputFormat.java", "diffHunk": "@@ -248,7 +263,11 @@ public RowData nextRecord(RowData reuse) throws IOException {\n \t}\n \n \t@Override\n-\tpublic void close() throws IOException {\n+\tpublic void close() {", "originalCommit": "4223a26640c7243a61135e803aa1dd21888114a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0ODI1Ng==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422748256", "bodyText": "I am wrong, should in close.", "author": "JingsongLi", "createdAt": "2020-05-11T02:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwNjE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MTk5Nw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422471997", "bodyText": "I think it's possible that a partition folder exists in FS but not in HMS, in which case that folder should be simply ignored instead of throwing an exception.", "author": "lirui-apache", "createdAt": "2020-05-09T08:59:00Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.flink.table.filesystem.PartitionTimeExtractor;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static org.apache.flink.table.filesystem.TimestampPartTimeExtractor.toLocalDateTime;\n+\n+/**\n+ * This is the single (non-parallel) monitoring task which takes a {@link HiveTableInputFormat},\n+ * it is responsible for:\n+ *\n+ * <ol>\n+ *     <li>Monitoring partitions of hive meta store.</li>\n+ *     <li>Deciding which partitions should be further read and processed.</li>\n+ *     <li>Creating the {@link HiveTableInputSplit splits} corresponding to those partitions.</li>\n+ *     <li>Assigning them to downstream tasks for further processing.</li>\n+ * </ol>\n+ *\n+ * <p>The splits to be read are forwarded to the downstream {@link ContinuousFileReaderOperator}\n+ * which can have parallelism greater than one.\n+ *\n+ * <p><b>IMPORTANT NOTE: </b> Splits are forwarded downstream for reading in ascending partition time order,\n+ * based on the partition time of the partitions they belong to.\n+ */\n+public class HiveContinuousMonitoringFunction\n+\t\textends RichSourceFunction<TimestampedHiveInputSplit>\n+\t\timplements CheckpointedFunction {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(HiveContinuousMonitoringFunction.class);\n+\n+\t/** The parallelism of the downstream readers. */\n+\tprivate final int readerParallelism;\n+\n+\t/** The interval between consecutive path scans. */\n+\tprivate final long interval;\n+\n+\tprivate final HiveShim hiveShim;\n+\n+\tprivate final JobConfWrapper conf;\n+\n+\tprivate final ObjectPath tablePath;\n+\n+\tprivate final List<String> partitionKeys;\n+\n+\tprivate final String[] fieldNames;\n+\n+\tprivate final DataType[] fieldTypes;\n+\n+\t// consumer variables\n+\tprivate final String consumeOrder;\n+\tprivate final String consumeOffset;\n+\n+\t// extractor variables\n+\tprivate final String extractorType;\n+\tprivate final String extractorClass;\n+\tprivate final String extractorPattern;\n+\n+\tprivate volatile boolean isRunning = true;\n+\n+\t/** The maximum partition read time seen so far. */\n+\tprivate volatile long currentReadTime;\n+\n+\tprivate transient PartitionDiscovery.Context context;\n+\n+\tprivate transient PartitionDiscovery fetcher;\n+\n+\tprivate transient Object checkpointLock;\n+\n+\tprivate transient ListState<Long> currReadTimeState;\n+\n+\tprivate transient ListState<List<List<String>>> distinctPartsState;\n+\n+\tprivate transient IMetaStoreClient client;\n+\n+\tprivate transient Properties tableProps;\n+\n+\tprivate transient String defaultPartitionName;\n+\n+\tprivate transient Set<List<String>> distinctPartitions;\n+\n+\tpublic HiveContinuousMonitoringFunction(\n+\t\t\tHiveShim hiveShim,\n+\t\t\tJobConf conf,\n+\t\t\tObjectPath tablePath,\n+\t\t\tCatalogTable catalogTable,\n+\t\t\tint readerParallelism,\n+\t\t\tString consumeOrder,\n+\t\t\tString consumeOffset,\n+\t\t\tString extractorType,\n+\t\t\tString extractorClass,\n+\t\t\tString extractorPattern,\n+\t\t\tlong interval) {\n+\t\tthis.hiveShim = hiveShim;\n+\t\tthis.conf = new JobConfWrapper(conf);\n+\t\tthis.tablePath = tablePath;\n+\t\tthis.partitionKeys = catalogTable.getPartitionKeys();\n+\t\tthis.fieldNames = catalogTable.getSchema().getFieldNames();\n+\t\tthis.fieldTypes = catalogTable.getSchema().getFieldDataTypes();\n+\t\tthis.consumeOrder = consumeOrder;\n+\t\tthis.extractorType = extractorType;\n+\t\tthis.extractorClass = extractorClass;\n+\t\tthis.extractorPattern = extractorPattern;\n+\t\tthis.consumeOffset = consumeOffset;\n+\n+\t\tthis.interval = interval;\n+\t\tthis.readerParallelism = Math.max(readerParallelism, 1);\n+\t\tthis.currentReadTime = 0;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeState(FunctionInitializationContext context) throws Exception {\n+\t\tthis.currReadTimeState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tLongSerializer.INSTANCE\n+\t\t\t)\n+\t\t);\n+\t\tthis.distinctPartsState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tnew ListSerializer<>(new ListSerializer<>(StringSerializer.INSTANCE))\n+\t\t\t)\n+\t\t);\n+\n+\t\tthis.client = this.hiveShim.getHiveMetastoreClient(new HiveConf(conf.conf(), HiveConf.class));\n+\n+\t\tTable hiveTable = client.getTable(tablePath.getDatabaseName(), tablePath.getObjectName());\n+\t\tthis.tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, hiveTable);\n+\t\tthis.defaultPartitionName = conf.conf().get(HiveConf.ConfVars.DEFAULTPARTITIONNAME.varname,\n+\t\t\t\tHiveConf.ConfVars.DEFAULTPARTITIONNAME.defaultStrVal);\n+\n+\t\tPartitionTimeExtractor extractor = PartitionTimeExtractor.create(\n+\t\t\t\tgetRuntimeContext().getUserCodeClassLoader(),\n+\t\t\t\textractorType,\n+\t\t\t\textractorClass,\n+\t\t\t\textractorPattern);\n+\n+\t\tthis.fetcher = new DirectoryMonitorDiscovery();\n+\n+\t\tPath location = new Path(hiveTable.getSd().getLocation());\n+\t\tFileSystem fs = location.getFileSystem(conf.conf());\n+\t\tthis.context = new PartitionDiscovery.Context() {\n+\n+\t\t\t@Override\n+\t\t\tpublic List<String> partitionKeys() {\n+\t\t\t\treturn partitionKeys;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Partition getPartition(List<String> partValues) throws TException {\n+\t\t\t\treturn client.getPartition(", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MjAyMA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422472020", "bodyText": "Should add constants for create-time and partition-time.", "author": "lirui-apache", "createdAt": "2020-05-09T08:59:25Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.flink.table.filesystem.PartitionTimeExtractor;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static org.apache.flink.table.filesystem.TimestampPartTimeExtractor.toLocalDateTime;\n+\n+/**\n+ * This is the single (non-parallel) monitoring task which takes a {@link HiveTableInputFormat},\n+ * it is responsible for:\n+ *\n+ * <ol>\n+ *     <li>Monitoring partitions of hive meta store.</li>\n+ *     <li>Deciding which partitions should be further read and processed.</li>\n+ *     <li>Creating the {@link HiveTableInputSplit splits} corresponding to those partitions.</li>\n+ *     <li>Assigning them to downstream tasks for further processing.</li>\n+ * </ol>\n+ *\n+ * <p>The splits to be read are forwarded to the downstream {@link ContinuousFileReaderOperator}\n+ * which can have parallelism greater than one.\n+ *\n+ * <p><b>IMPORTANT NOTE: </b> Splits are forwarded downstream for reading in ascending partition time order,\n+ * based on the partition time of the partitions they belong to.\n+ */\n+public class HiveContinuousMonitoringFunction\n+\t\textends RichSourceFunction<TimestampedHiveInputSplit>\n+\t\timplements CheckpointedFunction {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(HiveContinuousMonitoringFunction.class);\n+\n+\t/** The parallelism of the downstream readers. */\n+\tprivate final int readerParallelism;\n+\n+\t/** The interval between consecutive path scans. */\n+\tprivate final long interval;\n+\n+\tprivate final HiveShim hiveShim;\n+\n+\tprivate final JobConfWrapper conf;\n+\n+\tprivate final ObjectPath tablePath;\n+\n+\tprivate final List<String> partitionKeys;\n+\n+\tprivate final String[] fieldNames;\n+\n+\tprivate final DataType[] fieldTypes;\n+\n+\t// consumer variables\n+\tprivate final String consumeOrder;\n+\tprivate final String consumeOffset;\n+\n+\t// extractor variables\n+\tprivate final String extractorType;\n+\tprivate final String extractorClass;\n+\tprivate final String extractorPattern;\n+\n+\tprivate volatile boolean isRunning = true;\n+\n+\t/** The maximum partition read time seen so far. */\n+\tprivate volatile long currentReadTime;\n+\n+\tprivate transient PartitionDiscovery.Context context;\n+\n+\tprivate transient PartitionDiscovery fetcher;\n+\n+\tprivate transient Object checkpointLock;\n+\n+\tprivate transient ListState<Long> currReadTimeState;\n+\n+\tprivate transient ListState<List<List<String>>> distinctPartsState;\n+\n+\tprivate transient IMetaStoreClient client;\n+\n+\tprivate transient Properties tableProps;\n+\n+\tprivate transient String defaultPartitionName;\n+\n+\tprivate transient Set<List<String>> distinctPartitions;\n+\n+\tpublic HiveContinuousMonitoringFunction(\n+\t\t\tHiveShim hiveShim,\n+\t\t\tJobConf conf,\n+\t\t\tObjectPath tablePath,\n+\t\t\tCatalogTable catalogTable,\n+\t\t\tint readerParallelism,\n+\t\t\tString consumeOrder,\n+\t\t\tString consumeOffset,\n+\t\t\tString extractorType,\n+\t\t\tString extractorClass,\n+\t\t\tString extractorPattern,\n+\t\t\tlong interval) {\n+\t\tthis.hiveShim = hiveShim;\n+\t\tthis.conf = new JobConfWrapper(conf);\n+\t\tthis.tablePath = tablePath;\n+\t\tthis.partitionKeys = catalogTable.getPartitionKeys();\n+\t\tthis.fieldNames = catalogTable.getSchema().getFieldNames();\n+\t\tthis.fieldTypes = catalogTable.getSchema().getFieldDataTypes();\n+\t\tthis.consumeOrder = consumeOrder;\n+\t\tthis.extractorType = extractorType;\n+\t\tthis.extractorClass = extractorClass;\n+\t\tthis.extractorPattern = extractorPattern;\n+\t\tthis.consumeOffset = consumeOffset;\n+\n+\t\tthis.interval = interval;\n+\t\tthis.readerParallelism = Math.max(readerParallelism, 1);\n+\t\tthis.currentReadTime = 0;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeState(FunctionInitializationContext context) throws Exception {\n+\t\tthis.currReadTimeState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tLongSerializer.INSTANCE\n+\t\t\t)\n+\t\t);\n+\t\tthis.distinctPartsState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tnew ListSerializer<>(new ListSerializer<>(StringSerializer.INSTANCE))\n+\t\t\t)\n+\t\t);\n+\n+\t\tthis.client = this.hiveShim.getHiveMetastoreClient(new HiveConf(conf.conf(), HiveConf.class));\n+\n+\t\tTable hiveTable = client.getTable(tablePath.getDatabaseName(), tablePath.getObjectName());\n+\t\tthis.tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, hiveTable);\n+\t\tthis.defaultPartitionName = conf.conf().get(HiveConf.ConfVars.DEFAULTPARTITIONNAME.varname,\n+\t\t\t\tHiveConf.ConfVars.DEFAULTPARTITIONNAME.defaultStrVal);\n+\n+\t\tPartitionTimeExtractor extractor = PartitionTimeExtractor.create(\n+\t\t\t\tgetRuntimeContext().getUserCodeClassLoader(),\n+\t\t\t\textractorType,\n+\t\t\t\textractorClass,\n+\t\t\t\textractorPattern);\n+\n+\t\tthis.fetcher = new DirectoryMonitorDiscovery();\n+\n+\t\tPath location = new Path(hiveTable.getSd().getLocation());\n+\t\tFileSystem fs = location.getFileSystem(conf.conf());\n+\t\tthis.context = new PartitionDiscovery.Context() {\n+\n+\t\t\t@Override\n+\t\t\tpublic List<String> partitionKeys() {\n+\t\t\t\treturn partitionKeys;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Partition getPartition(List<String> partValues) throws TException {\n+\t\t\t\treturn client.getPartition(\n+\t\t\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\t\t\tpartValues);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic FileSystem fileSystem() {\n+\t\t\t\treturn fs;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Path tableLocation() {\n+\t\t\t\treturn new Path(hiveTable.getSd().getLocation());\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic long extractTimestamp(\n+\t\t\t\t\tList<String> partKeys,\n+\t\t\t\t\tList<String> partValues,\n+\t\t\t\t\tSupplier<Long> fileTime) {\n+\t\t\t\tswitch (consumeOrder) {\n+\t\t\t\t\tcase \"create-time\":", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ3MzU4NQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422473585", "bodyText": "this.distinctPartitions.add(partSpec)?", "author": "lirui-apache", "createdAt": "2020-05-09T09:16:12Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/HiveContinuousMonitoringFunction.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.state.ListState;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.typeutils.base.ListSerializer;\n+import org.apache.flink.api.common.typeutils.base.LongSerializer;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.connectors.hive.HiveTablePartition;\n+import org.apache.flink.connectors.hive.HiveTableSource;\n+import org.apache.flink.connectors.hive.JobConfWrapper;\n+import org.apache.flink.runtime.state.FunctionInitializationContext;\n+import org.apache.flink.runtime.state.FunctionSnapshotContext;\n+import org.apache.flink.streaming.api.checkpoint.CheckpointedFunction;\n+import org.apache.flink.streaming.api.functions.source.ContinuousFileReaderOperator;\n+import org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n+import org.apache.flink.table.catalog.CatalogTable;\n+import org.apache.flink.table.catalog.ObjectPath;\n+import org.apache.flink.table.catalog.hive.client.HiveShim;\n+import org.apache.flink.table.catalog.hive.util.HiveReflectionUtils;\n+import org.apache.flink.table.data.TimestampData;\n+import org.apache.flink.table.filesystem.PartitionTimeExtractor;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.conf.HiveConf;\n+import org.apache.hadoop.hive.metastore.IMetaStoreClient;\n+import org.apache.hadoop.hive.metastore.api.Partition;\n+import org.apache.hadoop.hive.metastore.api.Table;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import static org.apache.flink.table.filesystem.TimestampPartTimeExtractor.toLocalDateTime;\n+\n+/**\n+ * This is the single (non-parallel) monitoring task which takes a {@link HiveTableInputFormat},\n+ * it is responsible for:\n+ *\n+ * <ol>\n+ *     <li>Monitoring partitions of hive meta store.</li>\n+ *     <li>Deciding which partitions should be further read and processed.</li>\n+ *     <li>Creating the {@link HiveTableInputSplit splits} corresponding to those partitions.</li>\n+ *     <li>Assigning them to downstream tasks for further processing.</li>\n+ * </ol>\n+ *\n+ * <p>The splits to be read are forwarded to the downstream {@link ContinuousFileReaderOperator}\n+ * which can have parallelism greater than one.\n+ *\n+ * <p><b>IMPORTANT NOTE: </b> Splits are forwarded downstream for reading in ascending partition time order,\n+ * based on the partition time of the partitions they belong to.\n+ */\n+public class HiveContinuousMonitoringFunction\n+\t\textends RichSourceFunction<TimestampedHiveInputSplit>\n+\t\timplements CheckpointedFunction {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(HiveContinuousMonitoringFunction.class);\n+\n+\t/** The parallelism of the downstream readers. */\n+\tprivate final int readerParallelism;\n+\n+\t/** The interval between consecutive path scans. */\n+\tprivate final long interval;\n+\n+\tprivate final HiveShim hiveShim;\n+\n+\tprivate final JobConfWrapper conf;\n+\n+\tprivate final ObjectPath tablePath;\n+\n+\tprivate final List<String> partitionKeys;\n+\n+\tprivate final String[] fieldNames;\n+\n+\tprivate final DataType[] fieldTypes;\n+\n+\t// consumer variables\n+\tprivate final String consumeOrder;\n+\tprivate final String consumeOffset;\n+\n+\t// extractor variables\n+\tprivate final String extractorType;\n+\tprivate final String extractorClass;\n+\tprivate final String extractorPattern;\n+\n+\tprivate volatile boolean isRunning = true;\n+\n+\t/** The maximum partition read time seen so far. */\n+\tprivate volatile long currentReadTime;\n+\n+\tprivate transient PartitionDiscovery.Context context;\n+\n+\tprivate transient PartitionDiscovery fetcher;\n+\n+\tprivate transient Object checkpointLock;\n+\n+\tprivate transient ListState<Long> currReadTimeState;\n+\n+\tprivate transient ListState<List<List<String>>> distinctPartsState;\n+\n+\tprivate transient IMetaStoreClient client;\n+\n+\tprivate transient Properties tableProps;\n+\n+\tprivate transient String defaultPartitionName;\n+\n+\tprivate transient Set<List<String>> distinctPartitions;\n+\n+\tpublic HiveContinuousMonitoringFunction(\n+\t\t\tHiveShim hiveShim,\n+\t\t\tJobConf conf,\n+\t\t\tObjectPath tablePath,\n+\t\t\tCatalogTable catalogTable,\n+\t\t\tint readerParallelism,\n+\t\t\tString consumeOrder,\n+\t\t\tString consumeOffset,\n+\t\t\tString extractorType,\n+\t\t\tString extractorClass,\n+\t\t\tString extractorPattern,\n+\t\t\tlong interval) {\n+\t\tthis.hiveShim = hiveShim;\n+\t\tthis.conf = new JobConfWrapper(conf);\n+\t\tthis.tablePath = tablePath;\n+\t\tthis.partitionKeys = catalogTable.getPartitionKeys();\n+\t\tthis.fieldNames = catalogTable.getSchema().getFieldNames();\n+\t\tthis.fieldTypes = catalogTable.getSchema().getFieldDataTypes();\n+\t\tthis.consumeOrder = consumeOrder;\n+\t\tthis.extractorType = extractorType;\n+\t\tthis.extractorClass = extractorClass;\n+\t\tthis.extractorPattern = extractorPattern;\n+\t\tthis.consumeOffset = consumeOffset;\n+\n+\t\tthis.interval = interval;\n+\t\tthis.readerParallelism = Math.max(readerParallelism, 1);\n+\t\tthis.currentReadTime = 0;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeState(FunctionInitializationContext context) throws Exception {\n+\t\tthis.currReadTimeState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tLongSerializer.INSTANCE\n+\t\t\t)\n+\t\t);\n+\t\tthis.distinctPartsState = context.getOperatorStateStore().getListState(\n+\t\t\tnew ListStateDescriptor<>(\n+\t\t\t\t\"partition-monitoring-state\",\n+\t\t\t\tnew ListSerializer<>(new ListSerializer<>(StringSerializer.INSTANCE))\n+\t\t\t)\n+\t\t);\n+\n+\t\tthis.client = this.hiveShim.getHiveMetastoreClient(new HiveConf(conf.conf(), HiveConf.class));\n+\n+\t\tTable hiveTable = client.getTable(tablePath.getDatabaseName(), tablePath.getObjectName());\n+\t\tthis.tableProps = HiveReflectionUtils.getTableMetadata(hiveShim, hiveTable);\n+\t\tthis.defaultPartitionName = conf.conf().get(HiveConf.ConfVars.DEFAULTPARTITIONNAME.varname,\n+\t\t\t\tHiveConf.ConfVars.DEFAULTPARTITIONNAME.defaultStrVal);\n+\n+\t\tPartitionTimeExtractor extractor = PartitionTimeExtractor.create(\n+\t\t\t\tgetRuntimeContext().getUserCodeClassLoader(),\n+\t\t\t\textractorType,\n+\t\t\t\textractorClass,\n+\t\t\t\textractorPattern);\n+\n+\t\tthis.fetcher = new DirectoryMonitorDiscovery();\n+\n+\t\tPath location = new Path(hiveTable.getSd().getLocation());\n+\t\tFileSystem fs = location.getFileSystem(conf.conf());\n+\t\tthis.context = new PartitionDiscovery.Context() {\n+\n+\t\t\t@Override\n+\t\t\tpublic List<String> partitionKeys() {\n+\t\t\t\treturn partitionKeys;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Partition getPartition(List<String> partValues) throws TException {\n+\t\t\t\treturn client.getPartition(\n+\t\t\t\t\t\ttablePath.getDatabaseName(),\n+\t\t\t\t\t\ttablePath.getObjectName(),\n+\t\t\t\t\t\tpartValues);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic FileSystem fileSystem() {\n+\t\t\t\treturn fs;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic Path tableLocation() {\n+\t\t\t\treturn new Path(hiveTable.getSd().getLocation());\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic long extractTimestamp(\n+\t\t\t\t\tList<String> partKeys,\n+\t\t\t\t\tList<String> partValues,\n+\t\t\t\t\tSupplier<Long> fileTime) {\n+\t\t\t\tswitch (consumeOrder) {\n+\t\t\t\t\tcase \"create-time\":\n+\t\t\t\t\t\treturn fileTime.get();\n+\t\t\t\t\tcase \"partition-time\":\n+\t\t\t\t\t\treturn toMills(extractor.extract(partKeys, partValues));\n+\t\t\t\t\tdefault:\n+\t\t\t\t\t\tthrow new UnsupportedOperationException(\n+\t\t\t\t\t\t\t\t\"Unsupported consumer order: \" + consumeOrder);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\n+\t\tthis.distinctPartitions = new HashSet<>();\n+\t\tif (context.isRestored()) {\n+\t\t\tLOG.info(\"Restoring state for the {}.\", getClass().getSimpleName());\n+\t\t\tthis.currentReadTime = this.currReadTimeState.get().iterator().next();\n+\t\t\tthis.distinctPartitions.addAll(this.distinctPartsState.get().iterator().next());\n+\t\t} else {\n+\t\t\tLOG.info(\"No state to restore for the {}.\", getClass().getSimpleName());\n+\t\t\tif (consumeOffset != null) {\n+\t\t\t\tthis.currentReadTime = toMills(toLocalDateTime(consumeOffset));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void run(SourceContext<TimestampedHiveInputSplit> context) throws Exception {\n+\t\tcheckpointLock = context.getCheckpointLock();\n+\t\twhile (isRunning) {\n+\t\t\tsynchronized (checkpointLock) {\n+\t\t\t\tmonitorAndForwardSplits(context);\n+\t\t\t}\n+\t\t\tThread.sleep(interval);\n+\t\t}\n+\t}\n+\n+\tprivate void monitorAndForwardSplits(\n+\t\t\tSourceContext<TimestampedHiveInputSplit> context) throws Exception {\n+\t\tassert (Thread.holdsLock(checkpointLock));\n+\n+\t\tList<Tuple2<Partition, Long>> partitions = fetcher.fetchPartitions(this.context, currentReadTime);\n+\n+\t\tif (partitions.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tpartitions.sort((o1, o2) -> (int) (o1.f1 - o2.f1));\n+\n+\t\tlong maxTimestamp = Long.MIN_VALUE;\n+\t\tSet<List<String>> nextDistinctParts = new HashSet<>();\n+\t\tfor (Tuple2<Partition, Long> tuple2 : partitions) {\n+\t\t\tPartition partition = tuple2.f0;\n+\t\t\tList<String> partSpec = partition.getValues();\n+\t\t\tif (!this.distinctPartitions.contains(partSpec)) {\n+\t\t\t\tthis.distinctPartitions.add(partition.getValues());", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4MjIyMQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422482221", "bodyText": "\"Seek too many rows.\" ?", "author": "lirui-apache", "createdAt": "2020-05-09T10:52:25Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/SplitReader.java", "diffHunk": "@@ -46,4 +46,17 @@\n \t * @throws IOException Thrown, if an I/O error occurred.\n \t */\n \tRowData nextRecord(RowData reuse) throws IOException;\n+\n+\t/**\n+\t * Seek to a particular row number.\n+\t */\n+\tdefault void seekToRow(long rowCount, RowData reuse) throws IOException {\n+\t\tfor (int i = 0; i < rowCount; i++) {\n+\t\t\tboolean end = reachedEnd();\n+\t\t\tif (end) {\n+\t\t\t\tthrow new RuntimeException(\"Seek to many rows.\");", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NDU0NQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422484545", "bodyText": "For two split instances, this means equals can return false while compareTo returns 0. Is this intended behavior?", "author": "lirui-apache", "createdAt": "2020-05-09T11:20:15Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/TimestampedHiveInputSplit.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.typeinfo.BasicTypeInfo;\n+import org.apache.flink.api.common.typeinfo.TypeInfo;\n+import org.apache.flink.api.common.typeinfo.TypeInfoFactory;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.SimpleTypeSerializerSnapshot;\n+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;\n+import org.apache.flink.api.common.typeutils.base.TypeSerializerSingleton;\n+import org.apache.flink.api.java.typeutils.runtime.DataInputViewStream;\n+import org.apache.flink.api.java.typeutils.runtime.DataOutputViewStream;\n+import org.apache.flink.core.memory.DataInputView;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.streaming.api.functions.source.TimestampedInputSplit;\n+import org.apache.flink.util.FlinkRuntimeException;\n+import org.apache.flink.util.InstantiationUtil;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link HiveTableInputSplit} with {@link TimestampedInputSplit}.\n+ * Kryo serializer can not deal with hadoop split, need specific type information factory.\n+ */\n+@TypeInfo(TimestampedHiveInputSplit.SplitTypeInfoFactory.class)\n+public class TimestampedHiveInputSplit extends HiveTableInputSplit implements TimestampedInputSplit {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\t/** The modification time of the file this split belongs to. */\n+\tprivate final long modificationTime;\n+\n+\t/**\n+\t * The state of the split. This information is used when\n+\t * restoring from a checkpoint and allows to resume reading the\n+\t * underlying file from the point we left off.\n+\t * */\n+\tprivate Serializable splitState;\n+\n+\tpublic TimestampedHiveInputSplit(\n+\t\t\tlong modificationTime,\n+\t\t\tHiveTableInputSplit split) {\n+\t\tsuper(\n+\t\t\t\tsplit.getSplitNumber(),\n+\t\t\t\tsplit.getHadoopInputSplit(),\n+\t\t\t\tsplit.getJobConf(),\n+\t\t\t\tsplit.getHiveTablePartition());\n+\t\tthis.modificationTime = modificationTime;\n+\t}\n+\n+\t@Override\n+\tpublic void setSplitState(Serializable state) {\n+\t\tthis.splitState = state;\n+\t}\n+\n+\t@Override\n+\tpublic Serializable getSplitState() {\n+\t\treturn this.splitState;\n+\t}\n+\n+\t@Override\n+\tpublic long getModificationTime() {\n+\t\treturn modificationTime;\n+\t}\n+\n+\t@Override\n+\tpublic int compareTo(TimestampedInputSplit o) {\n+\t\tTimestampedHiveInputSplit split = (TimestampedHiveInputSplit) o;\n+\t\tint modTimeComp = Long.compare(this.modificationTime, split.modificationTime);\n+\t\tif (modTimeComp != 0L) {\n+\t\t\treturn modTimeComp;\n+\t\t}\n+\n+\t\tint pathComp = this.hiveTablePartition.getStorageDescriptor().compareTo(\n+\t\t\t\tsplit.hiveTablePartition.getStorageDescriptor());\n+\n+\t\treturn pathComp != 0 ? pathComp :\n+\t\t\t\tthis.getSplitNumber() - o.getSplitNumber();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!super.equals(o)) {", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1MjY1NA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422752654", "bodyText": "Yes, we can create the case like you said, but in read world, it should not happen.", "author": "JingsongLi", "createdAt": "2020-05-11T02:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NDU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1NjQxNw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422756417", "bodyText": "I think the best practice is to avoid such implementations. And if for some reason it has to be done this way, we should clarify it in the java doc, according to the suggestions of Comparable:\n     * <p>It is strongly recommended, but <i>not</i> strictly required that\n     * <tt>(x.compareTo(y)==0) == (x.equals(y))</tt>.  Generally speaking, any\n     * class that implements the <tt>Comparable</tt> interface and violates\n     * this condition should clearly indicate this fact.  The recommended\n     * language is \"Note: this class has a natural ordering that is\n     * inconsistent with equals.\"", "author": "lirui-apache", "createdAt": "2020-05-11T03:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NDU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1Nzc5Mw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422757793", "bodyText": "TimestampedHiveInputSplit is only used in ContinuousFileReaderOperator. I will add comments.", "author": "JingsongLi", "createdAt": "2020-05-11T03:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NDU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NDU2OQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422484569", "bodyText": "I think this compares more than just paths.", "author": "lirui-apache", "createdAt": "2020-05-09T11:20:33Z", "path": "flink-connectors/flink-connector-hive/src/main/java/org/apache/flink/connectors/hive/read/TimestampedHiveInputSplit.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.connectors.hive.read;\n+\n+import org.apache.flink.api.common.typeinfo.BasicTypeInfo;\n+import org.apache.flink.api.common.typeinfo.TypeInfo;\n+import org.apache.flink.api.common.typeinfo.TypeInfoFactory;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.common.typeutils.SimpleTypeSerializerSnapshot;\n+import org.apache.flink.api.common.typeutils.TypeSerializerSnapshot;\n+import org.apache.flink.api.common.typeutils.base.TypeSerializerSingleton;\n+import org.apache.flink.api.java.typeutils.runtime.DataInputViewStream;\n+import org.apache.flink.api.java.typeutils.runtime.DataOutputViewStream;\n+import org.apache.flink.core.memory.DataInputView;\n+import org.apache.flink.core.memory.DataOutputView;\n+import org.apache.flink.streaming.api.functions.source.TimestampedInputSplit;\n+import org.apache.flink.util.FlinkRuntimeException;\n+import org.apache.flink.util.InstantiationUtil;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A {@link HiveTableInputSplit} with {@link TimestampedInputSplit}.\n+ * Kryo serializer can not deal with hadoop split, need specific type information factory.\n+ */\n+@TypeInfo(TimestampedHiveInputSplit.SplitTypeInfoFactory.class)\n+public class TimestampedHiveInputSplit extends HiveTableInputSplit implements TimestampedInputSplit {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\t/** The modification time of the file this split belongs to. */\n+\tprivate final long modificationTime;\n+\n+\t/**\n+\t * The state of the split. This information is used when\n+\t * restoring from a checkpoint and allows to resume reading the\n+\t * underlying file from the point we left off.\n+\t * */\n+\tprivate Serializable splitState;\n+\n+\tpublic TimestampedHiveInputSplit(\n+\t\t\tlong modificationTime,\n+\t\t\tHiveTableInputSplit split) {\n+\t\tsuper(\n+\t\t\t\tsplit.getSplitNumber(),\n+\t\t\t\tsplit.getHadoopInputSplit(),\n+\t\t\t\tsplit.getJobConf(),\n+\t\t\t\tsplit.getHiveTablePartition());\n+\t\tthis.modificationTime = modificationTime;\n+\t}\n+\n+\t@Override\n+\tpublic void setSplitState(Serializable state) {\n+\t\tthis.splitState = state;\n+\t}\n+\n+\t@Override\n+\tpublic Serializable getSplitState() {\n+\t\treturn this.splitState;\n+\t}\n+\n+\t@Override\n+\tpublic long getModificationTime() {\n+\t\treturn modificationTime;\n+\t}\n+\n+\t@Override\n+\tpublic int compareTo(TimestampedInputSplit o) {\n+\t\tTimestampedHiveInputSplit split = (TimestampedHiveInputSplit) o;\n+\t\tint modTimeComp = Long.compare(this.modificationTime, split.modificationTime);\n+\t\tif (modTimeComp != 0L) {\n+\t\t\treturn modTimeComp;\n+\t\t}\n+\n+\t\tint pathComp = this.hiveTablePartition.getStorageDescriptor().compareTo(", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1MjQ3Mw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422752473", "bodyText": "It is a short cut for comparing. If the sd is same, SplitNumber must be different.", "author": "JingsongLi", "createdAt": "2020-05-11T02:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NDU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NTI2Mw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422485263", "bodyText": "Wondering what's the relationship between this and the execution mode? E.g. can I enable streaming source with batch execution mode?", "author": "lirui-apache", "createdAt": "2020-05-09T11:29:41Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/FileSystemOptions.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.filesystem;\n+\n+import org.apache.flink.configuration.ConfigOption;\n+\n+import java.time.Duration;\n+\n+import static org.apache.flink.configuration.ConfigOptions.key;\n+\n+/**\n+ * This class holds configuration constants used by filesystem(Including hive) connector.\n+ */\n+public class FileSystemOptions {\n+\n+\tpublic static final ConfigOption<Boolean> STREAMING_SOURCE_ENABLE =", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1MTk3NA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422751974", "bodyText": "No, but streaming execution mode can run both streaming source and batch source.\nBatch execution mode is a subset of streaming execution.", "author": "JingsongLi", "createdAt": "2020-05-11T02:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NTU5MA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422485590", "bodyText": "Why it's the minimum interval? It may seem confusing to users.", "author": "lirui-apache", "createdAt": "2020-05-09T11:33:33Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/FileSystemOptions.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.filesystem;\n+\n+import org.apache.flink.configuration.ConfigOption;\n+\n+import java.time.Duration;\n+\n+import static org.apache.flink.configuration.ConfigOptions.key;\n+\n+/**\n+ * This class holds configuration constants used by filesystem(Including hive) connector.\n+ */\n+public class FileSystemOptions {\n+\n+\tpublic static final ConfigOption<Boolean> STREAMING_SOURCE_ENABLE =\n+\t\t\tkey(\"streaming-source.enable\")\n+\t\t\t\t\t.booleanType()\n+\t\t\t\t\t.defaultValue(false)\n+\t\t\t\t\t.withDescription(\"Enable streaming source or not.\");\n+\n+\tpublic static final ConfigOption<Duration> STREAMING_SOURCE_MONITOR_INTERVAL =\n+\t\t\tkey(\"streaming-source.monitor-interval\")\n+\t\t\t\t\t.durationType()\n+\t\t\t\t\t.defaultValue(Duration.ofMillis(1))\n+\t\t\t\t\t.withDescription(\"The minimum interval allowed between consecutive partition/file discovery.\");", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1MzAxOQ==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422753019", "bodyText": "Time interval for consecutively monitoring partition/file.", "author": "JingsongLi", "createdAt": "2020-05-11T02:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NTU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NTk3MA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422485970", "bodyText": "I think we'd better clarify this is not the partition create time in HMS, but the folder/file create time in filesystem?", "author": "lirui-apache", "createdAt": "2020-05-09T11:39:04Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/FileSystemOptions.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.filesystem;\n+\n+import org.apache.flink.configuration.ConfigOption;\n+\n+import java.time.Duration;\n+\n+import static org.apache.flink.configuration.ConfigOptions.key;\n+\n+/**\n+ * This class holds configuration constants used by filesystem(Including hive) connector.\n+ */\n+public class FileSystemOptions {\n+\n+\tpublic static final ConfigOption<Boolean> STREAMING_SOURCE_ENABLE =\n+\t\t\tkey(\"streaming-source.enable\")\n+\t\t\t\t\t.booleanType()\n+\t\t\t\t\t.defaultValue(false)\n+\t\t\t\t\t.withDescription(\"Enable streaming source or not.\");\n+\n+\tpublic static final ConfigOption<Duration> STREAMING_SOURCE_MONITOR_INTERVAL =\n+\t\t\tkey(\"streaming-source.monitor-interval\")\n+\t\t\t\t\t.durationType()\n+\t\t\t\t\t.defaultValue(Duration.ofMillis(1))\n+\t\t\t\t\t.withDescription(\"The minimum interval allowed between consecutive partition/file discovery.\");\n+\n+\tpublic static final ConfigOption<String> STREAMING_SOURCE_CONSUME_ORDER =\n+\t\t\tkey(\"streaming-source.consume-order\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"create-time\")\n+\t\t\t\t\t.withDescription(\"The consume order of streaming source,\" +\n+\t\t\t\t\t\t\t\" support create-time and partition-time.\" +\n+\t\t\t\t\t\t\t\" create-time compare partition/file creation time;\" +", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NjMwMw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422486303", "bodyText": "Clarify this should only be used if STREAMING_SOURCE_CONSUME_ORDER is set to partition-time?", "author": "lirui-apache", "createdAt": "2020-05-09T11:44:09Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/FileSystemOptions.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.filesystem;\n+\n+import org.apache.flink.configuration.ConfigOption;\n+\n+import java.time.Duration;\n+\n+import static org.apache.flink.configuration.ConfigOptions.key;\n+\n+/**\n+ * This class holds configuration constants used by filesystem(Including hive) connector.\n+ */\n+public class FileSystemOptions {\n+\n+\tpublic static final ConfigOption<Boolean> STREAMING_SOURCE_ENABLE =\n+\t\t\tkey(\"streaming-source.enable\")\n+\t\t\t\t\t.booleanType()\n+\t\t\t\t\t.defaultValue(false)\n+\t\t\t\t\t.withDescription(\"Enable streaming source or not.\");\n+\n+\tpublic static final ConfigOption<Duration> STREAMING_SOURCE_MONITOR_INTERVAL =\n+\t\t\tkey(\"streaming-source.monitor-interval\")\n+\t\t\t\t\t.durationType()\n+\t\t\t\t\t.defaultValue(Duration.ofMillis(1))\n+\t\t\t\t\t.withDescription(\"The minimum interval allowed between consecutive partition/file discovery.\");\n+\n+\tpublic static final ConfigOption<String> STREAMING_SOURCE_CONSUME_ORDER =\n+\t\t\tkey(\"streaming-source.consume-order\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"create-time\")\n+\t\t\t\t\t.withDescription(\"The consume order of streaming source,\" +\n+\t\t\t\t\t\t\t\" support create-time and partition-time.\" +\n+\t\t\t\t\t\t\t\" create-time compare partition/file creation time;\" +\n+\t\t\t\t\t\t\t\" partition-time compare time represented by partition name.\");\n+\n+\tpublic static final ConfigOption<String> STREAMING_SOURCE_CONSUME_START_OFFSET =\n+\t\t\tkey(\"streaming-source.consume-start-offset\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"1970-00-00\")\n+\t\t\t\t\t.withDescription(\"Start offset for streaming consuming.\" +\n+\t\t\t\t\t\t\t\" How to parse and compare offsets depends on your order.\" +\n+\t\t\t\t\t\t\t\" For create-time and partition-time, should be a timestamp string.\");\n+\n+\tpublic static final ConfigOption<String> PARTITION_TIME_EXTRACTOR_TYPE =\n+\t\t\tkey(\"partition.time-extractor.type\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"timestamp\")\n+\t\t\t\t\t.withDescription(\"Time extractor to extract time from partition values.\" +", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1MzQzOA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422753438", "bodyText": "Yes, will add comments.", "author": "JingsongLi", "createdAt": "2020-05-11T02:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NjMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NjQxMA==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422486410", "bodyText": "Seems unused", "author": "lirui-apache", "createdAt": "2020-05-09T11:45:41Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/FileSystemOptions.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.filesystem;\n+\n+import org.apache.flink.configuration.ConfigOption;\n+\n+import java.time.Duration;\n+\n+import static org.apache.flink.configuration.ConfigOptions.key;\n+\n+/**\n+ * This class holds configuration constants used by filesystem(Including hive) connector.\n+ */\n+public class FileSystemOptions {\n+\n+\tpublic static final ConfigOption<Boolean> STREAMING_SOURCE_ENABLE =\n+\t\t\tkey(\"streaming-source.enable\")\n+\t\t\t\t\t.booleanType()\n+\t\t\t\t\t.defaultValue(false)\n+\t\t\t\t\t.withDescription(\"Enable streaming source or not.\");\n+\n+\tpublic static final ConfigOption<Duration> STREAMING_SOURCE_MONITOR_INTERVAL =\n+\t\t\tkey(\"streaming-source.monitor-interval\")\n+\t\t\t\t\t.durationType()\n+\t\t\t\t\t.defaultValue(Duration.ofMillis(1))\n+\t\t\t\t\t.withDescription(\"The minimum interval allowed between consecutive partition/file discovery.\");\n+\n+\tpublic static final ConfigOption<String> STREAMING_SOURCE_CONSUME_ORDER =\n+\t\t\tkey(\"streaming-source.consume-order\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"create-time\")\n+\t\t\t\t\t.withDescription(\"The consume order of streaming source,\" +\n+\t\t\t\t\t\t\t\" support create-time and partition-time.\" +\n+\t\t\t\t\t\t\t\" create-time compare partition/file creation time;\" +\n+\t\t\t\t\t\t\t\" partition-time compare time represented by partition name.\");\n+\n+\tpublic static final ConfigOption<String> STREAMING_SOURCE_CONSUME_START_OFFSET =\n+\t\t\tkey(\"streaming-source.consume-start-offset\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"1970-00-00\")\n+\t\t\t\t\t.withDescription(\"Start offset for streaming consuming.\" +\n+\t\t\t\t\t\t\t\" How to parse and compare offsets depends on your order.\" +\n+\t\t\t\t\t\t\t\" For create-time and partition-time, should be a timestamp string.\");\n+\n+\tpublic static final ConfigOption<String> PARTITION_TIME_EXTRACTOR_TYPE =\n+\t\t\tkey(\"partition.time-extractor.type\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"timestamp\")\n+\t\t\t\t\t.withDescription(\"Time extractor to extract time from partition values.\" +\n+\t\t\t\t\t\t\t\" Support timestamp and custom.\" +\n+\t\t\t\t\t\t\t\" For timestamp, can configure timestamp pattern.\" +\n+\t\t\t\t\t\t\t\" For custom, should configure extractor class.\");\n+\n+\tpublic static final ConfigOption<String> PARTITION_TIME_EXTRACTOR_CLASS =\n+\t\t\tkey(\"partition.time-extractor.class\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.noDefaultValue()\n+\t\t\t\t\t.withDescription(\"The extractor class for implement PartitionTimeExtractor interface.\");\n+\n+\tpublic static final ConfigOption<String> PARTITION_TIME_EXTRACTOR_TIMESTAMP_PATTERN =\n+\t\t\tkey(\"partition.time-extractor.timestamp-pattern\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.noDefaultValue()\n+\t\t\t\t\t.withDescription(\"The 'timestamp' construction way allows users to use partition\" +\n+\t\t\t\t\t\t\t\" fields to get a legal timestamp pattern.\" +\n+\t\t\t\t\t\t\t\" Default support 'yyyy-mm-dd hh:mm:ss' from first field.\" +\n+\t\t\t\t\t\t\t\" If timestamp in partition is single field 'dt', can configure: '$dt'.\" +\n+\t\t\t\t\t\t\t\" If timestamp in partition is year, month, day, hour,\" +\n+\t\t\t\t\t\t\t\" can configure: '$year-$month-$day $hour:00:00'.\" +\n+\t\t\t\t\t\t\t\" If timestamp in partition is dt and hour, can configure: '$dt $hour:00:00'.\");\n+\n+\tpublic static final ConfigOption<Duration> PARTITION_TIME_INTERVAL =", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4NjUzMw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422486533", "bodyText": "Should add constants for these values", "author": "lirui-apache", "createdAt": "2020-05-09T11:47:33Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/PartitionTimeExtractor.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.filesystem;\n+\n+import org.apache.flink.annotation.Experimental;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+/**\n+ * Time extractor to extract time from partition values.\n+ */\n+@Experimental\n+public interface PartitionTimeExtractor extends Serializable {\n+\n+\t/**\n+\t * Extract time from partition keys and values.\n+\t */\n+\tLocalDateTime extract(List<String> partitionKeys, List<String> partitionValues);\n+\n+\tstatic PartitionTimeExtractor create(\n+\t\t\tClassLoader userClassLoader,\n+\t\t\tString extractorType,\n+\t\t\tString extractorClass,\n+\t\t\tString extractorPattern) {\n+\t\tswitch (extractorType) {\n+\t\t\tcase \"timestamp\":", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4Njk2Nw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422486967", "bodyText": "I find timestamp somehow difficult to understand. According to the PartitionTimeExtractor interface, any implementation should extract a \"timestamp\". We may as well just call it default?", "author": "lirui-apache", "createdAt": "2020-05-09T11:53:35Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/FileSystemOptions.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.filesystem;\n+\n+import org.apache.flink.configuration.ConfigOption;\n+\n+import java.time.Duration;\n+\n+import static org.apache.flink.configuration.ConfigOptions.key;\n+\n+/**\n+ * This class holds configuration constants used by filesystem(Including hive) connector.\n+ */\n+public class FileSystemOptions {\n+\n+\tpublic static final ConfigOption<Boolean> STREAMING_SOURCE_ENABLE =\n+\t\t\tkey(\"streaming-source.enable\")\n+\t\t\t\t\t.booleanType()\n+\t\t\t\t\t.defaultValue(false)\n+\t\t\t\t\t.withDescription(\"Enable streaming source or not.\");\n+\n+\tpublic static final ConfigOption<Duration> STREAMING_SOURCE_MONITOR_INTERVAL =\n+\t\t\tkey(\"streaming-source.monitor-interval\")\n+\t\t\t\t\t.durationType()\n+\t\t\t\t\t.defaultValue(Duration.ofMillis(1))\n+\t\t\t\t\t.withDescription(\"The minimum interval allowed between consecutive partition/file discovery.\");\n+\n+\tpublic static final ConfigOption<String> STREAMING_SOURCE_CONSUME_ORDER =\n+\t\t\tkey(\"streaming-source.consume-order\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"create-time\")\n+\t\t\t\t\t.withDescription(\"The consume order of streaming source,\" +\n+\t\t\t\t\t\t\t\" support create-time and partition-time.\" +\n+\t\t\t\t\t\t\t\" create-time compare partition/file creation time;\" +\n+\t\t\t\t\t\t\t\" partition-time compare time represented by partition name.\");\n+\n+\tpublic static final ConfigOption<String> STREAMING_SOURCE_CONSUME_START_OFFSET =\n+\t\t\tkey(\"streaming-source.consume-start-offset\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"1970-00-00\")\n+\t\t\t\t\t.withDescription(\"Start offset for streaming consuming.\" +\n+\t\t\t\t\t\t\t\" How to parse and compare offsets depends on your order.\" +\n+\t\t\t\t\t\t\t\" For create-time and partition-time, should be a timestamp string.\");\n+\n+\tpublic static final ConfigOption<String> PARTITION_TIME_EXTRACTOR_TYPE =\n+\t\t\tkey(\"partition.time-extractor.type\")\n+\t\t\t\t\t.stringType()\n+\t\t\t\t\t.defaultValue(\"timestamp\")\n+\t\t\t\t\t.withDescription(\"Time extractor to extract time from partition values.\" +\n+\t\t\t\t\t\t\t\" Support timestamp and custom.\" +", "originalCommit": "44df52a0ff62e1b4ec65efd6a14a8b07d7712e75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc1Mzc2Nw==", "url": "https://github.com/apache/flink/pull/12004#discussion_r422753767", "bodyText": "+1", "author": "JingsongLi", "createdAt": "2020-05-11T02:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4Njk2Nw=="}], "type": "inlineReview"}, {"oid": "c37bf2f2aa6fd60631561379bdbc3ea4f554b387", "url": "https://github.com/apache/flink/commit/c37bf2f2aa6fd60631561379bdbc3ea4f554b387", "message": "[FLINK-17434][hive] Hive partitioned source support streaming read", "committedDate": "2020-05-11T08:44:19Z", "type": "commit"}, {"oid": "bffea7d6cacc503cc630c8b3ddf77f4093554e84", "url": "https://github.com/apache/flink/commit/bffea7d6cacc503cc630c8b3ddf77f4093554e84", "message": "Rebase", "committedDate": "2020-05-11T08:48:57Z", "type": "commit"}, {"oid": "bffea7d6cacc503cc630c8b3ddf77f4093554e84", "url": "https://github.com/apache/flink/commit/bffea7d6cacc503cc630c8b3ddf77f4093554e84", "message": "Rebase", "committedDate": "2020-05-11T08:48:57Z", "type": "forcePushed"}, {"oid": "3117c4f9c2eda7ab4b02c14861ba1a838f81a82d", "url": "https://github.com/apache/flink/commit/3117c4f9c2eda7ab4b02c14861ba1a838f81a82d", "message": "extractorType -> extractorKind", "committedDate": "2020-05-11T10:22:31Z", "type": "commit"}, {"oid": "48017434485d6059dafddc8617bf7f75fa7b3892", "url": "https://github.com/apache/flink/commit/48017434485d6059dafddc8617bf7f75fa7b3892", "message": "Fix comments", "committedDate": "2020-05-11T10:25:53Z", "type": "commit"}, {"oid": "759ec78773fe262a57fe635add8f81bb809555db", "url": "https://github.com/apache/flink/commit/759ec78773fe262a57fe635add8f81bb809555db", "message": "checkstyle", "committedDate": "2020-05-12T02:24:20Z", "type": "commit"}, {"oid": "9ffa89537d531709bd2bab2938b26e3693a349ba", "url": "https://github.com/apache/flink/commit/9ffa89537d531709bd2bab2938b26e3693a349ba", "message": "Update default value of monitor-interval", "committedDate": "2020-05-12T06:22:34Z", "type": "commit"}]}