{"pr_number": 12746, "pr_title": "[FLINK-15416][task][network] Retry connection to the upstream", "pr_createdAt": "2020-06-22T17:04:54Z", "pr_url": "https://github.com/apache/flink/pull/12746", "timeline": [{"oid": "66a9dfae43e2a1f30799e72978ce392a53448ab8", "url": "https://github.com/apache/flink/commit/66a9dfae43e2a1f30799e72978ce392a53448ab8", "message": "[FLINK-15416][network] Remove ignored PartitionRequestClientFactoryTest.testResourceReleaseAfterInterruptedConnect\n\nThe test was ignored for 5 years already.", "committedDate": "2020-06-22T17:16:56Z", "type": "forcePushed"}, {"oid": "6d5d1c73dc7f1416ca1677bb6d4aa31c01f69190", "url": "https://github.com/apache/flink/commit/6d5d1c73dc7f1416ca1677bb6d4aa31c01f69190", "message": "[FLINK-15416][network] Remove ignored PartitionRequestClientFactoryTest.testResourceReleaseAfterInterruptedConnect\n\nThe test was ignored for 5 years already.", "committedDate": "2020-06-22T20:51:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2NTEzMw==", "url": "https://github.com/apache/flink/pull/12746#discussion_r443865133", "bodyText": "The line can be removed.", "author": "HuangZhenQiu", "createdAt": "2020-06-22T22:43:34Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactoryTest.java", "diffHunk": "@@ -39,94 +41,145 @@\n import java.net.UnknownHostException;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletionException;\n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n \n-@Ignore\n+/**\n+ * {@link PartitionRequestClientFactory} test.\n+ */\n public class PartitionRequestClientFactoryTest {\n \n-\tprivate final static int SERVER_PORT = NetUtils.getAvailablePort();\n+\tprivate static final int SERVER_PORT = NetUtils.getAvailablePort();\n \n \t@Test\n-\tpublic void testResourceReleaseAfterInterruptedConnect() throws Exception {\n+\tpublic void testNettyClientConnectRetry() throws Exception {\n+\t\tNettyTestUtil.NettyServerAndClient serverAndClient = createNettyServerAndClient();\n+\t\tUnstableNettyClient unstableNettyClient = new UnstableNettyClient(serverAndClient.client(), 2);\n \n-\t\t// Latch to synchronize on the connect call.\n-\t\tfinal CountDownLatch syncOnConnect = new CountDownLatch(1);\n+\t\tPartitionRequestClientFactory factory = new PartitionRequestClientFactory(unstableNettyClient, 2);\n+\t\tConnectionID serverAddress = new ConnectionID(new InetSocketAddress(InetAddress.getLocalHost(),\n+\t\t\tserverAndClient.server().getConfig().getServerPort()), 0);\n \n-\t\tfinal Tuple2<NettyServer, NettyClient> netty = createNettyServerAndClient(\n-\t\t\t\tnew NettyProtocol(null, null) {\n+\t\tfactory.createPartitionRequestClient(serverAddress);\n \n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic ChannelHandler[] getServerChannelHandlers() {\n-\t\t\t\t\t\treturn new ChannelHandler[0];\n-\t\t\t\t\t}\n+\t\tserverAndClient.client().shutdown();\n+\t\tserverAndClient.server().shutdown();\n+\t}\n \n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic ChannelHandler[] getClientChannelHandlers() {\n-\t\t\t\t\t\treturn new ChannelHandler[] {\n-\t\t\t\t\t\t\t\tnew CountDownLatchOnConnectHandler(syncOnConnect)};\n-\t\t\t\t\t}\n-\t\t\t\t});\n+\t@Test(expected = CompletionException.class)\n+\tpublic void testNettyClientConnectRetryFailure() throws Exception {\n+\t\tNettyTestUtil.NettyServerAndClient serverAndClient = createNettyServerAndClient();\n+\t\tUnstableNettyClient unstableNettyClient = new UnstableNettyClient(serverAndClient.client(), 3);\n \n-\t\tfinal NettyServer server = netty.f0;\n-\t\tfinal NettyClient client = netty.f1;\n+\t\ttry {\n+\t\t\tPartitionRequestClientFactory factory = new PartitionRequestClientFactory(unstableNettyClient, 2);\n+\t\t\tConnectionID serverAddress = new ConnectionID(new InetSocketAddress(InetAddress.getLocalHost(),\n+\t\t\t\tserverAndClient.server().getConfig().getServerPort()), 0);\n \n-\t\tfinal UncaughtTestExceptionHandler exceptionHandler = new UncaughtTestExceptionHandler();\n+\t\t\tfactory.createPartitionRequestClient(serverAddress);\n \n-\t\ttry {\n-\t\t\tfinal PartitionRequestClientFactory factory = new PartitionRequestClientFactory(client);\n+\t\t} catch (Exception e) {\n+\t\t\tthrow e;\n+\t\t} finally {\n+\t\t\tserverAndClient.client().shutdown();\n+\t\t\tserverAndClient.server().shutdown();\n+\t\t}\n+\t}\n \n-\t\t\tfinal Thread connect = new Thread(new Runnable() {\n-\t\t\t\t@Override\n-\t\t\t\tpublic void run() {\n-\t\t\t\t\tConnectionID serverAddress = null;\n+\t@Test\n+\tpublic void testNettyClientConnectRetryMultipleThread() throws Exception {\n+\t\tNettyTestUtil.NettyServerAndClient serverAndClient = createNettyServerAndClient();\n+\t\tUnstableNettyClient unstableNettyClient = new UnstableNettyClient(serverAndClient.client(), 2);\n \n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tserverAddress = createServerConnectionID(0);\n+\t\tPartitionRequestClientFactory factory = new PartitionRequestClientFactory(unstableNettyClient, 2);\n+\t\tConnectionID serverAddress = new ConnectionID(new InetSocketAddress(InetAddress.getLocalHost(),\n+\t\t\tserverAndClient.server().getConfig().getServerPort()), 0);\n \n-\t\t\t\t\t\t// This triggers a connect\n-\t\t\t\t\t\tfactory.createPartitionRequestClient(serverAddress);\n-\t\t\t\t\t}\n-\t\t\t\t\tcatch (Throwable t) {\n-\n-\t\t\t\t\t\tif (serverAddress != null) {\n-\t\t\t\t\t\t\tfactory.closeOpenChannelConnections(serverAddress);\n-\t\t\t\t\t\t\tThread.getDefaultUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), t);\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tt.printStackTrace();\n-\t\t\t\t\t\t\tfail(\"Could not create RemoteAddress for server.\");\n-\t\t\t\t\t\t}\n+\t\tExecutorService threadPoolExecutor = Executors.newFixedThreadPool(10);\n+\t\tList<Future<NettyPartitionRequestClient>> futures = new ArrayList<>();\n+\n+\t\tfor (int i = 0; i < 10; i++) {\n+\t\t\tFuture<NettyPartitionRequestClient> future = threadPoolExecutor.submit(new Callable<NettyPartitionRequestClient>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic NettyPartitionRequestClient call() {\n+\t\t\t\t\tNettyPartitionRequestClient client = null;\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tclient = factory.createPartitionRequestClient(serverAddress);\n+\t\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\t\t// catch exception\n+\t\t\t\t\t\tSystem.out.println(e.getMessage());\n+\t\t\t\t\t\tfail();\n \t\t\t\t\t}\n+\t\t\t\t\treturn client;\n \t\t\t\t}\n \t\t\t});\n \n-\t\t\tconnect.setUncaughtExceptionHandler(exceptionHandler);\n+\t\t\tfutures.add(future);\n+\t\t}\n \n-\t\t\tconnect.start();\n+\t\tfutures.forEach(runnableFuture -> {\n+\t\t\tNettyPartitionRequestClient client = null;\n+\t\t\ttry {\n+\t\t\t\tclient = runnableFuture.get();\n+\t\t\t\tSystem.out.println(\"Result = \" + client == null ? \"null\" : client.toString());\n+\t\t\t\tassertNotNull(client);", "originalCommit": "6d5d1c73dc7f1416ca1677bb6d4aa31c01f69190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE5ODUxMA==", "url": "https://github.com/apache/flink/pull/12746#discussion_r444198510", "bodyText": "Removed println.", "author": "rkhachatryan", "createdAt": "2020-06-23T12:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg2NTEzMw=="}], "type": "inlineReview"}, {"oid": "7cd6fde800adb26e305b954bf67daf5abfa56321", "url": "https://github.com/apache/flink/commit/7cd6fde800adb26e305b954bf67daf5abfa56321", "message": "[FLINK-15416][network] Remove ignored PartitionRequestClientFactoryTest.testResourceReleaseAfterInterruptedConnect\n\nThe test was ignored for 5 years already.", "committedDate": "2020-06-23T07:40:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEyMTYzMQ==", "url": "https://github.com/apache/flink/pull/12746#discussion_r444121631", "bodyText": "AtomicReference<Optional<CompletableFuture<NettyPartitionRequestClient>>> is a bit complicated type and it's not that easy to understand how is it working. Why not using something simpler and more precisely expressing the intention, that the first caller completes the future?:\nAtomicBoolean isFirstOne = new AtomicBoolean(false);\nCompletableFuture<NettyPartitionRequestClient> clientFuture = clients.computeIfAbsent(connectionId, unused -> {\n\tCompletableFuture<NettyPartitionRequestClient> future = new CompletableFuture<>();\n\tisFirstOne.set(true);\n\treturn future;\n});\nif (isFirstOne.get()) {\n\tclientFuture.complete(connectWithRetries(connectionId)));\n}", "author": "pnowojski", "createdAt": "2020-06-23T10:24:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestClientFactory.java", "diffHunk": "@@ -40,83 +45,91 @@\n  * instances.\n  */\n class PartitionRequestClientFactory {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(PartitionRequestClientFactory.class);\n \n \tprivate final NettyClient nettyClient;\n \n-\tprivate final ConcurrentMap<ConnectionID, Object> clients = new ConcurrentHashMap<ConnectionID, Object>();\n+\tprivate final int retryNumber;\n+\n+\tprivate final ConcurrentMap<ConnectionID, CompletableFuture<NettyPartitionRequestClient>> clients = new ConcurrentHashMap<>();\n \n \tPartitionRequestClientFactory(NettyClient nettyClient) {\n+\t\tthis(nettyClient, 0);\n+\t}\n+\n+\tPartitionRequestClientFactory(NettyClient nettyClient, int retryNumber) {\n \t\tthis.nettyClient = nettyClient;\n+\t\tthis.retryNumber = retryNumber;\n \t}\n \n \t/**\n \t * Atomically establishes a TCP connection to the given remote address and\n \t * creates a {@link NettyPartitionRequestClient} instance for this connection.\n \t */\n \tNettyPartitionRequestClient createPartitionRequestClient(ConnectionID connectionId) throws IOException, InterruptedException {\n-\t\tObject entry;\n-\t\tNettyPartitionRequestClient client = null;\n-\n-\t\twhile (client == null) {\n-\t\t\tentry = clients.get(connectionId);\n-\n-\t\t\tif (entry != null) {\n-\t\t\t\t// Existing channel or connecting channel\n-\t\t\t\tif (entry instanceof NettyPartitionRequestClient) {\n-\t\t\t\t\tclient = (NettyPartitionRequestClient) entry;\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tConnectingChannel future = (ConnectingChannel) entry;\n-\t\t\t\t\tclient = future.waitForChannel();\n-\n-\t\t\t\t\tclients.replace(connectionId, future, client);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\t// No channel yet. Create one, but watch out for a race.\n-\t\t\t\t// We create a \"connecting future\" and atomically add it to the map.\n-\t\t\t\t// Only the thread that really added it establishes the channel.\n-\t\t\t\t// The others need to wait on that original establisher's future.\n-\t\t\t\tConnectingChannel connectingChannel = new ConnectingChannel(connectionId, this);\n-\t\t\t\tObject old = clients.putIfAbsent(connectionId, connectingChannel);\n-\n-\t\t\t\tif (old == null) {\n-\t\t\t\t\tnettyClient.connect(connectionId.getAddress()).addListener(connectingChannel);\n-\n-\t\t\t\t\tclient = connectingChannel.waitForChannel();\n-\n-\t\t\t\t\tclients.replace(connectionId, connectingChannel, client);\n-\t\t\t\t}\n-\t\t\t\telse if (old instanceof ConnectingChannel) {\n-\t\t\t\t\tclient = ((ConnectingChannel) old).waitForChannel();\n-\n-\t\t\t\t\tclients.replace(connectionId, old, client);\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tclient = (NettyPartitionRequestClient) old;\n-\t\t\t\t}\n+\t\twhile (true) {\n+\t\t\tAtomicReference<Optional<CompletableFuture<NettyPartitionRequestClient>>> computeFuture = new AtomicReference<>(Optional.empty());\n+\t\t\tCompletableFuture<NettyPartitionRequestClient> waitFuture = clients.computeIfAbsent(connectionId, unused -> {\n+\t\t\t\tCompletableFuture<NettyPartitionRequestClient> future = new CompletableFuture<>();\n+\t\t\t\tcomputeFuture.set(Optional.of(future));\n+\t\t\t\treturn future;\n+\t\t\t});\n+\t\t\tcomputeFuture.get().ifPresent(future -> future.complete(connectWithRetries(connectionId)));", "originalCommit": "7cd6fde800adb26e305b954bf67daf5abfa56321", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE5ODI0Mg==", "url": "https://github.com/apache/flink/pull/12746#discussion_r444198242", "bodyText": "Done.", "author": "rkhachatryan", "createdAt": "2020-06-23T12:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEyMTYzMQ=="}], "type": "inlineReview"}, {"oid": "ebc49551875469c1f2851bc5bac22649cbaaa5d9", "url": "https://github.com/apache/flink/commit/ebc49551875469c1f2851bc5bac22649cbaaa5d9", "message": "[FLINK-15416][network] Remove ignored PartitionRequestClientFactoryTest.testResourceReleaseAfterInterruptedConnect\n\nThe test was ignored for 5 years already.", "committedDate": "2020-06-23T16:21:18Z", "type": "forcePushed"}, {"oid": "b8e020d9c136ef10c165aa6af081e9ceefc4c82f", "url": "https://github.com/apache/flink/commit/b8e020d9c136ef10c165aa6af081e9ceefc4c82f", "message": "[FLINK-15416][network] Retry connection to the upstream task", "committedDate": "2020-07-02T09:57:31Z", "type": "commit"}, {"oid": "db58941bbbd52672ae8cda263e330d0ba029cde3", "url": "https://github.com/apache/flink/commit/db58941bbbd52672ae8cda263e330d0ba029cde3", "message": "[FLINK-15416][network] Remove ignored PartitionRequestClientFactoryTest.testResourceReleaseAfterInterruptedConnect\n\nThe test was ignored for 5 years already.", "committedDate": "2020-07-02T09:57:31Z", "type": "commit"}, {"oid": "db58941bbbd52672ae8cda263e330d0ba029cde3", "url": "https://github.com/apache/flink/commit/db58941bbbd52672ae8cda263e330d0ba029cde3", "message": "[FLINK-15416][network] Remove ignored PartitionRequestClientFactoryTest.testResourceReleaseAfterInterruptedConnect\n\nThe test was ignored for 5 years already.", "committedDate": "2020-07-02T09:57:31Z", "type": "forcePushed"}]}