{"pr_number": 11543, "pr_title": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF", "pr_createdAt": "2020-03-27T05:41:50Z", "pr_url": "https://github.com/apache/flink/pull/11543", "timeline": [{"oid": "61e53d4800400c4b3b9f9a2aef9938e26034370f", "url": "https://github.com/apache/flink/commit/61e53d4800400c4b3b9f9a2aef9938e26034370f", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF", "committedDate": "2020-03-27T07:00:55Z", "type": "forcePushed"}, {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "url": "https://github.com/apache/flink/commit/7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF", "committedDate": "2020-03-27T08:03:32Z", "type": "commit"}, {"oid": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "url": "https://github.com/apache/flink/commit/7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "message": "[FLINK-16672][python] Support Counter, Gauge, Meter, Distribution metric type for Python UDF", "committedDate": "2020-03-27T08:03:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxODUyMQ==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399318521", "bodyText": "remove this line and set it in the following RuntimeException?", "author": "dianfu", "createdAt": "2020-03-27T14:47:36Z", "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tcounter = metricGroup.counter(metricResult.getKey().metricName().getName());\n+\t\t\t\t\tflinkCounterCache.put(flinkMetricIdentifier, counter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tcounter.inc(update - counter.getCount());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateDistributions(Iterable<MetricResult<DistributionResult>> distributions) {\n+\t\tfor (MetricResult<DistributionResult> metricResult : distributions) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\t\t\tDistributionResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkDistributionGauge gauge = flinkDistributionGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkDistributionGauge(update));\n+\t\t\t\tflinkDistributionGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateGauge(Iterable<MetricResult<GaugeResult>> gauges) {\n+\t\tfor (MetricResult<GaugeResult> metricResult : gauges) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\tGaugeResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkGauge gauge = flinkGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup = registerMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkGauge(update));\n+\t\t\t\tflinkGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic ArrayList getNameSpaceArray(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\ttry {\n+\t\t\treturn new ObjectMapper().readValue(metricName.getNamespace(), ArrayList.class);\n+\t\t} catch (JsonProcessingException e) {\n+\t\t\te.printStackTrace();", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMyNjM3Mw==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399326373", "bodyText": "ditto", "author": "dianfu", "createdAt": "2020-03-27T14:58:13Z", "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzMDMwMg==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399330302", "bodyText": "Change to the following then it will only lookup the map once:\ncounter = flinkCounterCache.get(flinkMetricIdentifier);\nif (counter == null) {\nXXX\n}", "author": "dianfu", "createdAt": "2020-03-27T15:03:23Z", "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM0NDY5Nw==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399344697", "bodyText": "this#flinkCounterCache -> #flinkCounterCache", "author": "dianfu", "createdAt": "2020-03-27T15:23:38Z", "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM0ODEzNQ==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399348135", "bodyText": "Integer.valueOf -> Integer.parseInt", "author": "dianfu", "createdAt": "2020-03-27T15:28:27Z", "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MTExNg==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399351116", "bodyText": "private?", "author": "dianfu", "createdAt": "2020-03-27T15:32:43Z", "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tcounter = metricGroup.counter(metricResult.getKey().metricName().getName());\n+\t\t\t\t\tflinkCounterCache.put(flinkMetricIdentifier, counter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tcounter.inc(update - counter.getCount());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateDistributions(Iterable<MetricResult<DistributionResult>> distributions) {\n+\t\tfor (MetricResult<DistributionResult> metricResult : distributions) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\t\t\tDistributionResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkDistributionGauge gauge = flinkDistributionGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkDistributionGauge(update));\n+\t\t\t\tflinkDistributionGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateGauge(Iterable<MetricResult<GaugeResult>> gauges) {\n+\t\tfor (MetricResult<GaugeResult> metricResult : gauges) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\tGaugeResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkGauge gauge = flinkGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup = registerMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkGauge(update));\n+\t\t\t\tflinkGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic ArrayList getNameSpaceArray(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\ttry {\n+\t\t\treturn new ObjectMapper().readValue(metricName.getNamespace(), ArrayList.class);\n+\t\t} catch (JsonProcessingException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tthrow new RuntimeException(String.format(\"Parse namespace[%s] error. \", metricName.getNamespace()));\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic String getFlinkMetricIdentifierString(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tList<String> results = scopeComponents.subList(0, scopeComponents.size() / 2);\n+\t\tresults.add(metricName.getName());\n+\t\treturn String.join(METRIC_KEY_SEPARATOR, results);\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic MetricGroup registerMetricGroup(MetricKey metricKey, MetricGroup metricGroup) {\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tint size = scopeComponents.size();\n+\t\tList<String> metricGroupNames = scopeComponents.subList(0, size / 2);\n+\t\tList<String> metricGroupTypes = scopeComponents.subList(size / 2, size);\n+\t\tfor (int i = 0; i < metricGroupNames.size(); ++i) {\n+\t\t\tif (metricGroupTypes.get(i).equals(\"MetricGroupType.generic\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(metricGroupNames.get(i));\n+\t\t\t} else if (metricGroupTypes.get(i).equals(\"MetricGroupType.key\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(\n+\t\t\t\t\tmetricGroupNames.get(i),\n+\t\t\t\t\tmetricGroupNames.get(++i));\n+\t\t\t}\n+\t\t}\n+\t\treturn metricGroup;\n+\t}\n+\n+\t/**\n+\t * Flink {@link Gauge} for {@link DistributionResult}.\n+\t */\n+\tpublic static class FlinkDistributionGauge implements Gauge<DistributionResult> {\n+\n+\t\tDistributionResult data;", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MTIzOQ==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399351239", "bodyText": "private?", "author": "dianfu", "createdAt": "2020-03-27T15:32:51Z", "path": "flink-python/src/main/java/org/apache/flink/python/metric/FlinkMetricContainer.java", "diffHunk": "@@ -19,17 +19,267 @@\n package org.apache.flink.python.metric;\n \n import org.apache.flink.annotation.Internal;\n+import org.apache.flink.configuration.GlobalConfiguration;\n+import org.apache.flink.configuration.MetricOptions;\n+import org.apache.flink.metrics.Counter;\n+import org.apache.flink.metrics.Gauge;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n import org.apache.flink.metrics.MetricGroup;\n \n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.metrics.MetricsContainerImpl;\n+import org.apache.beam.runners.core.metrics.MetricsContainerStepMap;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoMetricName;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.GaugeResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.sdk.metrics.MetricQueryResults;\n+import org.apache.beam.sdk.metrics.MetricResult;\n+import org.apache.beam.sdk.metrics.MetricResults;\n+import org.apache.beam.sdk.metrics.MetricsFilter;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.beam.runners.core.metrics.MetricsContainerStepMap.asAttemptedOnlyMetricResults;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n /**\n  * Helper class for forwarding Python metrics to Java accumulators and metrics.\n  */\n @Internal\n-public class FlinkMetricContainer {\n+public final class FlinkMetricContainer {\n+\n+\tprivate static final String METRIC_KEY_SEPARATOR =\n+\t\tGlobalConfiguration.loadConfiguration().getString(MetricOptions.SCOPE_DELIMITER);\n \n+\tprivate final MetricsContainerStepMap metricsContainers;\n \tprivate final MetricGroup baseMetricGroup;\n+\tprivate final Map<String, Counter> flinkCounterCache;\n+\tprivate final Map<String, Meter> flinkMeterCache;\n+\tprivate final Map<String, FlinkDistributionGauge> flinkDistributionGaugeCache;\n+\tprivate final Map<String, FlinkGauge> flinkGaugeCache;\n \n \tpublic FlinkMetricContainer(MetricGroup metricGroup) {\n-\t\tthis.baseMetricGroup = metricGroup;\n+\t\tthis.baseMetricGroup = checkNotNull(metricGroup);\n+\t\tthis.flinkCounterCache = new HashMap<>();\n+\t\tthis.flinkMeterCache = new HashMap<>();\n+\t\tthis.flinkDistributionGaugeCache = new HashMap<>();\n+\t\tthis.flinkGaugeCache = new HashMap<>();\n+\t\tthis.metricsContainers = new MetricsContainerStepMap();\n+\t}\n+\n+\tprivate MetricsContainerImpl getMetricsContainer(String stepName) {\n+\t\treturn metricsContainers.getContainer(stepName);\n+\t}\n+\n+\t/**\n+\t * Update this container with metrics from the passed {@link MonitoringInfo}s, and send updates\n+\t * along to Flink's internal metrics framework.\n+\t */\n+\tpublic void updateMetrics(String stepName, List<MonitoringInfo> monitoringInfos) {\n+\t\tgetMetricsContainer(stepName).update(monitoringInfos);\n+\t\tupdateMetrics(stepName);\n+\t}\n+\n+\t/**\n+\t * Update Flink's internal metrics ({@link this#flinkCounterCache}) with the latest metrics for\n+\t * a given step.\n+\t */\n+\tprivate void updateMetrics(String stepName) {\n+\t\tMetricResults metricResults = asAttemptedOnlyMetricResults(metricsContainers);\n+\t\tMetricQueryResults metricQueryResults =\n+\t\t\tmetricResults.queryMetrics(MetricsFilter.builder().addStep(stepName).build());\n+\t\tupdateCounterOrMeter(metricQueryResults.getCounters());\n+\t\tupdateDistributions(metricQueryResults.getDistributions());\n+\t\tupdateGauge(metricQueryResults.getGauges());\n+\t}\n+\n+\tprivate boolean isUserMetric(MetricResult metricResult) {\n+\t\tMetricName metricName = metricResult.getKey().metricName();\n+\t\treturn (metricName instanceof MonitoringInfoMetricName) &&\n+\t\t\t((MonitoringInfoMetricName) metricName).getUrn()\n+\t\t\t\t.contains(MonitoringInfoConstants.Urns.USER_COUNTER);\n+\t}\n+\n+\tprivate void updateCounterOrMeter(Iterable<MetricResult<Long>> counters) {\n+\t\tfor (MetricResult<Long> metricResult : counters) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\t// get metric type\n+\t\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricResult.getKey());\n+\t\t\tif ((scopeComponents.size() % 2) != 0) {\n+\t\t\t\tMeter meter;\n+\t\t\t\tif (flinkMeterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tmeter = flinkMeterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tint timeSpanInSeconds =\n+\t\t\t\t\t\tInteger.valueOf(scopeComponents.get(scopeComponents.size() - 1));\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tmeter = metricGroup.meter(\n+\t\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\t\tnew MeterView(timeSpanInSeconds));\n+\t\t\t\t\tflinkMeterCache.put(flinkMetricIdentifier, meter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tmeter.markEvent(update);\n+\t\t\t} else {\n+\t\t\t\tCounter counter;\n+\t\t\t\tif (flinkCounterCache.containsKey(flinkMetricIdentifier)) {\n+\t\t\t\t\tcounter = flinkCounterCache.get(flinkMetricIdentifier);\n+\t\t\t\t} else {\n+\t\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\t\tcounter = metricGroup.counter(metricResult.getKey().metricName().getName());\n+\t\t\t\t\tflinkCounterCache.put(flinkMetricIdentifier, counter);\n+\t\t\t\t}\n+\n+\t\t\t\tLong update = metricResult.getAttempted();\n+\t\t\t\tcounter.inc(update - counter.getCount());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateDistributions(Iterable<MetricResult<DistributionResult>> distributions) {\n+\t\tfor (MetricResult<DistributionResult> metricResult : distributions) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\t\t\tDistributionResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkDistributionGauge gauge = flinkDistributionGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup =\n+\t\t\t\t\tregisterMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkDistributionGauge(update));\n+\t\t\t\tflinkDistributionGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateGauge(Iterable<MetricResult<GaugeResult>> gauges) {\n+\t\tfor (MetricResult<GaugeResult> metricResult : gauges) {\n+\t\t\tif (!isUserMetric(metricResult)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t// get identifier\n+\t\t\tString flinkMetricIdentifier = getFlinkMetricIdentifierString(metricResult.getKey());\n+\n+\t\t\tGaugeResult update = metricResult.getAttempted();\n+\n+\t\t\t// update flink metric\n+\t\t\tFlinkGauge gauge = flinkGaugeCache.get(flinkMetricIdentifier);\n+\t\t\tif (gauge == null) {\n+\t\t\t\tMetricGroup metricGroup = registerMetricGroup(metricResult.getKey(), baseMetricGroup);\n+\t\t\t\tgauge = metricGroup.gauge(\n+\t\t\t\t\tmetricResult.getKey().metricName().getName(),\n+\t\t\t\t\tnew FlinkGauge(update));\n+\t\t\t\tflinkGaugeCache.put(flinkMetricIdentifier, gauge);\n+\t\t\t} else {\n+\t\t\t\tgauge.update(update);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic ArrayList getNameSpaceArray(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\ttry {\n+\t\t\treturn new ObjectMapper().readValue(metricName.getNamespace(), ArrayList.class);\n+\t\t} catch (JsonProcessingException e) {\n+\t\t\te.printStackTrace();\n+\t\t\tthrow new RuntimeException(String.format(\"Parse namespace[%s] error. \", metricName.getNamespace()));\n+\t\t}\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic String getFlinkMetricIdentifierString(MetricKey metricKey) {\n+\t\tMetricName metricName = metricKey.metricName();\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tList<String> results = scopeComponents.subList(0, scopeComponents.size() / 2);\n+\t\tresults.add(metricName.getName());\n+\t\treturn String.join(METRIC_KEY_SEPARATOR, results);\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic MetricGroup registerMetricGroup(MetricKey metricKey, MetricGroup metricGroup) {\n+\t\tArrayList<String> scopeComponents = getNameSpaceArray(metricKey);\n+\t\tint size = scopeComponents.size();\n+\t\tList<String> metricGroupNames = scopeComponents.subList(0, size / 2);\n+\t\tList<String> metricGroupTypes = scopeComponents.subList(size / 2, size);\n+\t\tfor (int i = 0; i < metricGroupNames.size(); ++i) {\n+\t\t\tif (metricGroupTypes.get(i).equals(\"MetricGroupType.generic\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(metricGroupNames.get(i));\n+\t\t\t} else if (metricGroupTypes.get(i).equals(\"MetricGroupType.key\")) {\n+\t\t\t\tmetricGroup = metricGroup.addGroup(\n+\t\t\t\t\tmetricGroupNames.get(i),\n+\t\t\t\t\tmetricGroupNames.get(++i));\n+\t\t\t}\n+\t\t}\n+\t\treturn metricGroup;\n+\t}\n+\n+\t/**\n+\t * Flink {@link Gauge} for {@link DistributionResult}.\n+\t */\n+\tpublic static class FlinkDistributionGauge implements Gauge<DistributionResult> {\n+\n+\t\tDistributionResult data;\n+\n+\t\tFlinkDistributionGauge(DistributionResult data) {\n+\t\t\tthis.data = data;\n+\t\t}\n+\n+\t\tvoid update(DistributionResult data) {\n+\t\t\tthis.data = data;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic DistributionResult getValue() {\n+\t\t\treturn data;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Flink {@link Gauge} for {@link GaugeResult}.\n+\t */\n+\tpublic static class FlinkGauge implements Gauge<Long> {\n+\n+\t\tGaugeResult data;", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1MzIyMg==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399353222", "bodyText": "private?", "author": "dianfu", "createdAt": "2020-03-27T15:35:40Z", "path": "flink-python/src/test/java/org/apache/flink/python/metric/FlinkMetricContainerTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.python.metric;\n+\n+import org.apache.flink.api.common.functions.RuntimeContext;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n+import org.apache.flink.metrics.MetricGroup;\n+import org.apache.flink.metrics.SimpleCounter;\n+import org.apache.flink.runtime.metrics.MetricRegistry;\n+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;\n+import org.apache.flink.runtime.metrics.groups.GenericMetricGroup;\n+import org.apache.flink.runtime.metrics.groups.MetricGroupTest;\n+\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi;\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.construction.BeamUrns;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.SimpleMonitoringInfoBuilder;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests for {@link FlinkMetricContainer}.\n+ */\n+public class FlinkMetricContainerTest {\n+\n+\t@Mock\n+\tprivate RuntimeContext runtimeContext;\n+\t@Mock\n+\tprivate MetricGroup metricGroup;\n+\n+\tFlinkMetricContainer container;", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1Mzg1NA==", "url": "https://github.com/apache/flink/pull/11543#discussion_r399353854", "bodyText": "The throws could be removed", "author": "dianfu", "createdAt": "2020-03-27T15:36:36Z", "path": "flink-python/src/test/java/org/apache/flink/python/metric/FlinkMetricContainerTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.python.metric;\n+\n+import org.apache.flink.api.common.functions.RuntimeContext;\n+import org.apache.flink.metrics.Meter;\n+import org.apache.flink.metrics.MeterView;\n+import org.apache.flink.metrics.MetricGroup;\n+import org.apache.flink.metrics.SimpleCounter;\n+import org.apache.flink.runtime.metrics.MetricRegistry;\n+import org.apache.flink.runtime.metrics.NoOpMetricRegistry;\n+import org.apache.flink.runtime.metrics.groups.GenericMetricGroup;\n+import org.apache.flink.runtime.metrics.groups.MetricGroupTest;\n+\n+import org.apache.flink.shaded.jackson2.com.fasterxml.jackson.core.JsonProcessingException;\n+\n+import org.apache.beam.model.pipeline.v1.MetricsApi;\n+import org.apache.beam.model.pipeline.v1.MetricsApi.MonitoringInfo;\n+import org.apache.beam.runners.core.construction.BeamUrns;\n+import org.apache.beam.runners.core.metrics.MonitoringInfoConstants;\n+import org.apache.beam.runners.core.metrics.SimpleMonitoringInfoBuilder;\n+import org.apache.beam.sdk.metrics.DistributionResult;\n+import org.apache.beam.sdk.metrics.MetricKey;\n+import org.apache.beam.sdk.metrics.MetricName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests for {@link FlinkMetricContainer}.\n+ */\n+public class FlinkMetricContainerTest {\n+\n+\t@Mock\n+\tprivate RuntimeContext runtimeContext;\n+\t@Mock\n+\tprivate MetricGroup metricGroup;\n+\n+\tFlinkMetricContainer container;\n+\n+\tprivate static final String GAUGE_URN =\n+\t\tBeamUrns.getUrn(MetricsApi.MonitoringInfoTypeUrns.Enum.LATEST_INT64_TYPE);\n+\n+\tprivate static final List<String> DEFAULT_SCOPE_COMPONENTS = Arrays.asList(\n+\t\t\"key\",\n+\t\t\"value\",\n+\t\t\"MetricGroupType.key\",\n+\t\t\"MetricGroupType.value\");\n+\n+\tprivate static final String DEFAULT_NAMESPACE =\n+\t\t\"[\\\"key\\\", \\\"value\\\", \\\"MetricGroupType.key\\\", \\\"MetricGroupType.value\\\"]\";\n+\n+\t@Before\n+\tpublic void beforeTest() {\n+\t\tMockitoAnnotations.initMocks(this);\n+\t\twhen(runtimeContext.getMetricGroup()).thenReturn(metricGroup);\n+\t\twhen(metricGroup.addGroup(any(), any())).thenReturn(metricGroup);\n+\t\twhen(metricGroup.addGroup(any())).thenReturn(metricGroup);\n+\t\tcontainer = new FlinkMetricContainer(runtimeContext.getMetricGroup());\n+\t}\n+\n+\t@Test\n+\tpublic void testGetNameSpaceArray() throws JsonProcessingException {", "originalCommit": "7b8750cdb19d7ffe6dddd9e7aa8eacc320b7dee5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b4566191e46ade55d78c10ab3102e075e969f4d", "url": "https://github.com/apache/flink/commit/8b4566191e46ade55d78c10ab3102e075e969f4d", "message": "address comments", "committedDate": "2020-03-29T11:39:04Z", "type": "commit"}, {"oid": "1bc76b91c0b79817117f1b796ea461126ad16e0a", "url": "https://github.com/apache/flink/commit/1bc76b91c0b79817117f1b796ea461126ad16e0a", "message": "update", "committedDate": "2020-03-30T04:04:18Z", "type": "commit"}, {"oid": "cb31a07d5c8e76efaf0cf3ad525bf913b731cce6", "url": "https://github.com/apache/flink/commit/cb31a07d5c8e76efaf0cf3ad525bf913b731cce6", "message": "remove useless import", "committedDate": "2020-03-30T06:03:58Z", "type": "commit"}]}