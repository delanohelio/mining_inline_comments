{"pr_number": 11877, "pr_title": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "pr_createdAt": "2020-04-23T08:37:09Z", "pr_url": "https://github.com/apache/flink/pull/11877", "timeline": [{"oid": "929403a9ae1b734c4e72a4585862f994d8c1f5e9", "url": "https://github.com/apache/flink/commit/929403a9ae1b734c4e72a4585862f994d8c1f5e9", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-04-23T10:40:36Z", "type": "forcePushed"}, {"oid": "ca6f75c37da358874cc38d7998bce5c4445feff5", "url": "https://github.com/apache/flink/commit/ca6f75c37da358874cc38d7998bce5c4445feff5", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-04-27T06:28:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422466188", "bodyText": "Make the following condition out of synchronized part, then we do not need to touch the lock for most of the cases.\nCheckpointOptions options = barrier.getCheckpointOptions();\nif (!(initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()))  {\n     return;\n}", "author": "zhijiangW", "createdAt": "2020-05-09T07:54:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -428,6 +423,23 @@ public void notifyBufferDestroyed() {\n \t\t// Nothing to do actually.\n \t}\n \n+\t@Override\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3MDcyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422970729", "bodyText": "It might be better to trigger this action by netty thread when received this barrier immediately. Otherwise the task processing might delay much time to better reuse the floating buffers for other channels.", "author": "zhijiangW", "createdAt": "2020-05-11T11:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3MjYyMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422972620", "bodyText": "Considering the race condition between this operation and canceler task, it might involve in potential conflicts and deadlock case if removeBufferListener and adjust isWaitingForFloatingBuffers here. Let me think whether we can lazy remove the listener and adjust isWaitingForFloatingBuffers by reusing the existing process RemoteInputChannel#notifyBufferAvailable.", "author": "zhijiangW", "createdAt": "2020-05-11T11:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NjE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0NzQyMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422847423", "bodyText": "The different message path is distinguished in both PartitionRequestQueue and CreditBasedSequenceNumberingViewReader now. We can improve it to judge only in one place instead.\n\nIntroduce ServerOutboundMessage class to extend NettyMessage and make AddBacklog and BufferResponse both extend ServerOutboundMessage.\nIntroduce NetworkSequenceViewReader#getNextMessage instead of existing NetworkSequenceViewReader#getNextBuffer. And inside CreditBasedSequenceNumberingViewReader implementation, we can judge the condition for distinguish.\n\npublic NettyMessage.ServerOutboundMessage getNextMessage() throws IOException {\n\t\tif (numCreditsAvailable == 0 && initialCredit == 0 && !subpartitionView.isAvailable(numCreditsAvailable)) {\n\t\t\treturn getBacklogMessage();\n\t\t} else {\n\t\t\treturn getNextBufferResponse();\n\t\t}\n\t}\n\nTo do so we can also reduce the necessary transformation between BufferAndAvailability and BufferResponse.", "author": "zhijiangW", "createdAt": "2020-05-11T07:47:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -234,11 +236,16 @@ private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IO\n \t\t\t\t\t\tregisterAvailableReader(reader);\n \t\t\t\t\t}\n \n-\t\t\t\t\tBufferResponse msg = new BufferResponse(\n-\t\t\t\t\t\tnext.buffer(),\n-\t\t\t\t\t\treader.getSequenceNumber(),\n-\t\t\t\t\t\treader.getReceiverId(),\n-\t\t\t\t\t\tnext.buffersInBacklog());\n+\t\t\t\t\tObject msg;\n+\t\t\t\t\tif (next.buffer() != null) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MzY5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422863695", "bodyText": "The previous buffersInBacklog variable should be replaced by this new variable, to avoid maintaining two variables.", "author": "zhijiangW", "createdAt": "2020-05-11T08:16:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -70,6 +70,10 @@\n \t@GuardedBy(\"buffers\")\n \tprivate int buffersInBacklog;\n \n+\t/** The number of non-event buffers to be announced to the downstream. */\n+\t@GuardedBy(\"buffers\")\n+\tprivate int unannouncedBacklog;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NDk4MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422864980", "bodyText": "buffersInBacklog and unannouncedBacklog should be retained only one finally.", "author": "zhijiangW", "createdAt": "2020-05-11T08:18:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultSubpartition.java", "diffHunk": "@@ -158,11 +158,18 @@ public boolean add(BufferConsumer bufferConsumer) throws IOException {\n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean isDataAvailable;\n \t\tprivate final int buffersInBacklog;\n+\t\tprivate final int unannouncedBacklog;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2ODk4Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422868983", "bodyText": "why we need to trigger announce backlog while adding credit?\nI assume since the added creditDeltas is always more than zero, then we have the chance to announce the backlog later via sending BufferResponse.", "author": "zhijiangW", "createdAt": "2020-05-11T08:25:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,27 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\treturn shouldAnnounceBacklog();", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDQyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r423500427", "bodyText": "You are right shouldAnnounceBacklog always return false, I will replace the function call with return false. The reason why we need to change return type of addCredit is that we can't identify whether we are calling addCredit or resumeConsumption in PartitionRequestQueue.", "author": "wsry", "createdAt": "2020-05-12T06:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2ODk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4NDU1MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422884550", "bodyText": "We can also avoid introducing nullable buffer by this comment https://github.com/apache/flink/pull/11877/files#r422847423", "author": "zhijiangW", "createdAt": "2020-05-11T08:51:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputChannel.java", "diffHunk": "@@ -305,19 +311,18 @@ protected CheckpointBarrier parseCheckpointBarrierOrNull(Buffer buffer) throws I\n \n \t/**\n \t * A combination of a {@link Buffer} and a flag indicating availability of further buffers,\n-\t * and the backlog length indicating how many non-event buffers are available in the\n-\t * subpartition.\n+\t * and the backlog length indicating how many credits the subpartition.\n \t */\n \tpublic static final class BufferAndAvailability {\n \n \t\tprivate final Buffer buffer;\n \t\tprivate final boolean moreAvailable;\n-\t\tprivate final int buffersInBacklog;\n+\t\tprivate final int backlog;\n \n-\t\tpublic BufferAndAvailability(Buffer buffer, boolean moreAvailable, int buffersInBacklog) {\n-\t\t\tthis.buffer = checkNotNull(buffer);\n+\t\tpublic BufferAndAvailability(@Nullable Buffer buffer, boolean moreAvailable, int backlog) {", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4OTAyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422889022", "bodyText": "I guess this check is not necessary or invalid.", "author": "zhijiangW", "createdAt": "2020-05-11T08:57:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,27 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic boolean addCredit(int creditDeltas) {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\treturn shouldAnnounceBacklog();\n+\t}\n+\n+\t@Override\n+\tpublic boolean shouldAnnounceBacklog() {\n+\t\treturn initialCredit == 0 && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic boolean resumeConsumption(int availableCredit, int unfulfilledBacklog) {\n+\t\tif (initialCredit > 0) {\n+\t\t\tcheckState(numCreditsAvailable == availableCredit, \"Illegal number of available credit.\");", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1MDcxMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r422950710", "bodyText": "nit: might rename to numRequiredFloatingBuffers for better reflecting the current semantic.", "author": "zhijiangW", "createdAt": "2020-05-11T10:44:35Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -99,7 +100,7 @@\n \t/** The number of available buffers that have not been announced to the producer yet. */\n \tprivate final AtomicInteger unannouncedCredit = new AtomicInteger(0);\n \n-\t/** The number of required buffers that equals to sender's backlog plus initial credit. */\n+\t/** The number of buffers to requested that equals to unfulfilled sender's backlog. */\n \t@GuardedBy(\"bufferQueue\")\n \tprivate int numRequiredBuffers;", "originalCommit": "ca6f75c37da358874cc38d7998bce5c4445feff5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3046802f6bfcf476af447fffbc9af3f20a96ed61", "url": "https://github.com/apache/flink/commit/3046802f6bfcf476af447fffbc9af3f20a96ed61", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-12T13:04:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1NjQyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424156429", "bodyText": "fix the javadoc accordingly.", "author": "zhijiangW", "createdAt": "2020-05-13T03:46:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -127,7 +127,7 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \t/**\n \t * Requests exclusive buffers from the provider and returns the number of requested amount.", "originalCommit": "8a9dba521dd41e70cb5c4be10669372b1c674d22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1NzE1Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424157153", "bodyText": "It is better to supplement the similar check to avoid this action is called multiple times in practice.\nMaybe we can check the available exclusive buffers should be 0 in BufferManager instead?", "author": "zhijiangW", "createdAt": "2020-05-13T03:49:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -122,10 +124,7 @@ public RemoteInputChannel(\n \t * after this input channel is created.\n \t */\n \tvoid assignExclusiveSegments() throws IOException {\n-\t\tcheckState(initialCredit == 0, \"Bug in input channel setup logic: exclusive buffers have \" +", "originalCommit": "8a9dba521dd41e70cb5c4be10669372b1c674d22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fc3e9f5b7933d0b74b53946e6f506916f73aba14", "url": "https://github.com/apache/flink/commit/fc3e9f5b7933d0b74b53946e6f506916f73aba14", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T03:57:50Z", "type": "forcePushed"}, {"oid": "708b2ceb97564084900c555d6f38e6ba1174d735", "url": "https://github.com/apache/flink/commit/708b2ceb97564084900c555d6f38e6ba1174d735", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T04:00:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2MzEyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424163129", "bodyText": "numberOfSegmentsToRequest  should never be negative because we already check this argument in constructor.\nif (numberOfSegmentsToRequest == 0) instead?", "author": "zhijiangW", "createdAt": "2020-05-13T04:16:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/NetworkBufferPool.java", "diffHunk": "@@ -162,6 +162,10 @@ public void recycle(MemorySegment segment) {\n \n \t@Override\n \tpublic List<MemorySegment> requestMemorySegments() throws IOException {\n+\t\tif (numberOfSegmentsToRequest <= 0) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2MzQyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424163429", "bodyText": "nit: import NettyMessage.AddBacklog because it occurs many times in this part.", "author": "zhijiangW", "createdAt": "2020-05-13T04:17:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -291,6 +290,11 @@ private void decodeMsg(Object msg) throws Throwable {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n+\t\t} else if (msgClazz == NettyMessage.AddBacklog.class) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424164395", "bodyText": "this change should be together with the previous hotfix commit \" making initialCredit as final\"", "author": "zhijiangW", "createdAt": "2020-05-13T04:22:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -129,7 +132,6 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \t */\n \tvoid requestExclusiveBuffers() throws IOException {\n \t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n-\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI4NDM4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424284387", "bodyText": "Before the last commit, we can't set numExclusive buffers to 0, so the check should be reserved before the last commit.", "author": "wsry", "createdAt": "2020-05-13T09:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkxMTkwMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424911901", "bodyText": "Got it. So do you think we add the if (initialCredit > 0) before calling this method inside RemoteInputChannel#assignExclusiveSegments?  Just for not necessary to synchronized below for empty segments.", "author": "zhijiangW", "createdAt": "2020-05-14T07:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NDM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NTEwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424165102", "bodyText": "This renaming is not necessary.\nBufferManager is abstracted as a general purpose, not coupled with credit-based process, so it is better to not define a argument strongly related to credit-based purpose. numRequired seems more general to describe the semantic.", "author": "zhijiangW", "createdAt": "2020-05-13T04:25:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -139,10 +141,10 @@ void requestExclusiveBuffers() throws IOException {\n \t}\n \n \t/**\n-\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * Requests floating buffers from the buffer pool based on the given backlog, and returns the actual\n \t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n \t */\n-\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\tint requestFloatingBuffers(int backlog) throws IOException {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2NzY5OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424167698", "bodyText": "Keep in mind that BufferManager is only for buffer request/release related operations, so it should not understand the other specific logics which should be done inside the respective InputChannel. Otherwise we would dirty this component and have ambiguous definition what is the role of this component.\nIn detail, the following should be done inside RemoteInputChannel\nCheckpointOptions options = barrier.getCheckpointOptions();\nif (initialCredit == 0 && options.isExactlyOnceMode() && !options.isUnalignedCheckpoint()) \n\nAnd rename  the method onCheckpointBarrier to distinguish with existing releaseFloatingBuffers(). From the perspective of outside caller, we should give a clear semantic method naming in order to be reused future.", "author": "zhijiangW", "createdAt": "2020-05-13T04:37:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +153,63 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(\n+\t\t\tInputChannelID channelID,\n+\t\t\tint initialCredit) throws IOException {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tcheckState(numRequiredBuffers >= 0, \"Number of required buffers should be non-negative.\");\n+\t\t\tcheckState(bufferQueue.getAvailableBufferSize() == initialCredit, \"Illegal number of available buffers.\");\n+\n+\t\t\tif (initialCredit > 0) {\n+\t\t\t\treturn new NettyMessage.ResumeConsumption(channelID, initialCredit, numRequiredBuffers);\n+\t\t\t}\n+\n+\t\t\tint numCredit = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numCredit;\n+\t\t\treturn new NettyMessage.ResumeConsumption(channelID, numCredit, numRequiredBuffers);\n+\t\t}\n+\t}\n+\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier, int initialCredit) {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE2ODI2NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424168264", "bodyText": "As mentioned in 708b2ce#r424167698, this logic should be done inside RemoteInputChannel, because the BufferManager should not understand the specific logics unless buffer request/release.", "author": "zhijiangW", "createdAt": "2020-05-13T04:39:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +153,63 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += backlog;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage(", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjkwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424182902", "bodyText": "resumeAndGetResumptionMessage() -> getResumeConsumptionMessage()", "author": "zhijiangW", "createdAt": "2020-05-13T05:36:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -334,6 +335,15 @@ public void resumeConsumption() {\n \t\tpartitionRequestClient.resumeConsumption(this);\n \t}\n \n+\t/**\n+\t * Called by netty thread to request buffers and generate {@link NettyMessage.ResumeConsumption} message.\n+\t */\n+\tpublic NettyMessage.ResumeConsumption resumeAndGetResumptionMessage() throws IOException {", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NjMwOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424186308", "bodyText": "Make this change a separate hotfix?", "author": "zhijiangW", "createdAt": "2020-05-13T05:48:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -415,11 +425,8 @@ public Buffer requestBuffer() {\n \t *\n \t * @param backlog The number of unsent buffers in the producer's sub partition.\n \t */\n-\tvoid onSenderBacklog(int backlog) throws IOException {\n-\t\tint numRequestedBuffers = bufferManager.requestFloatingBuffers(backlog + initialCredit);\n-\t\tif (numRequestedBuffers > 0 && unannouncedCredit.getAndAdd(numRequestedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n+\tpublic void onSenderBacklog(int backlog) throws IOException {\n+\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog));", "originalCommit": "708b2ceb97564084900c555d6f38e6ba1174d735", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "59b651c070adcca2b7e4e4a78e6b10411429c589", "url": "https://github.com/apache/flink/commit/59b651c070adcca2b7e4e4a78e6b10411429c589", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-13T10:25:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1MzQzOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424353439", "bodyText": "Actually the logic for adding credit does not need needAnnounceBacklog, so it might bring trouble to understand the logic of addCredit by reusing the common codes here.\nOne possible solution is to call enqueueAvailableReader in reader stack while applying the function, then the NetworkSequenceViewReader#addCredit and NetworkSequenceViewReader#resumeConsumption can judge the separate conditions before calling enqueueAvailableReader.", "author": "zhijiangW", "createdAt": "2020-05-13T11:04:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -145,20 +148,20 @@ public void close() throws IOException {\n \t * checkpoint and enqueues the corresponding reader for this consumer (if not enqueued yet).\n \t *\n \t * @param receiverId The input channel id to identify the consumer.\n-\t * @param operation The operation to be performed (add credit or resume data consumption).\n+\t * @param function The operation to be performed (add credit or resume data consumption).\n \t */\n \tvoid addCreditOrResumeConsumption(\n \t\t\tInputChannelID receiverId,\n-\t\t\tConsumer<NetworkSequenceViewReader> operation) throws Exception {\n+\t\t\tFunction<NetworkSequenceViewReader, Boolean> function) throws Exception {\n \t\tif (fatalError) {\n \t\t\treturn;\n \t\t}\n \n \t\tNetworkSequenceViewReader reader = allReaders.get(receiverId);\n \t\tif (reader != null) {\n-\t\t\toperation.accept(reader);\n+\t\t\tboolean needAnnounceBacklog = function.apply(reader);", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1Mzk0Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424353946", "bodyText": "To do so we can also avoid adjusting to return unnecessary boolean value for NetworkSequenceViewReader#addCredit", "author": "zhijiangW", "createdAt": "2020-05-13T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1MzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NDY4Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424354683", "bodyText": "Based on this comment, we might not need to bring announceBacklog argument in this method, to understand all the related processes together.", "author": "zhijiangW", "createdAt": "2020-05-13T11:07:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -94,10 +96,11 @@ void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader, boolean announceBacklog) throws Exception {\n+\t\tif (reader.isRegisteredAsAvailable() || (!reader.isAvailable() && !announceBacklog)) {", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NDk3NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424374975", "bodyText": "Renaming it to a boolean type withoutExclusiveCredits seems more direct to understand", "author": "zhijiangW", "createdAt": "2020-05-13T11:48:34Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -45,6 +47,8 @@\n \n \tprivate final PartitionRequestQueue requestQueue;\n \n+\tprivate final int initialCredit;", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDk0MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424860940", "bodyText": "nit: bufferReleased  -> numReleasedBuffers", "author": "zhijiangW", "createdAt": "2020-05-14T04:14:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +150,43 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += numRequired;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tif (isWaitingForFloatingBuffers) {\n+\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n+\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t}\n+\n+\t\t\tint bufferReleased = bufferQueue.releaseFloatingBuffers();", "originalCommit": "59b651c070adcca2b7e4e4a78e6b10411429c589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b0bc4fc762c88de29509bb7ffb16c71203327fa8", "url": "https://github.com/apache/flink/commit/b0bc4fc762c88de29509bb7ffb16c71203327fa8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T04:17:19Z", "type": "forcePushed"}, {"oid": "e033307ba22ee660cd6c39063896500075b60671", "url": "https://github.com/apache/flink/commit/e033307ba22ee660cd6c39063896500075b60671", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T04:22:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MzUyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424863522", "bodyText": "This method should be placed into the below section Buffer recycle.\nI think it is better to integrate this method with existing #releaseFloatingBuffers to provide a general one, otherwise it might bring confusing to understand the difference among them, especially for the different handle of numRequiredBuffers, to make them seem customized logic.\nThe integration is as below\nvoid releaseFloatingBuffers(boolean isTemporaryRelease) {\n\t\tsynchronized (bufferQueue) {\n\t\t\tif (isWaitingForFloatingBuffers) {\n\t\t\t\tinputChannel.inputGate.getBufferPool().removeBufferListener(this);\n\t\t\t\tisWaitingForFloatingBuffers = false;\n\t\t\t}\n\n\t\t\tint numReleasedBuffers = bufferQueue.releaseFloatingBuffers();\n\t\t\tif (isTemporaryRelease) {\n\t\t\t\tnumRequiredBuffers += numReleasedBuffers;\n\t\t\t} else {\n\t\t\t\tnumRequiredBuffers = 0;\n\t\t\t}\n\t\t}\n\t}", "author": "zhijiangW", "createdAt": "2020-05-14T04:25:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -151,23 +149,42 @@ int requestFloatingBuffers(int numRequired) throws IOException {\n \t\t\t\treturn numRequestedBuffers;\n \t\t\t}\n \n-\t\t\tnumRequiredBuffers = numRequired;\n+\t\t\tnumRequiredBuffers += numRequired;\n+\t\t\tnumRequestedBuffers = internalRequestFloatingBuffers(numRequiredBuffers);\n+\t\t\tnumRequiredBuffers -= numRequestedBuffers;\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n \n-\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n-\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n-\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n-\t\t\t\tif (buffer != null) {\n-\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n-\t\t\t\t\tnumRequestedBuffers++;\n-\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n-\t\t\t\t\tisWaitingForFloatingBuffers = true;\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n+\tprivate int internalRequestFloatingBuffers(int numBuffersToRequest) throws IOException {\n+\t\tassert Thread.holdsLock(bufferQueue);\n+\n+\t\tint numRequestedBuffers = 0;\n+\t\twhile (numRequestedBuffers < numBuffersToRequest && !isWaitingForFloatingBuffers) {\n+\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\tif (buffer != null) {\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\tnumRequestedBuffers++;\n+\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n \t\treturn numRequestedBuffers;\n \t}\n \n+\tpublic void unregisterBufferListenerAndReleaseFloatingBuffers() {", "originalCommit": "e033307ba22ee660cd6c39063896500075b60671", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NjA3Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424866076", "bodyText": "It should not be changed here. If the numRequiredBuffers is 0, getAvailableBufferSize() must be more than it. If numRequiredBuffers is 1 or something else, as long as the getAvailableBufferSize() is more than it, we also need to release a floating buffer.", "author": "zhijiangW", "createdAt": "2020-05-14T04:36:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -349,7 +373,7 @@ int unsynchronizedGetFloatingBuffersAvailable() {\n \t\t */\n \t\tint addExclusiveBuffer(Buffer buffer, int numRequiredBuffers) {\n \t\t\texclusiveBuffers.add(buffer);\n-\t\t\tif (getAvailableBufferSize() > numRequiredBuffers) {\n+\t\t\tif (numRequiredBuffers == 0) {", "originalCommit": "e033307ba22ee660cd6c39063896500075b60671", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "url": "https://github.com/apache/flink/commit/10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T06:16:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5OTUxNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424899517", "bodyText": "make it only private method inside RemoteInputChannel, because it is never used outside.", "author": "zhijiangW", "createdAt": "2020-05-14T06:32:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -327,6 +322,14 @@ public void notifyBufferAvailable(int numAvailableBuffers) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void onCheckpointBarrier(CheckpointBarrier barrier) {", "originalCommit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkwMjAyNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424902024", "bodyText": "nit: also adjust the javadoc of this method accordingly.", "author": "zhijiangW", "createdAt": "2020-05-14T06:38:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -418,8 +437,8 @@ public Buffer requestBuffer() {\n \t *\n \t * @param backlog The number of unsent buffers in the producer's sub partition.\n \t */\n-\tvoid onSenderBacklog(int backlog) throws IOException {\n-\t\tnotifyBufferAvailable(bufferManager.requestFloatingBuffers(backlog + initialCredit));\n+\tpublic void onSenderBacklog(int backlog) throws IOException {", "originalCommit": "10deae9993244cb215af6f0bb3bd6a9b0f9ef9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkwNjk3Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r424906972", "bodyText": "unsynchronizedGetAvailableExclusiveBuffers?", "author": "zhijiangW", "createdAt": "2020-05-14T06:49:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -313,7 +313,7 @@ int getNumberOfAvailableBuffers() {\n \t\t}\n \t}\n \n-\tint unsynchronizedGetExclusiveBuffersUsed() {\n+\tint unsynchronizedGetExclusiveBuffers() {", "originalCommit": "2ea543cf392fb1f2d8d7691fa358a93b6765d195", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2cb05ba959c5ac264eb8fa85d711f499301ed767", "url": "https://github.com/apache/flink/commit/2cb05ba959c5ac264eb8fa85d711f499301ed767", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:43:23Z", "type": "forcePushed"}, {"oid": "a933d700d53457d7743252c2a3c735a04fbd87f8", "url": "https://github.com/apache/flink/commit/a933d700d53457d7743252c2a3c735a04fbd87f8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:47:15Z", "type": "forcePushed"}, {"oid": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "url": "https://github.com/apache/flink/commit/ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T09:52:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MjA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425072084", "bodyText": "remove moreAvailable argument from the constructor, because it seems strange for AddBacklogMessage, then we can give false in below super instead.", "author": "zhijiangW", "createdAt": "2020-05-14T11:41:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -328,4 +325,67 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t/**\n+\t * Outbound message to be sent to the client.\n+\t */\n+\tpublic static abstract class ServerOutboundMessage {\n+\t\tprotected final InputChannelID receiverId;\n+\t\tprotected final int backlog;\n+\t\tprivate final boolean moreAvailable;\n+\n+\t\tServerOutboundMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {\n+\t\t\tcheckArgument(backlog >= 0, \"Number of backlog must be non-negative.\");\n+\t\t\tthis.receiverId = checkNotNull(receiverId);\n+\t\t\tthis.backlog = backlog;\n+\t\t\tthis.moreAvailable = moreAvailable;\n+\t\t}\n+\n+\t\tabstract Object build();\n+\n+\t\tpublic boolean isMoreAvailable() {\n+\t\t\treturn moreAvailable;\n+\t\t}\n+\n+\t\tvoid recycleBufferIfNeeded() {\n+\t\t}\n+\t}\n+\n+\tstatic class BufferResponseMessage extends ServerOutboundMessage {\n+\t\tprivate final Buffer buffer;\n+\t\tprivate final int sequenceNumber;\n+\n+\t\tBufferResponseMessage(\n+\t\t\t\tBuffer buffer,\n+\t\t\t\tInputChannelID receiverId,\n+\t\t\t\tint sequenceNumber,\n+\t\t\t\tint backlog,\n+\t\t\t\tboolean moreAvailable) {\n+\t\t\tsuper(receiverId, backlog, moreAvailable);\n+\t\t\tthis.buffer = checkNotNull(buffer);\n+\t\t\tthis.sequenceNumber = sequenceNumber;\n+\t\t}\n+\n+\t\t@Override\n+\t\tObject build() {\n+\t\t\treturn new BufferResponse(buffer, sequenceNumber, receiverId, backlog);\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid recycleBufferIfNeeded() {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\tstatic class AddBacklogMessage extends ServerOutboundMessage {\n+\n+\t\tAddBacklogMessage(InputChannelID receiverId, int backlog, boolean moreAvailable) {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3MzA2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425073066", "bodyText": "Adjust the javadoc accordingly", "author": "zhijiangW", "createdAt": "2020-05-14T11:43:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -94,10 +97,11 @@ void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {\n \t * <p>NOTE: Only one thread would trigger the actual enqueue after checking the reader's\n \t * availability, so there is no race condition here.\n \t */\n-\tprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n-\t\tif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\n+\tvoid enqueueAvailableReader(final NetworkSequenceViewReader reader, BooleanSupplier condition) throws Exception {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODUyMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425078522", "bodyText": "I guess we should not expect null return here. As long as the code path enters getAddBacklogMessage, then we should guarantee that the respective backlog should be more than 0.\nMaybe add assert backlog instead?", "author": "zhijiangW", "createdAt": "2020-05-14T11:53:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -163,8 +172,15 @@ boolean hasBuffersAvailable() {\n \t\treturn subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n-\t@Override\n-\tpublic BufferAndAvailability getNextBuffer() throws IOException {\n+\tprivate AddBacklogMessage getAddBacklogMessage() {\n+\t\tint backlog = subpartitionView.getAndResetUnannouncedBacklog();\n+\t\tif (backlog > 0) {\n+\t\t\treturn new AddBacklogMessage(receiverId, backlog, false);\n+\t\t}\n+\t\treturn null;", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTExNzEzNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425117136", "bodyText": "It can be null because of redundant data available notification.", "author": "wsry", "createdAt": "2020-05-14T13:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3ODcwNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425078707", "bodyText": "initialCredit  == 0", "author": "zhijiangW", "createdAt": "2020-05-14T11:54:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -69,6 +73,7 @@\n \t\tthis.receiverId = receiverId;\n \t\tthis.numCreditsAvailable = initialCredit;\n \t\tthis.requestQueue = requestQueue;\n+\t\tthis.withoutExclusiveCredits = initialCredit > 0;", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTMzOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r425079339", "bodyText": "nit: availableCredit -> availableCredits", "author": "zhijiangW", "createdAt": "2020-05-14T11:55:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -94,13 +99,22 @@ public void requestSubpartitionView(\n \t}\n \n \t@Override\n-\tpublic void addCredit(int creditDeltas) {\n+\tpublic void addCredit(int creditDeltas) throws Exception {\n \t\tnumCreditsAvailable += creditDeltas;\n+\t\trequestQueue.enqueueAvailableReader(this, this::isAvailable);\n+\t}\n+\n+\t@Override\n+\tpublic boolean shouldAnnounceBacklog() {\n+\t\treturn !withoutExclusiveCredits && numCreditsAvailable == 0 && subpartitionView.isAvailable(Integer.MAX_VALUE);\n \t}\n \n \t@Override\n-\tpublic void resumeConsumption() {\n+\tpublic void resumeConsumption(int availableCredit, boolean hasUnfulfilledBacklog) throws Exception {", "originalCommit": "ae90bc7d6d3753da3e9bbadcc99c80a152801e43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb4c607a5c4780729143d458b1c7633adcba59bf", "url": "https://github.com/apache/flink/commit/fb4c607a5c4780729143d458b1c7633adcba59bf", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-14T13:08:16Z", "type": "forcePushed"}, {"oid": "a51d7760c34c0652321427daa153070874c54a61", "url": "https://github.com/apache/flink/commit/a51d7760c34c0652321427daa153070874c54a61", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-15T18:27:12Z", "type": "forcePushed"}, {"oid": "0ed54d10e01403ccbe4478ad086d4859f6f511cf", "url": "https://github.com/apache/flink/commit/0ed54d10e01403ccbe4478ad086d4859f6f511cf", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-15T18:44:42Z", "type": "forcePushed"}, {"oid": "edabda8971fb299b278a0bd0b42c2dca82c8a6a4", "url": "https://github.com/apache/flink/commit/edabda8971fb299b278a0bd0b42c2dca82c8a6a4", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-16T03:03:56Z", "type": "forcePushed"}, {"oid": "d8b233f483d45b8901cc28770be9da71a39929ef", "url": "https://github.com/apache/flink/commit/d8b233f483d45b8901cc28770be9da71a39929ef", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-16T04:52:00Z", "type": "forcePushed"}, {"oid": "ab13e8a7dff7dcf53ed919196908437c30e78158", "url": "https://github.com/apache/flink/commit/ab13e8a7dff7dcf53ed919196908437c30e78158", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-18T03:56:00Z", "type": "forcePushed"}, {"oid": "3f89d29a4cee4917ff8087e16ab35c5d1274220c", "url": "https://github.com/apache/flink/commit/3f89d29a4cee4917ff8087e16ab35c5d1274220c", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-05-18T04:05:48Z", "type": "forcePushed"}, {"oid": "7dfdb8bfa05b783479697bd3aa3de3fac2628482", "url": "https://github.com/apache/flink/commit/7dfdb8bfa05b783479697bd3aa3de3fac2628482", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-06-28T05:30:04Z", "type": "forcePushed"}, {"oid": "66de3ded5740c19aab5984c8650b5d6a355ed6e8", "url": "https://github.com/apache/flink/commit/66de3ded5740c19aab5984c8650b5d6a355ed6e8", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-06-28T08:14:19Z", "type": "forcePushed"}, {"oid": "9963994d6a37e8c1721d31519ac7346e25922248", "url": "https://github.com/apache/flink/commit/9963994d6a37e8c1721d31519ac7346e25922248", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-07-01T16:03:05Z", "type": "forcePushed"}, {"oid": "5682e0256634e2ce1a38ca132cdaaddc79ee71c0", "url": "https://github.com/apache/flink/commit/5682e0256634e2ce1a38ca132cdaaddc79ee71c0", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers", "committedDate": "2020-07-02T03:27:27Z", "type": "forcePushed"}, {"oid": "1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "url": "https://github.com/apache/flink/commit/1440a6f1d30fc6cb7f4107facb3f9a5d08f34e87", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.", "committedDate": "2021-03-07T13:57:47Z", "type": "forcePushed"}, {"oid": "57cd88378e64e7c534d592d4538b2aa8222a2b00", "url": "https://github.com/apache/flink/commit/57cd88378e64e7c534d592d4538b2aa8222a2b00", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-07T15:25:00Z", "type": "forcePushed"}, {"oid": "379905b396355d37f565230cbcbee323dc626dce", "url": "https://github.com/apache/flink/commit/379905b396355d37f565230cbcbee323dc626dce", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T03:36:48Z", "type": "forcePushed"}, {"oid": "522dfaaf4295b903fa0c2d88e79db6d267086730", "url": "https://github.com/apache/flink/commit/522dfaaf4295b903fa0c2d88e79db6d267086730", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T05:48:19Z", "type": "forcePushed"}, {"oid": "8006bdc42eddf90eaaf8b1a426e3ee3c9b635e3c", "url": "https://github.com/apache/flink/commit/8006bdc42eddf90eaaf8b1a426e3ee3c9b635e3c", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T12:38:46Z", "type": "forcePushed"}, {"oid": "4b4b098f5eb40c7caf885c30b8c12aced99bbe05", "url": "https://github.com/apache/flink/commit/4b4b098f5eb40c7caf885c30b8c12aced99bbe05", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-08T13:58:14Z", "type": "forcePushed"}, {"oid": "87c4d9e67b205d7ca2fedf25a5a59402500de2ce", "url": "https://github.com/apache/flink/commit/87c4d9e67b205d7ca2fedf25a5a59402500de2ce", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-03-28T12:53:34Z", "type": "forcePushed"}, {"oid": "86af5b748a70ba9bb997d654b6f76c0f3a343bc0", "url": "https://github.com/apache/flink/commit/86af5b748a70ba9bb997d654b6f76c0f3a343bc0", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-05-08T07:29:43Z", "type": "forcePushed"}, {"oid": "ae312385b57ca67cdb73ee96be38c4edbe56478d", "url": "https://github.com/apache/flink/commit/ae312385b57ca67cdb73ee96be38c4edbe56478d", "message": "Commit for test", "committedDate": "2021-05-10T06:49:44Z", "type": "forcePushed"}, {"oid": "4f4ce33b815167b23c8ee3dc8d65e1e97cc0cd07", "url": "https://github.com/apache/flink/commit/4f4ce33b815167b23c8ee3dc8d65e1e97cc0cd07", "message": "Commit for test", "committedDate": "2021-05-10T10:06:29Z", "type": "forcePushed"}, {"oid": "8550965d808fe7b4d6ff2d48034612878937a579", "url": "https://github.com/apache/flink/commit/8550965d808fe7b4d6ff2d48034612878937a579", "message": "Fix commit", "committedDate": "2021-05-11T08:33:04Z", "type": "forcePushed"}, {"oid": "7b6eb661923f59967a116e9074cf790fd694c578", "url": "https://github.com/apache/flink/commit/7b6eb661923f59967a116e9074cf790fd694c578", "message": "Commit for test", "committedDate": "2021-05-11T12:15:11Z", "type": "forcePushed"}, {"oid": "2c49d1a8cee6485e8f367190f152e58960c901ff", "url": "https://github.com/apache/flink/commit/2c49d1a8cee6485e8f367190f152e58960c901ff", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-05-11T12:14:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661546940", "bodyText": "Before these changes where this buffer was recycled? or was it the bug?", "author": "akalash", "createdAt": "2021-06-30T14:46:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -340,7 +355,15 @@ private void decodeBufferOrEvent(\n             RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)\n             throws Throwable {\n         if (bufferOrEvent.isBuffer() && bufferOrEvent.bufferSize == 0) {\n-            inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+            try {\n+                inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);\n+            } finally {\n+                // recycle the empty buffer directly\n+                Buffer buffer = bufferOrEvent.getBuffer();\n+                if (buffer != null) {\n+                    buffer.recycleBuffer();", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk4NjgxMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661986812", "bodyText": "It is not a bug. The empty buffer will not be sent to the downstream before. However, after this change, the empty buffer will be sent to the downstream task to release the credit already allocated for it. If we do not send the empty buffer to the downstream, the corresponding downstream channel will occupy more credits than needed.", "author": "wsry", "createdAt": "2021-07-01T05:32:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDUwMzUyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664503527", "bodyText": "What do you mean by that @wsry ? That previously bufferOrEevnt.getBuffer() was always null?\nIf so why do we need to keep suport for sending both empty buffers or null buffer?", "author": "pnowojski", "createdAt": "2021-07-06T12:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5NzIxOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664997218", "bodyText": "Yes, you are right. Previously, bufferOrEevnt.getBuffer() was always null. And currently, it should be never null. So we do not need to support null buffer now.", "author": "wsry", "createdAt": "2021-07-07T02:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5OTc2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664999767", "bodyText": "I think I can keep this logic unchanged and release the buffer in decoder", "author": "wsry", "createdAt": "2021-07-07T02:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU0Njk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661554029", "bodyText": "as I understand, the backlog can not be less or equal to 0 here. So maybe convert it to checkArgument? Or I missed something?", "author": "akalash", "createdAt": "2021-06-30T14:53:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/PartitionRequestQueue.java", "diffHunk": "@@ -164,6 +168,27 @@ void addCreditOrResumeConsumption(\n         }\n     }\n \n+    /**\n+     * Announces remaining backlog to the consumer after the available data notification or data\n+     * consumption resumption.\n+     */\n+    private void announceBacklog(NetworkSequenceViewReader reader) {\n+        int backlog = reader.getRemainingBacklog();\n+        if (backlog > 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MDgyNQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661990825", "bodyText": "The backlog can be 0. For example, after resumption from checkpoint, if there is no pending data in the subpartition.", "author": "wsry", "createdAt": "2021-07-01T05:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0ODA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664648084", "bodyText": "Have you tested this @wsry ? After all it seems like if reader is available, it should have backlog > 0, shouldn't it?", "author": "pnowojski", "createdAt": "2021-07-06T15:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2OTg1NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664669854", "bodyText": "Secondly, getRemainingBacklog() is a very costly operation (additional synchronisation) that I think could have been avoided:\n\nBacklog can go up only as a result of org.apache.flink.runtime.io.network.netty.PartitionRequestQueue#notifyReaderNonEmpty(reader).\nBacklog can go down, only as a result of polling the data from the reader.\nSo instead of using thread safe reader.getRemainingBacklog(), we could re-use existing synchronisation in 1. and 2., to maintain remainingBacklog in the netty thread (in the PartitionRequestQueue.\n\nBut it would be even better to completely avoid this check (my comment above).", "author": "pnowojski", "createdAt": "2021-07-06T15:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTAxMjQ0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665012443", "bodyText": "You are right, we can do some optimization here.", "author": "wsry", "createdAt": "2021-07-07T03:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA3MzQ2Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665073463", "bodyText": "I think there is one thing blocking us from reusing the backlog from PartitionRequestQueue#notifyReaderNonEmpty(reader): we have duplicated availability notifications. We may get outdated backlog.", "author": "wsry", "createdAt": "2021-07-07T06:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTIyNTkzMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665225932", "bodyText": "Maybe we can reuse the return value of is available. Instead of just return a bool flag, we may also return the backlog. I will give it a try.", "author": "wsry", "createdAt": "2021-07-07T09:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTkwMDUxNQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665900515", "bodyText": "NetworkSequenceViewReader#isAvailable() has the same problem of synchronisation costs.\n\nI think there is one thing blocking us from reusing the backlog from PartitionRequestQueue#notifyReaderNonEmpty(reader): we have duplicated availability notifications. We may get outdated backlog.\n\nWhat is the problem?  Keep in mind that spurious notifications shouldn't be that big of a problem. If we sometimes wake up too many times, and we rarely send incorrect backlog information that should be fine, as long as we always over estimate the backlog.\nAfter all even in your version I think there can be a race condition where PartitionRequestQueue is notified reader is non empty, you check the getRemainingBacklog() and send the BacklogAnnouncement message, while before it gets processed by the receiver, some buffer is polled from this reader and backlog goes down to 0. And as a result, receiver assigns as a credit to a sender that doesn't have any data anymore?", "author": "pnowojski", "createdAt": "2021-07-08T06:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTkzMzA2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665933067", "bodyText": "NetworkSequenceViewReader#isAvailable() has already been called by PartitionRequestQueue#enqueueAvailableReader:\nprivate void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\nif (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {\nreturn;\n}\n......\n}\n\nI think we can change it to:\n    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {\n        if (reader.isRegisteredAsAvailable()) {\n            return;\n        }\n\n        ResultSubpartitionView.AvailabilityWithBacklog availabilityWithBacklog =\n                reader.getAvailabilityAndBacklog();\n        if (!availabilityWithBacklog.isAvailable()) {\n            int backlog = availabilityWithBacklog.getBacklog();\n            if (backlog > 0 && reader.needAnnounceBacklog()) {\n                announceBacklog(reader, backlog);\n            }\n            return;\n        }\n......\n}\n\nWhat do you think?\n\nAfter all even in your version I think there can be a race condition where PartitionRequestQueue is notified reader is non empty, you check the getRemainingBacklog() and send the BacklogAnnouncement message, while before it gets processed by the receiver, some buffer is polled from this reader and backlog goes down to 0. And as a result, receiver assigns as a credit to a sender that doesn't have any data anymore?\n\nI think there is no such problem. One reason is that getRemainingBacklog() is in netty thread and we can guarantee the order, the downstream will always process the BacklogAnnouncement before the buffer. The other reason is that we only announce credit when there is no credit available which means if there is credit available, only buffer with backlog will be sent, if there is no credit available, only BacklogAnnouncement will be send, buffer will be always wait for credit. It is also not a problem if we announce the same credit twice because we can guarantee the process order.", "author": "wsry", "createdAt": "2021-07-08T07:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjI4NjM5Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666286396", "bodyText": "Yes you are right. reader.isAvailable() is already being called. I'm not sure why I've missed that.\nreader.getAvailabilityAndBacklog(); should work fine :)", "author": "pnowojski", "createdAt": "2021-07-08T15:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661557618", "bodyText": "Is it also a bug? Or why do we distinguish EVENT_BUFFER and DATA_BUFFER now?", "author": "akalash", "createdAt": "2021-06-30T14:57:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java", "diffHunk": "@@ -91,10 +91,14 @@ public BufferAndBacklog getNextBuffer() throws IOException {\n \n         updateStatistics(current);\n \n-        // We simply assume all the data are non-events for batch jobs to avoid pre-fetching the\n-        // next header\n-        Buffer.DataType nextDataType =\n-                numDataAndEventBuffers > 0 ? Buffer.DataType.DATA_BUFFER : Buffer.DataType.NONE;\n+        // We simply assume all the data except for the last one (EndOfPartitionEvent)\n+        // are non-events for batch jobs to avoid pre-fetching the next header\n+        Buffer.DataType nextDataType = Buffer.DataType.NONE;\n+        if (numDataBuffers > 0) {\n+            nextDataType = Buffer.DataType.DATA_BUFFER;\n+        } else if (numDataAndEventBuffers > 0) {\n+            nextDataType = Buffer.DataType.EVENT_BUFFER;\n+        }", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MjQ1OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661992459", "bodyText": "An EVENT_BUFFER does not need any credit to be sent. The BoundedBlockingSubpartitionDirectTransferReader Implementation does not distinguish EVENT_BUFFER and DATA_BUFFER for simplicity. However, after this change, we need to distinguish EVENT_BUFFER and DATA_BUFFER because we do not want to allocate any credit at downstream for an EVENT_BUFFER.", "author": "wsry", "createdAt": "2021-07-01T05:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1NDk0OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664654949", "bodyText": "But what would be a problem with requesting for a credit for the EndOfPartitionEvent? In other words, what's wrong with doing it as it was done previously: always returning DATA_BUFFER or NONE?", "author": "pnowojski", "createdAt": "2021-07-06T15:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA1OTAyNw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665059027", "bodyText": "I think this is just an optimization. Without this change, the backlog announced to the downstream does not include the event and EVENT_BUFFER and DATA_BUFFER are not distinguished, this means the event buffer also need a credit to send. If there is no exclusive buffer, no enough buffer will be allocated for the event, because we only announce the data buffer backlog to the downstream. As a result, some tests will hang for there is no credit for the event buffer. To solve this dead lock, there are two simple ways:\n\nAnnounce both data buffer and event buffer backlog to the downstream, this lead to allocate more buffers than needed, these buffers will be released when the EOF is received at the downstream task.\nDistinguish EVENT_BUFFER and DATA_BUFFER just like what is doing now.\n\nThese choices are both acceptable to me. I chose the second one because EVENT_BUFFER and DATA_BUFFER are distinguished at the downstream task and we can allocate one less buffer.\nBoth of the choices need to do some change to BoundedBlockingSubpartitionDirectTransferReader. Which one do you prefer? I think both are acceptable for me.", "author": "wsry", "createdAt": "2021-07-07T05:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgzMDY5MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665830690", "bodyText": "After rethink about it, the first choice can support more events type in the future and the second choice make the assumption that we only have one event at the end of the data. Maybe the first choice is better?", "author": "wsry", "createdAt": "2021-07-08T02:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTg5NTUwNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665895504", "bodyText": "Let's stay with the option 2 (as you have currently implemented)", "author": "pnowojski", "createdAt": "2021-07-08T06:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU1NzYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU2MzMwNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661563304", "bodyText": "Does this mean that we don't need the credit for sending the event?", "author": "akalash", "createdAt": "2021-06-30T15:04:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/BoundedBlockingSubpartitionDirectTransferReader.java", "diffHunk": "@@ -110,7 +114,12 @@ private void updateStatistics(Buffer buffer) {\n     public boolean isAvailable(int numCreditsAvailable) {\n         // We simply assume there are no events except EndOfPartitionEvent for bath jobs,\n         // then it has no essential effect to ignore the judgement of next event buffer.\n-        return numCreditsAvailable > 0 && numDataAndEventBuffers > 0;\n+        return (numCreditsAvailable > 0 || numDataBuffers == 0) && numDataAndEventBuffers > 0;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5MzY0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661993643", "bodyText": "Yes, you are right. At the downstream task, no credit is needed when decoding an event.", "author": "wsry", "createdAt": "2021-07-01T05:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU2MzMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661589690", "bodyText": "I don't really get the idea of these changes.\nLet's suppose PipelindedSubpartition#buffers contain several but the first one is empty and finished already.\nHow it was before the changes:\n\nPartitionRequestQueue requests the buffer.\nin any case, PipelindedSubpartition#pollBuffer returns a buffer(it skip the first one because it is empty and finished but it returns the buffer from the next consumer)\nPartitionRequestQueue continues to request from this Reader until PipelindedSubpartition#buffers is not empty.\n\nAfter the changes:\n\nPartitionRequestQueue requests the buffer.\nPipelindedSubpartition#pollBuffer returns null.\nPartitionRequestQueue remove this reader from the available readers\nOther buffers from PipelindedSubpartition#buffers will be sent only when timeout happens and this reader is added to the available list again.\n\nWhat the point to delay the sending if we already have credit for it and we have the buffer ready to be sent?", "author": "akalash", "createdAt": "2021-06-30T15:33:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -288,9 +288,7 @@ BufferAndBacklog pollBuffer() {\n \n             if (buffers.isEmpty()) {\n                 flushRequested = false;\n-            }\n-\n-            while (!buffers.isEmpty()) {\n+            } else {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5ODg4NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661998885", "bodyText": "After the changes, if the first buffer is finished and empty. The empty buffer will be sent to the downstream to release the allocated credit for it instead of recycled directly.", "author": "wsry", "createdAt": "2021-07-01T05:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjIxNzkxNA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662217914", "bodyText": "Ok, I think I understand it now. Please, tell me I indeed understand the scenario right:\n\nSuppose the buffers contain one unfinished Buffer.\nThe flush was requested\nWhen pollBuffer() was called it collects all readable bytes from this unfinished buffer and getBuffersInBacklog returns 1(because flushRequested set to true)\nOne more credit is requested from downstream because getBuffersInBacklog equal to 1.\nWhen pollBuffer() was called again it reads nothing because all data was read last time. But it already has one credit that should be released(it is exactly what you told about?).", "author": "akalash", "createdAt": "2021-07-01T11:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjY4ODEyMA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662688120", "bodyText": "If there is only one buffer in the buffer queue, after all data is read, the flushRequested flag will be turned off. Consider the following scenario (correct me if I am wrong):\n\nThere is an unfinished buffer in the queue and all data is read.\nThen the buffer is finished but no new data is appended. Note appending data and finish buffer is not an atomic operation.\nNew buffer or event is added to the buffer queue.\nWhen polling buffer, an empty buffer is at the head of the queue and we already allocate a credit for it.", "author": "wsry", "createdAt": "2021-07-02T02:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjc3ODA1NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662778055", "bodyText": "appending data and finish buffer is not an atomic operation.\n\nIt is exactly what I want to emphasize. As I understand, we need the empty buffer only because appending data and finish buffer is not an atomic operation. which happens because BufferBuilder has a gap between commit and finish. So I propose to rewrite BufferBuilder in such a way that if it commits the current state and size == capacity it finishes it immediately(so there is no explicit finish call needed). These changes allow us to avoid all logic with an empty buffer which I think pretty untransparent.\nOne more time, my proposal:\n\nRewriting the BufferBuilder in such a way that it will be impossible to have the empty finished buffer(it just requires removing the gap between the last commit and finish).\nDon't send the empty buffer(after changes described above there won't be any empty buffers)\n\n@wsry WDYT?\n@pnowojski What is your opinion, is it safe to finish BufferBuilder immediately when it becomes full? I mean not to wait for call explicit finish but finish in the commit if it is full?", "author": "akalash", "createdAt": "2021-07-02T06:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjgxNjg1OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662816858", "bodyText": "Does that mean that the BufferBuilder can not finish a partial buffer, for example the last piece of data of the batch execution mode? Besides, there is another case which may lead to the empty buffer: in PipelinedApproximateSubpartition, if a partial record takes more than one buffer in the queue, those partial data will be dropped when recovering.", "author": "wsry", "createdAt": "2021-07-02T07:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Mjg0MTM3NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662841374", "bodyText": "Yes, the batch execution mode still requires the manual calling of finish which brokes my idea.  The same about PipelinedApproximateSubpartition. As I understand, it is impossible to know that a partial record will be sent or not before the request the credit.\nSo I still believe that it would be better to avoid sending the empty buffer if it is possible. But perhaps you right and it will be not so easy to do so in the current implementation, especially because of the scenarios which you described.", "author": "akalash", "createdAt": "2021-07-02T08:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzExOTk1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r663119956", "bodyText": "How common is that case? Can we measure how many those empty buffers are being sent? Is this an issue of 0.1% more messages or 50%? If it's hard to say or can vary, would it be difficult/would it complicate the code to send the empty buffers only if #exclusiveBuffers == 0 to make sure that there is no performance regression?", "author": "pnowojski", "createdAt": "2021-07-02T16:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MzU5MTI4NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r663591285", "bodyText": "It is pretty simple to send empty buffer only when  #exclusiveBuffers == 0.", "author": "wsry", "createdAt": "2021-07-05T01:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU4OTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5MjQ2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661592466", "bodyText": "So dangerous, why you so sure that buffers contain at least one object?", "author": "akalash", "createdAt": "2021-06-30T15:36:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -513,19 +514,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {\n+            if (isBlocked || buffers.isEmpty()) {\n+                return 0;\n+            }\n+\n+            if (flushRequested\n+                    || isFinished\n+                    || !checkNotNull(buffers.peekLast()).getBufferConsumer().isBuffer()) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk5OTc0MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661999741", "bodyText": "In the previous if block in this method, we have already filtered the case when the buffer queue is empty.", "author": "wsry", "createdAt": "2021-07-01T06:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5MjQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5NzQ4Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661597482", "bodyText": "It seems that it is the wrong place for such condition. Logically, even if the subpartition is blocked it still has the buffers. But as I understand, specifically for the case where 'initialCredit == 0' it should return 0. So it needs to think how does it do better.", "author": "akalash", "createdAt": "2021-06-30T15:42:05Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -513,19 +514,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {\n+            if (isBlocked || buffers.isEmpty()) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwMzA1OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662003058", "bodyText": "After the channel is blocked, we do not need to allocated any credit at the downstream, because no buffer will be sent. As mentioned in your comment, if the initialCredit is 0, it should return 0. If the initialCredit is not 0, we always have exclusive credits, we still do not need allocate any floating credit. Maybe returning the actual value instead of 0 is a small improvement.", "author": "wsry", "createdAt": "2021-07-01T06:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5NzQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5OTQ1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661599456", "bodyText": "As I understand, initialCredit is an unchangeable value, and BufferManager and AvailableBufferQueue know this value so maybe it is better to avoid this parameter?", "author": "akalash", "createdAt": "2021-06-30T15:44:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -83,8 +84,13 @@ public BufferManager(\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer() {\n+    Buffer requestBuffer(int initialCredit) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwMzQ3Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662003477", "bodyText": "You are right, we can avoid this parameter.", "author": "wsry", "createdAt": "2021-07-01T06:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTU5OTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMjExMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661602113", "bodyText": "I don't understand why initialCredit == 0 should be handled differently here. Even if initialCredit == 1 and the Buffer is requested we should decrease this value, or am I wrong?", "author": "akalash", "createdAt": "2021-06-30T15:47:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -83,8 +84,13 @@ public BufferManager(\n     // ------------------------------------------------------------------------\n \n     @Nullable\n-    Buffer requestBuffer() {\n+    Buffer requestBuffer(int initialCredit) {\n         synchronized (bufferQueue) {\n+            // decrease the number of buffers require to avoid the possibility of\n+            // allocating more than required buffers after the buffer is taken\n+            if (initialCredit == 0) {\n+                --numRequiredBuffers;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwNDMxMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662004311", "bodyText": "You are right, we should always decrease this value.", "author": "wsry", "createdAt": "2021-07-01T06:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMzY2MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661603660", "bodyText": "As I understand, the negative number is still illegal. So maybe it makes sense to add checkArgument for numExclusiveBuffers < 0?", "author": "akalash", "createdAt": "2021-06-30T15:49:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -130,11 +136,11 @@ private boolean shouldContinueRequest(BufferPool bufferPool) {\n \n     /** Requests exclusive buffers from the provider. */\n     void requestExclusiveBuffers(int numExclusiveBuffers) throws IOException {\n-        Collection<MemorySegment> segments = globalPool.requestMemorySegments(numExclusiveBuffers);\n-        checkArgument(\n-                !segments.isEmpty(),\n-                \"The number of exclusive buffers per channel should be larger than 0.\");\n+        if (numExclusiveBuffers <= 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAwNTUzMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662005533", "bodyText": "You are right, I will add a checkArgument.", "author": "wsry", "createdAt": "2021-07-01T06:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwMzY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661605173", "bodyText": "Can you explain what kind of deadlock can happen? Between LocalBufferPool and BufferManager?", "author": "akalash", "createdAt": "2021-06-30T15:50:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -215,9 +221,15 @@ public void recycle(MemorySegment segment) {\n     }\n \n     void releaseFloatingBuffers() {\n+        Queue<Buffer> buffers;\n         synchronized (bufferQueue) {\n             numRequiredBuffers = 0;\n-            bufferQueue.releaseFloatingBuffers();\n+            buffers = bufferQueue.clearFloatingBuffers();\n+        }\n+\n+        // recycle all buffers out of the synchronization block to avoid dead lock", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMDQ0NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662010444", "bodyText": "Each RemoteInputChannel has its own BufferManager and bufferQueue, floating buffers recycled by one RemoteInputChannel can be assigned to other RemoteInputChannels directly and the buffer assignment also need to sync the bufferQueue object. Besides, different RemoteInputChannels may recycle buffers simultaneously, which means we may need to lock two bufferQueue objects of different RemoteInputChannels simultaneously in the reverse order. I already encountered this dead lock when running test.", "author": "wsry", "createdAt": "2021-07-01T06:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjIzOTA2Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662239062", "bodyText": "As I understand from your explanation, it relates to this BufferManager#notifyBufferAvailable. But I still don't get which threads can call the releaseFloatingBuffers simultaneously. It is not so important, but just for curiosity if you have the stacktrace of this deadlock can you share it with me(or just tell me which test)?\nAnyway, your changes look correct here.", "author": "akalash", "createdAt": "2021-07-01T12:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjY4OTEwMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662689103", "bodyText": "It is the new logic added by this PR causes the problem. RemoteInputChannel#onBlockingUpstream will call BufferManager#releaseFloatingBuffers in netty thread and different RemoteInputChannels can have different netty thread.", "author": "wsry", "createdAt": "2021-07-02T02:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNjUwMg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661606502", "bodyText": "The same question that earlier - is this bug? or where did we recycle the buffer before this changes?", "author": "akalash", "createdAt": "2021-06-30T15:52:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -265,6 +265,13 @@ public void run() {\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n+\n+        // ignore the empty buffer directly\n+        if (buffer.readableBytes() == 0) {\n+            buffer.recycleBuffer();", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMTY2Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662011666", "bodyText": "Before this change, the buffer is recycled in the pollBuffer method of Subpartition because no empty buffer is sent.", "author": "wsry", "createdAt": "2021-07-01T06:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYwNjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMDY0Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661610647", "bodyText": "How is it even possible to get an empty buffer? Who is sending it?", "author": "akalash", "createdAt": "2021-06-30T15:57:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -265,6 +265,13 @@ public void run() {\n                 channelInfo,\n                 channelStatePersister,\n                 next.getSequenceNumber());\n+\n+        // ignore the empty buffer directly\n+        if (buffer.readableBytes() == 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxMjY2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662012667", "bodyText": "After this change, we can poll an empty buffer from the Subpartition of the upstream task.", "author": "wsry", "createdAt": "2021-07-01T06:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMDY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMzIwMQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661613201", "bodyText": "Why can not we do the same thing for any number of credits not only for initialCredit == 0? Or does it slow down the load after resuming?", "author": "akalash", "createdAt": "2021-06-30T16:00:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -357,11 +359,26 @@ public void resumeConsumption() throws IOException {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);\n+        }\n+\n         // notifies the producer that this channel is ready to\n         // unblock from checkpoint and resume data consumption\n         partitionRequestClient.resumeConsumption(this);\n     }\n \n+    private void onBlockingUpstream() {\n+        if (initialCredit == 0) {", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAxNjE1Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662016156", "bodyText": "I think it does not slow down the load after resuming. It is just for the simplicity of handling unannounced credit. Maybe we have already announced the credits to the producer.", "author": "wsry", "createdAt": "2021-07-01T06:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxMzIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661614767", "bodyText": "Do we need to do so because we released all buffers in onBlockingUpstream? If so can we hold this code in one place, ex. to move it into onBlockingUpstream?", "author": "akalash", "createdAt": "2021-06-30T16:02:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -357,11 +359,26 @@ public void resumeConsumption() throws IOException {\n         checkState(!isReleased.get(), \"Channel released.\");\n         checkPartitionRequestQueueInitialized();\n \n+        if (initialCredit == 0) {\n+            unannouncedCredit.set(0);", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAyMDQ3Mg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662020472", "bodyText": "Doing this in the onBlockingUpstream method can guarantee that after resumeConsumption the unannouncedCredit is in a clean state. Because the unannouncedCredit may get increased after that if there is any new available floating credit.", "author": "wsry", "createdAt": "2021-07-01T06:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY4Mjk4OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664682988", "bodyText": "But how can this floating credit be assigned to this blocked RemoteInputChannel? Wouldn't it cause the same deadlock, when floating buffers are assigned to blocked channels and job/task can not make any progress?\nIt sounds like maybe this should have been handled sooner when trying to increase unannouncedCredit?", "author": "pnowojski", "createdAt": "2021-07-06T15:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA2ODA0OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665068048", "bodyText": "This because RemoteInputChannel#notifyBufferAvailable which increases unannouncedCredit and floating buffer assignment is not an atomic operation. There is a possibility:\n\nthe floating buffer is assigned;\nthe floating buffer is released because of receiving an event which blocks the channel;\nthe notifyBufferAvailable is called and the unannouncedCredit is increased.\n\nDo you mean we should make RemoteInputChannel#notifyBufferAvailable and floating buffer assignment an atomic operation?", "author": "wsry", "createdAt": "2021-07-07T06:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTM5NDU1MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665394550", "bodyText": "Something sounds wrong here. The race condition that you described above, does it mean that unannouncedCredit can be out of sync? That we in reality have released all floating buffers, channel is blocked, but actually unannouncedCredit > 0? And it's only fixed after calling resumeConsumption()?\nAnd as I understand it, without your change, this problem doesn't exist, as floating buffers are kept assigned to the blocked channel and the unannouncedCredit (or maybe even assigned AddCredit that might have been sent to the upstream node)  are consistent with the reality. Also those assigned floating buffers are not used because channel is blocked, but that is not a big issue, because thanks to the exclusive buffers, other channels can make a progress?", "author": "pnowojski", "createdAt": "2021-07-07T13:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgxNDMzNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665814336", "bodyText": "Something sounds wrong here. The race condition that you described above, does it mean that unannouncedCredit can be out of sync? That we in reality have released all floating buffers, channel is blocked, but actually unannouncedCredit > 0? And it's only fixed after calling resumeConsumption()?\n\nYes, exactly.\n\nAnd as I understand it, without your change, this problem doesn't exist, as floating buffers are kept assigned to the blocked channel and the unannouncedCredit (or maybe even assigned AddCredit that might have been sent to the upstream node) are consistent with the reality. Also those assigned floating buffers are not used because channel is blocked, but that is not a big issue, because thanks to the exclusive buffers, other channels can make a progress?\n\nThat only happens when the exclusive credit is 0. If the exclusive credit is not 0, the allocated floating buffers will not be released and if the exclusive credit is 0, we release the floating buffers allocated to let other channel use them to avoid deadlock, an extreme case is that we only have 1 floating buffer and no exclusive buffer. At downstream, the unannounced credit will be reset, at the upstream, the available credit is also reset to 0 when resume consumption.", "author": "wsry", "createdAt": "2021-07-08T01:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjMzNDUwNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666334506", "bodyText": "Ok, can you at least add a comment explaining why this is set to 0 here?", "author": "pnowojski", "createdAt": "2021-07-08T16:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNDc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNzUyNg==", "url": "https://github.com/apache/flink/pull/11877#discussion_r661617526", "bodyText": "Do we do it because we know that all floating buffers would be released before the checkpoint when initialCredit == 0?", "author": "akalash", "createdAt": "2021-06-30T16:05:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedSequenceNumberingViewReader.java", "diffHunk": "@@ -100,8 +106,19 @@ public void addCredit(int creditDeltas) {\n         numCreditsAvailable += creditDeltas;\n     }\n \n+    @Override\n+    public boolean needAnnounceBacklog() {\n+        return initialCredit == 0 && numCreditsAvailable == 0;\n+    }\n+\n     @Override\n     public void resumeConsumption() {\n+        if (initialCredit == 0) {\n+            // reset available credit if no exclusive buffer is available at the\n+            // consumer side for all floating buffers must have been released\n+            numCreditsAvailable = 0;", "originalCommit": "2c49d1a8cee6485e8f367190f152e58960c901ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjAyMDc1OQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r662020759", "bodyText": "Yes, you are right.", "author": "wsry", "createdAt": "2021-07-01T06:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYxNzUyNg=="}], "type": "inlineReview"}, {"oid": "c161aff32e5aed483ca0722e0504ec8493348947", "url": "https://github.com/apache/flink/commit/c161aff32e5aed483ca0722e0504ec8493348947", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-01T07:53:09Z", "type": "forcePushed"}, {"oid": "159596e8f11586211a5f54e6aaae2c9fdee532a2", "url": "https://github.com/apache/flink/commit/159596e8f11586211a5f54e6aaae2c9fdee532a2", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-02T02:08:29Z", "type": "forcePushed"}, {"oid": "1814aee57851711782cc2d922c4ef8f118a74c13", "url": "https://github.com/apache/flink/commit/1814aee57851711782cc2d922c4ef8f118a74c13", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T01:55:10Z", "type": "forcePushed"}, {"oid": "f28812c2d19b7109e851d4cce6cdb9df82868117", "url": "https://github.com/apache/flink/commit/f28812c2d19b7109e851d4cce6cdb9df82868117", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T07:02:25Z", "type": "forcePushed"}, {"oid": "048818bd8e4548d20febf9308b83e42146806b6e", "url": "https://github.com/apache/flink/commit/048818bd8e4548d20febf9308b83e42146806b6e", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T07:13:41Z", "type": "forcePushed"}, {"oid": "ae5a618edba91af4656de9bab058e4a372a01331", "url": "https://github.com/apache/flink/commit/ae5a618edba91af4656de9bab058e4a372a01331", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T08:17:11Z", "type": "forcePushed"}, {"oid": "109e1d36469b537f997a7c844e57e23729a1af21", "url": "https://github.com/apache/flink/commit/109e1d36469b537f997a7c844e57e23729a1af21", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-05T08:39:29Z", "type": "forcePushed"}, {"oid": "028f2185c0bb15c542006065550d04f69b0b06bd", "url": "https://github.com/apache/flink/commit/028f2185c0bb15c542006065550d04f69b0b06bd", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-06T04:02:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664644076", "bodyText": "Why is this an issue? Is this an independent optimisation or is it relate with the other parts of the PR?", "author": "pnowojski", "createdAt": "2021-07-06T15:08:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/CreditBasedPartitionRequestClientHandler.java", "diffHunk": "@@ -433,8 +459,8 @@ public void operationComplete(ChannelFuture future) throws Exception {\n \n         @Override\n         public Object buildMessage() {\n-            return new AddCredit(\n-                    inputChannel.getAndResetUnannouncedCredit(), inputChannel.getInputChannelId());\n+            int credits = inputChannel.getAndResetUnannouncedCredit();\n+            return credits > 0 ? new AddCredit(credits, inputChannel.getInputChannelId()) : null;", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MDU4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664650587", "bodyText": "Secondly, return type of the buildMessage() is not annotated @Nullable, so if we need this code for correctness we need to add this annotation (but it would be better to avoid null here)", "author": "pnowojski", "createdAt": "2021-07-06T15:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MDE2NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665080164", "bodyText": "It is relevant to this PR, it is because we add the reset logic in RemoteInputChannel#resumeConsumption method.\n        if (initialCredit == 0) {\n            unannouncedCredit.set(0);\n        }", "author": "wsry", "createdAt": "2021-07-07T06:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MDQ5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665080497", "bodyText": "I will add a @nullable annotation.", "author": "wsry", "createdAt": "2021-07-07T06:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY0NDA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MTgwOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664651808", "bodyText": "@Nullable\nDo we really need to support null here? Can not we return empty Buffer?", "author": "pnowojski", "createdAt": "2021-07-06T15:17:45Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/netty/NetworkBufferAllocator.java", "diffHunk": "@@ -69,6 +69,9 @@ Buffer allocatePooledNetworkBuffer(InputChannelID receiverId) {\n      * @return The un-pooled network buffer.\n      */\n     Buffer allocateUnPooledNetworkBuffer(int size, Buffer.DataType dataType) {\n+        if (size <= 0) {\n+            return null;\n+        }", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4MjY3OA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665082678", "bodyText": "This method is used to allocate unpooled buffer for event, the size must be positive. I will replace it with a argument check.", "author": "wsry", "createdAt": "2021-07-07T06:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1MTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664659995", "bodyText": "Instead of this check here, can not we add similar check outside of the while (...) loop? For example replace:\nif (buffer == null) {\n    return null;\n}\n\nwith something like:\nif (buffer == null) {\n   if (buffersPerChannel == 0) {\n       return EMPTY_BUFFER;\n    }\n    else {\n       return null;\n    }\n}\n\n?\nThat way, we would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued?", "author": "pnowojski", "createdAt": "2021-07-06T15:27:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -315,6 +326,17 @@ BufferAndBacklog pollBuffer() {\n                 if (buffer.readableBytes() > 0) {\n                     break;\n                 }\n+\n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4NDYyOQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665084629", "bodyText": "I am afraid we can not skip the empty buffer is the exclusive credit is 0, because we may already allocate the floating credit for it and we can not just release the floating credit because we may already announce the credit to the upstream.", "author": "wsry", "createdAt": "2021-07-07T06:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA5MjA4NA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665092084", "bodyText": "I was not suggesting that. I was suggesting to:\n\nwe would avoid sending empty buffer if there are still more buffers in the backlog that are already enqueued", "author": "pnowojski", "createdAt": "2021-07-07T06:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTIyMjQ5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665222497", "bodyText": "I guess I did not fully understand the comment, could you please explain a bit more? From my understand, even there are multiple buffers in the queue and the first is empty, if we do not send the first empty buffer out, how could we guarantee the downstream tasks are not allocating too many buffers if the exclusive credit is 0? For example, if there is two buffers, the first one is empty and the second one is an event, we may already announce 1 backlog to the downstream task and if we send the event directly, dose that mean we can not release the credit already allocated? Correct me if I am wrong.", "author": "wsry", "createdAt": "2021-07-07T09:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTM0MjA3NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665342075", "bodyText": "If there are two buffers, first is empty the second one can be:\n\nnon empty buffer\nempty buffer\nevent\n\nIn all cases, instead of sending this first empty buffer with the backlog information, as far as I understand, it should be possible to just send any of the above instead with the updated backlog information. From the downstream node perspective, it should make no difference if we hide this empty buffer. If this is 2nd or 3rd case, we should be able to release the floating buffer regardless of that, shouldn't we?", "author": "pnowojski", "createdAt": "2021-07-07T12:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTgyOTM4Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665829387", "bodyText": "Let's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.\n\nThere are only one data buffer in the queue.\nFlush triggered.\nAll data of the first buffer is committed but the buffer is still not finished.\nAll data of the buffer is consumed by pollBuffer and the available credit becomes 0.\nThe first buffer is finished, the second event is added and the data available notification is triggered.\nThe upstream announces backlog to the downstream to request a credit.\nThe upstream receives available credit and start to pollBuffer.\nSkip the first empty buffer and send the second event.\nThe downstream receive the event but the event does not consume any credit.\n\nDo you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)? If there are multiple empty buffers, should we just skip the first one or should we skip all?", "author": "wsry", "createdAt": "2021-07-08T02:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY1OTk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2MjE1Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664662153", "bodyText": "pollBuffer() would be acquiring the lock twice, wouldn't it? If you really need to make this method public you should keep private int getBuffersInBacklogUnsafe() without any synchronisation.", "author": "pnowojski", "createdAt": "2021-07-06T15:29:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -517,19 +539,20 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n     public int getBuffersInBacklog() {\n-        if (flushRequested || isFinished) {\n-            return buffersInBacklog;\n-        } else {\n-            return Math.max(buffersInBacklog - 1, 0);\n+        synchronized (buffers) {", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTA4NDg3Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r665084877", "bodyText": "I will add a private int getBuffersInBacklogUnsafe() method", "author": "wsry", "createdAt": "2021-07-07T06:39:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY2MjE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDY3NTg2Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r664675867", "bodyText": "add the backlog value to the error message?", "author": "pnowojski", "createdAt": "2021-07-06T15:46:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -468,6 +485,11 @@ public void onBuffer(Buffer buffer, int sequenceNumber, int backlog) throws IOEx\n                 return;\n             }\n \n+            if (buffer.getDataType().isBlockingUpstream()) {\n+                onBlockingUpstream();\n+                checkArgument(backlog == 0, \"Illegal number of backlog.\");", "originalCommit": "028f2185c0bb15c542006065550d04f69b0b06bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb631b77700e2f05dcfdd50cd50cdea35e7cfb13", "url": "https://github.com/apache/flink/commit/fb631b77700e2f05dcfdd50cd50cdea35e7cfb13", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-07T02:10:53Z", "type": "forcePushed"}, {"oid": "826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "url": "https://github.com/apache/flink/commit/826c1aaddfc41d54a5b3f52be9feb73a0b193ebc", "message": "[FLINK-16641][network] Announce sender's backlog to solve the deadlock issue without exclusive buffers\n\nThis commit improves the current backlog announcement logic in two main aspects:\n1. If there is no initial credit, the upstream producer task will announce the available backlog to the downstream consumer task when available data is notified.\n2. The downstream consumer task will release all allocated buffers (credit) on receiving the aligned checkpoint barrier. Besides, it will never allocate any credit before checkpoint completion.\n3. For empty buffers of the upstream task, instead of released directly, they will be sent to the downstream task to release the buffers (credit) allocated for them.", "committedDate": "2021-07-07T08:46:21Z", "type": "forcePushed"}, {"oid": "01b2bc58b30a2a3730895f7c50ff59099bd273d2", "url": "https://github.com/apache/flink/commit/01b2bc58b30a2a3730895f7c50ff59099bd273d2", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-08T12:39:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjMwMjY4MA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666302680", "bodyText": "nit: Rename to getBuffersInBacklogUnsafe() (previously it was a private method just made @VisibleForTesting)", "author": "pnowojski", "createdAt": "2021-07-08T15:31:22Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -517,16 +520,16 @@ private void increaseBuffersInBacklog(BufferConsumer buffer) {\n         }\n     }\n \n-    /**\n-     * Gets the number of non-event buffers in this subpartition.\n-     *\n-     * <p><strong>Beware:</strong> This method should only be used in tests in non-concurrent access\n-     * scenarios since it does not make any concurrency guarantees.\n-     */\n-    @SuppressWarnings(\"FieldAccessNotGuarded\")\n-    @VisibleForTesting\n+    /** Gets the number of non-event buffers in this subpartition. */\n+    @Override\n     public int getBuffersInBacklog() {", "originalCommit": "c9956bc098175364585e5661d5d4ca097b2fe876", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666340771", "bodyText": "I can not seem to respond in the previous thread, so I need to start a new one.\n\nLet's maybe focus on the 3rd case first and we assume that the exclusive credit is 0.\n\nThere are only one data buffer in the queue.\nFlush triggered.\nAll data of the first buffer is committed but the buffer is still not finished.\nAll data of the buffer is consumed by pollBuffer and the available credit becomes 0.\nThe first buffer is finished, the second event is added and the data available notification is triggered.\nThe upstream announces backlog to the downstream to request a credit.\nThe upstream receives available credit and start to pollBuffer.\nSkip the first empty buffer and send the second event.\nThe downstream receive the event but the event does not consume any credit.\n\nDo you mean we should change the current logic and release the floating buffer for event in some cases (including reduce the available credit by 1 at the upstream, currently the available credit is not decreased for event)?\n\nNo, but I think we could send this regardless if any is credit available or not as we are doing right now. I think we are also already attaching information about the backlog to such event. One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?\n\nIf there are multiple empty buffers, should we just skip the first one or should we skip all?\n\nWe could skip all of them, until we reach one of the three options:\n\nnon empty data buffer\nevent (check above)\nlast empty buffer, without any events after it - here we would indeed need to send that empty buffer", "author": "pnowojski", "createdAt": "2021-07-08T16:19:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -312,6 +323,16 @@ BufferAndBacklog pollBuffer() {\n                     decreaseBuffersInBacklogUnsafe(bufferConsumer.isBuffer());\n                 }\n \n+                // if we have an empty finished buffer and the exclusive credit is 0, we just return\n+                // the empty buffer so that the downstream task can release the allocated credit for\n+                // this empty buffer, this happens in two main scenarios currently:\n+                // 1. all data of a buffer builder has been read and after that the buffer builder\n+                // is finished\n+                // 2. in approximate recovery mode, a partial record takes a whole buffer builder\n+                if (buffersPerChannel == 0 && bufferConsumer.isFinished()) {\n+                    break;\n+                }\n+", "originalCommit": "faee760500feb1a2f793a6d691a1d061b1d17917", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjYyNjg4Ng==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666626886", "bodyText": "One thing to add (unless we are not doing it already) would be to use this backlog information, to maybe release floating buffers if backlog dropped to 0?\n\nCurrently, we are not doing that. Actually, I think it is a little complicated to do so. Because we need to keep consistency between the sender side available credit and the receiver side floating buffers. If we just release the floating buffers at the receiver side, if the sender side available credit is not reset, then there is may data sent out without buffers at receiver side to receive them. If we also reset the available credit at the sender side when the backlog is 0, there is a possibility that some AddCredit messages are on the way and we are not resetting this part. Maybe one way is to not sending any data out after sending a buffer with 0 backlog at sender side, then the receivers clear all floating credits and send a reset message to the senders. Then the senders reset all available credits. This process is similar to the channel blocking and resumption. I think this is a little complicated and can incur extra overhead.\nWhat do you think? Or is there any simple way?", "author": "wsry", "createdAt": "2021-07-09T02:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjY3Nzk5Nw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666677997", "bodyText": "Yes, you are right. It wouldn't be that simple. In that case, how complicated would it be to optimise the code to skip the all of the empty buffers until:\n\nnon empty data buffer\nevent (then send empty buffer first)\nlast empty buffer, without any events after it - here we would indeed need to send that empty buffer\n\n?", "author": "pnowojski", "createdAt": "2021-07-09T05:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjcyMzU0Mw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666723543", "bodyText": "Currently, I can only come up with the following way, which depends on the downstream to reset the available credit of the upstream. This at least needs to add a special network message and propagating this message can incur extra overhead. If you think this is really important, I will spend some time to rethink about it and see if I can find a better way to solve it.\n\nMaybe one way is to not sending any data out after sending a buffer with 0 backlog at sender side, then the receivers clear all floating credits and send a reset message to the senders. Then the senders reset all available credits. This process is similar to the channel blocking and resumption.", "author": "wsry", "createdAt": "2021-07-09T07:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1MjExMw==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666752113", "bodyText": "Ok, let's go with the current way for now, as with buffersPerChannel == 0 check it's not that critical. But it would be nice if you could spend a little time thinking if we can improve this.", "author": "pnowojski", "createdAt": "2021-07-09T07:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc2MTQzOA==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666761438", "bodyText": "OK, thanks a lot. I will spend some time thinking if we can improve it.", "author": "wsry", "createdAt": "2021-07-09T08:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NjM0MDc3MQ=="}], "type": "inlineReview"}, {"oid": "2792e1a43d72ffc013bb60bdea52a577316d933a", "url": "https://github.com/apache/flink/commit/2792e1a43d72ffc013bb60bdea52a577316d933a", "message": "Fixup", "committedDate": "2021-07-09T03:57:07Z", "type": "forcePushed"}, {"oid": "d4b35b61d395564b24dd98896b785e22c6e3ab30", "url": "https://github.com/apache/flink/commit/d4b35b61d395564b24dd98896b785e22c6e3ab30", "message": "Fixup", "committedDate": "2021-07-09T03:59:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1NjI0MQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666756241", "bodyText": "rename networkBuffersPerChannel -> configuredNetworkBuffersPerChannel to better reflect that we are actually overriding this value for the output?", "author": "pnowojski", "createdAt": "2021-07-09T08:05:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/ResultPartitionFactory.java", "diffHunk": "@@ -156,15 +155,16 @@ public ResultPartition create(\n                             bufferCompressor,\n                             bufferPoolFactory);\n \n-            BiFunction<Integer, PipelinedResultPartition, PipelinedSubpartition> factory;\n-            if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n-                factory = PipelinedApproximateSubpartition::new;\n-            } else {\n-                factory = PipelinedSubpartition::new;\n-            }\n-\n             for (int i = 0; i < subpartitions.length; i++) {\n-                subpartitions[i] = factory.apply(i, pipelinedPartition);\n+                if (type == ResultPartitionType.PIPELINED_APPROXIMATE) {\n+                    subpartitions[i] =\n+                            new PipelinedApproximateSubpartition(\n+                                    i, networkBuffersPerChannel, pipelinedPartition);", "originalCommit": "a3f6a9f67fcb3429ce0b086c3384f14ff4a31b29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2Njc1Njk5NQ==", "url": "https://github.com/apache/flink/pull/11877#discussion_r666756995", "bodyText": "Can we rename this property to something like receiverExclusiveBuffersPerChannel?  Because actually this is not the number of buffersPerChannel for the sender.", "author": "pnowojski", "createdAt": "2021-07-09T08:06:49Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/PipelinedSubpartition.java", "diffHunk": "@@ -112,8 +120,11 @@\n \n     // ------------------------------------------------------------------------\n \n-    PipelinedSubpartition(int index, ResultPartition parent) {\n+    PipelinedSubpartition(int index, int buffersPerChannel, ResultPartition parent) {\n         super(index, parent);\n+\n+        checkArgument(buffersPerChannel >= 0, \"Buffers per channel must be non-negative.\");\n+        this.buffersPerChannel = buffersPerChannel;", "originalCommit": "a3f6a9f67fcb3429ce0b086c3384f14ff4a31b29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da81fde5fc9e110075cff4982048b7f7ee3a0d61", "url": "https://github.com/apache/flink/commit/da81fde5fc9e110075cff4982048b7f7ee3a0d61", "message": "Fixup", "committedDate": "2021-07-10T10:18:42Z", "type": "forcePushed"}, {"oid": "dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "url": "https://github.com/apache/flink/commit/dbb34f9ce26fdec9ee5a6d67b9545dd2cbb18903", "message": "[hotfix] Remove redundant if condition in BufferManager\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "29d20e309908eea85d077c9f96f9c337217ee89b", "url": "https://github.com/apache/flink/commit/29d20e309908eea85d077c9f96f9c337217ee89b", "message": "[hotfix] Remove outdated comments in UnionInputGate\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "c3428a92d528b20b61d030429b9099347144256d", "url": "https://github.com/apache/flink/commit/c3428a92d528b20b61d030429b9099347144256d", "message": "[hotfix] Simplify RemoteInputChannel#onSenderBacklog and call the existing method directly\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "b23c8f4778af071cb16b0f80b8357db4477ff812", "url": "https://github.com/apache/flink/commit/b23c8f4778af071cb16b0f80b8357db4477ff812", "message": "[hotfix] Fix typos in NettyShuffleUtils\n\nThis closes #11877.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "bede6d39163df06f22a1d64df440d1067408b2ec", "url": "https://github.com/apache/flink/commit/bede6d39163df06f22a1d64df440d1067408b2ec", "message": "[FLINK-16641][network] (Part#1) Introduce a new network message BacklogAnnouncement which can bring the upstream buffer backlog to the downstream", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "url": "https://github.com/apache/flink/commit/0ffa4e02e374cc5724552a4af8a15d03c8e31cca", "message": "[FLINK-16641][network] (Part#2) Distinguish data buffer and event buffer for BoundedBlockingSubpartitionDirectTransferReader\n\nCurrently, the BoundedBlockingSubpartitionDirectTransferReader does not distinguish data buffer and event buffer but it does not allocate floating credits for events, which means it relies on at least one exclusive credit to send the events. This patch changes the logic and distinguishes data buffer and event buffer for BoundedBlockingSubpartitionDirectTransferReader, after which the BoundedBlockingSubpartitionDirectTransferReader does not rely on the exclusive credits any more and we can set the exclusive credit to 0 after we finish FLINK-16641.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "url": "https://github.com/apache/flink/commit/639672bb7f1223ab6612090d72ad7cf20fb8bfcc", "message": "[FLINK-16641][network] (Part#3) Support to announce the upstream backlog to the downstream tasks\n\nThis batch introduce the ability of announcing upstream backlog to the downstream tasks through the BacklogAnnouncement message when the exclusive credit is 0. This gives the upstream tasks the ability to actively allocate credits from the downstream tasks, which is needed by FLINK-16641.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "url": "https://github.com/apache/flink/commit/412f55d8faa4ce6d8b014db6044da2ddac6b1e3b", "message": "[FLINK-16641][network] (Part#4) Release all allocated floating buffers of RemoteInputChannel on receiving any channel blocking event if the exclusive credit is 0\n\nThis patch tries to release all allocated floating buffers of RemoteInputChannel on receiving any channel blocking event if the exclusive credit is 0 because a blocked channel does not need any credit and after that, these released credits can be used by other active channels. This can avoid the deadlock where credits are assigned to channels which do need them and those channels who need credits can not get any when the exclusive credit is 0.", "committedDate": "2021-07-12T10:30:47Z", "type": "commit"}, {"oid": "941de53b0ae20ae40a820a1bb0e35c6d189a7221", "url": "https://github.com/apache/flink/commit/941de53b0ae20ae40a820a1bb0e35c6d189a7221", "message": "[FLINK-16641][network] (Part#5) Send empty buffers to the downstream tasks to release the allocated credits if the exclusive credit is 0\n\nCurrently,the empty buffers are not sent to the downstream tasks. This patch changes the logic and sends empty buffers to the downstream tasks when the exclusive credit is 0 release the allocated floating credits. If we do not do that, the downstream task may allocate more credits than needed which may lead to dead lock without exclusive credits.", "committedDate": "2021-07-12T10:45:01Z", "type": "commit"}, {"oid": "4609625eac16247f2d70d8c36c42b3e2dfec8768", "url": "https://github.com/apache/flink/commit/4609625eac16247f2d70d8c36c42b3e2dfec8768", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-12T11:16:21Z", "type": "commit"}, {"oid": "4609625eac16247f2d70d8c36c42b3e2dfec8768", "url": "https://github.com/apache/flink/commit/4609625eac16247f2d70d8c36c42b3e2dfec8768", "message": "[FLINK-16641][network] (Part#6) Enable to set network buffers per channel to 0\n\nThis PR enables to set the number of network buffer per channel (taskmanager.network.memory.buffers-per-channel) to 0. Previously, the value can not be set to 0 because of dead lock, FLINK-16641 solves the problem and we can set it to 0 now.", "committedDate": "2021-07-12T11:16:21Z", "type": "forcePushed"}]}