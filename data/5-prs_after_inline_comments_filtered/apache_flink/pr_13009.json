{"pr_number": 13009, "pr_title": "[FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy", "pr_createdAt": "2020-07-28T15:22:46Z", "pr_url": "https://github.com/apache/flink/pull/13009", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY3NjQxMw==", "url": "https://github.com/apache/flink/pull/13009#discussion_r461676413", "bodyText": "One known defect is the grouping of execution vertices from brother job vertices are possible suboptimal because it does not take connections to consumers vertices into account.\nExample: A(parallelism=4) --forward--> C(parallelism=4), B(parallelism=2) --rescale--> C\nExecution edges are: A1->C1, A2->C2, A3->C3, A4->C4; B1->C1, B1->C2, B2->C3,B2->C4\nOptimal grouping: {A1,B1,C1}{A2,C2}{A3,B2,C3}{A4,C4}     ->   there would be 2 remote edges\nCurrent grouping result: {A1,B1,C1} {A2,B2,C2}  {A3,C3}  {A4,C4}     ->   there would be 3 remote edges", "author": "zhuzhurk", "createdAt": "2020-07-28T15:34:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:", "originalCommit": "044578bc01da8b57e29a483ee2560a0e8f61148a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExODY4Ng==", "url": "https://github.com/apache/flink/pull/13009#discussion_r463118686", "bodyText": "If we do not want to do the full complicated connected graph analysis (harder to maintain), we could a lighter optimisation now or later. After the suggested traversal, we could do one more traversal where we try to move producers closer to their consumers if the producers are not already bounded by other co-located consumers or possibly by a co-location constraint. Parent producers of the producers (if parent ones have less parallelism) should not bound them for the move if the second traversal is bottom->up.", "author": "azagrebin", "createdAt": "2020-07-30T16:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY3NjQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ3NzY4Nw==", "url": "https://github.com/apache/flink/pull/13009#discussion_r463477687", "bodyText": "Result of our offline discussion with @tillrohrmann:\nThe described suboptimal case is not a strict regression because the existing SlotSharingManager can already produce this suboptimal case. The SlotSharingStrategy is already designed to be pluggable. Therefore, we can focus on the overall new bulk allocation implementation and optimize the simplest SlotSharingStrategy approach, suggested in this PR, later.", "author": "azagrebin", "createdAt": "2020-07-31T08:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTY3NjQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1NTY0Mg==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462855642", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tinterface Factory {\n          \n          \n            \n                @FunctionalInterface\n          \n          \n            \n            \tinterface Factory {", "author": "azagrebin", "createdAt": "2020-07-30T09:02:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/SlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.Set;\n+\n+/**\n+ * Strategy which determines {@link ExecutionSlotSharingGroup} for each execution vertex.\n+ */\n+interface SlotSharingStrategy {\n+\n+\tExecutionSlotSharingGroup getExecutionSlotSharingGroup(\n+\t\tExecutionVertexID executionVertexId);\n+\n+\tSet<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups();\n+\n+\tinterface Factory {", "originalCommit": "3b217eff2a9bc97b6a2ea663e91b2f9a688de5ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NzA0MA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464557040", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-08-03T17:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1NTY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1NzM2NQ==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462857365", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic CoLocationConstraintDesc(final AbstractID coLocationGroupId, final int constraintIndex) {\n          \n          \n            \n            \tCoLocationConstraintDesc(final AbstractID coLocationGroupId, final int constraintIndex) {", "author": "azagrebin", "createdAt": "2020-07-30T09:05:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/CoLocationConstraintDesc.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmanager.scheduler;\n+\n+import org.apache.flink.util.AbstractID;\n+\n+import java.util.Objects;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A read-only and light weight version of {@link CoLocationConstraint}.\n+ */\n+public class CoLocationConstraintDesc {\n+\n+\tprivate final AbstractID coLocationGroupId;\n+\n+\tprivate final int constraintIndex;\n+\n+\tpublic CoLocationConstraintDesc(final AbstractID coLocationGroupId, final int constraintIndex) {", "originalCommit": "3b217eff2a9bc97b6a2ea663e91b2f9a688de5ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1Njk4MQ==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464556981", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-08-03T17:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1NzM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1Nzk4NA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462857984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\treturn vertices;\n          \n          \n            \n            \t\treturn Collections.unmodifiableList(vertices);", "author": "azagrebin", "createdAt": "2020-07-30T09:06:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmanager/scheduler/CoLocationGroupDesc.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmanager.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.jobgraph.JobVertex;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.util.AbstractID;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A read-only and light weight version of {@link CoLocationGroup}.\n+ */\n+public class CoLocationGroupDesc {\n+\n+\tprivate final AbstractID id;\n+\n+\tprivate final List<JobVertexID> vertices;\n+\n+\tprivate CoLocationGroupDesc(final AbstractID id, final List<JobVertexID> vertices) {\n+\t\tthis.id = checkNotNull(id);\n+\t\tthis.vertices = checkNotNull(vertices);\n+\t}\n+\n+\tpublic AbstractID getId() {\n+\t\treturn id;\n+\t}\n+\n+\tpublic List<JobVertexID> getVertices() {\n+\t\treturn vertices;", "originalCommit": "3b217eff2a9bc97b6a2ea663e91b2f9a688de5ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1Njk0NA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464556944", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-08-03T17:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg1Nzk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MTYzMQ==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462961631", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n          \n          \n            \n            \t\t\t// loop on job vertices so that an execution vertex will not be added into a group", "author": "azagrebin", "createdAt": "2020-07-30T12:31:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group", "originalCommit": "044578bc01da8b57e29a483ee2560a0e8f61148a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NjkxMg==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464556912", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-08-03T17:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjExMA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462962110", "bodyText": "Is allVertices LinkedHashMap because we assume that topology gives the vertexes in the topological order to assign vertexes to their producers' groups ?", "author": "azagrebin", "createdAt": "2020-07-30T12:32:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();", "originalCommit": "044578bc01da8b57e29a483ee2560a0e8f61148a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyODk2OA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464528968", "bodyText": "Yes. BaseTopology#getVertices() is defined to return vertices in topological order. And we need LinkedHashMap to retain this order.", "author": "zhuzhurk", "createdAt": "2020-08-03T16:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzQxNA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r465137414", "bodyText": "thanks for confirmation", "author": "azagrebin", "createdAt": "2020-08-04T15:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NjExNQ==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462976115", "bodyText": "Do you know whether we have some kind of check whether the co-location constraint does not contradict to the slot sharing group? like 2 executions must be co-located according to the co-location constraint but they are in different logical slot sharing groups (e.g. forced by user in API)?", "author": "azagrebin", "createdAt": "2020-07-30T12:57:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n+\t\t\t// if that group better fits another execution vertex\n+\t\t\tfor (List<SchedulingExecutionVertex> executionVertices : allVertices.values()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> remaining = tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\t\texecutionVertices);\n+\n+\t\t\t\tfindAvailableOrCreateNewExecutionSlotSharingGroupFor(remaining);\n+\n+\t\t\t\tupdateConstraintToExecutionSlotSharingGroupMap(executionVertices);\n+\t\t\t}\n+\n+\t\t\treturn executionSlotSharingGroupMap;\n+\t\t}\n+\n+\t\tprivate LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> getExecutionVertices() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> vertices = new LinkedHashMap<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : topology.getVertices()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertexGroup = vertices.computeIfAbsent(\n+\t\t\t\t\texecutionVertex.getId().getJobVertexId(),\n+\t\t\t\t\tk -> new ArrayList<>());\n+\t\t\t\texecutionVertexGroup.add(executionVertex);\n+\t\t\t}\n+\t\t\treturn vertices;\n+\t\t}\n+\n+\t\tprivate List<SchedulingExecutionVertex> tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfinal List<SchedulingExecutionVertex> remaining = new ArrayList<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\tExecutionSlotSharingGroup group = tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(executionVertex);\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tgroup = tryFindAvailableProducerExecutionSlotSharingGroupFor(executionVertex);\n+\t\t\t\t}\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tremaining.add(executionVertex);\n+\t\t\t\t} else {\n+\t\t\t\t\taddVertexToExecutionSlotSharingGroup(executionVertex, group);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn remaining;\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\t\t\tfinal CoLocationGroupDesc coLocationGroup = coLocationGroupMap.get(executionVertexId.getJobVertexId());\n+\t\t\tif (coLocationGroup != null) {\n+\t\t\t\tfinal CoLocationConstraintDesc constraint = coLocationGroup.getLocationConstraint(\n+\t\t\t\t\texecutionVertexId.getSubtaskIndex());\n+\n+\t\t\t\treturn constraintToExecutionSlotSharingGroupMap.get(constraint);", "originalCommit": "044578bc01da8b57e29a483ee2560a0e8f61148a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzMTQzNA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464531434", "bodyText": "There are such checks in StreamingJobGraphGenerator#setCoLocation() for DataStream/SQL jobs and JobVertex#setStrictlyCoLocatedWith() for DataSet jobs.", "author": "zhuzhurk", "createdAt": "2020-08-03T16:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NjExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzYyNQ==", "url": "https://github.com/apache/flink/pull/13009#discussion_r465137625", "bodyText": "alright, thanks for pointing out", "author": "azagrebin", "createdAt": "2020-08-04T15:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3NjExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Nzk2Ng==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462977966", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\treturn slotSharingGroupId1 != null && slotSharingGroupId1.equals(slotSharingGroupId2);\n          \n          \n            \n            \t\t\treturn Objects.equals(slotSharingGroupId1, slotSharingGroupId2);", "author": "azagrebin", "createdAt": "2020-07-30T13:00:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n+\t\t\t// if that group better fits another execution vertex\n+\t\t\tfor (List<SchedulingExecutionVertex> executionVertices : allVertices.values()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> remaining = tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\t\texecutionVertices);\n+\n+\t\t\t\tfindAvailableOrCreateNewExecutionSlotSharingGroupFor(remaining);\n+\n+\t\t\t\tupdateConstraintToExecutionSlotSharingGroupMap(executionVertices);\n+\t\t\t}\n+\n+\t\t\treturn executionSlotSharingGroupMap;\n+\t\t}\n+\n+\t\tprivate LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> getExecutionVertices() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> vertices = new LinkedHashMap<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : topology.getVertices()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertexGroup = vertices.computeIfAbsent(\n+\t\t\t\t\texecutionVertex.getId().getJobVertexId(),\n+\t\t\t\t\tk -> new ArrayList<>());\n+\t\t\t\texecutionVertexGroup.add(executionVertex);\n+\t\t\t}\n+\t\t\treturn vertices;\n+\t\t}\n+\n+\t\tprivate List<SchedulingExecutionVertex> tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfinal List<SchedulingExecutionVertex> remaining = new ArrayList<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\tExecutionSlotSharingGroup group = tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(executionVertex);\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tgroup = tryFindAvailableProducerExecutionSlotSharingGroupFor(executionVertex);\n+\t\t\t\t}\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tremaining.add(executionVertex);\n+\t\t\t\t} else {\n+\t\t\t\t\taddVertexToExecutionSlotSharingGroup(executionVertex, group);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn remaining;\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\t\t\tfinal CoLocationGroupDesc coLocationGroup = coLocationGroupMap.get(executionVertexId.getJobVertexId());\n+\t\t\tif (coLocationGroup != null) {\n+\t\t\t\tfinal CoLocationConstraintDesc constraint = coLocationGroup.getLocationConstraint(\n+\t\t\t\t\texecutionVertexId.getSubtaskIndex());\n+\n+\t\t\t\treturn constraintToExecutionSlotSharingGroupMap.get(constraint);\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableProducerExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\n+\t\t\tfor (SchedulingResultPartition partition : executionVertex.getConsumedResults()) {\n+\t\t\t\tfinal ExecutionVertexID producerVertexId = partition.getProducer().getId();\n+\t\t\t\tif (!inSameLogicalSlotSharingGroup(producerVertexId, executionVertexId)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tfinal ExecutionSlotSharingGroup producerGroup = executionSlotSharingGroupMap.get(producerVertexId);\n+\n+\t\t\t\tcheckState(producerGroup != null);\n+\t\t\t\tif (isGroupAvailableForVertex(producerGroup, executionVertexId)) {\n+\t\t\t\t\treturn producerGroup;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprivate boolean inSameLogicalSlotSharingGroup(\n+\t\t\t\tfinal ExecutionVertexID executionVertexId1,\n+\t\t\t\tfinal ExecutionVertexID executionVertexId2) {\n+\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId1 = slotSharingGroupMap.get(executionVertexId1.getJobVertexId());\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId2 = slotSharingGroupMap.get(executionVertexId2.getJobVertexId());\n+\n+\t\t\treturn slotSharingGroupId1 != null && slotSharingGroupId1.equals(slotSharingGroupId2);", "originalCommit": "044578bc01da8b57e29a483ee2560a0e8f61148a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUzMzA1OA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464533058", "bodyText": "It's a bit different since I had wanted it to return false if either slotSharingGroup is null.", "author": "zhuzhurk", "createdAt": "2020-08-03T16:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Nzk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1Njc2Ng==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464556766", "bodyText": "But given that we now assumes that slotSharingGroup cannot be null. We can do this simplification.", "author": "zhuzhurk", "createdAt": "2020-08-03T17:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Nzk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MzU1NQ==", "url": "https://github.com/apache/flink/pull/13009#discussion_r465143555", "bodyText": "alright, makes sense", "author": "azagrebin", "createdAt": "2020-08-04T15:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3Nzk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MDE0Ng==", "url": "https://github.com/apache/flink/pull/13009#discussion_r462990146", "bodyText": "Can this happen at this point?\nIf I understand correctly, if a vertex does not belong to any group then it belongs to the default group according to user docs. So then the question is whether the default group already has a slotSharingGroupId at this point:\n\nif yes, then this should not happen\nif no, then do we risk to create a new slotSharingGroupId for each executionVertex from the default group?", "author": "azagrebin", "createdAt": "2020-07-30T13:20:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/LocalInputPreferredSlotSharingStrategy.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraintDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroupDesc;\n+import org.apache.flink.runtime.jobmanager.scheduler.SlotSharingGroup;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingExecutionVertex;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingResultPartition;\n+import org.apache.flink.runtime.scheduler.strategy.SchedulingTopology;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This strategy tries to reduce remote data exchanges. Execution vertices, which are connected\n+ * and belong to the same SlotSharingGroup, tend to be put in the same ExecutionSlotSharingGroup.\n+ * Co-location constraints will be respected.\n+ */\n+class LocalInputPreferredSlotSharingStrategy implements SlotSharingStrategy {\n+\n+\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\tLocalInputPreferredSlotSharingStrategy(\n+\t\t\tfinal SchedulingTopology topology,\n+\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\tthis.executionSlotSharingGroupMap = new ExecutionSlotSharingGroupBuilder(\n+\t\t\ttopology,\n+\t\t\tlogicalSlotSharingGroups,\n+\t\t\tcoLocationGroups).build();\n+\t}\n+\n+\t@Override\n+\tpublic ExecutionSlotSharingGroup getExecutionSlotSharingGroup(final ExecutionVertexID executionVertexId) {\n+\t\treturn executionSlotSharingGroupMap.get(executionVertexId);\n+\t}\n+\n+\t@Override\n+\tpublic Set<ExecutionSlotSharingGroup> getExecutionSlotSharingGroups() {\n+\t\treturn new HashSet<>(executionSlotSharingGroupMap.values());\n+\t}\n+\n+\tstatic class Factory implements SlotSharingStrategy.Factory {\n+\n+\t\tpublic LocalInputPreferredSlotSharingStrategy create(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\treturn new LocalInputPreferredSlotSharingStrategy(topology, logicalSlotSharingGroups, coLocationGroups);\n+\t\t}\n+\t}\n+\n+\tprivate static class ExecutionSlotSharingGroupBuilder {\n+\t\tprivate final SchedulingTopology topology;\n+\n+\t\tprivate final Map<JobVertexID, SlotSharingGroupId> slotSharingGroupMap;\n+\n+\t\tprivate final Map<JobVertexID, CoLocationGroupDesc> coLocationGroupMap;\n+\n+\t\tprivate final Map<ExecutionVertexID, ExecutionSlotSharingGroup> executionSlotSharingGroupMap;\n+\n+\t\tfinal Map<CoLocationConstraintDesc, ExecutionSlotSharingGroup> constraintToExecutionSlotSharingGroupMap;\n+\n+\t\tfinal Map<SlotSharingGroupId, List<ExecutionSlotSharingGroup>> executionSlotSharingGroups;\n+\n+\t\tprivate final Map<ExecutionSlotSharingGroup, Set<JobVertexID>> assignedJobVerticesForGroups;\n+\n+\t\tprivate ExecutionSlotSharingGroupBuilder(\n+\t\t\t\tfinal SchedulingTopology topology,\n+\t\t\t\tfinal Set<SlotSharingGroup> logicalSlotSharingGroups,\n+\t\t\t\tfinal Set<CoLocationGroupDesc> coLocationGroups) {\n+\n+\t\t\tthis.topology = checkNotNull(topology);\n+\n+\t\t\tthis.slotSharingGroupMap = new HashMap<>();\n+\t\t\tfor (SlotSharingGroup slotSharingGroup : logicalSlotSharingGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : slotSharingGroup.getJobVertexIds()) {\n+\t\t\t\t\tslotSharingGroupMap.put(jobVertexId, slotSharingGroup.getSlotSharingGroupId());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tthis.coLocationGroupMap = new HashMap<>();\n+\t\t\tfor (CoLocationGroupDesc coLocationGroup : coLocationGroups) {\n+\t\t\t\tfor (JobVertexID jobVertexId : coLocationGroup.getVertices()) {\n+\t\t\t\t\tcoLocationGroupMap.put(jobVertexId, coLocationGroup);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\texecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\tconstraintToExecutionSlotSharingGroupMap = new HashMap<>();\n+\t\t\texecutionSlotSharingGroups = new HashMap<>();\n+\t\t\tassignedJobVerticesForGroups = new IdentityHashMap<>();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Build ExecutionSlotSharingGroups for all vertices in the topology.\n+\t\t * The ExecutionSlotSharingGroup of a vertex is determined in order below:\n+\t\t *\n+\t\t * <p>1. try finding an existing group of the corresponding co-location constraint.\n+\t\t *\n+\t\t * <p>2. try finding an available group of its producer vertex if the producer is in the same slot sharing group.\n+\t\t *\n+\t\t * <p>3. try finding any available group.\n+\t\t *\n+\t\t * <p>4. create a new group.\n+\t\t */\n+\t\tprivate Map<ExecutionVertexID, ExecutionSlotSharingGroup> build() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> allVertices = getExecutionVertices();\n+\n+\t\t\t// loop on job vertices so that an execution vertex will not be add into a group\n+\t\t\t// if that group better fits another execution vertex\n+\t\t\tfor (List<SchedulingExecutionVertex> executionVertices : allVertices.values()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> remaining = tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\t\texecutionVertices);\n+\n+\t\t\t\tfindAvailableOrCreateNewExecutionSlotSharingGroupFor(remaining);\n+\n+\t\t\t\tupdateConstraintToExecutionSlotSharingGroupMap(executionVertices);\n+\t\t\t}\n+\n+\t\t\treturn executionSlotSharingGroupMap;\n+\t\t}\n+\n+\t\tprivate LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> getExecutionVertices() {\n+\t\t\tfinal LinkedHashMap<JobVertexID, List<SchedulingExecutionVertex>> vertices = new LinkedHashMap<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : topology.getVertices()) {\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertexGroup = vertices.computeIfAbsent(\n+\t\t\t\t\texecutionVertex.getId().getJobVertexId(),\n+\t\t\t\t\tk -> new ArrayList<>());\n+\t\t\t\texecutionVertexGroup.add(executionVertex);\n+\t\t\t}\n+\t\t\treturn vertices;\n+\t\t}\n+\n+\t\tprivate List<SchedulingExecutionVertex> tryFindOptimalAvailableExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfinal List<SchedulingExecutionVertex> remaining = new ArrayList<>();\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\tExecutionSlotSharingGroup group = tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(executionVertex);\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tgroup = tryFindAvailableProducerExecutionSlotSharingGroupFor(executionVertex);\n+\t\t\t\t}\n+\n+\t\t\t\tif (group == null) {\n+\t\t\t\t\tremaining.add(executionVertex);\n+\t\t\t\t} else {\n+\t\t\t\t\taddVertexToExecutionSlotSharingGroup(executionVertex, group);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn remaining;\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableCoLocatedExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\t\t\tfinal CoLocationGroupDesc coLocationGroup = coLocationGroupMap.get(executionVertexId.getJobVertexId());\n+\t\t\tif (coLocationGroup != null) {\n+\t\t\t\tfinal CoLocationConstraintDesc constraint = coLocationGroup.getLocationConstraint(\n+\t\t\t\t\texecutionVertexId.getSubtaskIndex());\n+\n+\t\t\t\treturn constraintToExecutionSlotSharingGroupMap.get(constraint);\n+\t\t\t} else {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate ExecutionSlotSharingGroup tryFindAvailableProducerExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal SchedulingExecutionVertex executionVertex) {\n+\n+\t\t\tfinal ExecutionVertexID executionVertexId = executionVertex.getId();\n+\n+\t\t\tfor (SchedulingResultPartition partition : executionVertex.getConsumedResults()) {\n+\t\t\t\tfinal ExecutionVertexID producerVertexId = partition.getProducer().getId();\n+\t\t\t\tif (!inSameLogicalSlotSharingGroup(producerVertexId, executionVertexId)) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tfinal ExecutionSlotSharingGroup producerGroup = executionSlotSharingGroupMap.get(producerVertexId);\n+\n+\t\t\t\tcheckState(producerGroup != null);\n+\t\t\t\tif (isGroupAvailableForVertex(producerGroup, executionVertexId)) {\n+\t\t\t\t\treturn producerGroup;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprivate boolean inSameLogicalSlotSharingGroup(\n+\t\t\t\tfinal ExecutionVertexID executionVertexId1,\n+\t\t\t\tfinal ExecutionVertexID executionVertexId2) {\n+\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId1 = slotSharingGroupMap.get(executionVertexId1.getJobVertexId());\n+\t\t\tfinal SlotSharingGroupId slotSharingGroupId2 = slotSharingGroupMap.get(executionVertexId2.getJobVertexId());\n+\n+\t\t\treturn slotSharingGroupId1 != null && slotSharingGroupId1.equals(slotSharingGroupId2);\n+\t\t}\n+\n+\t\tprivate boolean isGroupAvailableForVertex(\n+\t\t\t\tfinal ExecutionSlotSharingGroup executionSlotSharingGroup,\n+\t\t\t\tfinal ExecutionVertexID executionVertexId) {\n+\n+\t\t\tfinal Set<JobVertexID> assignedVertices = assignedJobVerticesForGroups.get(executionSlotSharingGroup);\n+\t\t\treturn assignedVertices == null || !assignedVertices.contains(executionVertexId.getJobVertexId());\n+\t\t}\n+\n+\t\tprivate void addVertexToExecutionSlotSharingGroup(\n+\t\t\t\tfinal SchedulingExecutionVertex vertex,\n+\t\t\t\tfinal ExecutionSlotSharingGroup group) {\n+\n+\t\t\tgroup.addVertex(vertex.getId());\n+\t\t\texecutionSlotSharingGroupMap.put(vertex.getId(), group);\n+\t\t\tassignedJobVerticesForGroups.computeIfAbsent(group, k -> new HashSet<>()).add(vertex.getId().getJobVertexId());\n+\t\t}\n+\n+\t\tprivate void findAvailableOrCreateNewExecutionSlotSharingGroupFor(\n+\t\t\t\tfinal List<SchedulingExecutionVertex> executionVertices) {\n+\n+\t\t\tfor (SchedulingExecutionVertex executionVertex : executionVertices) {\n+\t\t\t\t// create a new slotSharingGroupId if the vertex is not in a slot sharing group", "originalCommit": "044578bc01da8b57e29a483ee2560a0e8f61148a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU0MjkxMA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464542910", "bodyText": "This should not happen in production.\nIf the slot sharing group name of an operator is set to be null in DataStream, its slotSharingGroup will be decided automatically, either in its producers' slot sharing group or in the default slot sharing group, and no chance to be null in production. See StreamGraphGenerator#determineSlotSharingGroup().\nHowever, in current runtime framework, slotSharingGroup is still treated as nullable in many places. I had once opened a ticket to propose to simply it https://issues.apache.org/jira/browse/FLINK-14870.\nIn this case, we can simplify it by having a sanity check to ensure that a vertex can never have a null slotSharingGroup.", "author": "zhuzhurk", "createdAt": "2020-08-03T17:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NjExOA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r464556118", "bodyText": "Done by introducing getSlotSharingGroupId(...) which checks the slot sharing group to be non-null.", "author": "zhuzhurk", "createdAt": "2020-08-03T17:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MDE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0MzIwNA==", "url": "https://github.com/apache/flink/pull/13009#discussion_r465143204", "bodyText": "Alright, makes sense", "author": "azagrebin", "createdAt": "2020-08-04T15:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MDE0Ng=="}], "type": "inlineReview"}, {"oid": "d7133401edf323e5be894758398098e70cf70506", "url": "https://github.com/apache/flink/commit/d7133401edf323e5be894758398098e70cf70506", "message": "fixup! [FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy", "committedDate": "2020-08-03T17:09:20Z", "type": "forcePushed"}, {"oid": "52f727e89f21c94f58b06647a70da769596872ca", "url": "https://github.com/apache/flink/commit/52f727e89f21c94f58b06647a70da769596872ca", "message": "[FLINK-18690][runtime] Introduce ExecutionSlotSharingGroup and SlotSharingStrategy interface", "committedDate": "2020-08-04T03:35:59Z", "type": "commit"}, {"oid": "557e982407c488191ade7cc66807662796b3a306", "url": "https://github.com/apache/flink/commit/557e982407c488191ade7cc66807662796b3a306", "message": "[FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy", "committedDate": "2020-08-04T03:37:04Z", "type": "commit"}, {"oid": "557e982407c488191ade7cc66807662796b3a306", "url": "https://github.com/apache/flink/commit/557e982407c488191ade7cc66807662796b3a306", "message": "[FLINK-18690][runtime] Implement LocalInputPreferredSlotSharingStrategy", "committedDate": "2020-08-04T03:37:04Z", "type": "forcePushed"}]}