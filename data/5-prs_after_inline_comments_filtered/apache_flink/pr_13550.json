{"pr_number": 13550, "pr_title": "[FLINK-19474] Implement a state backend that holds a single key at a time", "pr_createdAt": "2020-10-06T16:07:58Z", "pr_url": "https://github.com/apache/flink/pull/13550", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNjkxNA==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502326914", "bodyText": "Should also be in a method like for the other backends.", "author": "aljoscha", "createdAt": "2020-10-09T10:10:08Z", "path": "flink-state-backends/flink-statebackend-rocksdb/src/test/java/org/apache/flink/contrib/streaming/state/benchmark/StateBackendBenchmarkUtils.java", "diffHunk": "@@ -74,6 +75,24 @@\n \t\t\tcase ROCKSDB:\n \t\t\t\trootDir = prepareDirectory(rootDirName, null);\n \t\t\t\treturn createRocksDBKeyedStateBackend(rootDir);\n+\t\t\tcase SINGLE_KEY:\n+\t\t\t\ttry {\n+\t\t\t\t\treturn new SingleKeyStateBackend().createKeyedStateBackend(", "originalCommit": "5e658efd970cd23de2637876e59becdbf00a8921", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2ODIyNQ==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502368225", "bodyText": "Actually I did it and forgot to force push \ud83e\udd26", "author": "dawidwys", "createdAt": "2020-10-09T11:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMyNjkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMDk1OA==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502330958", "bodyText": "Why do we need to additionally deduplicate?", "author": "aljoscha", "createdAt": "2020-10-09T10:18:24Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/SingleKeyKeyGroupedInternalPriorityQueue.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.runtime.state.heap.HeapPriorityQueue;\n+import org.apache.flink.runtime.state.heap.HeapPriorityQueueElement;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Very similar implementation to {@link org.apache.flink.runtime.state.heap.HeapPriorityQueueSet}. The only difference\n+ * is it keeps track of elements for a single key at a time.\n+ */\n+class SingleKeyKeyGroupedInternalPriorityQueue<T extends HeapPriorityQueueElement>\n+\t\textends HeapPriorityQueue<T>\n+\t\timplements KeyGroupedInternalPriorityQueue<T> {\n+\n+\tprivate final Map<T, T> dedupMap = new HashMap<>();", "originalCommit": "5e658efd970cd23de2637876e59becdbf00a8921", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4MzYzNA==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502383634", "bodyText": "Good question.\nThe reason is that we actually always use the *PriorityQueue as a Set. We use the PriorityQueue for storing timers and that's why we need Set semantics. We want to fire only a single timer for a timestamp. BTW, the logic is copied over from the HeapPriorityQueueSet.\nHowever to better address it I will rename the class to BatchExecutionInternalPriorityQueueSet.", "author": "dawidwys", "createdAt": "2020-10-09T12:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5ODg5MA==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502398890", "bodyText": "Ok, thanks for the explanation!", "author": "aljoscha", "createdAt": "2020-10-09T12:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjMzMDk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MTUxNQ==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502341515", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A simple {@link CheckpointableKeyedStateBackend} which keeps values for a single key at a time.\n          \n          \n            \n             * A {@link CheckpointableKeyedStateBackend} which keeps values for a single key at a time.\n          \n      \n    \n    \n  \n\nI think simple rarely adds much information.", "author": "aljoscha", "createdAt": "2020-10-09T10:40:42Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/SingleKeyKeyedStateBackend.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.state.AggregatingStateDescriptor;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ReducingStateDescriptor;\n+import org.apache.flink.api.common.state.State;\n+import org.apache.flink.api.common.state.StateDescriptor;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.state.CheckpointStreamFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.Keyed;\n+import org.apache.flink.runtime.state.KeyedStateFunction;\n+import org.apache.flink.runtime.state.KeyedStateHandle;\n+import org.apache.flink.runtime.state.PriorityComparable;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.runtime.state.SnapshotResult;\n+import org.apache.flink.runtime.state.StateSnapshotTransformer;\n+import org.apache.flink.runtime.state.heap.HeapPriorityQueueElement;\n+import org.apache.flink.runtime.state.internal.InternalKvState;\n+import org.apache.flink.util.FlinkRuntimeException;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.RunnableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A simple {@link CheckpointableKeyedStateBackend} which keeps values for a single key at a time.", "originalCommit": "5e658efd970cd23de2637876e59becdbf00a8921", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MjQ3Mg==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502342472", "bodyText": "I'm wondering about the name here. If we always refer to BATCH execution mode in the exceptions, maybe the state backend should be called BatchExecutionStateBackend. Or do we think it could be used for any other purpose.", "author": "aljoscha", "createdAt": "2020-10-09T10:42:47Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/sorted/state/SingleKeyKeyedStateBackend.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators.sorted.state;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.state.AggregatingStateDescriptor;\n+import org.apache.flink.api.common.state.ListStateDescriptor;\n+import org.apache.flink.api.common.state.MapStateDescriptor;\n+import org.apache.flink.api.common.state.ReducingStateDescriptor;\n+import org.apache.flink.api.common.state.State;\n+import org.apache.flink.api.common.state.StateDescriptor;\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeutils.TypeSerializer;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.checkpoint.CheckpointOptions;\n+import org.apache.flink.runtime.state.CheckpointStreamFactory;\n+import org.apache.flink.runtime.state.CheckpointableKeyedStateBackend;\n+import org.apache.flink.runtime.state.KeyGroupRange;\n+import org.apache.flink.runtime.state.KeyGroupedInternalPriorityQueue;\n+import org.apache.flink.runtime.state.Keyed;\n+import org.apache.flink.runtime.state.KeyedStateFunction;\n+import org.apache.flink.runtime.state.KeyedStateHandle;\n+import org.apache.flink.runtime.state.PriorityComparable;\n+import org.apache.flink.runtime.state.PriorityComparator;\n+import org.apache.flink.runtime.state.SnapshotResult;\n+import org.apache.flink.runtime.state.StateSnapshotTransformer;\n+import org.apache.flink.runtime.state.heap.HeapPriorityQueueElement;\n+import org.apache.flink.runtime.state.internal.InternalKvState;\n+import org.apache.flink.util.FlinkRuntimeException;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.RunnableFuture;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A simple {@link CheckpointableKeyedStateBackend} which keeps values for a single key at a time.\n+ *\n+ * <p><b>IMPORTANT:</b> Requires the incoming records to be sorted/grouped by the key. Used in a BATCH style execution.\n+ */\n+class SingleKeyKeyedStateBackend<K> implements CheckpointableKeyedStateBackend<K> {\n+\t@SuppressWarnings(\"rawtypes\")\n+\tprivate static final Map<Class<? extends StateDescriptor>, StateFactory> STATE_FACTORIES =\n+\t\tStream.of(\n+\t\t\tTuple2.of(ValueStateDescriptor.class, (StateFactory) SingleKeyValueState::create),\n+\t\t\tTuple2.of(ListStateDescriptor.class, (StateFactory) SingleKeyListState::create),\n+\t\t\tTuple2.of(MapStateDescriptor.class, (StateFactory) SingleKeyMapState::create),\n+\t\t\tTuple2.of(AggregatingStateDescriptor.class, (StateFactory) SingleKeyAggregatingState::create),\n+\t\t\tTuple2.of(ReducingStateDescriptor.class, (StateFactory) SingleKeyReducingState::create)\n+\t\t).collect(Collectors.toMap(t -> t.f0, t -> t.f1));\n+\n+\tprivate K currentKey = null;\n+\tprivate final TypeSerializer<K> keySerializer;\n+\tprivate final List<KeySelectionListener<K>> keySelectionListeners = new ArrayList<>();\n+\tprivate final Map<String, State> states = new HashMap<>();\n+\tprivate final Map<String, KeyGroupedInternalPriorityQueue<?>> priorityQueues = new HashMap<>();\n+\tprivate final KeyGroupRange keyGroupRange;\n+\n+\tpublic SingleKeyKeyedStateBackend(\n+\t\t\tTypeSerializer<K> keySerializer,\n+\t\t\tKeyGroupRange keyGroupRange) {\n+\t\tthis.keySerializer = keySerializer;\n+\t\tthis.keyGroupRange = keyGroupRange;\n+\t}\n+\n+\t@Override\n+\tpublic void setCurrentKey(K newKey) {\n+\t\tif (!Objects.equals(newKey, currentKey)) {\n+\t\t\tnotifyKeySelected(newKey);\n+\t\t\tfor (State value : states.values()) {\n+\t\t\t\t((AbstractSingleKeyState<?, ?, ?>) value).clearAllNamespaces();\n+\t\t\t}\n+\t\t\tfor (KeyGroupedInternalPriorityQueue<?> value : priorityQueues.values()) {\n+\t\t\t\twhile (value.poll() != null) {\n+\t\t\t\t\t// remove everything for the key\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tthis.currentKey = newKey;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic K getCurrentKey() {\n+\t\treturn currentKey;\n+\t}\n+\n+\t@Override\n+\tpublic TypeSerializer<K> getKeySerializer() {\n+\t\treturn keySerializer;\n+\t}\n+\n+\t@Override\n+\tpublic <N, S extends State, T> void applyToAllKeys(\n+\t\t\tN namespace,\n+\t\t\tTypeSerializer<N> namespaceSerializer,\n+\t\t\tStateDescriptor<S, T> stateDescriptor,\n+\t\t\tKeyedStateFunction<K, S> function) {\n+\t\tthrow new UnsupportedOperationException(\"applyToAllKeys() is not supported in BATCH execution mode.\");", "originalCommit": "5e658efd970cd23de2637876e59becdbf00a8921", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM2ODQ5MQ==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502368491", "bodyText": "Personally I can't think of other scenarios...", "author": "dawidwys", "createdAt": "2020-10-09T11:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MjQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4MzgyNA==", "url": "https://github.com/apache/flink/pull/13550#discussion_r502383824", "bodyText": "Will rename the classes.", "author": "dawidwys", "createdAt": "2020-10-09T12:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM0MjQ3Mg=="}], "type": "inlineReview"}, {"oid": "b7d64e6761396fda8ace8c17d400a9e6d925d527", "url": "https://github.com/apache/flink/commit/b7d64e6761396fda8ace8c17d400a9e6d925d527", "message": "[FLINK-19474] Implement a state backend that holds a single key at a time\n\nThis commit introduces a SingleKeyStateBackend. This state backend is a\nsimplified version of a state backend that can be used in a BATCH\nruntime mode. It requires the input to be sorted, as it only ever\nremembers the current key. If the key changes, the current state is\ndiscarded. Moreover this state backend does not support checkpointing.", "committedDate": "2020-10-06T16:06:54Z", "type": "forcePushed"}, {"oid": "f8f50916ab86dc0db496722194a6ef16abffbc88", "url": "https://github.com/apache/flink/commit/f8f50916ab86dc0db496722194a6ef16abffbc88", "message": "fixup! Rename BatchExecution priority queue", "committedDate": "2020-10-09T12:12:57Z", "type": "forcePushed"}, {"oid": "eaa536db01b506ec59d94a3120fb93ba81cbe69e", "url": "https://github.com/apache/flink/commit/eaa536db01b506ec59d94a3120fb93ba81cbe69e", "message": "[FLINK-19474] Implement a state backend that holds a single key at a time\n\nThis commit introduces a SingleKeyStateBackend. This state backend is a\nsimplified version of a state backend that can be used in a BATCH\nruntime mode. It requires the input to be sorted, as it only ever\nremembers the current key. If the key changes, the current state is\ndiscarded. Moreover this state backend does not support checkpointing.", "committedDate": "2020-10-11T17:13:26Z", "type": "commit"}, {"oid": "eaa536db01b506ec59d94a3120fb93ba81cbe69e", "url": "https://github.com/apache/flink/commit/eaa536db01b506ec59d94a3120fb93ba81cbe69e", "message": "[FLINK-19474] Implement a state backend that holds a single key at a time\n\nThis commit introduces a SingleKeyStateBackend. This state backend is a\nsimplified version of a state backend that can be used in a BATCH\nruntime mode. It requires the input to be sorted, as it only ever\nremembers the current key. If the key changes, the current state is\ndiscarded. Moreover this state backend does not support checkpointing.", "committedDate": "2020-10-11T17:13:26Z", "type": "forcePushed"}]}