{"pr_number": 12815, "pr_title": "[FLINK-17075][coordination] Reconcile deployed Executions", "pr_createdAt": "2020-07-03T08:15:10Z", "pr_url": "https://github.com/apache/flink/pull/12815", "timeline": [{"oid": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "url": "https://github.com/apache/flink/commit/c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "message": "[FLINK-17075][coordination] Reconcile deployed Executions", "committedDate": "2020-07-03T08:13:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NjE2NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449576164", "bodyText": "I think we can move this to ExecutionGraph.notifyExecutionChange. That way we will only react to signals coming from a valid Execution.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:11:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -1601,6 +1604,8 @@ private boolean transitionState(ExecutionState currentState, ExecutionState targ\n \t\t\t\t}\n \t\t\t}\n \n+\t\t\tgetExecutionGraph().getExecutionStateUpdateListener().onStateUpdate(attemptId, state);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxODEyNw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449618127", "bodyText": "Yes, that should work.", "author": "zentol", "createdAt": "2020-07-03T14:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3NjE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3Njg0Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449576842", "bodyText": "What happens if this Execution is no longer valid (e.g. it has failed in the meantime?). Shouldn't we guard against this situation similar to what we do in ExecutionVertex.notifyStateTransition by checking what the currentExecution is?", "author": "tillrohrmann", "createdAt": "2020-07-03T13:12:40Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -753,8 +753,11 @@ public void deploy() throws JobException {\n \t\t\t\t.thenCompose(Function.identity())\n \t\t\t\t.whenCompleteAsync(\n \t\t\t\t\t(ack, failure) -> {\n-\t\t\t\t\t\t// only respond to the failure case\n-\t\t\t\t\t\tif (failure != null) {\n+\t\t\t\t\t\tif (failure == null) {\n+\t\t\t\t\t\t\tgetExecutionGraph()\n+\t\t\t\t\t\t\t\t.getExecutionDeploymentListener()\n+\t\t\t\t\t\t\t\t.onCompletedDeployment(attemptId, getAssignedResourceLocation().getResourceID());", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNzk5NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449617994", "bodyText": "So just guard the call with if (this == vertex.getCurrentExecutionAttempt())?", "author": "zentol", "createdAt": "2020-07-03T14:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3Njg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMTM0Nw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449621347", "bodyText": "Maybe follow a similar pattern as what we do in ExecutionVertex.notifyStateTransition. We could introduce a ExecutionVertex.completeDeployment(this) which does the check whether this is still the currentExecution.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3Njg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449578166", "bodyText": "This call effectively is getVertex().getExecutionGraph().getExecutionDeploymentListener() which is violating the law of Demeter. It effectively couples the implementation of where the ExecutionDeploymentListener lives.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:15:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/Execution.java", "diffHunk": "@@ -753,8 +753,11 @@ public void deploy() throws JobException {\n \t\t\t\t.thenCompose(Function.identity())\n \t\t\t\t.whenCompleteAsync(\n \t\t\t\t\t(ack, failure) -> {\n-\t\t\t\t\t\t// only respond to the failure case\n-\t\t\t\t\t\tif (failure != null) {\n+\t\t\t\t\t\tif (failure == null) {\n+\t\t\t\t\t\t\tgetExecutionGraph()\n+\t\t\t\t\t\t\t\t.getExecutionDeploymentListener()", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzNDU0OA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449634548", "bodyText": "Well yes, but that's rather common in the ExecutionGraph?\nThe alternative I suppose would be to pass the listener through the constructor, ideally behind some kind of service interface which could evolve into a set covering all the other stuff we access the vertex/graph for.", "author": "zentol", "createdAt": "2020-07-03T15:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYzODE2Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449638162", "bodyText": "Do you still want me to change anything with the listener call being moved into the ExecutionVertex?", "author": "zentol", "createdAt": "2020-07-03T15:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0MTQ0MA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449641440", "bodyText": "Well, maybe we can introduce a ExecutionVertex.onDeploymentCompleted which then forwards the call to the ExecutionGraph.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3ODE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTA3Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449579073", "bodyText": "Maybe\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n          \n          \n            \n            \t\tExecutionDeploymentReconciler create(ExecutionDeploymentReconciliationHandler reconciliationHandler);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:17:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.Set;\n+\n+/**\n+ * Component for reconciling the deployment state of executions.\n+ */\n+public interface ExecutionDeploymentReconciler {\n+\n+\t/**\n+\t * Factory for {@link ExecutionDeploymentReconciler}.\n+\t */\n+\tinterface Factory {\n+\t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTI2MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449579261", "bodyText": "Description is missing", "author": "tillrohrmann", "createdAt": "2020-07-03T13:18:00Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciler.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.Set;\n+\n+/**\n+ * Component for reconciling the deployment state of executions.\n+ */\n+public interface ExecutionDeploymentReconciler {\n+\n+\t/**\n+\t * Factory for {@link ExecutionDeploymentReconciler}.\n+\t */\n+\tinterface Factory {\n+\t\tExecutionDeploymentReconciler get(ExecutionDeploymentReconciliationHandler reconciliationHandler);\n+\t}\n+\n+\t/**\n+\t * Reconciles the deployment states between all reported/expected executions for the given task executor.\n+\t *\n+\t * @param taskExecutorHost", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTczMw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449579733", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n          \n          \n            \n            public class DefaultExecutionDeploymentReconciler implements ExecutionDeploymentReconciler {\n          \n      \n    \n    \n  \n\nIt is not a lot more specific than XYZImpl but a bit since it says that this is the default implementation.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:19:09Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNDEzNA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449614134", "bodyText": "I prefer *Impl purely because in an alphabetical file listing it is closer to the interface.", "author": "zentol", "createdAt": "2020-07-03T14:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTczMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMzAyMg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449623022", "bodyText": "Hmm, I think it would be slightly better to give implementations a meaningful/expressive name. In the future we might add special implementations which do things a bit differently and if we have a ExecutionDeploymentReconcilerImpl and a FatallyFailingExecutionDeploymentReconciler, then it might not be super obvious what the former does. But admittedly, DefaultXYZ is also not the best of all names. Ideally one has a name which describes the implementation.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU3OTczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4MDE1Nw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449580157", "bodyText": "I prefer the KISS principle and would simply use the for-each loop here.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:20:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+\n+\tprivate final ExecutionDeploymentReconciliationHandler handler;\n+\n+\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\t\tthis.handler = handler;\n+\t}\n+\n+\t@Override\n+\tpublic void reconcileExecutionDeployments(ResourceID taskExecutorHost, ExecutionDeploymentReport executionDeploymentReport, Set<ExecutionAttemptID> expectedDeployedExecutions) {\n+\t\tfinal Set<ExecutionAttemptID> executions = new HashSet<>(expectedDeployedExecutions);\n+\n+\t\texecutionDeploymentReport.getExecutions().forEach(executionAttemptID -> {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4MTE5MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449581191", "bodyText": "The JavaDocs are not complete. For interfaces I think we should provide complete JavaDocs.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:22:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+/**\n+ * Interface for triggering actions in case of state mismatches.\n+ */\n+public interface ExecutionDeploymentReconciliationHandler {\n+\t/**\n+\t * Called if an execution is expected to be hosted on a task executor, but isn't.\n+\t */", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTI0NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585244", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid onMissingDeployment(ExecutionAttemptID deployment);\n          \n          \n            \n            \tvoid onMissingDeployment(ExecutionAttemptID executionAttemptId);\n          \n      \n    \n    \n  \n\nnot sure whether the parameter should really be named deployment.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:31:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconciliationHandler.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+/**\n+ * Interface for triggering actions in case of state mismatches.\n+ */\n+public interface ExecutionDeploymentReconciliationHandler {\n+\t/**\n+\t * Called if an execution is expected to be hosted on a task executor, but isn't.\n+\t */\n+\tvoid onMissingDeployment(ExecutionAttemptID deployment);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTU0MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n          \n          \n            \n            \tvoid startTrackingDeploymentOf(ExecutionAttemptID executionAttemptId, ResourceID host);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:31:54Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A tracker for deployed executions.\n+ */\n+public interface ExecutionDeploymentTracker {\n+\n+\t/**\n+\t * Starts tracking the given execution that was deployed on the given host.\n+\t *\n+\t * @param deployment deployment to start tracking\n+\t * @param host hosting task executor\n+\t */\n+\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTY0Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585642", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid stopTrackingDeployment(ExecutionAttemptID deployment);\n          \n          \n            \n            \tvoid stopTrackingDeploymentOf(ExecutionAttemptID executionAttemptId);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:32:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A tracker for deployed executions.\n+ */\n+public interface ExecutionDeploymentTracker {\n+\n+\t/**\n+\t * Starts tracking the given execution that was deployed on the given host.\n+\t *\n+\t * @param deployment deployment to start tracking\n+\t * @param host hosting task executor\n+\t */\n+\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n+\n+\t/**\n+\t * Stops tracking the given execution.\n+\t *\n+\t * @param deployment deployment to stop tracking\n+\t */\n+\tvoid stopTrackingDeployment(ExecutionAttemptID deployment);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTg4Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585883", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tSet<ExecutionAttemptID> getExecutions(ResourceID host);\n          \n          \n            \n            \tSet<ExecutionAttemptID> getExecutionsOn(ResourceID host);\n          \n      \n    \n    \n  \n\nor maybe getExecutionsOnHost", "author": "tillrohrmann", "createdAt": "2020-07-03T13:32:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTracker.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A tracker for deployed executions.\n+ */\n+public interface ExecutionDeploymentTracker {\n+\n+\t/**\n+\t * Starts tracking the given execution that was deployed on the given host.\n+\t *\n+\t * @param deployment deployment to start tracking\n+\t * @param host hosting task executor\n+\t */\n+\tvoid startTrackingDeployment(ExecutionAttemptID deployment, ResourceID host);\n+\n+\t/**\n+\t * Stops tracking the given execution.\n+\t *\n+\t * @param deployment deployment to stop tracking\n+\t */\n+\tvoid stopTrackingDeployment(ExecutionAttemptID deployment);\n+\n+\t/**\n+\t * Returns all tracked executions for the given host.\n+\t *\n+\t * @param host hosting task executor\n+\t * @return tracked executions\n+\t */\n+\tSet<ExecutionAttemptID> getExecutions(ResourceID host);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTk3Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449585973", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionDeploymentTrackerImpl implements ExecutionDeploymentTracker, ExecutionDeploymentListener {\n          \n          \n            \n            public class DefaultExecutionDeploymentTracker implements ExecutionDeploymentTracker, ExecutionDeploymentListener {", "author": "tillrohrmann", "createdAt": "2020-07-03T13:32:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.executiongraph.ExecutionDeploymentListener;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentTracker} implementation.\n+ */\n+public class ExecutionDeploymentTrackerImpl implements ExecutionDeploymentTracker, ExecutionDeploymentListener {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMTE5OQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449601199", "bodyText": "Why does this class implement ExecutionDeploymentListener? I think it is nowhere used.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMDgyNQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449620825", "bodyText": "Artifact of an earlier iteration where the tracker was passed into the ExecutionGraph as the listener.", "author": "zentol", "createdAt": "2020-07-03T14:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4NTk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU4ODA5Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449588093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\texecutionsByHost.compute(host, (resourceID, executionAttemptIds) -> {\n          \n          \n            \n            \t\t\tif (executionAttemptIds == null) {\n          \n          \n            \n            \t\t\t\texecutionAttemptIds = new HashSet<>();\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\texecutionAttemptIds.add(execution);\n          \n          \n            \n            \t\t\treturn executionAttemptIds;\n          \n          \n            \n            \t\t});\n          \n          \n            \n            \t\texecutionsByHost.computeIfAbsent(host, ignored -> new HashSet<>()).add(execution);", "author": "tillrohrmann", "createdAt": "2020-07-03T13:37:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImpl.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.executiongraph.ExecutionDeploymentListener;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentTracker} implementation.\n+ */\n+public class ExecutionDeploymentTrackerImpl implements ExecutionDeploymentTracker, ExecutionDeploymentListener {\n+\n+\tprivate final Map<ResourceID, Set<ExecutionAttemptID>> executionsByHost = new HashMap<>();\n+\tprivate final Map<ExecutionAttemptID, ResourceID> hostByExecution = new HashMap<>();\n+\n+\t@Override\n+\tpublic void startTrackingDeployment(ExecutionAttemptID execution, ResourceID host) {\n+\t\thostByExecution.put(execution, host);\n+\t\texecutionsByHost.compute(host, (resourceID, executionAttemptIds) -> {\n+\t\t\tif (executionAttemptIds == null) {\n+\t\t\t\texecutionAttemptIds = new HashSet<>();\n+\t\t\t}\n+\t\t\texecutionAttemptIds.add(execution);\n+\t\t\treturn executionAttemptIds;\n+\t\t});", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MDU1NQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449590555", "bodyText": "Maybe add a bit more specific exception message.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:43:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/JobMaster.java", "diffHunk": "@@ -224,10 +227,34 @@ public JobMaster(\n \t\t\tClassLoader userCodeLoader,\n \t\t\tSchedulerNGFactory schedulerNGFactory,\n \t\t\tShuffleMaster<?> shuffleMaster,\n-\t\t\tPartitionTrackerFactory partitionTrackerFactory) throws Exception {\n+\t\t\tPartitionTrackerFactory partitionTrackerFactory,\n+\t\t\tExecutionDeploymentTracker executionDeploymentTracker,\n+\t\t\tExecutionDeploymentReconciler.Factory executionDeploymentReconcilerFactory) throws Exception {\n \n \t\tsuper(rpcService, AkkaRpcServiceUtils.createRandomName(JOB_MANAGER_NAME), null);\n \n+\t\tfinal ExecutionDeploymentReconciliationHandler executionStateReconciliationHandler = new ExecutionDeploymentReconciliationHandler() {\n+\t\t\t@Override\n+\t\t\tpublic void onMissingDeployment(ExecutionAttemptID deployment) {\n+\t\t\t\tlog.debug(\"Failing deployment {} due to no longer being deployed.\", deployment);\n+\t\t\t\tschedulerNG.updateTaskExecutionState(new TaskExecutionState(\n+\t\t\t\t\tjobGraph.getJobID(), deployment, ExecutionState.FAILED, new FlinkException(\"State de-sync\")", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTQ0OQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449591449", "bodyText": "Does it make sense to batch the executions which are unknown? That way we would not have to make a lookup for every unknown Execution.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:45:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+\n+\tprivate final ExecutionDeploymentReconciliationHandler handler;\n+\n+\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\t\tthis.handler = handler;\n+\t}\n+\n+\t@Override\n+\tpublic void reconcileExecutionDeployments(ResourceID taskExecutorHost, ExecutionDeploymentReport executionDeploymentReport, Set<ExecutionAttemptID> expectedDeployedExecutions) {\n+\t\tfinal Set<ExecutionAttemptID> executions = new HashSet<>(expectedDeployedExecutions);\n+\n+\t\texecutionDeploymentReport.getExecutions().forEach(executionAttemptID -> {\n+\t\t\tboolean isTracked = executions.remove(executionAttemptID);\n+\t\t\tif (!isTracked) {\n+\t\t\t\thandler.onUnknownDeployment(executionAttemptID, taskExecutorHost);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDkzMw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449624933", "bodyText": "hmm, yes, but then we maybe should also batch the cancel calls?", "author": "zentol", "createdAt": "2020-07-03T15:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0MTg2Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449641862", "bodyText": "This is an orthogonal discussion. The question here is whether the interface should enforce a single deployment lookup/cancellation call or be flexible enough to support batched calls.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5MTY1Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449591656", "bodyText": "Same here. If handler.onMissingDeployments takes a collection of Execution we only would have to call it once.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:45:56Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImpl.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+/**\n+ * Default {@link ExecutionDeploymentReconciler} implementation. Detects missing/unknown deployments, and defers\n+ * to a provided {@link ExecutionDeploymentReconciliationHandler} to resolve them.\n+ */\n+public class ExecutionDeploymentReconcilerImpl implements ExecutionDeploymentReconciler {\n+\n+\tprivate final ExecutionDeploymentReconciliationHandler handler;\n+\n+\tpublic ExecutionDeploymentReconcilerImpl(ExecutionDeploymentReconciliationHandler handler) {\n+\t\tthis.handler = handler;\n+\t}\n+\n+\t@Override\n+\tpublic void reconcileExecutionDeployments(ResourceID taskExecutorHost, ExecutionDeploymentReport executionDeploymentReport, Set<ExecutionAttemptID> expectedDeployedExecutions) {\n+\t\tfinal Set<ExecutionAttemptID> executions = new HashSet<>(expectedDeployedExecutions);\n+\n+\t\texecutionDeploymentReport.getExecutions().forEach(executionAttemptID -> {\n+\t\t\tboolean isTracked = executions.remove(executionAttemptID);\n+\t\t\tif (!isTracked) {\n+\t\t\t\thandler.onUnknownDeployment(executionAttemptID, taskExecutorHost);\n+\t\t\t}\n+\t\t});\n+\t\texecutions.forEach(handler::onMissingDeployment);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDE4Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449594186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class TaskExecutorToJobManagerHeartbeatPayload {\n          \n          \n            \n            public class TaskExecutorToJobManagerHeartbeatPayload implements Serializable {\n          \n          \n            \n            \n          \n          \n            \n            private static final long serialVersionUID = ....", "author": "tillrohrmann", "createdAt": "2020-07-03T13:51:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/TaskExecutorToJobManagerHeartbeatPayload.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import java.util.Collections;\n+\n+/**\n+ * Payload for heartbeats sent from the TaskExecutor to the JobManager.\n+ */\n+public class TaskExecutorToJobManagerHeartbeatPayload {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDMxOQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449594319", "bodyText": "the AkkaRpcService requires that all messages are serializable.", "author": "tillrohrmann", "createdAt": "2020-07-03T13:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5NDU1Ng==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449594556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionDeploymentReport {\n          \n          \n            \n            public class ExecutionDeploymentReport implements Serializable {", "author": "tillrohrmann", "createdAt": "2020-07-03T13:52:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/taskexecutor/ExecutionDeploymentReport.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+\n+import java.util.Set;\n+\n+/**\n+ * A report about the currently deployed executions of a TaskExecutor.\n+ */\n+public class ExecutionDeploymentReport {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTU5OTc2MQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449599761", "bodyText": "It's mainly a personal preference but I think tests are easier to understand if one know what's going on. With runTest a lot of details are being hidden. For example, the below suggestion makes it a bit easier to understand what missingFuture and unknownFuture actually are.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t@Test\n          \n          \n            \n            \tpublic void testMatchingDeployments() throws Exception {\n          \n          \n            \n            \t\trunTest((reconciler, missingFuture, unknownFuture) -> {\n          \n          \n            \n            \t\t\tResourceID resourceId = ResourceID.generate();\n          \n          \n            \n            \t\t\tExecutionAttemptID attemptId = new ExecutionAttemptID();\n          \n          \n            \n            \n          \n          \n            \n            \t\t\treconciler.reconcileExecutionDeployments(\n          \n          \n            \n            \t\t\t\tresourceId,\n          \n          \n            \n            \t\t\t\tnew ExecutionDeploymentReport(Collections.singleton(attemptId)),\n          \n          \n            \n            \t\t\t\tCollections.singleton(attemptId));\n          \n          \n            \n            \n          \n          \n            \n            \t\t\tassertFalse(missingFuture.isDone());\n          \n          \n            \n            \t\t\tassertFalse(unknownFuture.isDone());\n          \n          \n            \n            \t\t});\n          \n          \n            \n            \t}\n          \n          \n            \n                   @Test\n          \n          \n            \n            \tpublic void test() {\n          \n          \n            \n            \t\tfinal TestingExecutionDeploymentReconciliationHandler handler = new TestingExecutionDeploymentReconciliationHandler();\n          \n          \n            \n            \t\tfinal ExecutionDeploymentReconciler reconciler = new ExecutionDeploymentReconcilerImpl(handler);\n          \n          \n            \n            \t\tResourceID resourceId = ResourceID.generate();\n          \n          \n            \n            \t\tExecutionAttemptID attemptId = new ExecutionAttemptID();\n          \n          \n            \n            \n          \n          \n            \n            \t\treconciler.reconcileExecutionDeployments(\n          \n          \n            \n            \t\t\tresourceId,\n          \n          \n            \n            \t\t\tnew ExecutionDeploymentReport(Collections.singleton(attemptId)),\n          \n          \n            \n            \t\t\tCollections.singleton(attemptId));\n          \n          \n            \n            \n          \n          \n            \n            \t\tassertThat(handler.getMissingDeployments(), is(empty()));\n          \n          \n            \n            \t\tassertFalse(handler.getUnknownDeployments(), is(empty()));\n          \n          \n            \n            \t}", "author": "tillrohrmann", "createdAt": "2020-07-03T14:03:50Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentReconcilerImplTest.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link ExecutionDeploymentReconcilerImpl}.\n+ */\n+public class ExecutionDeploymentReconcilerImplTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testMatchingDeployments() throws Exception {\n+\t\trunTest((reconciler, missingFuture, unknownFuture) -> {\n+\t\t\tResourceID resourceId = ResourceID.generate();\n+\t\t\tExecutionAttemptID attemptId = new ExecutionAttemptID();\n+\n+\t\t\treconciler.reconcileExecutionDeployments(\n+\t\t\t\tresourceId,\n+\t\t\t\tnew ExecutionDeploymentReport(Collections.singleton(attemptId)),\n+\t\t\t\tCollections.singleton(attemptId));\n+\n+\t\t\tassertFalse(missingFuture.isDone());\n+\t\t\tassertFalse(unknownFuture.isDone());\n+\t\t});\n+\t}", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMTU4NQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449601585", "bodyText": "Should we also assert that the returned Collection is empty?", "author": "tillrohrmann", "createdAt": "2020-07-03T14:07:52Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/ExecutionDeploymentTrackerImplTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.core.IsCollectionContaining.hasItems;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link ExecutionDeploymentTrackerImpl}.\n+ */\n+public class ExecutionDeploymentTrackerImplTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testStartTracking() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t}\n+\n+\t@Test\n+\tpublic void testOnCompleteEquivalentToStartTracking() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.onCompletedDeployment(attemptId1, resourceId1);\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t}\n+\n+\t@Test\n+\tpublic void testStopTracking() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\n+\t\ttracker.stopTrackingDeployment(attemptId1);\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testStopTrackingDoesNotAffectOtherIds() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId1 = new ExecutionAttemptID();\n+\t\tfinal ResourceID resourceId1 = ResourceID.generate();\n+\t\ttracker.startTrackingDeployment(attemptId1, resourceId1);\n+\n+\t\ttracker.stopTrackingDeployment(new ExecutionAttemptID());\n+\n+\t\tassertThat(tracker.getExecutions(resourceId1), hasItems(attemptId1));\n+\t}\n+\n+\t@Test\n+\tpublic void testStopTrackingUnknownExecutionDoesNotThrowException() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tfinal ExecutionAttemptID attemptId2 = new ExecutionAttemptID();\n+\t\ttracker.stopTrackingDeployment(attemptId2);\n+\t}\n+\n+\t@Test\n+\tpublic void testGetExecutionsReturnsEmptySetForUnknownHost() {\n+\t\tfinal ExecutionDeploymentTrackerImpl tracker = new ExecutionDeploymentTrackerImpl();\n+\n+\t\tassertThat(tracker.getExecutions(ResourceID.generate()), notNullValue());", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMjIwNQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449602205", "bodyText": "You could also use TestingRpcServiceResource here.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:09:16Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.jobgraph.utils.JobGraphTestUtils;\n+import org.apache.flink.runtime.jobmanager.OnCompletionActions;\n+import org.apache.flink.runtime.jobmaster.utils.JobMasterBuilder;\n+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.AccumulatorReport;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorToJobManagerHeartbeatPayload;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalUnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link JobMaster}.\n+ */\n+public class JobMasterExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time testingTimeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpcService;", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwMzc4Mg==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449603782", "bodyText": "One could make AllocationIdsResourceManagerGateway a top level class.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:12:35Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.jobgraph.utils.JobGraphTestUtils;\n+import org.apache.flink.runtime.jobmanager.OnCompletionActions;\n+import org.apache.flink.runtime.jobmaster.utils.JobMasterBuilder;\n+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.AccumulatorReport;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorToJobManagerHeartbeatPayload;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalUnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link JobMaster}.\n+ */\n+public class JobMasterExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time testingTimeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpcService;\n+\n+\tprivate final HeartbeatServices heartbeatServices = new HeartbeatServices(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final TestingLeaderElectionService resourceManagerLeaderElectionService = new TestingLeaderElectionService();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setResourceManagerLeaderElectionService(resourceManagerLeaderElectionService);\n+\t\thaServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpcService.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpcService = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpcService.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testExecutionDeploymentReconciliation() throws Exception {\n+\t\tJobMasterBuilder.TestingOnCompletionActions onCompletionActions = new JobMasterBuilder.TestingOnCompletionActions();\n+\t\tJobMaster jobMaster = createAndStartJobMaster(onCompletionActions);\n+\t\tJobMasterGateway jobMasterGateway = jobMaster.getSelfGateway(JobMasterGateway.class);\n+\t\trpcService.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);\n+\n+\t\tfinal JobMasterPartitionReleaseTest.AllocationIdsResourceManagerGateway resourceManagerGateway = createResourceManagerGateway();", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNzAzMA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449607030", "bodyText": "I think this test is unstable because the completion of this future does not guarantee that we are tracking the respective task. If you add a Thread.sleep() in line 161, then you can reproduce it. The reason is that we use a whenCompleteAsync when deploying an Execution.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:20:07Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster;\n+\n+import org.apache.flink.api.common.JobStatus;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.checkpoint.StandaloneCheckpointRecoveryFactory;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.jobgraph.utils.JobGraphTestUtils;\n+import org.apache.flink.runtime.jobmanager.OnCompletionActions;\n+import org.apache.flink.runtime.jobmaster.utils.JobMasterBuilder;\n+import org.apache.flink.runtime.leaderelection.TestingLeaderElectionService;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.AccumulatorReport;\n+import org.apache.flink.runtime.taskexecutor.ExecutionDeploymentReport;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorToJobManagerHeartbeatPayload;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalUnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.UnresolvedTaskManagerLocation;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link JobMaster}.\n+ */\n+public class JobMasterExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time testingTimeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpcService;\n+\n+\tprivate final HeartbeatServices heartbeatServices = new HeartbeatServices(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final TestingLeaderElectionService resourceManagerLeaderElectionService = new TestingLeaderElectionService();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setResourceManagerLeaderElectionService(resourceManagerLeaderElectionService);\n+\t\thaServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpcService.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpcService = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpcService.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testExecutionDeploymentReconciliation() throws Exception {\n+\t\tJobMasterBuilder.TestingOnCompletionActions onCompletionActions = new JobMasterBuilder.TestingOnCompletionActions();\n+\t\tJobMaster jobMaster = createAndStartJobMaster(onCompletionActions);\n+\t\tJobMasterGateway jobMasterGateway = jobMaster.getSelfGateway(JobMasterGateway.class);\n+\t\trpcService.registerGateway(jobMasterGateway.getAddress(), jobMasterGateway);\n+\n+\t\tfinal JobMasterPartitionReleaseTest.AllocationIdsResourceManagerGateway resourceManagerGateway = createResourceManagerGateway();\n+\n+\t\tfinal CompletableFuture<Void> taskSubmissionFuture = new CompletableFuture<>();\n+\t\tfinal CompletableFuture<ExecutionAttemptID> taskCancellationFuture = new CompletableFuture<>();\n+\t\tTaskExecutorGateway taskExecutorGateway = createTaskExecutorGateway(taskSubmissionFuture, taskCancellationFuture);\n+\t\tLocalUnresolvedTaskManagerLocation localUnresolvedTaskManagerLocation = new LocalUnresolvedTaskManagerLocation();\n+\n+\t\tregisterTaskExecutorAndOfferSlots(resourceManagerGateway, jobMasterGateway, taskExecutorGateway, localUnresolvedTaskManagerLocation);\n+\n+\t\ttaskSubmissionFuture.get();", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNzUzNw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449607537", "bodyText": "Maybe make this a top level class.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:21:22Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterPartitionReleaseTest.java", "diffHunk": "@@ -162,10 +162,10 @@ private void testPartitionReleaseOrPromotionOnJobTermination(Function<TestSetup,\n \t\t}\n \t}\n \n-\tprivate static final class AllocationIdsResourceManagerGateway extends TestingResourceManagerGateway {\n+\tpublic static final class AllocationIdsResourceManagerGateway extends TestingResourceManagerGateway {", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwNzkxOQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449607919", "bodyText": "Maybe use TestingRpcServiceResource.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:22:17Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYwOTM1OQ==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449609359", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);\n          \n          \n            \n            \t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsQueue = new ArrayBlockingQueue<>(3);", "author": "tillrohrmann", "createdAt": "2020-07-03T14:25:36Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpc.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpc = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpc.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxMDczNA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449610734", "bodyText": "Can we use TaskDeploymentDescriptorBuilder here?", "author": "tillrohrmann", "createdAt": "2020-07-03T14:28:44Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpc.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpc = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpc.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);\n+\t\tfinal CompletableFuture<Void> taskFinishedFuture = new CompletableFuture<>();\n+\t\tfinal ResourceID jobManagerResourceId = ResourceID.generate();\n+\t\tfinal TestingJobMasterGateway jobMasterGateway = setupJobManagerGateway(slotOfferLatch, deployedExecutionsFuture, taskFinishedFuture, jobManagerResourceId);\n+\n+\t\tfinal CompletableFuture<SlotReport> initialSlotReportFuture = new CompletableFuture<>();\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = setupResourceManagerGateway(initialSlotReportFuture);\n+\n+\t\tfinal TaskManagerServices taskManagerServices = new TaskManagerServicesBuilder()\n+\t\t\t.setTaskSlotTable(TaskSlotUtils.createTaskSlotTable(1, timeout))\n+\t\t\t.setShuffleEnvironment(new NettyShuffleEnvironmentBuilder().build())\n+\t\t\t.build();\n+\n+\t\tfinal TestingTaskExecutor taskExecutor = createTestingTaskExecutor(taskManagerServices);\n+\n+\t\ttry {\n+\t\t\ttaskExecutor.start();\n+\t\t\ttaskExecutor.waitUntilStarted();\n+\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = taskExecutor.getSelfGateway(TaskExecutorGateway.class);\n+\n+\t\t\tfinal TaskDeploymentDescriptor taskDeploymentDescriptor = createTaskDeploymentDescriptor(jobId);\n+\n+\t\t\tconnectComponentsAndRequestSlot(jobMasterGateway, testingResourceManagerGateway, taskExecutorGateway, taskManagerServices.getJobLeaderService(), initialSlotReportFuture, taskDeploymentDescriptor.getAllocationId());\n+\n+\t\t\tTestingInvokable.sync = new BlockerSync();\n+\n+\t\t\t// This ensures TM has been successfully registered to JM.\n+\t\t\tslotOfferLatch.await();\n+\n+\t\t\tAllocatedSlotReport slotAllocationReport = new AllocatedSlotReport(jobId, Collections.singleton(new AllocatedSlotInfo(0, taskDeploymentDescriptor.getAllocationId())));\n+\n+\t\t\t// nothing as deployed, so the deployment report should be empty\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\n+\t\t\ttaskExecutorGateway.submitTask(taskDeploymentDescriptor, jobMasterGateway.getFencingToken(), timeout)\n+\t\t\t\t.get();\n+\n+\t\t\tTestingInvokable.sync.awaitBlocker();\n+\n+\t\t\t// task is deployed, so the deployment report should contain it\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasItem(taskDeploymentDescriptor.getExecutionAttemptId()));\n+\n+\t\t\tTestingInvokable.sync.releaseBlocker();\n+\n+\t\t\t// task is finished ans was cleaned up, so the deployment report should be empty\n+\t\t\ttaskFinishedFuture.get();\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\t\t} finally {\n+\t\t\tRpcUtils.terminateRpcEndpoint(taskExecutor, timeout);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Test invokable which completes the given future when executed.\n+\t */\n+\tpublic static class TestingInvokable extends AbstractInvokable {\n+\n+\t\tstatic BlockerSync sync;\n+\n+\t\tpublic TestingInvokable(Environment environment) {\n+\t\t\tsuper(environment);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void invoke() throws Exception {\n+\t\t\tsync.block();\n+\t\t}\n+\t}\n+\n+\tprivate TestingTaskExecutor createTestingTaskExecutor(TaskManagerServices taskManagerServices) throws IOException {\n+\t\tfinal Configuration configuration = new Configuration();\n+\t\treturn new TestingTaskExecutor(\n+\t\t\trpc,\n+\t\t\tTaskManagerConfiguration.fromConfiguration(\n+\t\t\t\tconfiguration,\n+\t\t\t\tTaskExecutorResourceUtils.resourceSpecFromConfigForLocalExecution(configuration),\n+\t\t\t\tInetAddress.getLoopbackAddress().getHostAddress()),\n+\t\t\thaServices,\n+\t\t\ttaskManagerServices,\n+\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n+\t\t\tnew HeartbeatServices(1_000L, 30_000L),\n+\t\t\tUnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),\n+\t\t\tnull,\n+\t\t\tnew BlobCacheService(\n+\t\t\t\tconfiguration,\n+\t\t\t\tnew VoidBlobStore(),\n+\t\t\t\tnull),\n+\t\t\ttestingFatalErrorHandlerResource.getFatalErrorHandler(),\n+\t\t\tnew TestingTaskExecutorPartitionTracker(),\n+\t\t\tTaskManagerRunner.createBackPressureSampleService(configuration, rpc.getScheduledExecutor()));\n+\t}\n+\n+\tprivate static TaskDeploymentDescriptor createTaskDeploymentDescriptor(JobID jobId) throws IOException {\n+\t\tfinal ResultPartitionDeploymentDescriptor taskResultPartitionDescriptor =\n+\t\t\tPartitionTestUtils.createPartitionDeploymentDescriptor(ResultPartitionType.BLOCKING);\n+\n+\t\treturn TaskExecutorSubmissionTest.createTaskDeploymentDescriptor(\n+\t\t\tjobId,\n+\t\t\t\"job\",\n+\t\t\ttaskResultPartitionDescriptor.getShuffleDescriptor().getResultPartitionID().getProducerId(),\n+\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n+\t\t\t\"Sender\",\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\tnew Configuration(),\n+\t\t\tnew Configuration(),\n+\t\t\tTestingInvokable.class.getName(),\n+\t\t\tCollections.singletonList(taskResultPartitionDescriptor),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\t0);", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxMTgwMw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449611803", "bodyText": "If you want to wait that the TaskExecutor has established the connection to the ResourceManager, then one can wait for the ResourceManagerGateway.sendSlotReport call.", "author": "tillrohrmann", "createdAt": "2020-07-03T14:31:19Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.ExecutionConfig;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.ResultPartitionDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.PartitionTestUtils;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionType;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcService;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.SerializedValue;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate static TestingRpcService rpc;\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\trpc.clearGateways();\n+\t}\n+\n+\t@BeforeClass\n+\tpublic static void setupClass() {\n+\t\trpc = new TestingRpcService();\n+\t}\n+\n+\t@AfterClass\n+\tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n+\t\trpc.stopService().get();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture = new ArrayBlockingQueue<>(3);\n+\t\tfinal CompletableFuture<Void> taskFinishedFuture = new CompletableFuture<>();\n+\t\tfinal ResourceID jobManagerResourceId = ResourceID.generate();\n+\t\tfinal TestingJobMasterGateway jobMasterGateway = setupJobManagerGateway(slotOfferLatch, deployedExecutionsFuture, taskFinishedFuture, jobManagerResourceId);\n+\n+\t\tfinal CompletableFuture<SlotReport> initialSlotReportFuture = new CompletableFuture<>();\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = setupResourceManagerGateway(initialSlotReportFuture);\n+\n+\t\tfinal TaskManagerServices taskManagerServices = new TaskManagerServicesBuilder()\n+\t\t\t.setTaskSlotTable(TaskSlotUtils.createTaskSlotTable(1, timeout))\n+\t\t\t.setShuffleEnvironment(new NettyShuffleEnvironmentBuilder().build())\n+\t\t\t.build();\n+\n+\t\tfinal TestingTaskExecutor taskExecutor = createTestingTaskExecutor(taskManagerServices);\n+\n+\t\ttry {\n+\t\t\ttaskExecutor.start();\n+\t\t\ttaskExecutor.waitUntilStarted();\n+\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = taskExecutor.getSelfGateway(TaskExecutorGateway.class);\n+\n+\t\t\tfinal TaskDeploymentDescriptor taskDeploymentDescriptor = createTaskDeploymentDescriptor(jobId);\n+\n+\t\t\tconnectComponentsAndRequestSlot(jobMasterGateway, testingResourceManagerGateway, taskExecutorGateway, taskManagerServices.getJobLeaderService(), initialSlotReportFuture, taskDeploymentDescriptor.getAllocationId());\n+\n+\t\t\tTestingInvokable.sync = new BlockerSync();\n+\n+\t\t\t// This ensures TM has been successfully registered to JM.\n+\t\t\tslotOfferLatch.await();\n+\n+\t\t\tAllocatedSlotReport slotAllocationReport = new AllocatedSlotReport(jobId, Collections.singleton(new AllocatedSlotInfo(0, taskDeploymentDescriptor.getAllocationId())));\n+\n+\t\t\t// nothing as deployed, so the deployment report should be empty\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\n+\t\t\ttaskExecutorGateway.submitTask(taskDeploymentDescriptor, jobMasterGateway.getFencingToken(), timeout)\n+\t\t\t\t.get();\n+\n+\t\t\tTestingInvokable.sync.awaitBlocker();\n+\n+\t\t\t// task is deployed, so the deployment report should contain it\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasItem(taskDeploymentDescriptor.getExecutionAttemptId()));\n+\n+\t\t\tTestingInvokable.sync.releaseBlocker();\n+\n+\t\t\t// task is finished ans was cleaned up, so the deployment report should be empty\n+\t\t\ttaskFinishedFuture.get();\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsFuture.take(), hasSize(0));\n+\t\t} finally {\n+\t\t\tRpcUtils.terminateRpcEndpoint(taskExecutor, timeout);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Test invokable which completes the given future when executed.\n+\t */\n+\tpublic static class TestingInvokable extends AbstractInvokable {\n+\n+\t\tstatic BlockerSync sync;\n+\n+\t\tpublic TestingInvokable(Environment environment) {\n+\t\t\tsuper(environment);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void invoke() throws Exception {\n+\t\t\tsync.block();\n+\t\t}\n+\t}\n+\n+\tprivate TestingTaskExecutor createTestingTaskExecutor(TaskManagerServices taskManagerServices) throws IOException {\n+\t\tfinal Configuration configuration = new Configuration();\n+\t\treturn new TestingTaskExecutor(\n+\t\t\trpc,\n+\t\t\tTaskManagerConfiguration.fromConfiguration(\n+\t\t\t\tconfiguration,\n+\t\t\t\tTaskExecutorResourceUtils.resourceSpecFromConfigForLocalExecution(configuration),\n+\t\t\t\tInetAddress.getLoopbackAddress().getHostAddress()),\n+\t\t\thaServices,\n+\t\t\ttaskManagerServices,\n+\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n+\t\t\tnew HeartbeatServices(1_000L, 30_000L),\n+\t\t\tUnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),\n+\t\t\tnull,\n+\t\t\tnew BlobCacheService(\n+\t\t\t\tconfiguration,\n+\t\t\t\tnew VoidBlobStore(),\n+\t\t\t\tnull),\n+\t\t\ttestingFatalErrorHandlerResource.getFatalErrorHandler(),\n+\t\t\tnew TestingTaskExecutorPartitionTracker(),\n+\t\t\tTaskManagerRunner.createBackPressureSampleService(configuration, rpc.getScheduledExecutor()));\n+\t}\n+\n+\tprivate static TaskDeploymentDescriptor createTaskDeploymentDescriptor(JobID jobId) throws IOException {\n+\t\tfinal ResultPartitionDeploymentDescriptor taskResultPartitionDescriptor =\n+\t\t\tPartitionTestUtils.createPartitionDeploymentDescriptor(ResultPartitionType.BLOCKING);\n+\n+\t\treturn TaskExecutorSubmissionTest.createTaskDeploymentDescriptor(\n+\t\t\tjobId,\n+\t\t\t\"job\",\n+\t\t\ttaskResultPartitionDescriptor.getShuffleDescriptor().getResultPartitionID().getProducerId(),\n+\t\t\tnew SerializedValue<>(new ExecutionConfig()),\n+\t\t\t\"Sender\",\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\t1,\n+\t\t\t0,\n+\t\t\tnew Configuration(),\n+\t\t\tnew Configuration(),\n+\t\t\tTestingInvokable.class.getName(),\n+\t\t\tCollections.singletonList(taskResultPartitionDescriptor),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\tCollections.emptyList(),\n+\t\t\t0);\n+\t}\n+\n+\tprivate static TestingJobMasterGateway setupJobManagerGateway(OneShotLatch slotOfferLatch, BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture, CompletableFuture<Void> taskFinishedFuture, ResourceID jobManagerResourceId) {\n+\t\treturn new TestingJobMasterGatewayBuilder()\n+\t\t\t.setRegisterTaskManagerFunction((s, location) -> CompletableFuture.completedFuture(new JMTMRegistrationSuccess(jobManagerResourceId)))\n+\t\t\t.setOfferSlotsFunction((resourceID, slotOffers) -> {\n+\t\t\t\tslotOfferLatch.trigger();\n+\t\t\t\treturn CompletableFuture.completedFuture(slotOffers);\n+\t\t\t})\n+\t\t\t.setTaskManagerHeartbeatConsumer((resourceID, taskExecutorToJobManagerHeartbeatPayload) -> {\n+\t\t\t\tExecutionDeploymentReport executionDeploymentReport = taskExecutorToJobManagerHeartbeatPayload.getExecutionDeploymentReport();\n+\t\t\t\tdeployedExecutionsFuture.add(executionDeploymentReport.getExecutions());\n+\t\t\t})\n+\t\t\t.setUpdateTaskExecutionStateFunction(taskExecutionState -> {\n+\t\t\t\tif (taskExecutionState.getExecutionState() == ExecutionState.FINISHED) {\n+\t\t\t\t\ttaskFinishedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.build();\n+\t}\n+\n+\tprivate static TestingResourceManagerGateway setupResourceManagerGateway(CompletableFuture<SlotReport> initialSlotReportFuture) {\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = new TestingResourceManagerGateway();\n+\t\ttestingResourceManagerGateway.setSendSlotReportFunction(resourceIDInstanceIDSlotReportTuple3 -> {\n+\t\t\tinitialSlotReportFuture.complete(resourceIDInstanceIDSlotReportTuple3.f2);\n+\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t});\n+\t\ttestingResourceManagerGateway.setRegisterTaskExecutorFunction(input -> CompletableFuture.completedFuture(\n+\t\t\tnew TaskExecutorRegistrationSuccess(\n+\t\t\t\tnew InstanceID(),\n+\t\t\t\ttestingResourceManagerGateway.getOwnResourceId(),\n+\t\t\t\tnew ClusterInformation(\"blobServerHost\", 55555))));\n+\t\treturn testingResourceManagerGateway;\n+\t}\n+\n+\tprivate void connectComponentsAndRequestSlot(\n+\t\t\tJobMasterGateway jobMasterGateway,\n+\t\t\tResourceManagerGateway resourceManagerGateway,\n+\t\t\tTaskExecutorGateway taskExecutorGateway,\n+\t\t\tJobLeaderService jobLeaderService,\n+\t\t\tCompletableFuture<SlotReport> initialSlotReportFuture,\n+\t\t\tAllocationID allocationId) throws Exception {\n+\t\tfinal String jobMasterAddress = \"jm\";\n+\t\trpc.registerGateway(jobMasterAddress, jobMasterGateway);\n+\t\trpc.registerGateway(resourceManagerGateway.getAddress(), resourceManagerGateway);\n+\n+\t\t// inform the task manager about the job leader\n+\t\tjobLeaderService.addJob(jobId, jobMasterAddress);\n+\t\tjobManagerLeaderRetriever.notifyListener(jobMasterAddress, UUID.randomUUID());\n+\t\tresourceManagerLeaderRetriever.notifyListener(resourceManagerGateway.getAddress(), resourceManagerGateway.getFencingToken().toUUID());\n+\n+\t\tfinal Optional<SlotStatus> slotStatusOptional = StreamSupport.stream(initialSlotReportFuture.get().spliterator(), false)\n+\t\t\t.findAny();\n+\n+\t\tassertTrue(slotStatusOptional.isPresent());\n+\n+\t\twhile (true) {\n+\t\t\ttry {\n+\t\t\t\ttaskExecutorGateway.requestSlot(\n+\t\t\t\t\tslotStatusOptional.get().getSlotID(),\n+\t\t\t\t\tjobId,\n+\t\t\t\t\tallocationId,\n+\t\t\t\t\tResourceProfile.ZERO,\n+\t\t\t\t\tjobMasterAddress,\n+\t\t\t\t\tresourceManagerGateway.getFencingToken(),\n+\t\t\t\t\ttimeout\n+\t\t\t\t).get();\n+\t\t\t\tbreak;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\t// the proper establishment of the RM connection is tracked\n+\t\t\t\t// asynchronously, so we have to poll here until it went through\n+\t\t\t\t// until then, slot requests will fail with an exception\n+\t\t\t\tThread.sleep(50);\n+\t\t\t}\n+\t\t}", "originalCommit": "c7057fb78bada7b389fd1e6e20965940d5e5d8a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "55e325143fefcfaf116109ee14e8c2ef2c551b91", "url": "https://github.com/apache/flink/commit/55e325143fefcfaf116109ee14e8c2ef2c551b91", "message": "Move state update listeners calls into EG", "committedDate": "2020-07-03T14:43:56Z", "type": "commit"}, {"oid": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "url": "https://github.com/apache/flink/commit/0260110c2b7464c4daeab3e4803f4a67540f25c1", "message": "address comments", "committedDate": "2020-07-03T15:38:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0Mjc4NA==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449642784", "bodyText": "I think the resource will take care of shutting the service down.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:52:40Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/JobMasterExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -86,38 +88,29 @@ public void setup() {\n \t\thaServices.setCheckpointRecoveryFactory(new StandaloneCheckpointRecoveryFactory());\n \t}\n \n-\t@After\n-\tpublic void shutdown() {\n-\t\trpcService.clearGateways();\n-\t}\n-\n-\t@BeforeClass\n-\tpublic static void setupClass() {\n-\t\trpcService = new TestingRpcService();\n-\t}\n-\n \t@AfterClass\n \tpublic static void shutdownClass() throws ExecutionException, InterruptedException {\n-\t\trpcService.stopService().get();\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().stopService().get();", "originalCommit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0NDg3Mw==", "url": "https://github.com/apache/flink/pull/12815#discussion_r449644873", "bodyText": "Why exactly do we need this while loop here? I think by waiting on initialSlotReportFuture it is not needed.", "author": "tillrohrmann", "createdAt": "2020-07-03T15:59:08Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/taskexecutor/TaskExecutorExecutionDeploymentReconciliationTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.taskexecutor;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.testutils.BlockerSync;\n+import org.apache.flink.core.testutils.OneShotLatch;\n+import org.apache.flink.runtime.blob.BlobCacheService;\n+import org.apache.flink.runtime.blob.VoidBlobStore;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptor;\n+import org.apache.flink.runtime.deployment.TaskDeploymentDescriptorBuilder;\n+import org.apache.flink.runtime.entrypoint.ClusterInformation;\n+import org.apache.flink.runtime.execution.Environment;\n+import org.apache.flink.runtime.execution.ExecutionState;\n+import org.apache.flink.runtime.executiongraph.ExecutionAttemptID;\n+import org.apache.flink.runtime.externalresource.ExternalResourceInfoProvider;\n+import org.apache.flink.runtime.heartbeat.HeartbeatServices;\n+import org.apache.flink.runtime.highavailability.TestingHighAvailabilityServices;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.io.network.NettyShuffleEnvironmentBuilder;\n+import org.apache.flink.runtime.io.network.partition.TestingTaskExecutorPartitionTracker;\n+import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JMTMRegistrationSuccess;\n+import org.apache.flink.runtime.jobmaster.JobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGateway;\n+import org.apache.flink.runtime.jobmaster.utils.TestingJobMasterGatewayBuilder;\n+import org.apache.flink.runtime.leaderretrieval.SettableLeaderRetrievalService;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.metrics.groups.UnregisteredMetricGroups;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.resourcemanager.utils.TestingResourceManagerGateway;\n+import org.apache.flink.runtime.rpc.RpcUtils;\n+import org.apache.flink.runtime.rpc.TestingRpcServiceResource;\n+import org.apache.flink.runtime.taskexecutor.slot.TaskSlotUtils;\n+import org.apache.flink.runtime.util.TestingFatalErrorHandlerResource;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.Collections;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.StreamSupport;\n+\n+import static org.hamcrest.collection.IsCollectionWithSize.hasSize;\n+import static org.hamcrest.core.IsCollectionContaining.hasItem;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the execution deployment-reconciliation logic in the {@link TaskExecutor}.\n+ */\n+public class TaskExecutorExecutionDeploymentReconciliationTest extends TestLogger {\n+\n+\tprivate static final Time timeout = Time.seconds(10L);\n+\n+\tprivate final TestingHighAvailabilityServices haServices = new TestingHighAvailabilityServices();\n+\tprivate final SettableLeaderRetrievalService jobManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final SettableLeaderRetrievalService resourceManagerLeaderRetriever = new SettableLeaderRetrievalService();\n+\tprivate final JobID jobId = new JobID();\n+\n+\t@ClassRule\n+\tpublic static final TestingRpcServiceResource RPC_SERVICE_RESOURCE = new TestingRpcServiceResource();\n+\n+\t@Rule\n+\tpublic final TestingFatalErrorHandlerResource testingFatalErrorHandlerResource = new TestingFatalErrorHandlerResource();\n+\n+\t@Before\n+\tpublic void setup() {\n+\t\thaServices.setResourceManagerLeaderRetriever(resourceManagerLeaderRetriever);\n+\t\thaServices.setJobMasterLeaderRetriever(jobId, jobManagerLeaderRetriever);\n+\t}\n+\n+\t@After\n+\tpublic void shutdown() {\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().clearGateways();\n+\t}\n+\n+\t@Test\n+\tpublic void testDeployedExecutionReporting() throws Exception {\n+\t\tfinal OneShotLatch slotOfferLatch = new OneShotLatch();\n+\t\tfinal BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsQueue = new ArrayBlockingQueue<>(3);\n+\t\tfinal CompletableFuture<Void> taskFinishedFuture = new CompletableFuture<>();\n+\t\tfinal ResourceID jobManagerResourceId = ResourceID.generate();\n+\t\tfinal TestingJobMasterGateway jobMasterGateway = setupJobManagerGateway(slotOfferLatch, deployedExecutionsQueue, taskFinishedFuture, jobManagerResourceId);\n+\n+\t\tfinal CompletableFuture<SlotReport> initialSlotReportFuture = new CompletableFuture<>();\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = setupResourceManagerGateway(initialSlotReportFuture);\n+\n+\t\tfinal TaskManagerServices taskManagerServices = new TaskManagerServicesBuilder()\n+\t\t\t.setTaskSlotTable(TaskSlotUtils.createTaskSlotTable(1, timeout))\n+\t\t\t.setShuffleEnvironment(new NettyShuffleEnvironmentBuilder().build())\n+\t\t\t.build();\n+\n+\t\tfinal TestingTaskExecutor taskExecutor = createTestingTaskExecutor(taskManagerServices);\n+\n+\t\ttry {\n+\t\t\ttaskExecutor.start();\n+\t\t\ttaskExecutor.waitUntilStarted();\n+\n+\t\t\tfinal TaskExecutorGateway taskExecutorGateway = taskExecutor.getSelfGateway(TaskExecutorGateway.class);\n+\n+\t\t\tfinal TaskDeploymentDescriptor taskDeploymentDescriptor = createTaskDeploymentDescriptor(jobId);\n+\n+\t\t\tconnectComponentsAndRequestSlot(jobMasterGateway, testingResourceManagerGateway, taskExecutorGateway, taskManagerServices.getJobLeaderService(), initialSlotReportFuture, taskDeploymentDescriptor.getAllocationId());\n+\n+\t\t\tTestingInvokable.sync = new BlockerSync();\n+\n+\t\t\t// This ensures TM has been successfully registered to JM.\n+\t\t\tslotOfferLatch.await();\n+\n+\t\t\tAllocatedSlotReport slotAllocationReport = new AllocatedSlotReport(jobId, Collections.singleton(new AllocatedSlotInfo(0, taskDeploymentDescriptor.getAllocationId())));\n+\n+\t\t\t// nothing as deployed, so the deployment report should be empty\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsQueue.take(), hasSize(0));\n+\n+\t\t\ttaskExecutorGateway.submitTask(taskDeploymentDescriptor, jobMasterGateway.getFencingToken(), timeout)\n+\t\t\t\t.get();\n+\n+\t\t\tTestingInvokable.sync.awaitBlocker();\n+\n+\t\t\t// task is deployed, so the deployment report should contain it\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsQueue.take(), hasItem(taskDeploymentDescriptor.getExecutionAttemptId()));\n+\n+\t\t\tTestingInvokable.sync.releaseBlocker();\n+\n+\t\t\t// task is finished ans was cleaned up, so the deployment report should be empty\n+\t\t\ttaskFinishedFuture.get();\n+\t\t\ttaskExecutorGateway.heartbeatFromJobManager(jobManagerResourceId, slotAllocationReport);\n+\t\t\tassertThat(deployedExecutionsQueue.take(), hasSize(0));\n+\t\t} finally {\n+\t\t\tRpcUtils.terminateRpcEndpoint(taskExecutor, timeout);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Test invokable which completes the given future when executed.\n+\t */\n+\tpublic static class TestingInvokable extends AbstractInvokable {\n+\n+\t\tstatic BlockerSync sync;\n+\n+\t\tpublic TestingInvokable(Environment environment) {\n+\t\t\tsuper(environment);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void invoke() throws Exception {\n+\t\t\tsync.block();\n+\t\t}\n+\t}\n+\n+\tprivate TestingTaskExecutor createTestingTaskExecutor(TaskManagerServices taskManagerServices) throws IOException {\n+\t\tfinal Configuration configuration = new Configuration();\n+\t\treturn new TestingTaskExecutor(\n+\t\t\tRPC_SERVICE_RESOURCE.getTestingRpcService(),\n+\t\t\tTaskManagerConfiguration.fromConfiguration(\n+\t\t\t\tconfiguration,\n+\t\t\t\tTaskExecutorResourceUtils.resourceSpecFromConfigForLocalExecution(configuration),\n+\t\t\t\tInetAddress.getLoopbackAddress().getHostAddress()),\n+\t\t\thaServices,\n+\t\t\ttaskManagerServices,\n+\t\t\tExternalResourceInfoProvider.NO_EXTERNAL_RESOURCES,\n+\t\t\tnew HeartbeatServices(1_000L, 30_000L),\n+\t\t\tUnregisteredMetricGroups.createUnregisteredTaskManagerMetricGroup(),\n+\t\t\tnull,\n+\t\t\tnew BlobCacheService(\n+\t\t\t\tconfiguration,\n+\t\t\t\tnew VoidBlobStore(),\n+\t\t\t\tnull),\n+\t\t\ttestingFatalErrorHandlerResource.getFatalErrorHandler(),\n+\t\t\tnew TestingTaskExecutorPartitionTracker(),\n+\t\t\tTaskManagerRunner.createBackPressureSampleService(configuration, RPC_SERVICE_RESOURCE.getTestingRpcService().getScheduledExecutor()));\n+\t}\n+\n+\tprivate static TaskDeploymentDescriptor createTaskDeploymentDescriptor(JobID jobId) throws IOException {\n+\t\treturn TaskDeploymentDescriptorBuilder.newBuilder(jobId, TestingInvokable.class).build();\n+\t}\n+\n+\tprivate static TestingJobMasterGateway setupJobManagerGateway(OneShotLatch slotOfferLatch, BlockingQueue<Set<ExecutionAttemptID>> deployedExecutionsFuture, CompletableFuture<Void> taskFinishedFuture, ResourceID jobManagerResourceId) {\n+\t\treturn new TestingJobMasterGatewayBuilder()\n+\t\t\t.setRegisterTaskManagerFunction((s, location) -> CompletableFuture.completedFuture(new JMTMRegistrationSuccess(jobManagerResourceId)))\n+\t\t\t.setOfferSlotsFunction((resourceID, slotOffers) -> {\n+\t\t\t\tslotOfferLatch.trigger();\n+\t\t\t\treturn CompletableFuture.completedFuture(slotOffers);\n+\t\t\t})\n+\t\t\t.setTaskManagerHeartbeatConsumer((resourceID, taskExecutorToJobManagerHeartbeatPayload) -> {\n+\t\t\t\tExecutionDeploymentReport executionDeploymentReport = taskExecutorToJobManagerHeartbeatPayload.getExecutionDeploymentReport();\n+\t\t\t\tdeployedExecutionsFuture.add(executionDeploymentReport.getExecutions());\n+\t\t\t})\n+\t\t\t.setUpdateTaskExecutionStateFunction(taskExecutionState -> {\n+\t\t\t\tif (taskExecutionState.getExecutionState() == ExecutionState.FINISHED) {\n+\t\t\t\t\ttaskFinishedFuture.complete(null);\n+\t\t\t\t}\n+\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t\t})\n+\t\t\t.build();\n+\t}\n+\n+\tprivate static TestingResourceManagerGateway setupResourceManagerGateway(CompletableFuture<SlotReport> initialSlotReportFuture) {\n+\t\tfinal TestingResourceManagerGateway testingResourceManagerGateway = new TestingResourceManagerGateway();\n+\t\ttestingResourceManagerGateway.setSendSlotReportFunction(resourceIDInstanceIDSlotReportTuple3 -> {\n+\t\t\tinitialSlotReportFuture.complete(resourceIDInstanceIDSlotReportTuple3.f2);\n+\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n+\t\t});\n+\t\ttestingResourceManagerGateway.setRegisterTaskExecutorFunction(input -> CompletableFuture.completedFuture(\n+\t\t\tnew TaskExecutorRegistrationSuccess(\n+\t\t\t\tnew InstanceID(),\n+\t\t\t\ttestingResourceManagerGateway.getOwnResourceId(),\n+\t\t\t\tnew ClusterInformation(\"blobServerHost\", 55555))));\n+\t\treturn testingResourceManagerGateway;\n+\t}\n+\n+\tprivate void connectComponentsAndRequestSlot(\n+\t\t\tJobMasterGateway jobMasterGateway,\n+\t\t\tResourceManagerGateway resourceManagerGateway,\n+\t\t\tTaskExecutorGateway taskExecutorGateway,\n+\t\t\tJobLeaderService jobLeaderService,\n+\t\t\tCompletableFuture<SlotReport> initialSlotReportFuture,\n+\t\t\tAllocationID allocationId) throws Exception {\n+\t\tfinal String jobMasterAddress = \"jm\";\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().registerGateway(jobMasterAddress, jobMasterGateway);\n+\t\tRPC_SERVICE_RESOURCE.getTestingRpcService().registerGateway(resourceManagerGateway.getAddress(), resourceManagerGateway);\n+\n+\t\t// inform the task manager about the job leader\n+\t\tjobLeaderService.addJob(jobId, jobMasterAddress);\n+\t\tjobManagerLeaderRetriever.notifyListener(jobMasterAddress, UUID.randomUUID());\n+\t\tresourceManagerLeaderRetriever.notifyListener(resourceManagerGateway.getAddress(), resourceManagerGateway.getFencingToken().toUUID());\n+\n+\t\tfinal Optional<SlotStatus> slotStatusOptional = StreamSupport.stream(initialSlotReportFuture.get().spliterator(), false)\n+\t\t\t.findAny();\n+\n+\t\tassertTrue(slotStatusOptional.isPresent());\n+\n+\t\twhile (true) {", "originalCommit": "0260110c2b7464c4daeab3e4803f4a67540f25c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f2209c8b21fb3120252b58e35debb9f715b3c237", "url": "https://github.com/apache/flink/commit/f2209c8b21fb3120252b58e35debb9f715b3c237", "message": "batch #2", "committedDate": "2020-07-07T09:19:53Z", "type": "commit"}]}