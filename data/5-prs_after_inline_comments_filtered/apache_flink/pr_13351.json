{"pr_number": 13351, "pr_title": "[FLINK-18990][task] Read channel state sequentially", "pr_createdAt": "2020-09-08T09:01:36Z", "pr_url": "https://github.com/apache/flink/pull/13351", "timeline": [{"oid": "fb92ec41b039a5d5509fd0376ad305ce81ee5ad2", "url": "https://github.com/apache/flink/commit/fb92ec41b039a5d5509fd0376ad305ce81ee5ad2", "message": "Unconditionally read channel state", "committedDate": "2020-09-22T14:32:08Z", "type": "forcePushed"}, {"oid": "8d443ef45b7d7db48c807c9cb4338ee92bdc3239", "url": "https://github.com/apache/flink/commit/8d443ef45b7d7db48c807c9cb4338ee92bdc3239", "message": "Request per gate", "committedDate": "2020-09-22T19:16:02Z", "type": "forcePushed"}, {"oid": "4ea479a303d7939af8f20b106c704a799c40cee1", "url": "https://github.com/apache/flink/commit/4ea479a303d7939af8f20b106c704a799c40cee1", "message": "Request partition per gate", "committedDate": "2020-09-22T19:42:26Z", "type": "forcePushed"}, {"oid": "a219f9406ef75b88de09418025b8c21552fbbe1c", "url": "https://github.com/apache/flink/commit/a219f9406ef75b88de09418025b8c21552fbbe1c", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-23T14:19:54Z", "type": "forcePushed"}, {"oid": "8e0da15242baad7de020938d24ad076b11b651c4", "url": "https://github.com/apache/flink/commit/8e0da15242baad7de020938d24ad076b11b651c4", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-23T16:19:00Z", "type": "forcePushed"}, {"oid": "df935f35307616478058c4991d17de06376836a2", "url": "https://github.com/apache/flink/commit/df935f35307616478058c4991d17de06376836a2", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-23T19:02:11Z", "type": "forcePushed"}, {"oid": "4a598b96aa0250255f8758ce4ce57df23072dac7", "url": "https://github.com/apache/flink/commit/4a598b96aa0250255f8758ce4ce57df23072dac7", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-23T22:56:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEzMzQ2Mg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494133462", "bodyText": "Good fix. I'm starting to wonder if we should phase out DummyEnvironment. It seems like it lacks so much.", "author": "AHeise", "createdAt": "2020-09-24T08:29:31Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/operators/testutils/DummyEnvironment.java", "diffHunk": "@@ -230,7 +230,7 @@ public ResultPartitionWriter getWriter(int index) {\n \n \t@Override\n \tpublic IndexedInputGate getInputGate(int index) {\n-\t\treturn null;\n+\t\tthrow new ArrayIndexOutOfBoundsException(0);", "originalCommit": "77ec70dc867605d7855ea4a8aad21a1bfc5743bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NDg5Mw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494284893", "bodyText": "Could we unify both code paths by always using\nfor (InputGate inputGate : getEnvironment().getAllInputGates()) {\n\tinputGate\n\t\t.getStateConsumedFuture()\n\t\t.thenRun(() -> mainMailboxExecutor.execute(inputGate::requestPartitions, \"Input gate request partitions\"));\n}\n\nand set getStateConsumedFuture to done if no data is available?", "author": "AHeise", "createdAt": "2020-09-24T12:42:08Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -502,33 +503,24 @@ protected void beforeInvoke() throws Exception {\n \t}\n \n \tprivate void readRecoveredChannelState() throws IOException, InterruptedException {\n-\t\tChannelStateReader reader = getEnvironment().getTaskStateManager().getChannelStateReader();\n-\t\tif (!reader.hasChannelStates()) {\n-\t\t\trequestPartitions();\n-\t\t\treturn;\n-\t\t}\n-\n-\t\tResultPartitionWriter[] writers = getEnvironment().getAllWriters();\n-\t\tif (writers != null) {\n-\t\t\tfor (ResultPartitionWriter writer : writers) {\n-\t\t\t\tif (writer instanceof CheckpointedResultPartition) {\n-\t\t\t\t\t((CheckpointedResultPartition) writer).readRecoveredState(reader);\n-\t\t\t\t} else {\n-\t\t\t\t\tthrow new IllegalStateException(\n-\t\t\t\t\t\t\t\"Cannot restore state to a non-checkpointable partition type: \" + writer);\n+\t\tSequentialChannelStateReader reader = getEnvironment().getTaskStateManager().getSequentialChannelStateReader();\n+\t\tif (reader.hasChannelStates()) {\n+\t\t\treader.readOutputData(getEnvironment().getAllWriters());\n+\t\t\tchannelIOExecutor.execute(() -> {\n+\t\t\t\ttry {\n+\t\t\t\t\treader.readInputData(getEnvironment().getAllInputGates());\n+\t\t\t\t} catch (Exception e) {\n+\t\t\t\t\tasyncExceptionHandler.handleAsyncException(\"Unable to read channel state\", e);\n \t\t\t\t}\n-\t\t\t}\n-\t\t}\n+\t\t\t});\n \n-\t\t// It would get possible benefits to recovery input side after output side, which guarantees the\n-\t\t// output can request more floating buffers from global firstly.\n-\t\tInputGate[] inputGates = getEnvironment().getAllInputGates();\n-\t\tif (inputGates != null && inputGates.length > 0) {\n-\t\t\tfor (InputGate inputGate : inputGates) {\n+\t\t\tfor (InputGate inputGate : getEnvironment().getAllInputGates()) {\n \t\t\t\tinputGate\n-\t\t\t\t\t.readRecoveredState(channelIOExecutor, reader)\n+\t\t\t\t\t.getStateConsumedFuture()\n \t\t\t\t\t.thenRun(() -> mainMailboxExecutor.execute(inputGate::requestPartitions, \"Input gate request partitions\"));\n \t\t\t}\n+\t\t} else {\n+\t\t\trequestPartitions();", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5ODIyNg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494498226", "bodyText": "Yes, this is what I'm doing in [FLINK-18989][task] Read channel state unconditionally (but I'm trying to move this commit to #13467).", "author": "rkhachatryan", "createdAt": "2020-09-24T17:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NDg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NjIwNw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494286207", "bodyText": "Do we have a use for the old ChannelStateReader? I had expected to see all changes inside the existing class.", "author": "AHeise", "createdAt": "2020-09-24T12:44:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReader.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.apache.flink.runtime.checkpoint.channel;\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Reads channel state saved during checkpoint/savepoint.\n+ */\n+@Internal\n+public interface SequentialChannelStateReader extends AutoCloseable {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgzMDY0MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494830641", "bodyText": "Became apparent with later commits that it's going to be removed. Would be good to see it reflected in commit message.", "author": "AHeise", "createdAt": "2020-09-25T08:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI4NjIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NDQ0Ng==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494294446", "bodyText": "It's probably easier to understand (at least for me) if you apply the extractor on call side and just pass Stream<StateObjectCollection<Handle>> into read.\nread(OperatorSubtaskState::getInputChannelState, stateHandler)\n\n->\nread(streamSubtaskStates().map(OperatorSubtaskState::getInputChannelState), stateHandler)", "author": "AHeise", "createdAt": "2020-09-24T12:56:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NTkzMQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494295931", "bodyText": "Okay noob question: What is the relation between delegate and handles?\nIs that necessary because of the optimization to have small state in metadata?\nI thought that we only have one state file per subtask and now I'm a bit confused.", "author": "AHeise", "createdAt": "2020-09-24T12:58:59Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwMzk0OA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494503948", "bodyText": "What is the relation between delegate and handles\n\n1:M, that is one underlying delegate can be referenced by 1 or more handles.\n\nwe only have one state file per subtask\n\nYes, but on downscaling we can have more.\nDoes this answer your question?", "author": "rkhachatryan", "createdAt": "2020-09-24T17:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5NTkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5Nzg4MA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494297880", "bodyText": "When would we have length == 0? Shouldn't that be already skipped while writing? I wonder if it's worth throwing.", "author": "AHeise", "createdAt": "2020-09-24T13:02:00Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;\n+\n+\tvoid recover(Info info, Context context) throws IOException;\n+}\n+\n+class InputChannelRecoveredStateHandler implements RecoveredChannelStateHandler<InputChannelInfo, Buffer> {\n+\tprivate final InputGate[] inputGates;\n+\n+\tInputChannelRecoveredStateHandler(InputGate[] inputGates) {\n+\t\tthis.inputGates = inputGates;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Buffer> getBuffer(InputChannelInfo channelInfo) throws IOException {\n+\t\tRecoveredInputChannel channel = getChannel(channelInfo);\n+\t\tBuffer buffer;\n+\t\ttry {\n+\t\t\tbuffer = channel.getBuffer();\n+\t\t\treturn Tuple2.of(wrap(buffer), buffer);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void recover(InputChannelInfo channelInfo, Buffer buffer) {\n+\t\tif (buffer.readableBytes() > 0) {\n+\t\t\tgetChannel(channelInfo).onRecoveredStateBuffer(buffer);\n+\t\t} else {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\t// note that we need to finish all RecoveredInputChannels, not just those with state\n+\t\tfor (final InputGate inputGate : inputGates) {\n+\t\t\tinputGate.finishReadRecoveredState();\n+\t\t}\n+\t}\n+\n+\tprivate RecoveredInputChannel getChannel(InputChannelInfo info) {\n+\t\treturn (RecoveredInputChannel) inputGates[info.getGateIdx()].getChannel(info.getInputChannelIdx());\n+\t}\n+}\n+\n+class ResultSubpartitionRecoveredStateHandler implements RecoveredChannelStateHandler<ResultSubpartitionInfo, Tuple2<BufferBuilder, BufferConsumer>> {\n+\n+\tprivate final ResultPartitionWriter[] writers;\n+\n+\tResultSubpartitionRecoveredStateHandler(ResultPartitionWriter[] writers) {\n+\t\tthis.writers = writers;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Tuple2<BufferBuilder, BufferConsumer>> getBuffer(ResultSubpartitionInfo subpartitionInfo) throws IOException {\n+\t\tBufferBuilder bufferBuilder;\n+\t\ttry {\n+\t\t\tbufferBuilder = getWriter(subpartitionInfo).getBufferBuilder(subpartitionInfo.getSubPartitionIdx());\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\treturn Tuple2.of(wrap(bufferBuilder), Tuple2.of(bufferBuilder, bufferBuilder.createBufferConsumer()));\n+\t}\n+\n+\t@Override\n+\tpublic void recover(ResultSubpartitionInfo subpartitionInfo, Tuple2<BufferBuilder, BufferConsumer> bufferConsumer) throws IOException {\n+\t\tbufferConsumer.f0.finish();\n+\t\tgetWriter(subpartitionInfo).addBufferConsumer(bufferConsumer.f1, subpartitionInfo.getSubPartitionIdx());\n+\t}\n+\n+\tprivate ResultPartitionWriter getWriter(ResultSubpartitionInfo info) {\n+\t\treturn writers[info.getPartitionIdx()];\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t}\n+}\n+\n+class ChannelStateChunkReader {\n+\tprivate final ChannelStateSerializer serializer;\n+\n+\tChannelStateChunkReader(ChannelStateSerializer serializer) {\n+\t\tthis.serializer = serializer;\n+\t}\n+\n+\t<Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readChunk(\n+\t\t\tFSDataInputStream source,\n+\t\t\tlong sourceOffset,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler,\n+\t\t\tInfo channelInfo) throws IOException {\n+\t\tif (source.getPos() != sourceOffset) {\n+\t\t\tsource.seek(sourceOffset);\n+\t\t}\n+\t\tint length = serializer.readLength(source);\n+\t\twhile (length > 0) {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNzM5Ng==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494507396", "bodyText": "length is decremented below: length -= serializer.readData", "author": "rkhachatryan", "createdAt": "2020-09-24T17:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI5Nzg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwMzAxNg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494303016", "bodyText": "What is the main motivation for keeping readChunk in a separate class from SeqReaderImpl? Is it for unit tests?", "author": "AHeise", "createdAt": "2020-09-24T13:09:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;\n+\n+\tvoid recover(Info info, Context context) throws IOException;\n+}\n+\n+class InputChannelRecoveredStateHandler implements RecoveredChannelStateHandler<InputChannelInfo, Buffer> {\n+\tprivate final InputGate[] inputGates;\n+\n+\tInputChannelRecoveredStateHandler(InputGate[] inputGates) {\n+\t\tthis.inputGates = inputGates;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Buffer> getBuffer(InputChannelInfo channelInfo) throws IOException {\n+\t\tRecoveredInputChannel channel = getChannel(channelInfo);\n+\t\tBuffer buffer;\n+\t\ttry {\n+\t\t\tbuffer = channel.getBuffer();\n+\t\t\treturn Tuple2.of(wrap(buffer), buffer);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void recover(InputChannelInfo channelInfo, Buffer buffer) {\n+\t\tif (buffer.readableBytes() > 0) {\n+\t\t\tgetChannel(channelInfo).onRecoveredStateBuffer(buffer);\n+\t\t} else {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\t// note that we need to finish all RecoveredInputChannels, not just those with state\n+\t\tfor (final InputGate inputGate : inputGates) {\n+\t\t\tinputGate.finishReadRecoveredState();\n+\t\t}\n+\t}\n+\n+\tprivate RecoveredInputChannel getChannel(InputChannelInfo info) {\n+\t\treturn (RecoveredInputChannel) inputGates[info.getGateIdx()].getChannel(info.getInputChannelIdx());\n+\t}\n+}\n+\n+class ResultSubpartitionRecoveredStateHandler implements RecoveredChannelStateHandler<ResultSubpartitionInfo, Tuple2<BufferBuilder, BufferConsumer>> {\n+\n+\tprivate final ResultPartitionWriter[] writers;\n+\n+\tResultSubpartitionRecoveredStateHandler(ResultPartitionWriter[] writers) {\n+\t\tthis.writers = writers;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Tuple2<BufferBuilder, BufferConsumer>> getBuffer(ResultSubpartitionInfo subpartitionInfo) throws IOException {\n+\t\tBufferBuilder bufferBuilder;\n+\t\ttry {\n+\t\t\tbufferBuilder = getWriter(subpartitionInfo).getBufferBuilder(subpartitionInfo.getSubPartitionIdx());\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\treturn Tuple2.of(wrap(bufferBuilder), Tuple2.of(bufferBuilder, bufferBuilder.createBufferConsumer()));\n+\t}\n+\n+\t@Override\n+\tpublic void recover(ResultSubpartitionInfo subpartitionInfo, Tuple2<BufferBuilder, BufferConsumer> bufferConsumer) throws IOException {\n+\t\tbufferConsumer.f0.finish();\n+\t\tgetWriter(subpartitionInfo).addBufferConsumer(bufferConsumer.f1, subpartitionInfo.getSubPartitionIdx());\n+\t}\n+\n+\tprivate ResultPartitionWriter getWriter(ResultSubpartitionInfo info) {\n+\t\treturn writers[info.getPartitionIdx()];\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t}\n+}\n+\n+class ChannelStateChunkReader {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwOTE5NA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494509194", "bodyText": "Yes, mostly for testing.", "author": "rkhachatryan", "createdAt": "2020-09-24T18:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwMzAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwNDAxMA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494304010", "bodyText": "It would easier to read if you add a small POJO instead of using Tuple2.", "author": "AHeise", "createdAt": "2020-09-24T13:11:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwNjU4Mg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494306582", "bodyText": "rename parameter to bufferBuilderAndConsumer?", "author": "AHeise", "createdAt": "2020-09-24T13:14:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;\n+\n+\tvoid recover(Info info, Context context) throws IOException;\n+}\n+\n+class InputChannelRecoveredStateHandler implements RecoveredChannelStateHandler<InputChannelInfo, Buffer> {\n+\tprivate final InputGate[] inputGates;\n+\n+\tInputChannelRecoveredStateHandler(InputGate[] inputGates) {\n+\t\tthis.inputGates = inputGates;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Buffer> getBuffer(InputChannelInfo channelInfo) throws IOException {\n+\t\tRecoveredInputChannel channel = getChannel(channelInfo);\n+\t\tBuffer buffer;\n+\t\ttry {\n+\t\t\tbuffer = channel.getBuffer();\n+\t\t\treturn Tuple2.of(wrap(buffer), buffer);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void recover(InputChannelInfo channelInfo, Buffer buffer) {\n+\t\tif (buffer.readableBytes() > 0) {\n+\t\t\tgetChannel(channelInfo).onRecoveredStateBuffer(buffer);\n+\t\t} else {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\t// note that we need to finish all RecoveredInputChannels, not just those with state\n+\t\tfor (final InputGate inputGate : inputGates) {\n+\t\t\tinputGate.finishReadRecoveredState();\n+\t\t}\n+\t}\n+\n+\tprivate RecoveredInputChannel getChannel(InputChannelInfo info) {\n+\t\treturn (RecoveredInputChannel) inputGates[info.getGateIdx()].getChannel(info.getInputChannelIdx());\n+\t}\n+}\n+\n+class ResultSubpartitionRecoveredStateHandler implements RecoveredChannelStateHandler<ResultSubpartitionInfo, Tuple2<BufferBuilder, BufferConsumer>> {\n+\n+\tprivate final ResultPartitionWriter[] writers;\n+\n+\tResultSubpartitionRecoveredStateHandler(ResultPartitionWriter[] writers) {\n+\t\tthis.writers = writers;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Tuple2<BufferBuilder, BufferConsumer>> getBuffer(ResultSubpartitionInfo subpartitionInfo) throws IOException {\n+\t\tBufferBuilder bufferBuilder;\n+\t\ttry {\n+\t\t\tbufferBuilder = getWriter(subpartitionInfo).getBufferBuilder(subpartitionInfo.getSubPartitionIdx());\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\treturn Tuple2.of(wrap(bufferBuilder), Tuple2.of(bufferBuilder, bufferBuilder.createBufferConsumer()));\n+\t}\n+\n+\t@Override\n+\tpublic void recover(ResultSubpartitionInfo subpartitionInfo, Tuple2<BufferBuilder, BufferConsumer> bufferConsumer) throws IOException {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwODEzNw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494308137", "bodyText": "Wouldn't it be enough to just create the consumer in recover? Then you also could go with BufferBuilder as Context.", "author": "AHeise", "createdAt": "2020-09-24T13:16:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;\n+\n+\tvoid recover(Info info, Context context) throws IOException;\n+}\n+\n+class InputChannelRecoveredStateHandler implements RecoveredChannelStateHandler<InputChannelInfo, Buffer> {\n+\tprivate final InputGate[] inputGates;\n+\n+\tInputChannelRecoveredStateHandler(InputGate[] inputGates) {\n+\t\tthis.inputGates = inputGates;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Buffer> getBuffer(InputChannelInfo channelInfo) throws IOException {\n+\t\tRecoveredInputChannel channel = getChannel(channelInfo);\n+\t\tBuffer buffer;\n+\t\ttry {\n+\t\t\tbuffer = channel.getBuffer();\n+\t\t\treturn Tuple2.of(wrap(buffer), buffer);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void recover(InputChannelInfo channelInfo, Buffer buffer) {\n+\t\tif (buffer.readableBytes() > 0) {\n+\t\t\tgetChannel(channelInfo).onRecoveredStateBuffer(buffer);\n+\t\t} else {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\t// note that we need to finish all RecoveredInputChannels, not just those with state\n+\t\tfor (final InputGate inputGate : inputGates) {\n+\t\t\tinputGate.finishReadRecoveredState();\n+\t\t}\n+\t}\n+\n+\tprivate RecoveredInputChannel getChannel(InputChannelInfo info) {\n+\t\treturn (RecoveredInputChannel) inputGates[info.getGateIdx()].getChannel(info.getInputChannelIdx());\n+\t}\n+}\n+\n+class ResultSubpartitionRecoveredStateHandler implements RecoveredChannelStateHandler<ResultSubpartitionInfo, Tuple2<BufferBuilder, BufferConsumer>> {\n+\n+\tprivate final ResultPartitionWriter[] writers;\n+\n+\tResultSubpartitionRecoveredStateHandler(ResultPartitionWriter[] writers) {\n+\t\tthis.writers = writers;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Tuple2<BufferBuilder, BufferConsumer>> getBuffer(ResultSubpartitionInfo subpartitionInfo) throws IOException {\n+\t\tBufferBuilder bufferBuilder;\n+\t\ttry {\n+\t\t\tbufferBuilder = getWriter(subpartitionInfo).getBufferBuilder(subpartitionInfo.getSubPartitionIdx());\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\treturn Tuple2.of(wrap(bufferBuilder), Tuple2.of(bufferBuilder, bufferBuilder.createBufferConsumer()));", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyMzc3Nw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494523777", "bodyText": "Here, it's important to create consumer before writing data.\nFrom BufferBuilder.createBufferConsumer javadoc:\n\nData written to BufferBuilder before creation of BufferConsumer won't be visible for that BufferConsumer", "author": "rkhachatryan", "createdAt": "2020-09-24T18:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMwODEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDY1MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494314651", "bodyText": "Should the context also be cleaned up or doesn't it matter because it's failing anyways?", "author": "AHeise", "createdAt": "2020-09-24T13:26:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;\n+\n+\tvoid recover(Info info, Context context) throws IOException;\n+}\n+\n+class InputChannelRecoveredStateHandler implements RecoveredChannelStateHandler<InputChannelInfo, Buffer> {\n+\tprivate final InputGate[] inputGates;\n+\n+\tInputChannelRecoveredStateHandler(InputGate[] inputGates) {\n+\t\tthis.inputGates = inputGates;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Buffer> getBuffer(InputChannelInfo channelInfo) throws IOException {\n+\t\tRecoveredInputChannel channel = getChannel(channelInfo);\n+\t\tBuffer buffer;\n+\t\ttry {\n+\t\t\tbuffer = channel.getBuffer();\n+\t\t\treturn Tuple2.of(wrap(buffer), buffer);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void recover(InputChannelInfo channelInfo, Buffer buffer) {\n+\t\tif (buffer.readableBytes() > 0) {\n+\t\t\tgetChannel(channelInfo).onRecoveredStateBuffer(buffer);\n+\t\t} else {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\t// note that we need to finish all RecoveredInputChannels, not just those with state\n+\t\tfor (final InputGate inputGate : inputGates) {\n+\t\t\tinputGate.finishReadRecoveredState();\n+\t\t}\n+\t}\n+\n+\tprivate RecoveredInputChannel getChannel(InputChannelInfo info) {\n+\t\treturn (RecoveredInputChannel) inputGates[info.getGateIdx()].getChannel(info.getInputChannelIdx());\n+\t}\n+}\n+\n+class ResultSubpartitionRecoveredStateHandler implements RecoveredChannelStateHandler<ResultSubpartitionInfo, Tuple2<BufferBuilder, BufferConsumer>> {\n+\n+\tprivate final ResultPartitionWriter[] writers;\n+\n+\tResultSubpartitionRecoveredStateHandler(ResultPartitionWriter[] writers) {\n+\t\tthis.writers = writers;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Tuple2<BufferBuilder, BufferConsumer>> getBuffer(ResultSubpartitionInfo subpartitionInfo) throws IOException {\n+\t\tBufferBuilder bufferBuilder;\n+\t\ttry {\n+\t\t\tbufferBuilder = getWriter(subpartitionInfo).getBufferBuilder(subpartitionInfo.getSubPartitionIdx());\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t\treturn Tuple2.of(wrap(bufferBuilder), Tuple2.of(bufferBuilder, bufferBuilder.createBufferConsumer()));\n+\t}\n+\n+\t@Override\n+\tpublic void recover(ResultSubpartitionInfo subpartitionInfo, Tuple2<BufferBuilder, BufferConsumer> bufferConsumer) throws IOException {\n+\t\tbufferConsumer.f0.finish();\n+\t\tgetWriter(subpartitionInfo).addBufferConsumer(bufferConsumer.f1, subpartitionInfo.getSubPartitionIdx());\n+\t}\n+\n+\tprivate ResultPartitionWriter getWriter(ResultSubpartitionInfo info) {\n+\t\treturn writers[info.getPartitionIdx()];\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t}\n+}\n+\n+class ChannelStateChunkReader {\n+\tprivate final ChannelStateSerializer serializer;\n+\n+\tChannelStateChunkReader(ChannelStateSerializer serializer) {\n+\t\tthis.serializer = serializer;\n+\t}\n+\n+\t<Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readChunk(\n+\t\t\tFSDataInputStream source,\n+\t\t\tlong sourceOffset,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler,\n+\t\t\tInfo channelInfo) throws IOException {\n+\t\tif (source.getPos() != sourceOffset) {\n+\t\t\tsource.seek(sourceOffset);\n+\t\t}\n+\t\tint length = serializer.readLength(source);\n+\t\twhile (length > 0) {\n+\t\t\tTuple2<ChannelStateByteBuffer, Context> bufferWithContext = stateHandler.getBuffer(channelInfo);\n+\t\t\ttry {\n+\t\t\t\twhile (length > 0 && bufferWithContext.f0.isWritable()) {\n+\t\t\t\t\tlength -= serializer.readData(source, bufferWithContext.f0, length);\n+\t\t\t\t}\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tbufferWithContext.f0.recycle();", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzMDc4NA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494530784", "bodyText": "It's enough to clean buffer, context is not supposed to hold any resources on its own.", "author": "rkhachatryan", "createdAt": "2020-09-24T18:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxNDY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTg5Nw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494319897", "bodyText": "This exception handling looks suspicious to me. I'd probably let the exception bubble up as is.\nIf you want to translate for some reason, I'd still use Thread.currentThread().interrupt(); to restore the interruption flag of the thread.", "author": "AHeise", "createdAt": "2020-09-24T13:33:04Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;\n+\n+\tvoid recover(Info info, Context context) throws IOException;\n+}\n+\n+class InputChannelRecoveredStateHandler implements RecoveredChannelStateHandler<InputChannelInfo, Buffer> {\n+\tprivate final InputGate[] inputGates;\n+\n+\tInputChannelRecoveredStateHandler(InputGate[] inputGates) {\n+\t\tthis.inputGates = inputGates;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Buffer> getBuffer(InputChannelInfo channelInfo) throws IOException {\n+\t\tRecoveredInputChannel channel = getChannel(channelInfo);\n+\t\tBuffer buffer;\n+\t\ttry {\n+\t\t\tbuffer = channel.getBuffer();\n+\t\t\treturn Tuple2.of(wrap(buffer), buffer);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void recover(InputChannelInfo channelInfo, Buffer buffer) {\n+\t\tif (buffer.readableBytes() > 0) {\n+\t\t\tgetChannel(channelInfo).onRecoveredStateBuffer(buffer);\n+\t\t} else {\n+\t\t\tbuffer.recycleBuffer();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\t// note that we need to finish all RecoveredInputChannels, not just those with state\n+\t\tfor (final InputGate inputGate : inputGates) {\n+\t\t\tinputGate.finishReadRecoveredState();\n+\t\t}\n+\t}\n+\n+\tprivate RecoveredInputChannel getChannel(InputChannelInfo info) {\n+\t\treturn (RecoveredInputChannel) inputGates[info.getGateIdx()].getChannel(info.getInputChannelIdx());\n+\t}\n+}\n+\n+class ResultSubpartitionRecoveredStateHandler implements RecoveredChannelStateHandler<ResultSubpartitionInfo, Tuple2<BufferBuilder, BufferConsumer>> {\n+\n+\tprivate final ResultPartitionWriter[] writers;\n+\n+\tResultSubpartitionRecoveredStateHandler(ResultPartitionWriter[] writers) {\n+\t\tthis.writers = writers;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Tuple2<BufferBuilder, BufferConsumer>> getBuffer(ResultSubpartitionInfo subpartitionInfo) throws IOException {\n+\t\tBufferBuilder bufferBuilder;\n+\t\ttry {\n+\t\t\tbufferBuilder = getWriter(subpartitionInfo).getBufferBuilder(subpartitionInfo.getSubPartitionIdx());\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzNDQ5MA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494534490", "bodyText": "InterruptedException is a checked exception so I'd had to declare it if not wrapping.\nBut it's not appropriate for this layer (IO).\nThread.currentThread().interrupt(); only sets the status, so the caller can skip interrupt status check.", "author": "rkhachatryan", "createdAt": "2020-09-24T18:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0ODQzNA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494848434", "bodyText": "InterruptedException quite often should be handled differently and it's good to know that the InterruptedException has happened.\nFor example, when caller received IOException, it might decide to retry or just keep going if that was not a critical part. InterruptedException should on the other hand shut down the code semi gracefully and as quickly as possible.\nHere I think adding throws InterruptedException would be much better. But I didn't look how deep in a call stack are we and how difficult would it be to propagate it. Whether it is appropriate on this layer or not is kind of irrelevant. It can happen, the question is how should you handle it?\nre Thread.currentThread().interrupt();, the crowd wisdom is to always set it when wrapping/hiding/rethrowing InterruptedException. I think we are using interrupted flag in only a couple of places, but it's better to keep it clean, just in case we would had to use it some important place and then we would discover we need to fix interrupted flag everywhere to make it work.", "author": "pnowojski", "createdAt": "2020-09-25T08:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NzQxNQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495087415", "bodyText": "You're right about currentThread().interrupt() and that handling of IOException likely differs from that of InterruptedException.\nBut for the latter, I think it's better to wrap it into RuntimeException.", "author": "rkhachatryan", "createdAt": "2020-09-25T16:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2NDk5OA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495764998", "bodyText": "Personally I don't like declared exceptions, but even in that case special treatment of the InterruptedException means  it makes sense to declare it explicitly. But the issue is that in Flink trend is to have explicit exceptions handling/declarations. Here it looks like the InterruptedException is already present on the call site (StreamTask#readRecoveredChannelState), so it shouldn't be an issue to conform with this.", "author": "pnowojski", "createdAt": "2020-09-28T08:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ1Nzg3Mg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496457872", "bodyText": "Removed catch InterruptedException and added to the method signature after not converging in an offline discussion.", "author": "rkhachatryan", "createdAt": "2020-09-29T06:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMxOTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMTU3Mg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494321572", "bodyText": "This check is missing on output side. Add there for symmetry?\nHowever, I'd probably rather skip writing empty buffers altogether and just use a checkState to verify it here (and remove else branch).", "author": "AHeise", "createdAt": "2020-09-24T13:35:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {\n+\tTuple2<ChannelStateByteBuffer, Context> getBuffer(Info info) throws IOException;\n+\n+\tvoid recover(Info info, Context context) throws IOException;\n+}\n+\n+class InputChannelRecoveredStateHandler implements RecoveredChannelStateHandler<InputChannelInfo, Buffer> {\n+\tprivate final InputGate[] inputGates;\n+\n+\tInputChannelRecoveredStateHandler(InputGate[] inputGates) {\n+\t\tthis.inputGates = inputGates;\n+\t}\n+\n+\t@Override\n+\tpublic Tuple2<ChannelStateByteBuffer, Buffer> getBuffer(InputChannelInfo channelInfo) throws IOException {\n+\t\tRecoveredInputChannel channel = getChannel(channelInfo);\n+\t\tBuffer buffer;\n+\t\ttry {\n+\t\t\tbuffer = channel.getBuffer();\n+\t\t\treturn Tuple2.of(wrap(buffer), buffer);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tthrow new IOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void recover(InputChannelInfo channelInfo, Buffer buffer) {\n+\t\tif (buffer.readableBytes() > 0) {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMjYxMA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494322610", "bodyText": "nit: empty line.", "author": "AHeise", "createdAt": "2020-09-24T13:36:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzQ0Nw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494323447", "bodyText": "I was wondering if 5 classes per file are not too many. I haven't seen that in the code base so far. One option would be to extract RecoveredChannelStateHandler and its implementation to a separate file.", "author": "AHeise", "createdAt": "2020-09-24T13:37:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles\n+\t\t\t.stream()\n+\t\t\t.flatMap(SequentialChannelStateReaderImpl::extractOffsets)\n+\t\t\t.sorted(comparingLong(offsetAndInfo -> offsetAndInfo.f0))\n+\t\t\t.collect(toList());\n+\t}\n+\n+\tprivate static  <Info, Handle extends AbstractChannelStateHandle<Info>> Stream<Tuple2<Long, Info>> extractOffsets(Handle handle) {\n+\t\treturn handle.getOffsets().stream().map(offset -> Tuple2.of(offset, handle.getInfo()));\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t}\n+\n+}\n+\n+interface RecoveredChannelStateHandler<Info, Context> extends AutoCloseable {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NzkzOQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495087939", "bodyText": "Good point, I'll move them to a separate file.", "author": "rkhachatryan", "createdAt": "2020-09-25T16:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyNDQyMw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494324423", "bodyText": "package-default to make clear that it is only used for testing?", "author": "AHeise", "createdAt": "2020-09-24T13:39:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyNDQ5NQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494324495", "bodyText": "package-default to make clear that it is only used for testing?", "author": "AHeise", "createdAt": "2020-09-24T13:39:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4ODIyMg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495088222", "bodyText": "I found this constructor can even be inlined.", "author": "rkhachatryan", "createdAt": "2020-09-25T16:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyNDQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyODM4Mg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494328382", "bodyText": "When would the offsets be unsorted? Is this more of a precaution or is it common?\nIs it again the small file optimization?", "author": "AHeise", "createdAt": "2020-09-24T13:43:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImpl.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.api.writer.ResultPartitionWriter;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferBuilder;\n+import org.apache.flink.runtime.io.network.buffer.BufferConsumer;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.RecoveredInputChannel;\n+import org.apache.flink.runtime.state.AbstractChannelStateHandle;\n+import org.apache.flink.runtime.state.StreamStateHandle;\n+import org.apache.flink.util.Preconditions;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import static java.util.Comparator.comparingLong;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;\n+\n+/**\n+ * {@link SequentialChannelStateReader} implementation.\n+ */\n+public class SequentialChannelStateReaderImpl implements SequentialChannelStateReader {\n+\n+\tprivate final TaskStateSnapshot taskStateSnapshot;\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final ChannelStateChunkReader chunkReader;\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot) {\n+\t\tthis(taskStateSnapshot, new ChannelStateSerializerImpl());\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = new ChannelStateChunkReader(serializer);\n+\t}\n+\n+\tpublic SequentialChannelStateReaderImpl(TaskStateSnapshot taskStateSnapshot, ChannelStateSerializer serializer, ChannelStateChunkReader chunkReader) {\n+\t\tthis.taskStateSnapshot = taskStateSnapshot;\n+\t\tthis.serializer = serializer;\n+\t\tthis.chunkReader = chunkReader;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasChannelStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().anyMatch(subtaskStateEntry ->\n+\t\t\tsubtaskStateEntry.getValue().getInputChannelState().stream().anyMatch(h -> !h.getOffsets().isEmpty()) ||\n+\t\t\t\tsubtaskStateEntry.getValue().getResultSubpartitionState().stream().anyMatch(h -> !h.getOffsets().isEmpty()));\n+\t}\n+\n+\t@Override\n+\tpublic void readInputData(InputGate[] inputGates) throws IOException {\n+\t\ttry (InputChannelRecoveredStateHandler stateHandler = new InputChannelRecoveredStateHandler(inputGates)) {\n+\t\t\tread(OperatorSubtaskState::getInputChannelState, stateHandler);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void readOutputData(ResultPartitionWriter[] writers) throws IOException {\n+\t\ttry (ResultSubpartitionRecoveredStateHandler stateHandler = new ResultSubpartitionRecoveredStateHandler(writers)) {\n+\t\t\tread(OperatorSubtaskState::getResultSubpartitionState, stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void read(\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\tfor (Map.Entry<StreamStateHandle, List<Handle>> delegateAndHandles : groupByDelegate(streamSubtaskStates(), stateHandleExtractor).entrySet()) {\n+\t\t\treadSequentially(delegateAndHandles.getKey(), delegateAndHandles.getValue(), stateHandler);\n+\t\t}\n+\t}\n+\n+\tprivate <Info, Context, Handle extends AbstractChannelStateHandle<Info>> void readSequentially(\n+\t\t\tStreamStateHandle streamStateHandle,\n+\t\t\tList<Handle> channelStateHandles,\n+\t\t\tRecoveredChannelStateHandler<Info, Context> stateHandler) throws IOException {\n+\t\ttry (FSDataInputStream is = streamStateHandle.openInputStream()) {\n+\t\t\tserializer.readHeader(is);\n+\t\t\tfor (Tuple2<Long, Info> offsetAndChannelInfo : extractOffsetsSorted(channelStateHandles)) {\n+\t\t\t\tchunkReader.readChunk(is, offsetAndChannelInfo.f0, stateHandler, offsetAndChannelInfo.f1);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Stream<OperatorSubtaskState> streamSubtaskStates() {\n+\t\treturn taskStateSnapshot.getSubtaskStateMappings().stream().map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Map<StreamStateHandle, List<Handle>> groupByDelegate(\n+\t\t\tStream<OperatorSubtaskState> states,\n+\t\t\tFunction<OperatorSubtaskState, StateObjectCollection<Handle>> stateHandleExtractor) {\n+\t\treturn states\n+\t\t\t.map(stateHandleExtractor).flatMap(Collection::stream)\n+\t\t\t.peek(validate())\n+\t\t\t.collect(groupingBy(AbstractChannelStateHandle::getDelegate));\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> Consumer<Handle> validate() {\n+\t\tSet<Info> seen = new HashSet<>();\n+\t\t// expect each channel to be described only once; otherwise, buffers in channel could be re-ordered\n+\t\treturn handle -> Preconditions.checkState(seen.add(handle.getInfo()), \"duplicate channel info: %s\");\n+\t}\n+\n+\tprivate static <Info, Handle extends AbstractChannelStateHandle<Info>> List<Tuple2<Long, Info>> extractOffsetsSorted(List<Handle> channelStateHandles) {\n+\t\treturn channelStateHandles", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA5NTU3Nw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495095577", "bodyText": "Offsets are sorted only across single ChannelStateHandle.\nThey are mostly sorted across all ChannelStateHandles referring to the same file (if handles are sorted in the same way as during writing).\nSo sorting is necessary here.", "author": "rkhachatryan", "createdAt": "2020-09-25T16:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyODM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzMDI2Mg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494330262", "bodyText": "getStream?", "author": "AHeise", "createdAt": "2020-09-24T13:45:28Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateChunkReaderTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.core.memory.MemorySegmentFactory;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;\n+\n+import org.junit.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkState;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * {@link ChannelStateChunkReader} test.\n+ */\n+public class ChannelStateChunkReaderTest {\n+\n+\t@Test(expected = TestException.class)\n+\tpublic void testBufferRecycledOnFailure() throws IOException {\n+\t\tFailingChannelStateSerializer serializer = new FailingChannelStateSerializer();\n+\t\tTestRecoveredChannelStateHandler handler = new TestRecoveredChannelStateHandler();\n+\n+\t\ttry (FSDataInputStream stream = geStream(serializer, 10)) {\n+\t\t\tnew ChannelStateChunkReader(serializer).readChunk(stream, serializer.getHeaderLength(), handler, \"channelInfo\");\n+\t\t\tcheckState(serializer.failed);\n+\t\t\tcheckState(!handler.requestedBuffers.isEmpty());\n+\t\t} finally {\n+\t\t\tassertTrue(handler.requestedBuffers.stream().allMatch(TestChannelStateByteBuffer::isRecycled));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testBuffersNotRequestedForEmptyStream() throws IOException {\n+\t\tChannelStateSerializer serializer = new ChannelStateSerializerImpl();\n+\t\tTestRecoveredChannelStateHandler handler = new TestRecoveredChannelStateHandler();\n+\n+\t\ttry (FSDataInputStream stream = geStream(serializer, 0)) {\n+\t\t\tnew ChannelStateChunkReader(serializer).readChunk(stream, serializer.getHeaderLength(), handler, \"channelInfo\");\n+\t\t} finally {\n+\t\t\tassertTrue(handler.requestedBuffers.isEmpty());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNoSeekUnnecessarily() throws IOException {\n+\t\tfinal int offset = 123;\n+\t\tfinal FSDataInputStream stream = new FSDataInputStream() {\n+\t\t\t@Override\n+\t\t\tpublic long getPos() {\n+\t\t\t\treturn offset;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void seek(long ignored) {\n+\t\t\t\tfail();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int read() {\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t};\n+\n+\t\tnew ChannelStateChunkReader(new ChannelStateSerializerImpl())\n+\t\t\t.readChunk(stream, offset, new TestRecoveredChannelStateHandler(), \"channelInfo\");\n+\t}\n+\n+\tprivate static class TestRecoveredChannelStateHandler implements RecoveredChannelStateHandler<Object, Object> {\n+\t\tprivate final List<TestChannelStateByteBuffer> requestedBuffers = new ArrayList<>();\n+\n+\t\t@Override\n+\t\tpublic Tuple2<ChannelStateByteBuffer, Object> getBuffer(Object o) {\n+\t\t\tTestChannelStateByteBuffer buffer = new TestChannelStateByteBuffer();\n+\t\t\trequestedBuffers.add(buffer);\n+\t\t\treturn Tuple2.of(buffer, null);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void recover(Object o, Object o2) {\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() throws Exception {\n+\t\t}\n+\n+\t}\n+\n+\tprivate static class FailingChannelStateSerializer extends ChannelStateSerializerImpl {\n+\t\tprivate boolean failed;\n+\n+\t\t@Override\n+\t\tpublic int readData(InputStream stream, ChannelStateByteBuffer buffer, int bytes) {\n+\t\t\tfailed = true;\n+\t\t\tthrow new TestException();\n+\t\t}\n+\t}\n+\n+\tprivate static FSDataInputStream geStream(ChannelStateSerializer serializer, int size) throws IOException {", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNDAwNw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494334007", "bodyText": "I haven't understood the control flow here. Is this line really executed? Did you want to put it into finally?", "author": "AHeise", "createdAt": "2020-09-24T13:48:38Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateChunkReaderTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.core.memory.MemorySegmentFactory;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;\n+\n+import org.junit.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkState;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * {@link ChannelStateChunkReader} test.\n+ */\n+public class ChannelStateChunkReaderTest {\n+\n+\t@Test(expected = TestException.class)\n+\tpublic void testBufferRecycledOnFailure() throws IOException {\n+\t\tFailingChannelStateSerializer serializer = new FailingChannelStateSerializer();\n+\t\tTestRecoveredChannelStateHandler handler = new TestRecoveredChannelStateHandler();\n+\n+\t\ttry (FSDataInputStream stream = geStream(serializer, 10)) {\n+\t\t\tnew ChannelStateChunkReader(serializer).readChunk(stream, serializer.getHeaderLength(), handler, \"channelInfo\");\n+\t\t\tcheckState(serializer.failed);", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA5ODk0NQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495098945", "bodyText": "Yes, these checkStates should be in finally. Thanks!", "author": "rkhachatryan", "createdAt": "2020-09-25T16:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNDAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNjQzNQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494336435", "bodyText": "nit: empty line. (Could you check in all classes?)", "author": "AHeise", "createdAt": "2020-09-24T13:51:22Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateChunkReaderTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.fs.FSDataInputStream;\n+import org.apache.flink.core.memory.MemorySegmentFactory;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;\n+\n+import org.junit.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkState;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * {@link ChannelStateChunkReader} test.\n+ */\n+public class ChannelStateChunkReaderTest {\n+\n+\t@Test(expected = TestException.class)\n+\tpublic void testBufferRecycledOnFailure() throws IOException {\n+\t\tFailingChannelStateSerializer serializer = new FailingChannelStateSerializer();\n+\t\tTestRecoveredChannelStateHandler handler = new TestRecoveredChannelStateHandler();\n+\n+\t\ttry (FSDataInputStream stream = geStream(serializer, 10)) {\n+\t\t\tnew ChannelStateChunkReader(serializer).readChunk(stream, serializer.getHeaderLength(), handler, \"channelInfo\");\n+\t\t\tcheckState(serializer.failed);\n+\t\t\tcheckState(!handler.requestedBuffers.isEmpty());\n+\t\t} finally {\n+\t\t\tassertTrue(handler.requestedBuffers.stream().allMatch(TestChannelStateByteBuffer::isRecycled));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testBuffersNotRequestedForEmptyStream() throws IOException {\n+\t\tChannelStateSerializer serializer = new ChannelStateSerializerImpl();\n+\t\tTestRecoveredChannelStateHandler handler = new TestRecoveredChannelStateHandler();\n+\n+\t\ttry (FSDataInputStream stream = geStream(serializer, 0)) {\n+\t\t\tnew ChannelStateChunkReader(serializer).readChunk(stream, serializer.getHeaderLength(), handler, \"channelInfo\");\n+\t\t} finally {\n+\t\t\tassertTrue(handler.requestedBuffers.isEmpty());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNoSeekUnnecessarily() throws IOException {\n+\t\tfinal int offset = 123;\n+\t\tfinal FSDataInputStream stream = new FSDataInputStream() {\n+\t\t\t@Override\n+\t\t\tpublic long getPos() {\n+\t\t\t\treturn offset;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void seek(long ignored) {\n+\t\t\t\tfail();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic int read() {\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t};\n+\n+\t\tnew ChannelStateChunkReader(new ChannelStateSerializerImpl())\n+\t\t\t.readChunk(stream, offset, new TestRecoveredChannelStateHandler(), \"channelInfo\");\n+\t}\n+\n+\tprivate static class TestRecoveredChannelStateHandler implements RecoveredChannelStateHandler<Object, Object> {\n+\t\tprivate final List<TestChannelStateByteBuffer> requestedBuffers = new ArrayList<>();\n+\n+\t\t@Override\n+\t\tpublic Tuple2<ChannelStateByteBuffer, Object> getBuffer(Object o) {\n+\t\t\tTestChannelStateByteBuffer buffer = new TestChannelStateByteBuffer();\n+\t\t\trequestedBuffers.add(buffer);\n+\t\t\treturn Tuple2.of(buffer, null);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void recover(Object o, Object o2) {\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void close() throws Exception {\n+\t\t}\n+", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwMTEyMg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495101122", "bodyText": "Do you mean double newline between two }?\nWhy is it a problem?\nIt's very convenient for me to select it using vim select block :)", "author": "rkhachatryan", "createdAt": "2020-09-25T16:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNjQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU3NDQ2Mw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496574463", "bodyText": "When looking at formatting, I usually just look for consistency and there are a few classes with this extra new line and many without. But which way is better is probably not worth debating ;).", "author": "AHeise", "createdAt": "2020-09-29T09:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNjQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2MzE2NQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496663165", "bodyText": "Removed newline.", "author": "rkhachatryan", "createdAt": "2020-09-29T12:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzNjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzODMxNg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494338316", "bodyText": "Please check format string.", "author": "AHeise", "createdAt": "2020-09-24T13:53:41Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImplTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.memory.MemorySegmentFactory;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;\n+import org.apache.flink.runtime.io.network.partition.ResultPartition;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionBuilder;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGateBuilder;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.runtime.state.InputChannelStateHandle;\n+import org.apache.flink.runtime.state.ResultSubpartitionStateHandle;\n+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;\n+import org.apache.flink.util.function.ThrowingConsumer;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.IntStream.range;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * {@link SequentialChannelStateReaderImpl} Test.\n+ */\n+@RunWith(Parameterized.class)\n+public class SequentialChannelStateReaderImplTest {\n+\n+\t@Parameterized.Parameters(name = \"{0}: stateParLevel={1}, statePartsPerChannel={1}, stateBytesPerPart={2},  parLevel={4}, bufferSize={5}\")", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzOTU2Ng==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494339566", "bodyText": "nit: Can we use ThreadLocalRandom here? It's just a test, but it would be nice to use it everywhere it's possible.", "author": "AHeise", "createdAt": "2020-09-24T13:55:16Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImplTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.memory.MemorySegmentFactory;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;\n+import org.apache.flink.runtime.io.network.partition.ResultPartition;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionBuilder;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGateBuilder;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.runtime.state.InputChannelStateHandle;\n+import org.apache.flink.runtime.state.ResultSubpartitionStateHandle;\n+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;\n+import org.apache.flink.util.function.ThrowingConsumer;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.IntStream.range;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * {@link SequentialChannelStateReaderImpl} Test.\n+ */\n+@RunWith(Parameterized.class)\n+public class SequentialChannelStateReaderImplTest {\n+\n+\t@Parameterized.Parameters(name = \"{0}: stateParLevel={1}, statePartsPerChannel={1}, stateBytesPerPart={2},  parLevel={4}, bufferSize={5}\")\n+\tpublic static Object[][] parameters() {\n+\t\treturn new Object[][]{\n+\t\t\t{\"NoStateAndNoChannels\", 0, 0, 0, 0, 0},\n+\t\t\t{\"NoState\", 0, 10, 10, 10, 10},\n+\t\t\t{\"ReadPermutedStateWithEqualBuffer\", 10, 10, 10, 10, 10},\n+\t\t\t{\"ReadPermutedStateWithReducedBuffer\", 10, 10, 10, 20, 10},\n+\t\t\t{\"ReadPermutedStateWithIncreasedBuffer\", 10, 10, 10, 10, 20},\n+\t\t};\n+\t}\n+\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final Random random;", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwNzQwNA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495107404", "bodyText": "I think this wouldn't give performance benefit as tests are currently run sequentially.\nAnd even if run in parallel, a new class instance would be created for each test, so threads wouldn't share Random instance.", "author": "rkhachatryan", "createdAt": "2020-09-25T16:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzOTU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU3ODE4OA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496578188", "bodyText": "The issue is rather that Random is always strictly slower than ThreadLocalRandom because of lock acquisitions. However, you are right, as long as we not using multiple threads, we do not have contention, so the difference is marginal.", "author": "AHeise", "createdAt": "2020-09-29T09:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzOTU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2MDY2MA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496660660", "bodyText": "Random is always strictly slower than ThreadLocalRandom\n\nnextBytes  used in this test is not overridden in ThreadLocalRandom so it's the same.\nAnd the creation of Random seems cheaper than ThreadLocalRandom.\nSo it would be slower in the end.", "author": "rkhachatryan", "createdAt": "2020-09-29T12:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMzOTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0MDkyMQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494340921", "bodyText": "Could you please extract a function with meaningful name of the lowest level?", "author": "AHeise", "createdAt": "2020-09-24T13:56:56Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImplTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.memory.MemorySegmentFactory;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;\n+import org.apache.flink.runtime.io.network.partition.ResultPartition;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionBuilder;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGateBuilder;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.runtime.state.InputChannelStateHandle;\n+import org.apache.flink.runtime.state.ResultSubpartitionStateHandle;\n+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;\n+import org.apache.flink.util.function.ThrowingConsumer;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.IntStream.range;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * {@link SequentialChannelStateReaderImpl} Test.\n+ */\n+@RunWith(Parameterized.class)\n+public class SequentialChannelStateReaderImplTest {\n+\n+\t@Parameterized.Parameters(name = \"{0}: stateParLevel={1}, statePartsPerChannel={1}, stateBytesPerPart={2},  parLevel={4}, bufferSize={5}\")\n+\tpublic static Object[][] parameters() {\n+\t\treturn new Object[][]{\n+\t\t\t{\"NoStateAndNoChannels\", 0, 0, 0, 0, 0},\n+\t\t\t{\"NoState\", 0, 10, 10, 10, 10},\n+\t\t\t{\"ReadPermutedStateWithEqualBuffer\", 10, 10, 10, 10, 10},\n+\t\t\t{\"ReadPermutedStateWithReducedBuffer\", 10, 10, 10, 20, 10},\n+\t\t\t{\"ReadPermutedStateWithIncreasedBuffer\", 10, 10, 10, 10, 20},\n+\t\t};\n+\t}\n+\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final Random random;\n+\tprivate final int parLevel;\n+\tprivate final int statePartsPerChannel;\n+\tprivate final int stateBytesPerPart;\n+\tprivate final int bufferSize;\n+\tprivate final int stateParLevel;\n+\tprivate final boolean expectToHaveState;\n+\tprivate final int buffersPerChannel;\n+\n+\tpublic SequentialChannelStateReaderImplTest(String desc, int stateParLevel, int statePartsPerChannel, int stateBytesPerPart, int parLevel, int bufferSize) {\n+\t\tthis.serializer = new ChannelStateSerializerImpl();\n+\t\tthis.random = new Random();\n+\t\tthis.parLevel = parLevel;\n+\t\tthis.statePartsPerChannel = statePartsPerChannel;\n+\t\tthis.stateBytesPerPart = stateBytesPerPart;\n+\t\tthis.bufferSize = bufferSize;\n+\t\tthis.stateParLevel = stateParLevel;\n+\t\tthis.expectToHaveState = stateParLevel * statePartsPerChannel * stateBytesPerPart > 0;\n+\t\t// will read without waiting for consumption\n+\t\tthis.buffersPerChannel = Math.max(1, statePartsPerChannel * (bufferSize >= stateBytesPerPart ? 1 : stateBytesPerPart / bufferSize));\n+\t}\n+\n+\t@Test\n+\tpublic void testReadPermutedState() throws Exception {\n+\t\tMap<InputChannelInfo, List<byte[]>> inputChannelsData = generateState(InputChannelInfo::new);\n+\t\tMap<ResultSubpartitionInfo, List<byte[]>> resultPartitionsData = generateState(ResultSubpartitionInfo::new);\n+\n+\t\tSequentialChannelStateReader reader = new SequentialChannelStateReaderImpl(buildSnapshot(writePermuted(inputChannelsData, resultPartitionsData)));\n+\t\tassertEquals(expectToHaveState, reader.hasChannelStates());\n+\n+\t\twithResultPartitions(resultPartitions -> {\n+\t\t\treader.readOutputData(resultPartitions);\n+\t\t\tassertBuffersEquals(resultPartitionsData, collectBuffers(resultPartitions));\n+\t\t});\n+\n+\t\twithInputGates(gates -> {\n+\t\t\treader.readInputData(gates);\n+\t\t\tassertBuffersEquals(inputChannelsData, collectBuffers(gates));\n+\t\t\tassertConsumed(gates);\n+\t\t});\n+\t}\n+\n+\tprivate Map<ResultSubpartitionInfo, List<Buffer>> collectBuffers(ResultPartition[] resultPartitions) throws IOException {\n+\t\tMap<ResultSubpartitionInfo, List<Buffer>> actual = new HashMap<>();\n+\t\tfor (ResultPartition resultPartition : resultPartitions) {\n+\t\t\tfor (int i = 0; i < resultPartition.getNumberOfSubpartitions(); i++) {\n+\t\t\t\tResultSubpartitionInfo info = resultPartition.getSubpartitionInfo(i);\n+\t\t\t\tResultSubpartitionView view = resultPartition.createSubpartitionView(info.getSubPartitionIdx(), () -> { /**/ });\n+\t\t\t\tfor (BufferAndBacklog buffer = view.getNextBuffer(); buffer != null; buffer = view.getNextBuffer()) {\n+\t\t\t\t\tactual.computeIfAbsent(info, unused -> new ArrayList<>()).add(buffer.buffer());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn actual;\n+\t}\n+\n+\tprivate Map<InputChannelInfo, List<Buffer>> collectBuffers(InputGate[] gates) throws Exception {\n+\t\tMap<InputChannelInfo, List<Buffer>> actual = new HashMap<>();\n+\t\tfor (InputGate gate : gates) {\n+\t\t\tfor (Optional<BufferOrEvent> next = gate.pollNext(); next.isPresent(); next = gate.pollNext()) {\n+\t\t\t\tactual.computeIfAbsent(\n+\t\t\t\t\tnext.get().getChannelInfo(),\n+\t\t\t\t\tunused -> new ArrayList<>()).add(next.get().getBuffer());\n+\t\t\t}\n+\t\t}\n+\t\treturn actual;\n+\t}\n+\n+\tprivate void assertConsumed(InputGate[] gates) throws InterruptedException, java.util.concurrent.ExecutionException {\n+\t\tfor (InputGate gate: gates) {\n+\t\t\tassertTrue(gate.getStateConsumedFuture().isDone());\n+\t\t\tgate.getStateConsumedFuture().get();\n+\t\t}\n+\t}\n+\n+\tprivate void withInputGates(ThrowingConsumer<InputGate[], Exception> action) throws Exception {\n+\t\tSingleInputGate[] gates = new SingleInputGate[parLevel];\n+\t\tfinal int segmentsToAllocate = parLevel * parLevel * buffersPerChannel;\n+\t\tNetworkBufferPool networkBufferPool = new NetworkBufferPool(segmentsToAllocate, bufferSize);\n+\t\ttry {\n+\t\t\tfor (int i = 0; i < parLevel; i++) {\n+\t\t\t\tgates[i] = new SingleInputGateBuilder()\n+\t\t\t\t\t.setNumberOfChannels(parLevel)\n+\t\t\t\t\t.setSingleInputGateIndex(i)\n+\t\t\t\t\t.setBufferPoolFactory(networkBufferPool.createBufferPool(0, buffersPerChannel))\n+\t\t\t\t\t.setSegmentProvider(networkBufferPool)\n+\t\t\t\t\t.setChannelFactory((builder, gate) -> builder\n+\t\t\t\t\t.setNetworkBuffersPerChannel(buffersPerChannel)\n+\t\t\t\t\t.buildRemoteRecoveredChannel(gate))\n+\t\t\t\t\t.build();\n+\t\t\t\tgates[i].setup();\n+\t\t\t}\n+\t\t\taction.accept(gates);\n+\t\t} finally {\n+\t\t\tfor (InputGate inputGate: gates) {\n+\t\t\t\tinputGate.close();\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tassertEquals(segmentsToAllocate, networkBufferPool.getNumberOfAvailableMemorySegments());\n+\t\t\t} finally {\n+\t\t\t\tnetworkBufferPool.destroyAllBufferPools();\n+\t\t\t\tnetworkBufferPool.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void withResultPartitions(ThrowingConsumer<ResultPartition[], Exception> action) throws Exception {\n+\t\tint segmentsToAllocate = parLevel * parLevel * buffersPerChannel;\n+\t\tNetworkBufferPool networkBufferPool = new NetworkBufferPool(segmentsToAllocate, bufferSize);\n+\t\tResultPartition[] resultPartitions = range(0, parLevel)\n+\t\t\t.mapToObj(i -> new ResultPartitionBuilder().setResultPartitionIndex(i).setNumberOfSubpartitions(parLevel).setNetworkBufferPool(networkBufferPool).build())\n+\t\t\t.toArray(ResultPartition[]::new);\n+\t\ttry {\n+\t\t\tfor (ResultPartition resultPartition: resultPartitions) {\n+\t\t\t\tresultPartition.setup();\n+\t\t\t}\n+\t\t\taction.accept(resultPartitions);\n+\t\t} finally {\n+\t\t\tfor (ResultPartition resultPartition: resultPartitions) {\n+\t\t\t\tresultPartition.close();\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tassertEquals(segmentsToAllocate, networkBufferPool.getNumberOfAvailableMemorySegments());\n+\t\t\t} finally {\n+\t\t\t\tnetworkBufferPool.destroyAllBufferPools();\n+\t\t\t\tnetworkBufferPool.destroy();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate TaskStateSnapshot buildSnapshot(Tuple2<List<InputChannelStateHandle>, List<ResultSubpartitionStateHandle>> handles) {\n+\t\treturn new TaskStateSnapshot(\n+\t\t\tCollections.singletonMap(new OperatorID(), new OperatorSubtaskState(\n+\t\t\t\tStateObjectCollection.empty(),\n+\t\t\t\tStateObjectCollection.empty(),\n+\t\t\t\tStateObjectCollection.empty(),\n+\t\t\t\tStateObjectCollection.empty(),\n+\t\t\t\tnew StateObjectCollection<>(handles.f0),\n+\t\t\t\tnew StateObjectCollection<>(handles.f1)\n+\t\t\t))\n+\t\t);\n+\t}\n+\n+\tprivate <T> Map<T, List<byte[]>> generateState(BiFunction<Integer, Integer, T> descriptorCreator) {\n+\t\treturn range(0, stateParLevel).boxed().flatMap(\n+\t\t\tgateId -> range(0, stateParLevel).mapToObj(\n+\t\t\t\tchannelId ->\n+\t\t\t\t\tdescriptorCreator.apply(gateId, channelId))).collect(toMap(", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExMjY4MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495112681", "bodyText": "Good idea.\nI'll extract generateSingleChannelState method.", "author": "rkhachatryan", "createdAt": "2020-09-25T16:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0MDkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0MzY4MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494343681", "bodyText": "NoOpBufferAvailablityListener if we ever add a new mandatory method.", "author": "AHeise", "createdAt": "2020-09-24T13:59:48Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/SequentialChannelStateReaderImplTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.checkpoint.channel;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.core.memory.MemorySegmentFactory;\n+import org.apache.flink.runtime.checkpoint.OperatorSubtaskState;\n+import org.apache.flink.runtime.checkpoint.StateObjectCollection;\n+import org.apache.flink.runtime.checkpoint.TaskStateSnapshot;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.FreeingBufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;\n+import org.apache.flink.runtime.io.network.partition.ResultPartition;\n+import org.apache.flink.runtime.io.network.partition.ResultPartitionBuilder;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartition.BufferAndBacklog;\n+import org.apache.flink.runtime.io.network.partition.ResultSubpartitionView;\n+import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;\n+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGate;\n+import org.apache.flink.runtime.io.network.partition.consumer.SingleInputGateBuilder;\n+import org.apache.flink.runtime.jobgraph.OperatorID;\n+import org.apache.flink.runtime.state.InputChannelStateHandle;\n+import org.apache.flink.runtime.state.ResultSubpartitionStateHandle;\n+import org.apache.flink.runtime.state.memory.ByteStreamStateHandle;\n+import org.apache.flink.util.function.ThrowingConsumer;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.IntStream.range;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * {@link SequentialChannelStateReaderImpl} Test.\n+ */\n+@RunWith(Parameterized.class)\n+public class SequentialChannelStateReaderImplTest {\n+\n+\t@Parameterized.Parameters(name = \"{0}: stateParLevel={1}, statePartsPerChannel={1}, stateBytesPerPart={2},  parLevel={4}, bufferSize={5}\")\n+\tpublic static Object[][] parameters() {\n+\t\treturn new Object[][]{\n+\t\t\t{\"NoStateAndNoChannels\", 0, 0, 0, 0, 0},\n+\t\t\t{\"NoState\", 0, 10, 10, 10, 10},\n+\t\t\t{\"ReadPermutedStateWithEqualBuffer\", 10, 10, 10, 10, 10},\n+\t\t\t{\"ReadPermutedStateWithReducedBuffer\", 10, 10, 10, 20, 10},\n+\t\t\t{\"ReadPermutedStateWithIncreasedBuffer\", 10, 10, 10, 10, 20},\n+\t\t};\n+\t}\n+\n+\tprivate final ChannelStateSerializer serializer;\n+\tprivate final Random random;\n+\tprivate final int parLevel;\n+\tprivate final int statePartsPerChannel;\n+\tprivate final int stateBytesPerPart;\n+\tprivate final int bufferSize;\n+\tprivate final int stateParLevel;\n+\tprivate final boolean expectToHaveState;\n+\tprivate final int buffersPerChannel;\n+\n+\tpublic SequentialChannelStateReaderImplTest(String desc, int stateParLevel, int statePartsPerChannel, int stateBytesPerPart, int parLevel, int bufferSize) {\n+\t\tthis.serializer = new ChannelStateSerializerImpl();\n+\t\tthis.random = new Random();\n+\t\tthis.parLevel = parLevel;\n+\t\tthis.statePartsPerChannel = statePartsPerChannel;\n+\t\tthis.stateBytesPerPart = stateBytesPerPart;\n+\t\tthis.bufferSize = bufferSize;\n+\t\tthis.stateParLevel = stateParLevel;\n+\t\tthis.expectToHaveState = stateParLevel * statePartsPerChannel * stateBytesPerPart > 0;\n+\t\t// will read without waiting for consumption\n+\t\tthis.buffersPerChannel = Math.max(1, statePartsPerChannel * (bufferSize >= stateBytesPerPart ? 1 : stateBytesPerPart / bufferSize));\n+\t}\n+\n+\t@Test\n+\tpublic void testReadPermutedState() throws Exception {\n+\t\tMap<InputChannelInfo, List<byte[]>> inputChannelsData = generateState(InputChannelInfo::new);\n+\t\tMap<ResultSubpartitionInfo, List<byte[]>> resultPartitionsData = generateState(ResultSubpartitionInfo::new);\n+\n+\t\tSequentialChannelStateReader reader = new SequentialChannelStateReaderImpl(buildSnapshot(writePermuted(inputChannelsData, resultPartitionsData)));\n+\t\tassertEquals(expectToHaveState, reader.hasChannelStates());\n+\n+\t\twithResultPartitions(resultPartitions -> {\n+\t\t\treader.readOutputData(resultPartitions);\n+\t\t\tassertBuffersEquals(resultPartitionsData, collectBuffers(resultPartitions));\n+\t\t});\n+\n+\t\twithInputGates(gates -> {\n+\t\t\treader.readInputData(gates);\n+\t\t\tassertBuffersEquals(inputChannelsData, collectBuffers(gates));\n+\t\t\tassertConsumed(gates);\n+\t\t});\n+\t}\n+\n+\tprivate Map<ResultSubpartitionInfo, List<Buffer>> collectBuffers(ResultPartition[] resultPartitions) throws IOException {\n+\t\tMap<ResultSubpartitionInfo, List<Buffer>> actual = new HashMap<>();\n+\t\tfor (ResultPartition resultPartition : resultPartitions) {\n+\t\t\tfor (int i = 0; i < resultPartition.getNumberOfSubpartitions(); i++) {\n+\t\t\t\tResultSubpartitionInfo info = resultPartition.getSubpartitionInfo(i);\n+\t\t\t\tResultSubpartitionView view = resultPartition.createSubpartitionView(info.getSubPartitionIdx(), () -> { /**/ });", "originalCommit": "b018aaeb6eeeccfd5f1d0a0c3fa142f8a25f3e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0NzA3MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494347071", "bodyText": "Okay you just did what I wrote on the last commit. Probably squashing makes sense.", "author": "AHeise", "createdAt": "2020-09-24T14:04:10Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -504,23 +502,18 @@ protected void beforeInvoke() throws Exception {\n \n \tprivate void readRecoveredChannelState() throws IOException, InterruptedException {\n \t\tSequentialChannelStateReader reader = getEnvironment().getTaskStateManager().getSequentialChannelStateReader();\n-\t\tif (reader.hasChannelStates()) {\n-\t\t\treader.readOutputData(getEnvironment().getAllWriters());\n-\t\t\tchannelIOExecutor.execute(() -> {\n-\t\t\t\ttry {\n-\t\t\t\t\treader.readInputData(getEnvironment().getAllInputGates());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tasyncExceptionHandler.handleAsyncException(\"Unable to read channel state\", e);\n-\t\t\t\t}\n-\t\t\t});\n-\n-\t\t\tfor (InputGate inputGate : getEnvironment().getAllInputGates()) {\n-\t\t\t\tinputGate\n-\t\t\t\t\t.getStateConsumedFuture()\n-\t\t\t\t\t.thenRun(() -> mainMailboxExecutor.execute(inputGate::requestPartitions, \"Input gate request partitions\"));\n+\t\treader.readOutputData(getEnvironment().getAllWriters());\n+\t\tchannelIOExecutor.execute(() -> {\n+\t\t\ttry {\n+\t\t\t\treader.readInputData(getEnvironment().getAllInputGates());\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tasyncExceptionHandler.handleAsyncException(\"Unable to read channel state\", e);\n \t\t\t}\n-\t\t} else {\n-\t\t\trequestPartitions();\n+\t\t});\n+\t\tfor (InputGate inputGate : getEnvironment().getAllInputGates()) {", "originalCommit": "4913b2f902918470bd20236df46d60c84d97293d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0NzQwOQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494347409", "bodyText": "nit: typo in commit message.", "author": "AHeise", "createdAt": "2020-09-24T14:04:37Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractRecordReader.java", "diffHunk": "@@ -45,6 +45,8 @@\n \n \tprivate RecordDeserializer<T> currentRecordDeserializer;\n \n+\tprivate boolean finishedStateReading;", "originalCommit": "6ef9ee7deb0111ea4d1e113f9258d89a1c5b336e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0ODcxOQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494348719", "bodyText": "protected?", "author": "AHeise", "createdAt": "2020-09-24T14:06:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java", "diffHunk": "@@ -77,13 +78,18 @@\n \t\tbufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n \t}\n \n+\tpublic final InputChannel toInputChannel() throws IOException {\n+\t\tPreconditions.checkState(stateConsumedFuture.isDone(), \"recovered state is not fully consumed\");\n+\t\treturn toInputChannelInternal();\n+\t}\n+\n \t@Override\n \tpublic void setChannelStateWriter(ChannelStateWriter channelStateWriter) {\n \t\tcheckState(this.channelStateWriter == null, \"Already initialized\");\n \t\tthis.channelStateWriter = checkNotNull(channelStateWriter);\n \t}\n \n-\tpublic abstract InputChannel toInputChannel() throws IOException;\n+\tpublic abstract InputChannel toInputChannelInternal() throws IOException;", "originalCommit": "6ef9ee7deb0111ea4d1e113f9258d89a1c5b336e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExNDYzNg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495114636", "bodyText": "Yes :)", "author": "rkhachatryan", "createdAt": "2020-09-25T16:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0ODcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MDk4Ng==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494350986", "bodyText": "Okay, now I see that you removed the original ChannelStateReader. I'd probably state that in the commit that adds SeqReader.", "author": "AHeise", "createdAt": "2020-09-24T14:09:34Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializerImplTest.java", "diffHunk": "@@ -36,7 +36,6 @@\n import java.util.Random;\n \n import static org.apache.flink.runtime.checkpoint.channel.ChannelStateByteBuffer.wrap;", "originalCommit": "4a598b96aa0250255f8758ce4ce57df23072dac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExNTIzOQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495115239", "bodyText": "Done.", "author": "rkhachatryan", "createdAt": "2020-09-25T16:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MDk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MTIwMg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494351202", "bodyText": "What's that change about?", "author": "AHeise", "createdAt": "2020-09-24T14:09:50Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/checkpoint/channel/ChannelStateSerializerImplTest.java", "diffHunk": "@@ -146,4 +145,10 @@ private void readAndCheck(byte[] data, ChannelStateSerializerImpl serializer, By\n \t\t}\n \t}\n \n+\tstatic byte[] generateData(int len) {", "originalCommit": "4a598b96aa0250255f8758ce4ce57df23072dac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwNTA4MA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494805080", "bodyText": "Previously, this method was imported from ChannelStateReaderImplTest.\nIn this commit ChannelStateReaderImplTest was removed and generateData moved to this class.", "author": "rkhachatryan", "createdAt": "2020-09-25T07:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MTUyMw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r494351523", "bodyText": "It looks like some cleanup is needed here.", "author": "AHeise", "createdAt": "2020-09-24T14:10:14Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/state/ChannelPersistenceITCase.java", "diffHunk": "@@ -76,17 +67,17 @@ public void testReadWritten() throws Exception {\n \t\t\tsingletonMap(resultSubpartitionInfo, resultSubpartitionInfoData)\n \t\t);\n \n-\t\tassertArrayEquals(inputChannelInfoData, read(", "originalCommit": "4a598b96aa0250255f8758ce4ce57df23072dac7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTExNTA1Mw==", "url": "https://github.com/apache/flink/pull/13351#discussion_r495115053", "bodyText": "Right, forgot about this test :)", "author": "rkhachatryan", "createdAt": "2020-09-25T16:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM1MTUyMw=="}], "type": "inlineReview"}, {"oid": "859b19e0af50e8188addfa7ce42179b25c806c80", "url": "https://github.com/apache/flink/commit/859b19e0af50e8188addfa7ce42179b25c806c80", "message": "[FLINK-18989][task] Address review feedback", "committedDate": "2020-09-25T18:05:58Z", "type": "forcePushed"}, {"oid": "d5de65d33ae7216bee7ae8d55bf20839584c520f", "url": "https://github.com/apache/flink/commit/d5de65d33ae7216bee7ae8d55bf20839584c520f", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-28T14:09:48Z", "type": "forcePushed"}, {"oid": "ce1ddf0120e722f172916745adac6c4829cbae29", "url": "https://github.com/apache/flink/commit/ce1ddf0120e722f172916745adac6c4829cbae29", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-29T06:46:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ2MTY5OA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496461698", "bodyText": "@pnowojski,\nthis test started to fail after rebasing of Read channel state unconditionally.\nSo I replaced processSingleStep with processAll.\nPlease take a look.", "author": "rkhachatryan", "createdAt": "2020-09-29T07:02:04Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMultipleInputSelectiveReadingTest.java", "diffHunk": "@@ -197,22 +198,21 @@ public void testInputStarvation() throws Exception {\n \t\t\ttestHarness.processElement(new StreamRecord<>(\"3\"), 1);\n \t\t\ttestHarness.processElement(new StreamRecord<>(\"4\"), 1);\n \n-\t\t\ttestHarness.processSingleStep();\n \t\t\texpectedOutput.add(new StreamRecord<>(\"[2]: 1\"));\n-\t\t\ttestHarness.processSingleStep();\n \t\t\texpectedOutput.add(new StreamRecord<>(\"[2]: 2\"));\n-\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\t\t\ttestHarness.processAll();\n+\t\t\tassertEquals(expectedOutput, new ArrayList<>(testHarness.getOutput()).subList(0, expectedOutput.size()));", "originalCommit": "ce1ddf0120e722f172916745adac6c4829cbae29", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMTg4MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r499521881", "bodyText": "This test is now not doing what it was intended.\nNow you are processing all elements from the input gate 1 before testHarness.processElement(new StreamRecord<>(\"1\"), 2); (L207/206) is being enqueued to input gate 2.\nI would guess that\n// to avoid starvation, if the input selection is ALL and availableInputsMask is not ALL,\n// always try to check and set the availability of another input\nif (inputSelectionHandler.shouldSetAvailableForAnotherInput()) {\n\tfullCheckAndSetAvailable();\n}\n\ncheck from StreamMultipleInputProcessor#selectNextReadingInputIndex is currently not tested.\nThe intention behind this test is:\n\nto have a long (just as well could be infinite) backlog of records to process on one of the inputs\nintroduce the availability change on the second input, and make sure it's checked/respected (instead of hot looping on the first input)\nalso throw in a third not selected input just to spice things a little bit\n\nWhy did you have to change this test?", "author": "pnowojski", "createdAt": "2020-10-05T11:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ2MTY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NDU1MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r499694551", "bodyText": "Thanks for the explanation.\nThe problem was that the output didn't match the expected one. The reason was that requesting partitions now also requires a mailbox step.\nAfter your comment I replaced the fix with:\nfor (int i = 0; i < testHarness.inputGates.length; i++) {\n\ttestHarness.processSingleStep();\n}\n\nDoes it look good to you?", "author": "rkhachatryan", "createdAt": "2020-10-05T15:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ2MTY5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDQ5NA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r499760494", "bodyText": "Hmmm, maybe replace it with more future proof condition? sth like:\nboolean noElementFromInputGate3 = true;\nsteps = 0;\nwhile (noElementFromInputGate3 && steps++ < 100 && testHarness.procesSingleStep()) {\n  noElementFromInputGate3 = ... // check for presence of `new StreamRecord<>(\"[3]: 1\"))`\n}\n\n?\nOr maybe #13351 (comment) ?", "author": "pnowojski", "createdAt": "2020-10-05T17:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ2MTY5OA=="}], "type": "inlineReview"}, {"oid": "f19eaa5205bc3ee57e8563eabe992b7377e6bd25", "url": "https://github.com/apache/flink/commit/f19eaa5205bc3ee57e8563eabe992b7377e6bd25", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-29T07:04:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU3MTg5Mg==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496571892", "bodyText": "An alternative way to propagate the exception would be:\n\t\t\t\ttaskInvocation.exceptionally(e -> {\n\t\t\t\t\tthrow new AssertionError(\"Task has stopped\", e);\n\t\t\t\t});\n\nIt depends if you want the test to fail through assertions or through unexpected exception.", "author": "AHeise", "createdAt": "2020-09-29T09:26:06Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/util/StreamTaskUtil.java", "diffHunk": "@@ -29,9 +30,10 @@\n  */\n public class StreamTaskUtil {\n \n-\tpublic static void waitTaskIsRunning(StreamTask<?, ?> task, CompletableFuture<Void> taskInvocation) throws InterruptedException {\n+\tpublic static void waitTaskIsRunning(StreamTask<?, ?> task, CompletableFuture<Void> taskInvocation) throws InterruptedException, ExecutionException {\n \t\twhile (!task.isRunning()) {\n \t\t\tif (taskInvocation.isDone()) {\n+\t\t\t\ttaskInvocation.get();", "originalCommit": "0f5f4780b86654a878548a7f69b9474e7e3f3618", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY2MjA0MQ==", "url": "https://github.com/apache/flink/pull/13351#discussion_r496662041", "bodyText": "I'd prefer not to wrap it as it's more straightforward to me both in code and in the logs.", "author": "rkhachatryan", "createdAt": "2020-09-29T12:05:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjU3MTg5Mg=="}], "type": "inlineReview"}, {"oid": "78668b9ada20adf13fc33cba2e9fd12874b47115", "url": "https://github.com/apache/flink/commit/78668b9ada20adf13fc33cba2e9fd12874b47115", "message": "[FLINK-18989][task] Remove ChannelStateReader", "committedDate": "2020-09-29T11:51:29Z", "type": "forcePushed"}, {"oid": "e8c03361de3a583a8da862bcf3839de214c5cb83", "url": "https://github.com/apache/flink/commit/e8c03361de3a583a8da862bcf3839de214c5cb83", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-05T15:35:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MjAxNA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r499762014", "bodyText": "Would it work if replaced with testHarness.processAll ?", "author": "pnowojski", "createdAt": "2020-10-05T17:34:27Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskMultipleInputSelectiveReadingTest.java", "diffHunk": "@@ -183,6 +183,9 @@ public void testInputStarvation() throws Exception {\n \t\t\t\t\t.setupOutputForSingletonOperatorChain(new TestInputStarvationMultipleInputOperatorFactory())\n \t\t\t\t\t.build()) {\n \n+\t\t\tfor (int i = 0; i < testHarness.inputGates.length; i++) {\n+\t\t\t\ttestHarness.processSingleStep();\n+\t\t\t}", "originalCommit": "e8c03361de3a583a8da862bcf3839de214c5cb83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMzIyNA==", "url": "https://github.com/apache/flink/pull/13351#discussion_r499823224", "bodyText": "Yes! \ud83d\ude04", "author": "rkhachatryan", "createdAt": "2020-10-05T19:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MjAxNA=="}], "type": "inlineReview"}, {"oid": "3e38dfe739fa34ed301dc2c0303086568f138d57", "url": "https://github.com/apache/flink/commit/3e38dfe739fa34ed301dc2c0303086568f138d57", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-05T19:29:13Z", "type": "forcePushed"}, {"oid": "5f4afd19fde91ffe545666daffd8953b126de7bf", "url": "https://github.com/apache/flink/commit/5f4afd19fde91ffe545666daffd8953b126de7bf", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-06T15:34:43Z", "type": "forcePushed"}, {"oid": "ec6d68e0c67f14994082adb24e4f86dd599fc9f0", "url": "https://github.com/apache/flink/commit/ec6d68e0c67f14994082adb24e4f86dd599fc9f0", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-06T21:21:44Z", "type": "forcePushed"}, {"oid": "3041c4816637a7e1686723ec0e04d99db5cce14c", "url": "https://github.com/apache/flink/commit/3041c4816637a7e1686723ec0e04d99db5cce14c", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-08T11:35:15Z", "type": "forcePushed"}, {"oid": "a74023442126ad0bc056566da4616d73f98096fd", "url": "https://github.com/apache/flink/commit/a74023442126ad0bc056566da4616d73f98096fd", "message": "[hotfix][tests] Report FailureReason in StreamTask tests", "committedDate": "2020-10-08T11:38:36Z", "type": "commit"}, {"oid": "cc26964340d6a074ee695b93c9ba43b665fdb0f6", "url": "https://github.com/apache/flink/commit/cc26964340d6a074ee695b93c9ba43b665fdb0f6", "message": "[hotfix][tests] Return empty array of gates instead of null", "committedDate": "2020-10-08T11:38:36Z", "type": "commit"}, {"oid": "e574b031862fab04177e5689211b0852d9ff076a", "url": "https://github.com/apache/flink/commit/e574b031862fab04177e5689211b0852d9ff076a", "message": "[FLINK-19385] Request partitions for each inputGate independently", "committedDate": "2020-10-08T11:38:36Z", "type": "commit"}, {"oid": "e4946c0fbc1a46d866b29edff083eb4e2370e437", "url": "https://github.com/apache/flink/commit/e4946c0fbc1a46d866b29edff083eb4e2370e437", "message": "[task][refactor] Introduce InputChannel.setup\n\nThis removes casts to RemoteInputChannel and RecoveredInputChannel", "committedDate": "2020-10-08T11:38:36Z", "type": "commit"}, {"oid": "eee860a9e25bc66972d967fe1aef60746180dc7e", "url": "https://github.com/apache/flink/commit/eee860a9e25bc66972d967fe1aef60746180dc7e", "message": "[FLINK-18989][task] Read channel state sequentially\n\nNon-sequential state reader and the associated code will be removed in\nsubsequent commits.", "committedDate": "2020-10-08T11:38:36Z", "type": "commit"}, {"oid": "59ca6fe974dd7270f5b6de4880b9de845eda830f", "url": "https://github.com/apache/flink/commit/59ca6fe974dd7270f5b6de4880b9de845eda830f", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-08T11:38:36Z", "type": "forcePushed"}, {"oid": "5dd10853af3a821bdb567509a55c50280f55368a", "url": "https://github.com/apache/flink/commit/5dd10853af3a821bdb567509a55c50280f55368a", "message": "[FLINK-18989][task] Read channel state unconditionally\n\nMotivation: reduce the required test coverage (tests will be removed in\na later commit).", "committedDate": "2020-10-09T09:52:17Z", "type": "commit"}, {"oid": "7cc1374100e7e9d43d62ace88673b8eaba1a1568", "url": "https://github.com/apache/flink/commit/7cc1374100e7e9d43d62ace88673b8eaba1a1568", "message": "[FLINK-18989][task] Allow conversion of RecoveredInputChannel only after state was fully consumed\n\nMotivation:\n1. Guarantee state is not lost\n2. Reduce the required test coverage (tests will be removed in the next\ncommit)", "committedDate": "2020-10-09T09:52:39Z", "type": "commit"}, {"oid": "c0b8f40dbf063678f53fc427bcf57c4c7876f87e", "url": "https://github.com/apache/flink/commit/c0b8f40dbf063678f53fc427bcf57c4c7876f87e", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-09T09:52:39Z", "type": "commit"}, {"oid": "c0b8f40dbf063678f53fc427bcf57c4c7876f87e", "url": "https://github.com/apache/flink/commit/c0b8f40dbf063678f53fc427bcf57c4c7876f87e", "message": "[FLINK-18989][task] Remove non-sequental ChannelStateReader and the related code\n\n- ChannelStateReader and supporting classes\n- methods for channel state recovery in inputChannels, subpartitions, etc.\n- tests for reading channel state non-sequentially", "committedDate": "2020-10-09T09:52:39Z", "type": "forcePushed"}]}