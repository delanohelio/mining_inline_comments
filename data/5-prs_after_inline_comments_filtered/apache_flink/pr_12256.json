{"pr_number": 12256, "pr_title": "[FLINK-17018][runtime] Allocates slots in bulks for pipelined region scheduling", "pr_createdAt": "2020-05-19T18:47:43Z", "pr_url": "https://github.com/apache/flink/pull/12256", "timeline": [{"oid": "edab8aef00bcac9a530501fa64165f344d7c74e7", "url": "https://github.com/apache/flink/commit/edab8aef00bcac9a530501fa64165f344d7c74e7", "message": "[FLINK-17018][runtime] DefaultExecutionSlotAllocator supports bulk slot allocation", "committedDate": "2020-05-20T06:41:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4MDgxNA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429180814", "bodyText": "Method name doesn't match the field name willOccupySlotIndefinitely vs willBeOccupiedIndefinitely. Is it intentional?", "author": "GJL", "createdAt": "2020-05-22T10:57:58Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SingleLogicalSlot.java", "diffHunk": "@@ -168,6 +185,11 @@ public void release(Throwable cause) {\n \t\treleaseFuture.complete(null);\n \t}\n \n+\t@Override\n+\tpublic boolean willOccupySlotIndefinitely() {", "originalCommit": "1ccc37fca05d5a3d616af8c6eee21b741e6759f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc1MzczOA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429753738", "bodyText": "It is intentional.\nSingleLogicalSlot has 2 roles. One is logical slot and the other is physical slot payload.\nIt will occupy a physical slot indefinitely iff it will be occupied indefinitely by a task.", "author": "zhuzhurk", "createdAt": "2020-05-25T06:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4MDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODM3OQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429208379", "bodyText": "I would prefer this method (allocateSlotsFor()) to be the first in the class.", "author": "GJL", "createdAt": "2020-05-22T12:07:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -67,23 +76,211 @@\n \n \tprivate final SlotProviderStrategy slotProviderStrategy;\n \n+\tprivate final SlotOwner slotOwner;\n+\n \tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n \n+\t// temporary hack. can be removed along with the individual slot allocation code path\n+\t// once bulk slot allocation is fully functional\n+\tprivate final boolean enableBulkSlotAllocation;\n+\n \tpublic DefaultExecutionSlotAllocator(\n \t\t\tSlotProviderStrategy slotProviderStrategy,\n-\t\t\tInputsLocationsRetriever inputsLocationsRetriever) {\n+\t\t\tInputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tboolean enableBulkSlotAllocation) {\n \t\tthis.slotProviderStrategy = checkNotNull(slotProviderStrategy);\n \t\tthis.inputsLocationsRetriever = checkNotNull(inputsLocationsRetriever);\n+\t\tthis.enableBulkSlotAllocation = enableBulkSlotAllocation;\n+\n+\t\tthis.slotOwner = new DefaultExecutionSlotAllocatorSlotOwner();\n \n \t\tpendingSlotAssignments = new HashMap<>();\n \t}\n \n+\t/**\n+\t * Allocate slots in bulks. It has some limitations at the moment and is for pipelined region scheduling only.\n+\t * Slot sharing will be ignored.\n+\t * Co-location constraints are not allowed as a result.\n+\t * Intra-bulk input location preferences will be ignored.\n+\t */\n+\tprivate List<SlotExecutionVertexAssignment> allocateSlotsInBulks(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnull);\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored here\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile = schedulingRequirements.getTaskResourceProfile();\n+\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\tallPreviousAllocationIds);\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotProviderStrategy.willSlotBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProviderStrategy.allocatePhysicalSlots(physicalSlotRequests))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t\t} catch (Exception ex) {\n+\t\t\t\t\t\tthrow new CompletionException(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal PhysicalSlot physicalSlot) throws FlinkException {\n+\n+\t\tfinal SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(\n+\t\t\tslotRequestId,\n+\t\t\tphysicalSlot,\n+\t\t\tnull,\n+\t\t\tLocality.UNKNOWN,\n+\t\t\tslotOwner);\n+\n+\t\tif (physicalSlot.tryAssignPayload(singleTaskSlot)) {\n+\t\t\treturn singleTaskSlot;\n+\t\t} else {\n+\t\t\tthrow new FlinkException(\"Could not assign payload to allocated slot \" + physicalSlot.getAllocationId() + '.');\n+\t\t}\n+\t}\n+\n \t@Override\n \tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(", "originalCommit": "edab8aef00bcac9a530501fa64165f344d7c74e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3NzY2Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429777663", "bodyText": "Done with methods of OneSlotPerExecutionSlotAllocator moved out.", "author": "zhuzhurk", "createdAt": "2020-05-25T07:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNzU1Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429217557", "bodyText": "Should be final.", "author": "GJL", "createdAt": "2020-05-22T12:29:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+/**\n+ * Represents a request for a physical slot.\n+ */\n+public class PhysicalSlotRequest {\n+\n+\tprivate SlotRequestId slotRequestId;\n+\n+\tprivate SlotProfile slotProfile;\n+\n+\tprivate boolean slotWillBeOccupiedIndefinitely;\n+\n+\tpublic PhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely) {\n+\n+\t\tthis.slotRequestId = slotRequestId;\n+\t\tthis.slotProfile = slotProfile;\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t}\n+\n+\tpublic SlotRequestId getSlotRequestId() {\n+\t\treturn slotRequestId;\n+\t}\n+\n+\tpublic SlotProfile getSlotProfile() {\n+\t\treturn slotProfile;\n+\t}\n+\n+\tboolean willSlotBeOccupiedIndefinitely() {\n+\t\treturn slotWillBeOccupiedIndefinitely;\n+\t}\n+\n+\t/**\n+\t * Result of a {@link PhysicalSlotRequest}.\n+\t */\n+\tpublic static class Result {\n+\n+\t\tprivate SlotRequestId slotRequestId;", "originalCommit": "edab8aef00bcac9a530501fa64165f344d7c74e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc1ODI1OA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429758258", "bodyText": "ok.", "author": "zhuzhurk", "createdAt": "2020-05-25T06:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNzU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNzU4Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429217587", "bodyText": "Should be final.", "author": "GJL", "createdAt": "2020-05-22T12:29:53Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+/**\n+ * Represents a request for a physical slot.\n+ */\n+public class PhysicalSlotRequest {\n+\n+\tprivate SlotRequestId slotRequestId;", "originalCommit": "edab8aef00bcac9a530501fa64165f344d7c74e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc1ODA2MQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429758061", "bodyText": "ok.", "author": "zhuzhurk", "createdAt": "2020-05-25T06:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxNzU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyMzg4Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429223887", "bodyText": "Would it be possible to move the new logic to a new class (e.g., OneSlotPerExecutionSlotAllocator) that subclasses from DefaultExecutionSlotAllocator?", "author": "GJL", "createdAt": "2020-05-22T12:44:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -67,23 +76,211 @@\n \n \tprivate final SlotProviderStrategy slotProviderStrategy;\n \n+\tprivate final SlotOwner slotOwner;\n+\n \tprivate final InputsLocationsRetriever inputsLocationsRetriever;\n \n+\t// temporary hack. can be removed along with the individual slot allocation code path\n+\t// once bulk slot allocation is fully functional\n+\tprivate final boolean enableBulkSlotAllocation;", "originalCommit": "edab8aef00bcac9a530501fa64165f344d7c74e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc1NDA5Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429754093", "bodyText": "Good suggestion! Will give a try.", "author": "zhuzhurk", "createdAt": "2020-05-25T06:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyMzg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc3NzMyMg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429777322", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-05-25T07:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIyMzg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0MTIzNg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429241236", "bodyText": "What is the benefit of passing an external timestamp instead of calling clock.relativeTimeMillis() inside this method?", "author": "GJL", "createdAt": "2020-05-22T13:20:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulkTracker.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.util.clock.Clock;\n+\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Tracks physical slot request bulks.\n+ */\n+class PhysicalSlotRequestBulkTracker {\n+\n+\tprivate final Clock clock;\n+\n+\t/** Timestamps indicate when bulks become unfulfillable. */\n+\tprivate final Map<PhysicalSlotRequestBulk, Long> bulkUnfulfillableTimestamps;\n+\n+\tPhysicalSlotRequestBulkTracker(final Clock clock) {\n+\t\tthis.clock = clock;\n+\t\tthis.bulkUnfulfillableTimestamps = new IdentityHashMap<>();\n+\t}\n+\n+\tvoid track(final PhysicalSlotRequestBulk bulk) {\n+\t\t// a bulk is initially unfulfillable\n+\t\tbulkUnfulfillableTimestamps.put(bulk, clock.relativeTimeMillis());\n+\t}\n+\n+\tvoid untrack(final PhysicalSlotRequestBulk bulk) {\n+\t\tbulkUnfulfillableTimestamps.remove(bulk);\n+\t}\n+\n+\tboolean isTracked(final PhysicalSlotRequestBulk bulk) {\n+\t\treturn bulkUnfulfillableTimestamps.containsKey(bulk);\n+\t}\n+\n+\tvoid markBulkFulfillable(final PhysicalSlotRequestBulk bulk) {\n+\t\tcheckState(isTracked(bulk));\n+\n+\t\tbulkUnfulfillableTimestamps.put(bulk, Long.MAX_VALUE);\n+\t}\n+\n+\tvoid markBulkUnfulfillable(final PhysicalSlotRequestBulk bulk, final long currentTimestamp) {", "originalCommit": "edab8aef00bcac9a530501fa64165f344d7c74e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc1NTE1MA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429755150", "bodyText": "This is to reduce the invocations of System.nanoTime() and ensures the timestamp is consistent in SchedulerImpl#checkPhysicalSlotRequestBulkTimeout(...).", "author": "zhuzhurk", "createdAt": "2020-05-25T06:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI0MTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwOTgzNw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429309837", "bodyText": "private", "author": "GJL", "createdAt": "2020-05-22T15:20:35Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/PhysicalSlotRequestBulk.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a bulk of physical slot requests.\n+ */\n+public class PhysicalSlotRequestBulk {\n+\n+\tfinal Map<SlotRequestId, PhysicalSlotRequest> pendingRequests;", "originalCommit": "a2fa66e19cbba4726a27da817fdfbabd1d054cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc1ODM1MQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429758351", "bodyText": "ok.", "author": "zhuzhurk", "createdAt": "2020-05-25T06:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMwOTgzNw=="}], "type": "inlineReview"}, {"oid": "cce8477d3eae8bad8b4109fa1f85e810220b6d39", "url": "https://github.com/apache/flink/commit/cce8477d3eae8bad8b4109fa1f85e810220b6d39", "message": "Fixup! [FLINK-17018][runtime] SlotPoolImpl supports to check whether a bulk of slot requests is fulfillable", "committedDate": "2020-05-25T06:47:50Z", "type": "forcePushed"}, {"oid": "7f16b12b9c89b723a6c201da252d65e259a53c84", "url": "https://github.com/apache/flink/commit/7f16b12b9c89b723a6c201da252d65e259a53c84", "message": "Fixup! [FLINK-17018][runtime] SlotPoolImpl supports to check whether a bulk of slot requests is fulfillable", "committedDate": "2020-05-25T07:32:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTU0OA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429801548", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n          \n          \n            \n            \n          \n          \n            \n            \t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n          \n          \n            \n            \t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, false);\n          \n          \n            \n            \n          \n          \n            \n            \t\tassertFalse(physicalSlot.willBeOccupiedIndefinitely());", "author": "azagrebin", "createdAt": "2020-05-25T08:24:35Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation works correctly.\n+ */\n+public class SlotOccupationTest extends TestLogger {\n+\n+\t@Test\n+\tpublic void testSingleTaskOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());\n+\t}\n+\n+\t@Test\n+\tpublic void testSingleTaskNotOccupyingSlotIndefinitely() {\n+\t\tfinal PhysicalSlot physicalSlot = createPhysicalSlot();\n+\t\tallocateSingleLogicalSlotFromPhysicalSlot(physicalSlot, true);\n+\n+\t\tassertTrue(physicalSlot.willBeOccupiedIndefinitely());", "originalCommit": "5682f58a0f2dc3b7a460f123eb1c29cac216c415", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE5MDczOQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430190739", "bodyText": "Nice catch!", "author": "zhuzhurk", "createdAt": "2020-05-26T06:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1MzIzOQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431653239", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-05-28T08:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgwMTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTk0Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429821943", "bodyText": "Do we need to keep PhysicalSlotRequests in PhysicalSlotRequestBulk?\nIt seems we use only ids and ResourceProfile of PhysicalSlotRequest.SlotProfile.\nWould it be enough for now to keep only ResourceProfiles in PhysicalSlotRequestBulk.pendingRequests?", "author": "azagrebin", "createdAt": "2020-05-25T09:05:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -469,6 +469,47 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \t\t\t.collect(Collectors.toList());\n \t}\n \n+\t@Override\n+\tpublic boolean isSlotRequestBulkFulfillable(final PhysicalSlotRequestBulk slotRequestBulk) {\n+\t\tfinal Set<AllocationID> assignedSlots = new HashSet<>(slotRequestBulk.getFulfilledRequests().values());\n+\t\tfinal Set<SlotInfo> reusableSlots = getReusableSlots(assignedSlots);\n+\t\treturn areRequestsFulfillableWithSlots(slotRequestBulk.getPendingRequests().values(), reusableSlots);\n+\t}\n+\n+\tprivate Set<SlotInfo> getReusableSlots(final Set<AllocationID> slotsToExclude) {\n+\t\treturn Stream\n+\t\t\t.concat(\n+\t\t\t\tgetAvailableSlotsInformation().stream(),\n+\t\t\t\tgetAllocatedSlotsInformation().stream())\n+\t\t\t.filter(slotInfo -> !slotInfo.willBeOccupiedIndefinitely())\n+\t\t\t.filter(slotInfo -> !slotsToExclude.contains(slotInfo.getAllocationId()))\n+\t\t\t.collect(Collectors.toSet());\n+\t}\n+\n+\tprivate static boolean areRequestsFulfillableWithSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> requests,\n+\t\t\tfinal Set<SlotInfo> slots) {\n+\n+\t\tfinal Set<SlotInfo> remainingSlots = new HashSet<>(slots);\n+\t\tfor (PhysicalSlotRequest request : requests) {\n+\t\t\tfinal Optional<SlotInfo> matchedSlot = findMatchingSlotForRequest(request, remainingSlots);\n+\t\t\tif (matchedSlot.isPresent()) {\n+\t\t\t\tremainingSlots.remove(matchedSlot.get());\n+\t\t\t} else {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\tprivate static Optional<SlotInfo> findMatchingSlotForRequest(\n+\t\t\tfinal PhysicalSlotRequest request,\n+\t\t\tfinal Collection<SlotInfo> slots) {\n+\n+\t\tfinal ResourceProfile requiredResource = request.getSlotProfile().getPhysicalSlotResourceProfile();", "originalCommit": "90581a62267f9ce4129ed37497e92e41a4cc4840", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE5MTY0Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430191647", "bodyText": "ResourceProfiles are enough.\nI think you are right that we should simplify it.", "author": "zhuzhurk", "createdAt": "2020-05-26T06:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY1MzMzNA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431653334", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-05-28T08:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzODYzMg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r429838632", "bodyText": "Do we need to mix this concern of bulk allocation to SlotPool?\nCould we keep the SlotPool as only single physical slot allocator?\nWould it not be more natural to expose SlotPool#getAllocatedSlotsInformation and move the bulk logic to its tracker?", "author": "azagrebin", "createdAt": "2020-05-25T09:38:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPoolImpl.java", "diffHunk": "@@ -469,6 +469,47 @@ public void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwabl\n \t\t\t.collect(Collectors.toList());\n \t}\n \n+\t@Override\n+\tpublic boolean isSlotRequestBulkFulfillable(final PhysicalSlotRequestBulk slotRequestBulk) {", "originalCommit": "90581a62267f9ce4129ed37497e92e41a4cc4840", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE5MDAyNw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430190027", "bodyText": "This sounds good to me.\nI had wanted to do it like that but encountered some problems. I do not remember the problems unfortunately.\nI will try and see if it is still a problem. Maybe not since the design was adjusted during  developing.", "author": "zhuzhurk", "createdAt": "2020-05-26T06:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzODYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTU2Ng==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431939566", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-05-28T15:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgzODYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MTM1Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430051357", "bodyText": "It looks like componentMainThreadExecutor/tryAllocateFromAvailable/cancelSlotRequest are the only things, we reuse in SchedulerImpl.\nNot sure whether it makes sense to extend this class which has not been designed for bulk slot allocation.\nDo you think we can reuse SchedulerImpl in future?\nCould we just introduce another component for the change in this commit (basically bulk timeout), e.g. BulkSlotProvider.allocatePhysicalSlots/cancelSlotRequest interface or so?\nWould just duplicating tryAllocateFromAvailable/cancelSlotRequest in BulkSlotProviderImpl bring less confusion in future?\nWill we need single slot provider eventually for pipeline region scheduling at all?\nLater we could see how to introduce slot sharing and co-location concerns, maybe as other components on top.", "author": "azagrebin", "createdAt": "2020-05-25T19:12:42Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulerImpl.java", "diffHunk": "@@ -562,4 +575,110 @@ private void releaseSharedSlot(\n \tpublic boolean requiresPreviousExecutionGraphAllocations() {\n \t\treturn slotSelectionStrategy instanceof PreviousAllocationSlotSelectionStrategy;\n \t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\n+\t\tfinal Optional<SlotAndLocality> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);", "originalCommit": "4408dbdd70acda6cce06ae6974515c694115d6db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIzMTU4OA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430231588", "bodyText": "I think that the majority part of SchedulerImpl will not be needed anymore in the future.\nIntroducing a separate interface like BulkSlotProvider  might make it easier for us to drop the deprecated components in the future.\n\nDo you think we can reuse SchedulerImpl in future?\n\nI think not.\n\nWould just duplicating tryAllocateFromAvailable/cancelSlotRequest in BulkSlotProviderImpl bring less confusion in future?\n\nI think yes. Let's do it this way.\n\nWill we need single slot provider eventually for pipeline region scheduling at all?\n\nI think not.", "author": "zhuzhurk", "createdAt": "2020-05-26T08:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MTM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkzOTc3Mg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431939772", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-05-28T15:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MTM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAwNDU5NQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r432004595", "bodyText": "I just realized that BulkSlotProvider  is actually making things more complicated because we will need to change how we create it and its factory in JobMaster and DefaultJobManagerRunnerFactory.\nBulkSlotProvider needs to know main thread executor and slot pool, which makes it hard to create it in SchedulerNG internally.\nThen we will need to keep BulkSlotProvider and Scheduler/SlotProvider at the same time in JobMaster before we can completely drop SchedulerImpl.\nI think it would be easier and cleaner to just keep the bulk slot allocation logics in SchedulerImpl. We can try to make them less coupled with existing logics that will be dropped in the future.\nWDYT? @azagrebin", "author": "zhuzhurk", "createdAt": "2020-05-28T17:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MTM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzOTgxMw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r432239813", "bodyText": "I find one way that we can still have a separate BulkSlotProvider and do not need to change Scheduler/SlotProvider  creating and initializing codes.\nThat is, we still enables SlotProvider for bulk slot allocation. However, SchedulerImpl creates a BulkSlotProviderImpl internally and dedicates bulk slot allocation requests to it.\nSee 395c6cb", "author": "zhuzhurk", "createdAt": "2020-05-29T03:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MTM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MjUxMg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430052512", "bodyText": "These requests to SlotPoolImpl will also schedule per-slot timeout in streaming and additional fullfilability check for batch slot in SlotPoolImpl. Do we want to keep this complication, especially in future? Bulk timeout seems to be enough and basically addresses the same.\nWould it be easier to add e.g. SlotPoolImpl#requestNewAllocatedSlotWithoutTimeout? requestNewAllocatedSlotWithoutTimeout could be similar to requestNewAllocatedSlot for streaming but w/o any per-slot timeout tracking in SlotPoolImpl.", "author": "azagrebin", "createdAt": "2020-05-25T19:18:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SchedulerImpl.java", "diffHunk": "@@ -562,4 +575,110 @@ private void releaseSharedSlot(\n \tpublic boolean requiresPreviousExecutionGraphAllocations() {\n \t\treturn slotSelectionStrategy instanceof PreviousAllocationSlotSelectionStrategy;\n \t}\n+\n+\t@Override\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(\n+\t\t\tfinal Collection<PhysicalSlotRequest> physicalSlotRequests,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal PhysicalSlotRequestBulk slotRequestBulk = new PhysicalSlotRequestBulk(physicalSlotRequests);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest.Result>> resultFutures = new ArrayList<>(physicalSlotRequests.size());\n+\t\tfor (PhysicalSlotRequest request : physicalSlotRequests) {\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest.Result> resultFuture =\n+\t\t\t\tallocatePhysicalSlot(request, timeout).thenApply(result -> {\n+\t\t\t\t\tslotRequestBulk.markRequestFulfilled(\n+\t\t\t\t\t\tresult.getSlotRequestId(),\n+\t\t\t\t\t\tresult.getPhysicalSlot().getAllocationId());\n+\n+\t\t\t\t\treturn result;\n+\t\t\t\t});\n+\t\t\tresultFutures.add(resultFuture);\n+\t\t}\n+\n+\t\tslotRequestBulkTracker.track(slotRequestBulk);\n+\t\tschedulePendingRequestBulkTimeoutCheck(slotRequestBulk, timeout);\n+\n+\t\treturn FutureUtils.combineAll(resultFutures)\n+\t\t\t.whenComplete((ignore, throwable) -> slotRequestBulkTracker.untrack(slotRequestBulk));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlotRequest.Result> allocatePhysicalSlot(\n+\t\t\tfinal PhysicalSlotRequest physicalSlotRequest,\n+\t\t\tfinal Time timeout) {\n+\n+\t\tfinal SlotRequestId slotRequestId = physicalSlotRequest.getSlotRequestId();\n+\t\tfinal SlotProfile slotProfile = physicalSlotRequest.getSlotProfile();\n+\n+\t\tfinal Optional<SlotAndLocality> availablePhysicalSlot = tryAllocateFromAvailable(slotRequestId, slotProfile);\n+\n+\t\tfinal CompletableFuture<PhysicalSlot> slotFuture;\n+\t\tif (availablePhysicalSlot.isPresent()) {\n+\t\t\tslotFuture = CompletableFuture.completedFuture(availablePhysicalSlot.get().getSlot());\n+\t\t} else if (physicalSlotRequest.willSlotBeOccupiedIndefinitely()) {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedSlot(slotRequestId, slotProfile.getPhysicalSlotResourceProfile(), timeout);\n+\t\t} else {\n+\t\t\tslotFuture = slotPool.requestNewAllocatedBatchSlot(slotRequestId, slotProfile.getPhysicalSlotResourceProfile());", "originalCommit": "4408dbdd70acda6cce06ae6974515c694115d6db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE5OTYzNw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430199637", "bodyText": "I think it's fine to have a requestNewAllocatedSlotWithoutTimeout().\nThe question is about batch slot requests which also have individual timeout check. The timeout check for batch requests is independent from the slot requesting invocation. (via a regularly scheduled checkBatchSlotTimeout)\nHow about to disable checkBatchSlotTimeout on requestNewAllocatedSlotWithoutTimeout ? It is a bit hack but reduces complication.\nIn the future, once we dropped individual slot allocation from slot provider, we can drop these individual timeout check.", "author": "zhuzhurk", "createdAt": "2020-05-26T07:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MjUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM3NDM5Ng==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430374396", "bodyText": "Yes, this is what I also thought about.", "author": "azagrebin", "createdAt": "2020-05-26T12:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MjUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk4MzE3NQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431983175", "bodyText": "done via a758c3a", "author": "zhuzhurk", "createdAt": "2020-05-28T16:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MjUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NDI2Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430054263", "bodyText": "Do we need SlotProviderStrategy in OneSlotPerExecutionSlotAllocator at all?\nCould we use directly new BulkSlotProvider.allocatePhysicalSlots/cancelSlotRequest and create OneSlotPerExecutionSlotAllocator with willSlotBeOccupiedIndefinitely flag based on ScheduleMode?", "author": "azagrebin", "createdAt": "2020-05-25T19:26:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/executiongraph/SlotProviderStrategy.java", "diffHunk": "@@ -56,6 +62,24 @@\n \t\tScheduledUnit scheduledUnit,\n \t\tSlotProfile slotProfile);\n \n+\t/**\n+\t * Allocates a bulk of physical slots.\n+\t *\n+\t * @param physicalSlotRequests requests for physical slots\n+\t * @return future of the allocation which will be completed normally only when all the requests are fulfilled\n+\t */\n+\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(", "originalCommit": "201574e26e493e30b3ab868df25ff4b3b1ece05e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIwMTQzOA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430201438", "bodyText": "Nice catch!\nIt's not needed. I kept it to not change creation of DefaultrExecutionSlotAllocator. But given that we now have OneSlotPerExecutionSlotAllocator, I think we can get rid of it.", "author": "zhuzhurk", "createdAt": "2020-05-26T07:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NDI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MjU2NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r432272564", "bodyText": "done by make OneSlotPerExecutionSlotAllocator  interact with SloProvider directly.", "author": "zhuzhurk", "createdAt": "2020-05-29T06:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NDI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NzgxNA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430057814", "bodyText": "Could we introduce new SlotProfileRetriever(inputsLocationsRetriever, ignoreInternalProducers, useTaskProfile).createSlotProfileFutures(Collection<ExecutionVertexSchedulingRequirements>)?\nThis would deduplicate a lot of code in OneSlotPerExecutionSlotAllocator/DefaultExecutionSlotAllocator.", "author": "azagrebin", "createdAt": "2020-05-25T19:44:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -96,52 +97,88 @@ public DefaultExecutionSlotAllocator(\n \n \t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n \n-\t\t\tCompletableFuture<LogicalSlot> slotFuture = calculatePreferredLocations(\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tCollections.emptySet(),\n+\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n+\t\t\t\tallPreviousAllocationIds);\n+\n+\t\t\tfinal CompletableFuture<LogicalSlot> slotFuture = slotProfileFuture.thenCompose(\n+\t\t\t\tslotProfile ->\n+\t\t\t\t\tslotProviderStrategy.allocateSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tnew ScheduledUnit(\n+\t\t\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\t\t\tslotSharingGroupId,\n+\t\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n+\t\t\t\t\t\tslotProfile));\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n \t\t\t\t\texecutionVertexId,\n-\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n-\t\t\t\t\tinputsLocationsRetriever,\n-\t\t\t\t\tCollections.emptySet()).thenCompose(\n-\t\t\t\t\t\t\t(Collection<TaskManagerLocation> preferredLocations) ->\n-\t\t\t\t\t\t\t\tslotProviderStrategy.allocateSlot(\n-\t\t\t\t\t\t\t\t\tslotRequestId,\n-\t\t\t\t\t\t\t\t\tnew ScheduledUnit(\n-\t\t\t\t\t\t\t\t\t\texecutionVertexId,\n-\t\t\t\t\t\t\t\t\t\tslotSharingGroupId,\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n-\t\t\t\t\t\t\t\t\tSlotProfile.priorAllocation(\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tpreferredLocations,\n-\t\t\t\t\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n-\t\t\t\t\t\t\t\t\t\tallPreviousAllocationIds)));\n-\n-\t\t\tSlotExecutionVertexAssignment slotExecutionVertexAssignment =\n-\t\t\t\t\tnew SlotExecutionVertexAssignment(executionVertexId, slotFuture);\n-\t\t\t// add to map first to avoid the future completed before added.\n-\t\t\tpendingSlotAssignments.put(executionVertexId, slotExecutionVertexAssignment);\n-\n-\t\t\tslotFuture.whenComplete(\n-\t\t\t\t\t(ignored, throwable) -> {\n-\t\t\t\t\t\tpendingSlotAssignments.remove(executionVertexId);\n-\t\t\t\t\t\tif (throwable != null) {\n-\t\t\t\t\t\t\tslotProviderStrategy.cancelSlotRequest(slotRequestId, slotSharingGroupId, throwable);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t});\n+\t\t\t\t\tslotFuture,\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tslotSharingGroupId);\n \n \t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n \t\t}\n \n \t\treturn slotExecutionVertexAssignments;\n \t}\n \n-\tprivate void validateSchedulingRequirements(Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\tprotected void validateSchedulingRequirements(Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n \t\tschedulingRequirements.stream()\n \t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n \t\t\t.forEach(id -> checkState(\n \t\t\t\t!pendingSlotAssignments.containsKey(id),\n \t\t\t\t\"BUG: vertex %s tries to allocate a slot when its previous slot request is still pending\", id));\n \t}\n \n+\tprotected CompletableFuture<SlotProfile> createSlotProfile(", "originalCommit": "b442cbb672832f5e64cfe7403b31fc8ab0fefe4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxMjQyNg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430212426", "bodyText": "This is a shared method. Not sure what is the duplication?", "author": "zhuzhurk", "createdAt": "2020-05-26T07:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM3NzI3MA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430377270", "bodyText": "True, there is no duplication at the moment.\nI meant to move the concern of SlotProfileRetriever (and all related code) into a separate component to reuse it in OneSlotPerExecutionSlotAllocator/DefaultExecutionSlotAllocator. This would simplify OneSlotPerExecutionSlotAllocator/DefaultExecutionSlotAllocator, imo, and there will be also no code duplication.", "author": "azagrebin", "createdAt": "2020-05-26T12:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0Nzk5Ng==", "url": "https://github.com/apache/flink/pull/12256#discussion_r432347996", "bodyText": "In the latest update, I removed createSlotProfile() because I find it does not reduce much code duplication but introduced a nested method with weird parameters to distinguish DefaultExecutionSlotAllocator and OneSlotPerExecutionSlotAllocator .\nI think the major part that would be good to extract out from ExecutionSlotAllocator is the preferred location calculation. We can introduce a PreferredLocationsRetriever which wraps InputsLocationsRetriever, calculatePreferredLocations(...) and getPreferredLocationsBasedOnInputs(...).\nI think we can open another task to do it since it is not very related  to this change. (I'm already working on it though.)\nWDYT?", "author": "zhuzhurk", "createdAt": "2020-05-29T08:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NTIyNQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r432385225", "bodyText": "FLINK-18034 is opened to \"Introduce PreferredLocationsRetriever\".\nWith it we can go one step further to centrally manage the preferred location calculation regardless of it's state-based or inputs-based.", "author": "zhuzhurk", "createdAt": "2020-05-29T10:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NzgxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEwNjQ4OA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r433106488", "bodyText": "PR #12423 is opened which is based on this PR.", "author": "zhuzhurk", "createdAt": "2020-06-01T08:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1NzgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTM3MQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430059371", "bodyText": "Should we also release the slot from SlotPool?", "author": "azagrebin", "createdAt": "2020-05-25T19:51:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.SlotProviderStrategy;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends DefaultExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProviderStrategy slotProviderStrategy,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\t\tsuper(slotProviderStrategy, inputsLocationsRetriever);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnull);\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored here\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile = schedulingRequirements.getTaskResourceProfile();\n+\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\tallPreviousAllocationIds);\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotProviderStrategy.willSlotBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProviderStrategy.allocatePhysicalSlots(physicalSlotRequests))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t\t} catch (Exception ex) {\n+\t\t\t\t\t\tthrow new CompletionException(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal PhysicalSlot physicalSlot) throws FlinkException {\n+\n+\t\tfinal SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(\n+\t\t\tslotRequestId,\n+\t\t\tphysicalSlot,\n+\t\t\tnull,\n+\t\t\tLocality.UNKNOWN,\n+\t\t\tslotOwner);\n+\n+\t\tif (physicalSlot.tryAssignPayload(singleTaskSlot)) {\n+\t\t\treturn singleTaskSlot;\n+\t\t} else {\n+\t\t\tthrow new FlinkException(\"Could not assign payload to allocated slot \" + physicalSlot.getAllocationId() + '.');", "originalCommit": "b442cbb672832f5e64cfe7403b31fc8ab0fefe4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIwNDY2NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430204664", "bodyText": "All pending requested and allocated slots will be released on this exception.\nThis is because slotProviderStrategy.cancelSlotRequest() will be invoked for each slot request.", "author": "zhuzhurk", "createdAt": "2020-05-26T07:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1OTM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDg5Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430060897", "bodyText": "OneSlotPerExecutionSlotAllocator and DefaultExecutionSlotAllocator implement different approaches.\nWould it make sense to introduce a base AbstractExecutionSlotAllocator and inherit it by both classes?\nThere will be not much in common, mostly some state management around pendingSlotAssignments, if we:\n\nintroduce a separate SlotProfileRetriever\nuse BulkSlotProvider and willSlotBeOccupiedIndefinitely flag in OneSlotPerExecutionSlotAllocator instead of slotProviderStrategy\nmaybe move static methods to utils if it make sense", "author": "azagrebin", "createdAt": "2020-05-25T19:58:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.SlotProviderStrategy;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends DefaultExecutionSlotAllocator {", "originalCommit": "b442cbb672832f5e64cfe7403b31fc8ab0fefe4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxMDM4Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430210383", "bodyText": "Actually most of the methods of DefaultExecutionSlotAllocator are required for OneSlotPerExecutionSlotAllocator.\nBut I think it's fine to extract the common things into a base class.\nI will give a try.", "author": "zhuzhurk", "createdAt": "2020-05-26T07:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDUyOQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r432270529", "bodyText": "done via 2c5a1da", "author": "zhuzhurk", "createdAt": "2020-05-29T05:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODE5NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430468194", "bodyText": "What is the subject under test here? I assume AllocatedSlot. It would be nice to rename this class AllocatedSlotOccupationTest so that Ctrl + Shift + T works in IDEA: https://www.jetbrains.com/help/idea/navigating-between-test-and-test-subject.html", "author": "GJL", "createdAt": "2020-05-26T14:44:48Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/SlotOccupationTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.executiongraph.utils.SimpleAckingTaskManagerGateway;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmanager.slots.TestingSlotOwner;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests whether the slot occupation works correctly.\n+ */\n+public class SlotOccupationTest extends TestLogger {", "originalCommit": "7f16b12b9c89b723a6c201da252d65e259a53c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyMDM3Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431020373", "bodyText": "Ok.", "author": "zhuzhurk", "createdAt": "2020-05-27T10:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0MDYxMQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431940611", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-05-28T15:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODk1OQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r430468959", "bodyText": "Under what circumstances can it happen that the physical slot is already assigned a payload?", "author": "GJL", "createdAt": "2020-05-26T14:45:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.executiongraph.SlotProviderStrategy;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends DefaultExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProviderStrategy slotProviderStrategy,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever) {\n+\t\tsuper(slotProviderStrategy, inputsLocationsRetriever);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnull);\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored here\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile = schedulingRequirements.getTaskResourceProfile();\n+\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = createSlotProfile(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\tallPreviousAllocationIds);\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotProviderStrategy.willSlotBeOccupiedIndefinitely());\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProviderStrategy.allocatePhysicalSlots(physicalSlotRequests))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t\t} catch (Exception ex) {\n+\t\t\t\t\t\tthrow new CompletionException(ex);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal PhysicalSlot physicalSlot) throws FlinkException {\n+\n+\t\tfinal SingleLogicalSlot singleTaskSlot = new SingleLogicalSlot(\n+\t\t\tslotRequestId,\n+\t\t\tphysicalSlot,\n+\t\t\tnull,\n+\t\t\tLocality.UNKNOWN,\n+\t\t\tslotOwner);\n+\n+\t\tif (physicalSlot.tryAssignPayload(singleTaskSlot)) {\n+\t\t\treturn singleTaskSlot;\n+\t\t} else {\n+\t\t\tthrow new FlinkException(\"Could not assign payload to allocated slot \" + physicalSlot.getAllocationId() + '.');", "originalCommit": "7f16b12b9c89b723a6c201da252d65e259a53c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyNTAxMQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r431025011", "bodyText": "Good point. I think  it is not supposed to happen with the new thread mode of JM.\nI will replace it with a state check as a sanity check.", "author": "zhuzhurk", "createdAt": "2020-05-27T10:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3MDQwMQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r432270401", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-05-29T05:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ2ODk1OQ=="}], "type": "inlineReview"}, {"oid": "2aa39a469f86ceae75eafb75194f7c7f82e3a6cc", "url": "https://github.com/apache/flink/commit/2aa39a469f86ceae75eafb75194f7c7f82e3a6cc", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling", "committedDate": "2020-05-29T04:34:43Z", "type": "forcePushed"}, {"oid": "ca05fc241f6fd0550a39612b4ddef86b63a304a6", "url": "https://github.com/apache/flink/commit/ca05fc241f6fd0550a39612b4ddef86b63a304a6", "message": "fixup! [FLINK-17018][runtime] Extract common logics of DefaultExecutionSlotAllocator into AbstractExecutionSlotAllocator", "committedDate": "2020-06-03T08:56:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA2MjI4Mg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435062282", "bodyText": "Could we already make OneSlotPerExecutionSlotAllocator depending on BulkSlotProvider if SlotProvider interface extends BulkSlotProvider and we duplicate cancelSlotRequest in BulkSlotProvider interface? or make BulkSlotProvider extend SlotOwner later.\nIf cancelSlotRequest is basically only used to release slots, then maybe we could rename it later to releaseSlot in BulkSlotProvider.", "author": "azagrebin", "createdAt": "2020-06-04T07:56:00Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzODgwOQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436238809", "bodyText": "It's done to make OneSlotPerExecutionSlotAllocator depend on BulkSlotProvider.\nI think cancelSlotRequest may be better because SlotPoolImpl#releaseSlot() also cancels pending physical slot request.", "author": "zhuzhurk", "createdAt": "2020-06-06T05:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA2MjI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MjA0Mg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435082042", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds.values().stream()\n          \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds.values()", "author": "azagrebin", "createdAt": "2020-06-04T08:29:36Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tthrowable -> slotProvider.cancelSlotRequest(slotRequestId, null, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n+\t\t\t\t\tinputsLocationsRetriever,\n+\t\t\t\t\tallExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));\n+\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProvider.allocatePhysicalSlots(physicalSlotRequests, allocationTimeout))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzODg2Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436238867", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-06T05:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MjY2MA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435082660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic OneSlotPerExecutionSlotAllocator(\n          \n          \n            \n            \tOneSlotPerExecutionSlotAllocator(", "author": "azagrebin", "createdAt": "2020-06-04T08:30:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzODg3Mg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436238872", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-06T05:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MjY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzQwMA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435087400", "bodyText": "private CompletableFuture<SlotProfile> getSlotProfileFuture(\n\t\t\tSet<ExecutionVertexID> allExecutionVertexIds,\n\t\t\tSet<AllocationID> allPreviousAllocationIds,\n\t\t\tExecutionVertexSchedulingRequirements schedulingRequirements) {\n\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n\t\t\tcalculatePreferredLocations(\n\t\t\t\tschedulingRequirements.getExecutionVertexId(),\n\t\t\t\tallExecutionVertexIds);\n\n\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n\t\treturn preferredLocationsFuture.thenApply(\n\t\t\tpreferredLocations ->\n\t\t\t\tSlotProfile.priorAllocation(\n\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n\t\t\t\t\tpreferredLocations,\n\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n\t\t\t\t\tallPreviousAllocationIds));\n\t}\n\nMaybe even deduplicate it with DefaultExecutionSlotAllocator by adding an additional ResourceProfile physicalSlotResourceProfile arg.", "author": "azagrebin", "createdAt": "2020-06-04T08:38:09Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tthrowable -> slotProvider.cancelSlotRequest(slotRequestId, null, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n+\t\t\t\t\tinputsLocationsRetriever,\n+\t\t\t\t\tallExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzNzc3OA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436237778", "bodyText": "There is already ExecutionVertexSchedulingRequirements#physicalSlotResourceProfile which is the sum of ResourceProfiles of all tasks in the same shared slot.\nHowever, we cannot use it in OneSlotPerExecutionSlotAllocator because it ignores slot sharing and the physical slot should fit a single task instead.", "author": "zhuzhurk", "createdAt": "2020-06-06T04:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk4NTgwOQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r437985809", "bodyText": "I meant at least to factor out getSlotProfileFuture into a separate private method inside OneSlotPerExecutionSlotAllocator and another one inside DefaultExecutionSlotAllocator . This would reduce the big method createPhysicalSlotRequestFutures.\nThe next idea was to deduplicate by adding what to use for physicalSlotResourceProfile in SlotProfile.priorAllocation:\nAbstractExecutionSlotAllocator#getSlotProfileFuture(..., ResourceProfile physicalSlotResourceProfile)\n\nThis might be too much.", "author": "azagrebin", "createdAt": "2020-06-10T09:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3NjY2MA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438076660", "bodyText": "Ok I see. AbstractExecutionSlotAllocator#getSlotProfileFuture() is added back.", "author": "zhuzhurk", "createdAt": "2020-06-10T12:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTUwNg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435095506", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n          \n          \n            \n            \t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n          \n          \n            \n            \t\t\t.collect(Collectors.toSet());\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n          \n          \n            \n            \t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n          \n          \n            \n            \t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n          \n          \n            \n            \t\t\tcreatePhysicalSlotRequestFutures(\n          \n          \n            \n            \t\t\t\texecutionVertexSchedulingRequirements,\n          \n          \n            \n            \t\t\t\tallExecutionVertexIds,\n          \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tallocateSlotsForAssignments(\n          \n          \n            \n            \t\t\tphysicalSlotRequestFutures,\n          \n          \n            \n            \t\t\tslotExecutionVertexAssignments,\n          \n          \n            \n            \t\t\texecutionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\treturn slotExecutionVertexAssignments;\n          \n          \n            \n            \t\tfinal Map<SlotRequestId, SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n          \n          \n            \n            \t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements);\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = slotExecutionVertexAssignments\n          \n          \n            \n            \t\t\t.entrySet()\n          \n          \n            \n            \t\t\t.stream()\n          \n          \n            \n            \t\t\t.collect(Collectors.toMap(e -> e.getValue().getExecutionVertexId(), Map.Entry::getKey));\n          \n          \n            \n            \n          \n          \n            \n            \t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n          \n          \n            \n            \t\t\tcreatePhysicalSlotRequestFutures(\n          \n          \n            \n            \t\t\t\texecutionVertexSchedulingRequirements,\n          \n          \n            \n            \t\t\t\texecutionVertexSlotRequestIds);\n          \n          \n            \n            \n          \n          \n            \n            \t\tallocateSlotsForAssignments(\n          \n          \n            \n            \t\t\tphysicalSlotRequestFutures,\n          \n          \n            \n            \t\t\tslotExecutionVertexAssignments);\n          \n          \n            \n            \n          \n          \n            \n            \t\treturn new ArrayList<>(slotExecutionVertexAssignments.values());\n          \n      \n    \n    \n  \n\nThis seems to be a bit less indexing... It also implies some simplification of the called private methods.", "author": "azagrebin", "createdAt": "2020-06-04T08:52:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzOTYyNQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436239625", "bodyText": "Good suggestion!\nI had wanted but failed to do it due to the slotRequestFailureHandler parameter of createAndRegisterSlotExecutionVertexAssignment was not well designed so that slotRequestId was needed before creating SlotExecutionVertexAssignments. Just changed it in b036807.\nThis method is now reorganized regarding your suggestions with some small differences:\n\nadded slotRequestId to SlotExecutionVertexAssignment and removed generateExecutionVertexSlotRequestIds \nallExecutionVertexIds is moved into createPhysicalSlotRequestFutures(...)\nallocateSlotsForAssignments is simplified\nstatements are reordered", "author": "zhuzhurk", "createdAt": "2020-06-06T05:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk5MTU5OA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r437991598", "bodyText": "Are you worried about performance for new ArrayList<>(slotExecutionVertexAssignments.values()) to make slotExecutionVertexAssignments a map?\nThen you would not need allExecutionVertexIds in createPhysicalSlotRequestFutures as it could be just slotExecutionVertexAssignments.keySet().\nAlso not sure, why the API is to return List<SlotExecutionVertexAssignment>. Do we need list indexing anywhere on the using side? Otherwise, allocateSlotsFor could return Collection, then it could return just slotExecutionVertexAssignments.values().", "author": "azagrebin", "createdAt": "2020-06-10T09:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3OTAxNw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438079017", "bodyText": "The API return a list because we want the the given scheduling order to be respected, and thus to avoid disordered scheduling/deployment. See FLINK-14909.", "author": "zhuzhurk", "createdAt": "2020-06-10T12:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA4Mjg0Mg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438082842", "bodyText": "createPhysicalSlotRequestFutures () does not take slotExecutionVertexAssignments\nas a param.\nBut you are right that we do not need to compute a allExecutionVertexIds .  We can directly use the keySet of executionVertexSlotRequestIds as allExecutionVertexIds. Done via 7d47343.", "author": "zhuzhurk", "createdAt": "2020-06-10T12:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjkxNg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435096916", "bodyText": "Maybe, this could be SingleLogicalSlot#createAndAllocateFromPhysicalSlot.", "author": "azagrebin", "createdAt": "2020-06-04T08:54:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+public class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal SlotProvider slotProvider,\n+\t\t\tfinal InputsLocationsRetriever inputsLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(inputsLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds =\n+\t\t\tgenerateExecutionVertexSlotRequestIds(allExecutionVertexIds);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements, executionVertexSlotRequestIds);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\tallExecutionVertexIds,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments,\n+\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate Map<ExecutionVertexID, SlotRequestId> generateExecutionVertexSlotRequestIds(\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = new HashMap<>();\n+\t\tfor (ExecutionVertexID executionVertexId : allExecutionVertexIds) {\n+\t\t\texecutionVertexSlotRequestIds.put(executionVertexId, new SlotRequestId());\n+\t\t}\n+\t\treturn executionVertexSlotRequestIds;\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\tthrowable -> slotProvider.cancelSlotRequest(slotRequestId, null, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tschedulingRequirements.getPreferredLocations(),\n+\t\t\t\t\tinputsLocationsRetriever,\n+\t\t\t\t\tallExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));\n+\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Map<ExecutionVertexID, SlotExecutionVertexAssignment> vertexToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getExecutionVertexId, Function.identity()));\n+\n+\t\tfinal Map<SlotRequestId, ExecutionVertexID> slotToVertexMapping = new HashMap<>();\n+\t\tfor (Map.Entry<ExecutionVertexID, SlotRequestId> entry : executionVertexSlotRequestIds.entrySet()) {\n+\t\t\tslotToVertexMapping.put(entry.getValue(), entry.getKey());\n+\t\t}\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProvider.allocatePhysicalSlots(physicalSlotRequests, allocationTimeout))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\tfinal LogicalSlot logicalSlot = allocateSingleLogicalSlotFromPhysicalSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tresult.getPhysicalSlot());\n+\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\texecutionVertexSlotRequestIds.values().stream()\n+\t\t\t\t\t.forEach(slotRequestId -> {\n+\t\t\t\t\t\tfinal ExecutionVertexID executionVertexId = slotToVertexMapping.get(slotRequestId);\n+\t\t\t\t\t\tvertexToAssignmentMapping.get(executionVertexId).getLogicalSlotFuture().completeExceptionally(ex);\n+\t\t\t\t\t});\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate LogicalSlot allocateSingleLogicalSlotFromPhysicalSlot(", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MDk5Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436060993", "bodyText": "Sure, that's what we had wanted when adding SingleLogicalSlot#createAndAllocateFromPhysicalSlot.", "author": "zhuzhurk", "createdAt": "2020-06-05T17:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzODg4NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436238884", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-06T05:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODE2NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435208164", "bodyText": "If we would manage to make OneSlotPerExecutionSlotAllocator depending on BulkSlotProvider, this allocatePhysicalSlots could in a separate AllocationToggableBulkSlotProvider or so, as a separate commit if we do it.", "author": "azagrebin", "createdAt": "2020-06-04T12:17:38Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocatorTest.java", "diffHunk": "@@ -216,13 +221,37 @@ private SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(\n \t\t\t\tTime timeout) {\n \n \t\t\tslotAllocationRequests.add(Tuple3.of(slotRequestId, task, slotProfile));\n-\t\t\tif (slotAllocationDisabled) {\n+\t\t\tif (forceFailingSlotAllocation) {\n+\t\t\t\treturn FutureUtils.completedExceptionally(new Exception(\"Forced failure\"));\n+\t\t\t} else if (slotAllocationDisabled) {\n \t\t\t\treturn new CompletableFuture<>();\n \t\t\t} else {\n \t\t\t\treturn CompletableFuture.completedFuture(new TestingLogicalSlotBuilder().createTestingLogicalSlot());\n \t\t\t}\n \t\t}\n \n+\t\tpublic CompletableFuture<Collection<PhysicalSlotRequest.Result>> allocatePhysicalSlots(", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzODk0NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436238944", "bodyText": "Yes, OneSlotPerExecutionSlotAllocatorTest is reworked now and does not use AllocationToggableBulkSlotProvider anymore.", "author": "zhuzhurk", "createdAt": "2020-06-06T05:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODQ3Ng==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435208476", "bodyText": "nit: would be nice to have a separate static util class for the shared static methods", "author": "azagrebin", "createdAt": "2020-06-04T12:18:13Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocatorTest.java", "diffHunk": "@@ -189,7 +192,7 @@ private DefaultExecutionSlotAllocator createExecutionSlotAllocator(InputsLocatio\n \t\treturn schedulingRequirements;\n \t}\n \n-\tprivate SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(\n+\tstatic SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzOTAxMA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436239010", "bodyText": "Agreed. Added util classes in 216a75a and 277ee72", "author": "zhuzhurk", "createdAt": "2020-06-06T05:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODczMA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435208730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tprivate boolean forceFailingSlotAllocation = false;\n          \n          \n            \n            \t\tprivate boolean forceFailingSlotAllocation;", "author": "azagrebin", "createdAt": "2020-06-04T12:18:40Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocatorTest.java", "diffHunk": "@@ -200,14 +203,16 @@ private SlotExecutionVertexAssignment findSlotAssignmentByExecutionVertexId(\n \t\t\t\t\t\texecutionVertexId)));\n \t}\n \n-\tprivate static class AllocationToggableSlotProvider implements SlotProvider {\n+\tstatic class AllocationToggableSlotProvider implements SlotProvider {\n \n \t\tprivate final List<Tuple3<SlotRequestId, ScheduledUnit, SlotProfile>> slotAllocationRequests = new ArrayList<>();\n \n \t\tprivate final List<SlotRequestId> cancelledSlotRequestIds = new ArrayList<>();\n \n \t\tprivate boolean slotAllocationDisabled;\n \n+\t\tprivate boolean forceFailingSlotAllocation = false;", "originalCommit": "a6f7cf4651b7c29de6bea239e9459bbeb68d9583", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIxMDU2MQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435210561", "bodyText": "nit: it would be nice to introduce enum AllocationTypeEnum {ENABLED, DISABLED, FAILING}", "author": "azagrebin", "createdAt": "2020-06-04T12:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzOTEzMw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436239133", "bodyText": "OneSlotPerExecutionSlotAllocatorTest now has its own TestingBulkSlotProvider which does not have 3 modes.", "author": "zhuzhurk", "createdAt": "2020-06-06T05:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIwODczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyMDk1Ng==", "url": "https://github.com/apache/flink/pull/12256#discussion_r435220956", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic OneSlotPerExecutionSlotAllocatorFactory(\n          \n          \n            \n            \tOneSlotPerExecutionSlotAllocatorFactory(", "author": "azagrebin", "createdAt": "2020-06-04T12:39:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocatorFactory.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * Factory for {@link OneSlotPerExecutionSlotAllocator}.\n+ */\n+public class OneSlotPerExecutionSlotAllocatorFactory implements ExecutionSlotAllocatorFactory {\n+\n+\tprivate final SlotProvider slotProvider;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tpublic OneSlotPerExecutionSlotAllocatorFactory(", "originalCommit": "044add50e281be712b30e8628b52daaec89e7227", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzOTE0MA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r436239140", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-06T05:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTIyMDk1Ng=="}], "type": "inlineReview"}, {"oid": "f181cf943442db6173eba4c817f40bbab49538da", "url": "https://github.com/apache/flink/commit/f181cf943442db6173eba4c817f40bbab49538da", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling", "committedDate": "2020-06-06T05:05:37Z", "type": "forcePushed"}, {"oid": "eba9c31264c2a0fe9f5bf955ba21de081bd1aa25", "url": "https://github.com/apache/flink/commit/eba9c31264c2a0fe9f5bf955ba21de081bd1aa25", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling", "committedDate": "2020-06-06T05:26:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3NjM0MA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r437976340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t(slotRequestId, throwable) -> slotProvider.cancelSlotRequest(slotRequestId, throwable));\n          \n          \n            \n            \t\t\t\t\tslotProvider::cancelSlotRequest);", "author": "azagrebin", "createdAt": "2020-06-10T09:08:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final BulkSlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tOneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal BulkSlotProvider slotProvider,\n+\t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(preferredLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = slotExecutionVertexAssignments\n+\t\t\t.stream()\n+\t\t\t.collect(\n+\t\t\t\tCollectors.toMap(\n+\t\t\t\t\tSlotExecutionVertexAssignment::getExecutionVertexId,\n+\t\t\t\t\tSlotExecutionVertexAssignment::getSlotRequestId));\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments);\n+\n+\t\treturn Collections.unmodifiableList(slotExecutionVertexAssignments);\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\t(slotRequestId, throwable) -> slotProvider.cancelSlotRequest(slotRequestId, throwable));", "originalCommit": "d754688951619f89701c5a49a915c611658a405b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODcxMg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438058712", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-10T11:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3NjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3OTExNQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r437979115", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class ExecutionSlotAllocatorTestUtils {\n          \n          \n            \n            class ExecutionSlotAllocatorTestUtils {", "author": "azagrebin", "createdAt": "2020-06-10T09:13:11Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/ExecutionSlotAllocatorTestUtils.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Test utils for {@link ExecutionSlotAllocator}.\n+ */\n+public class ExecutionSlotAllocatorTestUtils {", "originalCommit": "277ee720dee5ab63dade29c7178d9e7af69a3f21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA1ODc1NQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438058755", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-10T11:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk3OTExNQ=="}], "type": "inlineReview"}, {"oid": "f009698034f1c67e698a83e43bbb2bcc160f264d", "url": "https://github.com/apache/flink/commit/f009698034f1c67e698a83e43bbb2bcc160f264d", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex", "committedDate": "2020-06-11T02:38:42Z", "type": "forcePushed"}, {"oid": "f5939316d96975bea8e877770acb52bc17683087", "url": "https://github.com/apache/flink/commit/f5939316d96975bea8e877770acb52bc17683087", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex", "committedDate": "2020-06-11T03:19:45Z", "type": "forcePushed"}, {"oid": "7d4734369b4b87997cce4f593cfd706b78b212f6", "url": "https://github.com/apache/flink/commit/7d4734369b4b87997cce4f593cfd706b78b212f6", "message": "Fixup! [FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex", "committedDate": "2020-06-11T03:35:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1OTQyOA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438659428", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate class OneSlotPerExecutionSlotAllocatorSlotOwner implements SlotOwner {\n          \n          \n            \n            \n          \n          \n            \n            \t\t@Override\n          \n          \n            \n            \t\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n          \n          \n            \n            \t\t\tslotProvider.cancelSlotRequest(\n          \n          \n            \n            \t\t\t\tlogicalSlot.getSlotRequestId(),\n          \n          \n            \n            \t\t\t\tnew FlinkException(\"Slot is being returned to OneSlotPerExecutionSlotAllocator.\"));\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t}\n          \n          \n            \n            \t    @Override\n          \n          \n            \n            \t\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n          \n          \n            \n            \t\t\tslotProvider.cancelSlotRequest(\n          \n          \n            \n            \t\t\t\tlogicalSlot.getSlotRequestId(),\n          \n          \n            \n            \t\t\t\tnew FlinkException(\"Slot is being returned to OneSlotPerExecutionSlotAllocator.\"));\n          \n          \n            \n            \t\t}\n          \n      \n    \n    \n  \n\nMaybe it is just easier to implement SlotOwner in OneSlotPerExecutionSlotAllocator and pass this to SingleLogicalSlot.allocateFromPhysicalSlot?", "author": "azagrebin", "createdAt": "2020-06-11T09:29:15Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final BulkSlotProvider slotProvider;\n+\n+\tprivate final SlotOwner slotOwner;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tOneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal BulkSlotProvider slotProvider,\n+\t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(preferredLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\n+\t\tthis.slotOwner = new OneSlotPerExecutionSlotAllocatorSlotOwner();\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tcreateSlotExecutionVertexAssignments(executionVertexSchedulingRequirements);\n+\n+\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds = slotExecutionVertexAssignments\n+\t\t\t.stream()\n+\t\t\t.collect(\n+\t\t\t\tCollectors.toMap(\n+\t\t\t\t\tSlotExecutionVertexAssignment::getExecutionVertexId,\n+\t\t\t\t\tSlotExecutionVertexAssignment::getSlotRequestId));\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tcreatePhysicalSlotRequestFutures(\n+\t\t\t\texecutionVertexSchedulingRequirements,\n+\t\t\t\texecutionVertexSlotRequestIds);\n+\n+\t\tallocateSlotsForAssignments(\n+\t\t\tphysicalSlotRequestFutures,\n+\t\t\tslotExecutionVertexAssignments);\n+\n+\t\treturn Collections.unmodifiableList(slotExecutionVertexAssignments);\n+\t}\n+\n+\tprivate static void validateNoCoLocationConstraint(\n+\t\t\tfinal Collection<ExecutionVertexSchedulingRequirements> schedulingRequirements) {\n+\n+\t\tfinal boolean hasCoLocationConstraint = schedulingRequirements.stream()\n+\t\t\t.anyMatch(r -> r.getCoLocationConstraint() != null);\n+\t\tcheckState(\n+\t\t\t!hasCoLocationConstraint,\n+\t\t\t\"Jobs with co-location constraints are not allowed to run with pipelined region scheduling strategy.\");\n+\t}\n+\n+\tprivate List<SlotExecutionVertexAssignment> createSlotExecutionVertexAssignments(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\n+\t\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment =\n+\t\t\t\tcreateAndRegisterSlotExecutionVertexAssignment(\n+\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\tnew CompletableFuture<>(),\n+\t\t\t\t\t(slotRequestId, throwable) -> slotProvider.cancelSlotRequest(slotRequestId, throwable));\n+\t\t\tslotExecutionVertexAssignments.add(slotExecutionVertexAssignment);\n+\t\t}\n+\n+\t\treturn slotExecutionVertexAssignments;\n+\t}\n+\n+\tprivate List<CompletableFuture<PhysicalSlotRequest>> createPhysicalSlotRequestFutures(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements,\n+\t\t\tfinal Map<ExecutionVertexID, SlotRequestId> executionVertexSlotRequestIds) {\n+\n+\t\tfinal Set<ExecutionVertexID> allExecutionVertexIds = executionVertexSchedulingRequirements.stream()\n+\t\t\t.map(ExecutionVertexSchedulingRequirements::getExecutionVertexId)\n+\t\t\t.collect(Collectors.toSet());\n+\n+\t\tfinal Set<AllocationID> allPreviousAllocationIds =\n+\t\t\tcomputeAllPriorAllocationIds(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures =\n+\t\t\tnew ArrayList<>(executionVertexSchedulingRequirements.size());\n+\t\tfor (ExecutionVertexSchedulingRequirements schedulingRequirements : executionVertexSchedulingRequirements) {\n+\t\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n+\t\t\tfinal SlotRequestId slotRequestId = executionVertexSlotRequestIds.get(executionVertexId);\n+\n+\t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n+\n+\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\t\tcalculatePreferredLocations(executionVertexId, allExecutionVertexIds);\n+\n+\t\t\t// use the task resource profile as the physical slot resource requirement since slot sharing is ignored\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = preferredLocationsFuture.thenApply(\n+\t\t\t\tpreferredLocations ->\n+\t\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\t\tallPreviousAllocationIds));\n+\n+\t\t\tfinal CompletableFuture<PhysicalSlotRequest> physicalSlotRequestFuture =\n+\t\t\t\tslotProfileFuture.thenApply(\n+\t\t\t\t\tslotProfile -> createPhysicalSlotRequest(slotRequestId, slotProfile));\n+\t\t\tphysicalSlotRequestFutures.add(physicalSlotRequestFuture);\n+\t\t}\n+\n+\t\treturn physicalSlotRequestFutures;\n+\t}\n+\n+\tprivate PhysicalSlotRequest createPhysicalSlotRequest(\n+\t\t\tfinal SlotRequestId slotRequestId,\n+\t\t\tfinal SlotProfile slotProfile) {\n+\t\treturn new PhysicalSlotRequest(slotRequestId, slotProfile, slotWillBeOccupiedIndefinitely);\n+\t}\n+\n+\tprivate void allocateSlotsForAssignments(\n+\t\t\tfinal List<CompletableFuture<PhysicalSlotRequest>> physicalSlotRequestFutures,\n+\t\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments) {\n+\n+\t\tfinal Map<SlotRequestId, SlotExecutionVertexAssignment> requestToAssignmentMapping =\n+\t\t\tslotExecutionVertexAssignments.stream()\n+\t\t\t\t.collect(Collectors.toMap(SlotExecutionVertexAssignment::getSlotRequestId, Function.identity()));\n+\n+\t\tFutureUtils.combineAll(physicalSlotRequestFutures)\n+\t\t\t.thenCompose(physicalSlotRequests -> slotProvider.allocatePhysicalSlots(physicalSlotRequests, allocationTimeout))\n+\t\t\t.thenAccept(physicalSlotRequestResults -> {\n+\t\t\t\tfor (PhysicalSlotRequest.Result result : physicalSlotRequestResults) {\n+\t\t\t\t\tfinal SlotRequestId slotRequestId = result.getSlotRequestId();\n+\t\t\t\t\tfinal SlotExecutionVertexAssignment assignment = requestToAssignmentMapping.get(slotRequestId);\n+\n+\t\t\t\t\tcheckState(assignment != null);\n+\n+\t\t\t\t\tfinal LogicalSlot logicalSlot = SingleLogicalSlot.allocateFromPhysicalSlot(\n+\t\t\t\t\t\tslotRequestId,\n+\t\t\t\t\t\tresult.getPhysicalSlot(),\n+\t\t\t\t\t\tLocality.UNKNOWN,\n+\t\t\t\t\t\tslotOwner,\n+\t\t\t\t\t\tslotWillBeOccupiedIndefinitely);\n+\t\t\t\t\tassignment.getLogicalSlotFuture().complete(logicalSlot);\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.exceptionally(ex -> {\n+\t\t\t\tslotExecutionVertexAssignments.forEach(\n+\t\t\t\t\tassignment -> assignment.getLogicalSlotFuture().completeExceptionally(ex));\n+\t\t\t\treturn null;\n+\t\t\t});\n+\t}\n+\n+\tprivate class OneSlotPerExecutionSlotAllocatorSlotOwner implements SlotOwner {\n+\n+\t\t@Override\n+\t\tpublic void returnLogicalSlot(LogicalSlot logicalSlot) {\n+\t\t\tslotProvider.cancelSlotRequest(\n+\t\t\t\tlogicalSlot.getSlotRequestId(),\n+\t\t\t\tnew FlinkException(\"Slot is being returned to OneSlotPerExecutionSlotAllocator.\"));\n+\t\t}\n+\t}", "originalCommit": "fc243db69366bfc95c96a272936ebe30cbd6b26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MDI4Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438860287", "bodyText": "I think you are right. done.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1OTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MDc5NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438660794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprotected void validateSchedulingRequirements(\n          \n          \n            \n            \tvoid validateSchedulingRequirements(\n          \n      \n    \n    \n  \n\nnit: not sure, why we need protected for methods in AbstractExecutionSlotAllocator if it is used only within the package", "author": "azagrebin", "createdAt": "2020-06-11T09:31:39Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * Base class for all {@link ExecutionSlotAllocator}. It is responsible to allocate slots for tasks and\n+ * keep the unfulfilled slot requests for further cancellation.\n+ */\n+abstract class AbstractExecutionSlotAllocator implements ExecutionSlotAllocator {\n+\n+\tprivate final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n+\n+\tprivate final PreferredLocationsRetriever preferredLocationsRetriever;\n+\n+\tprotected AbstractExecutionSlotAllocator(final PreferredLocationsRetriever preferredLocationsRetriever) {\n+\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n+\t\tthis.pendingSlotAssignments = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void cancel(final ExecutionVertexID executionVertexId) {\n+\t\tfinal SlotExecutionVertexAssignment slotExecutionVertexAssignment = pendingSlotAssignments.get(executionVertexId);\n+\t\tif (slotExecutionVertexAssignment != null) {\n+\t\t\tslotExecutionVertexAssignment.getLogicalSlotFuture().cancel(false);\n+\t\t}\n+\t}\n+\n+\tprotected void validateSchedulingRequirements(", "originalCommit": "4866dbfb0920cc1a0cd7a9876810fa1fad4fc3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MDA5Nw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438860097", "bodyText": "Sure. We can make it package private for now given that we do not expect it to be implemented somewhere out of the package. The same applies for the other protected methods.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MDc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MDQ3NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438860474", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MDc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MzQzMg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438663432", "bodyText": "If it is a private method now, I guess we do not need it?", "author": "azagrebin", "createdAt": "2020-06-11T09:36:29Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/AbstractExecutionSlotAllocator.java", "diffHunk": "@@ -94,7 +96,26 @@ protected SlotExecutionVertexAssignment createAndRegisterSlotExecutionVertexAssi\n \t\treturn slotExecutionVertexAssignment;\n \t}\n \n-\tprotected CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(\n+\tprotected CompletableFuture<SlotProfile> getSlotProfileFuture(\n+\t\t\tfinal ExecutionVertexSchedulingRequirements schedulingRequirements,\n+\t\t\tfinal ResourceProfile physicalSlotResourceProfile,\n+\t\t\tfinal Set<ExecutionVertexID> producersToIgnore,\n+\t\t\tfinal Set<AllocationID> allPreviousAllocationIds) {\n+\n+\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture =\n+\t\t\tcalculatePreferredLocations(schedulingRequirements.getExecutionVertexId(), producersToIgnore);\n+\n+\t\treturn preferredLocationsFuture.thenApply(\n+\t\t\tpreferredLocations ->\n+\t\t\t\tSlotProfile.priorAllocation(\n+\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n+\t\t\t\t\tphysicalSlotResourceProfile,\n+\t\t\t\t\tpreferredLocations,\n+\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n+\t\t\t\t\tallPreviousAllocationIds));\n+\t}\n+\n+\tprivate CompletableFuture<Collection<TaskManagerLocation>> calculatePreferredLocations(", "originalCommit": "8234b6b1b11b6d08879fed60abdfbc948894c59d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1OTk5MQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438859991", "bodyText": "true. removed.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2MzQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NjUzMA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438666530", "bodyText": "nit, it would be nice to have:\nprivate CompletableFuture<LogicalSlot> allocateSlot(\n\t\t\tSet<AllocationID> allPreviousAllocationIds,\n\t\t\tExecutionVertexSchedulingRequirements schedulingRequirements) {\n\t\tfinal ExecutionVertexID executionVertexId = schedulingRequirements.getExecutionVertexId();\n\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n\n\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n\n\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = getSlotProfileFuture(\n\t\t\tschedulingRequirements,\n\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n\t\t\tCollections.emptySet(),\n\t\t\tallPreviousAllocationIds);\n\n\t\treturn slotProfileFuture.thenCompose(\n\t\t\tslotProfile -> slotProviderStrategy.allocateSlot(\n\t\t\t\tslotRequestId,\n\t\t\t\tnew ScheduledUnit(\n\t\t\t\t\texecutionVertexId,\n\t\t\t\t\tschedulingRequirements.getSlotSharingGroupId(),\n\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n\t\t\t\tslotProfile));\n\t}", "author": "azagrebin", "createdAt": "2020-06-11T09:42:14Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -77,22 +75,20 @@ public DefaultExecutionSlotAllocator(\n \n \t\t\tLOG.debug(\"Allocate slot with id {} for execution {}\", slotRequestId, executionVertexId);\n \n-\t\t\tCompletableFuture<LogicalSlot> slotFuture = calculatePreferredLocations(\n-\t\t\t\t\texecutionVertexId,\n-\t\t\t\t\tCollections.emptySet()).thenCompose(\n-\t\t\t\t\t\t\t(Collection<TaskManagerLocation> preferredLocations) ->\n-\t\t\t\t\t\t\t\tslotProviderStrategy.allocateSlot(\n-\t\t\t\t\t\t\t\t\tslotRequestId,\n-\t\t\t\t\t\t\t\t\tnew ScheduledUnit(\n-\t\t\t\t\t\t\t\t\t\texecutionVertexId,\n-\t\t\t\t\t\t\t\t\t\tslotSharingGroupId,\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n-\t\t\t\t\t\t\t\t\tSlotProfile.priorAllocation(\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getTaskResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n-\t\t\t\t\t\t\t\t\t\tpreferredLocations,\n-\t\t\t\t\t\t\t\t\t\tCollections.singletonList(schedulingRequirements.getPreviousAllocationId()),\n-\t\t\t\t\t\t\t\t\t\tallPreviousAllocationIds)));\n+\t\t\tfinal CompletableFuture<SlotProfile> slotProfileFuture = getSlotProfileFuture(\n+\t\t\t\tschedulingRequirements,\n+\t\t\t\tschedulingRequirements.getPhysicalSlotResourceProfile(),\n+\t\t\t\tCollections.emptySet(),\n+\t\t\t\tallPreviousAllocationIds);\n+\n+\t\t\tfinal CompletableFuture<LogicalSlot> slotFuture = slotProfileFuture.thenCompose(\n+\t\t\t\tslotProfile -> slotProviderStrategy.allocateSlot(\n+\t\t\t\t\tslotRequestId,\n+\t\t\t\t\tnew ScheduledUnit(\n+\t\t\t\t\t\texecutionVertexId,\n+\t\t\t\t\t\tslotSharingGroupId,\n+\t\t\t\t\t\tschedulingRequirements.getCoLocationConstraint()),\n+\t\t\t\t\tslotProfile));", "originalCommit": "8234b6b1b11b6d08879fed60abdfbc948894c59d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1OTQ3NA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438859474", "bodyText": "Yes it's good to have. done.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NjUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NzQyMQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438667421", "bodyText": "nit: constructor can be package-private", "author": "azagrebin", "createdAt": "2020-06-11T09:43:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/DefaultExecutionSlotAllocator.java", "diffHunk": "@@ -36,41 +35,28 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n-import java.util.stream.Collectors;\n \n import static org.apache.flink.util.Preconditions.checkNotNull;\n-import static org.apache.flink.util.Preconditions.checkState;\n \n /**\n  * Default {@link ExecutionSlotAllocator} which will use {@link SlotProvider} to allocate slots and\n  * keep the unfulfilled requests for further cancellation.\n  */\n-public class DefaultExecutionSlotAllocator implements ExecutionSlotAllocator {\n+public class DefaultExecutionSlotAllocator extends AbstractExecutionSlotAllocator {\n \n \tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultExecutionSlotAllocator.class);\n \n-\t/**\n-\t * Store the uncompleted slot assignments.\n-\t */\n-\tprivate final Map<ExecutionVertexID, SlotExecutionVertexAssignment> pendingSlotAssignments;\n-\n \tprivate final SlotProviderStrategy slotProviderStrategy;\n \n-\tprivate final PreferredLocationsRetriever preferredLocationsRetriever;\n-\n \tpublic DefaultExecutionSlotAllocator(\n \t\t\tfinal SlotProviderStrategy slotProviderStrategy,\n \t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever) {\n-\t\tthis.slotProviderStrategy = checkNotNull(slotProviderStrategy);\n-\t\tthis.preferredLocationsRetriever = checkNotNull(preferredLocationsRetriever);\n \n-\t\tpendingSlotAssignments = new HashMap<>();\n+\t\tsuper(preferredLocationsRetriever);", "originalCommit": "4866dbfb0920cc1a0cd7a9876810fa1fad4fc3c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1OTEzNA==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438859134", "bodyText": "Opened a separate hotfix to make DefaultExecutionSlotAllocator and its factory package private.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY2NzQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0NDY2MQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438744661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(\n          \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Collections.singletonList(", "author": "azagrebin", "createdAt": "2020-06-11T12:26:02Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocatorTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraint;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotTestUtils.createPhysicalSlot;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.createSchedulingRequirements;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.findSlotAssignmentByExecutionVertexId;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link OneSlotPerExecutionSlotAllocator}.\n+ */\n+public class OneSlotPerExecutionSlotAllocatorTest extends TestLogger {\n+\n+\tprivate TestingBulkSlotProvider slotProvider;\n+\n+\t@Before\n+\tpublic void setUp() throws Exception {\n+\t\tslotProvider = new TestingBulkSlotProvider();\n+\t}\n+\n+\t@Test\n+\tpublic void testSucceededSlotAllocation() {\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(1));\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getExecutionVertexId(), equalTo(executionVertexID));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailedSlotAllocation() {\n+\t\tfinal OneSlotPerExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tslotProvider.forceFailingSlotAllocation();\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(true));\n+\t\tassertThat(executionSlotAllocator.getPendingSlotAssignments().keySet(), hasSize(0));\n+\t\tassertThat(slotProvider.getCancelledSlotRequestIds(), contains(slotAssignment.getSlotRequestId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testInterBulkInputLocationPreferencesAreRespected() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForProducer =\n+\t\t\tcreateSchedulingRequirements(producerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForProducer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForProducer);\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignmentsForProducer);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForConsumer =\n+\t\t\tcreateSchedulingRequirements(consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForConsumer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForConsumer);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignmentsForConsumer);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(false));\n+\n+\t\tinputsLocationsRetriever.assignTaskManagerLocation(producerId);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testIntraBulkInputLocationPreferencesDoNotBlockAllocation() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(producerId, consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(2));\n+\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignments);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreatedSlotRequests() {\n+\t\tfinal ExecutionVertexID executionVertexId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal SlotSharingGroupId sharingGroupId = new SlotSharingGroupId();\n+\t\tfinal ResourceProfile taskResourceProfile = ResourceProfile.fromResources(0.5, 250);\n+\t\tfinal ResourceProfile physicalSlotResourceProfile = ResourceProfile.fromResources(1.0, 300);\n+\t\tfinal TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingStateLocationRetriever stateLocationRetriever = new TestingStateLocationRetriever();\n+\t\tstateLocationRetriever.setStateLocation(executionVertexId, taskManagerLocation);\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tstateLocationRetriever,\n+\t\t\tnew TestingInputsLocationsRetriever.Builder().build());\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(", "originalCommit": "fc243db69366bfc95c96a272936ebe30cbd6b26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1ODU5NQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438858595", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0NDY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0NDk0Mw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438744943", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(\n          \n          \n            \n            \t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Collections.singletonList(", "author": "azagrebin", "createdAt": "2020-06-11T12:26:39Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocatorTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.instance.SlotSharingGroupId;\n+import org.apache.flink.runtime.jobgraph.JobVertexID;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationConstraint;\n+import org.apache.flink.runtime.jobmanager.scheduler.CoLocationGroup;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotTestUtils.createPhysicalSlot;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.createSchedulingRequirements;\n+import static org.apache.flink.runtime.scheduler.ExecutionSlotAllocatorTestUtils.findSlotAssignmentByExecutionVertexId;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for {@link OneSlotPerExecutionSlotAllocator}.\n+ */\n+public class OneSlotPerExecutionSlotAllocatorTest extends TestLogger {\n+\n+\tprivate TestingBulkSlotProvider slotProvider;\n+\n+\t@Before\n+\tpublic void setUp() throws Exception {\n+\t\tslotProvider = new TestingBulkSlotProvider();\n+\t}\n+\n+\t@Test\n+\tpublic void testSucceededSlotAllocation() {\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(1));\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getExecutionVertexId(), equalTo(executionVertexID));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailedSlotAllocation() {\n+\t\tfinal OneSlotPerExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal ExecutionVertexID executionVertexID = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(executionVertexID);\n+\n+\t\tslotProvider.forceFailingSlotAllocation();\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tfinal SlotExecutionVertexAssignment slotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(executionVertexID, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(slotAssignment.getLogicalSlotFuture().isCompletedExceptionally(), is(true));\n+\t\tassertThat(executionSlotAllocator.getPendingSlotAssignments().keySet(), hasSize(0));\n+\t\tassertThat(slotProvider.getCancelledSlotRequestIds(), contains(slotAssignment.getSlotRequestId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testInterBulkInputLocationPreferencesAreRespected() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForProducer =\n+\t\t\tcreateSchedulingRequirements(producerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForProducer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForProducer);\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignmentsForProducer);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirementsForConsumer =\n+\t\t\tcreateSchedulingRequirements(consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignmentsForConsumer =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirementsForConsumer);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignmentsForConsumer);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(false));\n+\n+\t\tinputsLocationsRetriever.assignTaskManagerLocation(producerId);\n+\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testIntraBulkInputLocationPreferencesDoNotBlockAllocation() {\n+\t\tfinal ExecutionVertexID producerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal ExecutionVertexID consumerId = new ExecutionVertexID(new JobVertexID(), 0);\n+\n+\t\tfinal TestingInputsLocationsRetriever inputsLocationsRetriever = new TestingInputsLocationsRetriever.Builder()\n+\t\t\t.connectConsumerToProducer(consumerId, producerId)\n+\t\t\t.build();\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tnew TestingStateLocationRetriever(),\n+\t\t\tinputsLocationsRetriever);\n+\n+\t\tinputsLocationsRetriever.markScheduled(producerId);\n+\t\tinputsLocationsRetriever.markScheduled(consumerId);\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements =\n+\t\t\tcreateSchedulingRequirements(producerId, consumerId);\n+\t\tfinal Collection<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =\n+\t\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\n+\t\tassertThat(slotExecutionVertexAssignments, hasSize(2));\n+\n+\t\tfinal SlotExecutionVertexAssignment producerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(producerId, slotExecutionVertexAssignments);\n+\t\tfinal SlotExecutionVertexAssignment consumerSlotAssignment =\n+\t\t\tfindSlotAssignmentByExecutionVertexId(consumerId, slotExecutionVertexAssignments);\n+\n+\t\tassertThat(producerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t\tassertThat(consumerSlotAssignment.getLogicalSlotFuture().isDone(), is(true));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreatedSlotRequests() {\n+\t\tfinal ExecutionVertexID executionVertexId = new ExecutionVertexID(new JobVertexID(), 0);\n+\t\tfinal AllocationID allocationId = new AllocationID();\n+\t\tfinal SlotSharingGroupId sharingGroupId = new SlotSharingGroupId();\n+\t\tfinal ResourceProfile taskResourceProfile = ResourceProfile.fromResources(0.5, 250);\n+\t\tfinal ResourceProfile physicalSlotResourceProfile = ResourceProfile.fromResources(1.0, 300);\n+\t\tfinal TaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\n+\t\tfinal TestingStateLocationRetriever stateLocationRetriever = new TestingStateLocationRetriever();\n+\t\tstateLocationRetriever.setStateLocation(executionVertexId, taskManagerLocation);\n+\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator(\n+\t\t\tstateLocationRetriever,\n+\t\t\tnew TestingInputsLocationsRetriever.Builder().build());\n+\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(\n+\t\t\tnew ExecutionVertexSchedulingRequirements.Builder()\n+\t\t\t\t.withExecutionVertexId(executionVertexId)\n+\t\t\t\t.withPreviousAllocationId(allocationId)\n+\t\t\t\t.withSlotSharingGroupId(sharingGroupId)\n+\t\t\t\t.withPhysicalSlotResourceProfile(physicalSlotResourceProfile)\n+\t\t\t\t.withTaskResourceProfile(taskResourceProfile)\n+\t\t\t\t.build()\n+\t\t);\n+\n+\t\texecutionSlotAllocator.allocateSlotsFor(schedulingRequirements);\n+\t\tassertThat(slotProvider.getSlotRequests(), hasSize(1));\n+\n+\t\tfinal SlotProfile requestSlotProfile = slotProvider.getSlotRequests().iterator().next().getSlotProfile();\n+\n+\t\tassertThat(requestSlotProfile.getPreferredAllocations(), contains(allocationId));\n+\t\tassertThat(requestSlotProfile.getPreviousExecutionGraphAllocations(), contains(allocationId));\n+\t\tassertThat(requestSlotProfile.getTaskResourceProfile(), equalTo(taskResourceProfile));\n+\t\tassertThat(requestSlotProfile.getPreferredLocations(), contains(taskManagerLocation));\n+\t\t// task resource profile is used instead of slot sharing group resource profile since slot sharing is ignored\n+\t\tassertThat(requestSlotProfile.getPhysicalSlotResourceProfile(), equalTo(taskResourceProfile));\n+\t}\n+\n+\t@Test(expected = IllegalStateException.class)\n+\tpublic void testCoLocationConstraintThrowsException() {\n+\t\tfinal ExecutionSlotAllocator executionSlotAllocator = createExecutionSlotAllocator();\n+\n+\t\tfinal CoLocationConstraint coLocationConstraint = new CoLocationGroup().getLocationConstraint(0);\n+\t\tfinal List<ExecutionVertexSchedulingRequirements> schedulingRequirements = Arrays.asList(", "originalCommit": "fc243db69366bfc95c96a272936ebe30cbd6b26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1ODUzMw==", "url": "https://github.com/apache/flink/pull/12256#discussion_r438858533", "bodyText": "done.", "author": "zhuzhurk", "createdAt": "2020-06-11T15:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0NDk0Mw=="}], "type": "inlineReview"}, {"oid": "41bc7222db9beee142d3b0e80f51ec8fd80c60a6", "url": "https://github.com/apache/flink/commit/41bc7222db9beee142d3b0e80f51ec8fd80c60a6", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator", "committedDate": "2020-06-11T15:10:30Z", "type": "forcePushed"}, {"oid": "a751c48402cd2c23dabb4ebf21fc85e3f0d23b9f", "url": "https://github.com/apache/flink/commit/a751c48402cd2c23dabb4ebf21fc85e3f0d23b9f", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator", "committedDate": "2020-06-12T10:38:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5OTc1Ng==", "url": "https://github.com/apache/flink/pull/12256#discussion_r440199756", "bodyText": "Thanks for the fix @zhuzhurk\nI am wondering whether we need slotRequestId in SlotExecutionVertexAssignment.\nIf we make slotExecutionVertexAssignments LinkedHashMap<SlotRequestId, SlotExecutionVertexAssignment> and return new ArrayList<>(slotExecutionVertexAssignments.values()), we also do not need requestToAssignmentMapping in allocateSlotsForAssignments as it can be slotExecutionVertexAssignments.ketSet().\nIn tests, we could capture SlotRequestId from slotProvider.getSlotRequests/getSlotAllocationRequests.\nDoes it makes sense?", "author": "azagrebin", "createdAt": "2020-06-15T14:04:37Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/scheduler/OneSlotPerExecutionSlotAllocator.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.scheduler;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.SlotProfile;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.Locality;\n+import org.apache.flink.runtime.jobmaster.LogicalSlot;\n+import org.apache.flink.runtime.jobmaster.SlotOwner;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.jobmaster.slotpool.BulkSlotProvider;\n+import org.apache.flink.runtime.jobmaster.slotpool.PhysicalSlotRequest;\n+import org.apache.flink.runtime.jobmaster.slotpool.SingleLogicalSlot;\n+import org.apache.flink.runtime.jobmaster.slotpool.SlotProvider;\n+import org.apache.flink.runtime.scheduler.strategy.ExecutionVertexID;\n+import org.apache.flink.util.FlinkException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * This slot allocator will request one physical slot for each single execution vertex.\n+ * The slots will be requested in bulks so that the {@link SlotProvider} can check\n+ * whether this bulk of slot requests can be fulfilled at the same time.\n+ * It has several limitations:\n+ *\n+ * <p>1. Slot sharing will be ignored.\n+ *\n+ * <p>2. Co-location constraints are not allowed.\n+ *\n+ * <p>3. Intra-bulk input location preferences will be ignored.\n+ */\n+class OneSlotPerExecutionSlotAllocator extends AbstractExecutionSlotAllocator implements SlotOwner {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(OneSlotPerExecutionSlotAllocator.class);\n+\n+\tprivate final BulkSlotProvider slotProvider;\n+\n+\tprivate final boolean slotWillBeOccupiedIndefinitely;\n+\n+\tprivate final Time allocationTimeout;\n+\n+\tOneSlotPerExecutionSlotAllocator(\n+\t\t\tfinal BulkSlotProvider slotProvider,\n+\t\t\tfinal PreferredLocationsRetriever preferredLocationsRetriever,\n+\t\t\tfinal boolean slotWillBeOccupiedIndefinitely,\n+\t\t\tfinal Time allocationTimeout) {\n+\n+\t\tsuper(preferredLocationsRetriever);\n+\n+\t\tthis.slotProvider = checkNotNull(slotProvider);\n+\t\tthis.slotWillBeOccupiedIndefinitely = slotWillBeOccupiedIndefinitely;\n+\t\tthis.allocationTimeout = checkNotNull(allocationTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic List<SlotExecutionVertexAssignment> allocateSlotsFor(\n+\t\t\tfinal List<ExecutionVertexSchedulingRequirements> executionVertexSchedulingRequirements) {\n+\n+\t\tvalidateSchedulingRequirements(executionVertexSchedulingRequirements);\n+\n+\t\tvalidateNoCoLocationConstraint(executionVertexSchedulingRequirements);\n+\n+\t\tfinal List<SlotExecutionVertexAssignment> slotExecutionVertexAssignments =", "originalCommit": "cdb2b1d720afc0866f6a1e95eb7c74022f135ada", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0MzYxMQ==", "url": "https://github.com/apache/flink/pull/12256#discussion_r440243611", "bodyText": "The main problem is that the result list order will not match the given list order if we use new ArrayList<>(slotExecutionVertexAssignments.values()).", "author": "zhuzhurk", "createdAt": "2020-06-15T15:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5OTc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NjIyNg==", "url": "https://github.com/apache/flink/pull/12256#discussion_r440286226", "bodyText": "Just realized you proposed LinkedHashMap. It should work. done.", "author": "zhuzhurk", "createdAt": "2020-06-15T16:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5OTc1Ng=="}], "type": "inlineReview"}, {"oid": "1253ab0db340f4d3aac238a3c2bc8f8f4abb6941", "url": "https://github.com/apache/flink/commit/1253ab0db340f4d3aac238a3c2bc8f8f4abb6941", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment", "committedDate": "2020-06-15T16:03:55Z", "type": "forcePushed"}, {"oid": "2ceab54742dfb188455fc7592a8a4b026323a983", "url": "https://github.com/apache/flink/commit/2ceab54742dfb188455fc7592a8a4b026323a983", "message": "[hotfix][runtime] Move shared static test methods of physical slot into PhysicalSlotTestUtils", "committedDate": "2020-06-16T02:55:43Z", "type": "commit"}, {"oid": "952b25c2f99830867e41a843a963f5582a593cb8", "url": "https://github.com/apache/flink/commit/952b25c2f99830867e41a843a963f5582a593cb8", "message": "[hotfix][runtime] Move shared static test methods of slot allocator into ExecutionSlotAllocatorTestUtils", "committedDate": "2020-06-16T02:55:43Z", "type": "commit"}, {"oid": "a637f6415f4f46bc9cc576e0a170cab37266c17a", "url": "https://github.com/apache/flink/commit/a637f6415f4f46bc9cc576e0a170cab37266c17a", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment", "committedDate": "2020-06-16T02:55:44Z", "type": "forcePushed"}, {"oid": "fd6650187ebbbd75dd84d6481a8a2161d7499490", "url": "https://github.com/apache/flink/commit/fd6650187ebbbd75dd84d6481a8a2161d7499490", "message": "[FLINK-17018][runtime] Extract common logics of DefaultExecutionSlotAllocator into AbstractExecutionSlotAllocator", "committedDate": "2020-06-16T04:02:29Z", "type": "commit"}, {"oid": "df1096a06d6a1b7970a590207517d875d6b994f7", "url": "https://github.com/apache/flink/commit/df1096a06d6a1b7970a590207517d875d6b994f7", "message": "[FLINK-17018][runtime] Introduce OneSlotPerExecutionSlotAllocator which will request one physical slot for each single execution vertex\n\nOneSlotPerExecutionSlotAllocator allocates slots in bulks so that the SlotProvider can check whether this bulk of slot requests can be fulfilled at the same time.\nIt has several limitations:\n1. Slot sharing will be ignored.\n2. Co-location constraints are not allowed.\n3. Intra-bulk input location preferences will be ignored.", "committedDate": "2020-06-16T04:02:31Z", "type": "commit"}, {"oid": "66694a74f8d8f8cb6379b98858b13ba3e16425fd", "url": "https://github.com/apache/flink/commit/66694a74f8d8f8cb6379b98858b13ba3e16425fd", "message": "[FLINK-17018][runtime] Use OneSlotPerExecutionSlotAllocator on pipelined region scheduling", "committedDate": "2020-06-16T04:02:32Z", "type": "commit"}, {"oid": "000efff83037daa2fc15fbc8768f9a6e0e407767", "url": "https://github.com/apache/flink/commit/000efff83037daa2fc15fbc8768f9a6e0e407767", "message": "[hotfix][runtime] Narrow down the access scope of DefaultExecutionSlotAllocator", "committedDate": "2020-06-16T04:02:33Z", "type": "commit"}, {"oid": "3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "url": "https://github.com/apache/flink/commit/3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment", "committedDate": "2020-06-16T04:02:34Z", "type": "commit"}, {"oid": "3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "url": "https://github.com/apache/flink/commit/3e1f4485f91ab4c5537c5b6f3170391f25258f9a", "message": "[hotfix][runtime] Narrow down the access scope of SlotExecutionVertexAssignment", "committedDate": "2020-06-16T04:02:34Z", "type": "forcePushed"}]}