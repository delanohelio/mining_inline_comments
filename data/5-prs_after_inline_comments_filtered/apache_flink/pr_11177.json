{"pr_number": 11177, "pr_title": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.", "pr_createdAt": "2020-02-21T15:37:59Z", "pr_url": "https://github.com/apache/flink/pull/11177", "timeline": [{"oid": "61b28a39aa682892a746495931949ab20dd1979c", "url": "https://github.com/apache/flink/commit/61b28a39aa682892a746495931949ab20dd1979c", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.", "committedDate": "2020-02-21T15:39:21Z", "type": "forcePushed"}, {"oid": "3d36bd3136fd8b56ee367ee29dc9c92beaf4542a", "url": "https://github.com/apache/flink/commit/3d36bd3136fd8b56ee367ee29dc9c92beaf4542a", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.", "committedDate": "2020-02-21T19:58:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383135416", "bodyText": "Why can not we move headOperator.getChainingStrategy() != ChainingStrategy.NEVER into the canBeChainedTo(headOperator) call/check?", "author": "pnowojski", "createdAt": "2020-02-24T08:46:11Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDA0NQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384320045", "bodyText": "A different question imho. First, is upstream supporting chaining at all? Second, is this specific downstream chainable to the upstream.", "author": "AHeise", "createdAt": "2020-02-26T07:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0Nzk1NA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384347954", "bodyText": "I would prefer to have one method to rule them all (to have one definite answer how to handle the chaining strategy), but as you prefer.", "author": "pnowojski", "createdAt": "2020-02-26T08:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNTQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzA1Mg==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383137052", "bodyText": "headOperator is a misnomer, as it's not always \"head\". It's just previous/up stream operator.  So at least headOperator -> upStreamOperator ?\nHowever, also maybe optional/subjective, I would expect the call be here head chained with next instead of next chained to head:\nheadOperator.getChainingStrategy().canBeChainedWith/canBeChainedTo(outOperator)\n\nas that's usually how lists/chains are being constructed/traversed - head to tail, so maybe:\ncanBeChainedWith(StreamOperatorFactory<?> downStreamOperator)\n\nafter all?", "author": "pnowojski", "createdAt": "2020-02-24T08:50:33Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTY3OQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384319679", "bodyText": "Renamed vars in a separate hotfix.\nFor the remainder naming, I think it's the other way around. If I construct head to tail, I'd ask can this node by chained to the head?", "author": "AHeise", "createdAt": "2020-02-26T07:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEzNzk3OA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383137978", "bodyText": "Can we add a test coverage in StreamingJobGraphGeneratorTest?", "author": "pnowojski", "createdAt": "2020-02-24T08:52:44Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -602,9 +602,8 @@ public static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\t\t\t&& outOperator != null\n \t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& outOperator.getChainingStrategy().canBeChainedTo(headOperator)\n+\t\t\t\t&& headOperator.getChainingStrategy() != ChainingStrategy.NEVER", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MDcyMA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383140720", "bodyText": "Do we need this enum? Can not we replace HEAD_AFTER_LEGACY_SOURCE with a check if that we are in a legacy source task and the downStreamOpeartor instanceof YieldingOperatorFactory?", "author": "pnowojski", "createdAt": "2020-02-24T08:58:57Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAwMQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384319001", "bodyText": "Is yielding the root cause of not chainable to legacy sources? If so, then this is a valid way.\nI'm concerned though that we also disallow chaining of operators that just need access to the mailboxExecutor for submit.", "author": "AHeise", "createdAt": "2020-02-26T07:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MDcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MTE1Mg==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383141152", "bodyText": "Is it working properly? What if we have StreamSource -> OP2 -> OP3 -> AsyncWaitOperator?", "author": "pnowojski", "createdAt": "2020-02-24T09:00:03Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/operators/ChainingStrategy.java", "diffHunk": "@@ -38,16 +38,46 @@\n \t * <p>To optimize performance, it is generally a good practice to allow maximal\n \t * chaining and increase operator parallelism.\n \t */\n-\tALWAYS,\n+\tALWAYS {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn true;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the preceding or succeeding operators.\n \t */\n-\tNEVER,\n+\tNEVER {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n \n \t/**\n \t * The operator will not be chained to the predecessor, but successors may chain to this\n \t * operator.\n \t */\n-\tHEAD\n+\tHEAD {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn false;\n+\t\t}\n+\t},\n+\n+\t/**\n+\t * Operators will be eagerly chained whenever possible, except after legacy sources.\n+\t *\n+\t * <p>Operators that will not properly when processInput is called from another thread, must use this strategy\n+\t * instead of {@link #ALWAYS}.\n+\t */\n+\tHEAD_AFTER_LEGACY_SOURCE {\n+\t\t@Override\n+\t\tpublic boolean canBeChainedTo(StreamOperatorFactory<?> headOperator) {\n+\t\t\treturn !headOperator.isStreamSource();\n+\t\t}\n+\t};\n+\n+\tpublic abstract boolean canBeChainedTo(StreamOperatorFactory<?> headOperator);", "originalCommit": "7582e3e57ae14236024663a57a82cad7929be085", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODY0MQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384318641", "bodyText": "It was not. Good catch.", "author": "AHeise", "createdAt": "2020-02-26T07:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE0MjEyMA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r383142120", "bodyText": "add a simple mapping function?\ninput = chainEnv.fromElements(1).map(....);", "author": "pnowojski", "createdAt": "2020-02-24T09:02:23Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/async/AsyncWaitOperatorTest.java", "diffHunk": "@@ -365,10 +365,10 @@ private void testProcessingTime(AsyncDataStream.OutputMode mode) throws Exceptio\n \t}\n \n \t/**\n-\t * Test for the temporary fix to FLINK-13063.\n+\t * Tests FLINK-16219.\n \t */\n \t@Test\n-\tpublic void testAsyncOperatorIsNeverChained() {\n+\tpublic void testAsyncOperatorIsNotChainedToSources() {\n \t\tStreamExecutionEnvironment chainEnv = StreamExecutionEnvironment.getExecutionEnvironment();\n \n \t\tDataStream<Integer> input = chainEnv.fromElements(1);", "originalCommit": "3d36bd3136fd8b56ee367ee29dc9c92beaf4542a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "42f920ac137b14f43923fcee4677dc57c849fac2", "url": "https://github.com/apache/flink/commit/42f920ac137b14f43923fcee4677dc57c849fac2", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.", "committedDate": "2020-02-26T07:44:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM0ODg2MQ==", "url": "https://github.com/apache/flink/pull/11177#discussion_r384348861", "bodyText": "nit: downstream -> downStream & upstream -> upStream. I quickly git grepped the code, and downstream is only used in text/docs. downStream is used in the code.", "author": "pnowojski", "createdAt": "2020-02-26T08:56:10Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -542,14 +542,14 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \n \t\tphysicalEdgesInOrder.add(edge);\n \n-\t\tInteger downStreamvertexID = edge.getTargetId();\n+\t\tInteger downstreamVertexID = edge.getTargetId();", "originalCommit": "1cab8f3199f86009056903418dc31e20313cae21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "37d4a094fe466a22c2f3cc07a73d361a43928404", "url": "https://github.com/apache/flink/commit/37d4a094fe466a22c2f3cc07a73d361a43928404", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-26T09:16:56Z", "type": "forcePushed"}, {"oid": "810b12ab01637f7d70d091922ba9cbf9bc45680e", "url": "https://github.com/apache/flink/commit/810b12ab01637f7d70d091922ba9cbf9bc45680e", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-26T09:21:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwNDU1NA==", "url": "https://github.com/apache/flink/pull/11177#discussion_r385604554", "bodyText": "Can we unit test this method assuming that StreamNode and StreamGraph are easy to construct/mock?", "author": "pnowojski", "createdAt": "2020-02-28T09:59:02Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/graph/StreamingJobGraphGenerator.java", "diffHunk": "@@ -587,30 +588,54 @@ private void connect(Integer headOfChain, StreamEdge edge) {\n \n \t\tif (LOG.isDebugEnabled()) {\n \t\t\tLOG.debug(\"CONNECTED: {} - {} -> {}\", partitioner.getClass().getSimpleName(),\n-\t\t\t\t\theadOfChain, downStreamvertexID);\n+\t\t\t\t\theadOfChain, downStreamVertexID);\n \t\t}\n \t}\n \n \tpublic static boolean isChainable(StreamEdge edge, StreamGraph streamGraph) {\n \t\tStreamNode upStreamVertex = streamGraph.getSourceVertex(edge);\n \t\tStreamNode downStreamVertex = streamGraph.getTargetVertex(edge);\n \n-\t\tStreamOperatorFactory<?> headOperator = upStreamVertex.getOperatorFactory();\n-\t\tStreamOperatorFactory<?> outOperator = downStreamVertex.getOperatorFactory();\n-\n \t\treturn downStreamVertex.getInEdges().size() == 1\n-\t\t\t\t&& outOperator != null\n-\t\t\t\t&& headOperator != null\n \t\t\t\t&& upStreamVertex.isSameSlotSharingGroup(downStreamVertex)\n-\t\t\t\t&& outOperator.getChainingStrategy() == ChainingStrategy.ALWAYS\n-\t\t\t\t&& (headOperator.getChainingStrategy() == ChainingStrategy.HEAD ||\n-\t\t\t\t\theadOperator.getChainingStrategy() == ChainingStrategy.ALWAYS)\n+\t\t\t\t&& areOperatorsChainable(upStreamVertex, downStreamVertex, streamGraph)\n \t\t\t\t&& (edge.getPartitioner() instanceof ForwardPartitioner)\n \t\t\t\t&& edge.getShuffleMode() != ShuffleMode.BATCH\n \t\t\t\t&& upStreamVertex.getParallelism() == downStreamVertex.getParallelism()\n \t\t\t\t&& streamGraph.isChainingEnabled();\n \t}\n \n+\tprivate static boolean areOperatorsChainable(", "originalCommit": "810b12ab01637f7d70d091922ba9cbf9bc45680e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9918bd9191889dbc5a65c2f2982b4140b320bf99", "url": "https://github.com/apache/flink/commit/9918bd9191889dbc5a65c2f2982b4140b320bf99", "message": "[hotfix][runtime] Removed duplicate isChainable.", "committedDate": "2020-02-28T14:39:47Z", "type": "commit"}, {"oid": "e9323852743d7fc32c6abd787f63fa5705eea530", "url": "https://github.com/apache/flink/commit/e9323852743d7fc32c6abd787f63fa5705eea530", "message": "[hotfix][runtime] Unified variable names in StreamingJobGraphGenerator.\n\nRemoved confusing headOperators in isChainable.", "committedDate": "2020-02-28T14:39:47Z", "type": "commit"}, {"oid": "613acf26bdd79ea6c10fb3b3ae8fe27376b5b259", "url": "https://github.com/apache/flink/commit/613acf26bdd79ea6c10fb3b3ae8fe27376b5b259", "message": "[FLINK-16219][runtime] Disallow chaining of legacy source and yielding operator.\n\nThis change allows yielding operators to be eagerly chained whenever possible, except after legacy sources.\nYielding operators do not properly work when processInput is called from another thread, but are usually fine in any other chain.", "committedDate": "2020-02-28T14:41:00Z", "type": "commit"}, {"oid": "c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "url": "https://github.com/apache/flink/commit/c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-28T14:41:00Z", "type": "commit"}, {"oid": "c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "url": "https://github.com/apache/flink/commit/c8e0d15b1c909c2aa6a936f504d97ff0bd10303b", "message": "[FLINK-16219][runtime] Made AsyncWaitOperator chainable to non-sources.\n\nAsyncWaitOperator is not thread-safe when chained to legacy sources, but works well in a chained fashion in all other cases.\nMoved test case to StreamingJobGraphGenerator.", "committedDate": "2020-02-28T14:41:00Z", "type": "forcePushed"}]}