{"pr_number": 13692, "pr_title": "[FLINK-19624][table-planner-blink] Update deadlock break-up algorithm to cover more cases", "pr_createdAt": "2020-10-20T02:13:22Z", "pr_url": "https://github.com/apache/flink/pull/13692", "timeline": [{"oid": "80a4b375924b045454e04c75ab199e7da5876392", "url": "https://github.com/apache/flink/commit/80a4b375924b045454e04c75ab199e7da5876392", "message": "[FLINK-19624][table-planner-blink] Update deadlock break-up algorithm to cover more cases", "committedDate": "2020-10-20T02:05:54Z", "type": "commit"}, {"oid": "a43126b85a2068c5605a804b5c46d5c3e669dbbd", "url": "https://github.com/apache/flink/commit/a43126b85a2068c5605a804b5c46d5c3e669dbbd", "message": "[fix] Fix checkstyle", "committedDate": "2020-10-20T03:19:02Z", "type": "commit"}, {"oid": "22cf14c8194ecbb1811caf7bddf03641bf82c1d3", "url": "https://github.com/apache/flink/commit/22cf14c8194ecbb1811caf7bddf03641bf82c1d3", "message": "[fix] Fix scalastyle", "committedDate": "2020-10-20T07:42:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAzNzc0NA==", "url": "https://github.com/apache/flink/pull/13692#discussion_r509037744", "bodyText": "make this pojo stateless, we can use a map to represent the usage of the tag", "author": "godfreyhe", "createdAt": "2020-10-21T07:08:13Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/reuse/InputPriorityConflictResolver.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.reuse;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.streaming.api.datastream.DataStream;\n+import org.apache.flink.streaming.api.transformations.ShuffleMode;\n+import org.apache.flink.table.planner.plan.nodes.exec.AbstractExecNodeExactlyOnceVisitor;\n+import org.apache.flink.table.planner.plan.nodes.exec.BatchExecNode;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecEdge;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecNode;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecBoundedStreamScan;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecExchange;\n+import org.apache.flink.table.planner.plan.trait.FlinkRelDistribution;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+/**\n+ * This class contains algorithm to detect and resolve input priority conflict in an {@link ExecNode} graph.\n+ *\n+ * <p>Some batch operators (for example, hash join and nested loop join) have different priorities for their inputs.\n+ * When some operators are reused, a deadlock may occur due to the conflict in these priorities.\n+ *\n+ * <p>For example, consider the SQL query:\n+ * <pre>\n+ * WITH\n+ *   T1 AS (SELECT a, COUNT(*) AS cnt1 FROM x GROUP BY a),\n+ *   T2 AS (SELECT d, COUNT(*) AS cnt2 FROM y GROUP BY d)\n+ * SELECT * FROM\n+ *   (SELECT cnt1, cnt2 FROM T1 LEFT JOIN T2 ON a = d)\n+ *   UNION ALL\n+ *   (SELECT cnt1, cnt2 FROM T2 LEFT JOIN T1 ON d = a)\n+ * </pre>\n+ *\n+ * <p>When sub-plan reuse are enabled, we'll get the following physical plan:\n+ * <pre>\n+ * Union(all=[true], union=[cnt1, cnt2])\n+ * :- Calc(select=[CAST(cnt1) AS cnt1, cnt2])\n+ * :  +- HashJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, cnt1, d, cnt2], build=[right])\n+ * :     :- HashAggregate(isMerge=[true], groupBy=[a], select=[a, Final_COUNT(count1$0) AS cnt1], reuse_id=[2])\n+ * :     :  +- Exchange(distribution=[hash[a]])\n+ * :     :     +- LocalHashAggregate(groupBy=[a], select=[a, Partial_COUNT(*) AS count1$0])\n+ * :     :        +- Calc(select=[a])\n+ * :     :           +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])\n+ * :     +- HashAggregate(isMerge=[true], groupBy=[d], select=[d, Final_COUNT(count1$0) AS cnt2], reuse_id=[1])\n+ * :        +- Exchange(distribution=[hash[d]])\n+ * :           +- LocalHashAggregate(groupBy=[d], select=[d, Partial_COUNT(*) AS count1$0])\n+ * :              +- Calc(select=[d])\n+ * :                 +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f)]]], fields=[d, e, f])\n+ * +- Calc(select=[cnt1, CAST(cnt2) AS cnt2])\n+ *    +- HashJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, cnt2, a, cnt1], build=[right])\n+ *       :- Reused(reference_id=[1])\n+ *       +- Reused(reference_id=[2])\n+ * </pre>\n+ *\n+ * <p>Note that the first hash join needs to read all results from the hash aggregate whose reuse id is 1\n+ * before reading the results from the hash aggregate whose reuse id is 2, while the second hash join requires\n+ * the opposite. This physical plan will thus cause a deadlock.\n+ *\n+ * <p>This class maintains a topological graph in which an edge pointing from vertex A to vertex B indicates\n+ * that the results from vertex A need to be read before those from vertex B. A loop in the graph indicates\n+ * a deadlock, and we resolve such deadlock by inserting a {@link BatchExecExchange} with batch shuffle mode.\n+ *\n+ * <p>For a detailed explanation of the algorithm, see appendix of the\n+ * <a href=\"https://docs.google.com/document/d/1qKVohV12qn-bM51cBZ8Hcgp31ntwClxjoiNBUOqVHsI\">design doc</a>.\n+ */\n+@Internal\n+public class InputPriorityConflictResolver {\n+\n+\tprivate final List<ExecNode<?, ?>> sinks;\n+\n+\tprivate TopologyGraph graph;\n+\n+\tpublic InputPriorityConflictResolver(List<ExecNode<?, ?>> sinks) {\n+\t\tPreconditions.checkArgument(\n+\t\t\tsinks.stream().allMatch(sink -> sink instanceof BatchExecNode),\n+\t\t\t\"InputPriorityConflictResolver can only be used for batch jobs.\");\n+\t\tthis.sinks = sinks;\n+\t}\n+\n+\tpublic void detectAndResolve() {\n+\t\t// build an initial topology graph\n+\t\tgraph = new TopologyGraph(sinks);\n+\n+\t\t// check and resolve conflicts about input priorities\n+\t\tAbstractExecNodeExactlyOnceVisitor inputPriorityVisitor = new AbstractExecNodeExactlyOnceVisitor() {\n+\t\t\t@Override\n+\t\t\tprotected void visitNode(ExecNode<?, ?> node) {\n+\t\t\t\tvisitInputs(node);\n+\t\t\t\tcheckInputPriorities(node);\n+\t\t\t}\n+\t\t};\n+\t\tsinks.forEach(n -> n.accept(inputPriorityVisitor));\n+\t}\n+\n+\tprivate void checkInputPriorities(ExecNode<?, ?> node) {\n+\t\t// group inputs by input priorities\n+\t\tTreeMap<Integer, List<Integer>> inputPriorityGroupMap = new TreeMap<>();\n+\t\tPreconditions.checkState(\n+\t\t\tnode.getInputNodes().size() == node.getInputEdges().size(),\n+\t\t\t\"Number of inputs nodes does not equal to number of input edges for node \" +\n+\t\t\t\tnode.getClass().getName() + \". This is a bug.\");\n+\t\tfor (int i = 0; i < node.getInputNodes().size(); i++) {\n+\t\t\tint priority = node.getInputEdges().get(i).getPriority();\n+\t\t\tinputPriorityGroupMap.computeIfAbsent(priority, k -> new ArrayList<>()).add(i);\n+\t\t}\n+\n+\t\t// add edges between neighboring priority groups\n+\t\tList<List<Integer>> inputPriorityGroups = new ArrayList<>(inputPriorityGroupMap.values());\n+\t\tfor (int i = 0; i + 1 < inputPriorityGroups.size(); i++) {\n+\t\t\tList<Integer> higherGroup = inputPriorityGroups.get(i);\n+\t\t\tList<Integer> lowerGroup = inputPriorityGroups.get(i + 1);\n+\n+\t\t\tfor (int higher : higherGroup) {\n+\t\t\t\tfor (int lower : lowerGroup) {\n+\t\t\t\t\taddTopologyEdges(node, higher, lower);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void addTopologyEdges(ExecNode<?, ?> node, int higherInput, int lowerInput) {\n+\t\tExecNode<?, ?> higherNode = node.getInputNodes().get(higherInput);\n+\t\tExecNode<?, ?> lowerNode = node.getInputNodes().get(lowerInput);\n+\t\tList<ExecNode<?, ?>> lowerAncestors = calculateAncestors(lowerNode);\n+\n+\t\tList<Tuple2<ExecNode<?, ?>, ExecNode<?, ?>>> linkedEdges = new ArrayList<>();\n+\t\tfor (ExecNode<?, ?> ancestor : lowerAncestors) {\n+\t\t\tif (graph.link(higherNode, ancestor)) {\n+\t\t\t\tlinkedEdges.add(Tuple2.of(higherNode, ancestor));\n+\t\t\t} else {\n+\t\t\t\t// a conflict occurs, resolve it by adding a batch exchange\n+\t\t\t\t// and revert all linked edges\n+\t\t\t\tif (lowerNode instanceof BatchExecExchange) {\n+\t\t\t\t\tBatchExecExchange exchange = (BatchExecExchange) lowerNode;\n+\t\t\t\t\texchange.setRequiredShuffleMode(ShuffleMode.BATCH);\n+\t\t\t\t} else {\n+\t\t\t\t\tnode.replaceInputNode(lowerInput, (ExecNode) createExchange(node, lowerInput));\n+\t\t\t\t}\n+\n+\t\t\t\tfor (Tuple2<ExecNode<?, ?>, ExecNode<?, ?>> linkedEdge : linkedEdges) {\n+\t\t\t\t\tgraph.unlink(linkedEdge.f0, linkedEdge.f1);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Find the ancestors by going through PIPELINED edges.\n+\t */\n+\t@VisibleForTesting\n+\tList<ExecNode<?, ?>> calculateAncestors(ExecNode<?, ?> node) {\n+\t\tList<ExecNode<?, ?>> ret = new ArrayList<>();\n+\t\tAbstractExecNodeExactlyOnceVisitor ancestorVisitor = new AbstractExecNodeExactlyOnceVisitor() {\n+\t\t\t@Override\n+\t\t\tprotected void visitNode(ExecNode<?, ?> node) {\n+\t\t\t\tList<ExecEdge> inputEdges = node.getInputEdges();\n+\t\t\t\tboolean hasAncestor = false;\n+\n+\t\t\t\tfor (int i = 0; i < inputEdges.size(); i++) {\n+\t\t\t\t\t// we only go through PIPELINED edges\n+\t\t\t\t\tif (inputEdges.get(i).getDamBehavior().stricterOrEqual(ExecEdge.DamBehavior.END_INPUT)) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\thasAncestor = true;\n+\t\t\t\t\tnode.getInputNodes().get(i).accept(this);\n+\t\t\t\t}\n+\n+\t\t\t\tif (!hasAncestor) {\n+\t\t\t\t\tret.add(node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\tnode.accept(ancestorVisitor);\n+\t\treturn ret;\n+\t}\n+\n+\tprivate BatchExecExchange createExchange(ExecNode<?, ?> node, int idx) {\n+\t\tRelNode inputRel = (RelNode) node.getInputNodes().get(idx);\n+\n+\t\tFlinkRelDistribution distribution;\n+\t\tExecEdge.RequiredShuffle requiredShuffle = node.getInputEdges().get(idx).getRequiredShuffle();\n+\t\tif (requiredShuffle.getType() == ExecEdge.ShuffleType.HASH) {\n+\t\t\tdistribution = FlinkRelDistribution.hash(requiredShuffle.getKeys(), true);\n+\t\t} else if (requiredShuffle.getType() == ExecEdge.ShuffleType.BROADCAST) {\n+\t\t\t// should not occur\n+\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\"Trying to resolve input priority conflict on broadcast side. This is not expected.\");\n+\t\t} else if (requiredShuffle.getType() == ExecEdge.ShuffleType.SINGLETON) {\n+\t\t\tdistribution = FlinkRelDistribution.SINGLETON();\n+\t\t} else {\n+\t\t\tdistribution = FlinkRelDistribution.ANY();\n+\t\t}\n+\n+\t\tBatchExecExchange exchange = new BatchExecExchange(\n+\t\t\tinputRel.getCluster(),\n+\t\t\tinputRel.getTraitSet().replace(distribution),\n+\t\t\tinputRel,\n+\t\t\tdistribution);\n+\t\texchange.setRequiredShuffleMode(ShuffleMode.BATCH);\n+\t\treturn exchange;\n+\t}\n+\n+\t/**\n+\t * A data structure storing the topological information of an {@link ExecNode} graph.\n+\t */\n+\t@VisibleForTesting\n+\tstatic class TopologyGraph {\n+\t\tprivate final Map<ExecNode<?, ?>, TopologyNode> nodes;\n+\t\tprivate int visitTag;\n+\n+\t\tTopologyGraph(List<ExecNode<?, ?>> sinks) {\n+\t\t\tthis.nodes = new HashMap<>();\n+\t\t\tthis.visitTag = 0;\n+\n+\t\t\t// we first link all edges in the original exec node graph\n+\t\t\tAbstractExecNodeExactlyOnceVisitor visitor = new AbstractExecNodeExactlyOnceVisitor() {\n+\t\t\t\t@Override\n+\t\t\t\tprotected void visitNode(ExecNode<?, ?> node) {\n+\t\t\t\t\tfor (ExecNode<?, ?> input : node.getInputNodes()) {\n+\t\t\t\t\t\tlink(input, node);\n+\t\t\t\t\t}\n+\t\t\t\t\tvisitInputs(node);\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tsinks.forEach(n -> n.accept(visitor));\n+\t\t}\n+\n+\t\t/**\n+\t\t * Link an edge from `from` node to `to` node if no loop will occur after adding this edge.\n+\t\t * Returns if this edge is successfully added.\n+\t\t */\n+\t\tboolean link(ExecNode<?, ?> from, ExecNode<?, ?> to) {\n+\t\t\tTopologyNode fromNode = getTopologyNode(from);\n+\t\t\tTopologyNode toNode = getTopologyNode(to);\n+\n+\t\t\tif (canReach(toNode, fromNode)) {\n+\t\t\t\t// invalid edge, as `to` is the predecessor of `from`\n+\t\t\t\treturn false;\n+\t\t\t} else {\n+\t\t\t\t// link `from` and `to`\n+\t\t\t\tfromNode.outputs.add(toNode);\n+\t\t\t\ttoNode.inputs.add(fromNode);\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Remove the edge from `from` node to `to` node. If there is no edge between them then do nothing.\n+\t\t */\n+\t\tvoid unlink(ExecNode<?, ?> from, ExecNode<?, ?> to) {\n+\t\t\tTopologyNode fromNode = getTopologyNode(from);\n+\t\t\tTopologyNode toNode = getTopologyNode(to);\n+\n+\t\t\tfromNode.outputs.remove(toNode);\n+\t\t\ttoNode.inputs.remove(fromNode);\n+\t\t}\n+\n+\t\t@VisibleForTesting\n+\t\tboolean canReach(ExecNode<?, ?> from, ExecNode<?, ?> to) {\n+\t\t\tTopologyNode fromNode = getTopologyNode(from);\n+\t\t\tTopologyNode toNode = getTopologyNode(to);\n+\t\t\treturn canReach(fromNode, toNode);\n+\t\t}\n+\n+\t\tprivate boolean canReach(TopologyNode from, TopologyNode to) {\n+\t\t\tQueue<TopologyNode> queue = new LinkedList<>();\n+\t\t\tfrom.tag = --visitTag;\n+\t\t\tqueue.offer(from);\n+\n+\t\t\twhile (!queue.isEmpty()) {\n+\t\t\t\tTopologyNode node = queue.poll();\n+\t\t\t\tif (to.equals(node)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\n+\t\t\t\tfor (TopologyNode next : node.outputs) {\n+\t\t\t\t\tif (next.tag == visitTag) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\tnext.tag = visitTag;\n+\t\t\t\t\tqueue.offer(next);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tprivate TopologyNode getTopologyNode(ExecNode<?, ?> execNode) {\n+\t\t\t// NOTE: We treat different `BatchExecBoundedStreamScan`s with same `DataStream` object as the same\n+\t\t\tif (execNode instanceof BatchExecBoundedStreamScan) {\n+\t\t\t\tDataStream<?> currentStream =\n+\t\t\t\t\t((BatchExecBoundedStreamScan) execNode).boundedStreamTable().dataStream();\n+\t\t\t\tfor (Map.Entry<ExecNode<?, ?>, TopologyNode> entry : nodes.entrySet()) {\n+\t\t\t\t\tExecNode<?, ?> key = entry.getKey();\n+\t\t\t\t\tif (key instanceof BatchExecBoundedStreamScan) {\n+\t\t\t\t\t\tDataStream<?> existingStream =\n+\t\t\t\t\t\t\t((BatchExecBoundedStreamScan) key).boundedStreamTable().dataStream();\n+\t\t\t\t\t\tif (existingStream.equals(currentStream)) {\n+\t\t\t\t\t\t\treturn entry.getValue();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tTopologyNode result = new TopologyNode();\n+\t\t\t\tnodes.put(execNode, result);\n+\t\t\t\treturn result;\n+\t\t\t} else {\n+\t\t\t\treturn nodes.computeIfAbsent(execNode, k -> new TopologyNode());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A node in the {@link TopologyGraph}.\n+\t */\n+\tprivate static class TopologyNode {\n+\t\tprivate final Set<TopologyNode> inputs = new HashSet<>();\n+\t\tprivate final Set<TopologyNode> outputs = new HashSet<>();\n+\n+\t\tprivate int tag;", "originalCommit": "22cf14c8194ecbb1811caf7bddf03641bf82c1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0MjMwNQ==", "url": "https://github.com/apache/flink/pull/13692#discussion_r509042305", "bodyText": "nit: use node.getInputEdges().size(), consistent with the body of for", "author": "godfreyhe", "createdAt": "2020-10-21T07:16:40Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/reuse/InputPriorityConflictResolver.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.reuse;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.streaming.api.datastream.DataStream;\n+import org.apache.flink.streaming.api.transformations.ShuffleMode;\n+import org.apache.flink.table.planner.plan.nodes.exec.AbstractExecNodeExactlyOnceVisitor;\n+import org.apache.flink.table.planner.plan.nodes.exec.BatchExecNode;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecEdge;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecNode;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecBoundedStreamScan;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecExchange;\n+import org.apache.flink.table.planner.plan.trait.FlinkRelDistribution;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+/**\n+ * This class contains algorithm to detect and resolve input priority conflict in an {@link ExecNode} graph.\n+ *\n+ * <p>Some batch operators (for example, hash join and nested loop join) have different priorities for their inputs.\n+ * When some operators are reused, a deadlock may occur due to the conflict in these priorities.\n+ *\n+ * <p>For example, consider the SQL query:\n+ * <pre>\n+ * WITH\n+ *   T1 AS (SELECT a, COUNT(*) AS cnt1 FROM x GROUP BY a),\n+ *   T2 AS (SELECT d, COUNT(*) AS cnt2 FROM y GROUP BY d)\n+ * SELECT * FROM\n+ *   (SELECT cnt1, cnt2 FROM T1 LEFT JOIN T2 ON a = d)\n+ *   UNION ALL\n+ *   (SELECT cnt1, cnt2 FROM T2 LEFT JOIN T1 ON d = a)\n+ * </pre>\n+ *\n+ * <p>When sub-plan reuse are enabled, we'll get the following physical plan:\n+ * <pre>\n+ * Union(all=[true], union=[cnt1, cnt2])\n+ * :- Calc(select=[CAST(cnt1) AS cnt1, cnt2])\n+ * :  +- HashJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, cnt1, d, cnt2], build=[right])\n+ * :     :- HashAggregate(isMerge=[true], groupBy=[a], select=[a, Final_COUNT(count1$0) AS cnt1], reuse_id=[2])\n+ * :     :  +- Exchange(distribution=[hash[a]])\n+ * :     :     +- LocalHashAggregate(groupBy=[a], select=[a, Partial_COUNT(*) AS count1$0])\n+ * :     :        +- Calc(select=[a])\n+ * :     :           +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])\n+ * :     +- HashAggregate(isMerge=[true], groupBy=[d], select=[d, Final_COUNT(count1$0) AS cnt2], reuse_id=[1])\n+ * :        +- Exchange(distribution=[hash[d]])\n+ * :           +- LocalHashAggregate(groupBy=[d], select=[d, Partial_COUNT(*) AS count1$0])\n+ * :              +- Calc(select=[d])\n+ * :                 +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f)]]], fields=[d, e, f])\n+ * +- Calc(select=[cnt1, CAST(cnt2) AS cnt2])\n+ *    +- HashJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, cnt2, a, cnt1], build=[right])\n+ *       :- Reused(reference_id=[1])\n+ *       +- Reused(reference_id=[2])\n+ * </pre>\n+ *\n+ * <p>Note that the first hash join needs to read all results from the hash aggregate whose reuse id is 1\n+ * before reading the results from the hash aggregate whose reuse id is 2, while the second hash join requires\n+ * the opposite. This physical plan will thus cause a deadlock.\n+ *\n+ * <p>This class maintains a topological graph in which an edge pointing from vertex A to vertex B indicates\n+ * that the results from vertex A need to be read before those from vertex B. A loop in the graph indicates\n+ * a deadlock, and we resolve such deadlock by inserting a {@link BatchExecExchange} with batch shuffle mode.\n+ *\n+ * <p>For a detailed explanation of the algorithm, see appendix of the\n+ * <a href=\"https://docs.google.com/document/d/1qKVohV12qn-bM51cBZ8Hcgp31ntwClxjoiNBUOqVHsI\">design doc</a>.\n+ */\n+@Internal\n+public class InputPriorityConflictResolver {\n+\n+\tprivate final List<ExecNode<?, ?>> sinks;\n+\n+\tprivate TopologyGraph graph;\n+\n+\tpublic InputPriorityConflictResolver(List<ExecNode<?, ?>> sinks) {\n+\t\tPreconditions.checkArgument(\n+\t\t\tsinks.stream().allMatch(sink -> sink instanceof BatchExecNode),\n+\t\t\t\"InputPriorityConflictResolver can only be used for batch jobs.\");\n+\t\tthis.sinks = sinks;\n+\t}\n+\n+\tpublic void detectAndResolve() {\n+\t\t// build an initial topology graph\n+\t\tgraph = new TopologyGraph(sinks);\n+\n+\t\t// check and resolve conflicts about input priorities\n+\t\tAbstractExecNodeExactlyOnceVisitor inputPriorityVisitor = new AbstractExecNodeExactlyOnceVisitor() {\n+\t\t\t@Override\n+\t\t\tprotected void visitNode(ExecNode<?, ?> node) {\n+\t\t\t\tvisitInputs(node);\n+\t\t\t\tcheckInputPriorities(node);\n+\t\t\t}\n+\t\t};\n+\t\tsinks.forEach(n -> n.accept(inputPriorityVisitor));\n+\t}\n+\n+\tprivate void checkInputPriorities(ExecNode<?, ?> node) {\n+\t\t// group inputs by input priorities\n+\t\tTreeMap<Integer, List<Integer>> inputPriorityGroupMap = new TreeMap<>();\n+\t\tPreconditions.checkState(\n+\t\t\tnode.getInputNodes().size() == node.getInputEdges().size(),\n+\t\t\t\"Number of inputs nodes does not equal to number of input edges for node \" +\n+\t\t\t\tnode.getClass().getName() + \". This is a bug.\");\n+\t\tfor (int i = 0; i < node.getInputNodes().size(); i++) {", "originalCommit": "22cf14c8194ecbb1811caf7bddf03641bf82c1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NjUxNQ==", "url": "https://github.com/apache/flink/pull/13692#discussion_r509076515", "bodyText": "nit: an ExecNode may be not BatchExecSink here, use roots ?", "author": "godfreyhe", "createdAt": "2020-10-21T08:12:28Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/reuse/InputPriorityConflictResolver.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.reuse;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.streaming.api.datastream.DataStream;\n+import org.apache.flink.streaming.api.transformations.ShuffleMode;\n+import org.apache.flink.table.planner.plan.nodes.exec.AbstractExecNodeExactlyOnceVisitor;\n+import org.apache.flink.table.planner.plan.nodes.exec.BatchExecNode;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecEdge;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecNode;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecBoundedStreamScan;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecExchange;\n+import org.apache.flink.table.planner.plan.trait.FlinkRelDistribution;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+/**\n+ * This class contains algorithm to detect and resolve input priority conflict in an {@link ExecNode} graph.\n+ *\n+ * <p>Some batch operators (for example, hash join and nested loop join) have different priorities for their inputs.\n+ * When some operators are reused, a deadlock may occur due to the conflict in these priorities.\n+ *\n+ * <p>For example, consider the SQL query:\n+ * <pre>\n+ * WITH\n+ *   T1 AS (SELECT a, COUNT(*) AS cnt1 FROM x GROUP BY a),\n+ *   T2 AS (SELECT d, COUNT(*) AS cnt2 FROM y GROUP BY d)\n+ * SELECT * FROM\n+ *   (SELECT cnt1, cnt2 FROM T1 LEFT JOIN T2 ON a = d)\n+ *   UNION ALL\n+ *   (SELECT cnt1, cnt2 FROM T2 LEFT JOIN T1 ON d = a)\n+ * </pre>\n+ *\n+ * <p>When sub-plan reuse are enabled, we'll get the following physical plan:\n+ * <pre>\n+ * Union(all=[true], union=[cnt1, cnt2])\n+ * :- Calc(select=[CAST(cnt1) AS cnt1, cnt2])\n+ * :  +- HashJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, cnt1, d, cnt2], build=[right])\n+ * :     :- HashAggregate(isMerge=[true], groupBy=[a], select=[a, Final_COUNT(count1$0) AS cnt1], reuse_id=[2])\n+ * :     :  +- Exchange(distribution=[hash[a]])\n+ * :     :     +- LocalHashAggregate(groupBy=[a], select=[a, Partial_COUNT(*) AS count1$0])\n+ * :     :        +- Calc(select=[a])\n+ * :     :           +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])\n+ * :     +- HashAggregate(isMerge=[true], groupBy=[d], select=[d, Final_COUNT(count1$0) AS cnt2], reuse_id=[1])\n+ * :        +- Exchange(distribution=[hash[d]])\n+ * :           +- LocalHashAggregate(groupBy=[d], select=[d, Partial_COUNT(*) AS count1$0])\n+ * :              +- Calc(select=[d])\n+ * :                 +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f)]]], fields=[d, e, f])\n+ * +- Calc(select=[cnt1, CAST(cnt2) AS cnt2])\n+ *    +- HashJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, cnt2, a, cnt1], build=[right])\n+ *       :- Reused(reference_id=[1])\n+ *       +- Reused(reference_id=[2])\n+ * </pre>\n+ *\n+ * <p>Note that the first hash join needs to read all results from the hash aggregate whose reuse id is 1\n+ * before reading the results from the hash aggregate whose reuse id is 2, while the second hash join requires\n+ * the opposite. This physical plan will thus cause a deadlock.\n+ *\n+ * <p>This class maintains a topological graph in which an edge pointing from vertex A to vertex B indicates\n+ * that the results from vertex A need to be read before those from vertex B. A loop in the graph indicates\n+ * a deadlock, and we resolve such deadlock by inserting a {@link BatchExecExchange} with batch shuffle mode.\n+ *\n+ * <p>For a detailed explanation of the algorithm, see appendix of the\n+ * <a href=\"https://docs.google.com/document/d/1qKVohV12qn-bM51cBZ8Hcgp31ntwClxjoiNBUOqVHsI\">design doc</a>.\n+ */\n+@Internal\n+public class InputPriorityConflictResolver {\n+\n+\tprivate final List<ExecNode<?, ?>> sinks;\n+\n+\tprivate TopologyGraph graph;\n+\n+\tpublic InputPriorityConflictResolver(List<ExecNode<?, ?>> sinks) {", "originalCommit": "22cf14c8194ecbb1811caf7bddf03641bf82c1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3ODIxNQ==", "url": "https://github.com/apache/flink/pull/13692#discussion_r509078215", "bodyText": "could you provide more test cases to cover different branches ?", "author": "godfreyhe", "createdAt": "2020-10-21T08:15:06Z", "path": "flink-table/flink-table-planner-blink/src/main/java/org/apache/flink/table/planner/plan/reuse/InputPriorityConflictResolver.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.reuse;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.streaming.api.datastream.DataStream;\n+import org.apache.flink.streaming.api.transformations.ShuffleMode;\n+import org.apache.flink.table.planner.plan.nodes.exec.AbstractExecNodeExactlyOnceVisitor;\n+import org.apache.flink.table.planner.plan.nodes.exec.BatchExecNode;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecEdge;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecNode;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecBoundedStreamScan;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecExchange;\n+import org.apache.flink.table.planner.plan.trait.FlinkRelDistribution;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.apache.calcite.rel.RelNode;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+/**\n+ * This class contains algorithm to detect and resolve input priority conflict in an {@link ExecNode} graph.\n+ *\n+ * <p>Some batch operators (for example, hash join and nested loop join) have different priorities for their inputs.\n+ * When some operators are reused, a deadlock may occur due to the conflict in these priorities.\n+ *\n+ * <p>For example, consider the SQL query:\n+ * <pre>\n+ * WITH\n+ *   T1 AS (SELECT a, COUNT(*) AS cnt1 FROM x GROUP BY a),\n+ *   T2 AS (SELECT d, COUNT(*) AS cnt2 FROM y GROUP BY d)\n+ * SELECT * FROM\n+ *   (SELECT cnt1, cnt2 FROM T1 LEFT JOIN T2 ON a = d)\n+ *   UNION ALL\n+ *   (SELECT cnt1, cnt2 FROM T2 LEFT JOIN T1 ON d = a)\n+ * </pre>\n+ *\n+ * <p>When sub-plan reuse are enabled, we'll get the following physical plan:\n+ * <pre>\n+ * Union(all=[true], union=[cnt1, cnt2])\n+ * :- Calc(select=[CAST(cnt1) AS cnt1, cnt2])\n+ * :  +- HashJoin(joinType=[LeftOuterJoin], where=[=(a, d)], select=[a, cnt1, d, cnt2], build=[right])\n+ * :     :- HashAggregate(isMerge=[true], groupBy=[a], select=[a, Final_COUNT(count1$0) AS cnt1], reuse_id=[2])\n+ * :     :  +- Exchange(distribution=[hash[a]])\n+ * :     :     +- LocalHashAggregate(groupBy=[a], select=[a, Partial_COUNT(*) AS count1$0])\n+ * :     :        +- Calc(select=[a])\n+ * :     :           +- LegacyTableSourceScan(table=[[default_catalog, default_database, x, source: [TestTableSource(a, b, c)]]], fields=[a, b, c])\n+ * :     +- HashAggregate(isMerge=[true], groupBy=[d], select=[d, Final_COUNT(count1$0) AS cnt2], reuse_id=[1])\n+ * :        +- Exchange(distribution=[hash[d]])\n+ * :           +- LocalHashAggregate(groupBy=[d], select=[d, Partial_COUNT(*) AS count1$0])\n+ * :              +- Calc(select=[d])\n+ * :                 +- LegacyTableSourceScan(table=[[default_catalog, default_database, y, source: [TestTableSource(d, e, f)]]], fields=[d, e, f])\n+ * +- Calc(select=[cnt1, CAST(cnt2) AS cnt2])\n+ *    +- HashJoin(joinType=[LeftOuterJoin], where=[=(d, a)], select=[d, cnt2, a, cnt1], build=[right])\n+ *       :- Reused(reference_id=[1])\n+ *       +- Reused(reference_id=[2])\n+ * </pre>\n+ *\n+ * <p>Note that the first hash join needs to read all results from the hash aggregate whose reuse id is 1\n+ * before reading the results from the hash aggregate whose reuse id is 2, while the second hash join requires\n+ * the opposite. This physical plan will thus cause a deadlock.\n+ *\n+ * <p>This class maintains a topological graph in which an edge pointing from vertex A to vertex B indicates\n+ * that the results from vertex A need to be read before those from vertex B. A loop in the graph indicates\n+ * a deadlock, and we resolve such deadlock by inserting a {@link BatchExecExchange} with batch shuffle mode.\n+ *\n+ * <p>For a detailed explanation of the algorithm, see appendix of the\n+ * <a href=\"https://docs.google.com/document/d/1qKVohV12qn-bM51cBZ8Hcgp31ntwClxjoiNBUOqVHsI\">design doc</a>.\n+ */\n+@Internal\n+public class InputPriorityConflictResolver {\n+\n+\tprivate final List<ExecNode<?, ?>> sinks;\n+\n+\tprivate TopologyGraph graph;\n+\n+\tpublic InputPriorityConflictResolver(List<ExecNode<?, ?>> sinks) {\n+\t\tPreconditions.checkArgument(\n+\t\t\tsinks.stream().allMatch(sink -> sink instanceof BatchExecNode),\n+\t\t\t\"InputPriorityConflictResolver can only be used for batch jobs.\");\n+\t\tthis.sinks = sinks;\n+\t}\n+\n+\tpublic void detectAndResolve() {\n+\t\t// build an initial topology graph\n+\t\tgraph = new TopologyGraph(sinks);\n+\n+\t\t// check and resolve conflicts about input priorities\n+\t\tAbstractExecNodeExactlyOnceVisitor inputPriorityVisitor = new AbstractExecNodeExactlyOnceVisitor() {\n+\t\t\t@Override\n+\t\t\tprotected void visitNode(ExecNode<?, ?> node) {\n+\t\t\t\tvisitInputs(node);\n+\t\t\t\tcheckInputPriorities(node);\n+\t\t\t}\n+\t\t};\n+\t\tsinks.forEach(n -> n.accept(inputPriorityVisitor));\n+\t}\n+\n+\tprivate void checkInputPriorities(ExecNode<?, ?> node) {\n+\t\t// group inputs by input priorities\n+\t\tTreeMap<Integer, List<Integer>> inputPriorityGroupMap = new TreeMap<>();\n+\t\tPreconditions.checkState(\n+\t\t\tnode.getInputNodes().size() == node.getInputEdges().size(),\n+\t\t\t\"Number of inputs nodes does not equal to number of input edges for node \" +\n+\t\t\t\tnode.getClass().getName() + \". This is a bug.\");\n+\t\tfor (int i = 0; i < node.getInputNodes().size(); i++) {\n+\t\t\tint priority = node.getInputEdges().get(i).getPriority();\n+\t\t\tinputPriorityGroupMap.computeIfAbsent(priority, k -> new ArrayList<>()).add(i);\n+\t\t}\n+\n+\t\t// add edges between neighboring priority groups\n+\t\tList<List<Integer>> inputPriorityGroups = new ArrayList<>(inputPriorityGroupMap.values());\n+\t\tfor (int i = 0; i + 1 < inputPriorityGroups.size(); i++) {\n+\t\t\tList<Integer> higherGroup = inputPriorityGroups.get(i);\n+\t\t\tList<Integer> lowerGroup = inputPriorityGroups.get(i + 1);\n+\n+\t\t\tfor (int higher : higherGroup) {\n+\t\t\t\tfor (int lower : lowerGroup) {\n+\t\t\t\t\taddTopologyEdges(node, higher, lower);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void addTopologyEdges(ExecNode<?, ?> node, int higherInput, int lowerInput) {\n+\t\tExecNode<?, ?> higherNode = node.getInputNodes().get(higherInput);\n+\t\tExecNode<?, ?> lowerNode = node.getInputNodes().get(lowerInput);\n+\t\tList<ExecNode<?, ?>> lowerAncestors = calculateAncestors(lowerNode);\n+\n+\t\tList<Tuple2<ExecNode<?, ?>, ExecNode<?, ?>>> linkedEdges = new ArrayList<>();\n+\t\tfor (ExecNode<?, ?> ancestor : lowerAncestors) {\n+\t\t\tif (graph.link(higherNode, ancestor)) {\n+\t\t\t\tlinkedEdges.add(Tuple2.of(higherNode, ancestor));\n+\t\t\t} else {\n+\t\t\t\t// a conflict occurs, resolve it by adding a batch exchange\n+\t\t\t\t// and revert all linked edges\n+\t\t\t\tif (lowerNode instanceof BatchExecExchange) {\n+\t\t\t\t\tBatchExecExchange exchange = (BatchExecExchange) lowerNode;\n+\t\t\t\t\texchange.setRequiredShuffleMode(ShuffleMode.BATCH);\n+\t\t\t\t} else {\n+\t\t\t\t\tnode.replaceInputNode(lowerInput, (ExecNode) createExchange(node, lowerInput));\n+\t\t\t\t}\n+\n+\t\t\t\tfor (Tuple2<ExecNode<?, ?>, ExecNode<?, ?>> linkedEdge : linkedEdges) {\n+\t\t\t\t\tgraph.unlink(linkedEdge.f0, linkedEdge.f1);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Find the ancestors by going through PIPELINED edges.\n+\t */\n+\t@VisibleForTesting\n+\tList<ExecNode<?, ?>> calculateAncestors(ExecNode<?, ?> node) {\n+\t\tList<ExecNode<?, ?>> ret = new ArrayList<>();\n+\t\tAbstractExecNodeExactlyOnceVisitor ancestorVisitor = new AbstractExecNodeExactlyOnceVisitor() {\n+\t\t\t@Override\n+\t\t\tprotected void visitNode(ExecNode<?, ?> node) {\n+\t\t\t\tList<ExecEdge> inputEdges = node.getInputEdges();\n+\t\t\t\tboolean hasAncestor = false;\n+\n+\t\t\t\tfor (int i = 0; i < inputEdges.size(); i++) {\n+\t\t\t\t\t// we only go through PIPELINED edges\n+\t\t\t\t\tif (inputEdges.get(i).getDamBehavior().stricterOrEqual(ExecEdge.DamBehavior.END_INPUT)) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\thasAncestor = true;\n+\t\t\t\t\tnode.getInputNodes().get(i).accept(this);\n+\t\t\t\t}\n+\n+\t\t\t\tif (!hasAncestor) {\n+\t\t\t\t\tret.add(node);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\tnode.accept(ancestorVisitor);\n+\t\treturn ret;\n+\t}\n+\n+\tprivate BatchExecExchange createExchange(ExecNode<?, ?> node, int idx) {", "originalCommit": "22cf14c8194ecbb1811caf7bddf03641bf82c1d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIzODkwMw==", "url": "https://github.com/apache/flink/pull/13692#discussion_r509238903", "bodyText": "Existing tests in DeadlockBreakupTest already covers the possible branches.", "author": "tsreaper", "createdAt": "2020-10-21T12:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3ODIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3OTU1OQ==", "url": "https://github.com/apache/flink/pull/13692#discussion_r509079559", "bodyText": "add some comments to explain Pxx, Exx", "author": "godfreyhe", "createdAt": "2020-10-21T08:16:59Z", "path": "flink-table/flink-table-planner-blink/src/test/java/org/apache/flink/table/planner/plan/reuse/InputPriorityConflictResolverTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.table.planner.plan.reuse;\n+\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecEdge;\n+import org.apache.flink.table.planner.plan.nodes.exec.ExecNode;\n+import org.apache.flink.table.planner.plan.nodes.exec.TestingExecNode;\n+import org.apache.flink.table.planner.plan.nodes.physical.batch.BatchExecExchange;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Tests for {@link InputPriorityConflictResolver}.\n+ */\n+public class InputPriorityConflictResolverTest {\n+\n+\tprivate Tuple2<InputPriorityConflictResolver.TopologyGraph, TestingExecNode[]> buildTopologyGraph() {\n+\t\t// 0 -> 1 -> 2 --------> 5\n+\t\t//       \\-> 3 -> 4 -/\n+\t\t//            \\-> 6 -> 7\n+\t\tTestingExecNode[] nodes = new TestingExecNode[8];\n+\t\tfor (int i = 0; i < nodes.length; i++) {\n+\t\t\tnodes[i] = new TestingExecNode();\n+\t\t}\n+\t\tnodes[1].addInput(nodes[0]);\n+\t\tnodes[2].addInput(nodes[1]);\n+\t\tnodes[3].addInput(nodes[1]);\n+\t\tnodes[4].addInput(nodes[3]);\n+\t\tnodes[5].addInput(nodes[2]);\n+\t\tnodes[5].addInput(nodes[4]);\n+\t\tnodes[6].addInput(nodes[3]);\n+\t\tnodes[7].addInput(nodes[6]);\n+\n+\t\treturn Tuple2.of(\n+\t\t\tnew InputPriorityConflictResolver.TopologyGraph(Arrays.asList(nodes[5], nodes[7])),\n+\t\t\tnodes);\n+\t}\n+\n+\t@Test\n+\tpublic void testTopologyGraphCanReach() {\n+\t\tTuple2<InputPriorityConflictResolver.TopologyGraph, TestingExecNode[]> tuple2 = buildTopologyGraph();\n+\t\tInputPriorityConflictResolver.TopologyGraph graph = tuple2.f0;\n+\t\tTestingExecNode[] nodes = tuple2.f1;\n+\n+\t\tString[] canReach = new String[] {\n+\t\t\t\"11111111\",\n+\t\t\t\"01111111\",\n+\t\t\t\"00100100\",\n+\t\t\t\"00011111\",\n+\t\t\t\"00001100\",\n+\t\t\t\"00000100\",\n+\t\t\t\"00000011\",\n+\t\t\t\"00000001\"};\n+\t\tfor (int i = 0; i < 8; i++) {\n+\t\t\tfor (int j = 0; j < 8; j++) {\n+\t\t\t\tif (canReach[i].charAt(j) == '1') {\n+\t\t\t\t\tAssert.assertTrue(graph.canReach(nodes[i], nodes[j]));\n+\t\t\t\t} else {\n+\t\t\t\t\tAssert.assertFalse(graph.canReach(nodes[i], nodes[j]));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testTopologyGraphLink() {\n+\t\tTuple2<InputPriorityConflictResolver.TopologyGraph, TestingExecNode[]> tuple2 = buildTopologyGraph();\n+\t\tInputPriorityConflictResolver.TopologyGraph graph = tuple2.f0;\n+\t\tTestingExecNode[] nodes = tuple2.f1;\n+\n+\t\tAssert.assertTrue(graph.link(nodes[2], nodes[4]));\n+\t\tAssert.assertTrue(graph.link(nodes[3], nodes[5]));\n+\t\tAssert.assertTrue(graph.link(nodes[5], nodes[6]));\n+\t\tAssert.assertFalse(graph.link(nodes[7], nodes[2]));\n+\t\tAssert.assertFalse(graph.link(nodes[7], nodes[4]));\n+\t\tAssert.assertTrue(graph.link(nodes[0], nodes[7]));\n+\t}\n+\n+\t@Test\n+\tpublic void testTopologyGraphUnlink() {\n+\t\tTuple2<InputPriorityConflictResolver.TopologyGraph, TestingExecNode[]> tuple2 = buildTopologyGraph();\n+\t\tInputPriorityConflictResolver.TopologyGraph graph = tuple2.f0;\n+\t\tTestingExecNode[] nodes = tuple2.f1;\n+\n+\t\tgraph.unlink(nodes[2], nodes[5]);\n+\t\tAssert.assertTrue(graph.canReach(nodes[0], nodes[5]));\n+\t\tgraph.unlink(nodes[4], nodes[5]);\n+\t\tAssert.assertFalse(graph.canReach(nodes[0], nodes[5]));\n+\t\tgraph.unlink(nodes[3], nodes[6]);\n+\t\tAssert.assertFalse(graph.canReach(nodes[0], nodes[7]));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalculateAncestors() {\n+\t\t// 0 ------P----> 1 -E--> 2\n+\t\t//   \\-----P----> 3 -P-/\n+\t\t// 4 -E-> 5 -P-/ /\n+\t\t// 6 -----E-----/\n+\t\tTestingExecNode[] nodes = new TestingExecNode[7];\n+\t\tfor (int i = 0; i < nodes.length; i++) {\n+\t\t\tnodes[i] = new TestingExecNode();\n+\t\t}\n+\t\tnodes[1].addInput(nodes[0]);\n+\t\tnodes[2].addInput(nodes[1], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.END_INPUT).build());\n+\t\tnodes[2].addInput(nodes[3]);\n+\t\tnodes[3].addInput(nodes[0]);\n+\t\tnodes[3].addInput(nodes[5]);\n+\t\tnodes[3].addInput(nodes[6], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.END_INPUT).build());\n+\t\tnodes[5].addInput(nodes[4], ExecEdge.builder().damBehavior(ExecEdge.DamBehavior.END_INPUT).build());\n+\n+\t\tInputPriorityConflictResolver resolver = new InputPriorityConflictResolver(Collections.singletonList(nodes[2]));\n+\t\tList<ExecNode<?, ?>> ancestors = resolver.calculateAncestors(nodes[2]);\n+\t\tAssert.assertEquals(2, ancestors.size());\n+\t\tAssert.assertTrue(ancestors.contains(nodes[0]));\n+\t\tAssert.assertTrue(ancestors.contains(nodes[5]));\n+\t}\n+\n+\t@Test\n+\tpublic void testDetectAndResolve() {\n+\t\t// 0 --------(P0)----> 1 --(P0)-----------> 7\n+\t\t//  \\                    \\-(P0)-> 2 -(P0)--/\n+\t\t//   \\-------(P0)----> 3 --(P1)-----------/\n+\t\t//    \\------(P0)----> 4 --(P10)---------/\n+\t\t//     \\              /                 /\n+\t\t//      \\    8 -(P0)-<                 /\n+\t\t//       \\            \\               /\n+\t\t//        \\--(E0)----> 5 --(P10)-----/\n+\t\t// 6 ---------(P100)----------------/", "originalCommit": "22cf14c8194ecbb1811caf7bddf03641bf82c1d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c6d17dd177179695cb51f091fb96e85ca9382afe", "url": "https://github.com/apache/flink/commit/c6d17dd177179695cb51f091fb96e85ca9382afe", "message": "[fix] Fix comments", "committedDate": "2020-10-21T13:03:37Z", "type": "commit"}, {"oid": "0ecd31d4d489facbb299e49ce84f59a29bc6e522", "url": "https://github.com/apache/flink/commit/0ecd31d4d489facbb299e49ce84f59a29bc6e522", "message": "[fix] Fix added test", "committedDate": "2020-10-21T13:04:39Z", "type": "commit"}]}