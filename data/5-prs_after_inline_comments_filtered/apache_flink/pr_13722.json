{"pr_number": 13722, "pr_title": "[FLINK-19636][coordination] Add DeclarativeSlotPool ", "pr_createdAt": "2020-10-21T10:41:25Z", "pr_url": "https://github.com/apache/flink/pull/13722", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzNjk2MQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509336961", "bodyText": "Optional is unnecessary; the returned ResourceCounter could just be empty", "author": "zentol", "createdAt": "2020-10-21T14:29:09Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * Slot pool interface which uses Flink's declarative resource management\n+ * protocol to acquire resources.\n+ *\n+ * <p>In order to acquire new resources, users need to increase the required\n+ * resources. Once they no longer need the resources, users need to decrease\n+ * the required resources so that superfluous resources can be returned.\n+ */\n+public interface DeclarativeSlotPool {\n+\n+\t/**\n+\t * Increases the resource requirements by increment.\n+\t *\n+\t * @param increment increment by which to increase the resource requirements\n+\t */\n+\tvoid increaseResourceRequirementsBy(ResourceCounter increment);\n+\n+\t/**\n+\t * Decreases the resource requirements by decrement.\n+\t *\n+\t * @param decrement decrement by which to decrease the resource requirements\n+\t */\n+\tvoid decreaseResourceRequirementsBy(ResourceCounter decrement);\n+\n+\t/**\n+\t * Returns the current resource requirements.\n+\t *\n+\t * @return current resource requirements\n+\t */\n+\tCollection<ResourceRequirement> getResourceRequirements();\n+\n+\t/**\n+\t * Offers slots to this slot pool. The slot pool is free to accept as many slots as it\n+\t * needs.\n+\t *\n+\t * @param offers offers containing the list of slots offered to this slot pool\n+\t * @param taskManagerLocation taskManagerLocation is the location of the offering TaskExecutor\n+\t * @param taskManagerGateway taskManagerGateway is the gateway to talk to the offering TaskExecutor\n+\t * @param currentTime currentTime is the time the slots are being offered\n+\t * @return collection of accepted slots; the other slot offers are implicitly rejected\n+\t */\n+\tCollection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime);\n+\n+\t/**\n+\t * Returns the slot information for all free slots (slots which can be allocated from the slot pool).\n+\t *\n+\t * @return collection of free slot information\n+\t */\n+\tCollection<SlotInfoWithUtilization> getFreeSlotsInformation();\n+\n+\t/**\n+\t * Returns the slot information for all slots (free and allocated slots).\n+\t *\n+\t * @return collection of slot information\n+\t */\n+\tCollection<? extends SlotInfo> getAllSlotsInformation();\n+\n+\t/**\n+\t * Reserves the free slot identified by the given allocationId and maps it to\n+\t * the given requiredSlotProfile.\n+\t *\n+\t * @param allocationId allocationId identifies the free slot to allocate\n+\t * @param requiredSlotProfile requiredSlotProfile specifying the resource requirement\n+\t * @return a PhysicalSlot representing the allocated slot\n+\t * @throws IllegalStateException if no free slot with the given allocationId exists or if\n+\t *                               the specified slot cannot fulfill the requiredSlotProfile\n+\t */\n+\tPhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile);\n+\n+\t/**\n+\t * Frees the reserved a slot identified by the given allocationId. If no slot\n+\t * with allocationId exists, then the call is ignored.\n+\t *\n+\t * <p>Whether the freed slot is returned to the owning TaskExecutor is implementation\n+\t * dependent.\n+\t *\n+\t * @param allocationId allocationId identifying the slot to release\n+\t * @param cause cause for releasing the slot; can be {@code null}\n+\t * @param currentTime currentTime when the slot was released\n+\t * @return info about freed slot, if a reserved slot with the given allocationId existed\n+\t */\n+\tOptional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime);", "originalCommit": "60ab11bd57d914c712c70aab3b33181aadd1e133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzNzA1Mg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509337052", "bodyText": "same as above", "author": "zentol", "createdAt": "2020-10-21T14:29:16Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * Slot pool interface which uses Flink's declarative resource management\n+ * protocol to acquire resources.\n+ *\n+ * <p>In order to acquire new resources, users need to increase the required\n+ * resources. Once they no longer need the resources, users need to decrease\n+ * the required resources so that superfluous resources can be returned.\n+ */\n+public interface DeclarativeSlotPool {\n+\n+\t/**\n+\t * Increases the resource requirements by increment.\n+\t *\n+\t * @param increment increment by which to increase the resource requirements\n+\t */\n+\tvoid increaseResourceRequirementsBy(ResourceCounter increment);\n+\n+\t/**\n+\t * Decreases the resource requirements by decrement.\n+\t *\n+\t * @param decrement decrement by which to decrease the resource requirements\n+\t */\n+\tvoid decreaseResourceRequirementsBy(ResourceCounter decrement);\n+\n+\t/**\n+\t * Returns the current resource requirements.\n+\t *\n+\t * @return current resource requirements\n+\t */\n+\tCollection<ResourceRequirement> getResourceRequirements();\n+\n+\t/**\n+\t * Offers slots to this slot pool. The slot pool is free to accept as many slots as it\n+\t * needs.\n+\t *\n+\t * @param offers offers containing the list of slots offered to this slot pool\n+\t * @param taskManagerLocation taskManagerLocation is the location of the offering TaskExecutor\n+\t * @param taskManagerGateway taskManagerGateway is the gateway to talk to the offering TaskExecutor\n+\t * @param currentTime currentTime is the time the slots are being offered\n+\t * @return collection of accepted slots; the other slot offers are implicitly rejected\n+\t */\n+\tCollection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime);\n+\n+\t/**\n+\t * Returns the slot information for all free slots (slots which can be allocated from the slot pool).\n+\t *\n+\t * @return collection of free slot information\n+\t */\n+\tCollection<SlotInfoWithUtilization> getFreeSlotsInformation();\n+\n+\t/**\n+\t * Returns the slot information for all slots (free and allocated slots).\n+\t *\n+\t * @return collection of slot information\n+\t */\n+\tCollection<? extends SlotInfo> getAllSlotsInformation();\n+\n+\t/**\n+\t * Reserves the free slot identified by the given allocationId and maps it to\n+\t * the given requiredSlotProfile.\n+\t *\n+\t * @param allocationId allocationId identifies the free slot to allocate\n+\t * @param requiredSlotProfile requiredSlotProfile specifying the resource requirement\n+\t * @return a PhysicalSlot representing the allocated slot\n+\t * @throws IllegalStateException if no free slot with the given allocationId exists or if\n+\t *                               the specified slot cannot fulfill the requiredSlotProfile\n+\t */\n+\tPhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile);\n+\n+\t/**\n+\t * Frees the reserved a slot identified by the given allocationId. If no slot\n+\t * with allocationId exists, then the call is ignored.\n+\t *\n+\t * <p>Whether the freed slot is returned to the owning TaskExecutor is implementation\n+\t * dependent.\n+\t *\n+\t * @param allocationId allocationId identifying the slot to release\n+\t * @param cause cause for releasing the slot; can be {@code null}\n+\t * @param currentTime currentTime when the slot was released\n+\t * @return info about freed slot, if a reserved slot with the given allocationId existed\n+\t */\n+\tOptional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime);\n+\n+\t/**\n+\t * Releases all slots belonging to the owning TaskExecutor if it has been registered.\n+\t *\n+\t * @param owner owner identifying the owning TaskExecutor\n+\t * @param cause cause for failing the slots\n+\t * @return info about released slot\n+\t */\n+\tResourceCounter releaseSlots(ResourceID owner, Exception cause);\n+\n+\t/**\n+\t * Releases the slot specified by allocationId if one exists.\n+\t *\n+\t * @param allocationId allocationId identifying the slot to fail\n+\t * @param cause cause for failing the slot\n+\t * @return info about released slot, if a slot with the given allocationId existed\n+\t */\n+\tOptional<ResourceCounter> releaseSlot(AllocationID allocationId, Exception cause);", "originalCommit": "60ab11bd57d914c712c70aab3b33181aadd1e133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzNzU4Nw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509337587", "bodyText": "It could make sense to instead pass a Collection, to stay in sync with the RM side of things", "author": "zentol", "createdAt": "2020-10-21T14:29:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {\n+\n+\tprivate final DeclarativeSlotPool backingSlotPool;\n+\n+\tAutoRequirementDecrementingSlotPoolWrapper(DeclarativeSlotPool backingSlotPool) {\n+\t\tthis.backingSlotPool = backingSlotPool;\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {", "originalCommit": "60ab11bd57d914c712c70aab3b33181aadd1e133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzOTMyNw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509339327", "bodyText": "I would prefer it we would use the mutable ResourceCounter implementation here so the fields can be final, but as long as it's exposed in the API this would just create confusion.", "author": "zentol", "createdAt": "2020-10-21T14:31:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;", "originalCommit": "60ab11bd57d914c712c70aab3b33181aadd1e133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NDM5OQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511374399", "bodyText": "I have to admit that I prefer it as is because of the following reasons: Making the ResourceCounter immutable simplifies its operations (e.g. adding or subtracting will result into a new value). Moreover, in this class it is correctly shown that the totalResourceRequirements field is mutable. If it were final then it would not be obvious whether this field represents a static value or can be changed.", "author": "tillrohrmann", "createdAt": "2020-10-24T10:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzOTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMzOTY1OQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509339659", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t//order?", "author": "zentol", "createdAt": "2020-10-21T14:32:10Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = releasedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\treleasedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\ttryToFulfillResourceRequirement(allocatedSlot);\n+\t\t\tnotifyNewSlots.accept(Collections.singletonList(allocatedSlot));\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\tprivate void tryToFulfillResourceRequirement(AllocatedSlot allocatedSlot) {\n+\t\tfinal Collection<SlotOfferMatching> slotOfferMatchings = matchOffersWithOutstandingRequirements(Collections.singleton(allocatedSlotToSlotOffer(allocatedSlot)));\n+\n+\t\tfor (SlotOfferMatching slotOfferMatching : slotOfferMatchings) {\n+\t\t\tif (slotOfferMatching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = slotOfferMatching.getMatching().get();\n+\n+\t\t\t\tupdateSlotToRequirementProfileMapping(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateSlotToRequirementProfileMapping(AllocationID allocationId, ResourceProfile matchedResourceProfile) {\n+\t\tfinal ResourceProfile oldResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.put(allocationId, matchedResourceProfile), \"Expected slot profile matching to be non-empty.\");\n+\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(matchedResourceProfile, 1);\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.subtract(oldResourceProfile, 1);\n+\t}\n+\n+\tprivate void adjustRequirements(ResourceProfile oldResourceProfile, ResourceProfile newResourceProfile) {\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tdecreaseResourceRequirementsBy(ResourceCounter.withResource(newResourceProfile, 1));\n+\t\tincreaseResourceRequirementsBy(ResourceCounter.withResource(oldResourceProfile, 1));\n+\t}\n+\n+\t@Nonnull\n+\tprivate SlotOffer allocatedSlotToSlotOffer(AllocatedSlot allocatedSlot) {\n+\t\treturn new SlotOffer(allocatedSlot.getAllocationId(), allocatedSlot.getPhysicalSlotNumber(), allocatedSlot.getResourceProfile());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tfinal Collection<AllocatedSlot> removedSlots = slotPool.removeSlots(owner);\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = getFulfilledRequirements(removedSlots);\n+\n+\t\treleasePayload(removedSlots, cause);\n+\t\treleaseSlots(removedSlots, cause);\n+\n+\t\treturn previouslyFulfilledRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> releaseSlot(AllocationID allocationId, Exception cause) {\n+\t\tfinal Optional<AllocatedSlot> removedSlot = slotPool.removeSlot(allocationId);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = removedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\tremovedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\treleaseSlots(Collections.singleton(allocatedSlot), cause);\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\tprivate void releasePayload(Iterable<? extends AllocatedSlot> allocatedSlots, Throwable cause) {\n+\t\tfor (AllocatedSlot allocatedSlot : allocatedSlots) {\n+\t\t\tallocatedSlot.releasePayload(cause);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseIdleSlots(long currentTimeMillis) {\n+\t\tfinal Collection<AllocatedSlotPool.FreeSlotInfo> freeSlotsInformation = slotPool.getFreeSlotsInformation();\n+\n+\t\t//order?", "originalCommit": "60ab11bd57d914c712c70aab3b33181aadd1e133", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MDY2NA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509340664", "bodyText": "we could probably combine this loop with the matching of requirements", "author": "zentol", "createdAt": "2020-10-21T14:33:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {", "originalCommit": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NTc1Ng==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511375756", "bodyText": "But then, we couldn't reuse matchOffersWithOutstandingRequirements in tryToFulfillResourceRequirement.", "author": "tillrohrmann", "createdAt": "2020-10-24T10:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MDY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MjIzOQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509342239", "bodyText": "It may make sense to replace this with a JobScopedResourceTracker to keep the matching logic in sync with the RM side.", "author": "zentol", "createdAt": "2020-10-21T14:35:12Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;", "originalCommit": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3MzQ3Nw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511373477", "bodyText": "Hmm, the JobScopedResourceTracker does a bit more than this simple map here.", "author": "tillrohrmann", "createdAt": "2020-10-24T09:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3MzU5MQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511373591", "bodyText": "But I agree that the matching should be in sync between the RM and the JM side.", "author": "tillrohrmann", "createdAt": "2020-10-24T10:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzkyODc0OA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517928748", "bodyText": "Agreed, the resource tracker doesn't really fit; in particular because it cannot really handle the concept of slots being reserved.\nI've moved the matching logic from it into a re-usable RequirementMatcher component that is now used by the tracker and slot pool.", "author": "zentol", "createdAt": "2020-11-05T10:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0MjIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTM0NDQwMw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r509344403", "bodyText": "this could be skipped if the profiles match", "author": "zentol", "createdAt": "2020-10-21T14:37:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);", "originalCommit": "e7f73fbfde2458dce9b5ae9acec9b82c412bce63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NDQzOQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r512044439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n          \n          \n            \n            \t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was", "author": "zentol", "createdAt": "2020-10-26T15:20:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was", "originalCommit": "e378973cf6cb21f9da36c6fa9d9b9a7d326c2185", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1NDg3Nw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r512954877", "bodyText": "It may actually be better to inline and decreases into the wrapper introduced in FLINK-19314; as it is we're just spreading things around, and create weird inconsistencies where the wrapper does decrease requirements when releasing a pending requests, but does not decrease requirements when releasing an allocated slot.", "author": "zentol", "createdAt": "2020-10-27T19:05:30Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {", "originalCommit": "fa82dd23b082fc0b4d82de8217831b6ec7624947", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3ODMwMQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516078301", "bodyText": "Yes, I think this might be cleaner.", "author": "tillrohrmann", "createdAt": "2020-11-02T16:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1NDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NTIwMg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511375202", "bodyText": "one could factor this out into a separate method.", "author": "tillrohrmann", "createdAt": "2020-10-24T10:04:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}", "originalCommit": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NjA3Mw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511376073", "bodyText": "Maybe: Could be factored out as well.", "author": "tillrohrmann", "createdAt": "2020-10-24T10:07:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);", "originalCommit": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgyNjc1Mg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516826752", "bodyText": "there are so many data-structures to modify (acceptedSlots/acceptedSlotOffers/acceptedResources), which would have to be passed in, along with other stuff (taskManagerLocation/Gateway), that it would become a bit of a mess.", "author": "zentol", "createdAt": "2020-11-03T17:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NjA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4Mjk5Mw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517182993", "bodyText": "fair enough", "author": "tillrohrmann", "createdAt": "2020-11-04T08:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NjA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NzMwNA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511377304", "bodyText": "Shouldn't we also adjust unfulfilledResources here? Concretely, I think we should write unfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1); or move it out of the two branches and unify it.", "author": "tillrohrmann", "createdAt": "2020-10-24T10:10:37Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;", "originalCommit": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMDYwMQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516830601", "bodyText": "hmm...I think the idea was to accept any slot that could be used for some requirement if they don't exactly match, to prevent cases where we reject a slot because some other slot has taken it's place. For example, assume the requirements are one small and one large slot. Large slot offer comes first, fulfills small requirement, small slot arrives and is rejected.", "author": "zentol", "createdAt": "2020-11-03T17:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NzMwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4MDk4NA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517180984", "bodyText": "I think the idea was not to accept excess slots which we are sure not to use. Which slots, if there are multiple matching ones, to accept is a different question. I think that can be a follow up question and I'd be fine to simply take the first matching one.", "author": "tillrohrmann", "createdAt": "2020-11-04T08:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3NzMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM3Nzk2Mw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r511377963", "bodyText": "typo: is not in line", "author": "tillrohrmann", "createdAt": "2020-10-24T10:12:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was", "originalCommit": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA0NTM0OQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516045349", "bodyText": "nit: remove \"a\"", "author": "tillrohrmann", "createdAt": "2020-11-02T15:20:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * Slot pool interface which uses Flink's declarative resource management\n+ * protocol to acquire resources.\n+ *\n+ * <p>In order to acquire new resources, users need to increase the required\n+ * resources. Once they no longer need the resources, users need to decrease\n+ * the required resources so that superfluous resources can be returned.\n+ */\n+public interface DeclarativeSlotPool {\n+\n+\t/**\n+\t * Increases the resource requirements by increment.\n+\t *\n+\t * @param increment increment by which to increase the resource requirements\n+\t */\n+\tvoid increaseResourceRequirementsBy(ResourceCounter increment);\n+\n+\t/**\n+\t * Decreases the resource requirements by decrement.\n+\t *\n+\t * @param decrement decrement by which to decrease the resource requirements\n+\t */\n+\tvoid decreaseResourceRequirementsBy(ResourceCounter decrement);\n+\n+\t/**\n+\t * Returns the current resource requirements.\n+\t *\n+\t * @return current resource requirements\n+\t */\n+\tCollection<ResourceRequirement> getResourceRequirements();\n+\n+\t/**\n+\t * Offers slots to this slot pool. The slot pool is free to accept as many slots as it\n+\t * needs.\n+\t *\n+\t * @param offers offers containing the list of slots offered to this slot pool\n+\t * @param taskManagerLocation taskManagerLocation is the location of the offering TaskExecutor\n+\t * @param taskManagerGateway taskManagerGateway is the gateway to talk to the offering TaskExecutor\n+\t * @param currentTime currentTime is the time the slots are being offered\n+\t * @return collection of accepted slots; the other slot offers are implicitly rejected\n+\t */\n+\tCollection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime);\n+\n+\t/**\n+\t * Returns the slot information for all free slots (slots which can be allocated from the slot pool).\n+\t *\n+\t * @return collection of free slot information\n+\t */\n+\tCollection<SlotInfoWithUtilization> getFreeSlotsInformation();\n+\n+\t/**\n+\t * Returns the slot information for all slots (free and allocated slots).\n+\t *\n+\t * @return collection of slot information\n+\t */\n+\tCollection<? extends SlotInfo> getAllSlotsInformation();\n+\n+\t/**\n+\t * Reserves the free slot identified by the given allocationId and maps it to\n+\t * the given requiredSlotProfile.\n+\t *\n+\t * @param allocationId allocationId identifies the free slot to allocate\n+\t * @param requiredSlotProfile requiredSlotProfile specifying the resource requirement\n+\t * @return a PhysicalSlot representing the allocated slot\n+\t * @throws IllegalStateException if no free slot with the given allocationId exists or if\n+\t *                               the specified slot cannot fulfill the requiredSlotProfile\n+\t */\n+\tPhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile);\n+\n+\t/**\n+\t * Frees the reserved a slot identified by the given allocationId. If no slot", "originalCommit": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1MjQxMg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516052412", "bodyText": "I really like to rethink whether we need this mapping in this class or whether it could live in the wrapper. It somehow feels wrong that the DefaultDeclarativeSlotPool needs to track for which ResourceProfile a given slot has been reserved.", "author": "tillrohrmann", "createdAt": "2020-11-02T15:30:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);", "originalCommit": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg1MzE1NQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516853155", "bodyText": "I'm not sure if we can get rid of it.\nThe information that this slot was used to fulfill that requirement is used for so many things; be it matching slot offers against outstanding requirements, figuring out whether a slot is eligible for an idleness timeout, or to update the fulfilled requirements if a slot is released.\nIt seems impossible to remove this mapping without removing everything that makes this pool more than a wrapper around the AllocatedSlotPool.\nAt the end of the day we need this information somewhere anyway; be it in the slot pool, or the new scheduler so it could make sure to update the requirements.\nGiven that the declarative slot pool is all about managing slots in respects to requirements, it seems fitting that it contains such a mapping.\nMaybe this is just a naming/structural issue? What if the DeclarativeSlotPool were not actually a pool, but a requirement manager?\nSlot offers and releases would be issued directly against he AllocatedSlotPool, which informs the declarative slot pool, which then takes the appropriate steps of adjusting requirements etc. .\nBasically, instead of removing the mapping portion out of the slot pool, remove the slot pool portion from it.", "author": "zentol", "createdAt": "2020-11-03T17:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1MjQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2Nzk5MA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517367990", "bodyText": "I think my main concern comes from the following thought: I've considered the DeclarativeSlotPool as the component which makes sure that we keep a set of slots according to the declared resources and makes it accessible to a user for usage. If now the user decides to use a slot differently (e.g. for a smaller slot request), then it should be his responsibility to make sure that he no longer needs this slot or to adjust the resource requirements by asking for another big slot in order to fulfill the pending slot requests. Since this is something which has to be decided by the user, it shouldn't bother this component.\nWhat I am not saying is that we cannot remember the mapping of a matching to speed up future matchings. This is perfectly fine and can be encapsulated in the implementation. So what bothers me is that the reserveFreeSlot method has a requiredSlotProfile  argument.", "author": "tillrohrmann", "createdAt": "2020-11-04T14:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1MjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1NjYxMg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516056612", "bodyText": "Related to one of my previous comments: I am wondering whether this functionality is really necessary to keep in the DefaultDeclarativeSlotPool. I would hope that this is really only needed by the FutureSlotPool.", "author": "tillrohrmann", "createdAt": "2020-11-02T15:36:10Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,462 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<SlotOffer> candidates = new ArrayList<>();\n+\n+\t\t// filter out already accepted offers\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tfinal AllocationID allocationId = offer.getAllocationId();\n+\t\t\tif (slotPool.containsSlot(allocationId)) {\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tcandidates.add(offer);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<SlotOfferMatching> matchings = matchOffersWithOutstandingRequirements(candidates);\n+\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\t\tResourceCounter acceptedResources = ResourceCounter.empty();\n+\n+\t\tfor (SlotOfferMatching matching : matchings) {\n+\t\t\tif (matching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = matching.getMatching().get();\n+\n+\t\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tmatching.getSlotOffer(),\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t\tacceptedSlots.add(allocatedSlot);\n+\t\t\t\tacceptedSlotOffers.add(matching.getSlotOffer());\n+\n+\t\t\t\tacceptedResources = acceptedResources.add(matchedResourceProfile, 1);\n+\n+\t\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\t\tincreaseAvailableResources(acceptedResources);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Collection<SlotOfferMatching> matchOffersWithOutstandingRequirements(Collection<SlotOffer> slotOffers) {\n+\t\tResourceCounter unfulfilledResources = calculateUnfulfilledResources();\n+\n+\t\tfinal Collection<SlotOfferMatching> matching = new ArrayList<>();\n+\n+\t\tfor (SlotOffer slotOffer : slotOffers) {\n+\t\t\tResourceProfile matchingResourceProfile = null;\n+\n+\t\t\tif (unfulfilledResources.containsResource(slotOffer.getResourceProfile())) {\n+\t\t\t\tunfulfilledResources = unfulfilledResources.subtract(slotOffer.getResourceProfile(), 1);\n+\n+\t\t\t\t// use the profile of the slot offer since it is a direct match against the requirement\n+\t\t\t\tmatchingResourceProfile = slotOffer.getResourceProfile();\n+\t\t\t} else {\n+\t\t\t\tfor (ResourceProfile unfulfilledResource : unfulfilledResources.getResources()) {\n+\t\t\t\t\tif (slotOffer.getResourceProfile().isMatching(unfulfilledResource)) {\n+\t\t\t\t\t\tmatchingResourceProfile = unfulfilledResource;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tfinal SlotOfferMatching slotOfferMatching;\n+\t\t\tif (matchingResourceProfile != null) {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMatching(slotOffer, matchingResourceProfile);\n+\t\t\t} else {\n+\t\t\t\tslotOfferMatching = SlotOfferMatching.createMismatch(slotOffer);\n+\t\t\t}\n+\n+\t\t\tmatching.add(slotOfferMatching);\n+\t\t}\n+\n+\t\treturn matching;\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = releasedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\treleasedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\ttryToFulfillResourceRequirement(allocatedSlot);\n+\t\t\tnotifyNewSlots.accept(Collections.singletonList(allocatedSlot));\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\tprivate void tryToFulfillResourceRequirement(AllocatedSlot allocatedSlot) {\n+\t\tfinal Collection<SlotOfferMatching> slotOfferMatchings = matchOffersWithOutstandingRequirements(Collections.singleton(allocatedSlotToSlotOffer(allocatedSlot)));\n+\n+\t\tfor (SlotOfferMatching slotOfferMatching : slotOfferMatchings) {\n+\t\t\tif (slotOfferMatching.getMatching().isPresent()) {\n+\t\t\t\tfinal ResourceProfile matchedResourceProfile = slotOfferMatching.getMatching().get();\n+\n+\t\t\t\tupdateSlotToRequirementProfileMapping(allocatedSlot.getAllocationId(), matchedResourceProfile);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void updateSlotToRequirementProfileMapping(AllocationID allocationId, ResourceProfile matchedResourceProfile) {\n+\t\tfinal ResourceProfile oldResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.put(allocationId, matchedResourceProfile), \"Expected slot profile matching to be non-empty.\");\n+\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(matchedResourceProfile, 1);\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.subtract(oldResourceProfile, 1);\n+\t}\n+\n+\tprivate void adjustRequirements(ResourceProfile oldResourceProfile, ResourceProfile newResourceProfile) {\n+\t\t// slots can be reserved for a requirement that is no in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tdecreaseResourceRequirementsBy(ResourceCounter.withResource(newResourceProfile, 1));\n+\t\tincreaseResourceRequirementsBy(ResourceCounter.withResource(oldResourceProfile, 1));\n+\t}", "originalCommit": "4bf34fd591c7c4fd8ae19acdd9998fc6787bc7b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516077791", "bodyText": "Why are we decreasing the requirements if releaseSlots is called? I think this should be called if a TM's heartbeat times out.", "author": "tillrohrmann", "createdAt": "2020-11-02T16:05:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {\n+\n+\tprivate final DeclarativeSlotPool backingSlotPool;\n+\n+\tAutoRequirementDecrementingSlotPoolWrapper(DeclarativeSlotPool backingSlotPool) {\n+\t\tthis.backingSlotPool = backingSlotPool;\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\tbackingSlotPool.increaseResourceRequirementsBy(increment);\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(decrement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\treturn backingSlotPool.getResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime) {\n+\t\treturn backingSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, currentTime);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotInfoWithUtilization> getFreeSlotsInformation() {\n+\t\treturn backingSlotPool.getFreeSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<? extends SlotInfo> getAllSlotsInformation() {\n+\t\treturn backingSlotPool.getAllSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\treturn backingSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = backingSlotPool.freeReservedSlot(allocationId, cause, currentTime);\n+\t\tpreviouslyFulfilledRequirement\n+\t\t\t.ifPresent(backingSlotPool::decreaseResourceRequirementsBy);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = backingSlotPool.releaseSlots(owner, cause);\n+\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}", "originalCommit": "6e0d0cc61b72e86cdbca8f29684148e364a11240", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgzMzI2OA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516833268", "bodyText": "because we will request new slots for those that we just lost, and since this increments the requirements we have to decrement them somewhere to ensure the requirements stay the same.", "author": "zentol", "createdAt": "2020-11-03T17:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM2MDY1NA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517360654", "bodyText": "But shouldn't this be the responsibility of the user of this wrapper to do sort the requirements out correctly?", "author": "tillrohrmann", "createdAt": "2020-11-04T13:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQyMTI3Mg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517421272", "bodyText": "Currently the user of this wrapper does not know what mapping the slot pool came up with.\nWe would have to include the originally matched profile in the slot information, that is returned for free slots.", "author": "zentol", "createdAt": "2020-11-04T15:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQyNTIzNg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517425236", "bodyText": "or return it in reserveFreeSlot", "author": "zentol", "createdAt": "2020-11-04T15:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ0NDcxNQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517444715", "bodyText": "Ah I see. This is definitely a recurring theme that the matching of the slots to required resources and the slots to Executions need to be aligned.\nIn the case of the releaseSlots method, I guess that the return value will tell us which requirements are no longer fulfilled.\nMaybe it is not such a bad idea to return in some form the matched resource profile of a slot. This would allow the user to adjust the resource requirements if it decides to use this slot for a different Execution.", "author": "tillrohrmann", "createdAt": "2020-11-04T15:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ1MjcwMg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r517452702", "bodyText": "Yes, as is the return value of the releaseSlot(s) methods can be used for this (in fact that's the only reason they were added in the first place).\nHowever this only makes sense to long as the internal mapping is updated when a slot is reserved for a different requirement than initially intended.", "author": "zentol", "createdAt": "2020-11-04T16:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3Nzc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA3ODA0Mw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r516078043", "bodyText": "Same here, shouldn't releaseSlot keep the requirements constant?", "author": "tillrohrmann", "createdAt": "2020-11-02T16:05:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/AutoRequirementDecrementingSlotPoolWrapper.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+\n+/**\n+ * A wrapper around a {@link DeclarativeSlotPool} that automatically decrements requirements if a slot is freed or\n+ * released.\n+ */\n+class AutoRequirementDecrementingSlotPoolWrapper implements DeclarativeSlotPool {\n+\n+\tprivate final DeclarativeSlotPool backingSlotPool;\n+\n+\tAutoRequirementDecrementingSlotPoolWrapper(DeclarativeSlotPool backingSlotPool) {\n+\t\tthis.backingSlotPool = backingSlotPool;\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\tbackingSlotPool.increaseResourceRequirementsBy(increment);\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(decrement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\treturn backingSlotPool.getResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(Collection<? extends SlotOffer> offers, TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, long currentTime) {\n+\t\treturn backingSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, currentTime);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotInfoWithUtilization> getFreeSlotsInformation() {\n+\t\treturn backingSlotPool.getFreeSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic Collection<? extends SlotInfo> getAllSlotsInformation() {\n+\t\treturn backingSlotPool.getAllSlotsInformation();\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\treturn backingSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = backingSlotPool.freeReservedSlot(allocationId, cause, currentTime);\n+\t\tpreviouslyFulfilledRequirement\n+\t\t\t.ifPresent(backingSlotPool::decreaseResourceRequirementsBy);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = backingSlotPool.releaseSlots(owner, cause);\n+\n+\t\tbackingSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\treturn previouslyFulfilledRequirement;\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceCounter> releaseSlot(AllocationID allocationId, Exception cause) {\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirements = backingSlotPool.releaseSlot(allocationId, cause);\n+\t\tpreviouslyFulfilledRequirements\n+\t\t\t.ifPresent(backingSlotPool::decreaseResourceRequirementsBy);\n+\t\treturn previouslyFulfilledRequirements;\n+\t}", "originalCommit": "6e0d0cc61b72e86cdbca8f29684148e364a11240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0NTk0Nw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524345947", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link #freeReservedSlot released}.\n          \n          \n            \n             * {@link #freeReservedSlot freed}.\n          \n      \n    \n    \n  \n\nbc release is used in the API and means that we remove the slot from the pool.", "author": "tillrohrmann", "createdAt": "2020-11-16T15:19:58Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0OTMxNA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524349314", "bodyText": "The error message is missing.", "author": "tillrohrmann", "createdAt": "2020-11-16T15:24:27Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM0OTgwNg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524349806", "bodyText": "We could log on debug which offers are matching with which requirements.", "author": "tillrohrmann", "createdAt": "2020-11-16T15:25:00Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1MDI0MA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524350240", "bodyText": "Add debug logging which tells about the requirements adjustment.", "author": "tillrohrmann", "createdAt": "2020-11-16T15:25:33Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1MDYwOQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524350609", "bodyText": "Let's be consistent with the terms and use Free reserved slot {}. here.", "author": "tillrohrmann", "createdAt": "2020-11-16T15:26:04Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements\n+\t\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\t\t}\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1MDgxNg==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524350816", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n          \n          \n            \n            \t\tfinal Optional<AllocatedSlot> freedSlot = slotPool.freeReservedSlot(allocationId, currentTime);", "author": "tillrohrmann", "createdAt": "2020-11-16T15:26:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements\n+\t\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\t\t}\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM1NzY4OQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524357689", "bodyText": "maybe log on debug the cause.", "author": "tillrohrmann", "createdAt": "2020-11-16T15:35:01Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPool.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.DefaultRequirementMatcher;\n+import org.apache.flink.runtime.slots.RequirementMatcher;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Default {@link DeclarativeSlotPool} implementation.\n+ *\n+ * <p>The implementation collects the current resource requirements and declares them\n+ * at the ResourceManager. Whenever new slots are offered, the slot pool compares the\n+ * offered slots to the set of available and required resources and only accepts those\n+ * slots which are required.\n+ *\n+ * <p>Slots which are released won't be returned directly to their owners. Instead,\n+ * the slot pool implementation will only return them after the idleSlotTimeout has\n+ * been exceeded by a free slot.\n+ *\n+ * <p>The slot pool will call {@link #notifyNewSlots} whenever newly offered slots are\n+ * accepted or if an allocated slot should become free after it is being\n+ * {@link #freeReservedSlot released}.\n+ */\n+public class DefaultDeclarativeSlotPool implements DeclarativeSlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultDeclarativeSlotPool.class);\n+\n+\tprivate final Consumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements;\n+\n+\tprivate final Consumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots;\n+\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time rpcTimeout;\n+\n+\tprivate final AllocatedSlotPool slotPool;\n+\n+\tprivate final Map<AllocationID, ResourceProfile> slotToRequirementProfileMappings;\n+\n+\tprivate ResourceCounter totalResourceRequirements;\n+\n+\tprivate ResourceCounter fulfilledResourceRequirements;\n+\n+\tprivate final RequirementMatcher requirementMatcher = new DefaultRequirementMatcher();\n+\n+\tpublic DefaultDeclarativeSlotPool(\n+\t\tAllocatedSlotPool slotPool,\n+\t\tConsumer<? super Collection<ResourceRequirement>> notifyNewResourceRequirements,\n+\t\tConsumer<? super Collection<? extends PhysicalSlot>> notifyNewSlots,\n+\t\tTime idleSlotTimeout,\n+\t\tTime rpcTimeout) {\n+\n+\t\tthis.slotPool = slotPool;\n+\t\tthis.notifyNewResourceRequirements = notifyNewResourceRequirements;\n+\t\tthis.notifyNewSlots = notifyNewSlots;\n+\t\tthis.idleSlotTimeout = idleSlotTimeout;\n+\t\tthis.rpcTimeout = rpcTimeout;\n+\t\tthis.totalResourceRequirements = ResourceCounter.empty();\n+\t\tthis.fulfilledResourceRequirements = ResourceCounter.empty();\n+\t\tthis.slotToRequirementProfileMappings = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic void increaseResourceRequirementsBy(ResourceCounter increment) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.add(increment);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\t@Override\n+\tpublic void decreaseResourceRequirementsBy(ResourceCounter decrement) {\n+\t\ttotalResourceRequirements = totalResourceRequirements.subtract(decrement);\n+\n+\t\tdeclareResourceRequirements();\n+\t}\n+\n+\tprivate void declareResourceRequirements() {\n+\t\tnotifyNewResourceRequirements.accept(getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<ResourceRequirement> getResourceRequirements() {\n+\t\tfinal Collection<ResourceRequirement> currentResourceRequirements = new ArrayList<>();\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceRequirement : totalResourceRequirements.getResourcesWithCount()) {\n+\t\t\tcurrentResourceRequirements.add(ResourceRequirement.create(resourceRequirement.getKey(), resourceRequirement.getValue()));\n+\t\t}\n+\n+\t\treturn currentResourceRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(\n+\t\tCollection<? extends SlotOffer> offers,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway,\n+\t\tlong currentTime) {\n+\n+\t\tLOG.debug(\"Received {} slot offers from TaskExecutor {}.\", offers.size(), taskManagerLocation);\n+\t\tfinal Collection<SlotOffer> acceptedSlotOffers = new ArrayList<>();\n+\t\tfinal Collection<AllocatedSlot> acceptedSlots = new ArrayList<>();\n+\n+\t\tfor (SlotOffer offer : offers) {\n+\t\t\tif (slotPool.containsSlot(offer.getAllocationId())) {\n+\t\t\t\t// we have already accepted this offer\n+\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t} else {\n+\t\t\t\tOptional<AllocatedSlot> acceptedSlot = matchOfferWithOutstandingRequirements(offer, taskManagerLocation, taskManagerGateway);\n+\t\t\t\tif (acceptedSlot.isPresent()) {\n+\t\t\t\t\tacceptedSlotOffers.add(offer);\n+\t\t\t\t\tacceptedSlots.add(acceptedSlot.get());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tslotPool.addSlots(acceptedSlots, currentTime);\n+\n+\t\tif (!acceptedSlots.isEmpty()) {\n+\t\t\tnotifyNewSlots.accept(acceptedSlots);\n+\t\t}\n+\n+\t\treturn acceptedSlotOffers;\n+\t}\n+\n+\tprivate Optional<AllocatedSlot> matchOfferWithOutstandingRequirements(\n+\t\t\tSlotOffer slotOffer,\n+\t\t\tTaskManagerLocation taskManagerLocation,\n+\t\t\tTaskManagerGateway taskManagerGateway) {\n+\n+\t\tfinal Optional<ResourceProfile> match = requirementMatcher.match(\n+\t\t\t\tslotOffer.getResourceProfile(),\n+\t\t\t\ttotalResourceRequirements.getResourcesWithCount(),\n+\t\t\t\tfulfilledResourceRequirements::getResourceCount);\n+\n+\t\tif (match.isPresent()) {\n+\t\t\tincreaseAvailableResources(ResourceCounter.withResource(match.get(), 1));\n+\n+\t\t\tfinal AllocatedSlot allocatedSlot = createAllocatedSlot(\n+\t\t\t\t\tslotOffer,\n+\t\t\t\t\ttaskManagerLocation,\n+\t\t\t\t\ttaskManagerGateway);\n+\n+\t\t\t// store the ResourceProfile against which the given slot has matched for future book-keeping\n+\t\t\tslotToRequirementProfileMappings.put(allocatedSlot.getAllocationId(), match.get());\n+\n+\t\t\treturn Optional.of(allocatedSlot);\n+\t\t}\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@VisibleForTesting\n+\tResourceCounter calculateUnfulfilledResources() {\n+\t\treturn totalResourceRequirements.subtract(fulfilledResourceRequirements);\n+\t}\n+\n+\tprivate AllocatedSlot createAllocatedSlot(\n+\t\tSlotOffer slotOffer,\n+\t\tTaskManagerLocation taskManagerLocation,\n+\t\tTaskManagerGateway taskManagerGateway) {\n+\t\treturn new AllocatedSlot(\n+\t\t\tslotOffer.getAllocationId(),\n+\t\t\ttaskManagerLocation,\n+\t\t\tslotOffer.getSlotIndex(),\n+\t\t\tslotOffer.getResourceProfile(),\n+\t\t\ttaskManagerGateway);\n+\t}\n+\n+\tprivate void increaseAvailableResources(ResourceCounter acceptedResources) {\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(acceptedResources);\n+\t}\n+\n+\t@Nonnull\n+\tprivate ResourceProfile getMatchingResourceProfile(AllocationID allocationId) {\n+\t\treturn Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId), \"No matching resource profile found for %s\", allocationId);\n+\t}\n+\n+\t@Override\n+\tpublic PhysicalSlot reserveFreeSlot(AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tfinal AllocatedSlot allocatedSlot = slotPool.reserveFreeSlot(allocationId);\n+\n+\t\tPreconditions.checkState(allocatedSlot.getResourceProfile().isMatching(requiredSlotProfile), \"\");\n+\n+\t\tResourceProfile previouslyMatchedResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.get(allocationId));\n+\n+\t\tif (!previouslyMatchedResourceProfile.equals(requiredSlotProfile)) {\n+\t\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t\t// offered, so we have to update the mapping adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t\t// be able to fulfill the total requirements\n+\t\t\tupdateSlotToRequirementProfileMapping(allocationId, requiredSlotProfile);\n+\t\t\tadjustRequirements(previouslyMatchedResourceProfile, requiredSlotProfile);\n+\t\t}\n+\n+\t\treturn allocatedSlot;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter freeReservedSlot(AllocationID allocationId, @Nullable Throwable cause, long currentTime) {\n+\t\tLOG.debug(\"Release slot {}.\", allocationId);\n+\n+\t\tfinal Optional<AllocatedSlot> releasedSlot = slotPool.freeReservedSlot(allocationId, currentTime);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = releasedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\treleasedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\ttryToFulfillResourceRequirement(allocatedSlot);\n+\t\t\tnotifyNewSlots.accept(Collections.singletonList(allocatedSlot));\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement.orElseGet(ResourceCounter::empty);\n+\t}\n+\n+\tprivate void tryToFulfillResourceRequirement(AllocatedSlot allocatedSlot) {\n+\t\tmatchOfferWithOutstandingRequirements(allocatedSlotToSlotOffer(allocatedSlot), allocatedSlot.getTaskManagerLocation(), allocatedSlot.getTaskManagerGateway());\n+\t}\n+\n+\tprivate void updateSlotToRequirementProfileMapping(AllocationID allocationId, ResourceProfile matchedResourceProfile) {\n+\t\tfinal ResourceProfile oldResourceProfile = Preconditions.checkNotNull(slotToRequirementProfileMappings.put(allocationId, matchedResourceProfile), \"Expected slot profile matching to be non-empty.\");\n+\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.add(matchedResourceProfile, 1);\n+\t\tfulfilledResourceRequirements = fulfilledResourceRequirements.subtract(oldResourceProfile, 1);\n+\t}\n+\n+\tprivate void adjustRequirements(ResourceProfile oldResourceProfile, ResourceProfile newResourceProfile) {\n+\t\t// slots can be reserved for a requirement that is not in line with the mapping we computed when the slot was\n+\t\t// offered, so we have to adjust the requirements accordingly to ensure we still request enough slots to\n+\t\t// be able to fulfill the total requirements\n+\t\tdecreaseResourceRequirementsBy(ResourceCounter.withResource(newResourceProfile, 1));\n+\t\tincreaseResourceRequirementsBy(ResourceCounter.withResource(oldResourceProfile, 1));\n+\t}\n+\n+\t@Nonnull\n+\tprivate SlotOffer allocatedSlotToSlotOffer(AllocatedSlot allocatedSlot) {\n+\t\treturn new SlotOffer(allocatedSlot.getAllocationId(), allocatedSlot.getPhysicalSlotNumber(), allocatedSlot.getResourceProfile());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlots(ResourceID owner, Exception cause) {\n+\t\tfinal Collection<AllocatedSlot> removedSlots = slotPool.removeSlots(owner);\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = getFulfilledRequirements(removedSlots);\n+\n+\t\treleasePayload(removedSlots, cause);\n+\t\treleaseSlots(removedSlots, cause);\n+\n+\t\treturn previouslyFulfilledRequirements;\n+\t}\n+\n+\t@Override\n+\tpublic ResourceCounter releaseSlot(AllocationID allocationId, Exception cause) {\n+\t\tfinal Optional<AllocatedSlot> removedSlot = slotPool.removeSlot(allocationId);\n+\n+\t\tOptional<ResourceCounter> previouslyFulfilledRequirement = removedSlot.map(Collections::singleton).map(this::getFulfilledRequirements);\n+\n+\t\tremovedSlot.ifPresent(allocatedSlot -> {\n+\t\t\treleasePayload(Collections.singleton(allocatedSlot), cause);\n+\t\t\treleaseSlots(Collections.singleton(allocatedSlot), cause);\n+\t\t});\n+\n+\t\treturn previouslyFulfilledRequirement.orElseGet(ResourceCounter::empty);\n+\t}\n+\n+\tprivate void releasePayload(Iterable<? extends AllocatedSlot> allocatedSlots, Throwable cause) {\n+\t\tfor (AllocatedSlot allocatedSlot : allocatedSlots) {\n+\t\t\tallocatedSlot.releasePayload(cause);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseIdleSlots(long currentTimeMillis) {\n+\t\tfinal Collection<AllocatedSlotPool.FreeSlotInfo> freeSlotsInformation = slotPool.getFreeSlotsInformation();\n+\n+\t\tResourceCounter excessResources = fulfilledResourceRequirements.subtract(totalResourceRequirements);\n+\n+\t\tfinal Iterator<AllocatedSlotPool.FreeSlotInfo> freeSlotIterator = freeSlotsInformation.iterator();\n+\n+\t\tfinal Collection<AllocatedSlot> slotsToReturnToOwner = new ArrayList<>();\n+\n+\t\twhile (!excessResources.isEmpty() && freeSlotIterator.hasNext()) {\n+\t\t\tfinal AllocatedSlotPool.FreeSlotInfo idleSlot = freeSlotIterator.next();\n+\n+\t\t\tif (currentTimeMillis >= idleSlot.getFreeSince() + idleSlotTimeout.toMilliseconds()) {\n+\t\t\t\tfinal ResourceProfile matchingProfile = getMatchingResourceProfile(idleSlot.getAllocationId());\n+\n+\t\t\t\tif (excessResources.containsResource(matchingProfile)) {\n+\t\t\t\t\texcessResources = excessResources.subtract(matchingProfile, 1);\n+\t\t\t\t\tfinal Optional<AllocatedSlot> removedSlot = slotPool.removeSlot(idleSlot.getAllocationId());\n+\n+\t\t\t\t\tfinal AllocatedSlot allocatedSlot = removedSlot.orElseThrow(() -> new IllegalStateException(String.format(\"Could not find slot for allocation id %s.\", idleSlot.getAllocationId())));\n+\t\t\t\t\tslotsToReturnToOwner.add(allocatedSlot);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\treleaseSlots(slotsToReturnToOwner, new FlinkException(\"Returning idle slots to their owners.\"));\n+\t}\n+\n+\tprivate void releaseSlots(Iterable<AllocatedSlot> slotsToReturnToOwner, Throwable cause) {\n+\t\tfor (AllocatedSlot slotToReturn : slotsToReturnToOwner) {\n+\t\t\tPreconditions.checkState(!slotToReturn.isUsed(), \"Free slot must not be used.\");\n+\n+\t\t\tLOG.info(\"Releasing slot [{}].\", slotToReturn.getAllocationId());", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NDk4MQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524364981", "bodyText": "Maybe better to call this test testReleaseSlotDecreasesFulfilledResourceRequirements.", "author": "tillrohrmann", "createdAt": "2020-11-16T15:44:12Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NTMzMQ==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524365331", "bodyText": "testReleaseSlotReturnsSlot", "author": "tillrohrmann", "createdAt": "2020-11-16T15:44:35Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, resourceRequirements, null);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal ResourceCounter finalResourceRequirements = resourceRequirements.subtract(physicalSlot.getResourceProfile(), 1);\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(finalResourceRequirements));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotReturnsSlot() throws InterruptedException {", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NjE1Mw==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524366153", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// the pending requirement should be fulfilled by the released slot --> rejecting new slot offers\n          \n          \n            \n            \t\t// the pending requirement should be fulfilled by the freed slot --> rejecting new slot offers", "author": "tillrohrmann", "createdAt": "2020-11-16T15:45:35Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, resourceRequirements, null);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal ResourceCounter finalResourceRequirements = resourceRequirements.subtract(physicalSlot.getResourceProfile(), 1);\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(finalResourceRequirements));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotReturnsSlot() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal AllocationID freedSlot = Iterables.getOnlyElement(freeSlotConsumer.drainFreedSlots());\n+\n+\t\tassertThat(freedSlot, is(physicalSlot.getAllocationId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReturnIdleSlotsAfterTimeout() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\t// decrease the resource requirements so that slots are no longer needed\n+\t\tslotPool.decreaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(freedSlots, containsInAnyOrder(acceptedSlots.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t\tassertNoAvailableAndRequiredResources(slotPool);\n+\t}\n+\n+\tprivate void assertNoAvailableAndRequiredResources(DefaultDeclarativeSlotPool slotPool) {\n+\t\tassertTrue(slotPool.getFulfilledResourceRequirements().isEmpty());\n+\t\tassertTrue(slotPool.getResourceRequirements().isEmpty());\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testOnlyReturnExcessIdleSlots() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal ResourceCounter requiredResources = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter excessRequirements = resourceRequirements.subtract(requiredResources);\n+\t\tslotPool.decreaseResourceRequirementsBy(excessRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(requiredResources));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleasedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter initialRequirements = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, initialRequirements, null);\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\t\tfinal PhysicalSlot newSlot = Iterables.getOnlyElement(newSlots);\n+\n+\t\tslotPool.reserveFreeSlot(newSlot.getAllocationId(), RESOURCE_PROFILE_1);\n+\t\tslotPool.freeReservedSlot(newSlot.getAllocationId(), null, 0);\n+\n+\t\tfinal Collection<PhysicalSlot> recycledSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(Iterables.getOnlyElement(recycledSlots), sameInstance(newSlot));\n+\n+\t\tfinal Collection<SlotOffer> newSlotOffers = createSlotOffersForResourceRequirements(initialRequirements);\n+\n+\t\t// the pending requirement should be fulfilled by the released slot --> rejecting new slot offers", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDM2NjI1NA==", "url": "https://github.com/apache/flink/pull/13722#discussion_r524366254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic void testReleasedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {\n          \n          \n            \n            \tpublic void testFreedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {", "author": "tillrohrmann", "createdAt": "2020-11-16T15:45:43Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DefaultDeclarativeSlotPoolTest.java", "diffHunk": "@@ -0,0 +1,550 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.messages.Acknowledge;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGateway;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.apache.flink.shaded.guava18.com.google.common.collect.Iterables;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests for the {@link DefaultDeclarativeSlotPool}.\n+ */\n+public class DefaultDeclarativeSlotPoolTest extends TestLogger {\n+\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_1 = ResourceProfile.newBuilder().setCpuCores(1.7).build();\n+\tprivate static final ResourceProfile RESOURCE_PROFILE_2 = ResourceProfile.newBuilder().setManagedMemoryMB(100).build();\n+\n+\t@Test\n+\tpublic void testIncreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment1 = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter increment2 = createResourceRequirements();\n+\t\tslotPool.increaseResourceRequirementsBy(increment1);\n+\t\tslotPool.increaseResourceRequirementsBy(increment2);\n+\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(increment1)));\n+\n+\t\tfinal ResourceCounter totalResources = increment1.add(increment2);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testDecreasingResourceRequirementsWillSendResourceRequirementNotification() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService requirementsListener = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(requirementsListener);\n+\n+\t\tfinal ResourceCounter increment = ResourceCounter.withResource(RESOURCE_PROFILE_1, 3);\n+\t\tslotPool.increaseResourceRequirementsBy(increment);\n+\n+\t\trequirementsListener.takeResourceRequirements();\n+\n+\t\tfinal ResourceCounter decrement = ResourceCounter.withResource(RESOURCE_PROFILE_1, 2);\n+\t\tslotPool.decreaseResourceRequirementsBy(decrement);\n+\n+\t\tfinal ResourceCounter totalResources = increment.subtract(decrement);\n+\t\tassertThat(requirementsListener.takeResourceRequirements(), is(toResourceRequirements(totalResources)));\n+\t\tassertThat(requirementsListener.hasNextResourceRequirements(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void testGetResourceRequirements() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(ResourceCounter.empty())));\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tassertThat(slotPool.getResourceRequirements(), is(toResourceRequirements(resourceRequirements)));\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferSlots() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tCollection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\n+\t\tfinal Collection<PhysicalSlot> newSlots = drainNewSlotService(notifyNewSlots);\n+\n+\t\tassertThat(newSlots, containsInAnyOrder(slotOffers.stream().map(DefaultDeclarativeSlotPoolTest::matchesSlotOffer).collect(Collectors.toList())));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), containsInAnyOrder(newSlots.stream().map(DefaultAllocatedSlotPoolTest::matchesPhysicalSlot).collect(Collectors.toList())));\n+\t}\n+\n+\t@Test\n+\tpublic void testDuplicateSlotOfferings() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tofferSlots(slotPool, slotOffers);\n+\n+\t\tdrainNewSlotService(notifyNewSlots);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tassertThat(acceptedSlots, containsInAnyOrder(slotOffers.toArray()));\n+\t\t// duplicate slots should not trigger notify new slots\n+\t\tassertFalse(notifyNewSlots.hasNextNewSlots());\n+\t}\n+\n+\t@Test\n+\tpublic void testOfferingTooManySlots() {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tfinal ResourceCounter increasedRequirements = resourceRequirements.add(RESOURCE_PROFILE_1, 2);\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(increasedRequirements);\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal Map<ResourceProfile, Long> resourceProfileCount = acceptedSlots.stream().map(SlotOffer::getResourceProfile).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+\n+\t\tfor (Map.Entry<ResourceProfile, Integer> resourceCount : resourceRequirements.getResourcesWithCount()) {\n+\t\t\tassertThat(resourceProfileCount.getOrDefault(resourceCount.getKey(), 0L), is((long) resourceCount.getValue()));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsRemovesSlots() throws InterruptedException {\n+\t\tfinal NewResourceRequirementsService notifyNewResourceRequirements = new NewResourceRequirementsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewResourceRequirements);\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, createResourceRequirements(), taskManagerLocation);\n+\n+\t\tnotifyNewResourceRequirements.takeResourceRequirements();\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleaseSlotsReturnsSlot() {\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder().build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\n+\t\tfinal LocalTaskManagerLocation taskManagerLocation = new LocalTaskManagerLocation();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> slotOffers = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\ttaskManagerLocation,\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tslotPool.releaseSlots(taskManagerLocation.getResourceID(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(freedSlots, containsInAnyOrder(slotOffers.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotDecreasesResources() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(slotPool, resourceRequirements, null);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal ResourceCounter finalResourceRequirements = resourceRequirements.subtract(physicalSlot.getResourceProfile(), 1);\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(finalResourceRequirements));\n+\t}\n+\n+\t@Test\n+\tpublic void testFailSlotReturnsSlot() throws InterruptedException {\n+\t\tfinal NewSlotsService notifyNewSlots = new NewSlotsService();\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = createDefaultDeclarativeSlotPool(notifyNewSlots);\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tincreaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\tfinal Collection<? extends PhysicalSlot> physicalSlots = notifyNewSlots.takeNewSlots();\n+\n+\t\tfinal PhysicalSlot physicalSlot = physicalSlots.iterator().next();\n+\n+\t\tslotPool.releaseSlot(physicalSlot.getAllocationId(), new FlinkException(\"Test failure\"));\n+\n+\t\tfinal AllocationID freedSlot = Iterables.getOnlyElement(freeSlotConsumer.drainFreedSlots());\n+\n+\t\tassertThat(freedSlot, is(physicalSlot.getAllocationId()));\n+\t}\n+\n+\t@Test\n+\tpublic void testReturnIdleSlotsAfterTimeout() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal FreeSlotConsumer freeSlotConsumer = new FreeSlotConsumer();\n+\t\tfinal TestingTaskExecutorGateway testingTaskExecutorGateway = new TestingTaskExecutorGatewayBuilder()\n+\t\t\t.setFreeSlotFunction(freeSlotConsumer)\n+\t\t\t.createTestingTaskExecutorGateway();\n+\n+\t\tfinal Collection<SlotOffer> acceptedSlots = increaseRequirementsAndOfferSlotsToSlotPool(\n+\t\t\tslotPool,\n+\t\t\tresourceRequirements,\n+\t\t\tnew LocalTaskManagerLocation(),\n+\t\t\ttestingTaskExecutorGateway);\n+\n+\t\t// decrease the resource requirements so that slots are no longer needed\n+\t\tslotPool.decreaseResourceRequirementsBy(resourceRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tfinal Collection<AllocationID> freedSlots = freeSlotConsumer.drainFreedSlots();\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(freedSlots, containsInAnyOrder(acceptedSlots.stream().map(SlotOffer::getAllocationId).toArray()));\n+\t\tassertNoAvailableAndRequiredResources(slotPool);\n+\t}\n+\n+\tprivate void assertNoAvailableAndRequiredResources(DefaultDeclarativeSlotPool slotPool) {\n+\t\tassertTrue(slotPool.getFulfilledResourceRequirements().isEmpty());\n+\t\tassertTrue(slotPool.getResourceRequirements().isEmpty());\n+\t\tassertThat(slotPool.getAllSlotsInformation(), is(empty()));\n+\t}\n+\n+\t@Test\n+\tpublic void testOnlyReturnExcessIdleSlots() {\n+\t\tfinal Time idleSlotTimeout = Time.seconds(10);\n+\t\tfinal long offerTime = 0;\n+\t\tfinal DefaultDeclarativeSlotPool slotPool = DefaultDeclarativeSlotPoolBuilder.builder()\n+\t\t\t.setIdleSlotTimeout(idleSlotTimeout)\n+\t\t\t.build();\n+\n+\t\tfinal ResourceCounter resourceRequirements = createResourceRequirements();\n+\t\tfinal Collection<SlotOffer> slotOffers = createSlotOffersForResourceRequirements(resourceRequirements);\n+\n+\t\tslotPool.increaseResourceRequirementsBy(resourceRequirements);\n+\t\tfinal Collection<SlotOffer> acceptedSlots = offerSlots(slotPool, slotOffers);\n+\n+\t\tfinal ResourceCounter requiredResources = ResourceCounter.withResource(RESOURCE_PROFILE_1, 1);\n+\t\tfinal ResourceCounter excessRequirements = resourceRequirements.subtract(requiredResources);\n+\t\tslotPool.decreaseResourceRequirementsBy(excessRequirements);\n+\n+\t\tslotPool.releaseIdleSlots(offerTime + idleSlotTimeout.toMilliseconds());\n+\n+\t\tassertThat(acceptedSlots, is(not(empty())));\n+\t\tassertThat(slotPool.getFulfilledResourceRequirements(), is(requiredResources));\n+\t}\n+\n+\t@Test\n+\tpublic void testReleasedSlotWillBeUsedToFulfillOutstandingResourceRequirements() throws InterruptedException {", "originalCommit": "d270f9a8685dc9d2184de39a4c26b70d68552886", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2f59bf5d7da389a1f208497fec6d4453bee129de", "url": "https://github.com/apache/flink/commit/2f59bf5d7da389a1f208497fec6d4453bee129de", "message": "address comments", "committedDate": "2020-12-01T14:22:04Z", "type": "forcePushed"}, {"oid": "91068790a648e9a9d3a7da310e0bd69d8929730d", "url": "https://github.com/apache/flink/commit/91068790a648e9a9d3a7da310e0bd69d8929730d", "message": "[FLINK-19636][coordination] Refactor matching logic to make it re-usable", "committedDate": "2020-12-02T21:59:13Z", "type": "commit"}, {"oid": "547fd643bcee8a22d48697b952efeeebdc68a1f3", "url": "https://github.com/apache/flink/commit/547fd643bcee8a22d48697b952efeeebdc68a1f3", "message": "[FLINK-19636][coordination] Add DeclarativeSlotPool", "committedDate": "2020-12-02T21:59:13Z", "type": "commit"}, {"oid": "948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "url": "https://github.com/apache/flink/commit/948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "message": "[FLINK-19715][coordination] Fix inefficiencies in assignment of excess resources", "committedDate": "2020-12-02T21:59:13Z", "type": "commit"}, {"oid": "948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "url": "https://github.com/apache/flink/commit/948c92c9a9ea9f6f31b0e0b005e9373b9a897a71", "message": "[FLINK-19715][coordination] Fix inefficiencies in assignment of excess resources", "committedDate": "2020-12-02T21:59:13Z", "type": "forcePushed"}]}