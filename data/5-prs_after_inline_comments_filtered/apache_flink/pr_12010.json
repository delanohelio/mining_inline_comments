{"pr_number": 12010, "pr_title": "[FLINK-17286][connectors / filesystem]Integrate json to file system connector", "pr_createdAt": "2020-05-06T16:06:41Z", "pr_url": "https://github.com/apache/flink/pull/12010", "timeline": [{"oid": "525937f5ebb7779216fddf1697c522dfda897e1a", "url": "https://github.com/apache/flink/commit/525937f5ebb7779216fddf1697c522dfda897e1a", "message": "[FLINK-17286][connectors / filesystem]move PartitionPathUtils from flink-table-runtime-blink to flink-table-common", "committedDate": "2020-05-06T15:53:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMDIxMQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r421200211", "bodyText": "This class is not for user, we don't need builder.", "author": "JingsongLi", "createdAt": "2020-05-07T02:19:53Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonRowDataFileInputFormat.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A {@link JsonRowDataFileInputFormat} is responsible to read {@link RowData} records\n+ * from json format files.\n+ */\n+public class JsonRowDataFileInputFormat extends AbstractJsonFileInputFormat<RowData> {\n+\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tprivate final List<DataType> fieldTypes;\n+\tprivate final List<String> fieldNames;\n+\tprivate final int[] selectFields;\n+\tprivate final List<String> partitionKeys;\n+\tprivate final String defaultPartValue;\n+\tprivate final long limit;\n+\tprivate final List<String> jsonSelectFieldNames;\n+\tprivate final int[] jsonFieldMapping;\n+\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\tprivate transient boolean end;\n+\tprivate transient long emitted;\n+\t// reuse object for per record\n+\tprivate transient GenericRowData rowData;\n+\tprivate transient InputStreamReader inputStreamReader;\n+\tprivate transient BufferedReader reader;\n+\tprivate transient Charset charset;\n+\n+\tprivate JsonRowDataFileInputFormat(\n+\t\tPath[] filePaths,\n+\t\tRowType nonPartitionRowType,\n+\t\tTypeInformation nonPartitionRowTypeInfo,\n+\t\tList<DataType> dataTypes,\n+\t\tList<String> fieldNames,\n+\t\tint[] selectFields,\n+\t\tList<String> partitionKeys,\n+\t\tString defaultPartValue,\n+\t\tboolean failOnMissingField,\n+\t\tboolean ignoreParseErrors,\n+\t\tlong limit) {\n+\t\tsuper(filePaths);\n+\t\tthis.fieldTypes = dataTypes;\n+\t\tthis.fieldNames = fieldNames;\n+\t\tthis.selectFields = selectFields;\n+\t\tthis.partitionKeys = partitionKeys;\n+\t\tthis.defaultPartValue = defaultPartValue;\n+\t\tthis.limit = limit;\n+\t\t// project field\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tthis.jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tthis.jsonFieldMapping = jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\t\tthis.deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartitionRowType,\n+\t\t\tnonPartitionRowTypeInfo,\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\t}\n+\n+\t@Override\n+\tpublic void open(FileInputSplit split) throws IOException {\n+\t\tsuper.open(split);\n+\t\tthis.end = false;\n+\t\tthis.inputStreamReader = new InputStreamReader(jsonInputStream);\n+\t\tthis.reader = new BufferedReader(inputStreamReader);\n+\t\tthis.charset = Charset.forName(\"UTF-8\");\n+\t\tfillPartitionValueForRecord();\n+\t\tthis.emitted = 0L;\n+\t}\n+\n+\tprivate void fillPartitionValueForRecord() {\n+\t\trowData = new GenericRowData(selectFields.length);\n+\t\tPath path = currentSplit.getPath();\n+\t\tLinkedHashMap<String, String> partSpec = PartitionPathUtils.extractPartitionSpecFromPath(path);\n+\t\tfor (int i = 0; i < selectFields.length; i++) {\n+\t\t\tint selectField = selectFields[i];\n+\t\t\tString name = fieldNames.get(selectField);\n+\t\t\tif (partitionKeys.contains(name)) {\n+\t\t\t\tString value = partSpec.get(name);\n+\t\t\t\tvalue = defaultPartValue.equals(value) ? null : value;\n+\t\t\t\trowData.setField(i, PartitionPathUtils.restorePartValueFromType(value, fieldTypes.get(selectField)));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean reachedEnd() throws IOException {\n+\t\treturn emitted >= limit || end;\n+\t}\n+\n+\t@Override\n+\tpublic RowData nextRecord(RowData reuse) throws IOException {\n+\t\tGenericRowData returnRecord = rowData;\n+\t\tString line = reader.readLine();\n+\t\tif (line == null) {\n+\t\t\tthis.end = true;\n+\t\t\treturn null;\n+\t\t}\n+\t\tGenericRowData jsonRow = (GenericRowData) deserializationSchema.deserialize(line.getBytes(charset));\n+\t\tif (jsonRow != null) {\n+\t\t\tfor (int i = 0; i < jsonSelectFieldNames.size(); i++) {\n+\t\t\t\treturnRecord.setField(jsonFieldMapping[i], jsonRow.getField(i));\n+\t\t\t}\n+\t\t}\n+\t\temitted++;\n+\t\treturn returnRecord;\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tsuper.close();\n+\t\tif (reader != null) {\n+\t\t\tthis.reader.close();\n+\t\t\tthis.reader = null;\n+\t\t}\n+\t\tif (inputStreamReader != null) {\n+\t\t\tthis.inputStreamReader.close();\n+\t\t\tthis.inputStreamReader = null;\n+\t\t}\n+\t}\n+\n+\tpublic static Builder builder(FileSystemFormatFactory.ReaderContext context, TableSchema tableSchema, List<String> partitionKeys, Path... filePaths) {\n+\t\treturn new Builder(context, tableSchema, partitionKeys, filePaths);\n+\t}\n+\n+\t/**\n+\t * Builder for {@link JsonRowDataFileInputFormat}.\n+\t */\n+\tpublic static class Builder {", "originalCommit": "d7445e68ed77a6b1b88fdf0dac8638ff62ac8967", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMDcxNg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r421200716", "bodyText": "We don't need type info now.", "author": "JingsongLi", "createdAt": "2020-05-07T02:21:54Z", "path": "flink-table/flink-table-runtime-blink/src/main/java/org/apache/flink/table/filesystem/FileSystemTableSource.java", "diffHunk": "@@ -121,6 +127,14 @@ public TableSchema getSchema() {\n \t\t\t\treturn schema;\n \t\t\t}\n \n+\t\t\t@Override\n+\t\t\tpublic TypeInformation<?> createTypeInformation(DataType dataType) {", "originalCommit": "d7445e68ed77a6b1b88fdf0dac8638ff62ac8967", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMjE1Nw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r421202157", "bodyText": "JsonRowDataDeserializationSchema need this type info", "author": "leonardBang", "createdAt": "2020-05-07T02:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMDcxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNDQyOA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r421404428", "bodyText": "we can pass a GenericTypeInformation", "author": "leonardBang", "createdAt": "2020-05-07T10:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMDcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMTI2MQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r421201261", "bodyText": "This can be an inner class in FormatFactory just like parquet and orc.", "author": "JingsongLi", "createdAt": "2020-05-07T02:24:09Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonRowDataFileInputFormat.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+\n+/**\n+ * A {@link JsonRowDataFileInputFormat} is responsible to read {@link RowData} records\n+ * from json format files.\n+ */\n+public class JsonRowDataFileInputFormat extends AbstractJsonFileInputFormat<RowData> {", "originalCommit": "d7445e68ed77a6b1b88fdf0dac8638ff62ac8967", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNDAwMw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r421404003", "bodyText": "Thanks for contribution.\nWe need introduce an option multiLine, it default value is false now. (We can not support true, but should throw a good unsupported exception)\n\nHi, @JingsongLi multiline option for support read multiline per time? I don't get this point, could you explain more ?", "author": "leonardBang", "createdAt": "2020-05-07T10:31:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMTI2MQ=="}], "type": "inlineReview"}, {"oid": "c3958066f46822218c29a10c7bad1d4d699949f8", "url": "https://github.com/apache/flink/commit/c3958066f46822218c29a10c7bad1d4d699949f8", "message": "[FLINK-17286][connectors/filesystem]Integrate json to file system connector", "committedDate": "2020-05-07T12:56:50Z", "type": "commit"}, {"oid": "c3958066f46822218c29a10c7bad1d4d699949f8", "url": "https://github.com/apache/flink/commit/c3958066f46822218c29a10c7bad1d4d699949f8", "message": "[FLINK-17286][connectors/filesystem]Integrate json to file system connector", "committedDate": "2020-05-07T12:56:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNDgwOQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422024809", "bodyText": "Standardxxx.UTF-8", "author": "JingsongLi", "createdAt": "2020-05-08T08:46:55Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tint[] jsonFieldMapping =  jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\treturn new JsonFileSystemFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tfieldTypes,\n+\t\t\tfieldNames,\n+\t\t\tselectFields,\n+\t\t\tpartitionKeys,\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldNames,\n+\t\t\tjsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\tTableSchema nonPartKeySchema = new TableSchema.Builder()\n+\t\t\t.fields(context.getFieldNamesWithoutPartKeys(), context.getFieldTypesWithoutPartKeys())\n+\t\t\t.build();\n+\t\tLogicalType[] logicalTypes = Arrays.asList(nonPartKeySchema.getFieldDataTypes())\n+\t\t\t.stream().map(DataType::getLogicalType).toArray(LogicalType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(logicalTypes, nonPartKeySchema.getFieldNames());\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(nonPartRowType)));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonFileSystemFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonFileSystemFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\t/**\n+\t\t * The name of the charset to use for decoding.\n+\t\t */\n+\t\tprivate String charsetName = \"UTF-8\";\n+\n+\t\tprivate final List<DataType> fieldTypes;\n+\t\tprivate final List<String> fieldNames;\n+\t\tprivate final int[] selectFields;\n+\t\tprivate final List<String> partitionKeys;\n+\t\tprivate final String defaultPartValue;\n+\t\tprivate final long limit;\n+\t\tprivate final List<String> jsonSelectFieldNames;\n+\t\tprivate final int[] jsonFieldMapping;\n+\t\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\t\tprivate transient boolean end;\n+\t\tprivate transient long emitted;\n+\t\t// reuse object for per record\n+\t\tprivate transient GenericRowData rowData;\n+\n+\t\tpublic JsonFileSystemFormat(\n+\t\t\t\tPath[] filePaths,\n+\t\t\t\tList<DataType> fieldTypes,\n+\t\t\t\tList<String> fieldNames,\n+\t\t\t\tint[] selectFields,\n+\t\t\t\tList<String> partitionKeys,\n+\t\t\t\tString defaultPartValue,\n+\t\t\t\tlong limit,\n+\t\t\t\tList<String> jsonSelectFieldNames,\n+\t\t\t\tint[] jsonFieldMapping,\n+\t\t\t\tJsonRowDataDeserializationSchema deserializationSchema) {\n+\t\t\tsuper.setFilePaths(filePaths);\n+\t\t\tthis.fieldTypes = fieldTypes;\n+\t\t\tthis.fieldNames = fieldNames;\n+\t\t\tthis.selectFields = selectFields;\n+\t\t\tthis.partitionKeys = partitionKeys;\n+\t\t\tthis.defaultPartValue = defaultPartValue;\n+\t\t\tthis.limit = limit;\n+\t\t\tthis.jsonSelectFieldNames = jsonSelectFieldNames;\n+\t\t\tthis.jsonFieldMapping = jsonFieldMapping;\n+\t\t\tthis.deserializationSchema = deserializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void configure(Configuration parameters) {\n+\t\t\tsuper.configure(parameters);\n+\n+\t\t\tif (charsetName == null || !Charset.isSupported(charsetName)) {\n+\t\t\t\tthrow new RuntimeException(\"Unsupported charset: \" + charsetName);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsMultiPaths() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open(FileInputSplit split) throws IOException {\n+\t\t\tsuper.open(split);\n+\t\t\tthis.end = false;\n+\t\t\tfillPartitionValueForRecord();\n+\t\t\tthis.emitted = 0L;\n+\t\t}\n+\n+\t\tprivate void fillPartitionValueForRecord() {\n+\t\t\trowData = new GenericRowData(selectFields.length);\n+\t\t\tPath path = currentSplit.getPath();\n+\t\t\tLinkedHashMap<String, String> partSpec = PartitionPathUtils.extractPartitionSpecFromPath(path);\n+\t\t\tfor (int i = 0; i < selectFields.length; i++) {\n+\t\t\t\tint selectField = selectFields[i];\n+\t\t\t\tString name = fieldNames.get(selectField);\n+\t\t\t\tif (partitionKeys.contains(name)) {\n+\t\t\t\t\tString value = partSpec.get(name);\n+\t\t\t\t\tvalue = defaultPartValue.equals(value) ? null : value;\n+\t\t\t\t\trowData.setField(i, PartitionPathUtils.restorePartValueFromType(value, fieldTypes.get(selectField)));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean reachedEnd() {\n+\t\t\treturn emitted >= limit || end;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic RowData readRecord(RowData reuse, byte[] bytes, int offset, int numBytes) throws IOException {\n+\t\t\tGenericRowData returnRecord = rowData;\n+\n+\t\t\tif (this.getDelimiter() != null && this.getDelimiter().length == 1\n+\t\t\t\t&& this.getDelimiter()[0] == NEW_LINE && offset + numBytes >= 1\n+\t\t\t\t&& bytes[offset + numBytes - 1] == CARRIAGE_RETURN){\n+\t\t\t\tnumBytes -= 1;\n+\t\t\t}\n+\t\t\tbyte[] trimBytes = Arrays.copyOfRange(bytes, offset, offset + numBytes);\n+\t\t\tGenericRowData jsonRow = (GenericRowData) deserializationSchema.deserialize(trimBytes);\n+\t\t\tif (jsonRow != null) {\n+\t\t\t\tfor (int i = 0; i < jsonSelectFieldNames.size(); i++) {\n+\t\t\t\t\treturnRecord.setField(jsonFieldMapping[i], jsonRow.getField(i));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\temitted++;\n+\t\t\treturn returnRecord;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * A {@link JsonRowDataEncoder} is responsible to encode a {@link RowData} to {@link java.io.OutputStream}\n+\t * with json format.\n+\t */\n+\tpublic static class JsonRowDataEncoder implements Encoder<RowData> {\n+\n+\t\tprivate static final long serialVersionUID = 1L;\n+\t\tprivate static final String DEFAULT_LINE_DELIMITER = \"\\n\";\n+\t\tprivate final JsonRowDataSerializationSchema serializationSchema;\n+\n+\t\tpublic JsonRowDataEncoder(JsonRowDataSerializationSchema serializationSchema) {\n+\t\t\tthis.serializationSchema = serializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void encode(RowData element, OutputStream stream) throws IOException {\n+\t\t\tstream.write(serializationSchema.serialize(element));\n+\t\t\tstream.write(DEFAULT_LINE_DELIMITER.getBytes());", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNTk0Mg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422025942", "bodyText": "Can extract a method or class to put it in 'PartitionPathUtils'?", "author": "JingsongLi", "createdAt": "2020-05-08T08:49:17Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tint[] jsonFieldMapping =  jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\treturn new JsonFileSystemFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tfieldTypes,\n+\t\t\tfieldNames,\n+\t\t\tselectFields,\n+\t\t\tpartitionKeys,\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldNames,\n+\t\t\tjsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\tTableSchema nonPartKeySchema = new TableSchema.Builder()\n+\t\t\t.fields(context.getFieldNamesWithoutPartKeys(), context.getFieldTypesWithoutPartKeys())\n+\t\t\t.build();\n+\t\tLogicalType[] logicalTypes = Arrays.asList(nonPartKeySchema.getFieldDataTypes())\n+\t\t\t.stream().map(DataType::getLogicalType).toArray(LogicalType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(logicalTypes, nonPartKeySchema.getFieldNames());\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(nonPartRowType)));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonFileSystemFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonFileSystemFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\t/**\n+\t\t * The name of the charset to use for decoding.\n+\t\t */\n+\t\tprivate String charsetName = \"UTF-8\";\n+\n+\t\tprivate final List<DataType> fieldTypes;\n+\t\tprivate final List<String> fieldNames;\n+\t\tprivate final int[] selectFields;\n+\t\tprivate final List<String> partitionKeys;\n+\t\tprivate final String defaultPartValue;\n+\t\tprivate final long limit;\n+\t\tprivate final List<String> jsonSelectFieldNames;\n+\t\tprivate final int[] jsonFieldMapping;\n+\t\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\t\tprivate transient boolean end;\n+\t\tprivate transient long emitted;\n+\t\t// reuse object for per record\n+\t\tprivate transient GenericRowData rowData;\n+\n+\t\tpublic JsonFileSystemFormat(\n+\t\t\t\tPath[] filePaths,\n+\t\t\t\tList<DataType> fieldTypes,\n+\t\t\t\tList<String> fieldNames,\n+\t\t\t\tint[] selectFields,\n+\t\t\t\tList<String> partitionKeys,\n+\t\t\t\tString defaultPartValue,\n+\t\t\t\tlong limit,\n+\t\t\t\tList<String> jsonSelectFieldNames,\n+\t\t\t\tint[] jsonFieldMapping,\n+\t\t\t\tJsonRowDataDeserializationSchema deserializationSchema) {\n+\t\t\tsuper.setFilePaths(filePaths);\n+\t\t\tthis.fieldTypes = fieldTypes;\n+\t\t\tthis.fieldNames = fieldNames;\n+\t\t\tthis.selectFields = selectFields;\n+\t\t\tthis.partitionKeys = partitionKeys;\n+\t\t\tthis.defaultPartValue = defaultPartValue;\n+\t\t\tthis.limit = limit;\n+\t\t\tthis.jsonSelectFieldNames = jsonSelectFieldNames;\n+\t\t\tthis.jsonFieldMapping = jsonFieldMapping;\n+\t\t\tthis.deserializationSchema = deserializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void configure(Configuration parameters) {\n+\t\t\tsuper.configure(parameters);\n+\n+\t\t\tif (charsetName == null || !Charset.isSupported(charsetName)) {\n+\t\t\t\tthrow new RuntimeException(\"Unsupported charset: \" + charsetName);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsMultiPaths() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open(FileInputSplit split) throws IOException {\n+\t\t\tsuper.open(split);\n+\t\t\tthis.end = false;\n+\t\t\tfillPartitionValueForRecord();\n+\t\t\tthis.emitted = 0L;\n+\t\t}\n+\n+\t\tprivate void fillPartitionValueForRecord() {", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNjg5Nw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422026897", "bodyText": "convertStringToInternalValue?", "author": "JingsongLi", "createdAt": "2020-05-08T08:51:30Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/utils/PartitionPathUtils.java", "diffHunk": "@@ -201,6 +210,50 @@ public static String unescapePathName(String path) {\n \t\treturn ret;\n \t}\n \n+\t/**\n+\t * Restore partition value from string and type.\n+\t *\n+\t * @param valStr string partition value.\n+\t * @param type type of partition field.\n+\t * @return partition value.\n+\t */\n+\tpublic static Object restorePartValueFromType(String valStr, DataType type) {", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzAyNg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422027026", "bodyText": "why floatValue ?", "author": "JingsongLi", "createdAt": "2020-05-08T08:51:47Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/utils/PartitionPathUtils.java", "diffHunk": "@@ -201,6 +210,50 @@ public static String unescapePathName(String path) {\n \t\treturn ret;\n \t}\n \n+\t/**\n+\t * Restore partition value from string and type.\n+\t *\n+\t * @param valStr string partition value.\n+\t * @param type type of partition field.\n+\t * @return partition value.\n+\t */\n+\tpublic static Object restorePartValueFromType(String valStr, DataType type) {\n+\t\tif (valStr == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tLogicalTypeRoot typeRoot = type.getLogicalType().getTypeRoot();\n+\t\tswitch (typeRoot) {\n+\t\t\tcase CHAR:\n+\t\t\tcase VARCHAR:\n+\t\t\t\treturn StringData.fromString(valStr);\n+\t\t\tcase BOOLEAN:\n+\t\t\t\treturn Boolean.parseBoolean(valStr);\n+\t\t\tcase TINYINT:\n+\t\t\t\treturn Byte.parseByte(valStr);\n+\t\t\tcase SMALLINT:\n+\t\t\t\treturn Short.parseShort(valStr);\n+\t\t\tcase INTEGER:\n+\t\t\t\treturn Integer.parseInt(valStr);\n+\t\t\tcase BIGINT:\n+\t\t\t\treturn Long.parseLong(valStr);\n+\t\t\tcase FLOAT:\n+\t\t\t\treturn Float.valueOf(valStr).floatValue();", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEzMzk3NQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422133975", "bodyText": "will use Float.parseFloat() too", "author": "leonardBang", "createdAt": "2020-05-08T13:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNzkzMw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422027933", "bodyText": "JsonBatchFileSystemITCase?", "author": "JingsongLi", "createdAt": "2020-05-08T08:53:45Z", "path": "flink-formats/flink-json/src/test/java/org/apache/flink/formats/json/FsBatchJsonSinkITCase.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.table.planner.runtime.batch.sql.BatchFileSystemITCaseBase;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * ITCase to test json format for {@link JsonFileSystemFormatFactory}.\n+ */\n+@RunWith(Parameterized.class)\n+public class FsBatchJsonSinkITCase extends BatchFileSystemITCaseBase {", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyODAyNA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422028024", "bodyText": "JsonFsStreamSinkITCase", "author": "JingsongLi", "createdAt": "2020-05-08T08:53:58Z", "path": "flink-formats/flink-json/src/test/java/org/apache/flink/formats/json/FsStreamJsonSinkITCase.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.table.planner.runtime.stream.FsStreamingSinkITCaseBase;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Test checkpoint for file system table factory with json format.\n+ */\n+public class FsStreamJsonSinkITCase extends FsStreamingSinkITCaseBase {", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyODM2MA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422028360", "bodyText": "What is this for?", "author": "JingsongLi", "createdAt": "2020-05-08T08:54:41Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tint[] jsonFieldMapping =  jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\treturn new JsonFileSystemFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tfieldTypes,\n+\t\t\tfieldNames,\n+\t\t\tselectFields,\n+\t\t\tpartitionKeys,\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldNames,\n+\t\t\tjsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\tTableSchema nonPartKeySchema = new TableSchema.Builder()\n+\t\t\t.fields(context.getFieldNamesWithoutPartKeys(), context.getFieldTypesWithoutPartKeys())\n+\t\t\t.build();\n+\t\tLogicalType[] logicalTypes = Arrays.asList(nonPartKeySchema.getFieldDataTypes())\n+\t\t\t.stream().map(DataType::getLogicalType).toArray(LogicalType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(logicalTypes, nonPartKeySchema.getFieldNames());\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(nonPartRowType)));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonFileSystemFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonFileSystemFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\t/**\n+\t\t * The name of the charset to use for decoding.\n+\t\t */\n+\t\tprivate String charsetName = \"UTF-8\";", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjEyMjM5Mw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422122393", "bodyText": "I wanted to construct a transient Charset, but now it don't need any more after use StandardCharsets.UTF_8", "author": "leonardBang", "createdAt": "2020-05-08T12:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyODM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyODY0MQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422028641", "bodyText": "JsonInputFormat", "author": "JingsongLi", "createdAt": "2020-05-08T08:55:18Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.configuration.Configuration;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tint[] jsonFieldMapping =  jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\treturn new JsonFileSystemFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tfieldTypes,\n+\t\t\tfieldNames,\n+\t\t\tselectFields,\n+\t\t\tpartitionKeys,\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldNames,\n+\t\t\tjsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\tTableSchema nonPartKeySchema = new TableSchema.Builder()\n+\t\t\t.fields(context.getFieldNamesWithoutPartKeys(), context.getFieldTypesWithoutPartKeys())\n+\t\t\t.build();\n+\t\tLogicalType[] logicalTypes = Arrays.asList(nonPartKeySchema.getFieldDataTypes())\n+\t\t\t.stream().map(DataType::getLogicalType).toArray(LogicalType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(logicalTypes, nonPartKeySchema.getFieldNames());\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(nonPartRowType)));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonFileSystemFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonFileSystemFormat extends DelimitedInputFormat<RowData> {", "originalCommit": "c3958066f46822218c29a10c7bad1d4d699949f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "url": "https://github.com/apache/flink/commit/e13ca920f02c00cfc883bc55499d7c179b7a8564", "message": "address comments", "committedDate": "2020-05-08T14:07:33Z", "type": "commit"}, {"oid": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "url": "https://github.com/apache/flink/commit/e13ca920f02c00cfc883bc55499d7c179b7a8564", "message": "address comments", "committedDate": "2020-05-08T14:07:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzOTgzMg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422439832", "bodyText": "It is better to left an empty line in the first of class.", "author": "JingsongLi", "createdAt": "2020-05-09T01:53:09Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override", "originalCommit": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzOTk0NQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422439945", "bodyText": "Don't need a table schema, Just:\nLogicalType[] logicalTypes = Arrays.stream(context.getFieldTypesWithoutPartKeys())\n\t\t\t\t.map(DataType::getLogicalType)\n\t\t\t\t.toArray(LogicalType[]::new);\n\t\tRowType nonPartRowType = RowType.of(logicalTypes, context.getFieldNamesWithoutPartKeys());\n\nAnd please add a method into WriterContext. So we can reuse this in csv.", "author": "JingsongLi", "createdAt": "2020-05-09T01:54:47Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tint[] jsonFieldMapping =  jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\treturn new JsonInputFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tfieldTypes,\n+\t\t\tfieldNames,\n+\t\t\tselectFields,\n+\t\t\tpartitionKeys,\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldNames,\n+\t\t\tjsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\tTableSchema nonPartKeySchema = new TableSchema.Builder()", "originalCommit": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDI0Mg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422440242", "bodyText": "Notice to use Arrays.stream", "author": "JingsongLi", "createdAt": "2020-05-09T01:58:24Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()", "originalCommit": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDczOQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422440739", "bodyText": "Can you also add methods to ReaderContext:\ngetRowTypeWithoutPartKeys", "author": "JingsongLi", "createdAt": "2020-05-09T02:04:22Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(", "originalCommit": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDg3Ng==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422440876", "bodyText": "jsonRow.getField? jsonSelectFieldNames useless?\nYou can add tests too.", "author": "JingsongLi", "createdAt": "2020-05-09T02:05:48Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tint[] jsonFieldMapping =  jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\treturn new JsonInputFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tfieldTypes,\n+\t\t\tfieldNames,\n+\t\t\tselectFields,\n+\t\t\tpartitionKeys,\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldNames,\n+\t\t\tjsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\tTableSchema nonPartKeySchema = new TableSchema.Builder()\n+\t\t\t.fields(context.getFieldNamesWithoutPartKeys(), context.getFieldTypesWithoutPartKeys())\n+\t\t\t.build();\n+\t\tLogicalType[] logicalTypes = Arrays.asList(nonPartKeySchema.getFieldDataTypes())\n+\t\t\t.stream().map(DataType::getLogicalType).toArray(LogicalType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(logicalTypes, nonPartKeySchema.getFieldNames());\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(nonPartRowType)));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonInputFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonInputFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\tprivate final List<DataType> fieldTypes;\n+\t\tprivate final List<String> fieldNames;\n+\t\tprivate final int[] selectFields;\n+\t\tprivate final List<String> partitionKeys;\n+\t\tprivate final String defaultPartValue;\n+\t\tprivate final long limit;\n+\t\tprivate final List<String> jsonSelectFieldNames;\n+\t\tprivate final int[] jsonFieldMapping;\n+\t\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\t\tprivate transient boolean end;\n+\t\tprivate transient long emitted;\n+\t\t// reuse object for per record\n+\t\tprivate transient GenericRowData rowData;\n+\n+\t\tpublic JsonInputFormat(\n+\t\t\t\tPath[] filePaths,\n+\t\t\t\tList<DataType> fieldTypes,\n+\t\t\t\tList<String> fieldNames,\n+\t\t\t\tint[] selectFields,\n+\t\t\t\tList<String> partitionKeys,\n+\t\t\t\tString defaultPartValue,\n+\t\t\t\tlong limit,\n+\t\t\t\tList<String> jsonSelectFieldNames,\n+\t\t\t\tint[] jsonFieldMapping,\n+\t\t\t\tJsonRowDataDeserializationSchema deserializationSchema) {\n+\t\t\tsuper.setFilePaths(filePaths);\n+\t\t\tthis.fieldTypes = fieldTypes;\n+\t\t\tthis.fieldNames = fieldNames;\n+\t\t\tthis.selectFields = selectFields;\n+\t\t\tthis.partitionKeys = partitionKeys;\n+\t\t\tthis.defaultPartValue = defaultPartValue;\n+\t\t\tthis.limit = limit;\n+\t\t\tthis.jsonSelectFieldNames = jsonSelectFieldNames;\n+\t\t\tthis.jsonFieldMapping = jsonFieldMapping;\n+\t\t\tthis.deserializationSchema = deserializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsMultiPaths() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open(FileInputSplit split) throws IOException {\n+\t\t\tsuper.open(split);\n+\t\t\tthis.end = false;\n+\t\t\tthis.emitted = 0L;\n+\t\t\tthis.rowData = PartitionPathUtils.fillPartitionValueForRecord(fieldNames, fieldTypes, selectFields,\n+\t\t\t\tpartitionKeys, currentSplit.getPath(), defaultPartValue);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean reachedEnd() {\n+\t\t\treturn emitted >= limit || end;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic RowData readRecord(RowData reuse, byte[] bytes, int offset, int numBytes) throws IOException {\n+\t\t\tGenericRowData returnRecord = rowData;\n+\n+\t\t\tif (this.getDelimiter() != null && this.getDelimiter().length == 1\n+\t\t\t\t&& this.getDelimiter()[0] == NEW_LINE && offset + numBytes >= 1\n+\t\t\t\t&& bytes[offset + numBytes - 1] == CARRIAGE_RETURN){\n+\t\t\t\tnumBytes -= 1;\n+\t\t\t}\n+\t\t\tbyte[] trimBytes = Arrays.copyOfRange(bytes, offset, offset + numBytes);\n+\t\t\tGenericRowData jsonRow = (GenericRowData) deserializationSchema.deserialize(trimBytes);\n+\t\t\tif (jsonRow != null) {\n+\t\t\t\tfor (int i = 0; i < jsonSelectFieldNames.size(); i++) {\n+\t\t\t\t\treturnRecord.setField(jsonFieldMapping[i], jsonRow.getField(i));", "originalCommit": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0NzU1Ng==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422447556", "bodyText": "jsonSelectFieldNames length may less than jsonRow.size()?", "author": "leonardBang", "createdAt": "2020-05-09T03:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0ODE0Mg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422448142", "bodyText": "Do you want the project fields? But only the fields in front?", "author": "JingsongLi", "createdAt": "2020-05-09T03:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0ODE1Mw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422448153", "bodyText": "got your point\uff0cuse:\nfor (int i = 0; i < jsonFieldMapping.length; i++) {\n\treturnRecord.setField(jsonFieldMapping[i], jsonRow.getField(i));\n}", "author": "leonardBang", "createdAt": "2020-05-09T03:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0ODE4Mw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422448183", "bodyText": "It looks like totally wrong, you could add some projection tests.", "author": "JingsongLi", "createdAt": "2020-05-09T03:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDk5MA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422440990", "bodyText": "jsonRow != null? So what will be happen when jsonRow is null?", "author": "JingsongLi", "createdAt": "2020-05-09T02:06:55Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()\n+\t\t\t.filter(name -> !partitionKeys.contains(name)).collect(Collectors.toList());\n+\t\tint[] jsonFieldMapping =  jsonSelectFieldNames.stream().mapToInt(selectFieldNames::indexOf).toArray();\n+\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\treturn new JsonInputFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tfieldTypes,\n+\t\t\tfieldNames,\n+\t\t\tselectFields,\n+\t\t\tpartitionKeys,\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldNames,\n+\t\t\tjsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\tTableSchema nonPartKeySchema = new TableSchema.Builder()\n+\t\t\t.fields(context.getFieldNamesWithoutPartKeys(), context.getFieldTypesWithoutPartKeys())\n+\t\t\t.build();\n+\t\tLogicalType[] logicalTypes = Arrays.asList(nonPartKeySchema.getFieldDataTypes())\n+\t\t\t.stream().map(DataType::getLogicalType).toArray(LogicalType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(logicalTypes, nonPartKeySchema.getFieldNames());\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(nonPartRowType)));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonInputFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonInputFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\tprivate final List<DataType> fieldTypes;\n+\t\tprivate final List<String> fieldNames;\n+\t\tprivate final int[] selectFields;\n+\t\tprivate final List<String> partitionKeys;\n+\t\tprivate final String defaultPartValue;\n+\t\tprivate final long limit;\n+\t\tprivate final List<String> jsonSelectFieldNames;\n+\t\tprivate final int[] jsonFieldMapping;\n+\t\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\t\tprivate transient boolean end;\n+\t\tprivate transient long emitted;\n+\t\t// reuse object for per record\n+\t\tprivate transient GenericRowData rowData;\n+\n+\t\tpublic JsonInputFormat(\n+\t\t\t\tPath[] filePaths,\n+\t\t\t\tList<DataType> fieldTypes,\n+\t\t\t\tList<String> fieldNames,\n+\t\t\t\tint[] selectFields,\n+\t\t\t\tList<String> partitionKeys,\n+\t\t\t\tString defaultPartValue,\n+\t\t\t\tlong limit,\n+\t\t\t\tList<String> jsonSelectFieldNames,\n+\t\t\t\tint[] jsonFieldMapping,\n+\t\t\t\tJsonRowDataDeserializationSchema deserializationSchema) {\n+\t\t\tsuper.setFilePaths(filePaths);\n+\t\t\tthis.fieldTypes = fieldTypes;\n+\t\t\tthis.fieldNames = fieldNames;\n+\t\t\tthis.selectFields = selectFields;\n+\t\t\tthis.partitionKeys = partitionKeys;\n+\t\t\tthis.defaultPartValue = defaultPartValue;\n+\t\t\tthis.limit = limit;\n+\t\t\tthis.jsonSelectFieldNames = jsonSelectFieldNames;\n+\t\t\tthis.jsonFieldMapping = jsonFieldMapping;\n+\t\t\tthis.deserializationSchema = deserializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsMultiPaths() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open(FileInputSplit split) throws IOException {\n+\t\t\tsuper.open(split);\n+\t\t\tthis.end = false;\n+\t\t\tthis.emitted = 0L;\n+\t\t\tthis.rowData = PartitionPathUtils.fillPartitionValueForRecord(fieldNames, fieldTypes, selectFields,\n+\t\t\t\tpartitionKeys, currentSplit.getPath(), defaultPartValue);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean reachedEnd() {\n+\t\t\treturn emitted >= limit || end;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic RowData readRecord(RowData reuse, byte[] bytes, int offset, int numBytes) throws IOException {\n+\t\t\tGenericRowData returnRecord = rowData;\n+\n+\t\t\tif (this.getDelimiter() != null && this.getDelimiter().length == 1\n+\t\t\t\t&& this.getDelimiter()[0] == NEW_LINE && offset + numBytes >= 1\n+\t\t\t\t&& bytes[offset + numBytes - 1] == CARRIAGE_RETURN){\n+\t\t\t\tnumBytes -= 1;\n+\t\t\t}\n+\t\t\tbyte[] trimBytes = Arrays.copyOfRange(bytes, offset, offset + numBytes);\n+\t\t\tGenericRowData jsonRow = (GenericRowData) deserializationSchema.deserialize(trimBytes);\n+\t\t\tif (jsonRow != null) {", "originalCommit": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0NzgwNw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422447807", "bodyText": "return a record that filled with only partition key field, other fields are null", "author": "leonardBang", "createdAt": "2020-05-09T03:31:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0ODAyMQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422448021", "bodyText": "I don't think this is a correct behavior, you can take a look to kafka.", "author": "JingsongLi", "createdAt": "2020-05-09T03:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MDk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MTMzMw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422441333", "bodyText": "Please think about how to reuse codes to csv.", "author": "JingsongLi", "createdAt": "2020-05-09T02:10:35Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.api.TableSchema;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.LogicalType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\t// deal partition fields\n+\t\tTableSchema tableSchema = context.getSchema();\n+\t\tList<DataType> fieldTypes = Arrays.asList(tableSchema.getFieldDataTypes());\n+\t\tList<String> fieldNames = Arrays.asList(tableSchema.getFieldNames());\n+\t\tString[] nonPartFieldNames = fieldNames.stream()\n+\t\t\t.filter(name -> !context.getPartitionKeys().contains(name)).toArray(String[]::new);\n+\t\tDataType[] nonPartFieldTypes = Arrays.asList(nonPartFieldNames).stream()\n+\t\t\t.map(name -> fieldTypes.get(fieldNames.indexOf(name))).toArray(DataType[]::new);\n+\t\tRowType nonPartRowType = RowType.of(\n+\t\t\tArrays.asList(nonPartFieldTypes).stream()\n+\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\tnonPartFieldNames);\n+\n+\t\t// deal project fields\n+\t\tint[] selectFields = context.getProjectFields();\n+\t\tList<String> partitionKeys = context.getPartitionKeys();\n+\t\tList<String> selectFieldNames = Arrays.stream(selectFields)\n+\t\t\t.mapToObj(fieldNames::get)\n+\t\t\t.collect(Collectors.toList());\n+\t\tList<String> jsonSelectFieldNames = selectFieldNames.stream()", "originalCommit": "e13ca920f02c00cfc883bc55499d7c179b7a8564", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0NzgyNg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422447826", "bodyText": "nice tips", "author": "leonardBang", "createdAt": "2020-05-09T03:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ0MTMzMw=="}], "type": "inlineReview"}, {"oid": "0a0e23de47a9e838c81a4bf1244e50c98e689508", "url": "https://github.com/apache/flink/commit/0a0e23de47a9e838c81a4bf1244e50c98e689508", "message": "fix comments", "committedDate": "2020-05-09T07:43:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NTg5MA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422465890", "bodyText": "Should not return null only, if just return null, this source will been closed.\nYou should override nextRecord.", "author": "JingsongLi", "createdAt": "2020-05-09T07:51:13Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\tRowType nonPartRowType = context.getRowTypeWithoutPartKeys();\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\tint[] jsonSelectFieldToProjectFieldMapping = context.getNonPartFieldProjectMapping();\n+\t\tint[] jsonSelectFieldToJsonFieldMapping = context.getSelectFieldToNonPartFieldMapping();\n+\n+\t\treturn new JsonInputFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tcontext.getSchema().getFieldDataTypes(),\n+\t\t\tcontext.getSchema().getFieldNames(),\n+\t\t\tcontext.getProjectFields(),\n+\t\t\tcontext.getPartitionKeys(),\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldToProjectFieldMapping,\n+\t\t\tjsonSelectFieldToJsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(context.getNonPartRowType())));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonInputFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonInputFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\tprivate final DataType[] fieldTypes;\n+\t\tprivate final String[] fieldNames;\n+\t\tprivate final int[] selectFields;\n+\t\tprivate final List<String> partitionKeys;\n+\t\tprivate final String defaultPartValue;\n+\t\tprivate final long limit;\n+\t\tprivate final int[] jsonSelectFieldToProjectFieldMapping;\n+\t\tprivate final int[] jsonSelectFieldToJsonFieldMapping;\n+\t\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\t\tprivate transient boolean end;\n+\t\tprivate transient long emitted;\n+\t\t// reuse object for per record\n+\t\tprivate transient GenericRowData rowData;\n+\n+\t\tpublic JsonInputFormat(\n+\t\t\t\tPath[] filePaths,\n+\t\t\t\tDataType[] fieldTypes,\n+\t\t\t\tString[] fieldNames,\n+\t\t\t\tint[] selectFields,\n+\t\t\t\tList<String> partitionKeys,\n+\t\t\t\tString defaultPartValue,\n+\t\t\t\tlong limit,\n+\t\t\t\tint[] jsonSelectFieldToProjectFieldMapping,\n+\t\t\t\tint[] jsonSelectFieldToJsonFieldMapping,\n+\t\t\t\tJsonRowDataDeserializationSchema deserializationSchema) {\n+\t\t\tsuper.setFilePaths(filePaths);\n+\t\t\tthis.fieldTypes = fieldTypes;\n+\t\t\tthis.fieldNames = fieldNames;\n+\t\t\tthis.selectFields = selectFields;\n+\t\t\tthis.partitionKeys = partitionKeys;\n+\t\t\tthis.defaultPartValue = defaultPartValue;\n+\t\t\tthis.limit = limit;\n+\t\t\tthis.jsonSelectFieldToProjectFieldMapping = jsonSelectFieldToProjectFieldMapping;\n+\t\t\tthis.jsonSelectFieldToJsonFieldMapping = jsonSelectFieldToJsonFieldMapping;\n+\t\t\tthis.deserializationSchema = deserializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsMultiPaths() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open(FileInputSplit split) throws IOException {\n+\t\t\tsuper.open(split);\n+\t\t\tthis.end = false;\n+\t\t\tthis.emitted = 0L;\n+\t\t\tthis.rowData = PartitionPathUtils.fillPartitionValueForRecord(fieldNames, fieldTypes, selectFields,\n+\t\t\t\tpartitionKeys, currentSplit.getPath(), defaultPartValue);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean reachedEnd() {\n+\t\t\treturn emitted >= limit || end;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic RowData readRecord(RowData reuse, byte[] bytes, int offset, int numBytes) throws IOException {\n+\t\t\tGenericRowData returnRecord = rowData;\n+\t\t\t// remove \\r from a line when the line ends with \\r\\n\n+\t\t\tif (this.getDelimiter() != null && this.getDelimiter().length == 1\n+\t\t\t\t&& this.getDelimiter()[0] == NEW_LINE && offset + numBytes >= 1\n+\t\t\t\t&& bytes[offset + numBytes - 1] == CARRIAGE_RETURN){\n+\t\t\t\tnumBytes -= 1;\n+\t\t\t}\n+\t\t\tbyte[] trimBytes = Arrays.copyOfRange(bytes, offset, offset + numBytes);\n+\t\t\tGenericRowData jsonRow = (GenericRowData) deserializationSchema.deserialize(trimBytes);\n+\n+\t\t\tif (jsonRow == null) {\n+\t\t\t\t// if the record is null, simply just skip\n+\t\t\t\treturn null;", "originalCommit": "0a0e23de47a9e838c81a4bf1244e50c98e689508", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2Njg5Mg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422466892", "bodyText": "So, we need import a loop to read util meet not null value as per loop?", "author": "leonardBang", "createdAt": "2020-05-09T08:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NTg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NzEwNg==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422467106", "bodyText": "Yes, I think so.", "author": "JingsongLi", "createdAt": "2020-05-09T08:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NTg5MA=="}], "type": "inlineReview"}, {"oid": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "url": "https://github.com/apache/flink/commit/c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "message": "minor comments", "committedDate": "2020-05-09T08:39:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4OTczNw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422489737", "bodyText": "getFormatFieldNames", "author": "JingsongLi", "createdAt": "2020-05-09T12:27:14Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FileSystemFormatFactory.java", "diffHunk": "@@ -102,6 +105,66 @@\n \t\t * The follow up operator will filter the records again.\n \t\t */\n \t\tList<Expression> getPushedDownFilters();\n+\n+\t\t/**\n+\t\t * Get field names without partition keys.\n+\t\t */\n+\t\tdefault String[] getFieldNamesWithoutPartKeys() {", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4OTc0OA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422489748", "bodyText": "getFormatFieldTypes", "author": "JingsongLi", "createdAt": "2020-05-09T12:27:23Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FileSystemFormatFactory.java", "diffHunk": "@@ -102,6 +105,66 @@\n \t\t * The follow up operator will filter the records again.\n \t\t */\n \t\tList<Expression> getPushedDownFilters();\n+\n+\t\t/**\n+\t\t * Get field names without partition keys.\n+\t\t */\n+\t\tdefault String[] getFieldNamesWithoutPartKeys() {\n+\t\t\treturn Arrays.stream(getSchema().getFieldNames())\n+\t\t\t\t.filter(name -> !getPartitionKeys().contains(name))\n+\t\t\t\t.toArray(String[]::new);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Get field types without partition keys.\n+\t\t */\n+\t\tdefault DataType[] getFieldTypesWithoutPartKeys() {", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4OTc3NA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422489774", "bodyText": "getFormatRowType", "author": "JingsongLi", "createdAt": "2020-05-09T12:27:34Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FileSystemFormatFactory.java", "diffHunk": "@@ -102,6 +105,66 @@\n \t\t * The follow up operator will filter the records again.\n \t\t */\n \t\tList<Expression> getPushedDownFilters();\n+\n+\t\t/**\n+\t\t * Get field names without partition keys.\n+\t\t */\n+\t\tdefault String[] getFieldNamesWithoutPartKeys() {\n+\t\t\treturn Arrays.stream(getSchema().getFieldNames())\n+\t\t\t\t.filter(name -> !getPartitionKeys().contains(name))\n+\t\t\t\t.toArray(String[]::new);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Get field types without partition keys.\n+\t\t */\n+\t\tdefault DataType[] getFieldTypesWithoutPartKeys() {\n+\t\t\treturn Arrays.stream(getSchema().getFieldNames())\n+\t\t\t\t.filter(name -> !getPartitionKeys().contains(name))\n+\t\t\t\t.map(name -> getSchema().getFieldDataType(name).get())\n+\t\t\t\t.toArray(DataType[]::new);\n+\t\t}\n+\n+\t\t/**\n+\t\t * RowType of table that excludes partition key fields.\n+\t\t */\n+\t\tdefault RowType getNonPartRowType() {", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4OTgwOA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422489808", "bodyText": "These two methods should only one, otherwise it is very hard to understand.\nLeft only one: getFormatProjectFields", "author": "JingsongLi", "createdAt": "2020-05-09T12:27:50Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FileSystemFormatFactory.java", "diffHunk": "@@ -102,6 +105,66 @@\n \t\t * The follow up operator will filter the records again.\n \t\t */\n \t\tList<Expression> getPushedDownFilters();\n+\n+\t\t/**\n+\t\t * Get field names without partition keys.\n+\t\t */\n+\t\tdefault String[] getFieldNamesWithoutPartKeys() {\n+\t\t\treturn Arrays.stream(getSchema().getFieldNames())\n+\t\t\t\t.filter(name -> !getPartitionKeys().contains(name))\n+\t\t\t\t.toArray(String[]::new);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Get field types without partition keys.\n+\t\t */\n+\t\tdefault DataType[] getFieldTypesWithoutPartKeys() {\n+\t\t\treturn Arrays.stream(getSchema().getFieldNames())\n+\t\t\t\t.filter(name -> !getPartitionKeys().contains(name))\n+\t\t\t\t.map(name -> getSchema().getFieldDataType(name).get())\n+\t\t\t\t.toArray(DataType[]::new);\n+\t\t}\n+\n+\t\t/**\n+\t\t * RowType of table that excludes partition key fields.\n+\t\t */\n+\t\tdefault RowType getNonPartRowType() {\n+\t\t\treturn RowType.of(\n+\t\t\t\tArrays.stream(getFieldTypesWithoutPartKeys())\n+\t\t\t\t\t.map(DataType::getLogicalType)\n+\t\t\t\t\t.toArray(LogicalType[]::new),\n+\t\t\t\tgetFieldNamesWithoutPartKeys());\n+\t\t}\n+\n+\t\t/**\n+\t\t * Mapping from non-partition project fields index to all project fields index.\n+\t\t */\n+\t\tdefault int[] getNonPartFieldProjectMapping() {", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MDA3NQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422490075", "bodyText": "getFormatRowType\nAnd please modify getFieldNamesWithoutPartKeys  and getFieldTypesWithoutPartKeys", "author": "JingsongLi", "createdAt": "2020-05-09T12:30:26Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FileSystemFormatFactory.java", "diffHunk": "@@ -142,5 +205,17 @@\n \t\t\t\t\t.map(name -> getSchema().getFieldDataType(name).get())\n \t\t\t\t\t.toArray(DataType[]::new);\n \t\t}\n+\n+\t\t/**\n+\t\t * Get RowType of the table without partition keys.\n+\t\t * @return\n+\t\t */\n+\t\tdefault RowType getNonPartRowType() {", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MDE0Ng==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422490146", "bodyText": "LocalDate.parse?", "author": "JingsongLi", "createdAt": "2020-05-09T12:31:00Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/utils/PartitionPathUtils.java", "diffHunk": "@@ -201,6 +211,81 @@ public static String unescapePathName(String path) {\n \t\treturn ret;\n \t}\n \n+\t/**\n+\t * Extract partition value from path and fill to record.\n+\t * @param fieldNames record field names.\n+\t * @param fieldTypes record field types.\n+\t * @param selectFields the selected fields.\n+\t * @param partitionKeys the partition field names.\n+\t * @param path the file path that the partition located.\n+\t * @param defaultPartValue default value of partition field.\n+\t * @return the filled record.\n+\t */\n+\tpublic static GenericRowData fillPartitionValueForRecord(\n+\t\t\tString[] fieldNames,\n+\t\t\tDataType[] fieldTypes,\n+\t\t\tint[] selectFields,\n+\t\t\tList<String> partitionKeys,\n+\t\t\tPath path,\n+\t\t\tString defaultPartValue) {\n+\t\tGenericRowData record = new GenericRowData(selectFields.length);\n+\t\tLinkedHashMap<String, String> partSpec = PartitionPathUtils.extractPartitionSpecFromPath(path);\n+\t\tfor (int i = 0; i < selectFields.length; i++) {\n+\t\t\tint selectField = selectFields[i];\n+\t\t\tString name = fieldNames[selectField];\n+\t\t\tif (partitionKeys.contains(name)) {\n+\t\t\t\tString value = partSpec.get(name);\n+\t\t\t\tvalue = defaultPartValue.equals(value) ? null : value;\n+\t\t\t\trecord.setField(i, PartitionPathUtils.convertStringToInternalValue(value, fieldTypes[selectField]));\n+\t\t\t}\n+\t\t}\n+\t\treturn record;\n+\t}\n+\n+\t/**\n+\t * Restore partition value from string and type.\n+\t *\n+\t * @param valStr string partition value.\n+\t * @param type type of partition field.\n+\t * @return partition value.\n+\t */\n+\tpublic static Object convertStringToInternalValue(String valStr, DataType type) {\n+\t\tif (valStr == null) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tLogicalTypeRoot typeRoot = type.getLogicalType().getTypeRoot();\n+\t\tswitch (typeRoot) {\n+\t\t\tcase CHAR:\n+\t\t\tcase VARCHAR:\n+\t\t\t\treturn StringData.fromString(valStr);\n+\t\t\tcase BOOLEAN:\n+\t\t\t\treturn Boolean.parseBoolean(valStr);\n+\t\t\tcase TINYINT:\n+\t\t\t\treturn Byte.parseByte(valStr);\n+\t\t\tcase SMALLINT:\n+\t\t\t\treturn Short.parseShort(valStr);\n+\t\t\tcase INTEGER:\n+\t\t\t\treturn Integer.parseInt(valStr);\n+\t\t\tcase BIGINT:\n+\t\t\t\treturn Long.parseLong(valStr);\n+\t\t\tcase FLOAT:\n+\t\t\t\treturn Float.parseFloat(valStr);\n+\t\t\tcase DOUBLE:\n+\t\t\t\treturn Double.parseDouble(valStr);\n+\t\t\tcase DATE:\n+\t\t\t\tLocalDate date = ISO_LOCAL_DATE.parse(valStr).query(TemporalQueries.localDate());", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MDIyOA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422490228", "bodyText": "I don't get this.\nPlease add cases.", "author": "JingsongLi", "createdAt": "2020-05-09T12:31:47Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\tRowType nonPartRowType = context.getNonPartRowType();\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\tint[] jsonSelectFieldToProjectFieldMapping = context.getNonPartFieldProjectMapping();\n+\t\tint[] jsonSelectFieldToJsonFieldMapping = context.getSelectFieldToNonPartFieldMapping();\n+\n+\t\treturn new JsonInputFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tcontext.getSchema().getFieldDataTypes(),\n+\t\t\tcontext.getSchema().getFieldNames(),\n+\t\t\tcontext.getProjectFields(),\n+\t\t\tcontext.getPartitionKeys(),\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldToProjectFieldMapping,\n+\t\t\tjsonSelectFieldToJsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(context.getNonPartRowType())));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonInputFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonInputFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\tprivate final DataType[] fieldTypes;\n+\t\tprivate final String[] fieldNames;\n+\t\tprivate final int[] selectFields;\n+\t\tprivate final List<String> partitionKeys;\n+\t\tprivate final String defaultPartValue;\n+\t\tprivate final long limit;\n+\t\tprivate final int[] jsonSelectFieldToProjectFieldMapping;\n+\t\tprivate final int[] jsonSelectFieldToJsonFieldMapping;\n+\t\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\t\tprivate transient boolean end;\n+\t\tprivate transient long emitted;\n+\t\t// reuse object for per record\n+\t\tprivate transient GenericRowData rowData;\n+\n+\t\tpublic JsonInputFormat(\n+\t\t\t\tPath[] filePaths,\n+\t\t\t\tDataType[] fieldTypes,\n+\t\t\t\tString[] fieldNames,\n+\t\t\t\tint[] selectFields,\n+\t\t\t\tList<String> partitionKeys,\n+\t\t\t\tString defaultPartValue,\n+\t\t\t\tlong limit,\n+\t\t\t\tint[] jsonSelectFieldToProjectFieldMapping,\n+\t\t\t\tint[] jsonSelectFieldToJsonFieldMapping,\n+\t\t\t\tJsonRowDataDeserializationSchema deserializationSchema) {\n+\t\t\tsuper.setFilePaths(filePaths);\n+\t\t\tthis.fieldTypes = fieldTypes;\n+\t\t\tthis.fieldNames = fieldNames;\n+\t\t\tthis.selectFields = selectFields;\n+\t\t\tthis.partitionKeys = partitionKeys;\n+\t\t\tthis.defaultPartValue = defaultPartValue;\n+\t\t\tthis.limit = limit;\n+\t\t\tthis.jsonSelectFieldToProjectFieldMapping = jsonSelectFieldToProjectFieldMapping;\n+\t\t\tthis.jsonSelectFieldToJsonFieldMapping = jsonSelectFieldToJsonFieldMapping;\n+\t\t\tthis.deserializationSchema = deserializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsMultiPaths() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open(FileInputSplit split) throws IOException {\n+\t\t\tsuper.open(split);\n+\t\t\tthis.end = false;\n+\t\t\tthis.emitted = 0L;\n+\t\t\tthis.rowData = PartitionPathUtils.fillPartitionValueForRecord(fieldNames, fieldTypes, selectFields,\n+\t\t\t\tpartitionKeys, currentSplit.getPath(), defaultPartValue);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean reachedEnd() {\n+\t\t\treturn emitted >= limit || end;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic RowData readRecord(RowData reuse, byte[] bytes, int offset, int numBytes) throws IOException {\n+\t\t\tGenericRowData returnRecord = null;\n+\t\t\tdo {\n+\t\t\t\t// remove \\r from a line when the line ends with \\r\\n\n+\t\t\t\tif (this.getDelimiter() != null && this.getDelimiter().length == 1\n+\t\t\t\t\t&& this.getDelimiter()[0] == NEW_LINE && offset + numBytes >= 1\n+\t\t\t\t\t&& bytes[offset + numBytes - 1] == CARRIAGE_RETURN){\n+\t\t\t\t\tnumBytes -= 1;\n+\t\t\t\t}\n+\t\t\t\tbyte[] trimBytes = Arrays.copyOfRange(bytes, offset, offset + numBytes);\n+\t\t\t\tGenericRowData jsonRow = (GenericRowData) deserializationSchema.deserialize(trimBytes);\n+\n+\t\t\t\tif (jsonRow != null) {\n+\t\t\t\t\t// if the record is null, simply just skip\n+\t\t\t\t\treturnRecord = rowData;\n+\t\t\t\t\tfor (int i = 0; i < jsonSelectFieldToJsonFieldMapping.length; i++) {\n+\t\t\t\t\t\treturnRecord.setField(jsonSelectFieldToProjectFieldMapping[i],\n+\t\t\t\t\t\t\tjsonRow.getField(jsonSelectFieldToJsonFieldMapping[i]));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} while (returnRecord == null && !reachedEnd());", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MDU1OA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422490558", "bodyText": "RowData readRecord() {\n...\n  if (jsonRow == null) {\n    return null;\n  }\n...\n}\n\nRowData nextRecord() {\n   while (true) {\n      if (readLine()) {\n\t\t\tRowData row = readRecord(record, this.currBuffer, this.currOffset, this.currLen);\n             if (row == null) {\n                 continue;\n             } else {\n                return row; \n            }\n\t\t} else {\n\t\t\tthis.end = true;\n\t\t\treturn null;\n\t\t}\n  }\n}", "author": "JingsongLi", "createdAt": "2020-05-09T12:34:51Z", "path": "flink-formats/flink-json/src/main/java/org/apache/flink/formats/json/JsonFileSystemFormatFactory.java", "diffHunk": "@@ -0,0 +1,242 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.api.common.io.DelimitedInputFormat;\n+import org.apache.flink.api.common.io.InputFormat;\n+import org.apache.flink.api.common.serialization.BulkWriter;\n+import org.apache.flink.api.common.serialization.Encoder;\n+import org.apache.flink.api.java.typeutils.GenericTypeInfo;\n+import org.apache.flink.core.fs.FileInputSplit;\n+import org.apache.flink.core.fs.Path;\n+import org.apache.flink.table.data.GenericRowData;\n+import org.apache.flink.table.data.RowData;\n+import org.apache.flink.table.descriptors.DescriptorProperties;\n+import org.apache.flink.table.factories.FileSystemFormatFactory;\n+import org.apache.flink.table.types.DataType;\n+import org.apache.flink.table.types.logical.RowType;\n+import org.apache.flink.table.utils.PartitionPathUtils;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static org.apache.flink.table.descriptors.FormatDescriptorValidator.FORMAT;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_FAIL_ON_MISSING_FIELD;\n+import static org.apache.flink.table.descriptors.JsonValidator.FORMAT_IGNORE_PARSE_ERRORS;\n+\n+/**\n+ * Factory to build reader/writer to read/write json format file.\n+ */\n+public class JsonFileSystemFormatFactory implements FileSystemFormatFactory {\n+\n+\t@Override\n+\tpublic Map<String, String> requiredContext() {\n+\t\tMap<String, String> context = new HashMap<>();\n+\t\tcontext.put(FORMAT, \"json\");\n+\t\treturn context;\n+\t}\n+\n+\t@Override\n+\tpublic List<String> supportedProperties() {\n+\t\tArrayList<String> properties = new ArrayList<>();\n+\t\tproperties.add(FORMAT_FAIL_ON_MISSING_FIELD);\n+\t\tproperties.add(FORMAT_IGNORE_PARSE_ERRORS);\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic InputFormat<RowData, ?> createReader(ReaderContext context) {\n+\t\tDescriptorProperties properties = getValidatedProperties(context.getFormatProperties());\n+\t\tboolean failOnMissingField = properties.getOptionalBoolean(FORMAT_FAIL_ON_MISSING_FIELD).orElse(false);\n+\t\tboolean ignoreParseErrors = properties.getOptionalBoolean(FORMAT_IGNORE_PARSE_ERRORS).orElse(false);\n+\n+\t\tRowType nonPartRowType = context.getNonPartRowType();\n+\t\tJsonRowDataDeserializationSchema  deserializationSchema = new JsonRowDataDeserializationSchema(\n+\t\t\tnonPartRowType,\n+\t\t\tnew GenericTypeInfo(GenericRowData.class),\n+\t\t\tfailOnMissingField,\n+\t\t\tignoreParseErrors);\n+\n+\t\tint[] jsonSelectFieldToProjectFieldMapping = context.getNonPartFieldProjectMapping();\n+\t\tint[] jsonSelectFieldToJsonFieldMapping = context.getSelectFieldToNonPartFieldMapping();\n+\n+\t\treturn new JsonInputFormat(\n+\t\t\tcontext.getPaths(),\n+\t\t\tcontext.getSchema().getFieldDataTypes(),\n+\t\t\tcontext.getSchema().getFieldNames(),\n+\t\t\tcontext.getProjectFields(),\n+\t\t\tcontext.getPartitionKeys(),\n+\t\t\tcontext.getDefaultPartName(),\n+\t\t\tcontext.getPushedDownLimit(),\n+\t\t\tjsonSelectFieldToProjectFieldMapping,\n+\t\t\tjsonSelectFieldToJsonFieldMapping,\n+\t\t\tdeserializationSchema);\n+\t}\n+\n+\t@Override\n+\tpublic Optional<Encoder<RowData>> createEncoder(WriterContext context) {\n+\t\treturn Optional.of(new JsonRowDataEncoder(new JsonRowDataSerializationSchema(context.getNonPartRowType())));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<BulkWriter.Factory<RowData>> createBulkWriterFactory(WriterContext context) {\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic boolean supportsSchemaDerivation() {\n+\t\treturn true;\n+\t}\n+\n+\tprivate static DescriptorProperties getValidatedProperties(Map<String, String> propertiesMap) {\n+\t\tfinal DescriptorProperties properties = new DescriptorProperties(true);\n+\t\tproperties.putProperties(propertiesMap);\n+\t\tproperties.validateBoolean(FORMAT_FAIL_ON_MISSING_FIELD, true);\n+\t\tproperties.validateBoolean(FORMAT_IGNORE_PARSE_ERRORS, true);\n+\t\treturn properties;\n+\t}\n+\n+\t/**\n+\t * A {@link JsonInputFormat} is responsible to read {@link RowData} records\n+\t * from json format files.\n+\t */\n+\tpublic static class JsonInputFormat extends DelimitedInputFormat<RowData> {\n+\t\t/**\n+\t\t * Code of \\r, used to remove \\r from a line when the line ends with \\r\\n.\n+\t\t */\n+\t\tprivate static final byte CARRIAGE_RETURN = (byte) '\\r';\n+\n+\t\t/**\n+\t\t * Code of \\n, used to identify if \\n is used as delimiter.\n+\t\t */\n+\t\tprivate static final byte NEW_LINE = (byte) '\\n';\n+\n+\t\tprivate final DataType[] fieldTypes;\n+\t\tprivate final String[] fieldNames;\n+\t\tprivate final int[] selectFields;\n+\t\tprivate final List<String> partitionKeys;\n+\t\tprivate final String defaultPartValue;\n+\t\tprivate final long limit;\n+\t\tprivate final int[] jsonSelectFieldToProjectFieldMapping;\n+\t\tprivate final int[] jsonSelectFieldToJsonFieldMapping;\n+\t\tprivate final JsonRowDataDeserializationSchema deserializationSchema;\n+\n+\t\tprivate transient boolean end;\n+\t\tprivate transient long emitted;\n+\t\t// reuse object for per record\n+\t\tprivate transient GenericRowData rowData;\n+\n+\t\tpublic JsonInputFormat(\n+\t\t\t\tPath[] filePaths,\n+\t\t\t\tDataType[] fieldTypes,\n+\t\t\t\tString[] fieldNames,\n+\t\t\t\tint[] selectFields,\n+\t\t\t\tList<String> partitionKeys,\n+\t\t\t\tString defaultPartValue,\n+\t\t\t\tlong limit,\n+\t\t\t\tint[] jsonSelectFieldToProjectFieldMapping,\n+\t\t\t\tint[] jsonSelectFieldToJsonFieldMapping,\n+\t\t\t\tJsonRowDataDeserializationSchema deserializationSchema) {\n+\t\t\tsuper.setFilePaths(filePaths);\n+\t\t\tthis.fieldTypes = fieldTypes;\n+\t\t\tthis.fieldNames = fieldNames;\n+\t\t\tthis.selectFields = selectFields;\n+\t\t\tthis.partitionKeys = partitionKeys;\n+\t\t\tthis.defaultPartValue = defaultPartValue;\n+\t\t\tthis.limit = limit;\n+\t\t\tthis.jsonSelectFieldToProjectFieldMapping = jsonSelectFieldToProjectFieldMapping;\n+\t\t\tthis.jsonSelectFieldToJsonFieldMapping = jsonSelectFieldToJsonFieldMapping;\n+\t\t\tthis.deserializationSchema = deserializationSchema;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean supportsMultiPaths() {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void open(FileInputSplit split) throws IOException {\n+\t\t\tsuper.open(split);\n+\t\t\tthis.end = false;\n+\t\t\tthis.emitted = 0L;\n+\t\t\tthis.rowData = PartitionPathUtils.fillPartitionValueForRecord(fieldNames, fieldTypes, selectFields,\n+\t\t\t\tpartitionKeys, currentSplit.getPath(), defaultPartValue);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean reachedEnd() {\n+\t\t\treturn emitted >= limit || end;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic RowData readRecord(RowData reuse, byte[] bytes, int offset, int numBytes) throws IOException {\n+\t\t\tGenericRowData returnRecord = null;\n+\t\t\tdo {\n+\t\t\t\t// remove \\r from a line when the line ends with \\r\\n\n+\t\t\t\tif (this.getDelimiter() != null && this.getDelimiter().length == 1\n+\t\t\t\t\t&& this.getDelimiter()[0] == NEW_LINE && offset + numBytes >= 1\n+\t\t\t\t\t&& bytes[offset + numBytes - 1] == CARRIAGE_RETURN){\n+\t\t\t\t\tnumBytes -= 1;\n+\t\t\t\t}\n+\t\t\t\tbyte[] trimBytes = Arrays.copyOfRange(bytes, offset, offset + numBytes);\n+\t\t\t\tGenericRowData jsonRow = (GenericRowData) deserializationSchema.deserialize(trimBytes);\n+\n+\t\t\t\tif (jsonRow != null) {\n+\t\t\t\t\t// if the record is null, simply just skip\n+\t\t\t\t\treturnRecord = rowData;\n+\t\t\t\t\tfor (int i = 0; i < jsonSelectFieldToJsonFieldMapping.length; i++) {\n+\t\t\t\t\t\treturnRecord.setField(jsonSelectFieldToProjectFieldMapping[i],\n+\t\t\t\t\t\t\tjsonRow.getField(jsonSelectFieldToJsonFieldMapping[i]));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} while (returnRecord == null && !reachedEnd());", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxMjk0Mw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422512943", "bodyText": "so ,by this we can support ignore-parser-error and open by default?\nthat's a good tips", "author": "leonardBang", "createdAt": "2020-05-09T16:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5MDU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5NDQ2Nw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422494467", "bodyText": "The default value of fail-on-missing-field is false, should set it to true.", "author": "JingsongLi", "createdAt": "2020-05-09T13:13:21Z", "path": "flink-formats/flink-json/src/test/java/org/apache/flink/formats/json/JsonBatchFileSystemITCase.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.table.planner.runtime.batch.sql.BatchFileSystemITCaseBase;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * ITCase to test json format for {@link JsonFileSystemFormatFactory}.\n+ */\n+@RunWith(Parameterized.class)\n+public class JsonBatchFileSystemITCase extends BatchFileSystemITCaseBase {\n+\n+\tprivate final boolean configure;\n+\n+\t@Parameterized.Parameters(name = \"{0}\")\n+\tpublic static Collection<Boolean> parameters() {\n+\t\treturn Arrays.asList(false, true);\n+\t}\n+\n+\tpublic JsonBatchFileSystemITCase(boolean configure) {\n+\t\tthis.configure = configure;\n+\t}\n+\n+\t@Override\n+\tpublic String[] formatProperties() {\n+\t\tList<String> ret = new ArrayList<>();\n+\t\tret.add(\"'format'='json'\");\n+\t\tif (configure) {\n+\t\t\tret.add(\"'format.fail-on-missing-field'='true'\");\n+\t\t\tret.add(\"'format.ignore-parse-errors'='false'\");", "originalCommit": "c6f1ab4f02b683d44ac5c987430b9d9eab1e8cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "410e972bd87875f3ebc7eb8c3b1f39279397473a", "url": "https://github.com/apache/flink/commit/410e972bd87875f3ebc7eb8c3b1f39279397473a", "message": "address comments", "committedDate": "2020-05-09T16:38:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDA3Mw==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422740073", "bodyText": "getFormatFieldNames", "author": "JingsongLi", "createdAt": "2020-05-11T01:51:58Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FileSystemFormatFactory.java", "diffHunk": "@@ -127,7 +172,7 @@\n \t\t/**\n \t\t * Get field names without partition keys.\n \t\t */\n-\t\tdefault String[] getFieldNamesWithoutPartKeys() {\n+\t\tdefault String[] getFormatFieldTypes() {", "originalCommit": "410e972bd87875f3ebc7eb8c3b1f39279397473a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDA4OQ==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422740089", "bodyText": "getFormatFieldTypes", "author": "JingsongLi", "createdAt": "2020-05-11T01:52:04Z", "path": "flink-table/flink-table-common/src/main/java/org/apache/flink/table/factories/FileSystemFormatFactory.java", "diffHunk": "@@ -136,11 +181,23 @@\n \t\t/**\n \t\t * Get field types without partition keys.\n \t\t */\n-\t\tdefault DataType[] getFieldTypesWithoutPartKeys() {\n+\t\tdefault DataType[] getFormatFieldNames() {", "originalCommit": "410e972bd87875f3ebc7eb8c3b1f39279397473a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc0MDQwMA==", "url": "https://github.com/apache/flink/pull/12010#discussion_r422740400", "bodyText": "You could add a check(String sqlQuery, java.util.List<Row> expectedResult) to FileSystemITCaseBase.", "author": "JingsongLi", "createdAt": "2020-05-11T01:53:26Z", "path": "flink-formats/flink-json/src/test/java/org/apache/flink/formats/json/JsonBatchFileSystemITCase.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.formats.json;\n+\n+import org.apache.flink.table.planner.runtime.batch.sql.BatchFileSystemITCaseBase;\n+import org.apache.flink.types.Row;\n+import org.apache.flink.util.FileUtils;\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * ITCase to test json format for {@link JsonFileSystemFormatFactory}.\n+ */\n+public class JsonBatchFileSystemITCase extends BatchFileSystemITCaseBase {\n+\n+\t@Override\n+\tpublic String[] formatProperties() {\n+\t\tList<String> ret = new ArrayList<>();\n+\t\tret.add(\"'format'='json'\");\n+\t\tret.add(\"'format.ignore-parse-errors'='true'\");\n+\t\treturn ret.toArray(new String[0]);\n+\t}\n+\n+\t@Test\n+\tpublic void testParseError() throws Exception {\n+\t\tString path = new URI(resultPath()).getPath();\n+\t\tnew File(path).mkdirs();\n+\t\tFile file = new File(path, \"my_file\");\n+\t\tfile.createNewFile();\n+\t\tFileUtils.writeFileUtf8(file,\n+\t\t\t\"{\\\"x\\\":\\\"x5\\\",\\\"y\\\":5,\\\"a\\\":1,\\\"b\\\":1}\\n\" +\n+\t\t\t\t\"{I am a wrong json.}\\n\" +\n+\t\t\t\t\"{\\\"x\\\":\\\"x5\\\",\\\"y\\\":5,\\\"a\\\":1,\\\"b\\\":1}\");\n+\n+\t\tcheck(\"select * from nonPartitionedTable\",\n+\t\t\tJavaConverters.asScalaIteratorConverter(Arrays.asList(", "originalCommit": "410e972bd87875f3ebc7eb8c3b1f39279397473a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "edacdf8f0062fdae68a1581936a7410c1b35baa2", "url": "https://github.com/apache/flink/commit/edacdf8f0062fdae68a1581936a7410c1b35baa2", "message": "update", "committedDate": "2020-05-11T02:14:22Z", "type": "commit"}]}