{"pr_number": 13964, "pr_title": " [FLINK-19314][coordination] Add DeclarativeSlotPoolBridge ", "pr_createdAt": "2020-11-06T12:17:00Z", "pr_url": "https://github.com/apache/flink/pull/13964", "timeline": [{"oid": "b2fc4902b25f60f403bf5839ca717b465f09b67a", "url": "https://github.com/apache/flink/commit/b2fc4902b25f60f403bf5839ca717b465f09b67a", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management", "committedDate": "2020-12-02T21:59:57Z", "type": "forcePushed"}, {"oid": "aa2a35104a430e3dada923f364ceff82d4fcc87d", "url": "https://github.com/apache/flink/commit/aa2a35104a430e3dada923f364ceff82d4fcc87d", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management", "committedDate": "2020-12-03T09:44:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NDMxNw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539184317", "bodyText": "I think it returns Optional#empty if the given allocation id is not available.", "author": "tillrohrmann", "createdAt": "2020-12-09T10:23:02Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -157,6 +161,22 @@ void start(\n \t\t@Nonnull SlotRequestId slotRequestId,\n \t\t@Nonnull AllocationID allocationID);\n \n+\t/**\n+\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n+\t * {@code null} if no slot with the given allocation id is available.", "originalCommit": "8729bb29add5014ff34474fe14ab9a5c7d5717ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NDU0NA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539184544", "bodyText": "Returns Optional#empty instead of null.", "author": "tillrohrmann", "createdAt": "2020-12-09T10:23:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -157,6 +161,22 @@ void start(\n \t\t@Nonnull SlotRequestId slotRequestId,\n \t\t@Nonnull AllocationID allocationID);\n \n+\t/**\n+\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n+\t * {@code null} if no slot with the given allocation id is available.\n+\t *\n+\t * @param slotRequestId identifying the requested slot\n+\t * @param allocationID the allocation id of the requested available slot\n+\t * @param requiredSlotProfile requiredSlotProfile for which to allocate the slot\n+\t * @return the previously available slot with the given allocation id or {@code null} if no such slot existed.", "originalCommit": "8729bb29add5014ff34474fe14ab9a5c7d5717ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NDc0Ng==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539184746", "bodyText": "It would be good to state what it means if requiredSlotProfile is null. Also add for what this parameter is used.", "author": "tillrohrmann", "createdAt": "2020-12-09T10:23:35Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -157,6 +161,22 @@ void start(\n \t\t@Nonnull SlotRequestId slotRequestId,\n \t\t@Nonnull AllocationID allocationID);\n \n+\t/**\n+\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n+\t * {@code null} if no slot with the given allocation id is available.\n+\t *\n+\t * @param slotRequestId identifying the requested slot\n+\t * @param allocationID the allocation id of the requested available slot\n+\t * @param requiredSlotProfile requiredSlotProfile for which to allocate the slot", "originalCommit": "8729bb29add5014ff34474fe14ab9a5c7d5717ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0MzkzNA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539443934", "bodyText": "After looking at the current usages, it looks like we can remove  @Nullable and the allocateAvailableSlot() variant that does not pass a slot profile.\nThe profile is never null, and the method is never called.", "author": "zentol", "createdAt": "2020-12-09T16:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4NDc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MjQwMw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539192403", "bodyText": "nit: I would change the order of the parameters. First saying which requests get cancelled and then with what.", "author": "tillrohrmann", "createdAt": "2020-12-09T10:34:28Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {", "originalCommit": "3c7f5dec4c973aa6592444b8e00738c8975a1aae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5NjA2NA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539196064", "bodyText": "Just as a side note: I really would like to do FLINK-11719 at some point in time. This should allow us to get rid of this pattern here.", "author": "tillrohrmann", "createdAt": "2020-12-09T10:39:41Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}", "originalCommit": "3c7f5dec4c973aa6592444b8e00738c8975a1aae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQzNzU1NA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539437554", "bodyText": "definitely!", "author": "zentol", "createdAt": "2020-12-09T16:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5NjA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMDE5Mg==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539330192", "bodyText": "I don't fully understand newSlotsSet. If this set is supposed to filter out repeated newSlotsAreAvailable calls, how is this possible if the only thing we are doing between adding a slot to newSlotsAreAvailable and removing it from there is to add the slot to matchingsToFulfill? Can it be that this is no longer possible because the completion of pending requests has been moved into a separate loop?", "author": "tillrohrmann", "createdAt": "2020-12-09T14:01:54Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());", "originalCommit": "3c7f5dec4c973aa6592444b8e00738c8975a1aae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MTE3NA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539591174", "bodyText": "In the current state I also cannot see a point in the newSlotsSet. I suppose it only had any effect if the request completion triggers another free/reserve cycle, i.e., it triggers a recursion.\nWith the completion moved into a separate loop the reservation of slots is now locked in before any recursion can happen, which seems...good?\nWhat I'm unsure of are the implications. I think we're fine from a correctness point of view, but does this mean the scheduler now has less options when it comes to how shared slots are allocated?\nTBH I don't fully understand the issue you fixed in tillrohrmann@2c02f54. It reads to me like the scheduler is cycling through different allocation setups, but if it frees the slot in between how can a vertex be assigned twice? Was the slot pool leaking state across recursions, or is the scheduler doing the book-keeping incorrectly?\nUnfortunately I don't quite remember when and why I moved the completion out of the loop; but not having this recursion should at least make it easier to reason about...", "author": "zentol", "createdAt": "2020-12-09T19:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMDE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA2MDQ0NA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540060444", "bodyText": "I think this might have tried to solve a similar problem as tillrohrmann/flink@8c6f00e but I also cannot recall what the problematic scenario was. Looking at the code, I think we can remove it.", "author": "tillrohrmann", "createdAt": "2020-12-10T10:39:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMDE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMjYwNQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540222605", "bodyText": "I think I could reproduce the problem using the TimeStampITCase with the commit before tillrohrmann/flink@2c02f54. The problem was that we were reusing the same MultiTaskSlot for the same JobVertexID twice. I think the problem is the following: When scheduling a subtask a, we allocate a MultiTaskSlot in SchedulerImpl.allocateMultiTaskSlot by picking a MultiTaskSlot which does not contain yet the JobVertexID. Once we have it, we try to allocate an available slot to see whether it has a better locality. If this is not the case, then we release the slot. This will trigger the newSlotsAreAvailable method again. If now the last input for a subtask b of the same JobVertexID is pending, the released slot could be used to fulfill the request. This would then trigger the scheduling of b which could take the same MultiTaskSlot which a had picked but not yet reserved. The problem is that due to the direct executions of the future, we can have an interleaved execution where multiple calls to SchedulerImpl.allocateMultiTaskSlot can happen nestedly:\nstart allocateMultiTaskSlot(a)\nstart allocateMultiTaskSlot(b)\nstart allocateMultiTaskSlot(c)\nend allocateMultiTaskSlot(c)\nend allocateMultiTaskSlot(b)\nend allocateMultiTaskSlot(a)", "author": "tillrohrmann", "createdAt": "2020-12-10T14:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMDE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIzNDU5OQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540234599", "bodyText": "Long story short, this should no longer a problem with first assigning the slots to pending requests and then fulfilling them.", "author": "tillrohrmann", "createdAt": "2020-12-10T14:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMDE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTU3Mw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539331573", "bodyText": "I am wondering whether this logging statement shouldn't be part of the AllocatedSlotPool.", "author": "tillrohrmann", "createdAt": "2020-12-09T14:03:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());\n+\t\t}\n+\n+\t\t// we have to first reserve all matching slots before fulfilling the requests\n+\t\t// otherwise it can happen that the SchedulerImpl reserves one of the new slots\n+\t\t// for a request which has been triggered by fulfilling a pending request\n+\t\tfor (PendingRequestSlotMatching pendingRequestSlotMatching : matchingsToFulfill) {\n+\t\t\tpendingRequestSlotMatching.fulfillPendingRequest();\n+\t\t}\n+\t}\n+\n+\tprivate void reserveFreeSlot(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile resourceProfile) {\n+\t\tLOG.debug(\"Reserve slot {} for slot request id {}\", allocationId, slotRequestId);", "originalCommit": "3c7f5dec4c973aa6592444b8e00738c8975a1aae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NTk0NQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539465945", "bodyText": "How about we leave it as is for now, and in a follow-up do a sweep across the bridge/slotpool/allocatedslotpool to sort out logging responsibilities?\nIdeally the bridge logs as little as possible; everything that can be logged in the slot pool or below, should be logged there.", "author": "zentol", "createdAt": "2020-12-09T16:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAyNTY2OA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540025668", "bodyText": "Sounds good.", "author": "tillrohrmann", "createdAt": "2020-12-10T09:50:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMzMTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODI4MQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539348281", "bodyText": "I'd suggest to use FlinkMatchers.containsCause", "author": "tillrohrmann", "createdAt": "2020-12-09T14:24:40Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeTest extends TestLogger {\n+\n+\tprivate static final Time rpcTimeout = Time.seconds(20);\n+\tprivate static final JobID jobId = new JobID();\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\t@Test\n+\tpublic void testSlotOffer() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\t\tfinal AllocationID expectedAllocationId = new AllocationID();\n+\t\tfinal PhysicalSlot allocatedSlot = createAllocatedSlot(expectedAllocationId);\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, null);\n+\n+\t\t\tdeclarativeSlotPoolBridge.newSlotsAreAvailable(Collections.singleton(allocatedSlot));\n+\n+\t\t\tslotAllocationFuture.join();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNotEnoughResourcesAvailableFailsPendingRequests() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = CompletableFuture\n+\t\t\t\t\t.supplyAsync(() -> declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, Time.minutes(5)), mainThreadExecutor)\n+\t\t\t\t\t.get();\n+\n+\t\t\tmainThreadExecutor.execute(() -> declarativeSlotPoolBridge.notifyNotEnoughResourcesAvailable(Collections.emptyList()));\n+\n+\t\t\ttry {\n+\t\t\t\tslotAllocationFuture.join();\n+\t\t\t\tAssert.fail();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tOptional<NoResourceAvailableException> expectedException = ExceptionUtils.findThrowable(e, NoResourceAvailableException.class);\n+\t\t\t\tassertThat(expectedException.isPresent(), is(true));", "originalCommit": "3c7f5dec4c973aa6592444b8e00738c8975a1aae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODY4NQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539348685", "bodyText": "Or FlinkMatchers.futureWillCompleteExceptionally on slotAllocationFuture.", "author": "tillrohrmann", "createdAt": "2020-12-09T14:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2OTU1Nw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539469557", "bodyText": "containsCause is a bit annoying since it also does an exact match against the error message, which tends to just create maintenance overhead down the line.\nI will use futureWillCompleteExceptionally.", "author": "zentol", "createdAt": "2020-12-09T16:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM0ODI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM1MzAwOQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539353009", "bodyText": "I think FutureUtils.completeAll is what you want to use here.", "author": "tillrohrmann", "createdAt": "2020-12-09T14:30:28Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeTest extends TestLogger {\n+\n+\tprivate static final Time rpcTimeout = Time.seconds(20);\n+\tprivate static final JobID jobId = new JobID();\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\t@Test\n+\tpublic void testSlotOffer() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\t\tfinal AllocationID expectedAllocationId = new AllocationID();\n+\t\tfinal PhysicalSlot allocatedSlot = createAllocatedSlot(expectedAllocationId);\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, null);\n+\n+\t\t\tdeclarativeSlotPoolBridge.newSlotsAreAvailable(Collections.singleton(allocatedSlot));\n+\n+\t\t\tslotAllocationFuture.join();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNotEnoughResourcesAvailableFailsPendingRequests() throws Exception {\n+\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(TestingDeclarativeSlotPool.builder());\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tCompletableFuture<PhysicalSlot> slotAllocationFuture = CompletableFuture\n+\t\t\t\t\t.supplyAsync(() -> declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, Time.minutes(5)), mainThreadExecutor)\n+\t\t\t\t\t.get();\n+\n+\t\t\tmainThreadExecutor.execute(() -> declarativeSlotPoolBridge.notifyNotEnoughResourcesAvailable(Collections.emptyList()));\n+\n+\t\t\ttry {\n+\t\t\t\tslotAllocationFuture.join();\n+\t\t\t\tAssert.fail();\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tOptional<NoResourceAvailableException> expectedException = ExceptionUtils.findThrowable(e, NoResourceAvailableException.class);\n+\t\t\t\tassertThat(expectedException.isPresent(), is(true));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testReleasingAllocatedSlot() throws Exception {\n+\t\tfinal CompletableFuture<AllocationID> releaseSlotFuture = new CompletableFuture<>();\n+\t\tfinal AllocationID expectedAllocationId = new AllocationID();\n+\t\tfinal PhysicalSlot allocatedSlot = createAllocatedSlot(expectedAllocationId);\n+\n+\t\tfinal TestingDeclarativeSlotPoolBuilder builder = TestingDeclarativeSlotPool\n+\t\t\t\t.builder()\n+\t\t\t\t.setReserveFreeSlotFunction((allocationId, resourceProfile) -> {\n+\t\t\t\t\tassertThat(allocationId, is(expectedAllocationId));\n+\t\t\t\t\treturn allocatedSlot;\n+\t\t\t\t})\n+\t\t\t\t.setFreeReservedSlotFunction((allocationID, throwable, aLong) -> {\n+\t\t\t\t\treleaseSlotFuture.complete(allocationID);\n+\t\t\t\t\treturn ResourceCounter.empty();\n+\t\t\t\t});\n+\n+\t\tfinal TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new TestingDeclarativeSlotPoolFactory(builder);\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory)) {\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n+\n+\t\t\tdeclarativeSlotPoolBridge.allocateAvailableSlot(slotRequestId, expectedAllocationId, allocatedSlot.getResourceProfile());\n+\t\t\tdeclarativeSlotPoolBridge.releaseSlot(slotRequestId, null);\n+\n+\t\t\tassertThat(releaseSlotFuture.join(), is(expectedAllocationId));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testNoConcurrentModificationWhenSuspendingAndReleasingSlot() throws Exception {\n+\t\ttry (DeclarativeSlotPoolBridge declarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(new DefaultDeclarativeSlotPoolFactory())) {\n+\n+\t\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t\tfinal List<SlotRequestId> slotRequestIds = Arrays.asList(new SlotRequestId(), new SlotRequestId());\n+\n+\t\t\tfinal List<CompletableFuture<PhysicalSlot>> slotFutures = slotRequestIds.stream()\n+\t\t\t\t\t.map(slotRequestId -> {\n+\t\t\t\t\t\tfinal CompletableFuture<PhysicalSlot> slotFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(slotRequestId, ResourceProfile.UNKNOWN, rpcTimeout);\n+\t\t\t\t\t\tslotFuture.whenComplete((physicalSlot, throwable) -> {\n+\t\t\t\t\t\t\tif (throwable != null) {\n+\t\t\t\t\t\t\t\tdeclarativeSlotPoolBridge.releaseSlot(slotRequestId, throwable);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t\treturn slotFuture;\n+\t\t\t\t\t})\n+\t\t\t\t\t.collect(Collectors.toList());\n+\n+\t\t\tdeclarativeSlotPoolBridge.suspend();\n+\n+\t\t\ttry {\n+\t\t\t\tFutureUtils.waitForAll(slotFutures).get();", "originalCommit": "3c7f5dec4c973aa6592444b8e00738c8975a1aae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3OTA5Ng==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539479096", "bodyText": "hmm...seems like waitForAll is quite a trap? Wouldn't we always want to use completeAll during tests to gather as much information as possible? Unless there is a case where a failure in one future can imply that other futures will never complete, but that already feels wrong.", "author": "zentol", "createdAt": "2020-12-09T16:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM1MzAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUyNjQwMw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539526403", "bodyText": "Actually, completeAll cannot be used here because we'd have to wait for the timeout of other slots.", "author": "zentol", "createdAt": "2020-12-09T18:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM1MzAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAyNjE0OA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540026148", "bodyText": "Shouldn't they all be failed eventually when calling declarativeSlotPoolBridge.suspend?", "author": "tillrohrmann", "createdAt": "2020-12-10T09:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM1MzAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MDgwNw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539380807", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n          \n          \n            \n            \t\t\t\tpendingRequests.put(pendingRequest.getSlotRequestId(), pendingRequest);", "author": "tillrohrmann", "createdAt": "2020-12-09T15:02:59Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);", "originalCommit": "aa2a35104a430e3dada923f364ceff82d4fcc87d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4OTQ1MQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539389451", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\trequest -> !isBatchSlotRequestTimeoutCheckDisabled || !request.isBatchRequest);\n          \n          \n            \n            \t\t\t\t\t\trequest -> !isBatchSlotRequestTimeoutCheckDisabled || !request.isBatchRequest());", "author": "tillrohrmann", "createdAt": "2020-12-09T15:13:06Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());\n+\t\t}\n+\n+\t\t// we have to first reserve all matching slots before fulfilling the requests\n+\t\t// otherwise it can happen that the SchedulerImpl reserves one of the new slots\n+\t\t// for a request which has been triggered by fulfilling a pending request\n+\t\tfor (PendingRequestSlotMatching pendingRequestSlotMatching : matchingsToFulfill) {\n+\t\t\tpendingRequestSlotMatching.fulfillPendingRequest();\n+\t\t}\n+\t}\n+\n+\tprivate void reserveFreeSlot(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile resourceProfile) {\n+\t\tLOG.debug(\"Reserve slot {} for slot request id {}\", allocationId, slotRequestId);\n+\t\tdeclarativeSlotPool.reserveFreeSlot(allocationId, resourceProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\t}\n+\n+\tprivate Optional<PendingRequest> findMatchingPendingRequest(PhysicalSlot slot) {\n+\t\tfinal ResourceProfile resourceProfile = slot.getResourceProfile();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequests.values()) {\n+\t\t\tif (resourceProfile.isMatching(pendingRequest.getResourceProfile())) {\n+\t\t\t\tLOG.debug(\"Matched slot {} to pending request {}.\", slot, pendingRequest);\n+\t\t\t\treturn Optional.of(pendingRequest);\n+\t\t\t}\n+\t\t}\n+\t\tLOG.debug(\"Could not match slot {} to any pending request.\", slot);\n+\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID) {\n+\t\tthrow new UnsupportedOperationException(\"This method should not be used when using declarative resource management.\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID, @Nullable ResourceProfile requiredSlotProfile) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(requiredSlotProfile, \"The requiredSlotProfile must not be null.\");\n+\n+\t\tLOG.debug(\"Reserving free slot {} for slot request id {} and profile {}.\", allocationID, slotRequestId, requiredSlotProfile);\n+\n+\t\treturn Optional.of(reserveFreeSlotForResource(slotRequestId, allocationID, requiredSlotProfile));\n+\t}\n+\n+\tprivate PhysicalSlot reserveFreeSlotForResource(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(requiredSlotProfile, 1));\n+\t\tfinal PhysicalSlot physicalSlot = declarativeSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\n+\t\treturn physicalSlot;\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile, @Nullable Time timeout) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createNormalRequest(slotRequestId, resourceProfile);\n+\n+\t\tif (timeout != null) {\n+\t\t\tFutureUtils\n+\t\t\t\t.orTimeout(\n+\t\t\t\t\tpendingRequest.getSlotFuture(),\n+\t\t\t\t\ttimeout.toMilliseconds(),\n+\t\t\t\t\tTimeUnit.MILLISECONDS,\n+\t\t\t\t\tcomponentMainThreadExecutor)\n+\t\t\t\t.whenComplete((physicalSlot, throwable) -> {\n+\t\t\t\t\tif (throwable instanceof TimeoutException) {\n+\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t}\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedBatchSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated batch slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\tprivate void timeoutPendingSlotRequest(SlotRequestId slotRequestId) {\n+\t\treleaseSlot(slotRequestId, new TimeoutException(\"Pending slot request timed out in slot pool.\"));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlot> internalRequestNewAllocatedSlot(PendingRequest pendingRequest) {\n+\t\tpendingRequests.put(pendingRequest.getSlotRequestId(), pendingRequest);\n+\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\n+\t\treturn pendingRequest.getSlotFuture();\n+\t}\n+\n+\tprivate void declareResourceRequirements(Collection<ResourceRequirement> resourceRequirements) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Declare new resource requirements for job {}: {}.\", jobId, resourceRequirements);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.declareResourceRequirements(ResourceRequirements.create(jobId, jobManagerAddress, resourceRequirements));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(AllocationID allocationID, Exception cause) {\n+\t\tthrow new UnsupportedOperationException(\"Please call failAllocation(ResourceID, AllocationID, Exception)\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(@Nullable ResourceID resourceId, AllocationID allocationID, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tPreconditions.checkNotNull(allocationID);\n+\t\tPreconditions.checkNotNull(resourceId, \"This slot pool only supports failAllocation calls coming from the TaskExecutor.\");\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = declarativeSlotPool.releaseSlot(allocationID, cause);\n+\t\tif (!previouslyFulfilledRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirements);\n+\t\t}\n+\n+\t\tif (declarativeSlotPool.containsSlots(resourceId)) {\n+\t\t\treturn Optional.empty();\n+\t\t} else {\n+\t\t\treturn Optional.of(resourceId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwable cause) {\n+\t\tLOG.debug(\"Release slot with slot request id {}\", slotRequestId);\n+\t\tassertRunningInMainThread();\n+\n+\t\tfinal PendingRequest pendingRequest = pendingRequests.remove(slotRequestId);\n+\n+\t\tif (pendingRequest != null) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\t\t\tpendingRequest.failRequest(new FlinkException(\n+\t\t\t\t\tString.format(\"Pending slot request with %s has been released.\", pendingRequest.getSlotRequestId()),\n+\t\t\t\t\tcause));\n+\t\t} else {\n+\t\t\tfinal AllocationID allocationId = fulfilledRequests.remove(slotRequestId);\n+\n+\t\t\tif (allocationId != null) {\n+\t\t\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.freeReservedSlot(allocationId, cause, clock.relativeTimeMillis());\n+\t\t\t\tif (!previouslyFulfilledRequirement.isEmpty()) {\n+\t\t\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tLOG.debug(\"Could not find slot which has fulfilled slot request {}. Ignoring the release operation.\", slotRequestId);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void notifyNotEnoughResourcesAvailable(Collection<ResourceRequirement> acquiredResources) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tcomponentMainThreadExecutor.schedule(\n+\t\t\t\tfailPendingRequests(),\n+\t\t\t\tresourceAcquisitionTimeout.toMillis(),\n+\t\t\t\tTimeUnit.MILLISECONDS);\n+\t}\n+\n+\tprivate Runnable failPendingRequests() {\n+\t\treturn () -> {\n+\t\t\tif (!pendingRequests.isEmpty()) {\n+\t\t\t\tfinal NoResourceAvailableException cause = new NoResourceAvailableException(\"Could not acquire the minimum required resources.\");\n+\n+\t\t\t\tcancelPendingRequests(\n+\t\t\t\t\t\tcause,\n+\t\t\t\t\t\trequest -> !isBatchSlotRequestTimeoutCheckDisabled || !request.isBatchRequest);", "originalCommit": "aa2a35104a430e3dada923f364ceff82d4fcc87d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM5OTcyMw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539399723", "bodyText": "Why are we scheduling the failPendingRequests here and don't execute it immediately?", "author": "tillrohrmann", "createdAt": "2020-12-09T15:24:58Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -0,0 +1,680 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmanager.slots.TaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotInfo;\n+import org.apache.flink.runtime.jobmaster.AllocatedSlotReport;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotInfo;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.resourcemanager.ResourceManagerGateway;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.slots.ResourceRequirements;\n+import org.apache.flink.runtime.taskexecutor.slot.SlotOffer;\n+import org.apache.flink.runtime.taskmanager.TaskManagerLocation;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.Preconditions;\n+import org.apache.flink.util.clock.Clock;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * {@link SlotPool} implementation which uses the {@link DeclarativeSlotPool} to allocate slots.\n+ */\n+public class DeclarativeSlotPoolBridge implements SlotPool {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DeclarativeSlotPoolBridge.class);\n+\n+\tprivate final JobID jobId;\n+\n+\tprivate final Map<SlotRequestId, PendingRequest> pendingRequests;\n+\tprivate final Map<SlotRequestId, AllocationID> fulfilledRequests;\n+\tprivate final Set<AllocationID> newSlotsSet;\n+\tprivate final DeclarativeSlotPool declarativeSlotPool;\n+\tprivate final Set<ResourceID> registeredTaskManagers;\n+\n+\t@Nullable\n+\tprivate ComponentMainThreadExecutor componentMainThreadExecutor;\n+\n+\t@Nullable\n+\tprivate String jobManagerAddress;\n+\n+\t@Nullable\n+\tprivate JobMasterId jobMasterId;\n+\n+\tprivate DeclareResourceRequirementServiceConnectionManager declareResourceRequirementServiceConnectionManager;\n+\n+\tprivate final Clock clock;\n+\tprivate final Time rpcTimeout;\n+\tprivate final Time idleSlotTimeout;\n+\tprivate final Time batchSlotTimeout;\n+\tprivate boolean isBatchSlotRequestTimeoutCheckDisabled;\n+\tprivate final Duration resourceAcquisitionTimeout;\n+\n+\tpublic DeclarativeSlotPoolBridge(\n+\t\t\tJobID jobId,\n+\t\t\tDeclarativeSlotPoolFactory declarativeSlotPoolFactory,\n+\t\t\tClock clock,\n+\t\t\tTime rpcTimeout,\n+\t\t\tTime idleSlotTimeout,\n+\t\t\tTime batchSlotTimeout, Duration resourceAcquisitionTimeout) {\n+\t\tthis.jobId = Preconditions.checkNotNull(jobId);\n+\t\tthis.clock = Preconditions.checkNotNull(clock);\n+\t\tthis.rpcTimeout = Preconditions.checkNotNull(rpcTimeout);\n+\t\tthis.idleSlotTimeout = Preconditions.checkNotNull(idleSlotTimeout);\n+\t\tthis.batchSlotTimeout = Preconditions.checkNotNull(batchSlotTimeout);\n+\t\tthis.isBatchSlotRequestTimeoutCheckDisabled = false;\n+\t\tthis.resourceAcquisitionTimeout = Preconditions.checkNotNull(resourceAcquisitionTimeout);\n+\n+\t\tthis.pendingRequests = new LinkedHashMap<>();\n+\t\tthis.fulfilledRequests = new HashMap<>();\n+\t\tthis.newSlotsSet = new HashSet<>();\n+\t\tthis.registeredTaskManagers = new HashSet<>();\n+\t\tthis.declareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tthis.declarativeSlotPool = declarativeSlotPoolFactory.create(\n+\t\t\t\tthis::declareResourceRequirements,\n+\t\t\t\tthis::newSlotsAreAvailable,\n+\t\t\t\tidleSlotTimeout,\n+\t\t\t\trpcTimeout);\n+\t}\n+\n+\t@Override\n+\tpublic void start(JobMasterId jobMasterId, String newJobManagerAddress, ComponentMainThreadExecutor jmMainThreadScheduledExecutor) throws Exception {\n+\t\tthis.componentMainThreadExecutor = Preconditions.checkNotNull(jmMainThreadScheduledExecutor);\n+\t\tthis.jobManagerAddress = Preconditions.checkNotNull(newJobManagerAddress);\n+\t\tthis.jobMasterId = Preconditions.checkNotNull(jobMasterId);\n+\t\tthis.declareResourceRequirementServiceConnectionManager = DefaultDeclareResourceRequirementServiceConnectionManager.create(componentMainThreadExecutor);\n+\n+\t\tcomponentMainThreadExecutor.schedule(this::checkIdleSlotTimeout, idleSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t\tcomponentMainThreadExecutor.schedule(this::checkBatchSlotTimeout, batchSlotTimeout.toMilliseconds(), TimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@Override\n+\tpublic void suspend() {\n+\t\tassertRunningInMainThread();\n+\t\tLOG.info(\"Suspending slot pool.\");\n+\n+\t\tcancelPendingRequests(new FlinkException(\"Suspending slot pool.\"), request -> true);\n+\t\tclearState();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\tLOG.info(\"Closing slot pool.\");\n+\t\tfinal FlinkException cause = new FlinkException(\"Closing slot pool\");\n+\t\tcancelPendingRequests(cause, request -> true);\n+\t\treleaseAllTaskManagers(new FlinkException(\"Closing slot pool.\"));\n+\t\tclearState();\n+\t}\n+\n+\tprivate void cancelPendingRequests(FlinkException cancelCause, Predicate<PendingRequest> requestPredicate) {\n+\t\tResourceCounter decreasedResourceRequirements = ResourceCounter.empty();\n+\n+\t\t// need a copy since failing a request could trigger another request to be issued\n+\t\tfinal Iterable<PendingRequest> pendingRequestsToFail = new ArrayList<>(pendingRequests.values());\n+\t\tpendingRequests.clear();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequestsToFail) {\n+\t\t\tif (requestPredicate.test(pendingRequest)) {\n+\t\t\t\tpendingRequest.failRequest(cancelCause);\n+\t\t\t\tdecreasedResourceRequirements = decreasedResourceRequirements.add(pendingRequest.getResourceProfile(), 1);\n+\t\t\t} else {\n+\t\t\t\tpendingRequests.put(pendingRequest.slotRequestId, pendingRequest);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!decreasedResourceRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(decreasedResourceRequirements);\n+\t\t}\n+\t}\n+\n+\tprivate void clearState() {\n+\t\tdeclareResourceRequirementServiceConnectionManager.close();\n+\t\tdeclareResourceRequirementServiceConnectionManager = NoOpDeclareResourceRequirementServiceConnectionManager.INSTANCE;\n+\t\tregisteredTaskManagers.clear();\n+\t\tjobManagerAddress = null;\n+\t\tjobMasterId = null;\n+\t}\n+\n+\t@Override\n+\tpublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(resourceManagerGateway);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.connect(resourceRequirements -> resourceManagerGateway.declareRequiredResources(jobMasterId, resourceRequirements, rpcTimeout));\n+\t\tdeclareResourceRequirements(declarativeSlotPool.getResourceRequirements());\n+\t}\n+\n+\t@Override\n+\tpublic void disconnectResourceManager() {\n+\t\tassertRunningInMainThread();\n+\t\tthis.declareResourceRequirementServiceConnectionManager.disconnect();\n+\t}\n+\n+\t@Override\n+\tpublic boolean registerTaskManager(ResourceID resourceID) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Register new TaskExecutor {}.\", resourceID);\n+\t\treturn registeredTaskManagers.add(resourceID);\n+\t}\n+\n+\t@Override\n+\tpublic boolean releaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tif (registeredTaskManagers.remove(resourceId)) {\n+\t\t\tinternalReleaseTaskManager(resourceId, cause);\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\tprivate void releaseAllTaskManagers(FlinkException cause) {\n+\t\tfor (ResourceID registeredTaskManager : registeredTaskManagers) {\n+\t\t\tinternalReleaseTaskManager(registeredTaskManager, cause);\n+\t\t}\n+\n+\t\tregisteredTaskManagers.clear();\n+\t}\n+\n+\tprivate void internalReleaseTaskManager(ResourceID resourceId, Exception cause) {\n+\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.releaseSlots(resourceId, cause);\n+\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<SlotOffer> offerSlots(TaskManagerLocation taskManagerLocation, TaskManagerGateway taskManagerGateway, Collection<SlotOffer> offers) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(taskManagerGateway);\n+\t\tPreconditions.checkNotNull(offers);\n+\n+\t\tif (!registeredTaskManagers.contains(taskManagerLocation.getResourceID())) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\treturn declarativeSlotPool.offerSlots(offers, taskManagerLocation, taskManagerGateway, clock.relativeTimeMillis());\n+\t}\n+\n+\t@VisibleForTesting\n+\tvoid newSlotsAreAvailable(Collection<? extends PhysicalSlot> newSlots) {\n+\t\t// Avoid notifying new slots multiple times due to SchedulerImpl allocating and releasing slots\n+\t\t// in order to find the best shared slot\n+\t\tfinal Collection<PhysicalSlot> slotsToProcess = new ArrayList<>();\n+\t\tfor (PhysicalSlot newSlot : newSlots) {\n+\t\t\tif (newSlotsSet.add(newSlot.getAllocationId())) {\n+\t\t\t\tslotsToProcess.add(newSlot);\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal Collection<PendingRequestSlotMatching> matchingsToFulfill = new ArrayList<>();\n+\n+\t\tfor (PhysicalSlot newSlot : slotsToProcess) {\n+\t\t\tfinal Optional<PendingRequest> matchingPendingRequest = findMatchingPendingRequest(newSlot);\n+\n+\t\t\tmatchingPendingRequest.ifPresent(pendingRequest -> {\n+\t\t\t\tPreconditions.checkNotNull(pendingRequests.remove(pendingRequest.getSlotRequestId()), \"Cannot fulfill a non existing pending slot request.\");\n+\t\t\t\treserveFreeSlot(pendingRequest.getSlotRequestId(), newSlot.getAllocationId(), pendingRequest.resourceProfile);\n+\n+\t\t\t\tmatchingsToFulfill.add(PendingRequestSlotMatching.createFor(pendingRequest, newSlot));\n+\t\t\t});\n+\n+\t\t\tnewSlotsSet.remove(newSlot.getAllocationId());\n+\t\t}\n+\n+\t\t// we have to first reserve all matching slots before fulfilling the requests\n+\t\t// otherwise it can happen that the SchedulerImpl reserves one of the new slots\n+\t\t// for a request which has been triggered by fulfilling a pending request\n+\t\tfor (PendingRequestSlotMatching pendingRequestSlotMatching : matchingsToFulfill) {\n+\t\t\tpendingRequestSlotMatching.fulfillPendingRequest();\n+\t\t}\n+\t}\n+\n+\tprivate void reserveFreeSlot(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile resourceProfile) {\n+\t\tLOG.debug(\"Reserve slot {} for slot request id {}\", allocationId, slotRequestId);\n+\t\tdeclarativeSlotPool.reserveFreeSlot(allocationId, resourceProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\t}\n+\n+\tprivate Optional<PendingRequest> findMatchingPendingRequest(PhysicalSlot slot) {\n+\t\tfinal ResourceProfile resourceProfile = slot.getResourceProfile();\n+\n+\t\tfor (PendingRequest pendingRequest : pendingRequests.values()) {\n+\t\t\tif (resourceProfile.isMatching(pendingRequest.getResourceProfile())) {\n+\t\t\t\tLOG.debug(\"Matched slot {} to pending request {}.\", slot, pendingRequest);\n+\t\t\t\treturn Optional.of(pendingRequest);\n+\t\t\t}\n+\t\t}\n+\t\tLOG.debug(\"Could not match slot {} to any pending request.\", slot);\n+\n+\t\treturn Optional.empty();\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID) {\n+\t\tthrow new UnsupportedOperationException(\"This method should not be used when using declarative resource management.\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<PhysicalSlot> allocateAvailableSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull AllocationID allocationID, @Nullable ResourceProfile requiredSlotProfile) {\n+\t\tassertRunningInMainThread();\n+\t\tPreconditions.checkNotNull(requiredSlotProfile, \"The requiredSlotProfile must not be null.\");\n+\n+\t\tLOG.debug(\"Reserving free slot {} for slot request id {} and profile {}.\", allocationID, slotRequestId, requiredSlotProfile);\n+\n+\t\treturn Optional.of(reserveFreeSlotForResource(slotRequestId, allocationID, requiredSlotProfile));\n+\t}\n+\n+\tprivate PhysicalSlot reserveFreeSlotForResource(SlotRequestId slotRequestId, AllocationID allocationId, ResourceProfile requiredSlotProfile) {\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(requiredSlotProfile, 1));\n+\t\tfinal PhysicalSlot physicalSlot = declarativeSlotPool.reserveFreeSlot(allocationId, requiredSlotProfile);\n+\t\tfulfilledRequests.put(slotRequestId, allocationId);\n+\n+\t\treturn physicalSlot;\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile, @Nullable Time timeout) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createNormalRequest(slotRequestId, resourceProfile);\n+\n+\t\tif (timeout != null) {\n+\t\t\tFutureUtils\n+\t\t\t\t.orTimeout(\n+\t\t\t\t\tpendingRequest.getSlotFuture(),\n+\t\t\t\t\ttimeout.toMilliseconds(),\n+\t\t\t\t\tTimeUnit.MILLISECONDS,\n+\t\t\t\t\tcomponentMainThreadExecutor)\n+\t\t\t\t.whenComplete((physicalSlot, throwable) -> {\n+\t\t\t\t\tif (throwable instanceof TimeoutException) {\n+\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t}\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\t@Override\n+\t@Nonnull\n+\tpublic CompletableFuture<PhysicalSlot> requestNewAllocatedBatchSlot(@Nonnull SlotRequestId slotRequestId, @Nonnull ResourceProfile resourceProfile) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Request new allocated batch slot with slot request id {} and resource profile {}\", slotRequestId, resourceProfile);\n+\n+\t\tfinal PendingRequest pendingRequest = PendingRequest.createBatchRequest(slotRequestId, resourceProfile);\n+\n+\t\treturn internalRequestNewAllocatedSlot(pendingRequest);\n+\t}\n+\n+\tprivate void timeoutPendingSlotRequest(SlotRequestId slotRequestId) {\n+\t\treleaseSlot(slotRequestId, new TimeoutException(\"Pending slot request timed out in slot pool.\"));\n+\t}\n+\n+\tprivate CompletableFuture<PhysicalSlot> internalRequestNewAllocatedSlot(PendingRequest pendingRequest) {\n+\t\tpendingRequests.put(pendingRequest.getSlotRequestId(), pendingRequest);\n+\n+\t\tdeclarativeSlotPool.increaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\n+\t\treturn pendingRequest.getSlotFuture();\n+\t}\n+\n+\tprivate void declareResourceRequirements(Collection<ResourceRequirement> resourceRequirements) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tLOG.debug(\"Declare new resource requirements for job {}: {}.\", jobId, resourceRequirements);\n+\n+\t\tdeclareResourceRequirementServiceConnectionManager.declareResourceRequirements(ResourceRequirements.create(jobId, jobManagerAddress, resourceRequirements));\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(AllocationID allocationID, Exception cause) {\n+\t\tthrow new UnsupportedOperationException(\"Please call failAllocation(ResourceID, AllocationID, Exception)\");\n+\t}\n+\n+\t@Override\n+\tpublic Optional<ResourceID> failAllocation(@Nullable ResourceID resourceId, AllocationID allocationID, Exception cause) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tPreconditions.checkNotNull(allocationID);\n+\t\tPreconditions.checkNotNull(resourceId, \"This slot pool only supports failAllocation calls coming from the TaskExecutor.\");\n+\n+\t\tResourceCounter previouslyFulfilledRequirements = declarativeSlotPool.releaseSlot(allocationID, cause);\n+\t\tif (!previouslyFulfilledRequirements.isEmpty()) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirements);\n+\t\t}\n+\n+\t\tif (declarativeSlotPool.containsSlots(resourceId)) {\n+\t\t\treturn Optional.empty();\n+\t\t} else {\n+\t\t\treturn Optional.of(resourceId);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void releaseSlot(@Nonnull SlotRequestId slotRequestId, @Nullable Throwable cause) {\n+\t\tLOG.debug(\"Release slot with slot request id {}\", slotRequestId);\n+\t\tassertRunningInMainThread();\n+\n+\t\tfinal PendingRequest pendingRequest = pendingRequests.remove(slotRequestId);\n+\n+\t\tif (pendingRequest != null) {\n+\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(ResourceCounter.withResource(pendingRequest.getResourceProfile(), 1));\n+\t\t\tpendingRequest.failRequest(new FlinkException(\n+\t\t\t\t\tString.format(\"Pending slot request with %s has been released.\", pendingRequest.getSlotRequestId()),\n+\t\t\t\t\tcause));\n+\t\t} else {\n+\t\t\tfinal AllocationID allocationId = fulfilledRequests.remove(slotRequestId);\n+\n+\t\t\tif (allocationId != null) {\n+\t\t\t\tResourceCounter previouslyFulfilledRequirement = declarativeSlotPool.freeReservedSlot(allocationId, cause, clock.relativeTimeMillis());\n+\t\t\t\tif (!previouslyFulfilledRequirement.isEmpty()) {\n+\t\t\t\t\tdeclarativeSlotPool.decreaseResourceRequirementsBy(previouslyFulfilledRequirement);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tLOG.debug(\"Could not find slot which has fulfilled slot request {}. Ignoring the release operation.\", slotRequestId);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void notifyNotEnoughResourcesAvailable(Collection<ResourceRequirement> acquiredResources) {\n+\t\tassertRunningInMainThread();\n+\n+\t\tcomponentMainThreadExecutor.schedule(\n+\t\t\t\tfailPendingRequests(),\n+\t\t\t\tresourceAcquisitionTimeout.toMillis(),\n+\t\t\t\tTimeUnit.MILLISECONDS);", "originalCommit": "aa2a35104a430e3dada923f364ceff82d4fcc87d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ4MzAwNQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539483005", "bodyText": "IIRC we wanted to have a timeout here in particular for a newly started cluster to ensure the job can run even if the task executors are starting up a bit slowly.", "author": "zentol", "createdAt": "2020-12-09T17:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM5OTcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NzQwOA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539597408", "bodyText": "no wait, that case is covered by the resource managers startup period...\nI don't quite remember then. It does use the slot request timeout as a default, but then again we already setup a timeout within requestNewAllocatedSlot. But this will likely just result in the allocation being retried?\nI guess that is it; in order to differentiate between timeouts due to network issues, and not enough resources being available......................but then why not fail immediately?\nOH. I remember now; we actually discussed this once. My thinking back then was that we should not fail immediately because we should honor the slot request timeout, but you mentioned that this is just a maximum, and if a component has more information available then it is free to fail earlier.\nSo this is just something I forgot to change :/", "author": "zentol", "createdAt": "2020-12-09T19:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM5OTcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAyNjM0MA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540026340", "bodyText": "Sounds good to me.", "author": "tillrohrmann", "createdAt": "2020-12-10T09:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM5OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwNDY2OA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r539404668", "bodyText": "I think it would be great to add some tests which ensure that the set of declared resources is correct wrt to different actions on the SlotPool (e.g. failAllocation, releaseSlot, allocateAvailableSlot etc.)", "author": "tillrohrmann", "createdAt": "2020-12-09T15:30:25Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.concurrent.FutureUtils;\n+import org.apache.flink.runtime.jobmanager.scheduler.NoResourceAvailableException;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.RpcTaskManagerGateway;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.taskmanager.LocalTaskManagerLocation;\n+import org.apache.flink.util.ExceptionUtils;\n+import org.apache.flink.util.TestLogger;\n+import org.apache.flink.util.clock.SystemClock;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nonnull;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeTest extends TestLogger {", "originalCommit": "aa2a35104a430e3dada923f364ceff82d4fcc87d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NDY1Nw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540154657", "bodyText": "What exception will be thrown?", "author": "tillrohrmann", "createdAt": "2020-12-10T13:08:44Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/SlotPool.java", "diffHunk": "@@ -151,32 +151,18 @@ void start(\n \tCollection<SlotInfo> getAllocatedSlotsInformation();\n \n \t/**\n-\t * Allocates the available slot with the given allocation id under the given request id. This method returns\n-\t * {@code null} if no slot with the given allocation id is available.\n+\t * Allocates the available slot with the given allocation id under the given request id for the given requirement profile.\n+\t * The slot must be able to fulfill the requirement profile, otherwise an exception will be thrown.", "originalCommit": "4a2a3fe7bf8c8b7f9579e2aebd100e4c58fefd6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1OTYwMw==", "url": "https://github.com/apache/flink/pull/13964#discussion_r540159603", "bodyText": "I think the fact that failing this future triggers the cleanup is an implementation detail which can change in the future. I would suggest to use a very small timeout so that the request fails fast.", "author": "tillrohrmann", "createdAt": "2020-12-10T13:16:19Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeResourceDeclarationTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createAllocatedSlot;\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createDeclarativeSlotPoolBridge;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeResourceDeclarationTest extends TestLogger {\n+\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\tprivate RequirementListener requirementListener;\n+\tprivate DeclarativeSlotPoolBridge declarativeSlotPoolBridge;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\trequirementListener = new RequirementListener();\n+\n+\t\tfinal TestingDeclarativeSlotPoolBuilder slotPoolBuilder = TestingDeclarativeSlotPool.builder()\n+\t\t\t.setIncreaseResourceRequirementsByConsumer(requirementListener::increaseRequirements)\n+\t\t\t.setDecreaseResourceRequirementsByConsumer(requirementListener::decreaseRequirements)\n+\t\t\t.setReserveFreeSlotFunction((allocationId, resourceProfile) -> createAllocatedSlot(allocationId))\n+\t\t\t.setFreeReservedSlotFunction((allocationID, throwable, aLong) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1))\n+\t\t\t.setReleaseSlotFunction((allocationID, e) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1));\n+\n+\t\tfinal DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory(slotPoolBuilder);\n+\t\tdeclarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory);\n+\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\t}\n+\n+\t@After\n+\tpublic void teardown() throws Exception {\n+\t\tif (declarativeSlotPoolBridge != null) {\n+\t\t\tdeclarativeSlotPoolBridge.close();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsIncreasedOnNewAllocation() {\n+\t\t// requesting the allocation of a new slot should increase the requirements\n+\t\tdeclarativeSlotPoolBridge.requestNewAllocatedSlot(new SlotRequestId(), ResourceProfile.UNKNOWN, Time.minutes(5));\n+\t\tassertThat(requirementListener.getRequirements().getResourceCount(ResourceProfile.UNKNOWN), is(1));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsDecreasedOnAllocationTimeout() {\n+\t\t// requesting the allocation of a new slot increases the requirements\n+\t\tfinal CompletableFuture<PhysicalSlot> allocationFuture = declarativeSlotPoolBridge.requestNewAllocatedSlot(new SlotRequestId(), ResourceProfile.UNKNOWN, Time.minutes(5));\n+\t\t// when the allocation fails the requirements should be reduced (it is the users responsibility to retry)\n+\t\tallocationFuture.completeExceptionally(new TimeoutException());", "originalCommit": "4a2a3fe7bf8c8b7f9579e2aebd100e4c58fefd6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "38b20a3ba8f75871d2d12fe9c54f09372d72a995", "url": "https://github.com/apache/flink/commit/38b20a3ba8f75871d2d12fe9c54f09372d72a995", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management", "committedDate": "2020-12-13T23:40:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI2NjU1NA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r544266554", "bodyText": "x", "author": "zentol", "createdAt": "2020-12-16T12:40:30Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridgeResourceDeclarationTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.jobmaster.slotpool;\n+\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.core.testutils.FlinkMatchers;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutor;\n+import org.apache.flink.runtime.concurrent.ComponentMainThreadExecutorServiceAdapter;\n+import org.apache.flink.runtime.jobmaster.JobMasterId;\n+import org.apache.flink.runtime.jobmaster.SlotRequestId;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createAllocatedSlot;\n+import static org.apache.flink.runtime.jobmaster.slotpool.DeclarativeSlotPoolBridgeTest.createDeclarativeSlotPoolBridge;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link DeclarativeSlotPoolBridge}.\n+ */\n+public class DeclarativeSlotPoolBridgeResourceDeclarationTest extends TestLogger {\n+\n+\tprivate static final JobMasterId jobMasterId = JobMasterId.generate();\n+\tprivate final ComponentMainThreadExecutor mainThreadExecutor = ComponentMainThreadExecutorServiceAdapter.forMainThread();\n+\n+\tprivate RequirementListener requirementListener;\n+\tprivate DeclarativeSlotPoolBridge declarativeSlotPoolBridge;\n+\n+\t@Before\n+\tpublic void setup() throws Exception {\n+\t\trequirementListener = new RequirementListener();\n+\n+\t\tfinal TestingDeclarativeSlotPoolBuilder slotPoolBuilder = TestingDeclarativeSlotPool.builder()\n+\t\t\t.setIncreaseResourceRequirementsByConsumer(requirementListener::increaseRequirements)\n+\t\t\t.setDecreaseResourceRequirementsByConsumer(requirementListener::decreaseRequirements)\n+\t\t\t.setReserveFreeSlotFunction((allocationId, resourceProfile) -> createAllocatedSlot(allocationId))\n+\t\t\t.setFreeReservedSlotFunction((allocationID, throwable, aLong) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1))\n+\t\t\t.setReleaseSlotFunction((allocationID, e) -> ResourceCounter.withResource(ResourceProfile.UNKNOWN, 1));\n+\n+\t\tfinal DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory declarativeSlotPoolFactory = new DeclarativeSlotPoolBridgeTest.TestingDeclarativeSlotPoolFactory(slotPoolBuilder);\n+\t\tdeclarativeSlotPoolBridge = createDeclarativeSlotPoolBridge(declarativeSlotPoolFactory);\n+\t}\n+\n+\t@After\n+\tpublic void teardown() throws Exception {\n+\t\tif (declarativeSlotPoolBridge != null) {\n+\t\t\tdeclarativeSlotPoolBridge.close();\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsIncreasedOnNewAllocation() throws Exception {\n+\t\tdeclarativeSlotPoolBridge.start(jobMasterId, \"localhost\", mainThreadExecutor);\n+\n+\t\t// requesting the allocation of a new slot should increase the requirements\n+\t\tdeclarativeSlotPoolBridge.requestNewAllocatedSlot(new SlotRequestId(), ResourceProfile.UNKNOWN, Time.minutes(5));\n+\t\tassertThat(requirementListener.getRequirements().getResourceCount(ResourceProfile.UNKNOWN), is(1));\n+\t}\n+\n+\t@Test\n+\tpublic void testRequirementsDecreasedOnAllocationTimeout() throws Exception {", "originalCommit": "d4226484f9f498f8e4697a794027b1956bdb62c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NzM3OA==", "url": "https://github.com/apache/flink/pull/13964#discussion_r544397378", "bodyText": "After an offline discussion with Chesnay we concluded that this is not the fix for the problem. Instead we will try to not expose futures which have other dependents because this can lead to violating the main thread guarantee when waiting on this future outside of the main thread (get() will try to complete the future's dependents).", "author": "tillrohrmann", "createdAt": "2020-12-16T15:36:04Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/jobmaster/slotpool/DeclarativeSlotPoolBridge.java", "diffHunk": "@@ -317,11 +317,12 @@ private PhysicalSlot reserveFreeSlotForResource(SlotRequestId slotRequestId, All\n \t\t\t\t\ttimeout.toMilliseconds(),\n \t\t\t\t\tTimeUnit.MILLISECONDS,\n \t\t\t\t\tcomponentMainThreadExecutor)\n-\t\t\t\t.whenComplete((physicalSlot, throwable) -> {\n-\t\t\t\t\tif (throwable instanceof TimeoutException) {\n-\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n-\t\t\t\t\t}\n-\t\t\t\t});\n+\t\t\t\t.whenCompleteAsync((physicalSlot, throwable) -> {\n+\t\t\t\t\t\tif (throwable instanceof TimeoutException) {\n+\t\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t},\n+\t\t\t\t\tcomponentMainThreadExecutor);", "originalCommit": "6f58354898bc5d4e76e1e99874e92db60ad09707", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDQwMTA5OQ==", "url": "https://github.com/apache/flink/pull/13964#discussion_r544401099", "bodyText": "Due to whenCompleteAsync the testRequirementsDecreasedOnAllocationTimeout now sometimes fails because the timeoutPendingSlotRequest is not run before the final assertion.", "author": "tillrohrmann", "createdAt": "2020-12-16T15:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM5NzM3OA=="}], "type": "inlineReview"}, {"oid": "58bb428c34a3a544d622dafdbc455474e5d72592", "url": "https://github.com/apache/flink/commit/58bb428c34a3a544d622dafdbc455474e5d72592", "message": "different approach for CompletableFuture issue", "committedDate": "2020-12-16T15:55:40Z", "type": "forcePushed"}, {"oid": "35e50f75efaa798efea1ed3d139f7c021a9f00c1", "url": "https://github.com/apache/flink/commit/35e50f75efaa798efea1ed3d139f7c021a9f00c1", "message": "[hotfix][coordination] Add ExcessResource#toString()", "committedDate": "2020-12-17T14:27:36Z", "type": "commit"}, {"oid": "d686fcc297e7ba5ac9838a525a9e6ff3aba9faa4", "url": "https://github.com/apache/flink/commit/d686fcc297e7ba5ac9838a525a9e6ff3aba9faa4", "message": "[hotfix][coordination][tests] Remove error message assertions", "committedDate": "2020-12-17T14:27:36Z", "type": "commit"}, {"oid": "cc0400f585e9502076269c190a6d0b06f108ae2c", "url": "https://github.com/apache/flink/commit/cc0400f585e9502076269c190a6d0b06f108ae2c", "message": "[FLINK-19314][coordination][tests] Add TestingDeclarativeSlotPoolBuilder", "committedDate": "2020-12-17T14:27:36Z", "type": "commit"}, {"oid": "049382bdaae5591daf56ae518d664df0e744e5b9", "url": "https://github.com/apache/flink/commit/049382bdaae5591daf56ae518d664df0e744e5b9", "message": "[FLINK-19314][coordination] Add DeclarativeSlotPoolFactory", "committedDate": "2020-12-17T14:27:37Z", "type": "commit"}, {"oid": "ed7bc13c0fe8696d68fbf2348b714115d521b42c", "url": "https://github.com/apache/flink/commit/ed7bc13c0fe8696d68fbf2348b714115d521b42c", "message": "[FLINK-19314][coordination] Extend SlotPool interface", "committedDate": "2020-12-17T14:27:37Z", "type": "commit"}, {"oid": "633532e6ff6b74a0c90c1a8af98a627ada8ac88c", "url": "https://github.com/apache/flink/commit/633532e6ff6b74a0c90c1a8af98a627ada8ac88c", "message": "[FLINK-19314][coordination] Add DeclarativeSlotPoolBridge", "committedDate": "2020-12-17T14:27:37Z", "type": "commit"}, {"oid": "716aa2625b423f76c12b081ad6d3544cdc586f80", "url": "https://github.com/apache/flink/commit/716aa2625b423f76c12b081ad6d3544cdc586f80", "message": "[FLINK-19314][coordination] Wire notifications about resources not being available", "committedDate": "2020-12-17T14:27:37Z", "type": "commit"}, {"oid": "1261d16c5f1aa9517fee4a8a471300cd13d39fe2", "url": "https://github.com/apache/flink/commit/1261d16c5f1aa9517fee4a8a471300cd13d39fe2", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management", "committedDate": "2020-12-17T14:27:37Z", "type": "forcePushed"}, {"oid": "95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "url": "https://github.com/apache/flink/commit/95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management", "committedDate": "2020-12-17T17:03:32Z", "type": "commit"}, {"oid": "95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "url": "https://github.com/apache/flink/commit/95d0b35e9842bc5d92aac29a5f612bc2aa4bcefd", "message": "[FLINK-19305][coordination][CI] Setup CI run with declarative slot management", "committedDate": "2020-12-17T17:03:32Z", "type": "forcePushed"}]}