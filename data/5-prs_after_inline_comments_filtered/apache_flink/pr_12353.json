{"pr_number": 12353, "pr_title": "[FLINK-17322][network] Fixes BroadcastRecordWriter overwriting memory segments on first finished BufferConsumer.", "pr_createdAt": "2020-05-27T08:29:42Z", "pr_url": "https://github.com/apache/flink/pull/12353", "timeline": [{"oid": "1e0e6b50bfecaf86fac285ff25dfb32aa52dde2c", "url": "https://github.com/apache/flink/commit/1e0e6b50bfecaf86fac285ff25dfb32aa52dde2c", "message": "[FLINK-17322][network] Fixes BroadcastRecordWriter overwriting memory segments on first finished BufferConsumer.\n\nBroadcastRecordWriter#randomEmit initialized buffer consumers for other non-target channels incorrectly leading to separate buffer reference counting and subsequently released buffers too early.", "committedDate": "2020-05-28T08:46:26Z", "type": "forcePushed"}, {"oid": "a542150b0b6544d2b38c350be0e5b0d12dc305a2", "url": "https://github.com/apache/flink/commit/a542150b0b6544d2b38c350be0e5b0d12dc305a2", "message": "[FLINK-17322][network] Fixes BroadcastRecordWriter overwriting memory segments on first finished BufferConsumer.\n\nBroadcastRecordWriter#randomEmit initialized buffer consumers for other non-target channels incorrectly leading to separate buffer reference counting and subsequently released buffers too early.", "committedDate": "2020-05-28T08:46:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDgyNA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r432264824", "bodyText": "I think we should not construct the consumer before filling the BufferBuilder, otherwise the random emitted latency marker is also visible for all the other channels, which breaks the previous assumption.", "author": "zhijiangW", "createdAt": "2020-05-29T05:35:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/BroadcastRecordWriter.java", "diffHunk": "@@ -130,7 +132,7 @@ public BufferBuilder requestNewBufferBuilder(int targetChannel) throws IOExcepti\n \n \t\tBufferBuilder builder = super.requestNewBufferBuilder(targetChannel);\n \t\tif (randomTriggered) {\n-\t\t\taddBufferConsumer(builder.createBufferConsumer(), targetChannel);\n+\t\t\taddBufferConsumer(randomConsumer = builder.createBufferConsumer(), targetChannel);", "originalCommit": "1e0e6b50bfecaf86fac285ff25dfb32aa52dde2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUwMjU3MA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r432502570", "bodyText": "We have to or else the underlying buffer is not reference counted properly.\nThe idea is to keep the randomConsumer and use copy to use the then updated reader index.\nIf the random event spans multiple buffers, only the last randomConsumer is effectively used.", "author": "AHeise", "createdAt": "2020-05-29T14:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3NTU4NA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r432575584", "bodyText": "Yeah,  your thought is right. But my concern is that the current changes would make the latency marker visible for all the channels, not only for one random channel if my understanding is right.\nI mean the current created randomConsumer will have the read position 0, then all the copies should also have the read position 0, which means they can read the latency marker when it is filled in the BufferBuilder afterwards.\nI guess the proper way might be we only create one consumer for the random channel before filling the latency marker. After that, we create/copy the separate consumers with increased references for all the left channels, then the read position for these copied  consumers should overtake the length of latency marker?", "author": "zhijiangW", "createdAt": "2020-05-29T15:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2ODg4OA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r432768888", "bodyText": "You are right, currently LM gets replicated, which is not good. I was expecting #copy to pick up the current builder position for some reason.\nComing back to this bug, the issue is that the underlying memory segment will be recycled as soon as the first buffer consumer (with LM) is being consumed. That causes buffers to be effectively skipped and corrupted streams.\n@pnowojski and I was also questioning why BufferBuilder only holds the memory segment and not the buffer. By definition calling #createBufferConsumer more than once will create the aforementioned race condition.\nIt would be solved if BufferBuilder holds the buffer instead of the raw memory segment as a buffer would only be recycled when the last buffer consumer has been closed. However, it seems so obvious that there must be a reason for the current implementation.", "author": "AHeise", "createdAt": "2020-05-29T22:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjkzMjQ1Nw==", "url": "https://github.com/apache/flink/pull/12353#discussion_r432932457", "bodyText": "Creating Buffer in BufferBuilder would require two more volatile access when bumping the reference count on the per buffer path. I would expect this to be visible in our benchmarks with high number of network channels and frequent flushing (1000,1ms). I'm not sure, I might be wrong but I think I was even benchmarking this on Nico's request during the initial development of low latency changes.", "author": "pnowojski", "createdAt": "2020-05-31T10:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzEwMw==", "url": "https://github.com/apache/flink/pull/12353#discussion_r432967103", "bodyText": "Okay I added a proposal that strives for a middle ground: buffer is owned by BufferBuilder but not initialized before first buffer consumer is being created. If consumers are always created from the same thread, we can avoid making this cache volatile.", "author": "AHeise", "createdAt": "2020-05-31T17:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzI4NQ==", "url": "https://github.com/apache/flink/pull/12353#discussion_r432967285", "bodyText": "Alternatively, we \"just\" need to add a specific API that copies a BufferConsumer but set the positionMarker to that of a given BufferBuilder.\n\tpublic BufferConsumer copyAndSync(BufferBuilder builder) {\n\t\treturn new BufferConsumer(buffer.retainBuffer(), builder.positionMarker,\n\t\t\tbuilder.positionMarker.cachedPosition);\n\t}", "author": "AHeise", "createdAt": "2020-05-31T17:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI2NDgyNA=="}], "type": "inlineReview"}, {"oid": "b42e90672edae737f5a2ac9e4f16c5756fb6ed33", "url": "https://github.com/apache/flink/commit/b42e90672edae737f5a2ac9e4f16c5756fb6ed33", "message": "[FLINK-17322][network] Let BufferBuilder own buffer instead of memory segment.\n\nThis will unify buffer reference counting, such that it avoids BroadcastRecordWriter#randomEmit creating separate buffer reference counters for other non-target channels leading to buffers being released too early.", "committedDate": "2020-05-30T21:31:25Z", "type": "forcePushed"}, {"oid": "a4b1247ea779353f476e4c70609094f367e7d06c", "url": "https://github.com/apache/flink/commit/a4b1247ea779353f476e4c70609094f367e7d06c", "message": "[FLINK-17322][network] Fixes BroadcastRecordWriter overwriting memory segments on first finished BufferConsumer.\n\nBroadcastRecordWriter#randomEmit initialized buffer consumers for other non-target channels incorrectly leading to separate buffer reference counting and subsequently released buffers too early.\nThis commit caches the buffer created during BufferBuilder#createBufferConsumer and reuses it for subsequent buffer consumers.", "committedDate": "2020-05-31T17:24:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1MzY2OA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r434353668", "bodyText": "I think this still leaves a window for the same error to happen. When buffer == null, the returned BufferConsumer could be recycled before the next call to BufferBuilder#createBufferConsumer.\nEven besides that, the other proposal:\n\tpublic BufferConsumer copyAndSync(BufferBuilder builder) {\n\t\treturn new BufferConsumer(buffer.retainBuffer(), builder.positionMarker,\n\t\t\tbuilder.positionMarker.cachedPosition);\n\t}\n\nI think it's cleaner as it avoids adding more mutable state in the BufferBuilder.", "author": "pnowojski", "createdAt": "2020-06-03T07:11:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferBuilder.java", "diffHunk": "@@ -53,9 +55,13 @@ public BufferBuilder(MemorySegment memorySegment, BufferRecycler recycler) {\n \t * @return created matching instance of {@link BufferConsumer} to this {@link BufferBuilder}.\n \t */\n \tpublic BufferConsumer createBufferConsumer() {\n+\t\tif (buffer == null) {\n+\t\t\tbuffer = new NetworkBuffer(memorySegment, recycler);\n+\t\t} else {\n+\t\t\tbuffer.retainBuffer();\n+\t\t}", "originalCommit": "a4b1247ea779353f476e4c70609094f367e7d06c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b748b70721ad822f8484a86abc4ddc32bae6e2cc", "url": "https://github.com/apache/flink/commit/b748b70721ad822f8484a86abc4ddc32bae6e2cc", "message": "[FLINK-17322][network] Fixes BroadcastRecordWriter overwriting memory segments on first finished BufferConsumer.\n\nBroadcastRecordWriter#randomEmit initialized buffer consumers for other non-target channels incorrectly leading to separate buffer reference counting and subsequently released buffers too early.\nThis commit uses the new BufferConsumer#copyAndSync method to copy the buffer while updating the read index to the last committed write index of the builder.", "committedDate": "2020-06-03T11:48:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0NjQ2OA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r434546468", "bodyText": "Could you re-introduced checkState(!bufferConsumerCreated) removed by 7f2382a#diff-c3aa29406973e93a909773e89093b9caL43 ?", "author": "pnowojski", "createdAt": "2020-06-03T12:58:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/BroadcastRecordWriter.java", "diffHunk": "@@ -84,7 +86,7 @@ void randomEmit(T record, int targetChannelIndex) throws IOException, Interrupte\n \t\tif (bufferBuilder != null) {\n \t\t\tfor (int index = 0; index < numberOfChannels; index++) {\n \t\t\t\tif (index != targetChannelIndex) {\n-\t\t\t\t\taddBufferConsumer(bufferBuilder.createBufferConsumer(), index);", "originalCommit": "b748b70721ad822f8484a86abc4ddc32bae6e2cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MDExOA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r434550118", "bodyText": "Uhhh. This is a nice spaghetti (the way how randomTriggeredConsumer is being set and used here).\nI don't know, but maybe we should re-think the inheritance and code deduplication between BroadcastRecordWriter and RecordWriter? Maybe we should drop this connection and live with code duplication? Or maybe there is some better way? Like extract some class and switch to composition?\nIf you and @curcur are fine with the current fix, I would be fine with doing the refactor/rethinking it outside of this bug fix.", "author": "pnowojski", "createdAt": "2020-06-03T13:04:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/writer/BroadcastRecordWriter.java", "diffHunk": "@@ -84,7 +86,7 @@ void randomEmit(T record, int targetChannelIndex) throws IOException, Interrupte\n \t\tif (bufferBuilder != null) {\n \t\t\tfor (int index = 0; index < numberOfChannels; index++) {\n \t\t\t\tif (index != targetChannelIndex) {\n-\t\t\t\t\taddBufferConsumer(bufferBuilder.createBufferConsumer(), index);\n+\t\t\t\t\taddBufferConsumer(randomTriggeredConsumer.copyAndSync(bufferBuilder), index);", "originalCommit": "b748b70721ad822f8484a86abc4ddc32bae6e2cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2OTIxOQ==", "url": "https://github.com/apache/flink/pull/12353#discussion_r435869219", "bodyText": "I agree, but without the refactoring, I don't think we can avoid spaghetti.\nI'd suggest to do a refactoring as a separate task.", "author": "AHeise", "createdAt": "2020-06-05T11:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MDExOA=="}], "type": "inlineReview"}, {"oid": "20e850ec68b8e70c8e8e88a477e660a7a9ec0585", "url": "https://github.com/apache/flink/commit/20e850ec68b8e70c8e8e88a477e660a7a9ec0585", "message": "[FLINK-17322][network] Fixes BroadcastRecordWriter overwriting memory segments on first finished BufferConsumer.\n\nBroadcastRecordWriter#randomEmit initialized buffer consumers for other non-target channels incorrectly leading to separate buffer reference counting and subsequently released buffers too early.\nThis commit uses the new BufferConsumer#copyAndSync method to copy the buffer while updating the read index to the last committed write index of the builder.", "committedDate": "2020-06-05T11:46:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyNTE0NA==", "url": "https://github.com/apache/flink/pull/12353#discussion_r439225144", "bodyText": "How about renaming it as copyWithReaderPosition(int readerPosition)? The semantic of this method is for copying the current consumer with setting any reader position which is not only limited to builder.getCommittedBytes(), and then we can pass the builder.getCommittedBytes() from the caller by different usages.\nAnother consideration is that only build creates the respective consumer in single direction, so consumer will not see the builder before. copyWithReaderPosition(int readerPosition) can avoid touching builder somehow from public way.", "author": "zhijiangW", "createdAt": "2020-06-12T06:10:40Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/buffer/BufferConsumer.java", "diffHunk": "@@ -118,6 +118,16 @@ public BufferConsumer copy() {\n \t\treturn new BufferConsumer(buffer.retainBuffer(), writerPosition.positionMarker, currentReaderPosition);\n \t}\n \n+\t/**\n+\t * Returns a retained copy with separate indexes and syncs it with the current position of the given {@link BufferBuilder}.\n+\t * This allows to read from the same {@link MemorySegment} twice starting from the position of the builder.\n+\t *\n+\t * @return a retained copy of self with separate indexes\n+\t */\n+\tpublic BufferConsumer copyAndSync(BufferBuilder builder) {", "originalCommit": "20e850ec68b8e70c8e8e88a477e660a7a9ec0585", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NDE3Ng==", "url": "https://github.com/apache/flink/pull/12353#discussion_r439244176", "bodyText": "I like it as it gives more flexibility, I just need to make the writer position publicly available, but imho that is a good change anyway (needed that we debugging in various places).", "author": "AHeise", "createdAt": "2020-06-12T07:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIyNTE0NA=="}], "type": "inlineReview"}, {"oid": "1be27d2d61ae143a25a7beece7af333c520e02f4", "url": "https://github.com/apache/flink/commit/1be27d2d61ae143a25a7beece7af333c520e02f4", "message": "[FLINK-17322][network] Disallowing repeated consumer creation for BufferBuilder.\n\nThis is a partial revert of FLINK-10995.", "committedDate": "2020-06-12T08:07:28Z", "type": "forcePushed"}, {"oid": "cd85d830cd315f6b44f0e2188175b3d0d2aedbf9", "url": "https://github.com/apache/flink/commit/cd85d830cd315f6b44f0e2188175b3d0d2aedbf9", "message": "[FLINK-17322][network] Disallowing repeated consumer creation for BufferBuilder.\n\nThis is a partial revert of FLINK-10995.", "committedDate": "2020-06-12T09:56:44Z", "type": "forcePushed"}, {"oid": "2e6c27f743494ba1483195132cf622abcde78332", "url": "https://github.com/apache/flink/commit/2e6c27f743494ba1483195132cf622abcde78332", "message": "[FLINK-17322][network] Fixes BroadcastRecordWriter overwriting memory segments on first finished BufferConsumer.\n\nBroadcastRecordWriter#randomEmit initialized buffer consumers for other non-target channels incorrectly leading to separate buffer reference counting and subsequently released buffers too early.\nThis commit uses the new BufferConsumer#copyWithReaderPosition method to copy the buffer while updating the read index to the last committed write index of the builder.", "committedDate": "2020-06-12T09:59:05Z", "type": "commit"}, {"oid": "1d481800964ccfc9c9077a27c64182394b1b6df1", "url": "https://github.com/apache/flink/commit/1d481800964ccfc9c9077a27c64182394b1b6df1", "message": "[FLINK-17322][network] Disallowing repeated consumer creation for BufferBuilder.\n\nThis is a partial revert of FLINK-10995.", "committedDate": "2020-06-12T09:59:05Z", "type": "commit"}, {"oid": "1d481800964ccfc9c9077a27c64182394b1b6df1", "url": "https://github.com/apache/flink/commit/1d481800964ccfc9c9077a27c64182394b1b6df1", "message": "[FLINK-17322][network] Disallowing repeated consumer creation for BufferBuilder.\n\nThis is a partial revert of FLINK-10995.", "committedDate": "2020-06-12T09:59:05Z", "type": "forcePushed"}]}