{"pr_number": 13508, "pr_title": "[FLINK-19308][coordination] Add SlotTracker ", "pr_createdAt": "2020-09-29T12:30:40Z", "pr_url": "https://github.com/apache/flink/pull/13508", "timeline": [{"oid": "2d93fb45481027c3b686353ee315d7d2e5687666", "url": "https://github.com/apache/flink/commit/2d93fb45481027c3b686353ee315d7d2e5687666", "message": "[FLINK-19308][coordination] (Slot)State as top-level class", "committedDate": "2020-09-29T10:05:25Z", "type": "commit"}, {"oid": "200ab7a50f03dec0fe7bdbe2ca8e358ac59c5494", "url": "https://github.com/apache/flink/commit/200ab7a50f03dec0fe7bdbe2ca8e358ac59c5494", "message": "[FLINK-19308][coordination] Add default TMSlotInformation#isMatchingRequirement", "committedDate": "2020-09-29T10:05:25Z", "type": "commit"}, {"oid": "0118a55e59ad2362af363ee9dd0132d6bbcb6fd8", "url": "https://github.com/apache/flink/commit/0118a55e59ad2362af363ee9dd0132d6bbcb6fd8", "message": "[FLINK-19308][coordination] Add TEConnection to TMSlotInformation", "committedDate": "2020-09-29T10:05:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY5NDgwOQ==", "url": "https://github.com/apache/flink/pull/13508#discussion_r498694809", "bodyText": "it would be a lot nicer for testing if listeners could be registered after the tracker was created; it would make it easier to inject a custom tracker into the slot manager.", "author": "zentol", "createdAt": "2020-10-02T08:49:07Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Default SlotTracker implementation.\n+ */\n+class DefaultSlotTracker implements SlotTracker {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultSlotTracker.class);\n+\n+\t/**\n+\t * Map for all registered slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> slots = new HashMap<>();\n+\n+\t/**\n+\t * Index of all currently free slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> freeSlots = new LinkedHashMap<>();\n+\n+\tprivate final SlotStatusUpdateListener slotStatusUpdateListener;\n+\n+\tprivate final SlotStatusStateReconciler slotStatusStateReconciler = new SlotStatusStateReconciler(this::transitionSlotToFree, this::transitionSlotToPending, this::transitionSlotToAllocated);\n+\n+\tpublic DefaultSlotTracker(SlotStatusUpdateListener slotStatusUpdateListener) {", "originalCommit": "7e7e625020d95393f6ba8473cf40ba6773fc08e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4Nzk0NA==", "url": "https://github.com/apache/flink/pull/13508#discussion_r499587944", "bodyText": "Is it because now we need to introduce a factory to introduce a custom tracker into the SlotManager?", "author": "tillrohrmann", "createdAt": "2020-10-05T13:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY5NDgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA4NTU0Mg==", "url": "https://github.com/apache/flink/pull/13508#discussion_r500085542", "bodyText": "yes, and the tracker returned by the factory must accept the listener passed by the slot manager. So you have to instantiate the tracker instance within the factory; you can't create it upfront, and if you want to access it later one you must use an AtomicReference or such.\n(And you can't just ignore the listener because it is tying multiple components in the slot manager together (which is kinda bad, but I did not see another way))", "author": "zentol", "createdAt": "2020-10-06T08:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY5NDgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NzQxMw==", "url": "https://github.com/apache/flink/pull/13508#discussion_r499577413", "bodyText": "Does it make a difference whether slotStatusUpdateListener.notifySlotStatusChange is called before effectuating the state change on slot? I am asking because transitionSlotToPending and transitionSlotToFree do it in the different order.", "author": "tillrohrmann", "createdAt": "2020-10-05T12:56:51Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTracker.java", "diffHunk": "@@ -0,0 +1,251 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Default SlotTracker implementation.\n+ */\n+class DefaultSlotTracker implements SlotTracker {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultSlotTracker.class);\n+\n+\t/**\n+\t * Map for all registered slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> slots = new HashMap<>();\n+\n+\t/**\n+\t * Index of all currently free slots.\n+\t */\n+\tprivate final Map<SlotID, DeclarativeTaskManagerSlot> freeSlots = new LinkedHashMap<>();\n+\n+\tprivate final SlotStatusUpdateListener slotStatusUpdateListener;\n+\n+\tprivate final SlotStatusStateReconciler slotStatusStateReconciler = new SlotStatusStateReconciler(this::transitionSlotToFree, this::transitionSlotToPending, this::transitionSlotToAllocated);\n+\n+\tpublic DefaultSlotTracker(SlotStatusUpdateListener slotStatusUpdateListener) {\n+\t\tthis.slotStatusUpdateListener = Preconditions.checkNotNull(slotStatusUpdateListener);\n+\t}\n+\n+\t@Override\n+\tpublic void addSlot(\n+\t\tSlotID slotId,\n+\t\tResourceProfile resourceProfile,\n+\t\tTaskExecutorConnection taskManagerConnection,\n+\t\t@Nullable JobID assignedJob) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\tPreconditions.checkNotNull(resourceProfile);\n+\t\tPreconditions.checkNotNull(taskManagerConnection);\n+\n+\t\tif (slots.containsKey(slotId)) {\n+\t\t\t// remove the old slot first\n+\t\t\tLOG.debug(\"A slot was added with an already tracked slot ID {}. Removing previous entry.\", slotId);\n+\t\t\tremoveSlot(slotId);\n+\t\t}\n+\n+\t\tDeclarativeTaskManagerSlot slot = new DeclarativeTaskManagerSlot(slotId, resourceProfile, taskManagerConnection);\n+\t\tslots.put(slotId, slot);\n+\t\tfreeSlots.put(slotId, slot);\n+\t\tslotStatusStateReconciler.executeStateTransition(slot, assignedJob);\n+\t}\n+\n+\t@Override\n+\tpublic void removeSlots(Iterable<SlotID> slotsToRemove) {\n+\t\tPreconditions.checkNotNull(slotsToRemove);\n+\n+\t\tfor (SlotID slotId : slotsToRemove) {\n+\t\t\tremoveSlot(slotId);\n+\t\t}\n+\t}\n+\n+\tprivate void removeSlot(SlotID slotId) {\n+\t\tDeclarativeTaskManagerSlot slot = slots.remove(slotId);\n+\n+\t\tif (slot != null) {\n+\t\t\tif (slot.getState() != SlotState.FREE) {\n+\t\t\t\ttransitionSlotToFree(slot);\n+\t\t\t}\n+\t\t\tfreeSlots.remove(slotId);\n+\t\t} else {\n+\t\t\tLOG.debug(\"There was no slot registered with slot id {}.\", slotId);\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// ResourceManager slot status API - optimistically trigger transitions, but they may not represent true state on task executors\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void notifyFree(SlotID slotId) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\ttransitionSlotToFree(slots.get(slotId));\n+\t}\n+\n+\t@Override\n+\tpublic void notifyAllocationStart(SlotID slotId, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\ttransitionSlotToPending(slots.get(slotId), jobId);\n+\t}\n+\n+\t@Override\n+\tpublic void notifyAllocationComplete(SlotID slotId, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slotId);\n+\t\tPreconditions.checkNotNull(jobId);\n+\t\ttransitionSlotToAllocated(slots.get(slotId), jobId);\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// TaskExecutor slot status API - acts as source of truth\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\t@Override\n+\tpublic void notifySlotStatus(Iterable<SlotStatus> slotStatuses) {\n+\t\tPreconditions.checkNotNull(slotStatuses);\n+\t\tfor (SlotStatus slotStatus : slotStatuses) {\n+\t\t\tslotStatusStateReconciler.executeStateTransition(slots.get(slotStatus.getSlotID()), slotStatus.getJobID());\n+\t\t}\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// Core state transitions\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tprivate void transitionSlotToFree(DeclarativeTaskManagerSlot slot) {\n+\t\tPreconditions.checkNotNull(slot);\n+\t\tPreconditions.checkState(slot.getState() != SlotState.FREE);\n+\n+\t\t// remember the slots current job and state for the notification, as this information will be cleared from\n+\t\t// the slot upon freeing\n+\t\tfinal JobID jobId = slot.getJobId();\n+\t\tfinal SlotState state = slot.getState();\n+\n+\t\tslot.freeSlot();\n+\t\tfreeSlots.put(slot.getSlotId(), slot);\n+\t\tslotStatusUpdateListener.notifySlotStatusChange(slot, state, SlotState.FREE, jobId);\n+\t}\n+\n+\tprivate void transitionSlotToPending(DeclarativeTaskManagerSlot slot, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slot);\n+\t\tPreconditions.checkState(slot.getState() == SlotState.FREE);\n+\n+\t\tslot.startAllocation(jobId);\n+\t\tfreeSlots.remove(slot.getSlotId());\n+\t\tslotStatusUpdateListener.notifySlotStatusChange(slot, SlotState.FREE, SlotState.PENDING, jobId);\n+\t}\n+\n+\tprivate void transitionSlotToAllocated(DeclarativeTaskManagerSlot slot, JobID jobId) {\n+\t\tPreconditions.checkNotNull(slot);\n+\t\tPreconditions.checkState(slot.getState() == SlotState.PENDING);\n+\t\tPreconditions.checkState(jobId.equals(slot.getJobId()));\n+\n+\t\tslotStatusUpdateListener.notifySlotStatusChange(slot, SlotState.PENDING, SlotState.ALLOCATED, jobId);\n+\t\tslot.completeAllocation();", "originalCommit": "bc7dd7cf9f5876dbd7b99b9f1860647448418577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA4NzI3NA==", "url": "https://github.com/apache/flink/pull/13508#discussion_r500087274", "bodyText": "the notification should always be fired after the state transition to ensure that any component reacting to it, e.g., by querying the tracker, is in a consistent state with the tracker.\nIn an earlier version the notification was sent before the update for convenience (don't have to remember stuff in transition to free).", "author": "zentol", "createdAt": "2020-10-06T08:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NzQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDExODI2OQ==", "url": "https://github.com/apache/flink/pull/13508#discussion_r500118269", "bodyText": "(although it's not as important when going from PENDING to ALLOCATED because nothing in the API exposes this distinction)", "author": "zentol", "createdAt": "2020-10-06T09:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3NzQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3OTQ4NQ==", "url": "https://github.com/apache/flink/pull/13508#discussion_r499579485", "bodyText": "maybe spell out what the initial behaviour is. For someone not having written this code, this might not be obvious.", "author": "tillrohrmann", "createdAt": "2020-10-05T12:59:52Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTrackerTest.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Queue;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DefaultSlotTracker}.\n+ */\n+public class DefaultSlotTrackerTest extends TestLogger {\n+\n+\tprivate static final TaskExecutorConnection TASK_EXECUTOR_CONNECTION = new TaskExecutorConnection(\n+\t\tResourceID.generate(),\n+\t\tnew TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway());\n+\n+\tprivate static final JobID jobId = new JobID();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {", "originalCommit": "bc7dd7cf9f5876dbd7b99b9f1860647448418577", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MzE3Mg==", "url": "https://github.com/apache/flink/pull/13508#discussion_r499583172", "bodyText": "I think I would split these blocks into separate test methods.", "author": "tillrohrmann", "createdAt": "2020-10-05T13:05:47Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/DefaultSlotTrackerTest.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.Test;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Queue;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.collection.IsEmptyCollection.empty;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Tests for the {@link DefaultSlotTracker}.\n+ */\n+public class DefaultSlotTrackerTest extends TestLogger {\n+\n+\tprivate static final TaskExecutorConnection TASK_EXECUTOR_CONNECTION = new TaskExecutorConnection(\n+\t\tResourceID.generate(),\n+\t\tnew TestingTaskExecutorGatewayBuilder().createTestingTaskExecutorGateway());\n+\n+\tprivate static final JobID jobId = new JobID();\n+\n+\t@Test\n+\tpublic void testInitialBehavior() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t}\n+\n+\t@Test\n+\tpublic void testSlotAddition() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\n+\t\tSlotID slotId1 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\t\tSlotID slotId2 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 1);\n+\n+\t\ttracker.addSlot(slotId1, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId2, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\tassertThat(tracker.getFreeSlots(), containsInAnyOrder(Arrays.asList(infoWithSlotId(slotId1), infoWithSlotId(slotId2))));\n+\t}\n+\n+\t@Test\n+\tpublic void testSlotRemoval() {\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\t\tDefaultSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) ->\n+\t\t\tstateTransitions.add(new SlotStateTransition(slot.getSlotId(), previous, current, jobId)));\n+\n+\t\tSlotID slotId1 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\t\tSlotID slotId2 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 1);\n+\t\tSlotID slotId3 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 2);\n+\n+\t\ttracker.addSlot(slotId1, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId2, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId3, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId2, jobId);\n+\t\ttracker.notifyAllocationStart(slotId3, jobId);\n+\t\ttracker.notifyAllocationComplete(slotId3, jobId);\n+\n+\t\t// the transitions to this point are not relevant for this test\n+\t\tstateTransitions.clear();\n+\t\t// we now have 1 slot in each slot state (free, pending, allocated)\n+\t\t// it should be possible to remove slots regardless of their state\n+\t\ttracker.removeSlots(Arrays.asList(slotId1, slotId2, slotId3));\n+\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(tracker.areMapsEmpty(), is(true));\n+\n+\t\tassertThat(stateTransitions, containsInAnyOrder(\n+\t\t\tnew SlotStateTransition(slotId2, SlotState.PENDING, SlotState.FREE, jobId),\n+\t\t\tnew SlotStateTransition(slotId3, SlotState.ALLOCATED, SlotState.FREE, jobId)\n+\t\t));\n+\t}\n+\n+\t@Test\n+\tpublic void testAllocationCompletion() {\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) ->\n+\t\t\tstateTransitions.add(new SlotStateTransition(slot.getSlotId(), previous, current, jobId)));\n+\n+\t\tSlotID slotId = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\n+\t\ttracker.addSlot(slotId, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId, jobId);\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.FREE, SlotState.PENDING, jobId)));\n+\n+\t\ttracker.notifyAllocationComplete(slotId, jobId);\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.PENDING, SlotState.ALLOCATED, jobId)));\n+\n+\t\ttracker.notifyFree(slotId);\n+\n+\t\tassertThat(tracker.getFreeSlots(), contains(infoWithSlotId(slotId)));\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.ALLOCATED, SlotState.FREE, jobId)));\n+\t}\n+\n+\t@Test\n+\tpublic void testAllocationCompletionForDifferentJobThrowsIllegalStateException() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\n+\t\tSlotID slotId = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\n+\t\ttracker.addSlot(slotId, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId, new JobID());\n+\t\ttry {\n+\t\t\ttracker.notifyAllocationComplete(slotId, new JobID());\n+\t\t\tfail(\"Allocations must not be completed for a different job ID.\");\n+\t\t} catch (IllegalStateException expected) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testAllocationCancellation() {\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) ->\n+\t\t\tstateTransitions.add(new SlotStateTransition(slot.getSlotId(), previous, current, jobId)));\n+\n+\t\tSlotID slotId = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\n+\t\ttracker.addSlot(slotId, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\n+\t\ttracker.notifyAllocationStart(slotId, jobId);\n+\t\tassertThat(tracker.getFreeSlots(), empty());\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.FREE, SlotState.PENDING, jobId)));\n+\n+\t\ttracker.notifyFree(slotId);\n+\t\tassertThat(tracker.getFreeSlots(), contains(infoWithSlotId(slotId)));\n+\t\tassertThat(stateTransitions.remove(), is(new SlotStateTransition(slotId, SlotState.PENDING, SlotState.FREE, jobId)));\n+\t}\n+\n+\t@Test\n+\tpublic void testSlotStatusProcessing() {\n+\t\tSlotTracker tracker = new DefaultSlotTracker((slot, previous, current, jobId) -> {});\n+\t\tSlotID slotId1 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 0);\n+\t\tSlotID slotId2 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 1);\n+\t\tSlotID slotId3 = new SlotID(TASK_EXECUTOR_CONNECTION.getResourceID(), 2);\n+\t\ttracker.addSlot(slotId1, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId2, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, null);\n+\t\ttracker.addSlot(slotId3, ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION, jobId);\n+\n+\t\tassertThat(tracker.getFreeSlots(), containsInAnyOrder(Arrays.asList(infoWithSlotId(slotId1), infoWithSlotId(slotId2))));\n+\n+\t\t// move slot2 to PENDING\n+\t\ttracker.notifyAllocationStart(slotId2, jobId);\n+\n+\t\ttracker.notifySlotStatus(Arrays.asList(\n+\t\t\tnew SlotStatus(slotId1, ResourceProfile.ANY, jobId, new AllocationID()),\n+\t\t\tnew SlotStatus(slotId2, ResourceProfile.ANY, null, new AllocationID()),\n+\t\t\tnew SlotStatus(slotId3, ResourceProfile.ANY, null, new AllocationID())));\n+\n+\t\t// slot1 should now be allocated; slot2 should continue to be in a pending state; slot3 should be freed\n+\t\tassertThat(tracker.getFreeSlots(), contains(infoWithSlotId(slotId3)));\n+\n+\t\t// if slot2 is not in a pending state, this will fail with an exception\n+\t\ttracker.notifyAllocationComplete(slotId2, jobId);\n+\t}\n+\n+\t/**\n+\t * Tests all state transitions that could (or should not) occur due to a slot status update. This test only checks\n+\t * the target state and job ID for state transitions, because the slot ID is not interesting and the slot state\n+\t * is not *actually* being updated. We assume the reconciler locks in a set of transitions given a source and target\n+\t * state, without worrying about the correctness of intermediate steps (because it shouldn't; and it would be a bit\n+\t * annoying to setup).\n+\t */\n+\t@Test\n+\tpublic void testSlotStatusReconciliation() {\n+\t\tJobID jobId1 = new JobID();\n+\t\tJobID jobId2 = new JobID();\n+\n+\t\tQueue<SlotStateTransition> stateTransitions = new ArrayDeque<>();\n+\n+\t\tDefaultSlotTracker.SlotStatusStateReconciler reconciler = new DefaultSlotTracker.SlotStatusStateReconciler(\n+\t\t\tslot -> stateTransitions.add(new SlotStateTransition(slot.getSlotId(), slot.getState(), SlotState.FREE, slot.getJobId())),\n+\t\t\t(slot, jobID) -> stateTransitions.add(new SlotStateTransition(slot.getSlotId(), slot.getState(), SlotState.PENDING, jobID)),\n+\t\t\t(slot, jobID) -> stateTransitions.add(new SlotStateTransition(slot.getSlotId(), slot.getState(), SlotState.ALLOCATED, jobID)));\n+\n+\t\t{// free slot\n+\t\t\tDeclarativeTaskManagerSlot slot = new DeclarativeTaskManagerSlot(new SlotID(ResourceID.generate(), 0), ResourceProfile.ANY, TASK_EXECUTOR_CONNECTION);\n+\n+\t\t\treconciler.executeStateTransition(slot, null);\n+\t\t\tassertThat(stateTransitions, empty());\n+\n+\t\t\treconciler.executeStateTransition(slot, jobId1);\n+\t\t\tassertThat(stateTransitions.remove(), is(transitionWithTargetStateForJob(SlotState.PENDING, jobId1)));\n+\t\t\tassertThat(stateTransitions.remove(), is(transitionWithTargetStateForJob(SlotState.ALLOCATED, jobId1)));\n+\t\t}", "originalCommit": "bc7dd7cf9f5876dbd7b99b9f1860647448418577", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NjM1MA==", "url": "https://github.com/apache/flink/pull/13508#discussion_r499586350", "bodyText": "Do we know why this test is untable?", "author": "tillrohrmann", "createdAt": "2020-10-05T13:11:04Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/dispatcher/DispatcherResourceCleanupTest.java", "diffHunk": "@@ -343,6 +344,7 @@ public void testRunningJobsRegistryCleanup() throws Exception {\n \t * before a new job with the same {@link JobID} is started.\n \t */\n \t@Test\n+\t@Ignore", "originalCommit": "7e7e625020d95393f6ba8473cf40ba6773fc08e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDA4NzczNA==", "url": "https://github.com/apache/flink/pull/13508#discussion_r500087734", "bodyText": "FLINK-19344", "author": "zentol", "createdAt": "2020-10-06T08:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NjM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI4NTc4Ng==", "url": "https://github.com/apache/flink/pull/13508#discussion_r500285786", "bodyText": "Thanks for the pointer.", "author": "tillrohrmann", "createdAt": "2020-10-06T13:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4NjM1MA=="}], "type": "inlineReview"}, {"oid": "ad2d4b6441c8842a107b71782cb7bee18b583942", "url": "https://github.com/apache/flink/commit/ad2d4b6441c8842a107b71782cb7bee18b583942", "message": "[FLINK-19308][coordination] Add SlotTracker", "committedDate": "2020-10-06T14:15:04Z", "type": "commit"}, {"oid": "ad2d4b6441c8842a107b71782cb7bee18b583942", "url": "https://github.com/apache/flink/commit/ad2d4b6441c8842a107b71782cb7bee18b583942", "message": "[FLINK-19308][coordination] Add SlotTracker", "committedDate": "2020-10-06T14:15:04Z", "type": "forcePushed"}]}