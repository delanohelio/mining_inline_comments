{"pr_number": 11687, "pr_title": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint", "pr_createdAt": "2020-04-09T09:48:08Z", "pr_url": "https://github.com/apache/flink/pull/11687", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMTExMg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r406231112", "bodyText": "Could those changes about dropping int subpartitionIndex be a separate commit?", "author": "pnowojski", "createdAt": "2020-04-09T14:08:18Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -95,7 +95,7 @@ public LocalInputChannel(\n \t// ------------------------------------------------------------------------\n \n \t@Override\n-\tprotected void requestSubpartition(int subpartitionIndex) throws IOException, InterruptedException {\n+\tprotected void requestSubpartition() throws IOException, InterruptedException {", "originalCommit": "c8c0da9e2badf68c11e8466943c7a8e14156c858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyNDUzNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r407224535", "bodyText": "I actually considered whether to extract it as a separate commit or not when implementation. I think both ways can be interpreted from different motivations.\n\n\nIf making it as a separate hotfix or refactor commit, we only save one argument from this interface method and fetch it from SingleInputGate instead. Then the benefit seems not very obvious if without the following input recovery change.\n\n\nIf making it along with the input recovery changes, the motivation seems a must-work to do. Since we migrate the actual usage of this argument outside of this method, then this argument should also be cleaned up as a result.\n\n\nTherefore I preferred a bit not to make it a separate commit before. It is fine for my either ways actually. If you are in favor of separate commit, i am willing to change it.", "author": "zhijiangW", "createdAt": "2020-04-12T16:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzMzc3NQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408333775", "bodyText": "It made the final commit a bit smaller, so I think it was worth it (to speed up reviewing). As hotfix on it's own it's also a nice simplification I think.", "author": "pnowojski", "createdAt": "2020-04-14T18:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MjY2MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r406292661", "bodyText": "notifyStateBuffersAvailable()? notifyBuffersForReadChannelStateAvailable?", "author": "pnowojski", "createdAt": "2020-04-09T15:34:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -311,10 +367,16 @@ public void recycle(MemorySegment segment) {\n \t\t\t\t\tExceptionUtils.rethrow(t);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\tshouldNotifyChannelState = isWaitingForStateBuffers;\n+\t\t\tisWaitingForStateBuffers = false;\n+\n \t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n \t\t}\n \n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n+\t\tif (shouldNotifyChannelState) {\n+\t\t\tnotifyReadChannelState();", "originalCommit": "c8c0da9e2badf68c11e8466943c7a8e14156c858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyMjk3OQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r407222979", "bodyText": "I like notifyStateBuffersAvailable", "author": "zhijiangW", "createdAt": "2020-04-12T16:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MjY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNTAzOQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r406825039", "bodyText": "stateReader.readInputData is not thread safe as it is currently and this readInputChannelState method can be executed by netty threads concurrently for different channels, right?", "author": "pnowojski", "createdAt": "2020-04-10T16:05:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -149,16 +154,58 @@ void assignExclusiveSegments() throws IOException {\n \t\t}\n \t}\n \n+\t/**\n+\t * Reads the channel state data executed by netty thread, so it can make use of almost all the\n+\t * existing processes to avoid bringing additional race conditions with task thread. Also it can\n+\t * avoid introducing another thread pool to handle this work to make things more complex.\n+\t */\n+\tprivate void readInputChannelState() throws IOException {\n+\t\twhile (true) {\n+\t\t\tBuffer buffer;\n+\t\t\tsynchronized (bufferQueue) {\n+\t\t\t\tbuffer = bufferQueue.takeBuffer();\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tif (isReleased()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tbuffer = inputGate.getBufferPool().requestBuffer();\n+\t\t\t\t\tif (buffer != null) {\n+\t\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tinputGate.getBufferProvider().addBufferListener(this);\n+\t\t\t\t\t\tisWaitingForStateBuffers = true;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tChannelStateReader.ReadResult result = inputGate.stateReader.readInputData(channelInfo, buffer);", "originalCommit": "c8c0da9e2badf68c11e8466943c7a8e14156c858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIyMjg5Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r407222896", "bodyText": "Yes, readInputChannelState can be executed concurrently by multiple netty threads for different channels by design. I think in general task processing should be more faster than reading states, so one thread might not be enough for filling buffer to feed task thread well. And every channel actually has exclusive buffers which can be used in parallel to speed up recovery process.\nI overlooked the NotThreadSafe annotation in ChanelStateReaderImpl.  Since every input channel handle will actually generate a separate ChannelStateStreamReader and respective stream, I was supposed one input channel state should not be read by multiple threads, but different channel states can be read by different threads concurrent. I would further confirm with Roman whether there are other limitations.", "author": "zhijiangW", "createdAt": "2020-04-12T16:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNTAzOQ=="}], "type": "inlineReview"}, {"oid": "7b32c0f208a47925d94e290a91132ec15590236e", "url": "https://github.com/apache/flink/commit/7b32c0f208a47925d94e290a91132ec15590236e", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-14T15:50:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzNjkxOA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408336918", "bodyText": "Could it be that we start reading from a channel before we actually request subpartition? For example:\nOptional<BufferAndAvailability> RemoteInputChannel#getNextBuffer() throws IOException {\n\t(...)\n\tcheckState(partitionRequestClient != null, \"Queried for a buffer before requesting a queue.\"); // ??\n\nor what if partitionRequestClient is already not null, but\npartitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, this, 0);\n\nhasn't completed?", "author": "pnowojski", "createdAt": "2020-04-14T18:10:39Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -243,7 +249,23 @@ void requestPartitions() throws IOException, InterruptedException {\n \t\t\t\t}\n \n \t\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n-\t\t\t\t\tinputChannel.requestSubpartition();\n+\t\t\t\t\texecutor.submit(() -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tinputChannel.initializeState(reader);\n+\t\t\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\t\t\tinputChannel.setError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\n+\t\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n+\t\t\t\t\texecutor.submit(() -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tinputChannel.requestSubpartition();", "originalCommit": "7b32c0f208a47925d94e290a91132ec15590236e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU2OTI3Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408569272", "bodyText": "Yes, it has another issue here.  In order to compatible with previous process, we can divide the previous requestSubpartition into two steps. The first step is to create client which can be done during InputGate#setup as before. The second step is to actual request partition which is triggered after reading channel state as done in this PR change.\nTo do so, this check is still valid, but I guess it is still breaking the previous assumption which actually wants to guarantee the partition is really requested before calling getNextBuffer. But now the existing client does not mean the partition was requested already. So another option might remove this checkState.", "author": "zhijiangW", "createdAt": "2020-04-15T04:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzNjkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MDg3Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r410380876", "bodyText": "I currently remove this checkState in PR for simple. If you have other thoughts, then we can further sync afterwards.", "author": "zhijiangW", "createdAt": "2020-04-17T17:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzNjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzODc2OQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408338769", "bodyText": "I would move the for loop inside the executor, to avoid race conditions and not depend on executor being single threaded.", "author": "pnowojski", "createdAt": "2020-04-14T18:13:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -243,7 +249,23 @@ void requestPartitions() throws IOException, InterruptedException {\n \t\t\t\t}\n \n \t\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n-\t\t\t\t\tinputChannel.requestSubpartition();\n+\t\t\t\t\texecutor.submit(() -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tinputChannel.initializeState(reader);\n+\t\t\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\t\t\tinputChannel.setError(t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});", "originalCommit": "7b32c0f208a47925d94e290a91132ec15590236e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU2OTQ0Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408569446", "bodyText": "good point", "author": "zhijiangW", "createdAt": "2020-04-15T04:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzODc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDI3Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408340272", "bodyText": "Is someone notifing this thread to wake up? Can not we wait on the buffer in another way?", "author": "pnowojski", "createdAt": "2020-04-14T18:16:32Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -149,6 +149,47 @@ void assignExclusiveSegments() throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void initializeState(ChannelStateReader reader) throws IOException, InterruptedException {\n+\t\tnumRequiredBuffers = initialCredit + inputGate.getBufferPool().getMaxNumberOfMemorySegments();\n+\t\tunannouncedCredit.set(initialCredit);\n+\n+\t\twhile (true) {\n+\t\t\tBuffer buffer;\n+\t\t\tsynchronized (bufferQueue) {\n+\t\t\t\tbuffer = bufferQueue.takeBuffer();\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tif (isReleased()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (!isWaitingForFloatingBuffers) {\n+\t\t\t\t\t\tbuffer = inputGate.getBufferPool().requestBuffer();\n+\t\t\t\t\t\tif (buffer == null) {\n+\t\t\t\t\t\t\tinputGate.getBufferProvider().addBufferListener(this);\n+\t\t\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (buffer == null) {\n+\t\t\t\twait(10);", "originalCommit": "7b32c0f208a47925d94e290a91132ec15590236e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3NDI5Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408574292", "bodyText": "TBH the current wait way is also not in my favor as I mentioned as unsatisfied points, because how long time to wait might be an issue.\nI also considered other ways, but the key problem is that we can not exit this runnable to let the thread execute other runables in advance, so it seems somehow as blocking way here. In contrast, the previous floating request from netty thread was non-blocking way, so we do not need the mechanism of notifyAll  inside RemoteInputChannel#recycle and RemoteInputChannel#notifyBufferAvailable.\nMaybe it is possible to add notifyAll in above two methods for compatible with the new process. WDYT?", "author": "zhijiangW", "createdAt": "2020-04-15T04:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyODkzMQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408728931", "bodyText": "Ok I see. We can not block the shared executor for unspecified long time. This method would have to be rewritten in a such way, that once buffers are not available, it exits, and re-enqueuing action is done once more buffers are ready.\nIf we spawned our custom thread for unspilling, we could block it however we want, but in that case we would also need a mechanism to wake it up once more buffers are ready, instead of sleeping for fixed amount of time.\nedit: I guess we would have exactly the same issues with a separate unspilling component like SpilledInputChannel or SpilledInputGate?", "author": "pnowojski", "createdAt": "2020-04-15T10:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI4MzUyMA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r409283520", "bodyText": "Yes, we have the same issue in another option of SpilledInputChannel/SpilledInputGate.\nIn conclusion, there may be several solutions:\n\n\nwait() if unavailable buffers: block the unspilling thread always and it fits our current requirements. We should not exit current channel to switch another channel temporarily, which might bring random IO. And it requires the wakeup mechanism when buffer available again.\n\n\nwait(timeout) if unavailable buffers: more or less the same with above wait(), but wakeup mechanism is not a mandatory, can be regarded as  somehow improvement to wakeup eerily.\n\n\nunblocking way: terminate the current channel and unspill another channel with available buffers. It would bring random IO as mentioned above and not the current suggestion.\n\n\nBased on the current situation with custom thread for unspilling, and allow only one thread to unspill channel one by one to avoid random IO, so I choose the unblocking option 1 or 2.\nRegarding the option 2, wakeup is not necessary, then we do not need to touch the previous processes RemoteInputChannel#recycle and RemoteInputChannel#notifyBufferAvailable. If we want to add the wakeup mechanism, option 1 also makes sense.", "author": "zhijiangW", "createdAt": "2020-04-16T05:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxNTAyMQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r409415021", "bodyText": "Oh, I missed that we are already using a separate thread pool. In that case we don't need the not blocking option now.\nIt would be still good to get rid of timed wait in favour of some notifications though.", "author": "pnowojski", "createdAt": "2020-04-16T09:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MDI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MjE1Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408342152", "bodyText": "who is now calling this method in batch tasks?", "author": "pnowojski", "createdAt": "2020-04-14T18:19:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -213,19 +215,23 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {\n \t\tcheckState(this.bufferPool == null, \"Bug in input gate setup logic: Already registered buffer pool.\");\n \t\t// assign exclusive buffers to input channels directly and use the rest for floating buffers\n \t\tassignExclusiveSegments();\n \n \t\tBufferPool bufferPool = bufferPoolFactory.get();\n \t\tsetBufferPool(bufferPool);\n+\t}\n+\n \n-\t\trequestPartitions();", "originalCommit": "7b32c0f208a47925d94e290a91132ec15590236e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3NTU3MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r408575571", "bodyText": "No matter streaming or batch, this method is always called by task thread when the SingleInputGate is created to setup. The only difference between streaming and batch is for RPC call updateInputChannel which is only valid in batch. But for batch we do not support unaligned cp, so the new transformed remote channel from unknown can request partition directly.", "author": "zhijiangW", "createdAt": "2020-04-15T04:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0MjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwMjE5NQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r409402195", "bodyText": "rename channelStateUnspillingExecutor?", "author": "pnowojski", "createdAt": "2020-04-16T09:09:59Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -289,6 +292,8 @@ protected StreamTask(\n \t\t} else {\n \t\t\tthis.timerService = timerService;\n \t\t}\n+\n+\t\tthis.ioExecutor = Executors.newSingleThreadExecutor(new ExecutorThreadFactory(\"state-io\"));", "originalCommit": "7b32c0f208a47925d94e290a91132ec15590236e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwOTM3NA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r409409374", "bodyText": "could we pass the state recovery parameters here? And have a single step setup method instead of introducing 2nd initialisation step (setup and initializeState).", "author": "pnowojski", "createdAt": "2020-04-16T09:21:08Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -213,19 +215,23 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {", "originalCommit": "7b32c0f208a47925d94e290a91132ec15590236e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk5NTEyNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r409995125", "bodyText": "I agree that it has benefits to reduce steps for managing the lifecycle of input gate. But I thought of another potential concern if integrating it within setup.\nThe previous assumption was that the output recovery should execute earlier than the input recovery in order to occupy more floating buffers from global, to get the benefit to speedup recovery process. Now the output recovery is executed by task thread during StreamTask#beforeInvoke. If we integrate the input recovery within setup process, then it would perform before output recovery to occupy more floating buffers in limited buffers environment.\nI also considered integrating the output recovery within ResultPartition#setup, but the output recovery is executed by task thread then it would block the following operations, so I wonder it might also bring potential risks to do so.", "author": "zhijiangW", "createdAt": "2020-04-17T05:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwOTM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDIyNjI1MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r410226251", "bodyText": "The previous assumption was that the output recovery should execute earlier than the input recovery in order to occupy more floating buffers from global, to get the benefit to speedup recovery process. Now the output recovery is executed by task thread during StreamTask#beforeInvoke. If we integrate the input recovery within setup process, then it would perform before output recovery to occupy more floating buffers in limited buffers environment.\n\nOk, I haven't considered that. I guess it's best to keep it as it is?", "author": "pnowojski", "createdAt": "2020-04-17T13:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwOTM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM4MDI4Mw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r410380283", "bodyText": "Yes, I guess so.\nI found another benefit to execute the input state recovery inside StreamTask instead of Task stack(setup integration). The new dedicated executor for unspilling channel state is only meaningful for the unaligned checkpoint mode. So I tried not to create this executor for normal checkpoints, also for batch jobs to reduce total threads in TaskManager. This improvement can only be done inside StreamTask because it can judge the checkpoint mode via StreamConfig. And task class can not get this option because of runtime module can not depend on streaming module.", "author": "zhijiangW", "createdAt": "2020-04-17T17:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQwOTM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxNDExMw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r409414113", "bodyText": "Does it make sense to rename initializeState to readRecoveredState? or processRecoveredState?", "author": "pnowojski", "createdAt": "2020-04-16T09:28:22Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -149,6 +149,47 @@ void assignExclusiveSegments() throws IOException {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void initializeState(ChannelStateReader reader) throws IOException, InterruptedException {", "originalCommit": "7b32c0f208a47925d94e290a91132ec15590236e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c15a33465aff4a5bcbb0b32a75393c19ef3c4e1e", "url": "https://github.com/apache/flink/commit/c15a33465aff4a5bcbb0b32a75393c19ef3c4e1e", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-17T12:34:50Z", "type": "forcePushed"}, {"oid": "c236bcd49d282e8f85ee216eced2436bba5a88bf", "url": "https://github.com/apache/flink/commit/c236bcd49d282e8f85ee216eced2436bba5a88bf", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-17T14:37:28Z", "type": "forcePushed"}, {"oid": "1e4e8a55a86be7b11af2e0e81f36a39e82dbdd7d", "url": "https://github.com/apache/flink/commit/1e4e8a55a86be7b11af2e0e81f36a39e82dbdd7d", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-17T14:43:00Z", "type": "forcePushed"}, {"oid": "56e983f7b2e17e4de99fc1791d1feff500cd0a6d", "url": "https://github.com/apache/flink/commit/56e983f7b2e17e4de99fc1791d1feff500cd0a6d", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-17T14:44:47Z", "type": "forcePushed"}, {"oid": "5bad018f00f85a7359345187a12d7938aa510d25", "url": "https://github.com/apache/flink/commit/5bad018f00f85a7359345187a12d7938aa510d25", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-17T14:46:01Z", "type": "forcePushed"}, {"oid": "371f4a669c47fb1ad3d7f7c643edd71c54405195", "url": "https://github.com/apache/flink/commit/371f4a669c47fb1ad3d7f7c643edd71c54405195", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-17T14:58:14Z", "type": "forcePushed"}, {"oid": "d51ce7f47381d99b843278cd701dcff223761a0b", "url": "https://github.com/apache/flink/commit/d51ce7f47381d99b843278cd701dcff223761a0b", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-17T15:14:59Z", "type": "forcePushed"}, {"oid": "2d03b238ddb9bb7d1b32261d6d61be96983b8fb4", "url": "https://github.com/apache/flink/commit/2d03b238ddb9bb7d1b32261d6d61be96983b8fb4", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-19T16:37:05Z", "type": "forcePushed"}, {"oid": "a18363014fe72d3a0fcc766355639b36f56989b3", "url": "https://github.com/apache/flink/commit/a18363014fe72d3a0fcc766355639b36f56989b3", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-20T03:36:12Z", "type": "forcePushed"}, {"oid": "cba096ae3d8eba4a0d39c64659f76ad10a62be27", "url": "https://github.com/apache/flink/commit/cba096ae3d8eba4a0d39c64659f76ad10a62be27", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-20T04:31:24Z", "type": "forcePushed"}, {"oid": "bec74b31e59e84487c7fc09165aa44e4c39aa927", "url": "https://github.com/apache/flink/commit/bec74b31e59e84487c7fc09165aa44e4c39aa927", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-20T09:29:44Z", "type": "forcePushed"}, {"oid": "054de880d6814fd93c782d199a87490d1440a573", "url": "https://github.com/apache/flink/commit/054de880d6814fd93c782d199a87490d1440a573", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-20T11:28:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNTgxMA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411315810", "bodyText": "Do we want this change here? I would like to avoid introducing many different places that are manually disabling/enabling unaligned checkpoints. Maybe this should be handled generically as part of this ticket https://issues.apache.org/jira/browse/FLINK-17258 ?", "author": "pnowojski", "createdAt": "2020-04-20T11:52:39Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/StreamTaskTest.java", "diffHunk": "@@ -914,7 +914,9 @@ public void testInitializeResultPartitionState() throws Exception {\n \n \t\tMockEnvironment mockEnvironment = new MockEnvironmentBuilder().build();\n \t\tmockEnvironment.addOutputs(Arrays.asList(partitions));\n-\t\tStreamTask task = new MockStreamTaskBuilder(mockEnvironment).build();\n+\t\tStreamConfig config = new StreamConfig(new Configuration());\n+\t\tconfig.setUnalignedCheckpointsEnabled(true);", "originalCommit": "34a60cefb9c81c3220030ddba2ea99722ed6a622", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1MTk4NA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411451984", "bodyText": "The current default value for ExecutionCheckpointingOptions#ENABLE_UNALIGNED is still false. But in StreamTask#beforeInvoke the channel state recovery is only called when enabling unaligned mode. So ATM we still need this explicit setting for making the test through.", "author": "zhijiangW", "createdAt": "2020-04-20T15:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNjUzNw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411316537", "bodyText": "readRecoveredStateAndRequestPartitions?", "author": "pnowojski", "createdAt": "2020-04-20T11:53:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGate.java", "diffHunk": "@@ -131,7 +135,12 @@\n \t/**\n \t * Setup gate, potentially heavy-weight, blocking operation comparing to just creation.\n \t */\n-\tpublic abstract void setup() throws IOException, InterruptedException;\n+\tpublic abstract void setup() throws IOException;\n+\n+\tpublic abstract void initializeStateAndRequestPartitions(", "originalCommit": "054de880d6814fd93c782d199a87490d1440a573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NzA5OA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411467098", "bodyText": "initializeState is for alignment with the other side ResultPartition#initializeState introduced before. I am both fine with either naming.", "author": "zhijiangW", "createdAt": "2020-04-20T15:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNjUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4MTQzNw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411481437", "bodyText": "ok, we can keep it consistent (we could also rename it in the partitions ;) ). initializeState sounds to me more  like we are trying to initialize a state and keep using it later on (like in operators). readState better carries out the intention that the state is only used once.", "author": "pnowojski", "createdAt": "2020-04-20T15:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNjUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4OTQwMA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411489400", "bodyText": "Agree, I already renamed it on input side, and I can also refactor the partition side in a separate hotfix commit.", "author": "zhijiangW", "createdAt": "2020-04-20T15:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTMxNjUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0NTI5MA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411345290", "bodyText": "initializeCreditsForRecoveringState?", "author": "pnowojski", "createdAt": "2020-04-20T12:42:17Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -162,6 +163,95 @@ void assignExclusiveSegments() throws IOException {\n \t// Consume\n \t// ------------------------------------------------------------------------\n \n+\tvoid readRecoveredState(ChannelStateReader reader) throws IOException, InterruptedException {\n+\t\tbeforeReadRecoveredState();\n+\n+\t\twhile (true) {\n+\t\t\tBuffer buffer;\n+\t\t\tsynchronized (bufferQueue) {\n+\t\t\t\tbuffer = bufferQueue.takeBuffer();\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tif (isReleased()) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (!isWaitingForFloatingBuffers) {\n+\t\t\t\t\t\tbuffer = inputGate.getBufferPool().requestBuffer();\n+\t\t\t\t\t\tif (buffer == null) {\n+\t\t\t\t\t\t\tinputGate.getBufferProvider().addBufferListener(this);\n+\t\t\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (buffer == null) {\n+\t\t\t\t\tbufferQueue.wait();\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tChannelStateReader.ReadResult result = internalReaderRecoveredState(reader, buffer);\n+\t\t\tif (result == ChannelStateReader.ReadResult.NO_MORE_DATA) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void beforeReadRecoveredState() {", "originalCommit": "054de880d6814fd93c782d199a87490d1440a573", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0OTk4OA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411349988", "bodyText": "This doesn't look right - boolean hasStates and @Nullable executor - it looks like this check should be on a different layer. As this method looks like it's called only in one place, shouldn't it be just inlined?", "author": "pnowojski", "createdAt": "2020-04-20T12:49:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -222,19 +225,65 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {\n \t\tcheckState(this.bufferPool == null, \"Bug in input gate setup logic: Already registered buffer pool.\");\n \t\t// assign exclusive buffers to input channels directly and use the rest for floating buffers\n \t\tassignExclusiveSegments();\n \n \t\tBufferPool bufferPool = bufferPoolFactory.get();\n \t\tsetBufferPool(bufferPool);\n+\t}\n \n-\t\trequestPartitions();\n+\t@Override\n+\tpublic void initializeStateAndRequestPartitions(\n+\t\t\tboolean hasStates,\n+\t\t\t@Nullable ExecutorService executor,\n+\t\t\tChannelStateReader reader) throws Exception {\n+\n+\t\tif (hasStates) {\n+\t\t\tcheckNotNull(executor);\n+\t\t\treadRecoveredStateBeforeRequestPartition(executor, reader);\n+\t\t} else {\n+\t\t\trequestPartitions();\n+\t\t}", "originalCommit": "054de880d6814fd93c782d199a87490d1440a573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2NTU4OA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411465588", "bodyText": "It actually inlines two requirements on purpose. TBH I was also a bit torn to do so before.\nMy previous thought was trying not to affect the normal process if not enabling unaligned mode, that means requesting partitions directly, otherwise short lifecycle jobs might be sensitive for the potential performance regression with unnecessary state recovery process. And passing nullable executor can also simplify the unit tests without unaligned mode not to maintain the useless executor.\nAnother solution is to separate it into two methods. One is for #requestPartitions and the other is for #readRecoveredState. But that means we also need to define another explicit interface method InputGate#requestPartitions, which would bring more tiny steps in the lifecycle of InputGate, like setup -> readRecoveredState -> requestPartitions. So I chose the inlined way to reduce this overhead.", "author": "zhijiangW", "createdAt": "2020-04-20T15:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0OTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ4ODY3Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411488676", "bodyText": "Ok, I see. This is messy :/ It comes down to this issue that input gates are initialised in the Task and state is handled in StreamTask :/ It should have been handled together upon the construction of SingleInputGate class.\nI think I would be +0.1 for dropping initializeStateAndRequestPartitions and both readRecoveredStateBeforeRequestPartition and requestPartitions to the interfaces, but if you think it's better to have a single method, I'm fine with that.", "author": "pnowojski", "createdAt": "2020-04-20T15:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0OTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyNTc3Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411525772", "bodyText": "I am planning to separate this inlined method for your 0.1 favor. :)", "author": "zhijiangW", "createdAt": "2020-04-20T16:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM0OTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MjA1NQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411352055", "bodyText": "Add a TODO that it should be replaced by a global TaskManager ioExecutor?", "author": "pnowojski", "createdAt": "2020-04-20T12:52:54Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -204,6 +205,9 @@\n \n \tprotected final MailboxProcessor mailboxProcessor;\n \n+\t@Nullable\n+\tprivate final ExecutorService channelStateUnspillingExecutor;", "originalCommit": "054de880d6814fd93c782d199a87490d1440a573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1NjAzOA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r411456038", "bodyText": "Maybe, not quite sure whether the existing ioExecutor in TaskManagerService can be used for unspill  state purpose. Anyway, we can always introduce a dedicated executor on TaskManager level future.", "author": "zhijiangW", "createdAt": "2020-04-20T15:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MjA1NQ=="}], "type": "inlineReview"}, {"oid": "d6bf8d30b07508e1bfab01026414e9d461fb2a52", "url": "https://github.com/apache/flink/commit/d6bf8d30b07508e1bfab01026414e9d461fb2a52", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-20T15:27:06Z", "type": "forcePushed"}, {"oid": "3c8127c5af7014b7368b202fbb3966f3d478a791", "url": "https://github.com/apache/flink/commit/3c8127c5af7014b7368b202fbb3966f3d478a791", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-20T15:31:30Z", "type": "forcePushed"}, {"oid": "9c84a49b5dfcafda82951da969e169cbe7b15645", "url": "https://github.com/apache/flink/commit/9c84a49b5dfcafda82951da969e169cbe7b15645", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-20T16:40:42Z", "type": "forcePushed"}, {"oid": "f20368de0bdc14ae26ea92256137a9551bdb0879", "url": "https://github.com/apache/flink/commit/f20368de0bdc14ae26ea92256137a9551bdb0879", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-21T02:36:04Z", "type": "forcePushed"}, {"oid": "1f5288d48dbc82412dd9ddf9d8e3d9b2f0f4b92d", "url": "https://github.com/apache/flink/commit/1f5288d48dbc82412dd9ddf9d8e3d9b2f0f4b92d", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-21T05:50:46Z", "type": "forcePushed"}, {"oid": "7da2bce04403094880b080257cc837e94ae41164", "url": "https://github.com/apache/flink/commit/7da2bce04403094880b080257cc837e94ae41164", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-21T07:17:48Z", "type": "forcePushed"}, {"oid": "23818c4b30eb9714154080253a090fc63d983925", "url": "https://github.com/apache/flink/commit/23818c4b30eb9714154080253a090fc63d983925", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-21T10:09:54Z", "type": "forcePushed"}, {"oid": "528daec595675b9f2871612186b259a00afc53f0", "url": "https://github.com/apache/flink/commit/528daec595675b9f2871612186b259a00afc53f0", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nThe InputGate would request buffer from local pool and then interact with ChannelStateReader to fill in the state data.  The filled buffer\nwould be inserted into respective InputChannel queue for processing in normal way.\n\nIt should guarantee that the new data from upstream side should not overtake the input state data to avoid mis-order issue.", "committedDate": "2020-04-21T10:34:55Z", "type": "forcePushed"}, {"oid": "9b6278f15a4fc65d78671a145305df2c7310cc6a", "url": "https://github.com/apache/flink/commit/9b6278f15a4fc65d78671a145305df2c7310cc6a", "message": "fixup test failure", "committedDate": "2020-04-21T10:56:37Z", "type": "forcePushed"}, {"oid": "336b9fb055fc2d3bcf622abbb7e2a73e4fb8f4a1", "url": "https://github.com/apache/flink/commit/336b9fb055fc2d3bcf622abbb7e2a73e4fb8f4a1", "message": "[fixup] Disable unaligned checkpoint for UnalignedCheckpointITCase", "committedDate": "2020-04-21T17:15:56Z", "type": "forcePushed"}, {"oid": "1a28ea65925ab2094ef7496c4427bb635ff6f70c", "url": "https://github.com/apache/flink/commit/1a28ea65925ab2094ef7496c4427bb635ff6f70c", "message": "[fixup] Disable unaligned checkpoint in UnalignedCheckpointITCase", "committedDate": "2020-04-22T03:06:50Z", "type": "forcePushed"}, {"oid": "a1140f49a314268a6ad5272cf9bb8909ed01f0f7", "url": "https://github.com/apache/flink/commit/a1140f49a314268a6ad5272cf9bb8909ed01f0f7", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily", "committedDate": "2020-04-22T05:37:21Z", "type": "forcePushed"}, {"oid": "02d7611d018172fa1414f0ae87ac6d282c4ba7c9", "url": "https://github.com/apache/flink/commit/02d7611d018172fa1414f0ae87ac6d282c4ba7c9", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily", "committedDate": "2020-04-22T09:18:48Z", "type": "forcePushed"}, {"oid": "4f7399680818f5d29e917e17720e00900822a43d", "url": "https://github.com/apache/flink/commit/4f7399680818f5d29e917e17720e00900822a43d", "message": "[fixup] Disable unstable UnalignedCheckpointITCase temporarily", "committedDate": "2020-04-22T09:31:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA2NTUyMw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r413065523", "bodyText": "I think this block of code is forgetting about getUnconsumedBuffer() from the LocalInputChannel that was spilled as part of the input data.", "author": "pnowojski", "createdAt": "2020-04-22T15:06:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGate.java", "diffHunk": "@@ -222,19 +226,54 @@ public SingleInputGate(\n \t}\n \n \t@Override\n-\tpublic void setup() throws IOException, InterruptedException {\n+\tpublic void setup() throws IOException {\n \t\tcheckState(this.bufferPool == null, \"Bug in input gate setup logic: Already registered buffer pool.\");\n \t\t// assign exclusive buffers to input channels directly and use the rest for floating buffers\n \t\tassignExclusiveSegments();\n \n \t\tBufferPool bufferPool = bufferPoolFactory.get();\n \t\tsetBufferPool(bufferPool);\n+\t}\n+\n+\t@Override\n+\tpublic void readRecoveredState(ExecutorService executor, ChannelStateReader reader) throws IOException {\n+\t\tinternalRequestPartitions(() -> executor.submit(() -> {\n+\n+\t\t\tfor (InputChannel inputChannel : inputChannels.values()) {\n+\t\t\t\tif (inputChannel instanceof RemoteInputChannel) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\t((RemoteInputChannel) inputChannel).readRecoveredState(reader);\n+\t\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\t\tinputChannel.setError(t);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}", "originalCommit": "4f7399680818f5d29e917e17720e00900822a43d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7e376a2be10cb7e0d9a2945c3ab2b30c2e14bd50", "url": "https://github.com/apache/flink/commit/7e376a2be10cb7e0d9a2945c3ab2b30c2e14bd50", "message": "fixup local input channel recovery", "committedDate": "2020-04-23T11:40:55Z", "type": "forcePushed"}, {"oid": "672a5e5b1a1c4607cb5e5e191877484f472dad1b", "url": "https://github.com/apache/flink/commit/672a5e5b1a1c4607cb5e5e191877484f472dad1b", "message": "fixup local input channel recovery", "committedDate": "2020-04-23T18:22:50Z", "type": "forcePushed"}, {"oid": "12c398dd2dc5b6716a590490575914698573ab76", "url": "https://github.com/apache/flink/commit/12c398dd2dc5b6716a590490575914698573ab76", "message": "fixup local input channel recovery", "committedDate": "2020-04-24T02:39:06Z", "type": "forcePushed"}, {"oid": "95dc7d6ada34179b51849d905f15c740ca585a8d", "url": "https://github.com/apache/flink/commit/95dc7d6ada34179b51849d905f15c740ca585a8d", "message": "fixup local input channel recovery", "committedDate": "2020-04-24T06:58:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r414689192", "bodyText": "Why do we have to requestPartitions() once per every record?", "author": "pnowojski", "createdAt": "2020-04-24T16:02:46Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractRecordReader.java", "diffHunk": "@@ -63,6 +63,8 @@ protected AbstractRecordReader(InputGate inputGate, String[] tmpDirectories) {\n \t}\n \n \tprotected boolean getNextRecord(T target) throws IOException, InterruptedException {\n+\t\tinputGate.requestPartitions();", "originalCommit": "6ca8ec305a96d208919ab49244448de89bc7b679", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIwNzY0Mw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r415207643", "bodyText": "This is the only concentrated place work for all the batch cases. Otherwise we have to add this call for all the specific invokable instances derived from BatchTask class, even we also need to consider many other cases which bypassed the invokable class and use the wrapped AbstractRecordReader directly in unit tests, etc.\nI remembered in the early version, the requestPartitions was also placed inside SingleInputGate#getNext  method. Because of the mailbox requirement, it was migrated into #setup afterwards.\nConsidering the batch case unrelated to mailbox path, so i think it might be accepted to redo it still in the original place only work for batch cases.", "author": "zhijiangW", "createdAt": "2020-04-26T04:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0NzczNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419347735", "bodyText": "I remembered in the early version, the requestPartitions was also placed inside SingleInputGate#getNext method. Because of the mailbox requirement, it was migrated into #setup afterwards.\n\nBut that wasn't a good design, and it's still not now :(", "author": "pnowojski", "createdAt": "2020-05-04T10:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NDQzMQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419484431", "bodyText": "Can not we keep the previous setup logic if unaligned checkpoints are disabled/not configured (that would include batch?)? And add a checkState somewhere, that unaligned checkpoints can not be used without StreamTask/in streaming or something like that?", "author": "pnowojski", "createdAt": "2020-05-04T14:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyMjk3NQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419522975", "bodyText": "agree, it is not a perfect way, but the feasible simple way ATM to not maintain many different code paths, also not sensitive for batch code path.", "author": "zhijiangW", "createdAt": "2020-05-04T15:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyNTI5Nw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422025297", "bodyText": "Could you explain why do you think:\n\nalso not sensitive for batch code path.\n\n?", "author": "pnowojski", "createdAt": "2020-05-08T08:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4OTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5NzQzMg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r414697432", "bodyText": "requestPartitions() requires similar java doc as readRecoveredState() explaining when it should be called.", "author": "pnowojski", "createdAt": "2020-04-24T16:15:31Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/InputGate.java", "diffHunk": "@@ -131,7 +133,18 @@\n \t/**\n \t * Setup gate, potentially heavy-weight, blocking operation comparing to just creation.\n \t */\n-\tpublic abstract void setup() throws IOException, InterruptedException;\n+\tpublic abstract void setup() throws IOException;\n+\n+\t/**\n+\t * It is only performed for unaligned checkpoint mode together with internal requesting partitions afterwards.\n+\t * Otherwise only {@link #requestPartitions()} is performed for other checkpoint modes.\n+\t *\n+\t * @param executor the dedicated executor for performing the recovery state for all the internal channels.\n+\t * @param reader the dedicated reader for unspilling the respective channel state from stored snapshots.\n+\t */\n+\tpublic abstract void readRecoveredState(ExecutorService executor, ChannelStateReader reader) throws IOException;\n+\n+\tpublic abstract void requestPartitions() throws IOException;", "originalCommit": "95dc7d6ada34179b51849d905f15c740ca585a8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "968fa03e469b1704f78106b059a5acaca488dbed", "url": "https://github.com/apache/flink/commit/968fa03e469b1704f78106b059a5acaca488dbed", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-04-30T11:24:04Z", "type": "forcePushed"}, {"oid": "da10d0e76f80f3d95d7bbd3c035c11bd4a4b388d", "url": "https://github.com/apache/flink/commit/da10d0e76f80f3d95d7bbd3c035c11bd4a4b388d", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-04-30T15:48:53Z", "type": "forcePushed"}, {"oid": "44c8e741ef3e7c17492736d441369a56646b6713", "url": "https://github.com/apache/flink/commit/44c8e741ef3e7c17492736d441369a56646b6713", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-04-30T17:12:46Z", "type": "forcePushed"}, {"oid": "25bf7d665d0b232621648b7d517376a60aab4311", "url": "https://github.com/apache/flink/commit/25bf7d665d0b232621648b7d517376a60aab4311", "message": "[fixup] Guarantee at-least one floating buffer in LocalBufferPool for local channel state recovery", "committedDate": "2020-05-01T16:10:07Z", "type": "forcePushed"}, {"oid": "b5e4853968886a623cb083fe71933fa2ce7f8932", "url": "https://github.com/apache/flink/commit/b5e4853968886a623cb083fe71933fa2ce7f8932", "message": "[fixup] Guarantee at-least one floating buffer in LocalBufferPool for local channel state recovery", "committedDate": "2020-05-02T14:37:35Z", "type": "forcePushed"}, {"oid": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "url": "https://github.com/apache/flink/commit/bd26e4d1aae1bfb87dee603ddd51afda409a46df", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-04T07:46:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMTA1MA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r414711050", "bodyText": "?", "author": "pnowojski", "createdAt": "2020-04-24T16:37:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -97,6 +100,18 @@ public LocalInputChannel(\n \t// Consume\n \t// ------------------------------------------------------------------------\n \n+\t@Override\n+\tpublic void readRecoveredState(ChannelStateReader reader) throws IOException, InterruptedException {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// In most of cases we only need one buffer for reading recovered state except in very large record case.\n+\t\t\t// Then only one floating buffer is required to avoid receive more floating buffers after recovery. Even\n+\t\t\t// though we need more buffers for recovery in large record case, it only increases some interactions with pool.\n+\t\t\tnumRequiredBuffers = 1;\n+\t\t}\n+\n+\t\tsuper.readRecoveredState(reader);", "originalCommit": "95dc7d6ada34179b51849d905f15c740ca585a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyMTgxNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419521815", "bodyText": "what is the issue here?", "author": "zhijiangW", "createdAt": "2020-05-04T15:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMTA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MjAxNw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419942017", "bodyText": "Ops, sorry, that was some older comment that I forgot to remove before publishing the review :)", "author": "pnowojski", "createdAt": "2020-05-05T08:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3NjA4OA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r416476088", "bodyText": "Why add synchornized section?", "author": "pnowojski", "createdAt": "2020-04-28T09:41:55Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -371,7 +373,14 @@ boolean isWaitingForFloatingBuffers() {\n \n \t@VisibleForTesting\n \tpublic Buffer getNextReceivedBuffer() {\n-\t\treturn receivedBuffers.poll();\n+\t\tsynchronized (receivedBuffers) {\n+\t\t\treturn receivedBuffers.poll();\n+\t\t}", "originalCommit": "95dc7d6ada34179b51849d905f15c740ca585a8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyMTYwNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419521605", "bodyText": "it is out of date and i can not find this code path now?", "author": "zhijiangW", "createdAt": "2020-05-04T15:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3NjA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MjMyNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419942325", "bodyText": "I think it's in a separate commit now org.apache.flink.runtime.io.network.partition.consumer.RemoteInputChannel#getNumberOfQueuedBuffers", "author": "pnowojski", "createdAt": "2020-05-05T08:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3NjA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyMjY0Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419322646", "bodyText": "I would keep the unsynchronized prefix for this method and getNumberOfAvailableFloatingBuffers as well.", "author": "pnowojski", "createdAt": "2020-05-04T09:46:50Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -477,11 +362,11 @@ public int unsynchronizedGetNumberOfQueuedBuffers() {\n \t}\n \n \tpublic int unsynchronizedGetExclusiveBuffersUsed() {\n-\t\treturn Math.max(0, initialCredit - bufferQueue.exclusiveBuffers.size());\n+\t\treturn Math.max(0, initialCredit - bufferManager.getNumberOfAvailableExclusiveBuffers());", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyODI4MA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419328280", "bodyText": "This method is not synchronized. However it could be marked as @VisibleForTesting, so we could ignore this issue for now + adding unsynchronized prefix?", "author": "pnowojski", "createdAt": "2020-05-04T09:57:37Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -321,111 +274,43 @@ private void notifyCreditAvailable() {\n \t\tpartitionRequestClient.notifyCreditAvailable(this);\n \t}\n \n-\t/**\n-\t * Exclusive buffer is recycled to this input channel directly and it may trigger return extra\n-\t * floating buffer and notify increased credit to the producer.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see below for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\ttry {\n-\t\t\t\t\tmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t\treturn;\n-\t\t\t\t} catch (Throwable t) {\n-\t\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t}\n-\n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n \tpublic int getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n+\t\treturn bufferManager.getNumberOfAvailableBuffers();\n \t}\n \n \tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n+\t\treturn bufferManager.getNumberOfRequiredBuffers();\n \t}", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ2NzgyOQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419467829", "bodyText": "Yes, it could be as you said. Actually it should be a separate hotfix if we want to fix it in this PR.", "author": "zhijiangW", "createdAt": "2020-05-04T14:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyODI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyODg0Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419328846", "bodyText": "unsychronized prefix + @VisibleForTesting?", "author": "pnowojski", "createdAt": "2020-05-04T09:58:47Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\t\tif (buffer != null) {\n+\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\tnumRequestedBuffers++;\n+\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer recycle\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n+\t *\n+\t * @param segment The exclusive segment of this channel.\n+\t */\n+\t@Override\n+\tpublic void recycle(MemorySegment segment) {\n+\t\tint numAddedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+\t\t\t\t// after channel released all buffers via releaseAllResources().\n+\t\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n+\t\t\t\t} else {\n+\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tExceptionUtils.rethrow(t);\n+\t\t\t}\n+\t\t}\n+\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n+\t}\n+\n+\t/**\n+\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n+\t */\n+\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n+\t\t// we do not want to trigger redistribution of buffers after each recycle.\n+\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+\t\tBuffer buffer;\n+\t\twhile ((buffer = buffers.poll()) != null) {\n+\t\t\tif (buffer.getRecycler() == this) {\n+\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+\t\t\t} else {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n+\t\t}\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n+\t\t}\n+\n+\t\tif (exclusiveRecyclingSegments.size() > 0) {\n+\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer listener notification\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n+\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n+\t * the buffer will be added into the <tt>bufferQueue</tt>.\n+\t *\n+\t * @param buffer Buffer that becomes available in buffer pool.\n+\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n+\t * more floating buffers.\n+\t */\n+\t@Override\n+\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\t\tThrowable throwable = null;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n+\n+\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n+\t\t\t\t// released all buffers. Following scenarios exist:\n+\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n+\t\t\t\t// -> while isReleased is set correctly in InputChannel\n+\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n+\t\t\t\t// lock on bufferQueue to release buffers\n+\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\treturn notificationResult;\n+\t\t\t\t}\n+\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\n+\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+\t\t\t\t} else {\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tthrowable = t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (throwable != null) {\n+\t\t\tinputChannel.setError(throwable);\n+\t\t} else if (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n+\t\t\tinputChannel.notifyBufferAvailable(1);\n+\t\t}\n+\t\treturn notificationResult;\n+\t}\n+\n+\t@Override\n+\tpublic void notifyBufferDestroyed() {\n+\t\t// Nothing to do actually.\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Getter properties\n+\t// ------------------------------------------------------------------------\n+\n+\tint getNumberOfRequiredBuffers() {", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ2OTg4Mw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419469883", "bodyText": "unsychronized makes sense, but not for @VisibleForTesting because now it is also used in formal codes of RemoteInputChannel#getSenderBacklog", "author": "zhijiangW", "createdAt": "2020-05-04T14:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyODg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyOTQyNw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419329427", "bodyText": "unsychronized prefix?", "author": "pnowojski", "createdAt": "2020-05-04T09:59:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\t\tif (buffer != null) {\n+\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\tnumRequestedBuffers++;\n+\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer recycle\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n+\t *\n+\t * @param segment The exclusive segment of this channel.\n+\t */\n+\t@Override\n+\tpublic void recycle(MemorySegment segment) {\n+\t\tint numAddedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+\t\t\t\t// after channel released all buffers via releaseAllResources().\n+\t\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n+\t\t\t\t} else {\n+\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tExceptionUtils.rethrow(t);\n+\t\t\t}\n+\t\t}\n+\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n+\t}\n+\n+\t/**\n+\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n+\t */\n+\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n+\t\t// we do not want to trigger redistribution of buffers after each recycle.\n+\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+\t\tBuffer buffer;\n+\t\twhile ((buffer = buffers.poll()) != null) {\n+\t\t\tif (buffer.getRecycler() == this) {\n+\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+\t\t\t} else {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n+\t\t}\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n+\t\t}\n+\n+\t\tif (exclusiveRecyclingSegments.size() > 0) {\n+\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer listener notification\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n+\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n+\t * the buffer will be added into the <tt>bufferQueue</tt>.\n+\t *\n+\t * @param buffer Buffer that becomes available in buffer pool.\n+\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n+\t * more floating buffers.\n+\t */\n+\t@Override\n+\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\t\tThrowable throwable = null;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n+\n+\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n+\t\t\t\t// released all buffers. Following scenarios exist:\n+\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n+\t\t\t\t// -> while isReleased is set correctly in InputChannel\n+\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n+\t\t\t\t// lock on bufferQueue to release buffers\n+\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\treturn notificationResult;\n+\t\t\t\t}\n+\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\n+\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+\t\t\t\t} else {\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tthrowable = t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (throwable != null) {\n+\t\t\tinputChannel.setError(throwable);\n+\t\t} else if (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n+\t\t\tinputChannel.notifyBufferAvailable(1);\n+\t\t}\n+\t\treturn notificationResult;\n+\t}\n+\n+\t@Override\n+\tpublic void notifyBufferDestroyed() {\n+\t\t// Nothing to do actually.\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Getter properties\n+\t// ------------------------------------------------------------------------\n+\n+\tint getNumberOfRequiredBuffers() {\n+\t\treturn numRequiredBuffers;\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isWaitingForFloatingBuffers() {", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzMTYyNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419331625", "bodyText": "unsychronized prefix?", "author": "pnowojski", "createdAt": "2020-05-04T10:04:23Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();\n+\t\t\t\tBuffer buffer = bufferPool.requestBuffer();\n+\t\t\t\tif (buffer != null) {\n+\t\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\t\t\t\t\tnumRequestedBuffers++;\n+\t\t\t\t} else if (bufferPool.addBufferListener(this)) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = true;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn numRequestedBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer recycle\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * Exclusive buffer is recycled to this channel manager directly and it may trigger return extra\n+\t * floating buffer based on <tt>numRequiredBuffers</tt>.\n+\t *\n+\t * @param segment The exclusive segment of this channel.\n+\t */\n+\t@Override\n+\tpublic void recycle(MemorySegment segment) {\n+\t\tint numAddedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n+\t\t\t\t// after channel released all buffers via releaseAllResources().\n+\t\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\t\tglobalPool.recycleMemorySegments(Collections.singletonList(segment));\n+\t\t\t\t} else {\n+\t\t\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tExceptionUtils.rethrow(t);\n+\t\t\t}\n+\t\t}\n+\t\tinputChannel.notifyBufferAvailable(numAddedBuffers);\n+\t}\n+\n+\t/**\n+\t * Recycles all the exclusive and floating buffers from the given buffer queue.\n+\t */\n+\tvoid releaseAllBuffers(ArrayDeque<Buffer> buffers) throws IOException {\n+\t\t// Gather all exclusive buffers and recycle them to global pool in batch, because\n+\t\t// we do not want to trigger redistribution of buffers after each recycle.\n+\t\tfinal List<MemorySegment> exclusiveRecyclingSegments = new ArrayList<>();\n+\n+\t\tBuffer buffer;\n+\t\twhile ((buffer = buffers.poll()) != null) {\n+\t\t\tif (buffer.getRecycler() == this) {\n+\t\t\t\texclusiveRecyclingSegments.add(buffer.getMemorySegment());\n+\t\t\t} else {\n+\t\t\t\tbuffer.recycleBuffer();\n+\t\t\t}\n+\t\t}\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tbufferQueue.releaseAll(exclusiveRecyclingSegments);\n+\t\t}\n+\n+\t\tif (exclusiveRecyclingSegments.size() > 0) {\n+\t\t\tglobalPool.recycleMemorySegments(exclusiveRecyclingSegments);\n+\t\t}\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer listener notification\n+\t// ------------------------------------------------------------------------\n+\n+\t/**\n+\t * The buffer pool notifies this listener of an available floating buffer. If the listener is released or\n+\t * currently does not need extra buffers, the buffer should be returned to the buffer pool. Otherwise,\n+\t * the buffer will be added into the <tt>bufferQueue</tt>.\n+\t *\n+\t * @param buffer Buffer that becomes available in buffer pool.\n+\t * @return NotificationResult indicates whether this channel accepts the buffer and is waiting for\n+\t * more floating buffers.\n+\t */\n+\t@Override\n+\tpublic BufferListener.NotificationResult notifyBufferAvailable(Buffer buffer) {\n+\t\tBufferListener.NotificationResult notificationResult = BufferListener.NotificationResult.BUFFER_NOT_USED;\n+\t\tThrowable throwable = null;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\ttry {\n+\t\t\t\tcheckState(isWaitingForFloatingBuffers, \"This channel should be waiting for floating buffers.\");\n+\n+\t\t\t\t// Important: make sure that we never add a buffer after releaseAllResources()\n+\t\t\t\t// released all buffers. Following scenarios exist:\n+\t\t\t\t// 1) releaseAllBuffers() already released buffers inside bufferQueue\n+\t\t\t\t// -> while isReleased is set correctly in InputChannel\n+\t\t\t\t// 2) releaseAllBuffers() did not yet release buffers from bufferQueue\n+\t\t\t\t// -> we may or may not have set isReleased yet but will always wait for the\n+\t\t\t\t// lock on bufferQueue to release buffers\n+\t\t\t\tif (inputChannel.isReleased() || bufferQueue.getAvailableBufferSize() >= numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\treturn notificationResult;\n+\t\t\t\t}\n+\n+\t\t\t\tbufferQueue.addFloatingBuffer(buffer);\n+\n+\t\t\t\tif (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) {\n+\t\t\t\t\tisWaitingForFloatingBuffers = false;\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NO_NEED_MORE;\n+\t\t\t\t} else {\n+\t\t\t\t\tnotificationResult = BufferListener.NotificationResult.BUFFER_USED_NEED_MORE;\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tthrowable = t;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (throwable != null) {\n+\t\t\tinputChannel.setError(throwable);\n+\t\t} else if (notificationResult != NotificationResult.BUFFER_NOT_USED) {\n+\t\t\tinputChannel.notifyBufferAvailable(1);\n+\t\t}\n+\t\treturn notificationResult;\n+\t}\n+\n+\t@Override\n+\tpublic void notifyBufferDestroyed() {\n+\t\t// Nothing to do actually.\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Getter properties\n+\t// ------------------------------------------------------------------------\n+\n+\tint getNumberOfRequiredBuffers() {\n+\t\treturn numRequiredBuffers;\n+\t}\n+\n+\t@VisibleForTesting\n+\tboolean isWaitingForFloatingBuffers() {\n+\t\treturn isWaitingForFloatingBuffers;\n+\t}\n+\n+\tint getNumberOfAvailableBuffers() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.getAvailableBufferSize();\n+\t\t}\n+\t}\n+\n+\tint getNumberOfAvailableExclusiveBuffers() {\n+\t\treturn bufferQueue.exclusiveBuffers.size();\n+\t}\n+\n+\tint getNumberOfAvailableFloatingBuffers() {\n+\t\treturn bufferQueue.floatingBuffers.size();\n+\t}", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNDI1Mw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419334253", "bodyText": "I think this method is bugged (unsychronized and used in the multi threaded context), however it seems like it's result is never used in the production code - InputChannel#getNextBuffer doesn't need to return buffersInBacklog, am I right? So we could drop it? If so, we could do it as a follow up ticket, as this is already a pre-existing issue.", "author": "pnowojski", "createdAt": "2020-05-04T10:10:10Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -321,111 +274,43 @@ private void notifyCreditAvailable() {\n \t\tpartitionRequestClient.notifyCreditAvailable(this);\n \t}\n \n-\t/**\n-\t * Exclusive buffer is recycled to this input channel directly and it may trigger return extra\n-\t * floating buffer and notify increased credit to the producer.\n-\t *\n-\t * @param segment The exclusive segment of this channel.\n-\t */\n-\t@Override\n-\tpublic void recycle(MemorySegment segment) {\n-\t\tint numAddedBuffers;\n-\n-\t\tsynchronized (bufferQueue) {\n-\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer\n-\t\t\t// after releaseAllResources() released all buffers (see below for details).\n-\t\t\tif (isReleased.get()) {\n-\t\t\t\ttry {\n-\t\t\t\t\tmemorySegmentProvider.recycleMemorySegments(Collections.singletonList(segment));\n-\t\t\t\t\treturn;\n-\t\t\t\t} catch (Throwable t) {\n-\t\t\t\t\tExceptionUtils.rethrow(t);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tnumAddedBuffers = bufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n-\t\t}\n-\n-\t\tif (numAddedBuffers > 0 && unannouncedCredit.getAndAdd(numAddedBuffers) == 0) {\n-\t\t\tnotifyCreditAvailable();\n-\t\t}\n-\t}\n-\n \tpublic int getNumberOfAvailableBuffers() {\n-\t\tsynchronized (bufferQueue) {\n-\t\t\treturn bufferQueue.getAvailableBufferSize();\n-\t\t}\n+\t\treturn bufferManager.getNumberOfAvailableBuffers();\n \t}\n \n \tpublic int getNumberOfRequiredBuffers() {\n-\t\treturn numRequiredBuffers;\n+\t\treturn bufferManager.getNumberOfRequiredBuffers();\n \t}\n \n \tpublic int getSenderBacklog() {", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ3MjQxMQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419472411", "bodyText": "Exactly as you said, we can remove it as a separate ticket or even hotfix commit in this PR if you think so.", "author": "zhijiangW", "createdAt": "2020-05-04T14:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNDI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNzcwMw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419337703", "bodyText": "This cyclic dependency can be an issue for refactoring/reusing the code. Can not we cut it? As it is, you are trying to decouple buffer manager from input channel, but after all they are still very strongly coupled and both have a shared state.", "author": "pnowojski", "createdAt": "2020-05-04T10:17:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4NzAzNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419487035", "bodyText": "yeah, I also noticed this cycle dependency issue while implementation. And I also tried to cut it if easy to go. But actually I found it needs pay more efforts, because there are many interactions among InputChannel and BufferManager.\n\n\nBufferManager relies on BufferPool, then while SingleInputGate#setup, it needs to register the respective BufferPool for every InputChannel#BufferManager. This is the main concern to bypass this issue at current implementation.\n\n\nWe also need to maintain the  separate isReleased variable inside BufferManager to not rely on InputChannel#isReleased.\n\n\nWe might need another separate interface which would be implemented by InputChannel, then we can decouple another two depending methods InputChannel#onError and InputChannel#notifyBufferAvailable.", "author": "zhijiangW", "createdAt": "2020-05-04T14:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MzY1MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419943651", "bodyText": "I played a bit with this code and maybe it's not perfect, but it's at least a bit better (after separating BufferManager from RemoteInputChannel), so we can keep it as it is. I don't know how to fix it properly though.", "author": "pnowojski", "createdAt": "2020-05-05T08:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNzcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0MTI4Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419341286", "bodyText": "This should probably be injected in the constructor", "author": "pnowojski", "createdAt": "2020-05-04T10:24:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.io.network.partition.consumer;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.core.memory.MemorySegment;\n+import org.apache.flink.core.memory.MemorySegmentProvider;\n+import org.apache.flink.runtime.io.network.buffer.Buffer;\n+import org.apache.flink.runtime.io.network.buffer.BufferListener;\n+import org.apache.flink.runtime.io.network.buffer.BufferPool;\n+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;\n+import org.apache.flink.runtime.io.network.buffer.NetworkBuffer;\n+import org.apache.flink.util.ExceptionUtils;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import java.io.IOException;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.apache.flink.util.Preconditions.checkArgument;\n+import static org.apache.flink.util.Preconditions.checkNotNull;\n+import static org.apache.flink.util.Preconditions.checkState;\n+\n+/**\n+ * The general buffer manager used by {@link InputChannel} to request/recycle\n+ * exclusive or floating buffers.\n+ */\n+public class BufferManager implements BufferListener, BufferRecycler {\n+\n+\t/** The available buffer queue wraps both exclusive and requested floating buffers. */\n+\tprivate final AvailableBufferQueue bufferQueue = new AvailableBufferQueue();\n+\n+\t/** The buffer provider for requesting exclusive buffers. */\n+\tprivate final MemorySegmentProvider globalPool;\n+\n+\t/** The input channel to own this buffer manager. */\n+\tprivate final InputChannel inputChannel;\n+\n+\t/** The tag indicates whether it is waiting for additional floating buffers from the buffer pool. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate boolean isWaitingForFloatingBuffers;\n+\n+\t/** The total number of required buffers for the respective input channel. */\n+\t@GuardedBy(\"bufferQueue\")\n+\tprivate int numRequiredBuffers;\n+\n+\tpublic BufferManager(\n+\t\tMemorySegmentProvider globalPool,\n+\t\tInputChannel inputChannel,\n+\t\tint numRequiredBuffers) {\n+\n+\t\tthis.globalPool = checkNotNull(globalPool);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.numRequiredBuffers = numRequiredBuffers;\n+\t}\n+\n+\t// ------------------------------------------------------------------------\n+\t// Buffer request\n+\t// ------------------------------------------------------------------------\n+\n+\t@Nullable\n+\tBuffer requestBuffer() {\n+\t\tsynchronized (bufferQueue) {\n+\t\t\treturn bufferQueue.takeBuffer();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Requests exclusive buffers from the provider and returns the number of requested amount.\n+\t */\n+\tint requestExclusiveBuffers() throws IOException {\n+\t\tCollection<MemorySegment> segments = globalPool.requestMemorySegments();\n+\t\tcheckArgument(!segments.isEmpty(), \"The number of exclusive buffers per channel should be larger than 0.\");\n+\n+\t\tsynchronized (bufferQueue) {\n+\t\t\tfor (MemorySegment segment : segments) {\n+\t\t\t\tbufferQueue.addExclusiveBuffer(new NetworkBuffer(segment, this), numRequiredBuffers);\n+\t\t\t}\n+\t\t}\n+\t\treturn segments.size();\n+\t}\n+\n+\t/**\n+\t * Requests floating buffers from the buffer pool based on the given required amount, and returns the actual\n+\t * requested amount. If the required amount is not fully satisfied, it will register as a listener.\n+\t */\n+\tint requestFloatingBuffers(int numRequired) throws IOException {\n+\t\tint numRequestedBuffers = 0;\n+\t\tsynchronized (bufferQueue) {\n+\t\t\t// Similar to notifyBufferAvailable(), make sure that we never add a buffer after channel\n+\t\t\t// released all buffers via releaseAllResources().\n+\t\t\tif (inputChannel.isReleased()) {\n+\t\t\t\treturn numRequestedBuffers;\n+\t\t\t}\n+\n+\t\t\tnumRequiredBuffers = numRequired;\n+\n+\t\t\twhile (bufferQueue.getAvailableBufferSize() < numRequiredBuffers && !isWaitingForFloatingBuffers) {\n+\t\t\t\tBufferPool bufferPool = inputChannel.inputGate.getBufferPool();", "originalCommit": "52f011acf79e07ccefa2eb6db22f2835a100e9b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ4OTE3NQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419489175", "bodyText": "I also hope so, but the truth is not, because we can not get the proper BufferPool while constructing the BufferManager.\nThe BufferPool is created in SingleInputGate#setup, and it is also the main reason of relying on InputChannel component in BufferManager to bypass this issue.", "author": "zhijiangW", "createdAt": "2020-05-04T14:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0MTI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0Njk2OQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419346969", "bodyText": "It would be better to inject this field instead of relaying on even tighter coupling with inputChannel.", "author": "pnowojski", "createdAt": "2020-05-04T10:36:57Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/BufferManager.java", "diffHunk": "@@ -65,14 +65,10 @@\n \t@GuardedBy(\"bufferQueue\")\n \tprivate int numRequiredBuffers;\n \n-\tpublic BufferManager(\n-\t\tMemorySegmentProvider globalPool,\n-\t\tInputChannel inputChannel,\n-\t\tint numRequiredBuffers) {\n-\n-\t\tthis.globalPool = checkNotNull(globalPool);\n-\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\tpublic BufferManager(InputChannel inputChannel, int numRequiredBuffers) {\n \t\tcheckArgument(numRequiredBuffers >= 0);\n+\t\tthis.inputChannel = checkNotNull(inputChannel);\n+\t\tthis.globalPool = inputChannel.inputGate.getMemorySegmentProvider();", "originalCommit": "d1da882e9fd7249eb5b78752bc6e8e104e6633cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ5MDY0Mw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419490643", "bodyText": "Actually I injected it in the constructor in previous version, but since we can not get ride of InputChannel completed in BufferManager as above said, then I reduce this unnecessary argument in constructor.", "author": "zhijiangW", "createdAt": "2020-05-04T14:44:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0Njk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0NTE4OQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419945189", "bodyText": "I think it would be better to limit the reliance on this faulty cyclic dependency. That way it will be easier to get rid of it in the future.", "author": "pnowojski", "createdAt": "2020-05-05T08:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0Njk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0NzI3MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r420147271", "bodyText": "Makes sense", "author": "zhijiangW", "createdAt": "2020-05-05T14:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0Njk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0OTU0Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419349542", "bodyText": "Why 6 instead of (NUM_TASKS + 3)? And also why has it increased?", "author": "pnowojski", "createdAt": "2020-05-04T10:42:57Z", "path": "flink-tests/src/test/java/org/apache/flink/test/streaming/runtime/BackPressureITCase.java", "diffHunk": "@@ -94,7 +94,7 @@ private static Configuration createNetworkBufferConfiguration() {\n \t\tfinal Configuration configuration = new Configuration();\n \n \t\tfinal int memorySegmentSizeKb = 32;\n-\t\tfinal MemorySize networkBuffersMemory = MemorySize.parse(memorySegmentSizeKb * (NUM_TASKS + 2) + \"kb\");\n+\t\tfinal MemorySize networkBuffersMemory = MemorySize.parse(memorySegmentSizeKb * 6 + \"kb\");", "originalCommit": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ5NDk4Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419494982", "bodyText": "In previous way the LocalBufferPool for SingleInputGate has 0 required buffers, but now we adjust it to guarantee at-least one required buffer for local channel state recovery.\nIn this ITCase,  the exclusive buffers for map and sink vertex should be 2 * 2 , and the floating buffers in LocalBufferPool should be 2 * 1, then the total minimum buffer amount should be 6.", "author": "zhijiangW", "createdAt": "2020-05-04T14:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM0OTU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1MDYzMw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419350633", "bodyText": "Does it mean that for every LocalInputChannel after recovery we are wasting a single buffer?\nedit: Ok, I see, that it's being released after end of reading from recovered state, but this is very mangled and hard to understand :(", "author": "pnowojski", "createdAt": "2020-05-04T10:45:24Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -87,10 +90,14 @@ public LocalInputChannel(\n \t\tint maxBackoff,\n \t\tInputChannelMetrics metrics) {\n \n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackoff, maxBackoff, metrics.getNumBytesInLocalCounter(), metrics.getNumBuffersInLocalCounter());\n+\t\tsuper(inputGate, channelIndex, partitionId, initialBackoff, maxBackoff, metrics);\n \n \t\tthis.partitionManager = checkNotNull(partitionManager);\n \t\tthis.taskEventPublisher = checkNotNull(taskEventPublisher);\n+\t\t// In most cases we only need one buffer for reading recovered state except for very large record.\n+\t\t// Then only one floating buffer is required. Even though we need more buffers for recovery for\n+\t\t// large record, it only increases some interactions with pool.\n+\t\tthis.bufferManager = new BufferManager(this, 1);", "originalCommit": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUwMjMwMQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419502301", "bodyText": "Yes, I agree it is a bit hard to understand.\nThe numRequiredBuffers factor is only the complex point of this buffer manager model for getting a bit optimization. Actually we can give any initial value for numRequiredBuffers (e.g. 0) for unifying the local and remote channels.  And ideally we should adjust this value based on how many total channel states are under unspilling exactly like the concept of backlog in credit-based mode.\nActually any value for numRequiredBuffers can work correctly now and the only cost is increasing some unnecessary interactions between BufferManager and LocalBufferPool.\nI am really a bit torn here when implementation whether to retain this optimization.", "author": "zhijiangW", "createdAt": "2020-05-04T15:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1MDYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MTQ1Nw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419941457", "bodyText": "What do you mean by:\n\nActually any value for numRequiredBuffers can work correctly now and the only cost is increasing some unnecessary interactions between BufferManager and LocalBufferPool.\n\n? That with numRequiredBuffers = 0, the only difference would be that there are not floating buffers initially assigned and they need to be ramped up as the backlog increases?", "author": "pnowojski", "createdAt": "2020-05-05T08:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1MDYzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2MDk0MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r420160941", "bodyText": "I mean we can give any initial numRequiredBuffers actually, e.g. 0. Then while requesting floating buffers from buffer pool in practice, it might have two different paths:\n\n\nGet the available buffer right now from buffer pool.\n\n\nNo available buffer from buffer pool now, then it will register listener to buffer pool for later notification. For this process we should give a proper value of numRequiredBuffers. As long as this value is more than 0, it can work correctly.\n\n\nIt is better to give some detail examples to explain how numRequiredBuffers works differently in practice.\nE.g. numRequiredBuffers is set to 1 for RemoteInputChannel. When the exclusive buffers are processed and recycled back to RemoteInputChannel, then the current available amount might be 2 which is more than the numRequiredBuffers (1). So when the floating buffers are processed and recycled to LocalBufferPool, then it will notify the listener (RemoteInputChannel) of available buffers. But the RemoteInputChannel already has enough buffers now, so it will not accept this floating buffer to cause waste efforts of register & notify.\nBut if we give a larger numRequiredBuffers,  then we only need to register listener once. After that as long as the floating buffers are processed and recycled, they will be notified to RemoteInputChannel and be accepted to reuse future. So it might reduce more interactions between RemoteInputChannel and LocalBufferPool in practice. Especially for the channel state recovery case, it makes sense to try to occupy all the floating buffers from LocalBufferPool because only one channel is unspilling at the same time.", "author": "zhijiangW", "createdAt": "2020-05-05T14:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1MDYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MjcxNQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419382715", "bodyText": "Having to go everything through getRecoveredStateBuffer() every time is not very clean.", "author": "pnowojski", "createdAt": "2020-05-04T11:56:48Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -168,6 +175,12 @@ public void run() {\n \tOptional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException {\n \t\tcheckError();\n \n+\t\tBufferAndAvailability bufferAndAvailability = getNextRecoveredStateBuffer();", "originalCommit": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUwODgyMA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419508820", "bodyText": "I am neutral for this option, because the similar way really existed in many other places before. E.g. we have BufferStorage in CheckpointedInputGate for caching the blocked channels' buffers, then while getNextBuffer we also need to check whether there are  any pending buffers to be read from BufferStorage firstly.\nI absolutely agree that it would be better to not have different paths, but I also think it is not so bad if no other easy options.", "author": "zhijiangW", "createdAt": "2020-05-04T15:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MjcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MzcxMA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419383710", "bodyText": "If this is null, but we are still recovering, we will actually go through the the subpartitionView.getNextBuffer()?", "author": "pnowojski", "createdAt": "2020-05-04T11:58:52Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/LocalInputChannel.java", "diffHunk": "@@ -168,6 +175,12 @@ public void run() {\n \tOptional<BufferAndAvailability> getNextBuffer() throws IOException, InterruptedException {\n \t\tcheckError();\n \n+\t\tBufferAndAvailability bufferAndAvailability = getNextRecoveredStateBuffer();\n+\t\tif (bufferAndAvailability != null) {", "originalCommit": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxMzc5MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419513791", "bodyText": "My previous assumption was that the local channel will not be chosen by SingleInputGate to read if there were no buffers to insert into RecoveredInputChannel#receivedBuffers to notify SingleInputGate.notifyChannelNonEmpty before.\nOr I missed some other corner case?", "author": "zhijiangW", "createdAt": "2020-05-04T15:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MzcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzNjY1NA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419936654", "bodyText": "Generally speaking there are no guarantees that data notifications will be accurate or not (I'm not sure if that's the case here). But the code looks a bit strange here and it relays on some extra assumptions.", "author": "pnowojski", "createdAt": "2020-05-05T08:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MzcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2NzE5MA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r420167190", "bodyText": "I know that the current data notification from downstream side is not very accurate which might cause return null buffer sometimes, but we can make the channel state notification accurate (actually it is the ground truth now). Then another truth is that the channel state consumption should always happen before downstream consumption, so it should be no problem here.\nAs long as getNextBuffer is triggered by channel state buffer, it can always get accurate buffer. Otherwise if it is triggered by downstream side notification, then it also confirms that the channel state recovery should already finish before.", "author": "zhijiangW", "createdAt": "2020-05-05T14:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MzcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4NTg0Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419385846", "bodyText": "Integer.MAX_VALUE? Doesn't it mean that all floating buffers will be stuck permanently in on RemoteInputChannel (that happened to ask for them first?)", "author": "pnowojski", "createdAt": "2020-05-04T12:03:20Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannel.java", "diffHunk": "@@ -105,12 +98,15 @@ public RemoteInputChannel(\n \t\tint maxBackoff,\n \t\tInputChannelMetrics metrics) {\n \n-\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff,\n-\t\t\tmetrics.getNumBytesInRemoteCounter(), metrics.getNumBuffersInRemoteCounter());\n+\t\tsuper(inputGate, channelIndex, partitionId, initialBackOff, maxBackoff, metrics);\n \n \t\tthis.connectionId = checkNotNull(connectionId);\n \t\tthis.connectionManager = checkNotNull(connectionManager);\n-\t\tthis.bufferManager = new BufferManager(this, 0);\n+\t\t// In theory it should get the total number of states to indicate the numRequiredBuffers.\n+\t\t// Since we can not get this information in advance, and considering only one input channel\n+\t\t// will read state at the same time by design, then we give a maximum value here to reduce\n+\t\t// unnecessary interactions with buffer pool during recovery.\n+\t\tthis.bufferManager = new BufferManager(this, Integer.MAX_VALUE);", "originalCommit": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUyMDU0Nw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419520547", "bodyText": "As I explained for LocalInputChannel case, this numRequiredBuffers setting is only for a bit optimization, actually we can unify them as 0 and adjust it while really requesting floating buffers in process.\nATM we only have one input channel under unspill, so it makes sense to grab all the available floating buffers for this channel now. After this channel finishes unspilling,  then it would release all the floating buffers back to LocalBufferPool to be reused by other unspill channel.\nThere was a bit tricky to design the factor of numRequiredBuffers before. If one exclusive buffer is recycled or a floating buffer is recycled to notify available for the listener, it would double check whether the current listener still needs more floating buffers ATM based on numRequiredBuffers. If not needed, then the floating buffer would be return back to local pool to assign other listeners.\nFor input channel unspill case, we can assume that the current channel is always needing more floating buffers until finish, to avoid the floating buffer back to local pool and request from pool again when need it next time.", "author": "zhijiangW", "createdAt": "2020-05-04T15:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4NTg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDg1Nw==", "url": "https://github.com/apache/flink/pull/11687#discussion_r419564857", "bodyText": "This seems like we are loosing a test coverage here? However this test was quite fragile in the first place and I'm not entirely sure what is it suppose to test.", "author": "pnowojski", "createdAt": "2020-05-04T16:29:21Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/RemoteInputChannelTest.java", "diffHunk": "@@ -731,33 +726,29 @@ public void testFailureInNotifyBufferAvailable() throws Exception {\n \t\t\tbuffer = checkNotNull(bufferPool.requestBuffer());\n \n \t\t\t// trigger subscription to buffer pool\n-\t\t\tfailingRemoteIC.onSenderBacklog(1);\n-\t\t\tsuccessfulRemoteIC.onSenderBacklog(numExclusiveBuffers + 1);\n-\t\t\t// recycling will call RemoteInputChannel#notifyBufferAvailable() which will fail and\n-\t\t\t// this exception will be swallowed and set as an error in failingRemoteIC\n+\t\t\tchannelWithoutPartition.onSenderBacklog(1);\n+\t\t\tchannelWithPartition.onSenderBacklog(numExclusiveBuffers + 1);\n+\n+\t\t\t// recycling will call RemoteInputChannel#notifyBufferAvailable() which will not increase\n+\t\t\t// the unannounced credit if the channel has not requested partition\n \t\t\tbuffer.recycleBuffer();\n-\t\t\tbuffer = null;\n-\t\t\ttry {\n-\t\t\t\tfailingRemoteIC.checkError();\n-\t\t\t\tfail(\"The input channel should have an error based on the failure in RemoteInputChannel#notifyBufferAvailable()\");\n-\t\t\t} catch (IOException e) {\n-\t\t\t\tassertThat(e, hasProperty(\"cause\", isA(IllegalStateException.class)));\n-\t\t\t}", "originalCommit": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4NjQxOQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r420186419", "bodyText": "The previous purpose was to verify that if one remote channel has not requested partition, then the notify credit available will fail with IllegalStateException because of non-initialized PartitionRequestClient in RemoteInputChannel.  I think this test is not meaningful in practice, because if the partition request have not happened yet, then the onSenderBacklog should also not happen as well. It seems not valid to explicitly call onSenderBacklog to verify this logic without partition request.\nMy changes for this test is to verify that if the partition request have not happened yet, then the announced credit would not be increased as a result because this is only for the state recovery process to notify available buffers, but this available buffer is not regarded as credit concept without partition request. So I think it makes more sense than the previous test purpose.", "author": "zhijiangW", "createdAt": "2020-05-05T15:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NDg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMDkwOA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r420100908", "bodyText": "It would simplify a threading model, if this was executed from the main thread, via mailbox (in your PR there is already a race condition between processing data (receiving EndOfPartitionEvent/InputChannel#releaseAllResources from the main thread, vs channelIOExecutor requesting partitions). Example failure (this happened on a modified version of this code, but I think it's a valid failure on your version as well)\nWe could enqueue in the channelIOExecutor a simple job, that would enqueue a mail into the mailbox OR inputGate.readRecoveredState could return Future, and we could enqueue a mail into the mailbox once all futures are completed.", "author": "pnowojski", "createdAt": "2020-05-05T13:18:04Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -464,6 +472,20 @@ protected void beforeInvoke() throws Exception {\n \t\t\t\t\twriter.readRecoveredState(getEnvironment().getTaskStateManager().getChannelStateReader());\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// It would get possible benefits to recovery input side after output side, which guarantees the\n+\t\t\t// output can request more floating buffers from global firstly.\n+\t\t\tInputGate[] inputGates = getEnvironment().getAllInputGates();\n+\t\t\tif (inputGates != null) {\n+\t\t\t\tfor (InputGate inputGate : inputGates) {\n+\t\t\t\t\tinputGate.readRecoveredState(channelIOExecutor, getEnvironment().getTaskStateManager().getChannelStateReader());\n+\t\t\t\t}\n+\n+\t\t\t\t// Note that we must request partition after all the single gate finishes recovery.\n+\t\t\t\tfor (InputGate inputGate : inputGates) {\n+\t\t\t\t\tinputGate.requestPartitions(channelIOExecutor);\n+\t\t\t\t}", "originalCommit": "bd26e4d1aae1bfb87dee603ddd51afda409a46df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE3ODg1OA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r420178858", "bodyText": "Yeah, actually I also considered the way of requesting partition by mailbox thread after all futures completed returned by inputGate.readRecoveredState.\nBut I also thought of another existing case to execute partition request by non-task main thread. During SingleInputGate#updateInputChannel, when the unknown channel transform into local or remote channel, then it would request partition directly by rpc thread.  If this case makes sense, then my assumption was that partition request actually can be executed by any other threads without race condition issues. So I take the current way instead to save some efforts.", "author": "zhijiangW", "createdAt": "2020-05-05T15:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDEwMDkwOA=="}], "type": "inlineReview"}, {"oid": "104f4a80a39e1967209360e6ed285ccd3a3fe6eb", "url": "https://github.com/apache/flink/commit/104f4a80a39e1967209360e6ed285ccd3a3fe6eb", "message": "Supplement the new unit tests", "committedDate": "2020-05-08T07:06:32Z", "type": "forcePushed"}, {"oid": "2d7acec5759588e1b6fcdeb744877ce5ce6ab934", "url": "https://github.com/apache/flink/commit/2d7acec5759588e1b6fcdeb744877ce5ce6ab934", "message": "Supplement the new unit tests", "committedDate": "2020-05-08T07:49:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAxNTU3MA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422015570", "bodyText": "Maybe add\nLOG.debug(\"{}/{} Finished recovering input.\", inputGate.getOwningTaskName(), channelInfo);\n\n?", "author": "pnowojski", "createdAt": "2020-05-08T08:26:19Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java", "diffHunk": "@@ -46,15 +49,19 @@\n \t\t\tint maxBackoff,\n \t\t\tInputChannelMetrics metrics) {\n \t\tsuper(inputGate, channelIndex, partitionId, initialBackoff, maxBackoff, metrics.getNumBytesInRemoteCounter(), metrics.getNumBuffersInRemoteCounter());\n+\n+\t\tbufferManager = new BufferManager(inputGate.getMemorySegmentProvider(), this, 0);\n \t}\n \n+\tpublic abstract InputChannel toInputChannel() throws IOException;\n+\n \tprotected void readRecoveredState(ChannelStateReader reader) throws IOException, InterruptedException {\n \t\tReadResult result = ReadResult.HAS_MORE_DATA;\n \t\twhile (result == ReadResult.HAS_MORE_DATA) {\n-\t\t\tBuffer buffer = getBufferManager().requestBufferBlocking();\n+\t\t\tBuffer buffer = bufferManager.requestBufferBlocking();\n \t\t\tresult = internalReaderRecoveredState(reader, buffer);\n \t\t}\n-\t\tgetBufferManager().releaseFloatingBuffers();\n+\t\tbufferManager.releaseFloatingBuffers();", "originalCommit": "63b78b0d9260f094d0e5b54b1527802f85b89102", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMTY1Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422021656", "bodyText": "Hmmm, this is a bit fragile, as it implicitly assumes futures are completed from the task thread? Maybe add a checkState(...) asserting a thread to document this assumption?", "author": "pnowojski", "createdAt": "2020-05-08T08:39:56Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -477,14 +477,18 @@ protected void beforeInvoke() throws Exception {\n \t\t\t// output can request more floating buffers from global firstly.\n \t\t\tInputGate[] inputGates = getEnvironment().getAllInputGates();\n \t\t\tif (inputGates != null) {\n-\t\t\t\tfor (InputGate inputGate : inputGates) {\n-\t\t\t\t\tinputGate.readRecoveredState(channelIOExecutor, getEnvironment().getTaskStateManager().getChannelStateReader());\n+\t\t\t\tCompletableFuture[] futures = new CompletableFuture[inputGates.length];\n+\t\t\t\tfor (int i = 0; i < inputGates.length; i++) {\n+\t\t\t\t\tfutures[i] = inputGates[i].readRecoveredState(\n+\t\t\t\t\t\tchannelIOExecutor, getEnvironment().getTaskStateManager().getChannelStateReader());\n \t\t\t\t}\n \n-\t\t\t\t// Note that we must request partition after all the single gate finishes recovery.\n-\t\t\t\tfor (InputGate inputGate : inputGates) {\n-\t\t\t\t\tinputGate.requestPartitions(channelIOExecutor);\n-\t\t\t\t}\n+\t\t\t\t// Note that we must request partition after all the single gates finished recovery.\n+\t\t\t\tCompletableFuture.allOf(futures).thenRun(ThrowingRunnable.unchecked(() -> {\n+\t\t\t\t\tfor (InputGate inputGate : inputGates) {\n+\t\t\t\t\t\tinputGate.requestPartitions();\n+\t\t\t\t\t}\n+\t\t\t\t}));", "originalCommit": "ed7f2261646bd55b43d94f9373b02f45bfc7d58d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyODA2Ng==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422028066", "bodyText": "Yeah I assume it should be completed by task thread, actually my initial version was mailboxProcessor.getMainMailboxExecutor().execute().\nI can add a checkState here to guarantee that the current thread is mailbox thread and then give some note comments.", "author": "zhijiangW", "createdAt": "2020-05-08T08:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMTY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMzA1OQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422023059", "bodyText": "Why atomic? It could easily be checked and set under synchronized (receivedBuffers) lock, simplifying threading model a bit and it would also avoid extra AtomicBoolean check on the hot path.", "author": "pnowojski", "createdAt": "2020-05-08T08:43:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/RecoveredInputChannel.java", "diffHunk": "@@ -177,17 +178,18 @@ void sendTaskEvent(TaskEvent event) {\n \n \t@Override\n \tboolean isReleased() {\n-\t\treturn isReleased;\n+\t\treturn isReleased.get();\n \t}\n \n \tvoid releaseAllResources() throws IOException {\n-\t\tArrayDeque<Buffer> releasedBuffers = new ArrayDeque<>();\n-\t\tsynchronized (receivedBuffers) {\n-\t\t\treleasedBuffers.addAll(receivedBuffers);\n-\t\t\treceivedBuffers.clear();\n-\t\t\tisReleased = true;\n+\t\tif (isReleased.compareAndSet(false, true)) {", "originalCommit": "ad2be9470ed6e122bc0990e05ef0648fe4e0ce33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyOTkzOQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422029939", "bodyText": "In RemoteInputChannel we also had the atomic released variable and I guess here is the similar case. The release operation might be called not only by task thread, but also by canceler thread. If the latter, it might has visibility issue for task thread while interacting with RecoveredInputChannel#isReleased in BufferManager related operations.", "author": "zhijiangW", "createdAt": "2020-05-08T08:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAzNjI1OQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422036259", "bodyText": "also by canceler thread. If the latter, it might has visibility issue\n\nit wouldn't:\n\nIt could easily be checked and set under synchronized (receivedBuffers) lock\n\n?", "author": "pnowojski", "createdAt": "2020-05-08T09:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NDAwNg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422054006", "bodyText": "yeah, we can also take the way of adding the synchronized (receivedBuffers) for the  method of RecoveredInputGate#isReleased()", "author": "zhijiangW", "createdAt": "2020-05-08T09:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1NTIxOA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422055218", "bodyText": "It seems we have different ways for this issue in different classes. LocalInputChannel introduces volatile for this variable, and RemoteInputChannel introduces atomic variable, but RecoveredInputChannel takes the normal boolean variable.\nWe might need to unify them in separate commits future.", "author": "zhijiangW", "createdAt": "2020-05-08T09:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA1ODg4Mg==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422058882", "bodyText": "Agreed. But generally speaking closing/releasing logic is on my list for a larger refactor/clean up for a long time, especially because of those various nasty concurrency issues - I would see closing/releasing eventually moved to task thread/mailbox.\nFor now, I would avoid introducing extra synchronisation point in form of Atomic to make reasoning about the concurrent invocations here as simple as possible.", "author": "pnowojski", "createdAt": "2020-05-08T10:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjAyMzA1OQ=="}], "type": "inlineReview"}, {"oid": "6c4b98ebac7fbb0763ee8a7c8bbb347f2454d8a3", "url": "https://github.com/apache/flink/commit/6c4b98ebac7fbb0763ee8a7c8bbb347f2454d8a3", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-08T09:49:31Z", "type": "forcePushed"}, {"oid": "2547c306759c683dae0eb54e364066c99d04fa5c", "url": "https://github.com/apache/flink/commit/2547c306759c683dae0eb54e364066c99d04fa5c", "message": "fixup comments", "committedDate": "2020-05-08T10:19:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4NjkzOQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422086939", "bodyText": "nit: maybe add a small comment why is done like so here?", "author": "pnowojski", "createdAt": "2020-05-08T11:16:25Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/reader/AbstractRecordReader.java", "diffHunk": "@@ -63,6 +63,8 @@ protected AbstractRecordReader(InputGate inputGate, String[] tmpDirectories) {\n \t}\n \n \tprotected boolean getNextRecord(T target) throws IOException, InterruptedException {\n+\t\tinputGate.requestPartitions();", "originalCommit": "3e6bf1161b89f0908b6161f13c4ed14d8585decd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjA4NzM4MQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r422087381", "bodyText": "nit: remove comment", "author": "pnowojski", "createdAt": "2020-05-08T11:17:38Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/io/network/partition/consumer/SingleInputGateFactory.java", "diffHunk": "@@ -190,6 +190,7 @@ private InputChannel createInputChannel(\n \t\t\t\t\tpartitionRequestMaxBackoff,\n \t\t\t\t\tmetrics);\n \t\t\t},\n+\t\t\t// TODO: can we sometimes call createKnownInputChannel?", "originalCommit": "3e6bf1161b89f0908b6161f13c4ed14d8585decd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0fb7b8f4719e0b0fa354ea1797bb981a594de7ce", "url": "https://github.com/apache/flink/commit/0fb7b8f4719e0b0fa354ea1797bb981a594de7ce", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-09T03:00:24Z", "type": "forcePushed"}, {"oid": "893ed6127cbc2a7a8b8b9dcf63bb97812822338c", "url": "https://github.com/apache/flink/commit/893ed6127cbc2a7a8b8b9dcf63bb97812822338c", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-09T03:01:21Z", "type": "forcePushed"}, {"oid": "58157b4250ed6a6467202b712b0514a08b41c355", "url": "https://github.com/apache/flink/commit/58157b4250ed6a6467202b712b0514a08b41c355", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-09T07:33:34Z", "type": "forcePushed"}, {"oid": "ca92d5c0da54186ff37f68ac348e528bbb7f133a", "url": "https://github.com/apache/flink/commit/ca92d5c0da54186ff37f68ac348e528bbb7f133a", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-10T13:46:29Z", "type": "forcePushed"}, {"oid": "eee9d27ce9ffad0ec71351817d7c6db6e4be36fa", "url": "https://github.com/apache/flink/commit/eee9d27ce9ffad0ec71351817d7c6db6e4be36fa", "message": "[hotfix][network] Fix useless backlog value in BufferAndAvailability returned by RemoteInputChannel#getNextBuffer", "committedDate": "2020-05-11T05:51:00Z", "type": "commit"}, {"oid": "955ab36f2ab996f8fdce0c2beaf7eb54af8b4df0", "url": "https://github.com/apache/flink/commit/955ab36f2ab996f8fdce0c2beaf7eb54af8b4df0", "message": "[hotfix][network] Extract a general buffer manager for future reuse by recovered input channel", "committedDate": "2020-05-11T05:51:00Z", "type": "commit"}, {"oid": "eabeaa27277d8bca2208c2240ee26207c5121d0d", "url": "https://github.com/apache/flink/commit/eabeaa27277d8bca2208c2240ee26207c5121d0d", "message": "[hotfix][network] Maintain MemorySegmentProvider from InputChannel to SingleInputGate", "committedDate": "2020-05-11T05:51:00Z", "type": "commit"}, {"oid": "a90fdb11467d11b3b343e4e0ee2341c58ff4e71f", "url": "https://github.com/apache/flink/commit/a90fdb11467d11b3b343e4e0ee2341c58ff4e71f", "message": "[hotfix][tests] Refactor unit tests in RemoteInputChannelTest to avoid mock way", "committedDate": "2020-05-11T05:51:00Z", "type": "commit"}, {"oid": "76e38d2b20304cf1e3256763110749a4b0cbf4f3", "url": "https://github.com/apache/flink/commit/76e38d2b20304cf1e3256763110749a4b0cbf4f3", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-11T06:42:49Z", "type": "forcePushed"}, {"oid": "4302180858352cd4fce0668615483a33d2f8e98e", "url": "https://github.com/apache/flink/commit/4302180858352cd4fce0668615483a33d2f8e98e", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-12T02:58:30Z", "type": "commit"}, {"oid": "4302180858352cd4fce0668615483a33d2f8e98e", "url": "https://github.com/apache/flink/commit/4302180858352cd4fce0668615483a33d2f8e98e", "message": "[FLINK-16536][network][checkpointing] Implement InputChannel state recovery for unaligned checkpoint\n\nDuring recovery process for unaligned checkpoint, the input channel state should also be recovered besides with existing operator states.\n\nWe considered three guarantees during the implementation:\n1. Make input recovery happen after the output recovery for providing more floating buffers on output side firstly.\n2. Make partition request happen after input recovery for avoiding new data overtaking the previous state data.\n3. Introduce a dedicated single IO executor for unspilling the channel state one by one, to avoid potential random IO.\n\nThis closes #11687.", "committedDate": "2020-05-12T02:58:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzc0MA==", "url": "https://github.com/apache/flink/pull/11687#discussion_r423507740", "bodyText": "In the offline discussion about this deadlock, I meant to have !configuration.isCheckpointingEnabled() check here for now. That would solve the deadlock with input selection, while preserving functionality to disable/enable unaligned checkpoints.", "author": "pnowojski", "createdAt": "2020-05-12T07:06:51Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java", "diffHunk": "@@ -458,17 +466,50 @@ protected void beforeInvoke() throws Exception {\n \t\t\t// registers a timer, that fires before the open() is called.\n \t\t\toperatorChain.initializeStateAndOpenOperators(createStreamTaskStateInitializer());\n \n-\t\t\tResultPartitionWriter[] writers = getEnvironment().getAllWriters();\n-\t\t\tif (writers != null) {\n-\t\t\t\tfor (ResultPartitionWriter writer : writers) {\n-\t\t\t\t\twriter.readRecoveredState(getEnvironment().getTaskStateManager().getChannelStateReader());\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\treadRecoveredChannelState();\n \t\t});\n \n \t\tisRunning = true;\n \t}\n \n+\tprivate void readRecoveredChannelState() throws IOException, InterruptedException {\n+\t\t//TODO we will support channel state recovery even if the current setting is not unaligned checkpoint.\n+\t\tif (!configuration.isUnalignedCheckpointsEnabled()) {", "originalCommit": "4302180858352cd4fce0668615483a33d2f8e98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU5MTczOQ==", "url": "https://github.com/apache/flink/pull/11687#discussion_r423591739", "bodyText": "It will be addressed in FLINK-17476", "author": "pnowojski", "createdAt": "2020-05-12T09:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwNzc0MA=="}], "type": "inlineReview"}]}