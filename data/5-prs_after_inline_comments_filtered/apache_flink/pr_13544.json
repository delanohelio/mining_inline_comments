{"pr_number": 13544, "pr_title": "[FLINK-19309][coordination] Add TaskExecutorManager", "pr_createdAt": "2020-10-06T09:52:53Z", "pr_url": "https://github.com/apache/flink/pull/13544", "timeline": [{"oid": "a66e85992ca9513c7e54c74f1f098f6773595f10", "url": "https://github.com/apache/flink/commit/a66e85992ca9513c7e54c74f1f098f6773595f10", "message": "[FLINK-19309][coordination] Add TaskExecutorManager", "committedDate": "2020-10-06T09:37:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI5NzkyNw==", "url": "https://github.com/apache/flink/pull/13544#discussion_r500297927", "bodyText": "Why does the TaskExecutorManager needs to know these values?", "author": "tillrohrmann", "createdAt": "2020-10-06T13:52:21Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManager.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.MathUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * SlotManager component for all task executor related things.\n+ *\n+ * <p>Dev note: This component only exists to keep the code out of the slot manager.\n+ * It covers many aspects that aren't really the responsibility of the slot manager, and should be refactored to live\n+ * outside the slot manager and split into multiple parts.\n+ */\n+class TaskExecutorManager implements AutoCloseable {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(TaskExecutorManager.class);\n+\n+\tprivate final ResourceProfile defaultSlotResourceProfile;\n+\n+\t/** The default resource spec of workers to request. */\n+\tprivate final WorkerResourceSpec defaultWorkerResourceSpec;", "originalCommit": "a66e85992ca9513c7e54c74f1f098f6773595f10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQyMDcyNw==", "url": "https://github.com/apache/flink/pull/13544#discussion_r500420727", "bodyText": "They are used for allocating resources. It wouldn't necessarily need it as they could be injected by the ResourceActions, but I did not want to do such refactorings.", "author": "zentol", "createdAt": "2020-10-06T16:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI5NzkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI5OTU1OA==", "url": "https://github.com/apache/flink/pull/13544#discussion_r500299558", "bodyText": "I don't fully understand why the TEM is responsible for the pending slots. This looks more like the responsibility of the SlotManager to me.", "author": "tillrohrmann", "createdAt": "2020-10-06T13:54:03Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManager.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.MathUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * SlotManager component for all task executor related things.\n+ *\n+ * <p>Dev note: This component only exists to keep the code out of the slot manager.\n+ * It covers many aspects that aren't really the responsibility of the slot manager, and should be refactored to live\n+ * outside the slot manager and split into multiple parts.\n+ */\n+class TaskExecutorManager implements AutoCloseable {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(TaskExecutorManager.class);\n+\n+\tprivate final ResourceProfile defaultSlotResourceProfile;\n+\n+\t/** The default resource spec of workers to request. */\n+\tprivate final WorkerResourceSpec defaultWorkerResourceSpec;\n+\n+\tprivate final int numSlotsPerWorker;\n+\n+\t/** Defines the max limitation of the total number of slots. */\n+\tprivate final int maxSlotNum;\n+\n+\t/** Release task executor only when each produced result partition is either consumed or failed. */\n+\tprivate final boolean waitResultConsumedBeforeRelease;\n+\n+\t/** Defines the number of redundant taskmanagers. */\n+\tprivate final int redundantTaskManagerNum;\n+\n+\t/** Timeout after which an unused TaskManager is released. */\n+\tprivate final Time taskManagerTimeout;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate final ResourceActions resourceActions;\n+\n+\t/** All currently registered task managers. */\n+\tprivate final Map<InstanceID, TaskManagerRegistration> taskManagerRegistrations = new HashMap<>();\n+\n+\tprivate final Map<TaskManagerSlotId, PendingTaskManagerSlot> pendingSlots = new HashMap<>();", "originalCommit": "a66e85992ca9513c7e54c74f1f098f6773595f10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMwMTE3OQ==", "url": "https://github.com/apache/flink/pull/13544#discussion_r500301179", "bodyText": "Shouldn't this the concern of the SlotManager intead of the TEM?", "author": "tillrohrmann", "createdAt": "2020-10-06T13:55:43Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManager.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.MathUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * SlotManager component for all task executor related things.\n+ *\n+ * <p>Dev note: This component only exists to keep the code out of the slot manager.\n+ * It covers many aspects that aren't really the responsibility of the slot manager, and should be refactored to live\n+ * outside the slot manager and split into multiple parts.\n+ */\n+class TaskExecutorManager implements AutoCloseable {\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(TaskExecutorManager.class);\n+\n+\tprivate final ResourceProfile defaultSlotResourceProfile;\n+\n+\t/** The default resource spec of workers to request. */\n+\tprivate final WorkerResourceSpec defaultWorkerResourceSpec;\n+\n+\tprivate final int numSlotsPerWorker;\n+\n+\t/** Defines the max limitation of the total number of slots. */\n+\tprivate final int maxSlotNum;\n+\n+\t/** Release task executor only when each produced result partition is either consumed or failed. */\n+\tprivate final boolean waitResultConsumedBeforeRelease;\n+\n+\t/** Defines the number of redundant taskmanagers. */\n+\tprivate final int redundantTaskManagerNum;\n+\n+\t/** Timeout after which an unused TaskManager is released. */\n+\tprivate final Time taskManagerTimeout;\n+\n+\t/** Callbacks for resource (de-)allocations. */\n+\tprivate final ResourceActions resourceActions;\n+\n+\t/** All currently registered task managers. */\n+\tprivate final Map<InstanceID, TaskManagerRegistration> taskManagerRegistrations = new HashMap<>();\n+\n+\tprivate final Map<TaskManagerSlotId, PendingTaskManagerSlot> pendingSlots = new HashMap<>();\n+\n+\tprivate final Executor mainThreadExecutor;\n+\n+\tprivate final ScheduledFuture<?> taskManagerTimeoutsAndRedundancyCheck;\n+\n+\tTaskExecutorManager(\n+\t\tWorkerResourceSpec defaultWorkerResourceSpec,\n+\t\tint numSlotsPerWorker,\n+\t\tint maxNumSlots,\n+\t\tboolean waitResultConsumedBeforeRelease,\n+\t\tint redundantTaskManagerNum,\n+\t\tTime taskManagerTimeout,\n+\t\tScheduledExecutor scheduledExecutor,\n+\t\tExecutor mainThreadExecutor,\n+\t\tResourceActions resourceActions) {\n+\n+\t\tthis.defaultWorkerResourceSpec = defaultWorkerResourceSpec;\n+\t\tthis.numSlotsPerWorker = numSlotsPerWorker;\n+\t\tthis.maxSlotNum = maxNumSlots;\n+\t\tthis.waitResultConsumedBeforeRelease = waitResultConsumedBeforeRelease;\n+\t\tthis.redundantTaskManagerNum = redundantTaskManagerNum;\n+\t\tthis.taskManagerTimeout = taskManagerTimeout;\n+\t\tthis.defaultSlotResourceProfile = generateDefaultSlotResourceProfile(defaultWorkerResourceSpec, numSlotsPerWorker);\n+\n+\t\tthis.resourceActions = Preconditions.checkNotNull(resourceActions);\n+\t\tthis.mainThreadExecutor = mainThreadExecutor;\n+\t\ttaskManagerTimeoutsAndRedundancyCheck = scheduledExecutor.scheduleWithFixedDelay(\n+\t\t\t() -> mainThreadExecutor.execute(\n+\t\t\t\tthis::checkTaskManagerTimeoutsAndRedundancy),\n+\t\t\t0L,\n+\t\t\ttaskManagerTimeout.toMilliseconds(),\n+\t\t\tTimeUnit.MILLISECONDS);\n+\t}\n+\n+\t@VisibleForTesting\n+\tstatic ResourceProfile generateDefaultSlotResourceProfile(WorkerResourceSpec workerResourceSpec, int numSlotsPerWorker) {\n+\t\treturn ResourceProfile.newBuilder()\n+\t\t\t.setCpuCores(workerResourceSpec.getCpuCores().divide(numSlotsPerWorker))\n+\t\t\t.setTaskHeapMemory(workerResourceSpec.getTaskHeapSize().divide(numSlotsPerWorker))\n+\t\t\t.setTaskOffHeapMemory(workerResourceSpec.getTaskOffHeapSize().divide(numSlotsPerWorker))\n+\t\t\t.setManagedMemory(workerResourceSpec.getManagedMemSize().divide(numSlotsPerWorker))\n+\t\t\t.setNetworkMemory(workerResourceSpec.getNetworkMemSize().divide(numSlotsPerWorker))\n+\t\t\t.build();\n+\t}\n+\n+\t@Override\n+\tpublic void close() {\n+\t\ttaskManagerTimeoutsAndRedundancyCheck.cancel(false);\n+\t}\n+\n+\t// ---------------------------------------------------------------------------------------------\n+\t// TaskExecutor (un)registration\n+\t// ---------------------------------------------------------------------------------------------\n+\n+\tpublic boolean isTaskManagerRegistered(InstanceID instanceId) {\n+\t\treturn taskManagerRegistrations.containsKey(instanceId);\n+\t}\n+\n+\tpublic boolean registerTaskManager(final TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport) {\n+\t\tif (isMaxSlotNumExceededAfterRegistration(initialSlotReport)) {\n+\t\t\tLOG.info(\"The total number of slots exceeds the max limitation {}, releasing the excess task executor.\", maxSlotNum);\n+\t\t\tresourceActions.releaseResource(taskExecutorConnection.getInstanceID(), new FlinkException(\"The total number of slots exceeds the max limitation.\"));\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tTaskManagerRegistration taskManagerRegistration = new TaskManagerRegistration(\n+\t\t\ttaskExecutorConnection,\n+\t\t\tStreamSupport.stream(initialSlotReport.spliterator(), false).map(SlotStatus::getSlotID).collect(Collectors.toList()));\n+\n+\t\ttaskManagerRegistrations.put(taskExecutorConnection.getInstanceID(), taskManagerRegistration);\n+\n+\t\t// next register the new slots\n+\t\tfor (SlotStatus slotStatus : initialSlotReport) {\n+\t\t\tif (slotStatus.getJobID() == null) {\n+\t\t\t\tfindAndRemoveExactlyMatchingPendingTaskManagerSlot(slotStatus.getResourceProfile());\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn true;\n+\t}\n+\n+\tprivate boolean isMaxSlotNumExceededAfterRegistration(SlotReport initialSlotReport) {\n+\t\t// check if the total number exceed before matching pending slot.\n+\t\tif (!isMaxSlotNumExceededAfterAdding(initialSlotReport.getNumSlotStatus())) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t// check if the total number exceed slots after consuming pending slot.\n+\t\treturn isMaxSlotNumExceededAfterAdding(getNumNonPendingReportedNewSlots(initialSlotReport));\n+\t}", "originalCommit": "a66e85992ca9513c7e54c74f1f098f6773595f10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMwODY5Ng==", "url": "https://github.com/apache/flink/pull/13544#discussion_r500308696", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic void testTaskManagerTimeoutDoesNotRemoveSlots1() throws Exception {\n          \n          \n            \n            \tpublic void testTaskManagerTimeoutDoesNotRemoveSlots() throws Exception {", "author": "tillrohrmann", "createdAt": "2020-10-06T14:03:32Z", "path": "flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManagerTest.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.api.common.JobID;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.AllocationID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceID;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.runtime.taskexecutor.TestingTaskExecutorGatewayBuilder;\n+import org.apache.flink.runtime.testingUtils.TestingUtils;\n+import org.apache.flink.util.TestLogger;\n+\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+\n+/**\n+ * Tests for the {@link TaskExecutorManager}.\n+ */\n+public class TaskExecutorManagerTest extends TestLogger {\n+\n+\t/**\n+\t * Tests that a pending slot is only fulfilled by an exactly matching received slot.\n+\t */\n+\t@Test\n+\tpublic void testPendingSlotNotFulfilledIfProfilesAreNotExactMatch() {\n+\t\tfinal int numWorkerCpuCores = 3;\n+\t\tfinal WorkerResourceSpec workerResourceSpec = new WorkerResourceSpec.Builder().setCpuCores(numWorkerCpuCores).build();\n+\t\tfinal ResourceProfile requestedSlotProfile = ResourceProfile.newBuilder().setCpuCores(numWorkerCpuCores).build();\n+\t\tfinal ResourceProfile offeredSlotProfile = ResourceProfile.newBuilder().setCpuCores(numWorkerCpuCores - 1).build();\n+\n+\t\ttry (final TaskExecutorManager taskExecutorManager = createTaskExecutorManagerBuilder()\n+\t\t\t.setDefaultWorkerResourceSpec(workerResourceSpec)\n+\t\t\t.setNumSlotsPerWorker(1) // set to one so that the slot profiles directly correspond to the worker spec\n+\t\t\t.setMaxNumSlots(2)\n+\t\t\t.createTaskExecutorManager()) {\n+\n+\t\t\t// create pending slot\n+\t\t\ttaskExecutorManager.allocateWorker(requestedSlotProfile);\n+\t\t\tassertThat(taskExecutorManager.getNumberPendingTaskManagerSlots(), is(1));\n+\n+\t\t\tcreateAndRegisterTaskExecutor(taskExecutorManager, 1, offeredSlotProfile);\n+\n+\t\t\t// the slot from the task executor should be accepted, but we should still be waiting for the originally requested slot\n+\t\t\tassertThat(taskExecutorManager.getNumberRegisteredSlots(), is(1));\n+\t\t\tassertThat(taskExecutorManager.getNumberPendingTaskManagerSlots(), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a pending slot is not fulfilled by an already allocated slot.\n+\t */\n+\t@Test\n+\tpublic void testPendingSlotNotFulfilledByAllocatedSlot() {\n+\t\tfinal int numWorkerCpuCores = 3;\n+\t\tfinal WorkerResourceSpec workerResourceSpec = new WorkerResourceSpec.Builder().setCpuCores(numWorkerCpuCores).build();\n+\t\tfinal ResourceProfile requestedSlotProfile = ResourceProfile.newBuilder().setCpuCores(numWorkerCpuCores).build();\n+\n+\t\ttry (final TaskExecutorManager taskExecutorManager = createTaskExecutorManagerBuilder()\n+\t\t\t.setDefaultWorkerResourceSpec(workerResourceSpec)\n+\t\t\t.setNumSlotsPerWorker(1) // set to one so that the slot profiles directly correspond to the worker spec\n+\t\t\t.setMaxNumSlots(2)\n+\t\t\t.createTaskExecutorManager()) {\n+\n+\t\t\t// create pending slot\n+\t\t\ttaskExecutorManager.allocateWorker(requestedSlotProfile);\n+\t\t\tassertThat(taskExecutorManager.getNumberPendingTaskManagerSlots(), is(1));\n+\n+\t\t\tfinal TaskExecutorConnection taskExecutorConnection = createTaskExecutorConnection();\n+\t\t\tfinal SlotReport slotReport = new SlotReport(\n+\t\t\t\tnew SlotStatus(\n+\t\t\t\t\tnew SlotID(taskExecutorConnection.getResourceID(), 0),\n+\t\t\t\t\trequestedSlotProfile,\n+\t\t\t\t\tJobID.generate(),\n+\t\t\t\t\tnew AllocationID()));\n+\t\t\ttaskExecutorManager.registerTaskManager(taskExecutorConnection, slotReport);\n+\n+\t\t\t// the slot from the task executor should be accepted, but we should still be waiting for the originally requested slot\n+\t\t\tassertThat(taskExecutorManager.getNumberRegisteredSlots(), is(1));\n+\t\t\tassertThat(taskExecutorManager.getNumberPendingTaskManagerSlots(), is(1));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Tests that a task manager timeout does not remove the slots from the SlotManager.\n+\t * A timeout should only trigger the {@link ResourceActions#releaseResource(InstanceID, Exception)}\n+\t * callback. The receiver of the callback can then decide what to do with the TaskManager.\n+\t *\n+\t * <p>See FLINK-7793\n+\t */\n+\t@Test\n+\tpublic void testTaskManagerTimeoutDoesNotRemoveSlots1() throws Exception {", "originalCommit": "a66e85992ca9513c7e54c74f1f098f6773595f10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMyMDI5NA==", "url": "https://github.com/apache/flink/pull/13544#discussion_r500320294", "bodyText": "For the understanding of this component it could be helpful to describe what this component is responsible for. I don't fully understand why this component is responsible for managing the pending slots and also decides whether we have reached the maximum number of slots or not. Judging from its name, I would expect this component to be responsible for managing the TE connections and do the timeouts of idle TEs.", "author": "tillrohrmann", "createdAt": "2020-10-06T14:15:26Z", "path": "flink-runtime/src/main/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManager.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.runtime.resourcemanager.slotmanager;\n+\n+import org.apache.flink.annotation.VisibleForTesting;\n+import org.apache.flink.api.common.time.Time;\n+import org.apache.flink.runtime.clusterframework.types.ResourceProfile;\n+import org.apache.flink.runtime.clusterframework.types.SlotID;\n+import org.apache.flink.runtime.concurrent.ScheduledExecutor;\n+import org.apache.flink.runtime.instance.InstanceID;\n+import org.apache.flink.runtime.resourcemanager.WorkerResourceSpec;\n+import org.apache.flink.runtime.resourcemanager.registration.TaskExecutorConnection;\n+import org.apache.flink.runtime.slots.ResourceRequirement;\n+import org.apache.flink.runtime.taskexecutor.SlotReport;\n+import org.apache.flink.runtime.taskexecutor.SlotStatus;\n+import org.apache.flink.util.FlinkException;\n+import org.apache.flink.util.MathUtils;\n+import org.apache.flink.util.Preconditions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+/**\n+ * SlotManager component for all task executor related things.", "originalCommit": "a66e85992ca9513c7e54c74f1f098f6773595f10", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbba3f53abb4d4d6c220f8a87fa31c395d5c4f86", "url": "https://github.com/apache/flink/commit/bbba3f53abb4d4d6c220f8a87fa31c395d5c4f86", "message": "Update flink-runtime/src/test/java/org/apache/flink/runtime/resourcemanager/slotmanager/TaskExecutorManagerTest.java\n\nCo-authored-by: Till Rohrmann <till.rohrmann@gmail.com>", "committedDate": "2020-10-06T15:52:42Z", "type": "commit"}, {"oid": "ce0850c33eb360dbc17bbc66ca61fb832a2565b5", "url": "https://github.com/apache/flink/commit/ce0850c33eb360dbc17bbc66ca61fb832a2565b5", "message": "extend javadoc", "committedDate": "2020-10-12T08:48:55Z", "type": "commit"}, {"oid": "63c62b4aa413c927b2b16e3bccbb90eec03cbb16", "url": "https://github.com/apache/flink/commit/63c62b4aa413c927b2b16e3bccbb90eec03cbb16", "message": "add test", "committedDate": "2020-10-12T10:45:38Z", "type": "commit"}]}