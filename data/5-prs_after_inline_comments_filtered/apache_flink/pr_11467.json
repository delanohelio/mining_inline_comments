{"pr_number": 11467, "pr_title": "[FLINK-16317][operators] Provide support for watermarks, key selector and latency marker in MultipleInputStreamOperator", "pr_createdAt": "2020-03-20T16:24:20Z", "pr_url": "https://github.com/apache/flink/pull/11467", "timeline": [{"oid": "81e17c31a837e19c544c85672354f9681b8a8205", "url": "https://github.com/apache/flink/commit/81e17c31a837e19c544c85672354f9681b8a8205", "message": "[FLINK-16317][operators] Provide support for key selector and latency marker in MultipleInputStreamOperator", "committedDate": "2020-03-23T10:01:38Z", "type": "forcePushed"}, {"oid": "e4659f0c4ef7afa42a6a67e3c2e1eeb73db02e57", "url": "https://github.com/apache/flink/commit/e4659f0c4ef7afa42a6a67e3c2e1eeb73db02e57", "message": "[FLINK-16317][operators] Provide support for key selector and latency marker in MultipleInputStreamOperator", "committedDate": "2020-03-23T10:06:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4NDkzNg==", "url": "https://github.com/apache/flink/pull/11467#discussion_r396984936", "bodyText": "comment is contradicting assertion", "author": "AHeise", "createdAt": "2020-03-24T08:46:51Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -355,8 +377,235 @@ public void testInputFairness() throws Exception {\n \t\t}\n \t}\n \n-\t// This must only be used in one test, otherwise the static fields will be changed\n-\t// by several tests concurrently\n+\t/**\n+\t * This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether\n+\t * watermarks are forwarded only when we have received watermarks from all inputs. The\n+\t * forwarded watermark must be the minimum of the watermarks of all active inputs.\n+\t */\n+\t@Test\n+\tpublic void testWatermarkAndStreamStatusForwarding() throws Exception {\n+\t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n+\t\t\t\t new MultipleInputStreamTaskTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t\t .addInput(BasicTypeInfo.STRING_TYPE_INFO, 2)\n+\t\t\t\t\t .addInput(BasicTypeInfo.INT_TYPE_INFO, 2)\n+\t\t\t\t\t .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, 2)\n+\t\t\t\t\t .setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory())\n+\t\t\t\t\t .build()) {\n+\t\t\tArrayDeque<Object> expectedOutput = new ArrayDeque<>();\n+\n+\t\t\tlong initialTime = 0L;\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 0, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 0, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 1, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 1, 1);\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 2, 0);\n+\n+\t\t\tassertThat(testHarness.getOutput(), IsEmptyCollection.empty());\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 2, 1);\n+\n+\t\t\t// now the watermark should have propagated, Map simply forward Watermarks\n+\t\t\texpectedOutput.add(new Watermark(initialTime));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// contrary to checkpoint barriers these elements are not blocked by watermarks\n+\t\t\ttestHarness.processElement(new StreamRecord<>(\"Hello\", initialTime), 0, 0);\n+\t\t\ttestHarness.processElement(new StreamRecord<>(42, initialTime), 1, 1);\n+\t\t\texpectedOutput.add(new StreamRecord<>(\"Hello\", initialTime));\n+\t\t\texpectedOutput.add(new StreamRecord<>(\"42\", initialTime));\n+\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 0, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 3), 0, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 3), 1, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 3), 2, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 2), 2, 1);\n+\n+\t\t\t// check whether we get the minimum of all the watermarks, this must also only occur in\n+\t\t\t// the output after the two StreamRecords\n+\t\t\texpectedOutput.add(new Watermark(initialTime + 2));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// advance watermark from one of the inputs, now we should get a new one since the\n+\t\t\t// minimum increases\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 1);\n+\t\t\texpectedOutput.add(new Watermark(initialTime + 3));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// advance the other two inputs, now we should get a new one since the\n+\t\t\t// minimum increases again\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 0, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 0);\n+\t\t\texpectedOutput.add(new Watermark(initialTime + 4));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// test whether idle input channels are acknowledged correctly when forwarding watermarks\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 0, 1);\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 1, 1);\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 0, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 6), 1, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 5), 2, 1); // this watermark should be advanced first\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 2, 1); // once this is acknowledged,\n+\n+\t\t\t// watermark (initial + 6) should be forwarded", "originalCommit": "d5724d23c3827de7c9bfee1b24d3d091ffd1a606", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4NTMxOA==", "url": "https://github.com/apache/flink/pull/11467#discussion_r396985318", "bodyText": "Idle tests should be a separate test.", "author": "AHeise", "createdAt": "2020-03-24T08:47:33Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -355,8 +377,235 @@ public void testInputFairness() throws Exception {\n \t\t}\n \t}\n \n-\t// This must only be used in one test, otherwise the static fields will be changed\n-\t// by several tests concurrently\n+\t/**\n+\t * This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether\n+\t * watermarks are forwarded only when we have received watermarks from all inputs. The\n+\t * forwarded watermark must be the minimum of the watermarks of all active inputs.\n+\t */\n+\t@Test\n+\tpublic void testWatermarkAndStreamStatusForwarding() throws Exception {\n+\t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n+\t\t\t\t new MultipleInputStreamTaskTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)\n+\t\t\t\t\t .addInput(BasicTypeInfo.STRING_TYPE_INFO, 2)\n+\t\t\t\t\t .addInput(BasicTypeInfo.INT_TYPE_INFO, 2)\n+\t\t\t\t\t .addInput(BasicTypeInfo.DOUBLE_TYPE_INFO, 2)\n+\t\t\t\t\t .setupOutputForSingletonOperatorChain(new MapToStringMultipleInputOperatorFactory())\n+\t\t\t\t\t .build()) {\n+\t\t\tArrayDeque<Object> expectedOutput = new ArrayDeque<>();\n+\n+\t\t\tlong initialTime = 0L;\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 0, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 0, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 1, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 1, 1);\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 2, 0);\n+\n+\t\t\tassertThat(testHarness.getOutput(), IsEmptyCollection.empty());\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime), 2, 1);\n+\n+\t\t\t// now the watermark should have propagated, Map simply forward Watermarks\n+\t\t\texpectedOutput.add(new Watermark(initialTime));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// contrary to checkpoint barriers these elements are not blocked by watermarks\n+\t\t\ttestHarness.processElement(new StreamRecord<>(\"Hello\", initialTime), 0, 0);\n+\t\t\ttestHarness.processElement(new StreamRecord<>(42, initialTime), 1, 1);\n+\t\t\texpectedOutput.add(new StreamRecord<>(\"Hello\", initialTime));\n+\t\t\texpectedOutput.add(new StreamRecord<>(\"42\", initialTime));\n+\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 0, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 3), 0, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 3), 1, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 3), 2, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 2), 2, 1);\n+\n+\t\t\t// check whether we get the minimum of all the watermarks, this must also only occur in\n+\t\t\t// the output after the two StreamRecords\n+\t\t\texpectedOutput.add(new Watermark(initialTime + 2));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// advance watermark from one of the inputs, now we should get a new one since the\n+\t\t\t// minimum increases\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 1);\n+\t\t\texpectedOutput.add(new Watermark(initialTime + 3));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// advance the other two inputs, now we should get a new one since the\n+\t\t\t// minimum increases again\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 0, 1);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 1, 0);\n+\t\t\ttestHarness.processElement(new Watermark(initialTime + 4), 2, 0);\n+\t\t\texpectedOutput.add(new Watermark(initialTime + 4));\n+\t\t\tassertThat(testHarness.getOutput(), contains(expectedOutput.toArray()));\n+\n+\t\t\t// test whether idle input channels are acknowledged correctly when forwarding watermarks\n+\t\t\ttestHarness.processElement(StreamStatus.IDLE, 0, 1);", "originalCommit": "d5724d23c3827de7c9bfee1b24d3d091ffd1a606", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk4ODkzNg==", "url": "https://github.com/apache/flink/pull/11467#discussion_r396988936", "bodyText": "SingleInputTestOperator?", "author": "AHeise", "createdAt": "2020-03-24T08:53:39Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/api/operators/AbstractStreamOperatorV2Test.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.operators;\n+\n+import org.apache.flink.api.common.state.ValueStateDescriptor;\n+import org.apache.flink.api.common.typeinfo.BasicTypeInfo;\n+import org.apache.flink.api.common.typeutils.base.StringSerializer;\n+import org.apache.flink.api.java.tuple.Tuple2;\n+import org.apache.flink.runtime.state.VoidNamespace;\n+import org.apache.flink.runtime.state.VoidNamespaceSerializer;\n+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;\n+import org.apache.flink.streaming.util.KeyedOneInputStreamOperatorTestHarness;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Tests for the facilities provided by {@link AbstractStreamOperatorV2}.\n+ */\n+public class AbstractStreamOperatorV2Test extends AbstractStreamOperatorTest {\n+\t@Override\n+\tprotected KeyedOneInputStreamOperatorTestHarness<Integer, Tuple2<Integer, String>, String> createTestHarness(\n+\t\t\tint maxParalelism,\n+\t\t\tint numSubtasks,\n+\t\t\tint subtaskIndex) throws Exception {\n+\t\treturn new KeyedOneInputStreamOperatorTestHarness<>(\n+\t\t\tnew TestOperatorFactory(),\n+\t\t\tnew TestKeySelector(),\n+\t\t\tBasicTypeInfo.INT_TYPE_INFO,\n+\t\t\tmaxParalelism,\n+\t\t\tnumSubtasks,\n+\t\t\tsubtaskIndex);\n+\t}\n+\n+\tprivate static class TestOperatorFactory extends AbstractStreamOperatorFactory<String> {\n+\t\t@Override\n+\t\tpublic <T extends StreamOperator<String>> T createStreamOperator(StreamOperatorParameters<String> parameters) {\n+\t\t\treturn (T) new TestOperator(parameters);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<? extends StreamOperator> getStreamOperatorClass(ClassLoader classLoader) {\n+\t\t\treturn TestOperator.class;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Testing operator that can respond to commands by either setting/deleting state, emitting\n+\t * state or setting timers.\n+\t */\n+\tprivate static class TestOperator", "originalCommit": "38b21822ac6849d08673b815d0446fbe327ca157", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk5MDE1OA==", "url": "https://github.com/apache/flink/pull/11467#discussion_r396990158", "bodyText": "These refactorings could probably also go into previous commit.", "author": "AHeise", "createdAt": "2020-03-24T08:55:38Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/util/OneInputStreamOperatorTestHarness.java", "diffHunk": "@@ -40,6 +48,9 @@\n public class OneInputStreamOperatorTestHarness<IN, OUT>", "originalCommit": "38b21822ac6849d08673b815d0446fbe327ca157", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNzg5MA==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397127890", "bodyText": "Previous commit has a small value on it's own and it's pure refactor. Changes in this file are adding new feature, which are required required by AbstractStreamOperatorV2Test, while without it, they are a dead/unnecessary code. (That's why I bundled them in this commit not the previous one)", "author": "pnowojski", "createdAt": "2020-03-24T12:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk5MDE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwMDYwNw==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397000607", "bodyText": "Can you double-check if this code is already in master or if the formatting fixes could be squashed?", "author": "AHeise", "createdAt": "2020-03-24T09:13:00Z", "path": "flink-streaming-java/src/test/java/org/apache/flink/streaming/runtime/tasks/MultipleInputStreamTaskTest.java", "diffHunk": "@@ -385,12 +386,12 @@ public void testInputFairness() throws Exception {\n \t@Test\n \tpublic void testWatermarkAndStreamStatusForwarding() throws Exception {\n \t\ttry (StreamTaskMailboxTestHarness<String> testHarness =\n-\t\t\t\t new MultipleInputStreamTaskTestHarnessBuilder<>(MultipleInputStreamTask::new, BasicTypeInfo.STRING_TYPE_INFO)", "originalCommit": "e4659f0c4ef7afa42a6a67e3c2e1eeb73db02e57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyOTQ2Ng==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397129466", "bodyText": "Ops, you are right. It should have been squashed with something else. It can not be in the master, as the check style would fail the build.\nFixed, previous commit in this PR was introducing this change.", "author": "pnowojski", "createdAt": "2020-03-24T12:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwMDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwNDg5MA==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397004890", "bodyText": "Can't that extend MultipleInputTransformation to get rid of AbstractMultipleInputTransformation?", "author": "AHeise", "createdAt": "2020-03-24T09:19:46Z", "path": "flink-streaming-java/src/main/java/org/apache/flink/streaming/api/transformations/KeyedMultipleInputTransformation.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.flink.streaming.api.transformations;\n+\n+import org.apache.flink.annotation.Internal;\n+import org.apache.flink.api.common.typeinfo.TypeInformation;\n+import org.apache.flink.api.dag.Transformation;\n+import org.apache.flink.api.java.functions.KeySelector;\n+import org.apache.flink.streaming.api.operators.StreamOperatorFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * {@link AbstractMultipleInputTransformation} implementation for keyed streams.\n+ */\n+@Internal\n+public class KeyedMultipleInputTransformation<OUT> extends AbstractMultipleInputTransformation<OUT> {", "originalCommit": "e4659f0c4ef7afa42a6a67e3c2e1eeb73db02e57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyOTA1Mw==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397129053", "bodyText": "It could (and initially it was like that), but in that case wouldn't  MultipleConnectedStreams look strange?", "author": "pnowojski", "createdAt": "2020-03-24T12:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwNDg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQxMTA3Nw==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397411077", "bodyText": "Hm I cannot follow. MultipleConnectedStreams is taking a MultipleInputTransformation being keyed or not, so not sure what is strange looking.\nThe main question to answer is if the hierarchy is proper: is KeyedMultipleInputTransformation really a MultipleInputTransformation? I'd say it is.\nI find the instanceof checks against AbstractMultipleInputTransformation stranger.", "author": "AHeise", "createdAt": "2020-03-24T19:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwNDg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ0MTkxNg==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397441916", "bodyText": "Ok, I remember the real reason why I introduced Abstract - keyed and non-keyed have different addInput methods, with different signature. If we make KeyedMultipleInputTransformation extends MultipleInputTransformation, we would drop compile time checks for correct addInput method calls in favour of runtime checks.", "author": "pnowojski", "createdAt": "2020-03-24T20:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwNDg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ0NTc2MA==", "url": "https://github.com/apache/flink/pull/11467#discussion_r397445760", "bodyText": "Okay, that makes sense. I haven't spotted that difference and I don't see a good workaround for that (except ugly generics). Related remark, how about makes the addInputs builder style with self return?", "author": "AHeise", "createdAt": "2020-03-24T20:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAwNDg5MA=="}], "type": "inlineReview"}, {"oid": "3ab3a90af4620dd236e4789ff28a81bf39317dc9", "url": "https://github.com/apache/flink/commit/3ab3a90af4620dd236e4789ff28a81bf39317dc9", "message": "[FLINK-16317][operators] Provide support for key selector and latency marker in MultipleInputStreamOperator", "committedDate": "2020-03-24T12:59:02Z", "type": "forcePushed"}, {"oid": "ff6dc0129cbeb2e9d13fdef11c4c365aeae42632", "url": "https://github.com/apache/flink/commit/ff6dc0129cbeb2e9d13fdef11c4c365aeae42632", "message": "[FLINK-16317][operators] return this from (Keyed)MultipleInputTransformation#addInput", "committedDate": "2020-03-25T07:54:06Z", "type": "forcePushed"}, {"oid": "4eef97dd31b15a79442b834490ca525fce0f4fd1", "url": "https://github.com/apache/flink/commit/4eef97dd31b15a79442b834490ca525fce0f4fd1", "message": "[hotfix][tests] Remove dead code", "committedDate": "2020-03-25T14:08:37Z", "type": "commit"}, {"oid": "71627278606049930027247036f0d34d165c8bba", "url": "https://github.com/apache/flink/commit/71627278606049930027247036f0d34d165c8bba", "message": "[FLINK-16317][operators] Provide support for watermarks in  MultipleInputStreamOperator", "committedDate": "2020-03-25T14:08:38Z", "type": "commit"}, {"oid": "7e29c88c280346dc5b6654306910a7ba1232dd9e", "url": "https://github.com/apache/flink/commit/7e29c88c280346dc5b6654306910a7ba1232dd9e", "message": "[FLINK-16317][operators] Refactor AbstractStreamOperatorTest class\n\nThis deduplicates code a little bit, fixes not closing issue and makes it ready for future extension that comes in next commit.", "committedDate": "2020-03-25T14:08:39Z", "type": "commit"}, {"oid": "63e07841f570e701e1f4ead07701eac4043e294f", "url": "https://github.com/apache/flink/commit/63e07841f570e701e1f4ead07701eac4043e294f", "message": "[FLINK-16317][operators] Implement AbstractStreamOperatorV2Test", "committedDate": "2020-03-25T14:08:41Z", "type": "commit"}, {"oid": "cfd0607cfc1fabdc657edcc4400dfd6252a26526", "url": "https://github.com/apache/flink/commit/cfd0607cfc1fabdc657edcc4400dfd6252a26526", "message": "[FLINK-16317][operators] Provide support for key selector and latency marker in MultipleInputStreamOperator", "committedDate": "2020-03-25T14:08:42Z", "type": "commit"}, {"oid": "9d6fbaaa22110e59ecba8c36959d28dbfaa6d587", "url": "https://github.com/apache/flink/commit/9d6fbaaa22110e59ecba8c36959d28dbfaa6d587", "message": "[FLINK-16317][operators] return this from (Keyed)MultipleInputTransformation#addInput", "committedDate": "2020-03-25T14:08:43Z", "type": "commit"}, {"oid": "9d6fbaaa22110e59ecba8c36959d28dbfaa6d587", "url": "https://github.com/apache/flink/commit/9d6fbaaa22110e59ecba8c36959d28dbfaa6d587", "message": "[FLINK-16317][operators] return this from (Keyed)MultipleInputTransformation#addInput", "committedDate": "2020-03-25T14:08:43Z", "type": "forcePushed"}]}