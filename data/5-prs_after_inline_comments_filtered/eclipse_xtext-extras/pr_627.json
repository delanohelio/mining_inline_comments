{"pr_number": 627, "pr_title": "[eclipse/xtext#1777] ported xtend code to java", "pr_createdAt": "2020-07-13T13:42:15Z", "pr_url": "https://github.com/eclipse/xtext-extras/pull/627", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDMwOQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454294309", "bodyText": "You can put this two lines higher and remove line 49 as well", "author": "tivervac", "createdAt": "2020-07-14T11:39:53Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454294966", "bodyText": "There are lot of @Pure in the file that declares IntegerRange", "author": "tivervac", "createdAt": "2020-07-14T11:41:09Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxODUzMA==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454318530", "bodyText": "I guess you'll handle this in another MR? Don't see any changes now", "author": "tivervac", "createdAt": "2020-07-14T12:27:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyMjY1NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454322655", "bodyText": "? replaced it with a for loop ?!?", "author": "cdietrich", "createdAt": "2020-07-14T12:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNTY5NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454325695", "bodyText": "That also works \ud83d\udc4d\nWhat I meant by my comment is that the file that declares IntegerRange has already undergone the xtend->java process, but we forgot to remove the @Pure annotations so we should also get rid of those", "author": "tivervac", "createdAt": "2020-07-14T12:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNjM0NQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454326345", "bodyText": "no integerrange always was java. and its in xbase lib. thus keep the pure for xtend (only) users", "author": "cdietrich", "createdAt": "2020-07-14T12:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMyNzAwMQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454327001", "bodyText": "I see, makes sense", "author": "tivervac", "createdAt": "2020-07-14T12:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTI5MQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295291", "bodyText": "No need for the intValue() AFAIK", "author": "tivervac", "createdAt": "2020-07-14T11:41:49Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTU4Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295582", "bodyText": "newLines++ or +=1?", "author": "tivervac", "createdAt": "2020-07-14T11:42:23Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxNTA4MQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454315081", "bodyText": "didnt wanna change this", "author": "cdietrich", "createdAt": "2020-07-14T12:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NTkxMw==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454295913", "bodyText": "You can just make this one else if", "author": "tivervac", "createdAt": "2020-07-14T11:43:08Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzAxNw==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297017", "bodyText": "Why is this a field? It's only used in one method", "author": "tivervac", "createdAt": "2020-07-14T11:45:21Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxMjY0Nw==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454312647", "bodyText": "refactoring error", "author": "cdietrich", "createdAt": "2020-07-14T12:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzU4NA==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297584", "bodyText": "No need for booleanValue()", "author": "tivervac", "createdAt": "2020-07-14T11:46:28Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5NzYyMg==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454297622", "bodyText": "No need for booleanValue()", "author": "tivervac", "createdAt": "2020-07-14T11:46:32Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {\n+\t\t\treturn (ILeafNode) current;\n+\t\t}\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (previous instanceof ILeafNode && matches.apply((ILeafNode) previous).booleanValue()) {", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5ODAxOA==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454298018", "bodyText": "Seems like a pretty useless comment to me", "author": "tivervac", "createdAt": "2020-07-14T11:47:22Z", "path": "org.eclipse.xtext.xbase/deprecated/org/eclipse/xtext/xbase/formatting/HiddenLeafAccess.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/**\n+ * Copyright (c) 2012, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.formatting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.xtext.formatting2.regionaccess.ITextRegionAccess;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.ILeafNode;\n+import org.eclipse.xtext.nodemodel.INode;\n+import org.eclipse.xtext.parsetree.reconstr.impl.NodeIterator;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.IntegerRange;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+\n+/**\n+ * @deprecated use {@link ITextRegionAccess}\n+ */\n+@Deprecated\n+public class HiddenLeafAccess {\n+\t@Inject\n+\tprivate NodeModelAccess nodeModelAccess;\n+\tprivate int offset;\n+\n+\tpublic HiddenLeafs getHiddenLeafsBefore(INode node) {\n+\t\tILeafNode start = nodeModelAccess.findNextLeaf(node, l -> !l.isHidden());\n+\t\tList<ILeafNode> nodes = this.findPreviousHiddenLeafs(start);\n+\t\tif (start != null) {\n+\t\t\tint offset = 0;\n+\t\t\tif (nodes.isEmpty()) {\n+\t\t\t\toffset = start.getOffset();\n+\t\t\t} else {\n+\t\t\t\toffset = IterableExtensions.head(nodes).getOffset();\n+\t\t\t}\n+\t\t\treturn newHiddenLeafs(offset, nodes);\n+\t\t} else {\n+\t\t\tint offset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected HiddenLeafs newHiddenLeafs(int offset, List<ILeafNode> nodes) {\n+\t\tHiddenLeafs result = new HiddenLeafs(offset);\n+\t\tboolean trailing = true;\n+\t\tfor (ILeafNode node : nodes) {\n+\t\t\tboolean comment = false;\n+\t\t\tint newLines = 0;\n+\t\t\tif (!Strings.isNullOrEmpty(node.getText())) {\n+\t\t\t\tfor (Integer i : new IntegerRange(0, node.getText().length() - 1)) {\n+\t\t\t\t\tchar c = node.getText().charAt((i).intValue());\n+\t\t\t\t\tif ('\\n' == c) {\n+\t\t\t\t\t\tnewLines = newLines + 1;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (!Character.isWhitespace(c)) {\n+\t\t\t\t\t\t\tcomment = true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (comment) {\n+\t\t\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, node.getOffset()));\n+\t\t\t\t}\n+\t\t\t\tresult.getLeafs().add(new CommentInfo(result, node, newLines, trailing));\n+\t\t\t} else {\n+\t\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, node, newLines, node.getOffset()));\n+\t\t\t}\n+\t\t\tif (newLines > 0) {\n+\t\t\t\ttrailing = false;\n+\t\t\t}\n+\t\t}\n+\t\tif (!(IterableExtensions.last(result.getLeafs()) instanceof WhitespaceInfo)) {\n+\t\t\tint whitespaceOffset = 0;\n+\t\t\tif (result.getLeafs().isEmpty()) {\n+\t\t\t\twhitespaceOffset = offset;\n+\t\t\t} else {\n+\t\t\t\twhitespaceOffset = IterableExtensions.last(result.getLeafs()).getNode().getEndOffset();\n+\t\t\t}\n+\t\t\tresult.getLeafs().add(new WhitespaceInfo(result, null, 0, whitespaceOffset));\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tpublic HiddenLeafs getHiddenLeafsAfter(INode node) {\n+\t\tILeafNode start = findPreviousLeaf(node, l -> !l.isHidden());\n+\t\tif (start != null) {\n+\t\t\treturn newHiddenLeafs(start.getEndOffset(), findNextHiddenLeafs(start));\n+\t\t} else {\n+\t\t\toffset = 0;\n+\t\t\tif (node != null) {\n+\t\t\t\toffset = node.getOffset();\n+\t\t\t}\n+\t\t\treturn new HiddenLeafs(offset);\n+\t\t}\n+\t}\n+\n+\tprotected List<ILeafNode> findNextHiddenLeafs(INode node) {\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tNodeIterator ni = new NodeIterator(node);\n+\t\twhile (ni.hasNext()) {\n+\t\t\tINode next = ni.next();\n+\t\t\tif (next instanceof ILeafNode) {\n+\t\t\t\tif (((ILeafNode) next).isHidden()) {\n+\t\t\t\t\tresult.add((ILeafNode) next);\n+\t\t\t\t} else {\n+\t\t\t\t\treturn result;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tprotected ILeafNode findPreviousLeaf(INode node, Function1<? super ILeafNode, ? extends Boolean> matches) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tif (current instanceof ILeafNode && matches.apply((ILeafNode) current).booleanValue()) {\n+\t\t\treturn (ILeafNode) current;\n+\t\t}\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (previous instanceof ILeafNode && matches.apply((ILeafNode) previous).booleanValue()) {\n+\t\t\t\t\treturn (ILeafNode) previous;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprotected List<ILeafNode> findPreviousHiddenLeafs(INode node) {\n+\t\tINode current = node;\n+\t\twhile (current instanceof ICompositeNode) {\n+\t\t\tcurrent = ((ICompositeNode) current).getLastChild();\n+\t\t}\n+\t\tList<ILeafNode> result = new ArrayList<>();\n+\t\tif (current != null) {\n+\t\t\tNodeIterator ni = new NodeIterator(current);\n+\t\t\twhile (ni.hasPrevious()) {\n+\t\t\t\tINode previous = ni.previous();\n+\t\t\t\tif (!Objects.equal(previous, current) && previous instanceof ILeafNode) {\n+\t\t\t\t\tif (((ILeafNode) previous).isHidden()) {\n+\t\t\t\t\t\tresult.add((ILeafNode) previous);\n+\t\t\t\t\t} else { // if(!result.empty)", "originalCommit": "4d3466e109d2bc1296ef61158fdbccd412080f9c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMxMzA0OQ==", "url": "https://github.com/eclipse/xtext-extras/pull/627#discussion_r454313049", "bodyText": "did not want to loose it", "author": "cdietrich", "createdAt": "2020-07-14T12:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI5ODAxOA=="}], "type": "inlineReview"}, {"oid": "74ec6694b502020992034659f60e8efcae97393e", "url": "https://github.com/eclipse/xtext-extras/commit/74ec6694b502020992034659f60e8efcae97393e", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-14T12:17:47Z", "type": "commit"}, {"oid": "74ec6694b502020992034659f60e8efcae97393e", "url": "https://github.com/eclipse/xtext-extras/commit/74ec6694b502020992034659f60e8efcae97393e", "message": "[eclipse/xtext#1777] ported xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-07-14T12:17:47Z", "type": "forcePushed"}]}