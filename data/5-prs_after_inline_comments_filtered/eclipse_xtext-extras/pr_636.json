{"pr_number": 636, "pr_title": "Convert BatchLinkableResourceStorage implementations to Java", "pr_createdAt": "2020-08-05T12:24:29Z", "pr_url": "https://github.com/eclipse/xtext-extras/pull/636", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465689790", "bodyText": "api change?", "author": "cdietrich", "createdAt": "2020-08-05T12:28:47Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {", "originalCommit": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTIxMQ==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465699211", "bodyText": "You mean the declared ClassNotFoundException?", "author": "szarnekow", "createdAt": "2020-08-05T12:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMDA2Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465700062", "bodyText": "yes", "author": "cdietrich", "createdAt": "2020-08-05T12:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMTM4OA==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465701388", "bodyText": "Moved the catch clause into this method.", "author": "szarnekow", "createdAt": "2020-08-05T12:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY4OTc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465690849", "bodyText": "buffering?", "author": "cdietrich", "createdAt": "2020-08-05T12:30:46Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedInputStream;\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipInputStream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.common.types.JvmIdentifiableElement;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageLoadable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+public class BatchLinkableResourceStorageLoadable extends ResourceStorageLoadable {\n+\n+\tpublic BatchLinkableResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tsuper(in, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tsuper.loadEntries(resource, zipIn);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\ttry {\n+\t\t\t\treadAssociationsAdapter((BatchLinkableResource) resource, zipIn);\n+\t\t\t} catch(ClassNotFoundException e) {\n+\t\t\t\tthrow new IOException(e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleLoadEObject(loaded, input);\n+\t\tif (input.readBoolean()) {\n+\t\t\tDocumentationAdapter documentationAdapter = new DocumentationAdapter(input.readString());\n+\t\t\tloaded.eAdapters().add(documentationAdapter);\n+\t\t}\n+\t\tif (input.readBoolean()) {\n+\t\t\tJvmIdentifiableMetaData metaData = new JvmIdentifiableMetaData();\n+\t\t\tmetaData.setSynthetic(input.readBoolean());\n+\t\t\tloaded.eAdapters().add(metaData);\n+\t\t}\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected void readAssociationsAdapter(BatchLinkableResource resource, ZipInputStream stream) throws IOException, ClassNotFoundException {\n+\t\tJvmModelAssociator.Adapter adapter = FluentIterable.from(resource.eAdapters())\n+\t\t\t\t.filter(JvmModelAssociator.Adapter.class)\n+\t\t\t\t.first()\n+\t\t\t\t.or(()->{\n+\t\t\t\t\tJvmModelAssociator.Adapter newAdapter = new JvmModelAssociator.Adapter();\n+\t\t\t\t\tresource.eAdapters().add(newAdapter);\n+\t\t\t\t\treturn newAdapter;\n+\t\t\t\t});\n+\t\t\n+\t\tstream.getNextEntry();\n+\t\t\n+\t\ttry (ObjectInputStream objIn = new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream)))) {\n+\t\t\tMap<String, String> logicalMap = (Map<String, String>) objIn.readObject();\n+\t\t\tlogicalMap.forEach((key, value)->{\n+\t\t\t\tadapter.logicalContainerMap.put(resource.getEObject(key), (JvmIdentifiableElement)resource.getEObject(value));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> sourceToTargetMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\tsourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tadapter.sourceToTargetMap.put(resource.getEObject(source), fragmentsToObjects(resource, targets));\n+\t\t\t});\n+\t\t\tMap<String, Set<String>> targetToSourceMap = (Map<String, Set<String>>) objIn.readObject();\n+\t\t\ttargetToSourceMap.forEach((target, sources)->{\n+\t\t\t\tadapter.targetToSourceMap.put(resource.getEObject(target), fragmentsToObjects(resource, sources)); \n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\tprivate Set<EObject> fragmentsToObjects(BatchLinkableResource resource, Set<String> fragments) {\n+\t\treturn FluentIterable.from(fragments)\n+\t\t.transform(resource::getEObject)\n+\t\t.copyInto(new LinkedHashSet<>());\n+\t}\n+\t\n+\tprivate static class NonClosingFilterInputStream extends FilterInputStream {", "originalCommit": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5OTQ5Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465699496", "bodyText": "Extend buffering instead of decorate buffering? Is that what you mean?", "author": "szarnekow", "createdAt": "2020-08-05T12:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMDI0Mw==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465700243", "bodyText": "the old used a bufferedInputstream", "author": "cdietrich", "createdAt": "2020-08-05T12:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwMTE0Ng==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465701146", "bodyText": "new ObjectInputStream(new NonClosingFilterInputStream(new BufferedInputStream(stream))) \nIt still does", "author": "szarnekow", "createdAt": "2020-08-05T12:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcwNDY5Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465704692", "bodyText": "looks like i missglanced this one", "author": "cdietrich", "createdAt": "2020-08-05T12:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MjYwNg==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465692606", "bodyText": "Qualification not needed", "author": "cdietrich", "createdAt": "2020-08-05T12:34:07Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageWritable.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmType;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageWritable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+import org.eclipse.xtext.xtype.XComputedTypeReference;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * @author Sven Efftinge\n+ */\n+public class BatchLinkableResourceStorageWritable extends ResourceStorageWritable {\n+\tprivate static final Logger LOG = Logger.getLogger(BatchLinkableResourceStorageWritable.class);\n+\n+\tpublic BatchLinkableResourceStorageWritable(OutputStream out, boolean storeNodeModel) {\n+\t\tsuper(out, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void writeEntries(StorageAwareResource resource, ZipOutputStream zipOut) throws IOException {\n+\t\tsuper.writeEntries(resource, zipOut);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\tzipOut.putNextEntry(new ZipEntry(\"associations\"));\n+\t\t\tBufferedOutputStream buffOut = new BufferedOutputStream(zipOut);\n+\t\t\ttry {\n+\t\t\t\twriteAssociationsAdapter((BatchLinkableResource) resource, buffOut);\n+\t\t\t} finally {\n+\t\t\t\tbuffOut.flush();\n+\t\t\t\tzipOut.closeEntry();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void beforeSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream writable)\n+\t\t\tthrows IOException {\n+\t\tsuper.beforeSaveEObject(object, writable);\n+\t\t// make sure lazy type references are computed\n+\t\tif (object instanceof XComputedTypeReference) {\n+\t\t\t((XComputedTypeReference) object).getType();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream out)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleSaveEObject(object, out);\n+\t\t\n+\t\tDocumentationAdapter documentationAdapter = null;\n+\t\tJvmIdentifiableMetaData metaDataAdapter = null;\n+\t\tfor (Adapter adapter : object.eAdapters()) {\n+\t\t\tif (adapter instanceof DocumentationAdapter) {\n+\t\t\t\tdocumentationAdapter = (DocumentationAdapter) adapter;\n+\t\t\t}\n+\t\t\tif (adapter instanceof JvmIdentifiableMetaData) {\n+\t\t\t\tmetaDataAdapter = (JvmIdentifiableMetaData) adapter;\n+\t\t\t}\n+\t\t}\n+\t\t// store Documentation adapters\n+\t\tif (documentationAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeString(documentationAdapter.getDocumentation());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t\t// store additional meta data\n+\t\tif (metaDataAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeBoolean(metaDataAdapter.isSynthetic());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t}\n+\n+\tprotected void writeAssociationsAdapter(BatchLinkableResource resource, OutputStream zipOut) throws IOException {\n+\t\tJvmModelAssociator.Adapter adapter = (org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator.Adapter) EcoreUtil.getExistingAdapter(resource, JvmModelAssociator.Adapter.class);", "originalCommit": "9747e35fe3c526fd0ecf869fecbeaccf18cb5bd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "44de69ca0c89bad86047d838950b3f5d01a2e223", "url": "https://github.com/eclipse/xtext-extras/commit/44de69ca0c89bad86047d838950b3f5d01a2e223", "message": "Xtend2Java", "committedDate": "2020-08-05T12:49:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNDc1MA==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465714750", "bodyText": "do we need a since?", "author": "cdietrich", "createdAt": "2020-08-05T13:10:38Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/compiler/DocumentationAdapter.java", "diffHunk": "@@ -16,6 +16,13 @@\n public class DocumentationAdapter extends AdapterImpl {\n \n \tprivate String documentation;\n+\t\n+\tpublic DocumentationAdapter(String documentation) {", "originalCommit": "44de69ca0c89bad86047d838950b3f5d01a2e223", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjI0NzIwNA==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r466247204", "bodyText": "Added", "author": "szarnekow", "createdAt": "2020-08-06T08:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNTYwNA==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465715604", "bodyText": "wrong map?", "author": "cdietrich", "createdAt": "2020-08-05T13:12:02Z", "path": "org.eclipse.xtext.xbase/src/org/eclipse/xtext/xbase/resource/BatchLinkableResourceStorageWritable.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xbase.resource;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.common.types.JvmType;\n+import org.eclipse.xtext.resource.persistence.ResourceStorageWritable;\n+import org.eclipse.xtext.resource.persistence.StorageAwareResource;\n+import org.eclipse.xtext.xbase.compiler.DocumentationAdapter;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmIdentifiableMetaData;\n+import org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator;\n+import org.eclipse.xtext.xtype.XComputedTypeReference;\n+\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * @author Sven Efftinge\n+ */\n+public class BatchLinkableResourceStorageWritable extends ResourceStorageWritable {\n+\tprivate static final Logger LOG = Logger.getLogger(BatchLinkableResourceStorageWritable.class);\n+\n+\tpublic BatchLinkableResourceStorageWritable(OutputStream out, boolean storeNodeModel) {\n+\t\tsuper(out, storeNodeModel);\n+\t}\n+\n+\t@Override\n+\tprotected void writeEntries(StorageAwareResource resource, ZipOutputStream zipOut) throws IOException {\n+\t\tsuper.writeEntries(resource, zipOut);\n+\t\tif (resource instanceof BatchLinkableResource) {\n+\t\t\tzipOut.putNextEntry(new ZipEntry(\"associations\"));\n+\t\t\tBufferedOutputStream buffOut = new BufferedOutputStream(zipOut);\n+\t\t\ttry {\n+\t\t\t\twriteAssociationsAdapter((BatchLinkableResource) resource, buffOut);\n+\t\t\t} finally {\n+\t\t\t\tbuffOut.flush();\n+\t\t\t\tzipOut.closeEntry();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void beforeSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream writable)\n+\t\t\tthrows IOException {\n+\t\tsuper.beforeSaveEObject(object, writable);\n+\t\t// make sure lazy type references are computed\n+\t\tif (object instanceof XComputedTypeReference) {\n+\t\t\t((XComputedTypeReference) object).getType();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tprotected void handleSaveEObject(InternalEObject object, BinaryResourceImpl.EObjectOutputStream out)\n+\t\t\tthrows IOException {\n+\t\tsuper.handleSaveEObject(object, out);\n+\t\t\n+\t\tDocumentationAdapter documentationAdapter = null;\n+\t\tJvmIdentifiableMetaData metaDataAdapter = null;\n+\t\tfor (Adapter adapter : object.eAdapters()) {\n+\t\t\tif (adapter instanceof DocumentationAdapter) {\n+\t\t\t\tdocumentationAdapter = (DocumentationAdapter) adapter;\n+\t\t\t}\n+\t\t\tif (adapter instanceof JvmIdentifiableMetaData) {\n+\t\t\t\tmetaDataAdapter = (JvmIdentifiableMetaData) adapter;\n+\t\t\t}\n+\t\t}\n+\t\t// store Documentation adapters\n+\t\tif (documentationAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeString(documentationAdapter.getDocumentation());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t\t// store additional meta data\n+\t\tif (metaDataAdapter != null) {\n+\t\t\tout.writeBoolean(true);\n+\t\t\tout.writeBoolean(metaDataAdapter.isSynthetic());\n+\t\t} else {\n+\t\t\tout.writeBoolean(false);\n+\t\t}\n+\t}\n+\n+\tprotected void writeAssociationsAdapter(BatchLinkableResource resource, OutputStream zipOut) throws IOException {\n+\t\tJvmModelAssociator.Adapter adapter = (JvmModelAssociator.Adapter) EcoreUtil.getExistingAdapter(resource, JvmModelAssociator.Adapter.class);\n+\t\tif (adapter == null) {\n+\t\t\tfor(int i = 1, max = resource.getContents().size(); i < max; i++) {\n+\t\t\t\tif (resource.getContents().get(i) instanceof JvmType) {\n+\t\t\t\t\tthrow new IOException(\"Missing JvmModelAssociator.Adapter but resource contains inferred types: \" + resource.getURI());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tadapter = new JvmModelAssociator.Adapter();\n+\t\t}\n+\t\ttry (ObjectOutputStream objOut = new ObjectOutputStream(zipOut) {\n+\t\t\t@Override\n+\t\t\tpublic void close() throws IOException {\n+\t\t\t\tflush();\n+\t\t\t}\n+\t\t}) {\n+\t\t\t// logicalMap\n+\t\t\tMap<String, String> logicalMap = new LinkedHashMap<>();\n+\t\t\tadapter.logicalContainerMap.forEach((key, value)->{\n+\t\t\t\tlogIfResourceMismatch(resource, key);\n+\t\t\t\tlogicalMap.put(getFragment(key), getFragment(value));\n+\t\t\t});\n+\t\t\tobjOut.writeObject(logicalMap);\n+\t\t\t\n+\t\t\t// sourceToTarget\n+\t\t\tMap<String, Set<String>> sourceToTarget = new LinkedHashMap<>();\n+\t\t\tadapter.sourceToTargetMap.forEach((source, targets)->{\n+\t\t\t\tlogIfResourceMismatch(resource, source);\n+\t\t\t\tsourceToTarget.put(getFragment(source), objectsToFragments(targets));\n+\t\t\t});\n+\t\t\tobjOut.writeObject(sourceToTarget);\n+\t\t\t\n+\t\t\t// targetToSource\n+\t\t\tMap<String, Set<String>> targetToSource = new LinkedHashMap<>();\n+\t\t\tadapter.sourceToTargetMap.forEach((target, sources)->{", "originalCommit": "44de69ca0c89bad86047d838950b3f5d01a2e223", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc1Mzg5Mw==", "url": "https://github.com/eclipse/xtext-extras/pull/636#discussion_r465753893", "bodyText": "Excellent :)", "author": "szarnekow", "createdAt": "2020-08-05T14:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxNTYwNA=="}], "type": "inlineReview"}, {"oid": "cc3fc76cc714e4914b3ac1d02152d8d935527058", "url": "https://github.com/eclipse/xtext-extras/commit/cc3fc76cc714e4914b3ac1d02152d8d935527058", "message": "Organize imports", "committedDate": "2020-08-06T08:54:33Z", "type": "forcePushed"}, {"oid": "c113fa806cbebd2ee12d5545de7077bd5bd9d5e6", "url": "https://github.com/eclipse/xtext-extras/commit/c113fa806cbebd2ee12d5545de7077bd5bd9d5e6", "message": "Xtend2Java", "committedDate": "2020-08-06T14:21:00Z", "type": "commit"}, {"oid": "c113fa806cbebd2ee12d5545de7077bd5bd9d5e6", "url": "https://github.com/eclipse/xtext-extras/commit/c113fa806cbebd2ee12d5545de7077bd5bd9d5e6", "message": "Xtend2Java", "committedDate": "2020-08-06T14:21:00Z", "type": "forcePushed"}]}