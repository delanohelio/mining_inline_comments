{"pr_number": 591, "pr_title": "[eclipse/xtext#1679]ported more code to java", "pr_createdAt": "2020-04-24T10:30:32Z", "pr_url": "https://github.com/eclipse/xtext-extras/pull/591", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYwMjM1Mg==", "url": "https://github.com/eclipse/xtext-extras/pull/591#discussion_r414602352", "bodyText": "Same list as above -> resourceContentsList.clear()", "author": "szarnekow", "createdAt": "2020-04-24T14:05:09Z", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaDerivedStateComputer.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.ImportReference;\n+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.parser.Parser;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmTypeParameter;\n+import org.eclipse.xtext.common.types.TypesFactory;\n+import org.eclipse.xtext.common.types.access.binary.BinaryClass;\n+import org.eclipse.xtext.common.types.access.binary.asm.ClassFileBytesAccess;\n+import org.eclipse.xtext.common.types.access.binary.asm.JvmDeclaredTypeBuilder;\n+import org.eclipse.xtext.common.types.descriptions.EObjectDescriptionBasedStubGenerator;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.parser.antlr.IReferableElementsUnloader;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.inject.Inject;\n+\n+public class JavaDerivedStateComputer {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaDerivedStateComputer.class);\n+\n+\t@Inject\n+\tprivate IReferableElementsUnloader unloader;\n+\n+\t@Inject\n+\tprivate EObjectDescriptionBasedStubGenerator stubGenerator;\n+\n+\t@Inject\n+\tprivate IResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\tpublic void discardDerivedState(Resource resource) {\n+\t\tEList<EObject> resourcesContentsList = resource.getContents();\n+\t\tfor (EObject eObject : resourcesContentsList) {\n+\t\t\tunloader.unloadRoot(eObject);\n+\t\t}\n+\t\tresource.getContents().clear();", "originalCommit": "7cb0404a6bfd7f11df37c795c17c83c153849fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYwMzE1MQ==", "url": "https://github.com/eclipse/xtext-extras/pull/591#discussion_r414603151", "bodyText": "org.eclipse.jdt.core.compiler.CharOperation.toString(char[][]) ?", "author": "szarnekow", "createdAt": "2020-04-24T14:06:16Z", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaDerivedStateComputer.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.ImportReference;\n+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.parser.Parser;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmTypeParameter;\n+import org.eclipse.xtext.common.types.TypesFactory;\n+import org.eclipse.xtext.common.types.access.binary.BinaryClass;\n+import org.eclipse.xtext.common.types.access.binary.asm.ClassFileBytesAccess;\n+import org.eclipse.xtext.common.types.access.binary.asm.JvmDeclaredTypeBuilder;\n+import org.eclipse.xtext.common.types.descriptions.EObjectDescriptionBasedStubGenerator;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.parser.antlr.IReferableElementsUnloader;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.inject.Inject;\n+\n+public class JavaDerivedStateComputer {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaDerivedStateComputer.class);\n+\n+\t@Inject\n+\tprivate IReferableElementsUnloader unloader;\n+\n+\t@Inject\n+\tprivate EObjectDescriptionBasedStubGenerator stubGenerator;\n+\n+\t@Inject\n+\tprivate IResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\tpublic void discardDerivedState(Resource resource) {\n+\t\tEList<EObject> resourcesContentsList = resource.getContents();\n+\t\tfor (EObject eObject : resourcesContentsList) {\n+\t\t\tunloader.unloadRoot(eObject);\n+\t\t}\n+\t\tresource.getContents().clear();\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (getCompilationUnit(resource) != null) {\n+\t\t\tClassFileCache classFileCache = findOrCreateClassFileCache(resource.getResourceSet());\n+\t\t\tclassFileCache.addResourceToCompile(resource);\n+\t\t}\n+\t}\n+\n+\tpublic void installStubs(Resource resource) {\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tCompilationUnit compilationUnit = getCompilationUnit(resource);\n+\t\tProblemReporter problemReporter = new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),\n+\t\t\t\tgetCompilerOptions(resource), new DefaultProblemFactory());\n+\t\tParser parser = new Parser(problemReporter, true);\n+\t\tCompilationResult compilationResult = new CompilationResult(compilationUnit, 0, 1, -1);\n+\t\tCompilationUnitDeclaration result = parser.dietParse(compilationUnit, compilationResult);\n+\t\tif (result.types != null) {\n+\t\t\tfor (TypeDeclaration type : result.types) {\n+\t\t\t\tImportReference currentPackage = result.currentPackage;\n+\t\t\t\tString packageName = null;\n+\t\t\t\tif (currentPackage != null) {\n+\t\t\t\t\tchar[][] importName = currentPackage.getImportName();\n+\t\t\t\t\tif (importName != null) {\n+\t\t\t\t\t\tpackageName = Arrays.stream(importName).map((a) -> String.valueOf(a))", "originalCommit": "7cb0404a6bfd7f11df37c795c17c83c153849fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYwNDUzMw==", "url": "https://github.com/eclipse/xtext-extras/pull/591#discussion_r414604533", "bodyText": "Unnecessary CollectionLiterals", "author": "szarnekow", "createdAt": "2020-04-24T14:08:15Z", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaDerivedStateComputer.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.ImportReference;\n+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.parser.Parser;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmTypeParameter;\n+import org.eclipse.xtext.common.types.TypesFactory;\n+import org.eclipse.xtext.common.types.access.binary.BinaryClass;\n+import org.eclipse.xtext.common.types.access.binary.asm.ClassFileBytesAccess;\n+import org.eclipse.xtext.common.types.access.binary.asm.JvmDeclaredTypeBuilder;\n+import org.eclipse.xtext.common.types.descriptions.EObjectDescriptionBasedStubGenerator;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.parser.antlr.IReferableElementsUnloader;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.inject.Inject;\n+\n+public class JavaDerivedStateComputer {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaDerivedStateComputer.class);\n+\n+\t@Inject\n+\tprivate IReferableElementsUnloader unloader;\n+\n+\t@Inject\n+\tprivate EObjectDescriptionBasedStubGenerator stubGenerator;\n+\n+\t@Inject\n+\tprivate IResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\tpublic void discardDerivedState(Resource resource) {\n+\t\tEList<EObject> resourcesContentsList = resource.getContents();\n+\t\tfor (EObject eObject : resourcesContentsList) {\n+\t\t\tunloader.unloadRoot(eObject);\n+\t\t}\n+\t\tresource.getContents().clear();\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (getCompilationUnit(resource) != null) {\n+\t\t\tClassFileCache classFileCache = findOrCreateClassFileCache(resource.getResourceSet());\n+\t\t\tclassFileCache.addResourceToCompile(resource);\n+\t\t}\n+\t}\n+\n+\tpublic void installStubs(Resource resource) {\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tCompilationUnit compilationUnit = getCompilationUnit(resource);\n+\t\tProblemReporter problemReporter = new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),\n+\t\t\t\tgetCompilerOptions(resource), new DefaultProblemFactory());\n+\t\tParser parser = new Parser(problemReporter, true);\n+\t\tCompilationResult compilationResult = new CompilationResult(compilationUnit, 0, 1, -1);\n+\t\tCompilationUnitDeclaration result = parser.dietParse(compilationUnit, compilationResult);\n+\t\tif (result.types != null) {\n+\t\t\tfor (TypeDeclaration type : result.types) {\n+\t\t\t\tImportReference currentPackage = result.currentPackage;\n+\t\t\t\tString packageName = null;\n+\t\t\t\tif (currentPackage != null) {\n+\t\t\t\t\tchar[][] importName = currentPackage.getImportName();\n+\t\t\t\t\tif (importName != null) {\n+\t\t\t\t\t\tpackageName = Arrays.stream(importName).map((a) -> String.valueOf(a))\n+\t\t\t\t\t\t\t\t.collect(Collectors.joining(\".\"));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tJvmDeclaredType jvmType = createType(type, packageName);\n+\t\t\t\tresource.getContents().add(jvmType);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic JvmDeclaredType createType(TypeDeclaration type, String packageName) {\n+\t\tJvmDeclaredType jvmType = null;\n+\t\tswitch (TypeDeclaration.kind(type.modifiers)) {\n+\t\tcase TypeDeclaration.CLASS_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmGenericType();\n+\t\t\tbreak;\n+\t\tcase TypeDeclaration.INTERFACE_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmGenericType();\n+\t\t\t((JvmGenericType) jvmType).setInterface(true);\n+\t\t\tbreak;\n+\t\tcase TypeDeclaration.ENUM_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmEnumerationType();\n+\t\t\tbreak;\n+\t\tcase TypeDeclaration.ANNOTATION_TYPE_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmAnnotationType();\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Cannot handle type \" + type.toString());\n+\t\t}\n+\t\tjvmType.setPackageName(packageName);\n+\t\tjvmType.setSimpleName(String.valueOf(type.name));\n+\t\tif (jvmType instanceof JvmGenericType) {\n+\t\t\tif (type.typeParameters != null) {\n+\t\t\t\tfor (TypeParameter typeParam : type.typeParameters) {\n+\t\t\t\t\tJvmTypeParameter jvmTypeParam = TypesFactory.eINSTANCE.createJvmTypeParameter();\n+\t\t\t\t\tjvmTypeParam.setName(String.valueOf(typeParam.name));\n+\t\t\t\t\t((JvmGenericType) jvmType).getTypeParameters().add(jvmTypeParam);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (type.memberTypes != null) {\n+\t\t\tfor (TypeDeclaration nestedType : type.memberTypes) {\n+\t\t\t\tJvmDeclaredType nested = createType(nestedType, null);\n+\t\t\t\tjvmType.getMembers().add(nested);\n+\t\t\t}\n+\t\t}\n+\t\treturn jvmType;\n+\t}\n+\n+\tpublic CompilationUnit getCompilationUnit(Resource resource) {\n+\t\treturn ((JavaResource) resource).getCompilationUnit();\n+\t}\n+\n+\tprotected ClassFileCache findOrCreateClassFileCache(ResourceSet rs) {\n+\t\tClassFileCache cache = ClassFileCache.findInEmfObject(rs);\n+\t\tif (cache == null) {\n+\t\t\tcache = new ClassFileCache();\n+\t\t\tcache.attachToEmfObject(rs);\n+\t\t}\n+\t\treturn cache;\n+\t}\n+\n+\tpublic void installFull(Resource resource) {\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tClassFileCache classFileCache = findOrCreateClassFileCache(resource.getResourceSet());\n+\t\tCompilationUnit compilationUnit = getCompilationUnit(resource);\n+\t\tClassLoader classLoader = getClassLoader(resource);\n+\t\tIResourceDescriptions data = resourceDescriptionsProvider.getResourceDescriptions(resource.getResourceSet());\n+\t\tif ((data == null)) {\n+\t\t\tthrow new IllegalStateException(\"No index installed\");\n+\t\t}\n+\t\tProcedure2<? super List<String>, ? super Map<String, byte[]>> initializer = (List<String> topLevelTypes,\n+\t\t\t\tMap<String, byte[]> classMap) -> {\n+\t\t\tInMemoryClassLoader inMemClassLoader = new InMemoryClassLoader(classMap, classLoader);\n+\t\t\tfor (String topLevel : topLevelTypes) {\n+\t\t\t\ttry {\n+\t\t\t\t\tBinaryClass binaryClass = new BinaryClass(topLevel, inMemClassLoader);\n+\t\t\t\t\tClassFileBytesAccess classFileBytesAccess = new ClassFileBytesAccess();\n+\t\t\t\t\tJvmDeclaredTypeBuilder builder = new JvmDeclaredTypeBuilder(binaryClass, classFileBytesAccess,\n+\t\t\t\t\t\t\tinMemClassLoader);\n+\t\t\t\t\tJvmDeclaredType type = builder.buildType();\n+\t\t\t\t\tresource.getContents().add(type);\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Could not load type '\" + topLevel + \"'\", t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\tboolean wasCached = classFileCache.popCompileResult(compilationUnit.fileName, initializer);\n+\t\tif (!wasCached) {\n+\t\t\tSet<CompilationUnit> unitsToCompile = classFileCache.drainResourcesToCompile().stream()\n+\t\t\t\t\t.map((r) -> getCompilationUnit(r)).collect(Collectors.toSet());\n+\t\t\tunitsToCompile.add(compilationUnit);\n+\t\t\tIndexAwareNameEnvironment nameEnv = new IndexAwareNameEnvironment(resource, classLoader, data,\n+\t\t\t\t\tstubGenerator, classFileCache);\n+\t\t\tICompilerRequestor compilerRequestor = new ICompilerRequestor() {\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic void acceptResult(CompilationResult result) {\n+\t\t\t\t\tfor (ClassFile cls : result.getClassFiles()) {\n+\t\t\t\t\t\tQualifiedName key = QualifiedName.create(CharOperation.toStrings(cls.getCompoundName()));\n+\t\t\t\t\t\tclassFileCache.computeIfAbsent(key, (QualifiedName name) -> {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\treturn new ClassFileReader(cls.getBytes(), cls.fileName());\n+\t\t\t\t\t\t\t} catch (Throwable e) {\n+\t\t\t\t\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t\tHashMap<String, byte[]> map = CollectionLiterals.<String, byte[]>newHashMap();", "originalCommit": "7cb0404a6bfd7f11df37c795c17c83c153849fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYwNDgwOA==", "url": "https://github.com/eclipse/xtext-extras/pull/591#discussion_r414604808", "bodyText": "unitsToCompile.toArray(..)", "author": "szarnekow", "createdAt": "2020-04-24T14:08:40Z", "path": "org.eclipse.xtext.java/src/org/eclipse/xtext/java/resource/JavaDerivedStateComputer.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.java.resource;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.EList;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.jdt.core.compiler.CharOperation;\n+import org.eclipse.jdt.internal.compiler.ClassFile;\n+import org.eclipse.jdt.internal.compiler.CompilationResult;\n+import org.eclipse.jdt.internal.compiler.DefaultErrorHandlingPolicies;\n+import org.eclipse.jdt.internal.compiler.ICompilerRequestor;\n+import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.ImportReference;\n+import org.eclipse.jdt.internal.compiler.ast.TypeDeclaration;\n+import org.eclipse.jdt.internal.compiler.ast.TypeParameter;\n+import org.eclipse.jdt.internal.compiler.batch.CompilationUnit;\n+import org.eclipse.jdt.internal.compiler.classfmt.ClassFileReader;\n+import org.eclipse.jdt.internal.compiler.env.ICompilationUnit;\n+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;\n+import org.eclipse.jdt.internal.compiler.parser.Parser;\n+import org.eclipse.jdt.internal.compiler.problem.DefaultProblemFactory;\n+import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;\n+import org.eclipse.xtext.common.types.JvmDeclaredType;\n+import org.eclipse.xtext.common.types.JvmGenericType;\n+import org.eclipse.xtext.common.types.JvmTypeParameter;\n+import org.eclipse.xtext.common.types.TypesFactory;\n+import org.eclipse.xtext.common.types.access.binary.BinaryClass;\n+import org.eclipse.xtext.common.types.access.binary.asm.ClassFileBytesAccess;\n+import org.eclipse.xtext.common.types.access.binary.asm.JvmDeclaredTypeBuilder;\n+import org.eclipse.xtext.common.types.descriptions.EObjectDescriptionBasedStubGenerator;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.parser.antlr.IReferableElementsUnloader;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.XtextResourceSet;\n+import org.eclipse.xtext.util.JavaVersion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.inject.Inject;\n+\n+public class JavaDerivedStateComputer {\n+\n+\tprivate static final Logger LOG = Logger.getLogger(JavaDerivedStateComputer.class);\n+\n+\t@Inject\n+\tprivate IReferableElementsUnloader unloader;\n+\n+\t@Inject\n+\tprivate EObjectDescriptionBasedStubGenerator stubGenerator;\n+\n+\t@Inject\n+\tprivate IResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\tpublic void discardDerivedState(Resource resource) {\n+\t\tEList<EObject> resourcesContentsList = resource.getContents();\n+\t\tfor (EObject eObject : resourcesContentsList) {\n+\t\t\tunloader.unloadRoot(eObject);\n+\t\t}\n+\t\tresource.getContents().clear();\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (getCompilationUnit(resource) != null) {\n+\t\t\tClassFileCache classFileCache = findOrCreateClassFileCache(resource.getResourceSet());\n+\t\t\tclassFileCache.addResourceToCompile(resource);\n+\t\t}\n+\t}\n+\n+\tpublic void installStubs(Resource resource) {\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tCompilationUnit compilationUnit = getCompilationUnit(resource);\n+\t\tProblemReporter problemReporter = new ProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),\n+\t\t\t\tgetCompilerOptions(resource), new DefaultProblemFactory());\n+\t\tParser parser = new Parser(problemReporter, true);\n+\t\tCompilationResult compilationResult = new CompilationResult(compilationUnit, 0, 1, -1);\n+\t\tCompilationUnitDeclaration result = parser.dietParse(compilationUnit, compilationResult);\n+\t\tif (result.types != null) {\n+\t\t\tfor (TypeDeclaration type : result.types) {\n+\t\t\t\tImportReference currentPackage = result.currentPackage;\n+\t\t\t\tString packageName = null;\n+\t\t\t\tif (currentPackage != null) {\n+\t\t\t\t\tchar[][] importName = currentPackage.getImportName();\n+\t\t\t\t\tif (importName != null) {\n+\t\t\t\t\t\tpackageName = Arrays.stream(importName).map((a) -> String.valueOf(a))\n+\t\t\t\t\t\t\t\t.collect(Collectors.joining(\".\"));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tJvmDeclaredType jvmType = createType(type, packageName);\n+\t\t\t\tresource.getContents().add(jvmType);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic JvmDeclaredType createType(TypeDeclaration type, String packageName) {\n+\t\tJvmDeclaredType jvmType = null;\n+\t\tswitch (TypeDeclaration.kind(type.modifiers)) {\n+\t\tcase TypeDeclaration.CLASS_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmGenericType();\n+\t\t\tbreak;\n+\t\tcase TypeDeclaration.INTERFACE_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmGenericType();\n+\t\t\t((JvmGenericType) jvmType).setInterface(true);\n+\t\t\tbreak;\n+\t\tcase TypeDeclaration.ENUM_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmEnumerationType();\n+\t\t\tbreak;\n+\t\tcase TypeDeclaration.ANNOTATION_TYPE_DECL:\n+\t\t\tjvmType = TypesFactory.eINSTANCE.createJvmAnnotationType();\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Cannot handle type \" + type.toString());\n+\t\t}\n+\t\tjvmType.setPackageName(packageName);\n+\t\tjvmType.setSimpleName(String.valueOf(type.name));\n+\t\tif (jvmType instanceof JvmGenericType) {\n+\t\t\tif (type.typeParameters != null) {\n+\t\t\t\tfor (TypeParameter typeParam : type.typeParameters) {\n+\t\t\t\t\tJvmTypeParameter jvmTypeParam = TypesFactory.eINSTANCE.createJvmTypeParameter();\n+\t\t\t\t\tjvmTypeParam.setName(String.valueOf(typeParam.name));\n+\t\t\t\t\t((JvmGenericType) jvmType).getTypeParameters().add(jvmTypeParam);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif (type.memberTypes != null) {\n+\t\t\tfor (TypeDeclaration nestedType : type.memberTypes) {\n+\t\t\t\tJvmDeclaredType nested = createType(nestedType, null);\n+\t\t\t\tjvmType.getMembers().add(nested);\n+\t\t\t}\n+\t\t}\n+\t\treturn jvmType;\n+\t}\n+\n+\tpublic CompilationUnit getCompilationUnit(Resource resource) {\n+\t\treturn ((JavaResource) resource).getCompilationUnit();\n+\t}\n+\n+\tprotected ClassFileCache findOrCreateClassFileCache(ResourceSet rs) {\n+\t\tClassFileCache cache = ClassFileCache.findInEmfObject(rs);\n+\t\tif (cache == null) {\n+\t\t\tcache = new ClassFileCache();\n+\t\t\tcache.attachToEmfObject(rs);\n+\t\t}\n+\t\treturn cache;\n+\t}\n+\n+\tpublic void installFull(Resource resource) {\n+\t\tif (isInfoFile(resource)) {\n+\t\t\treturn;\n+\t\t}\n+\t\tClassFileCache classFileCache = findOrCreateClassFileCache(resource.getResourceSet());\n+\t\tCompilationUnit compilationUnit = getCompilationUnit(resource);\n+\t\tClassLoader classLoader = getClassLoader(resource);\n+\t\tIResourceDescriptions data = resourceDescriptionsProvider.getResourceDescriptions(resource.getResourceSet());\n+\t\tif ((data == null)) {\n+\t\t\tthrow new IllegalStateException(\"No index installed\");\n+\t\t}\n+\t\tProcedure2<? super List<String>, ? super Map<String, byte[]>> initializer = (List<String> topLevelTypes,\n+\t\t\t\tMap<String, byte[]> classMap) -> {\n+\t\t\tInMemoryClassLoader inMemClassLoader = new InMemoryClassLoader(classMap, classLoader);\n+\t\t\tfor (String topLevel : topLevelTypes) {\n+\t\t\t\ttry {\n+\t\t\t\t\tBinaryClass binaryClass = new BinaryClass(topLevel, inMemClassLoader);\n+\t\t\t\t\tClassFileBytesAccess classFileBytesAccess = new ClassFileBytesAccess();\n+\t\t\t\t\tJvmDeclaredTypeBuilder builder = new JvmDeclaredTypeBuilder(binaryClass, classFileBytesAccess,\n+\t\t\t\t\t\t\tinMemClassLoader);\n+\t\t\t\t\tJvmDeclaredType type = builder.buildType();\n+\t\t\t\t\tresource.getContents().add(type);\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tthrow new IllegalStateException(\"Could not load type '\" + topLevel + \"'\", t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\tboolean wasCached = classFileCache.popCompileResult(compilationUnit.fileName, initializer);\n+\t\tif (!wasCached) {\n+\t\t\tSet<CompilationUnit> unitsToCompile = classFileCache.drainResourcesToCompile().stream()\n+\t\t\t\t\t.map((r) -> getCompilationUnit(r)).collect(Collectors.toSet());\n+\t\t\tunitsToCompile.add(compilationUnit);\n+\t\t\tIndexAwareNameEnvironment nameEnv = new IndexAwareNameEnvironment(resource, classLoader, data,\n+\t\t\t\t\tstubGenerator, classFileCache);\n+\t\t\tICompilerRequestor compilerRequestor = new ICompilerRequestor() {\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic void acceptResult(CompilationResult result) {\n+\t\t\t\t\tfor (ClassFile cls : result.getClassFiles()) {\n+\t\t\t\t\t\tQualifiedName key = QualifiedName.create(CharOperation.toStrings(cls.getCompoundName()));\n+\t\t\t\t\t\tclassFileCache.computeIfAbsent(key, (QualifiedName name) -> {\n+\t\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t\treturn new ClassFileReader(cls.getBytes(), cls.fileName());\n+\t\t\t\t\t\t\t} catch (Throwable e) {\n+\t\t\t\t\t\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t\tHashMap<String, byte[]> map = CollectionLiterals.<String, byte[]>newHashMap();\n+\t\t\t\t\tList<String> topLevelTypes = CollectionLiterals.<String>newArrayList();\n+\t\t\t\t\tfor (ClassFile cf : result.getClassFiles()) {\n+\t\t\t\t\t\tString className = CharOperation.toString(cf.getCompoundName());\n+\t\t\t\t\t\tmap.put(className, cf.getBytes());\n+\t\t\t\t\t\tif (!cf.isNestedType) {\n+\t\t\t\t\t\t\ttopLevelTypes.add(className);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (Arrays.equals(result.fileName, compilationUnit.fileName)) {\n+\t\t\t\t\t\tinitializer.apply(topLevelTypes, map);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tclassFileCache.addCompileResult(result.fileName, topLevelTypes, map);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t};\n+\t\t\tDefaultProblemFactory problemFactory = new DefaultProblemFactory();\n+\t\t\torg.eclipse.jdt.internal.compiler.Compiler compiler = new org.eclipse.jdt.internal.compiler.Compiler(\n+\t\t\t\t\tnameEnv, DefaultErrorHandlingPolicies.proceedWithAllProblems(), getCompilerOptions(resource),\n+\t\t\t\t\tcompilerRequestor, problemFactory);\n+\t\t\tcompiler.compile(((ICompilationUnit[]) Conversions.unwrapArray(unitsToCompile, ICompilationUnit.class)));", "originalCommit": "7cb0404a6bfd7f11df37c795c17c83c153849fe8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d4927a80f64d961d4f9f4414ae766c1ea4303ced", "url": "https://github.com/eclipse/xtext-extras/commit/d4927a80f64d961d4f9f4414ae766c1ea4303ced", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-24T14:19:17Z", "type": "forcePushed"}, {"oid": "6074837db0bfbe8ab39b1f020f81b7b45ef2125a", "url": "https://github.com/eclipse/xtext-extras/commit/6074837db0bfbe8ab39b1f020f81b7b45ef2125a", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-24T16:20:54Z", "type": "forcePushed"}, {"oid": "69039b4039425708661709451cbc0521a8f021b1", "url": "https://github.com/eclipse/xtext-extras/commit/69039b4039425708661709451cbc0521a8f021b1", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-24T17:20:57Z", "type": "forcePushed"}, {"oid": "56bed828f07aab2bd2adb050283492c9c1eb92fa", "url": "https://github.com/eclipse/xtext-extras/commit/56bed828f07aab2bd2adb050283492c9c1eb92fa", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-25T08:58:33Z", "type": "forcePushed"}, {"oid": "719118f3f6bf16f5a1bee73b64370a9111f9d3a2", "url": "https://github.com/eclipse/xtext-extras/commit/719118f3f6bf16f5a1bee73b64370a9111f9d3a2", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-25T09:16:47Z", "type": "commit"}, {"oid": "719118f3f6bf16f5a1bee73b64370a9111f9d3a2", "url": "https://github.com/eclipse/xtext-extras/commit/719118f3f6bf16f5a1bee73b64370a9111f9d3a2", "message": "[eclipse/xtext#1679]ported more code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-04-25T09:16:47Z", "type": "forcePushed"}]}