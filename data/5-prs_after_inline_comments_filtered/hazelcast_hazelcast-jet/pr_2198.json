{"pr_number": 2198, "pr_title": "Add toKeyFn/toValueFn to WriteMapP", "pr_createdAt": "2020-04-20T07:40:45Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2198", "timeline": [{"oid": "27d8e9850424f93df4dc70bce3c2b8f540cc2b18", "url": "https://github.com/hazelcast/hazelcast-jet/commit/27d8e9850424f93df4dc70bce3c2b8f540cc2b18", "message": "Add toKeyFn/toValueFn to WriteMapP, add convenience for HazelcastJsonValue", "committedDate": "2020-04-20T07:37:59Z", "type": "commit"}, {"oid": "d2663a3c6ff61add530ec5ce06fa5ef8004cdd4a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/d2663a3c6ff61add530ec5ce06fa5ef8004cdd4a", "message": "add since tag", "committedDate": "2020-04-20T07:42:35Z", "type": "commit"}, {"oid": "a9e423f638b4d2775662282abe7b8ecf00814771", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a9e423f638b4d2775662282abe7b8ecf00814771", "message": "fix default writeMapP", "committedDate": "2020-04-20T08:47:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQwODMyNQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2198#discussion_r411408325", "bodyText": "I don't think this overload adds much, and is a bit confusing. It should be enough to provide the function reference ? i.e. JsonUtil::asJson or something so I would just remove this variant and mention it in javadoc", "author": "cangencer", "createdAt": "2020-04-20T14:08:49Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sinks.java", "diffHunk": "@@ -109,7 +111,52 @@ private Sinks() {\n      */\n     @Nonnull\n     public static <K, V> Sink<Entry<K, V>> map(@Nonnull String mapName) {\n-        return new SinkImpl<>(\"mapSink(\" + mapName + ')', writeMapP(mapName), false, entryKey());\n+        return map(mapName, Entry::getKey, Entry::getValue);\n+    }\n+\n+    /**\n+     * Returns a sink that converts the key and value of {@code Map.Entry}s it\n+     * receives to {@link HazelcastJsonValue} and put them into a Hazelcast\n+     * {@code IMap} with the specified name.\n+     * <p>\n+     * This sink provides the exactly-once guarantee thanks to <i>idempotent\n+     * updates</i>. It means that the value with the same key is not appended,\n+     * but overwritten. After the job is restarted from snapshot, duplicate\n+     * items will not change the state in the target map.\n+     * <p>\n+     * The default local parallelism for this sink is 1.\n+     *\n+     * @since 4.1\n+     */\n+    @Nonnull\n+    public static <K, V> Sink<Entry<K, V>> map(@Nonnull String mapName, boolean jsonKey, boolean jsonValue) {", "originalCommit": "a9e423f638b4d2775662282abe7b8ecf00814771", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMTkyNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2198#discussion_r411411927", "bodyText": "should also be called item", "author": "cangencer", "createdAt": "2020-04-20T14:13:19Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/connector/WriteMapP.java", "diffHunk": "@@ -62,23 +70,31 @@ public void init(@Nonnull Outbox outbox, @Nonnull Context context) {\n \n         if (map instanceof MapProxyImpl) {\n             PartitioningStrategy<?> partitionStrategy = ((MapProxyImpl<K, V>) map).getPartitionStrategy();\n-            addToBuffer = entry -> {\n-                Data key = serializationService.toData(entry.getKey(), partitionStrategy);\n-                Data value = serializationService.toData(entry.getValue());\n+            addToBuffer = item -> {\n+                Data key = serializationService.toData(key(item), partitionStrategy);\n+                Data value = serializationService.toData(value(item));\n                 buffer.add(new SimpleEntry<>(key, value));\n             };\n         } else if (map instanceof ClientMapProxy) {\n             // TODO: add strategy/unify after https://github.com/hazelcast/hazelcast/issues/13950 is fixed\n             addToBuffer = entry -> {\n-                Data key = serializationService.toData(entry.getKey());\n-                Data value = serializationService.toData(entry.getValue());\n+                Data key = serializationService.toData(key(entry));", "originalCommit": "a9e423f638b4d2775662282abe7b8ecf00814771", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMzY5NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2198#discussion_r411413695", "bodyText": "missing overload for map(IMap<K,V>)..", "author": "cangencer", "createdAt": "2020-04-20T14:15:28Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sinks.java", "diffHunk": "@@ -109,7 +111,52 @@ private Sinks() {\n      */\n     @Nonnull\n     public static <K, V> Sink<Entry<K, V>> map(@Nonnull String mapName) {\n-        return new SinkImpl<>(\"mapSink(\" + mapName + ')', writeMapP(mapName), false, entryKey());\n+        return map(mapName, Entry::getKey, Entry::getValue);\n+    }\n+\n+    /**\n+     * Returns a sink that converts the key and value of {@code Map.Entry}s it\n+     * receives to {@link HazelcastJsonValue} and put them into a Hazelcast\n+     * {@code IMap} with the specified name.\n+     * <p>\n+     * This sink provides the exactly-once guarantee thanks to <i>idempotent\n+     * updates</i>. It means that the value with the same key is not appended,\n+     * but overwritten. After the job is restarted from snapshot, duplicate\n+     * items will not change the state in the target map.\n+     * <p>\n+     * The default local parallelism for this sink is 1.\n+     *\n+     * @since 4.1\n+     */\n+    @Nonnull\n+    public static <K, V> Sink<Entry<K, V>> map(@Nonnull String mapName, boolean jsonKey, boolean jsonValue) {\n+        return map(mapName,\n+                e -> jsonKey ? JsonUtil.hazelcastJsonValue(e.getKey()) : e.getKey(),\n+                e -> jsonValue ? JsonUtil.hazelcastJsonValue(e.getValue()) : e.getValue());\n+    }\n+\n+    /**\n+     * Returns a sink that uses the supplied functions to extract the key\n+     * and value with which to put to a Hazelcast {@code IMap}.\n+     * <p>\n+     * This sink provides the exactly-once guarantee thanks to <i>idempotent\n+     * updates</i>. It means that the value with the same key is not appended,\n+     * but overwritten. After the job is restarted from snapshot, duplicate\n+     * items will not change the state in the target map.\n+     * <p>\n+     * The default local parallelism for this sink is 1.\n+     *\n+     * @since 4.1\n+     */\n+    @Nonnull\n+    public static <T, K, V> Sink<T> map(", "originalCommit": "a9e423f638b4d2775662282abe7b8ecf00814771", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMzc2Ng==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2198#discussion_r411413766", "bodyText": "should be 4.2", "author": "cangencer", "createdAt": "2020-04-20T14:15:34Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/Sinks.java", "diffHunk": "@@ -109,7 +111,52 @@ private Sinks() {\n      */\n     @Nonnull\n     public static <K, V> Sink<Entry<K, V>> map(@Nonnull String mapName) {\n-        return new SinkImpl<>(\"mapSink(\" + mapName + ')', writeMapP(mapName), false, entryKey());\n+        return map(mapName, Entry::getKey, Entry::getValue);\n+    }\n+\n+    /**\n+     * Returns a sink that converts the key and value of {@code Map.Entry}s it\n+     * receives to {@link HazelcastJsonValue} and put them into a Hazelcast\n+     * {@code IMap} with the specified name.\n+     * <p>\n+     * This sink provides the exactly-once guarantee thanks to <i>idempotent\n+     * updates</i>. It means that the value with the same key is not appended,\n+     * but overwritten. After the job is restarted from snapshot, duplicate\n+     * items will not change the state in the target map.\n+     * <p>\n+     * The default local parallelism for this sink is 1.\n+     *\n+     * @since 4.1\n+     */\n+    @Nonnull\n+    public static <K, V> Sink<Entry<K, V>> map(@Nonnull String mapName, boolean jsonKey, boolean jsonValue) {\n+        return map(mapName,\n+                e -> jsonKey ? JsonUtil.hazelcastJsonValue(e.getKey()) : e.getKey(),\n+                e -> jsonValue ? JsonUtil.hazelcastJsonValue(e.getValue()) : e.getValue());\n+    }\n+\n+    /**\n+     * Returns a sink that uses the supplied functions to extract the key\n+     * and value with which to put to a Hazelcast {@code IMap}.\n+     * <p>\n+     * This sink provides the exactly-once guarantee thanks to <i>idempotent\n+     * updates</i>. It means that the value with the same key is not appended,\n+     * but overwritten. After the job is restarted from snapshot, duplicate\n+     * items will not change the state in the target map.\n+     * <p>\n+     * The default local parallelism for this sink is 1.\n+     *\n+     * @since 4.1", "originalCommit": "a9e423f638b4d2775662282abe7b8ecf00814771", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "82ce1eaf78cdddf0c5a75eae859055d2688fa102", "url": "https://github.com/hazelcast/hazelcast-jet/commit/82ce1eaf78cdddf0c5a75eae859055d2688fa102", "message": "address review comments", "committedDate": "2020-04-27T07:57:03Z", "type": "commit"}]}