{"pr_number": 2286, "pr_title": "[003] Elasticsearch 5 connector", "pr_createdAt": "2020-06-02T07:46:06Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2286", "timeline": [{"oid": "350190c1070f15730bc00286ebacb52b59c1ec70", "url": "https://github.com/hazelcast/hazelcast-jet/commit/350190c1070f15730bc00286ebacb52b59c1ec70", "message": "[003] Elasticsearch 5 connector", "committedDate": "2020-06-02T07:44:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNzQzOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r436537439", "bodyText": "I see that we have this obtaining RestClient via reflection at processor too. Maybe we can have it as a static utility method, in ElasticCatClient for example.", "author": "gurbuzali", "createdAt": "2020-06-08T08:36:23Z", "path": "extensions/elasticsearch/elasticsearch-5/src/main/java/com/hazelcast/jet/elastic/impl/ElasticSourcePMetaSupplier.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.elastic.impl;\n+\n+import com.hazelcast.cluster.Address;\n+import com.hazelcast.cluster.Member;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.core.ProcessorMetaSupplier;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.jet.core.processor.Processors;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestHighLevelClient;\n+\n+import javax.annotation.Nonnull;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.nCopies;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toSet;\n+\n+public class ElasticSourcePMetaSupplier<T> implements ProcessorMetaSupplier {\n+\n+    private static final long serialVersionUID = 1L;\n+    private static final int DEFAULT_LOCAL_PARALLELISM = 2;\n+\n+    @Nonnull\n+    private final ElasticSourceConfiguration<T> configuration;\n+\n+    private transient Map<Address, List<Shard>> assignedShards;\n+    private transient Address ownerAddress;\n+\n+    public ElasticSourcePMetaSupplier(@Nonnull ElasticSourceConfiguration<T> configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public int preferredLocalParallelism() {\n+        if (configuration.isCoLocatedReadingEnabled() || configuration.isSlicingEnabled()) {\n+            return DEFAULT_LOCAL_PARALLELISM;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    @Override\n+    public void init(@Nonnull Context context) throws Exception {\n+        RestHighLevelClient client = configuration.clientFn().get();", "originalCommit": "350190c1070f15730bc00286ebacb52b59c1ec70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3NzYyMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r440877622", "bodyText": "Done.", "author": "frant-hartm", "createdAt": "2020-06-16T14:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzNzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzOTg1Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r436539852", "bodyText": "why is this commented out ?", "author": "gurbuzali", "createdAt": "2020-06-08T08:40:46Z", "path": "extensions/elasticsearch/elasticsearch-5/src/test/java/com/hazelcast/jet/elastic/impl/ElasticSourcePTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 Hazelcast Inc.\n+ *\n+ * Licensed under the Hazelcast Community License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://hazelcast.com/hazelcast-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.elastic.impl;\n+\n+import com.hazelcast.jet.core.test.TestSupport;\n+import com.hazelcast.jet.elastic.impl.Shard.Prirep;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.search.SearchScrollRequest;\n+import org.elasticsearch.client.RestClient;\n+import org.elasticsearch.client.RestClientBuilder;\n+import org.elasticsearch.client.RestHighLevelClient;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.slice.SliceBuilder;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.util.Lists.newArrayList;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.RETURNS_DEEP_STUBS;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+public class ElasticSourcePTest {\n+\n+    public static final String HIT_SOURCE = \"{\\\"name\\\": \\\"Frantisek\\\"}\";\n+    public static final String HIT_SOURCE2 = \"{\\\"name\\\": \\\"Vladimir\\\"}\";\n+    public static final String SCROLL_ID = \"random-scroll-id\";\n+\n+    private static final String KEEP_ALIVE = \"42m\";\n+\n+    private ElasticSourceP<String> processor;\n+    private SerializableRestClient spyClient;\n+    private SearchResponse response;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        RestClientBuilder builderMock = mock(RestClientBuilder.class);\n+        RestClient restClientMock = mock(RestClient.class, RETURNS_DEEP_STUBS);\n+        when(builderMock.build()).thenReturn(restClientMock);\n+        SerializableRestClient client = new SerializableRestClient(builderMock);\n+        spyClient = SerializableRestClient.instanceHolder = spy(client);\n+        // Mocks returning mocks is not generally recommended, but the setup of empty SearchResponse is even uglier\n+        // See org.elasticsearch.action.search.SearchResponse#empty\n+        response = mock(SearchResponse.class);\n+        when(response.getScrollId()).thenReturn(SCROLL_ID);\n+        // client is a spy, need to to doReturn()\n+        doReturn(response).when(spyClient).search(any(SearchRequest.class), any());\n+    }\n+\n+    private TestSupport runProcessor() throws Exception {\n+        return runProcessor(emptyList(), false, false);\n+    }\n+\n+    private TestSupport runProcessorWithCoLocation(List<Shard> shards) throws Exception {\n+        return runProcessor(shards, false, true);\n+    }\n+\n+    private TestSupport runProcessor(List<Shard> shards,\n+                                     boolean slicing, boolean coLocatedReading)\n+            throws Exception {\n+\n+        RestHighLevelClient client = spyClient;\n+        ElasticSourceConfiguration<String> configuration = new ElasticSourceConfiguration<String>(\n+                () -> client,\n+                () -> new SearchRequest(\"*\"),\n+                SearchHit::getSourceAsString,\n+                slicing,\n+                coLocatedReading,\n+                KEEP_ALIVE\n+        );\n+\n+        // This constructor calls the client so it has to be called after specific mock setup in each test method\n+        // rather than in setUp()\n+        processor = new ElasticSourceP<>(configuration, shards);\n+\n+        return TestSupport.verifyProcessor(() -> processor)\n+                .disableSnapshots();\n+    }\n+\n+    @Test\n+    public void when_runProcessor_then_executeSearchRequestWithScroll() throws Exception {\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 0, Float.NaN));\n+\n+        TestSupport support = runProcessor();\n+\n+        support.expectOutput(emptyList());\n+\n+        ArgumentCaptor<SearchRequest> captor = forClass(SearchRequest.class);\n+        verify(spyClient).search(captor.capture());\n+\n+        SearchRequest request = captor.getValue();\n+        assertThat(request.scroll().keepAlive().getStringRep()).isEqualTo(KEEP_ALIVE);\n+    }\n+\n+    @Test\n+    public void given_singleHit_when_runProcessor_then_produceSingleHit() throws Exception {\n+        SearchHit hit = new SearchHit(0, \"id-0\", new Text(\"ignored\"), emptyMap());\n+        hit.sourceRef(new BytesArray(HIT_SOURCE));\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit}, 1, Float.NaN));\n+\n+        SearchResponse response2 = mock(SearchResponse.class);\n+        when(response2.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 1, Float.NaN));\n+        doReturn(response2).when(spyClient).searchScroll(any());\n+\n+        TestSupport testSupport = runProcessor();\n+\n+        testSupport.expectOutput(newArrayList(HIT_SOURCE));\n+    }\n+\n+    @Test\n+    public void givenMultipleResults_when_runProcessor_then_useScrollIdInFollowupScrollRequest() throws Exception {\n+        SearchHit hit = new SearchHit(0, \"id-0\", new Text(\"ignored\"), emptyMap());\n+        hit.sourceRef(new BytesArray(HIT_SOURCE));\n+        when(response.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit}, 3, Float.NaN));\n+\n+        SearchResponse response2 = mock(SearchResponse.class);\n+        SearchHit hit2 = new SearchHit(1, \"id-1\", new Text(\"ignored\"), emptyMap());\n+        hit2.sourceRef(new BytesArray(HIT_SOURCE2));\n+        when(response2.getHits()).thenReturn(new SearchHits(new SearchHit[]{hit2}, 3, Float.NaN));\n+\n+        SearchResponse response3 = mock(SearchResponse.class);\n+        when(response3.getHits()).thenReturn(new SearchHits(new SearchHit[]{}, 3, Float.NaN));\n+        doReturn(response2, response3).when(spyClient).searchScroll(any()); // client is a spy, need to to doReturn()..\n+\n+        TestSupport testSupport = runProcessor();\n+\n+        testSupport.expectOutput(newArrayList(HIT_SOURCE, HIT_SOURCE2));\n+\n+        ArgumentCaptor<SearchScrollRequest> captor = forClass(SearchScrollRequest.class);\n+\n+        verify(spyClient, times(2)).searchScroll(captor.capture());\n+        SearchScrollRequest request = captor.getValue();\n+        assertThat(request.scrollId()).isEqualTo(SCROLL_ID);\n+        assertThat(request.scroll().keepAlive().getStringRep()).isEqualTo(KEEP_ALIVE);\n+    }\n+\n+/*\n+    @Test", "originalCommit": "350190c1070f15730bc00286ebacb52b59c1ec70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3OTkyNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2286#discussion_r440879924", "bodyText": "Because the API is too different for this test to work in the way it was designed and I considered writing new test would not provide much benefit for v5.\nDeleted commented code.", "author": "frant-hartm", "createdAt": "2020-06-16T14:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjUzOTg1Mg=="}], "type": "inlineReview"}, {"oid": "99a4d077b6604b063199016c7b6b38fdc89e5abb", "url": "https://github.com/hazelcast/hazelcast-jet/commit/99a4d077b6604b063199016c7b6b38fdc89e5abb", "message": "Move reflection code to get RestClient to single place", "committedDate": "2020-06-16T14:05:01Z", "type": "commit"}, {"oid": "48d6295d9063009c1fd95d5229c2f1854678c847", "url": "https://github.com/hazelcast/hazelcast-jet/commit/48d6295d9063009c1fd95d5229c2f1854678c847", "message": "Remove duplicate dependency and commented code.", "committedDate": "2020-06-16T14:09:33Z", "type": "commit"}, {"oid": "ac7dbfbf01a6a23fc42de5cb5db477bb7c041a80", "url": "https://github.com/hazelcast/hazelcast-jet/commit/ac7dbfbf01a6a23fc42de5cb5db477bb7c041a80", "message": "Changes from elasticsearch-7 and elasticsearch-6", "committedDate": "2020-06-17T07:08:06Z", "type": "commit"}, {"oid": "1dfd3e915cfa57e0c112cc0c374592e55e5f826e", "url": "https://github.com/hazelcast/hazelcast-jet/commit/1dfd3e915cfa57e0c112cc0c374592e55e5f826e", "message": "Merge branch 'master' into elastic-5-pr", "committedDate": "2020-06-17T10:52:08Z", "type": "commit"}, {"oid": "c5615c1c7a7077edbbb5cc9119d4b6d51f61fe42", "url": "https://github.com/hazelcast/hazelcast-jet/commit/c5615c1c7a7077edbbb5cc9119d4b6d51f61fe42", "message": "Remove duplicate dependencies", "committedDate": "2020-06-17T11:11:41Z", "type": "commit"}]}