{"pr_number": 2754, "pr_title": "Add FANOUT routing policy", "pr_createdAt": "2020-12-14T13:58:38Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/2754", "timeline": [{"oid": "a763782deb2945ef6fb1c136dd025f7c926602f4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a763782deb2945ef6fb1c136dd025f7c926602f4", "message": "Add FANOUT routing policy", "committedDate": "2020-12-14T13:47:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542442375", "bodyText": "This doesn't state which processor on each member. The PR mentions \"round robin\" so I guess it's a different processor every time?", "author": "mtopolnik", "createdAt": "2020-12-14T14:49:31Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java", "diffHunk": "@@ -676,7 +692,12 @@ public int getClassId() {\n         /**\n          * This policy sends each item to all candidate processors.\n          */\n-        BROADCAST\n+        BROADCAST,\n+        /**\n+         * This policy sends each item to a single processor on each of the", "originalCommit": "a763782deb2945ef6fb1c136dd025f7c926602f4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0OTk2Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542449962", "bodyText": "Slightly reworded.", "author": "gierlachg", "createdAt": "2020-12-14T14:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ2NjQ4OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542466489", "bodyText": "I think it would be better to describe the procedure made in a round-robin fashion in another sentence. Because it's a bit unclear what exactly is done in a round-robin fashion.", "author": "ufukyilmaz", "createdAt": "2020-12-14T15:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjU1ODgwNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542558807", "bodyText": "Let's follow the lead of UNICAST, which says \"with no restriction on the choice.\" Here we can say \"sends each item to a single processor on every cluster member. Which exactly processor inside a member it chooses is arbitrary and may change with every item.\".", "author": "mtopolnik", "createdAt": "2020-12-14T17:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYwNjE0OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542606149", "bodyText": "Currently, we can run a DAG containing a fanout edge only in a cluster containing multiple members. Is this expected behavior? I would expect it to act like unicast when it is running on single member because we can normally run a DAG with a distributed edge on a single member.\nOtherwise, failing the job in this case is the expected behavior, let's note it here. Also, I think that we should add tests to RoutingPolicyTest for distributed edge types to demonstrate the single member behavior of them (I am aware that currently other distributed edge types isn't tested for their single member behaviors either.)", "author": "ufukyilmaz", "createdAt": "2020-12-14T18:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MjM3NQ=="}], "type": "inlineReview"}, {"oid": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "url": "https://github.com/hazelcast/hazelcast-jet/commit/7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "message": "Improve javadocs", "committedDate": "2020-12-14T14:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzMTIxMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r542631212", "bodyText": "This causes a job to be failed when it runs on a single member. If it is not intended, you can check this", "author": "ufukyilmaz", "createdAt": "2020-12-14T18:43:51Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "diffHunk": "@@ -378,23 +379,160 @@ private void initDag(InternalSerializationService jobSerializationService) {\n         return processors;\n     }\n \n+    private List<OutboundEdgeStream> createOutboundEdgeStreams(\n+            VertexDef vertex,\n+            int processorIdx,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n+        for (EdgeDef edge : vertex.outboundEdges()) {\n+            OutboundCollector outboundCollector = createOutboundCollector(edge, processorIdx, jobSerializationService);\n+            OutboundEdgeStream outboundEdgeStream = new OutboundEdgeStream(edge.sourceOrdinal(), outboundCollector);\n+            outboundStreams.add(outboundEdgeStream);\n+        }\n+        return outboundStreams;\n+    }\n+\n     /**\n-     * Populates {@code localConveyorMap}, {@code edgeSenderConveyorMap}.\n-     * Populates {@link #senderMap} and {@link #tasklets} fields.\n+     * Each edge is represented by an array of conveyors between the producers and consumers.\n+     * There are as many conveyors as there are consumers.\n+     * Each conveyor has one queue per producer.\n+     *\n+     * For a distributed edge, there is one additional producer per member represented\n+     * by the ReceiverTasklet.\n      */\n-    private List<OutboundEdgeStream> createOutboundEdgeStreams(VertexDef srcVertex, int processorIdx,\n-                                                               InternalSerializationService jobSerializationService) {\n-        final List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n-        for (EdgeDef edge : srcVertex.outboundEdges()) {\n-            Map<Address, ConcurrentConveyor<Object>> memberToSenderConveyorMap = null;\n-            if (edge.getDistributedTo() != null) {\n-                memberToSenderConveyorMap =\n-                        memberToSenderConveyorMap(edgeSenderConveyorMap, edge, jobSerializationService);\n+    private OutboundCollector createOutboundCollector(\n+            EdgeDef edge,\n+            int processorIndex,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        if (edge.isDistributed() && edge.routingPolicy() == RoutingPolicy.ISOLATED) {\n+            throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n+        }\n+        if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))\n+            && edge.routingPolicy() == RoutingPolicy.FANOUT) {\n+            throw new IllegalArgumentException(\"Fanout edges must be distributed: \" + edge);", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzExMTUxNw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543111517", "bodyText": "This method and the localCompositeCollector method are almost the same, except for the FANOUT case. It might be easier to follow if we have just one method, add boolean local argument, and in the FANOUT case do:\nlocal ? new RoundRobin(collectors) : new Broadcast(collectors);", "author": "viliam-durina", "createdAt": "2020-12-15T07:36:51Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/OutboundCollector.java", "diffHunk": "@@ -76,6 +77,26 @@ static OutboundCollector compositeCollector(\n         }\n     }\n \n+    static OutboundCollector distributedCompositeCollector(", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEyNjYyOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543126628", "bodyText": "If the second condition is true, the first is always true:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))\n          \n          \n            \n                    if (!DISTRIBUTE_TO_ALL.equals(edge.getDistributedTo())", "author": "viliam-durina", "createdAt": "2020-12-15T08:04:14Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/ExecutionPlan.java", "diffHunk": "@@ -378,23 +379,160 @@ private void initDag(InternalSerializationService jobSerializationService) {\n         return processors;\n     }\n \n+    private List<OutboundEdgeStream> createOutboundEdgeStreams(\n+            VertexDef vertex,\n+            int processorIdx,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n+        for (EdgeDef edge : vertex.outboundEdges()) {\n+            OutboundCollector outboundCollector = createOutboundCollector(edge, processorIdx, jobSerializationService);\n+            OutboundEdgeStream outboundEdgeStream = new OutboundEdgeStream(edge.sourceOrdinal(), outboundCollector);\n+            outboundStreams.add(outboundEdgeStream);\n+        }\n+        return outboundStreams;\n+    }\n+\n     /**\n-     * Populates {@code localConveyorMap}, {@code edgeSenderConveyorMap}.\n-     * Populates {@link #senderMap} and {@link #tasklets} fields.\n+     * Each edge is represented by an array of conveyors between the producers and consumers.\n+     * There are as many conveyors as there are consumers.\n+     * Each conveyor has one queue per producer.\n+     *\n+     * For a distributed edge, there is one additional producer per member represented\n+     * by the ReceiverTasklet.\n      */\n-    private List<OutboundEdgeStream> createOutboundEdgeStreams(VertexDef srcVertex, int processorIdx,\n-                                                               InternalSerializationService jobSerializationService) {\n-        final List<OutboundEdgeStream> outboundStreams = new ArrayList<>();\n-        for (EdgeDef edge : srcVertex.outboundEdges()) {\n-            Map<Address, ConcurrentConveyor<Object>> memberToSenderConveyorMap = null;\n-            if (edge.getDistributedTo() != null) {\n-                memberToSenderConveyorMap =\n-                        memberToSenderConveyorMap(edgeSenderConveyorMap, edge, jobSerializationService);\n+    private OutboundCollector createOutboundCollector(\n+            EdgeDef edge,\n+            int processorIndex,\n+            InternalSerializationService jobSerializationService\n+    ) {\n+        if (edge.isDistributed() && edge.routingPolicy() == RoutingPolicy.ISOLATED) {\n+            throw new IllegalArgumentException(\"Isolated edges must be local: \" + edge);\n+        }\n+        if ((!edge.isDistributed() || !edge.getDistributedTo().equals(DISTRIBUTE_TO_ALL))", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MjgxMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543152812", "bodyText": "I specifically didn't want to create this method because of the distributed-to-one edge type - it won't strike your eye that there are two types of distributed edges, especially when the distributed-to-one is rarely used. Maybe we can create isLocal method instead, it seems that there are more instances of !edge.isDistributed() than without the negation.", "author": "viliam-durina", "createdAt": "2020-12-15T08:46:30Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/EdgeDef.java", "diffHunk": "@@ -114,6 +114,10 @@ Address getDistributedTo() {\n         return distributedTo;\n     }\n \n+    boolean isDistributed() {", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE2NzcxNg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543167716", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /**\n          \n          \n            \n                     * This policy sends each item to a single processor on each of the\n          \n          \n            \n                     * cluster members in a round robin fashion. It is only available\n          \n          \n            \n                     * on a distributed edge.\n          \n          \n            \n                     */\n          \n          \n            \n                    /**\n          \n          \n            \n                     * This policy sends an item to all members, but only to one processor on\n          \n          \n            \n                     * each member. It's a combination of {@link #BROADCAST} and {@link\n          \n          \n            \n                     * #UNICAST}: an item is first <em>broadcast</em> to all members, and then,\n          \n          \n            \n                     * on each member, it is <em>unicast</em> to one processor.\n          \n          \n            \n                     * <p>\n          \n          \n            \n                     * If the destination local parallelism is 1, the behavior is equal to\n          \n          \n            \n                     * {@link #BROADCAST}.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @since 4.4\n          \n          \n            \n                     */", "author": "viliam-durina", "createdAt": "2020-12-15T09:08:42Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java", "diffHunk": "@@ -676,7 +692,13 @@ public int getClassId() {\n         /**\n          * This policy sends each item to all candidate processors.\n          */\n-        BROADCAST\n+        BROADCAST,\n+        /**\n+         * This policy sends each item to a single processor on each of the\n+         * cluster members in a round robin fashion. It is only available\n+         * on a distributed edge.\n+         */", "originalCommit": "7571af4155d3ecb84e1cb40f3b56f738e060ca0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a99e679f74adfc05a64ee6fdf58230c92e1b71b4", "url": "https://github.com/hazelcast/hazelcast-jet/commit/a99e679f74adfc05a64ee6fdf58230c92e1b71b4", "message": "Update hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-12-15T09:09:40Z", "type": "commit"}, {"oid": "14a6547b76b190d1ffae894b046d5c019eeb12c3", "url": "https://github.com/hazelcast/hazelcast-jet/commit/14a6547b76b190d1ffae894b046d5c019eeb12c3", "message": "Allow FANOUT for local edges & fix it for single node clusters", "committedDate": "2020-12-15T09:38:38Z", "type": "commit"}, {"oid": "308f600f232229acbfae271b58f5c1beffe9432d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/308f600f232229acbfae271b58f5c1beffe9432d", "message": "Update javadoc", "committedDate": "2020-12-15T10:09:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI0OTIyMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/2754#discussion_r543249222", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * If the destination local parallelism is 1, the behavior is equal to\n          \n          \n            \n                     * {@link #BROADCAST}.\n          \n          \n            \n                     * If the destination local parallelism is 1, the behavior is equal to\n          \n          \n            \n                     * {@link #BROADCAST}. If the member count in the cluster is 1, the\n          \n          \n            \n                     * behavior is equal to {@link #UNICAST}.", "author": "viliam-durina", "createdAt": "2020-12-15T11:04:01Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java", "diffHunk": "@@ -676,7 +690,19 @@ public int getClassId() {\n         /**\n          * This policy sends each item to all candidate processors.\n          */\n-        BROADCAST\n+        BROADCAST,\n+        /**\n+         * This policy sends an item to all members, but only to one processor on\n+         * each member. It's a combination of {@link #BROADCAST} and {@link\n+         * #UNICAST}: an item is first <em>broadcast</em> to all members, and then,\n+         * on each member, it is <em>unicast</em> to one processor.\n+         * <p>\n+         * If the destination local parallelism is 1, the behavior is equal to\n+         * {@link #BROADCAST}.", "originalCommit": "308f600f232229acbfae271b58f5c1beffe9432d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "230e083200842104848aefcdb0793c1969acacfd", "url": "https://github.com/hazelcast/hazelcast-jet/commit/230e083200842104848aefcdb0793c1969acacfd", "message": "Update hazelcast-jet-core/src/main/java/com/hazelcast/jet/core/Edge.java\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-12-15T11:06:17Z", "type": "commit"}, {"oid": "f628d36295c4c087291c98cf15e5de411a7ef631", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f628d36295c4c087291c98cf15e5de411a7ef631", "message": "Add EdgeDef.isLocal()", "committedDate": "2020-12-15T11:07:56Z", "type": "commit"}]}