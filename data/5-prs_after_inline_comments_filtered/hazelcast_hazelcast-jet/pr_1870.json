{"pr_number": 1870, "pr_title": "Call a Python Function from Jet Pipeline", "pr_createdAt": "2020-01-21T12:37:40Z", "pr_url": "https://github.com/hazelcast/hazelcast-jet/pull/1870", "timeline": [{"oid": "64818c486d05dcfb20b96ddcd313881f6e3c8f1a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/64818c486d05dcfb20b96ddcd313881f6e3c8f1a", "message": "Simple Python echo test", "committedDate": "2020-01-23T15:00:27Z", "type": "forcePushed"}, {"oid": "f527e9bc4d6a7a047b5512b6d2ed39bdc6522aec", "url": "https://github.com/hazelcast/hazelcast-jet/commit/f527e9bc4d6a7a047b5512b6d2ed39bdc6522aec", "message": "Simple Python echo test", "committedDate": "2020-01-23T15:25:25Z", "type": "forcePushed"}, {"oid": "1cbe27c8405b1691f56f4db581e49a1efc3a4254", "url": "https://github.com/hazelcast/hazelcast-jet/commit/1cbe27c8405b1691f56f4db581e49a1efc3a4254", "message": "Reuse method in Inbox", "committedDate": "2020-01-24T14:41:45Z", "type": "commit"}, {"oid": "faa9f41d79867e11b1f4d2129d04b70ee928c4c8", "url": "https://github.com/hazelcast/hazelcast-jet/commit/faa9f41d79867e11b1f4d2129d04b70ee928c4c8", "message": "Improve Javadoc", "committedDate": "2020-01-24T14:42:13Z", "type": "commit"}, {"oid": "b6952e4c306c285a0965b76527ae5538ac8a9c33", "url": "https://github.com/hazelcast/hazelcast-jet/commit/b6952e4c306c285a0965b76527ae5538ac8a9c33", "message": "hazelcast-jet-python module", "committedDate": "2020-01-24T14:49:16Z", "type": "forcePushed"}, {"oid": "764759f9e41031514458eb5e9e196adb3c303592", "url": "https://github.com/hazelcast/hazelcast-jet/commit/764759f9e41031514458eb5e9e196adb3c303592", "message": "hazelcast-jet-python module", "committedDate": "2020-01-24T15:13:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDUyOA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r370944528", "bodyText": "this would get serialized", "author": "cangencer", "createdAt": "2020-01-25T17:12:42Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/ServiceFactory.java", "diffHunk": "@@ -102,37 +106,31 @@\n      */\n     public static final boolean ORDERED_ASYNC_RESPONSES_DEFAULT = true;\n \n-    private final boolean isCooperative;\n+    private boolean isCooperative = COOPERATIVE_DEFAULT;\n \n     // options for async\n-    private final int maxPendingCallsPerProcessor;\n-    private final boolean orderedAsyncResponses;\n+    private int maxPendingCallsPerProcessor = MAX_PENDING_CALLS_DEFAULT;\n+    private boolean orderedAsyncResponses = ORDERED_ASYNC_RESPONSES_DEFAULT;\n \n     @Nonnull\n-    private final FunctionEx<? super Context, ? extends C> createContextFn;\n+    private FunctionEx<? super Context, ? extends C> createContextFn;\n+\n     @Nonnull\n-    private final BiFunctionEx<? super Processor.Context, ? super C, ? extends S> createServiceFn;\n+    private BiFunctionEx<? super Processor.Context, ? super C, ? extends S> createServiceFn = (ctx, svcContext) -> {\n+        throw new IllegalStateException(\"This ServiceFactory is missing a createServiceFn\");\n+    };\n+\n     @Nonnull\n-    private final ConsumerEx<? super S> destroyServiceFn;\n+    private ConsumerEx<? super S> destroyServiceFn = ConsumerEx.noop();\n+\n     @Nonnull\n-    private final ConsumerEx<? super C> destroyContextFn;\n-\n-    private ServiceFactory(\n-            @Nonnull FunctionEx<? super ProcessorSupplier.Context, ? extends C> createContextFn,\n-            @Nonnull BiFunctionEx<? super Processor.Context, ? super C, ? extends S> createServiceFn,\n-            @Nonnull ConsumerEx<? super S> destroyServiceFn,\n-            @Nonnull ConsumerEx<? super C> destroyContextFn,\n-            boolean isCooperative,\n-            int maxPendingCallsPerProcessor,\n-            boolean orderedAsyncResponses\n-    ) {\n+    private ConsumerEx<? super C> destroyContextFn = ConsumerEx.noop();\n+\n+    @Nonnull\n+    private Set<File> filesToAttach = new HashSet<>();", "originalCommit": "9c263f58fd3bc32b1c23b06ac1032fa11370b20d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4ODU1MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r370988550", "bodyText": "Fixed by nulling out in attachedFiles call.", "author": "mtopolnik", "createdAt": "2020-01-26T10:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDU5NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r370944595", "bodyText": "we should do this another way - it's easy to miss in one place to add the files, and you don't have coverage for all the options. Maybe Pipeline.attachFiles() or stage.addFiles() ?", "author": "cangencer", "createdAt": "2020-01-25T17:13:56Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/pipeline/ComputeStageImplBase.java", "diffHunk": "@@ -223,6 +223,7 @@\n             @Nonnull BiFunctionEx<? super S, ? super T, ? extends R> mapFn\n     ) {\n         checkSerializable(mapFn, \"mapFn\");\n+        pipelineImpl.attachFiles(serviceFactory.attachedFiles());", "originalCommit": "9c263f58fd3bc32b1c23b06ac1032fa11370b20d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDgxMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r370944812", "bodyText": "I wonder if it's better to represent these internally as Properties class or similar, so we don't have to add a method for every single option.", "author": "cangencer", "createdAt": "2020-01-25T17:18:58Z", "path": "hazelcast-jet-python/src/main/java/com/hazelcast/jet/python/PythonServiceConfig.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright (c) 2008-2019, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.python;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Configuration object for the Python service factory.\n+ */\n+public class PythonServiceConfig implements Serializable {\n+    private File baseDir;\n+    private File handlerFile;\n+    private String handlerModule;\n+    private String handlerFunction;", "originalCommit": "9c263f58fd3bc32b1c23b06ac1032fa11370b20d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk4ODgyNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r370988824", "bodyText": "You mean a field? Methods should stay as they have important Javadoc on them and make all the options easily discoverable. Also, just two options are strings.", "author": "mtopolnik", "createdAt": "2020-01-26T10:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDkwMQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r370944901", "bodyText": "we should include an example python function here", "author": "cangencer", "createdAt": "2020-01-25T17:20:58Z", "path": "hazelcast-jet-python/src/main/java/com/hazelcast/jet/python/PythonServiceConfig.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * Copyright (c) 2008-2019, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.python;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Configuration object for the Python service factory.\n+ */\n+public class PythonServiceConfig implements Serializable {\n+    private File baseDir;\n+    private File handlerFile;\n+    private String handlerModule;\n+    private String handlerFunction;\n+\n+    /**\n+     * Validates the configuration and throws an exception of\n+     * a mandatory config option is missing.\n+     */\n+    public void validate() {\n+        List<String> missingMandatoryFields = new ArrayList<>();\n+        if (baseDir == null) {\n+            if (handlerFile == null) {\n+                missingMandatoryFields.add(\"(baseDir or handlerFile)\");\n+            }\n+        } else if (handlerModule == null) {\n+            missingMandatoryFields.add(\"handlerModule\");\n+        }\n+        if (handlerFunction == null) {\n+            missingMandatoryFields.add(\"handlerFunction\");\n+        }\n+        if (!missingMandatoryFields.isEmpty()) {\n+            throw new InvalidPythonServiceConfigException(missingMandatoryFields);\n+        }\n+    }\n+\n+    /**\n+     * Returns the Python {@linkplain #setBaseDir base directory}.\n+     */\n+    @Nullable\n+    public File baseDir() {\n+        return baseDir;\n+    }\n+\n+    /**\n+     * Sets the base directory where the Python files reside. When you set this,\n+     * also set the name of the {@link #setHandlerModule handler module} to\n+     * identify the location of the handler function.\n+     * <p>\n+     * Jet also recognizes these special files in the base directory:\n+     * <ul><li>\n+     *     {@code requirements.txt} is assumed to list the <a href=\n+     *     \"https://pip.pypa.io/en/stable/user_guide/#requirements-files\">\n+     *     dependencies of your Python code</a>. Jet will automatically install\n+     *     them to a job-local virtual environment. You can also install the\n+     *     modules to the Jet servers' global Python environment in order to speed\n+     *     up job initialization. Jet reuses the global modules and adds the\n+     *     missing ones.\n+     * <li>\n+     *     {@code init.sh} is assumed to be a Bash script that Jet will run when\n+     *     initializing the job.\n+     * <li>\n+     *     {@code cleanup.sh} is assumed to be a Bash script that Jet will run\n+     *     when completing the job.\n+     * </ul>\n+     * <p>\n+     * If all you need to deploy to Jet is in a single file, you can call {@link\n+     * #setHandlerFile} instead.\n+     */\n+    public PythonServiceConfig setBaseDir(@Nonnull String baseDir) {\n+        if (handlerFile != null) {\n+            throw new IllegalArgumentException(\n+                    \"You already set handlerFile so you can't set baseDir.\" +\n+                    \" When using baseDir, set handlerModule instead.\");\n+        }\n+        String baseDirStr = requireNonBlank(baseDir, \"baseDir\");\n+        try {\n+            File dir = new File(baseDirStr).getCanonicalFile();\n+            if (!dir.isDirectory()) {\n+                throw new IOException(\"Not a directory: \" + dir);\n+            }\n+            this.baseDir = dir;\n+        } catch (IOException e) {\n+            throw new InvalidPythonServiceConfigException(\"Invalid baseDir argument\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the Python {@linkplain #setHandlerFile handler file}.\n+     */\n+    @Nullable\n+    public File handlerFile() {\n+        return handlerFile;\n+    }\n+\n+    /**\n+     * Sets the Python handler file. It must contain the {@linkplain\n+     * #setHandlerFunction handler function}. If your Python work is in more\n+     * than one file, call {@link #setBaseDir} instead.\n+     */\n+    public PythonServiceConfig setHandlerFile(@Nonnull String handlerFile) {\n+        if (baseDir != null) {\n+            throw new IllegalStateException(\n+                    \"You already set baseDir so you can't set handlerFile.\" +\n+                    \" If you want to set the handler module, call setHandlerModule().\");\n+        }\n+        if (handlerModule != null) {\n+            throw new IllegalStateException(\n+                    \"You already set handlerModule, it would be overwritten by setting handlerFile\");\n+        }\n+        String handlerFileStr = requireNonBlank(handlerFile, \"handlerFile\");\n+        if (!handlerFileStr.toLowerCase().endsWith(\".py\")) {\n+            throw new IllegalArgumentException(\"The handler file must be a .py file\");\n+        }\n+        try {\n+            File file = new File(handlerFileStr).getCanonicalFile();\n+            if (!file.isFile()) {\n+                throw new IOException(\"Not a regular file: \" + file);\n+            }\n+            this.handlerFile = file;\n+            this.handlerModule = file.getName().replaceFirst(\"\\\\.py$\", \"\");\n+        } catch (IOException e) {\n+            throw new InvalidPythonServiceConfigException(\"Invalid handlerFile argument\", e);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the {@linkplain #setHandlerModule handler module} name.\n+     * */\n+    public String handlerModule() {\n+        return handlerModule;\n+    }\n+\n+    /**\n+     * Sets the name of the Python module that has the function that\n+     * transforms Jet pipeline data.\n+     */\n+    public PythonServiceConfig setHandlerModule(@Nonnull String handlerModule) {\n+        if (handlerFile != null) {\n+            throw new IllegalStateException(\n+                    \"You already set handlerFile, it would be overwritten by setting handlerModule\");\n+        }\n+        this.handlerModule = requireNonBlank(handlerModule, \"handlerModule\");\n+        return this;\n+    }\n+\n+    /**\n+     * Returns the name of the {@linkplain #setHandlerFunction handler\n+     * function}.\n+     */\n+    public String handlerFunction() {\n+        return handlerFunction;\n+    }\n+\n+    /**\n+     * Sets the name of the Python function that transforms Jet pipeline data,\n+     * defined in the module you configured with {@link #setHandlerModule}.\n+     * The function must take a single argument that is a list of strings, and\n+     * return another list of strings which has the results of transforming each\n+     * item in the input list. There must be a strict one-to-one match between\n+     * the input and output lists.", "originalCommit": "9c263f58fd3bc32b1c23b06ac1032fa11370b20d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjExMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r370946110", "bodyText": "we should delete this after the tests", "author": "cangencer", "createdAt": "2020-01-25T17:45:47Z", "path": "hazelcast-jet-python/src/test/java/com/hazelcast/jet/python/PythonServiceTest.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.python;\n+\n+import com.hazelcast.jet.SimpleTestInClusterSupport;\n+import com.hazelcast.jet.impl.util.IOUtil;\n+import com.hazelcast.jet.pipeline.BatchStage;\n+import com.hazelcast.jet.pipeline.Pipeline;\n+import com.hazelcast.jet.pipeline.StreamStage;\n+import com.hazelcast.jet.pipeline.test.AssertionSinks;\n+import com.hazelcast.jet.pipeline.test.TestSources;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import static com.hazelcast.jet.python.PythonService.mapUsingPython;\n+import static com.hazelcast.jet.python.PythonService.mapUsingPythonBatch;\n+import static java.util.stream.Collectors.toList;\n+\n+public class PythonServiceTest extends SimpleTestInClusterSupport {\n+\n+    private static final int ITEM_COUNT = 10_000;\n+    private File baseDir;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {\n+        initialize(2, null);\n+    }\n+\n+    @Before\n+    public void before() throws Exception {\n+        baseDir = createTempDirectory();", "originalCommit": "1982dd31dcb13a4cd93b7cdbfebadbfbc742494c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "804dd3e4243343d170b9633e5d57bc37fc15c955", "url": "https://github.com/hazelcast/hazelcast-jet/commit/804dd3e4243343d170b9633e5d57bc37fc15c955", "message": "Address review", "committedDate": "2020-01-26T10:34:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAxMzU2OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371013569", "bodyText": "I mistakenly made this package-private, reverted now, also Nonnull / Nullable is missing for methods as well as the since tags", "author": "cangencer", "createdAt": "2020-01-26T16:48:12Z", "path": "hazelcast-jet-python/src/main/java/com/hazelcast/jet/python/PythonService.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.python;\n+\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.core.Processor.Context;\n+import com.hazelcast.jet.pipeline.BatchStage;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+import com.hazelcast.jet.pipeline.StreamStage;\n+import com.hazelcast.jet.python.grpc.InputMessage;\n+import com.hazelcast.jet.python.grpc.InputMessage.Builder;\n+import com.hazelcast.jet.python.grpc.JetToPythonGrpc;\n+import com.hazelcast.jet.python.grpc.JetToPythonGrpc.JetToPythonStub;\n+import com.hazelcast.jet.python.grpc.OutputMessage;\n+import com.hazelcast.logging.ILogger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * The service object used by the \"map using Python\" pipeline stage. As a\n+ * user you don't have to deal with this class directly. It is used when\n+ * you write {@link #mapUsingPython\n+ * stage.apply(PythonService.mapUsingPython(pyConfig))}\n+ */\n+class PythonService {", "originalCommit": "804dd3e4243343d170b9633e5d57bc37fc15c955", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE0OTY0OQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371149649", "bodyText": "we don't support ID here which is contradictory with how it works when doing it through JobConfig. Wouldn't it make sense to always require ID here, and then pythonService can add its own special id for these files?", "author": "cangencer", "createdAt": "2020-01-27T10:02:46Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/ServiceFactory.java", "diffHunk": "@@ -315,10 +310,65 @@ private ServiceFactory(\n      */\n     @Nonnull\n     public ServiceFactory<C, S> withUnorderedAsyncResponses() {\n-        return new ServiceFactory<>(\n-                createContextFn, createServiceFn, destroyServiceFn, destroyContextFn,\n-                isCooperative, maxPendingCallsPerProcessor, false\n-        );\n+        ServiceFactory<C, S> copy = clone();\n+        copy.orderedAsyncResponses = false;\n+        return copy;\n+\n+    }\n+\n+    /**\n+     * Attaches a file to this service factory. It will become a part of the\n+     * Jet job and available to {@link #createContextFn()} as {@link\n+     * ProcessorSupplier.Context#attachedFile\n+     * procSupplierContext.attachedFile(file.toString())}.\n+     *\n+     * @return a copy of this factory with the file attached\n+     *\n+     * @since 4.0\n+     */\n+    @Nonnull\n+    public ServiceFactory<C, S> withAttachedFile(@Nonnull File file) {\n+        if (!file.isFile()) {", "originalCommit": "540af8585ecef9b1eef5179913e1cb996f8dbaf2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1MzI4MQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371153281", "bodyText": "Isn't this method implementation is 1:1 copy of the one above ?", "author": "eminn", "createdAt": "2020-01-27T10:10:31Z", "path": "hazelcast-jet-python/src/main/java/com/hazelcast/jet/python/PythonService.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.python;\n+\n+import com.hazelcast.function.FunctionEx;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.core.Processor.Context;\n+import com.hazelcast.jet.pipeline.BatchStage;\n+import com.hazelcast.jet.pipeline.ServiceFactory;\n+import com.hazelcast.jet.pipeline.StreamStage;\n+import com.hazelcast.jet.python.grpc.InputMessage;\n+import com.hazelcast.jet.python.grpc.InputMessage.Builder;\n+import com.hazelcast.jet.python.grpc.JetToPythonGrpc;\n+import com.hazelcast.jet.python.grpc.JetToPythonGrpc.JetToPythonStub;\n+import com.hazelcast.jet.python.grpc.OutputMessage;\n+import com.hazelcast.logging.ILogger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.shaded.io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.stub.StreamObserver;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+/**\n+ * The service object used by the \"map using Python\" pipeline stage. As a\n+ * user you don't have to deal with this class directly. It is used when\n+ * you write {@link #mapUsingPython\n+ * stage.apply(PythonService.mapUsingPython(pyConfig))}\n+ *\n+ * @since 4.0\n+ */\n+public final class PythonService {\n+\n+    private static final String JET_TO_PYTHON_PREFIX = \"jet_to_python_\";\n+    static final String MAIN_SHELL_SCRIPT = JET_TO_PYTHON_PREFIX + \"main.sh\";\n+\n+    private final ILogger logger;\n+    private final JetToPythonServer server;\n+    private final ManagedChannel chan;\n+    private final StreamObserver<InputMessage> sink;\n+    private final Queue<CompletableFuture<List<String>>> futureQueue = new ConcurrentLinkedQueue<>();\n+\n+    private final CountDownLatch completionLatch = new CountDownLatch(1);\n+    private volatile Throwable exceptionInOutputObserver;\n+\n+    PythonService(Context procCtx, PythonServiceContext serviceContext) {\n+        logger = procCtx.logger();\n+        try {\n+            server = new JetToPythonServer(serviceContext.runtimeBaseDir(), logger);\n+            int serverPort = server.start();\n+            chan = NettyChannelBuilder.forAddress(\"127.0.0.1\", serverPort)\n+                                      .usePlaintext()\n+                                      .build();\n+            JetToPythonStub client = JetToPythonGrpc.newStub(chan);\n+            sink = client.streamingCall(new OutputMessageObserver());\n+        } catch (Exception e) {\n+            throw new JetException(\"PythonService initialization failed\", e);\n+        }\n+    }\n+\n+    /**\n+     * A stage-transforming method that adds a \"map using Python\" pipeline stage.\n+     * Use it with {@code stage.apply(PythonService.mapUsingPython(pyConfig))}.\n+     */\n+    @Nonnull\n+    public static FunctionEx<StreamStage<String>, StreamStage<String>> mapUsingPython(\n+            @Nonnull PythonServiceConfig cfg\n+    ) {\n+        return s -> s\n+                .mapUsingServiceAsyncBatched(factory(cfg), Integer.MAX_VALUE, PythonService::sendRequest)\n+                .setName(\"mapUsingPython\");\n+    }\n+\n+    /**\n+     * A stage-transforming method that adds a \"map using Python\" pipeline stage.\n+     * Use it with {@code stage.apply(PythonService.mapUsingPythonBatch(pyConfig))}.\n+     */\n+    @Nonnull\n+    public static FunctionEx<BatchStage<String>, BatchStage<String>> mapUsingPythonBatch(", "originalCommit": "540af8585ecef9b1eef5179913e1cb996f8dbaf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1MzgyMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371153820", "bodyText": "It's not possible to make them have same name, as the type params are different", "author": "cangencer", "createdAt": "2020-01-27T10:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1MzI4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1NDY4MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371154680", "bodyText": "The batch in the method name confused me, I've missed the signature", "author": "eminn", "createdAt": "2020-01-27T10:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE1MzI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTczMzMyMg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371733322", "bodyText": "We can declare this exception, the superclass allows it.", "author": "viliam-durina", "createdAt": "2020-01-28T10:55:17Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/pipeline/ServiceFactory.java", "diffHunk": "@@ -390,4 +439,31 @@ public int maxPendingCallsPerProcessor() {\n     public boolean hasOrderedAsyncResponses() {\n         return orderedAsyncResponses;\n     }\n+\n+    /**\n+     * Returns the files and directories attached to this service factory. They\n+     * will become a part of the Jet job and available to {@link\n+     * #createContextFn()} as {@link ProcessorSupplier.Context#attachedFile\n+     * procSupplierContext.attachedFile(file.toString())} or\n+     * {@link ProcessorSupplier.Context#attachedDirectory\n+     * procSupplierContext.attachedDirectory(directory.toString())}.\n+     *\n+     * @since 4.0\n+     */\n+    @Nonnull\n+    public Map<String, File> attachedFiles() {\n+        return Collections.unmodifiableMap(attachedFiles);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected ServiceFactory<C, S> clone() {\n+        try {\n+            ServiceFactory<C, S> copy = (ServiceFactory<C, S>) super.clone();\n+            copy.attachedFiles = new HashMap<>(attachedFiles);\n+            return copy;\n+        } catch (CloneNotSupportedException e) {", "originalCommit": "715272fcba52ce6e2bf268f27518690f7a8dee85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1MjUzMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371752533", "bodyText": "The point is to not have to deal with this exception when using the specific type. The exception will never occur.", "author": "mtopolnik", "createdAt": "2020-01-28T11:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTczMzMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371741324", "bodyText": "This is rather confusing. If the user doesn't use the attachFile variant with id, then the file name and ID are always equal. If he does, then he does so for some reason. We should use the ID he asked for and not the one from the URL. The URL might even not contain a file name, but we require it here.\nIf we keep it like this, we should document at attachFile(URL, id) that we require the URL to contain a file name and that that file name will be the name of the file, the ID is just used to look up that file.", "author": "viliam-durina", "createdAt": "2020-01-28T11:13:28Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/JobRepository.java", "diffHunk": "@@ -211,11 +212,12 @@ long uploadJobResources(JobConfig jobConfig) {\n                         }\n                         break;\n                     case FILE:\n-                        try (\n-                                InputStream in = rc.getUrl().openStream();\n-                                IMapOutputStream os = new IMapOutputStream(jobFileStorage.get(), fileKeyName(rc.getId()))\n+                        Path fnamePath = Paths.get(Objects.requireNonNull(rc.getUrl().getPath())).getFileName();\n+                        assert fnamePath != null; // needed to silence SpotBugs\n+                        try (InputStream in = rc.getUrl().openStream();\n+                             IMapOutputStream os = new IMapOutputStream(jobFileStorage.get(), fileKeyName(rc.getId()))\n                         ) {\n-                            packStreamIntoZip(in, os, rc.getId());\n+                            packStreamIntoZip(in, os, fnamePath.toString());", "originalCommit": "715272fcba52ce6e2bf268f27518690f7a8dee85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1NDExMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371754110", "bodyText": "ID must be unique, and if we use it as the filename then no two resources can have the same filename. On the other hand, a given filename may be required and there is no uniqueness requirement.", "author": "mtopolnik", "createdAt": "2020-01-28T11:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3MDAwMA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371770000", "bodyText": "Then we should document that the URL must contain a file name and that the file will actually have that name and ID is used to query that file. We can also mention that multiple files can have the same name and different ID, it will make that option obvious.", "author": "viliam-durina", "createdAt": "2020-01-28T12:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc3NTMxMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371775313", "bodyText": "The URL has in fact always had an even stronger requirement: to be resolvable into a local file. We should document that explicitly.", "author": "mtopolnik", "createdAt": "2020-01-28T12:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzMzMzOQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371833339", "bodyText": "Maybe in the past, now we only use url.openStream(), so it has to be any URL that can be read.", "author": "viliam-durina", "createdAt": "2020-01-28T14:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg3MzA3NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371873075", "bodyText": "The complete story is in JobConfig, where we convert URLs to files. I'm adding more explicit checking there.", "author": "mtopolnik", "createdAt": "2020-01-28T15:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxOTA1OA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371919058", "bodyText": "We convert the URLs to file names, not to files. A http URL works just fine, if it contains a file name.\nNevertheless, I was thinking about it more. Maybe we can leave it as it is. It's very unlikely to encounter a URL like http://hazelcast.com/ that has no file name. The user will receive a NPE or AssertionError in this case, which is very easy to fix by looking at the code. I'm marking this as resolved.", "author": "viliam-durina", "createdAt": "2020-01-28T16:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzMzE5Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r372233197", "bodyText": "In the meantime i cleaned up JobConfig to make the checks where needed. attachFile/Directory must get a file URL and checks for the existence of the file. The add variants can get an opaque URL that they don't check, but they still check it has at least one path segment to be used as the ID.", "author": "mtopolnik", "createdAt": "2020-01-29T07:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MTMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc0MjY5Nw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371742697", "bodyText": "This is a good idea. The id is user-supplied, it can be whatever. We should whitelist allowed characters and replace all others. Also maybe trim it to up to 20 chars or so.", "author": "viliam-durina", "createdAt": "2020-01-28T11:16:45Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/impl/execution/init/Contexts.java", "diffHunk": "@@ -185,13 +188,17 @@ private File extractFileToDisk(String id) {\n             IMap<String, byte[]> map = jetInstance().getMap(jobResourcesMapName(jobId()));\n             try (IMapInputStream inputStream = new IMapInputStream(map, fileKeyName(id))) {\n                 String prefix = \"jet-\" + jetInstance().getName() + \"-\" + idToString(jobId()) + \"-\" + id;\n-                Path directory = Files.createTempDirectory(prefix);\n+                Path directory = Files.createTempDirectory(sanitizeFilename(prefix));\n                 unzip(inputStream, directory);\n                 return directory.toFile();\n             } catch (IOException e) {\n                 throw ExceptionUtil.rethrow(e);\n             }\n         }\n+\n+        private static String sanitizeFilename(String proposed) {\n+            return proposed.replace('/', '_');", "originalCommit": "715272fcba52ce6e2bf268f27518690f7a8dee85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4MzA1Mg==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371783052", "bodyText": "Why do we wait here? Isn't it just a query whether the process terminated? Then we can wait for 0 seconds.", "author": "viliam-durina", "createdAt": "2020-01-28T12:52:04Z", "path": "hazelcast-jet-python/src/main/java/com/hazelcast/jet/python/JetToPythonServer.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.python;\n+\n+import com.hazelcast.logging.ILogger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.UnsupportedEncodingException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.nio.file.Path;\n+\n+import static com.hazelcast.jet.python.PythonService.MAIN_SHELL_SCRIPT;\n+import static java.lang.ProcessBuilder.Redirect.PIPE;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+class JetToPythonServer {\n+    private final File baseDir;\n+    private ILogger logger;\n+\n+    private Process pythonProcess;\n+    private String pythonProcessPid;\n+\n+    JetToPythonServer(Path baseDir, ILogger logger) {\n+        this.baseDir = baseDir.toFile();\n+        this.logger = logger;\n+    }\n+\n+    int start() throws IOException, InterruptedException {\n+        try (ServerSocket serverSocket = new ServerSocket()) {\n+            serverSocket.bind(null);\n+            InetSocketAddress endpoint = (InetSocketAddress) serverSocket.getLocalSocketAddress();\n+            ProcessBuilder builder = new ProcessBuilder(\n+                    \"/bin/sh\", \"-c\", \"./\" + MAIN_SHELL_SCRIPT\n+                    + \" \" + endpoint.getHostString() + \" \" + endpoint.getPort());\n+            pythonProcess = builder\n+                    .directory(baseDir)\n+                    .inheritIO()\n+                    .redirectInput(PIPE)\n+                    .start();\n+            pythonProcessPid = processPid(pythonProcess);\n+            logger.info(\"Started Python process: \" + pythonProcessPid);\n+            serverSocket.setSoTimeout((int) SECONDS.toMillis(1));\n+            while (true) {\n+                try (Socket clientSocket = serverSocket.accept()) {\n+                    int serverPort = Integer.parseInt(new BufferedReader(\n+                            new InputStreamReader(clientSocket.getInputStream(), UTF_8)).readLine());\n+                    logger.info(\"Python process \" + pythonProcessPid + \" listening on port \" + serverPort);\n+                    return serverPort;\n+                } catch (SocketTimeoutException e) {\n+                    if (pythonProcess.waitFor(1, SECONDS)) {", "originalCommit": "715272fcba52ce6e2bf268f27518690f7a8dee85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgyODIwMQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371828201", "bodyText": "We configure the socket timeout to 1 second, and if it elapses, we wait for one second before going to another accept() call, to see if the Python process will die. We could also just check process.isAlive() and go to another loop iteration. It's pretty arbitrary.", "author": "mtopolnik", "createdAt": "2020-01-28T14:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4MzA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg0MDMyMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371840323", "bodyText": "that was my point that it's pretty arbitrary. Why not going to accept again immediately?", "author": "viliam-durina", "createdAt": "2020-01-28T14:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc4MzA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgxNjIxMw==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371816213", "bodyText": "You could use Files.walk to process files recursively.", "author": "viliam-durina", "createdAt": "2020-01-28T13:57:34Z", "path": "hazelcast-jet-python/src/main/java/com/hazelcast/jet/python/PythonServiceContext.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.jet.python;\n+\n+import com.hazelcast.internal.nio.IOUtil;\n+import com.hazelcast.jet.JetException;\n+import com.hazelcast.jet.core.ProcessorSupplier;\n+import com.hazelcast.logging.ILogger;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.hazelcast.jet.impl.util.IOUtil.copyStream;\n+import static java.nio.file.LinkOption.NOFOLLOW_LINKS;\n+import static java.nio.file.attribute.PosixFilePermission.GROUP_WRITE;\n+import static java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE;\n+import static java.nio.file.attribute.PosixFilePermission.OWNER_WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.singletonList;\n+\n+/**\n+ * The context object used by the \"map using Python\" pipeline stage. As a\n+ * user you don't have to deal with this class directly. It is used when\n+ * you write {@link PythonTransforms#mapUsingPython\n+ * stage.apply(PythonService.mapUsingPython(pyConfig))}\n+ */\n+class PythonServiceContext {\n+\n+    private static final String JET_TO_PYTHON_PREFIX = \"jet_to_python_\";\n+    private static final String MAIN_SHELL_SCRIPT = JET_TO_PYTHON_PREFIX + \"main.sh\";\n+    private static final String PARAMS_SCRIPT = JET_TO_PYTHON_PREFIX + \"params.sh\";\n+    private static final String INIT_SHELL_SCRIPT = JET_TO_PYTHON_PREFIX + \"init.sh\";\n+    private static final String CLEANUP_SHELL_SCRIPT = JET_TO_PYTHON_PREFIX + \"cleanup.sh\";\n+    private static final String USER_INIT_SHELL_SCRIPT = \"init.sh\";\n+    private static final String USER_CLEANUP_SHELL_SCRIPT = \"cleanup.sh\";\n+    private static final String PYTHON_GRPC_SCRIPT = JET_TO_PYTHON_PREFIX + \"grpc_server.py\";\n+    private static final List<String> EXECUTABLE_SCRIPTS = asList(\n+            INIT_SHELL_SCRIPT, MAIN_SHELL_SCRIPT, CLEANUP_SHELL_SCRIPT);\n+    private static final List<String> USER_EXECUTABLE_SCRIPTS = asList(\n+            USER_INIT_SHELL_SCRIPT, USER_CLEANUP_SHELL_SCRIPT);\n+    private static final EnumSet<PosixFilePermission> WRITE_PERMISSIONS =\n+            EnumSet.of(OWNER_WRITE, GROUP_WRITE, OTHERS_WRITE);\n+    private static final Object INIT_LOCK = new Object();\n+\n+    private final ILogger logger;\n+\n+    private Path runtimeBaseDir;\n+\n+    PythonServiceContext(ProcessorSupplier.Context context, PythonServiceConfig cfg) {\n+        this.logger = context.logger();\n+        try {\n+            long start = System.nanoTime();\n+            runtimeBaseDir = cfg.baseDir() != null\n+                    ? context.attachedDirectory(cfg.baseDir().toString()).toPath()\n+                    : context.attachedFile(cfg.handlerFile().toString()).toPath().getParent();\n+            setupBaseDir(cfg);\n+            synchronized (INIT_LOCK) {\n+                // synchronized: the script will run pip which is not concurrency-safe\n+                new ProcessBuilder(\"/bin/sh\", \"-c\", \"./\" + INIT_SHELL_SCRIPT)\n+                        .directory(runtimeBaseDir.toFile())\n+                        .inheritIO()\n+                        .start()\n+                        .waitFor();\n+            }\n+            makeFilesReadOnly(runtimeBaseDir);\n+            context.logger().info(String.format(\"Initialization script took %,d ms\",\n+                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start)));\n+        } catch (Exception e) {\n+            throw new JetException(\"PythonService initialization failed\", e);\n+        }\n+    }\n+\n+    void destroy() {\n+        File runtimeBaseDirF = runtimeBaseDir.toFile();\n+        try {\n+            Path cleanupScriptPath = runtimeBaseDir.resolve(USER_CLEANUP_SHELL_SCRIPT);\n+            if (Files.exists(cleanupScriptPath)) {\n+                new ProcessBuilder(\"/bin/sh\", \"-c\", \"./\" + CLEANUP_SHELL_SCRIPT)\n+                        .directory(runtimeBaseDirF)\n+                        .inheritIO()\n+                        .start()\n+                        .waitFor();\n+            }\n+        } catch (Exception e) {\n+            throw new JetException(\"PythonService cleanup failed\", e);\n+        } finally {\n+            IOUtil.delete(runtimeBaseDir);\n+        }\n+    }\n+\n+    Path runtimeBaseDir() {\n+        return runtimeBaseDir;\n+    }\n+\n+    private void setupBaseDir(PythonServiceConfig cfg) throws IOException {\n+        createParamsScript(runtimeBaseDir.resolve(PARAMS_SCRIPT),\n+                \"HANDLER_MODULE\", cfg.handlerModule(),\n+                \"HANDLER_FUNCTION\", cfg.handlerFunction()\n+        );\n+        for (String fname : asList(\n+                JET_TO_PYTHON_PREFIX + \"pb2.py\",\n+                JET_TO_PYTHON_PREFIX + \"pb2_grpc.py\",\n+                INIT_SHELL_SCRIPT,\n+                MAIN_SHELL_SCRIPT,\n+                CLEANUP_SHELL_SCRIPT,\n+                PYTHON_GRPC_SCRIPT)\n+        ) {\n+            Path destPath = runtimeBaseDir.resolve(fname);\n+            try (InputStream in = Objects.requireNonNull(\n+                    PythonServiceContext.class.getClassLoader().getResourceAsStream(fname), fname);\n+                 OutputStream out = Files.newOutputStream(destPath)\n+            ) {\n+                copyStream(in, out);\n+            }\n+            if (EXECUTABLE_SCRIPTS.contains(fname)) {\n+                makeExecutable(destPath);\n+            }\n+            for (String userScript : USER_EXECUTABLE_SCRIPTS) {\n+                Path scriptPath = runtimeBaseDir.resolve(userScript);\n+                if (Files.exists(scriptPath)) {\n+                    makeExecutable(scriptPath);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void createParamsScript(Path paramsFile, String... namesAndVals) throws IOException {\n+        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(paramsFile))) {\n+            String jetToPython = JET_TO_PYTHON_PREFIX.toUpperCase();\n+            for (int i = 0; i < namesAndVals.length; i += 2) {\n+                String name = namesAndVals[i];\n+                String value = namesAndVals[i + 1];\n+                if (value != null && !value.isEmpty()) {\n+                    out.println(jetToPython + name + \"='\" + value + '\\'');\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void makeExecutable(Path path) throws IOException {\n+        Set<PosixFilePermission> perms = Files.getPosixFilePermissions(path, NOFOLLOW_LINKS);\n+        if (perms.add(PosixFilePermission.OWNER_EXECUTE)) {\n+            Files.setPosixFilePermissions(path, perms);\n+        }\n+    }\n+\n+    private static void makeReadOnly(Path path) throws IOException {\n+        Set<PosixFilePermission> perms = Files.getPosixFilePermissions(path, NOFOLLOW_LINKS);\n+        if (perms.removeAll(WRITE_PERMISSIONS)) {\n+            Files.setPosixFilePermissions(path, perms);\n+        }\n+    }\n+\n+    @SuppressFBWarnings(value = \"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\",\n+            justification = \"it's a false positive since java 11: https://github.com/spotbugs/spotbugs/issues/756\")\n+    private void makeFilesReadOnly(Path basePath) throws IOException {\n+        List<String> filesNotMarked = new ArrayList<>();\n+        Queue<Path> dirQueue = new ArrayDeque<>(singletonList(basePath));", "originalCommit": "b6deb54536bb8297a8465c19dbc9b52242e1e96e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNzc5MA==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r371837790", "bodyText": "isFile returns false if the file is in a directory which lacks the x attribute, see here. It's better to use canRead or to not check at all and rely when we try to read it.", "author": "viliam-durina", "createdAt": "2020-01-28T14:33:55Z", "path": "hazelcast-jet-core/src/main/java/com/hazelcast/jet/JetInstance.java", "diffHunk": "@@ -138,6 +141,17 @@ default Job newJob(@Nonnull Pipeline pipeline) {\n      */\n     @Nonnull\n     default Job newJob(@Nonnull Pipeline pipeline, @Nonnull JobConfig config) {\n+        PipelineImpl impl = (PipelineImpl) pipeline;\n+        for (Entry<String, File> e : impl.attachedFiles().entrySet()) {\n+            File file = e.getValue();\n+            if (file.isDirectory()) {\n+                config.attachDirectory(file, e.getKey());\n+            } else if (file.isFile()) {", "originalCommit": "d40ef2f0136c9a465f0471d6b120392ec5a2ef98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzODIzMQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r372238231", "bodyText": "isFile is used ubiquitously to check that a file exists as a regular file. I can only add one more check file.canRead", "author": "mtopolnik", "createdAt": "2020-01-29T08:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNzc5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI0NDA5NQ==", "url": "https://github.com/hazelcast/hazelcast-jet/pull/1870#discussion_r372244095", "bodyText": "You can't open a file in a directory without the x permission:\n$ cat test/test.txt \ntest\n$ chmod -x test\n$ cat test/test.txt \ncat: test/test.txt: Permission denied", "author": "mtopolnik", "createdAt": "2020-01-29T08:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNzc5MA=="}], "type": "inlineReview"}, {"oid": "3c325141bbac3b396dd42a7b0584c54c399a3a0a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/3c325141bbac3b396dd42a7b0584c54c399a3a0a", "message": "hazelcast-jet-python module", "committedDate": "2020-01-29T11:12:21Z", "type": "forcePushed"}, {"oid": "5be84eec7a5d0ed89397d8945b6d0ba50a147c98", "url": "https://github.com/hazelcast/hazelcast-jet/commit/5be84eec7a5d0ed89397d8945b6d0ba50a147c98", "message": "Fix test", "committedDate": "2020-01-29T14:30:59Z", "type": "forcePushed"}, {"oid": "570e32c1e353106ca7d99f0692832b47c9ce9b9a", "url": "https://github.com/hazelcast/hazelcast-jet/commit/570e32c1e353106ca7d99f0692832b47c9ce9b9a", "message": "Use original filename when deploying resource", "committedDate": "2020-01-29T14:39:15Z", "type": "commit"}, {"oid": "2a2a29c5b073d78675ed449057aed8b1cd59e58d", "url": "https://github.com/hazelcast/hazelcast-jet/commit/2a2a29c5b073d78675ed449057aed8b1cd59e58d", "message": "Check files/URLs for existence and well-formedness\n\nIn JobConfig.", "committedDate": "2020-01-29T14:40:04Z", "type": "commit"}, {"oid": "144db9b361896641bed1d468808f01145d5565d7", "url": "https://github.com/hazelcast/hazelcast-jet/commit/144db9b361896641bed1d468808f01145d5565d7", "message": "Support attaching files to PipelineImpl", "committedDate": "2020-01-29T14:40:04Z", "type": "commit"}, {"oid": "fed77594f020808ca128268066292125ee93ecdf", "url": "https://github.com/hazelcast/hazelcast-jet/commit/fed77594f020808ca128268066292125ee93ecdf", "message": "Support attaching files to ServiceFactory\n\nAlso rewrite the class to use clone-and-update instead of a massive\nconstructor.", "committedDate": "2020-01-29T14:40:04Z", "type": "commit"}, {"oid": "74138289f7086bfb813f10142b3710a83b6479ae", "url": "https://github.com/hazelcast/hazelcast-jet/commit/74138289f7086bfb813f10142b3710a83b6479ae", "message": "hazelcast-jet-python module", "committedDate": "2020-01-29T14:40:04Z", "type": "commit"}, {"oid": "74138289f7086bfb813f10142b3710a83b6479ae", "url": "https://github.com/hazelcast/hazelcast-jet/commit/74138289f7086bfb813f10142b3710a83b6479ae", "message": "hazelcast-jet-python module", "committedDate": "2020-01-29T14:40:04Z", "type": "forcePushed"}]}