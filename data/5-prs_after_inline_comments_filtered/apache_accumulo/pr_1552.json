{"pr_number": 1552, "pr_title": "Fix and simplify TransportCachingIT", "pr_createdAt": "2020-03-06T22:51:22Z", "pr_url": "https://github.com/apache/accumulo/pull/1552", "timeline": [{"oid": "18be6492c85c142e6ebf6cc1ed459fb9456f8c4e", "url": "https://github.com/apache/accumulo/commit/18be6492c85c142e6ebf6cc1ed459fb9456f8c4e", "message": "Fix and simplify TransportCachingIT", "committedDate": "2020-03-06T22:45:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4Mzc5Nw==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389183797", "bodyText": "Instead of waiting for non-empty, could wait for the expected number to start (I think mini starts up 2 by default, but this number can probably be retrieved from the config).", "author": "ctubbsii", "createdAt": "2020-03-06T22:57:09Z", "path": "test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java", "diffHunk": "@@ -18,87 +18,53 @@\n  */\n package org.apache.accumulo.test;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNotSame;\n import static org.junit.Assert.assertSame;\n \n-import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.accumulo.core.Constants;\n import org.apache.accumulo.core.client.Accumulo;\n import org.apache.accumulo.core.client.AccumuloClient;\n import org.apache.accumulo.core.clientImpl.ClientContext;\n import org.apache.accumulo.core.clientImpl.ThriftTransportKey;\n import org.apache.accumulo.core.clientImpl.ThriftTransportPool;\n import org.apache.accumulo.core.conf.ConfigurationTypeHelper;\n import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.ServerServices;\n-import org.apache.accumulo.core.util.ServerServices.Service;\n-import org.apache.accumulo.fate.zookeeper.ZooCache;\n+import org.apache.accumulo.core.util.HostAndPort;\n import org.apache.accumulo.harness.AccumuloClusterHarness;\n import org.apache.thrift.transport.TTransport;\n import org.apache.thrift.transport.TTransportException;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.Lists;\n+\n /**\n  * Test that {@link ThriftTransportPool} actually adheres to the cachedConnection argument\n  */\n public class TransportCachingIT extends AccumuloClusterHarness {\n   private static final Logger log = LoggerFactory.getLogger(TransportCachingIT.class);\n-  private static int ATTEMPTS = 0;\n \n   @Test\n   public void testCachedTransport() throws InterruptedException {\n     try (AccumuloClient client = Accumulo.newClient().from(getClientProps()).build()) {\n-      while (client.instanceOperations().getTabletServers().isEmpty()) {\n+\n+      List<String> tservers;\n+\n+      while ((tservers = client.instanceOperations().getTabletServers()).isEmpty()) {", "originalCommit": "18be6492c85c142e6ebf6cc1ed459fb9456f8c4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4ODg1Ng==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389188856", "bodyText": "I don't think the test needs more than one tserver.", "author": "keith-turner", "createdAt": "2020-03-06T23:15:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4Mzc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MzUzOQ==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389193539", "bodyText": "In that case, we should override mini's config to only start up one.", "author": "ctubbsii", "createdAt": "2020-03-06T23:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4Mzc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5NTgyOA==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389195828", "bodyText": "I think two are fine now.  I would prefer for test to not have config unless needed.", "author": "keith-turner", "createdAt": "2020-03-06T23:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4Mzc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5Njc1Mw==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389196753", "bodyText": "That's fair.", "author": "ctubbsii", "createdAt": "2020-03-06T23:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4Mzc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NTQ4NQ==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389185485", "bodyText": "This might snag on the modernizer plugin. Even if it doesn't, I think the pure Java streams form looks a little cleaner (or maybe I've just been using streams a lot to have acquired an affinity for them):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  List<ThriftTransportKey> servers = Lists.transform(tservers,\n          \n          \n            \n                      serverStr -> new ThriftTransportKey(HostAndPort.fromString(serverStr), rpcTimeout,\n          \n          \n            \n                          context));\n          \n          \n            \n                  List<ThriftTransportKey> servers = tservers.stream().map(serverStr -> {\n          \n          \n            \n                    return new ThriftTransportKey(HostAndPort.fromString(serverStr), rpcTimeout, context);\n          \n          \n            \n                  }).collect(Collectors.toList());\n          \n      \n    \n    \n  \n\n(not necessarily formatted)", "author": "ctubbsii", "createdAt": "2020-03-06T23:03:09Z", "path": "test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java", "diffHunk": "@@ -18,87 +18,53 @@\n  */\n package org.apache.accumulo.test;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNotSame;\n import static org.junit.Assert.assertSame;\n \n-import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.accumulo.core.Constants;\n import org.apache.accumulo.core.client.Accumulo;\n import org.apache.accumulo.core.client.AccumuloClient;\n import org.apache.accumulo.core.clientImpl.ClientContext;\n import org.apache.accumulo.core.clientImpl.ThriftTransportKey;\n import org.apache.accumulo.core.clientImpl.ThriftTransportPool;\n import org.apache.accumulo.core.conf.ConfigurationTypeHelper;\n import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.ServerServices;\n-import org.apache.accumulo.core.util.ServerServices.Service;\n-import org.apache.accumulo.fate.zookeeper.ZooCache;\n+import org.apache.accumulo.core.util.HostAndPort;\n import org.apache.accumulo.harness.AccumuloClusterHarness;\n import org.apache.thrift.transport.TTransport;\n import org.apache.thrift.transport.TTransportException;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.Lists;\n+\n /**\n  * Test that {@link ThriftTransportPool} actually adheres to the cachedConnection argument\n  */\n public class TransportCachingIT extends AccumuloClusterHarness {\n   private static final Logger log = LoggerFactory.getLogger(TransportCachingIT.class);\n-  private static int ATTEMPTS = 0;\n \n   @Test\n   public void testCachedTransport() throws InterruptedException {\n     try (AccumuloClient client = Accumulo.newClient().from(getClientProps()).build()) {\n-      while (client.instanceOperations().getTabletServers().isEmpty()) {\n+\n+      List<String> tservers;\n+\n+      while ((tservers = client.instanceOperations().getTabletServers()).isEmpty()) {\n         // sleep until a tablet server is up\n         Thread.sleep(50);\n       }\n+\n       ClientContext context = (ClientContext) client;\n       long rpcTimeout =\n           ConfigurationTypeHelper.getTimeInMillis(Property.GENERAL_RPC_TIMEOUT.getDefaultValue());\n \n-      ZooCache zc = context.getZooCache();\n-      final String zkRoot = context.getZooKeeperRoot();\n-\n-      // wait until Zookeeper is populated\n-      List<String> children = zc.getChildren(zkRoot + Constants.ZTSERVERS);\n-      while (children.isEmpty()) {\n-        Thread.sleep(100);\n-        children = zc.getChildren(zkRoot + Constants.ZTSERVERS);\n-      }\n-\n-      ArrayList<ThriftTransportKey> servers = new ArrayList<>();\n-      while (servers.isEmpty()) {\n-        for (String tserver : children) {\n-          String path = zkRoot + Constants.ZTSERVERS + \"/\" + tserver;\n-          byte[] data = zc.getLockData(path);\n-          if (data != null) {\n-            String strData = new String(data, UTF_8);\n-            if (!strData.equals(\"master\"))\n-              servers.add(new ThriftTransportKey(\n-                  new ServerServices(strData).getAddress(Service.TSERV_CLIENT), rpcTimeout,\n-                  context));\n-          }\n-        }\n-        ATTEMPTS++;\n-        if (!servers.isEmpty())\n-          break;\n-        else {\n-          if (ATTEMPTS < 100) {\n-            log.warn(\"Making another attempt to add ThriftTransportKey servers\");\n-            Thread.sleep(100);\n-          } else {\n-            log.error(\"Failed to add ThriftTransportKey servers - Failing TransportCachingIT test\");\n-            org.junit.Assert\n-                .fail(\"Failed to add ThriftTransportKey servers - Failing TransportCachingIT test\");\n-          }\n-        }\n-      }\n+      List<ThriftTransportKey> servers = Lists.transform(tservers,\n+          serverStr -> new ThriftTransportKey(HostAndPort.fromString(serverStr), rpcTimeout,\n+              context));", "originalCommit": "18be6492c85c142e6ebf6cc1ed459fb9456f8c4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4ODU1NA==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389188554", "bodyText": "I doubt modernizer would complain because there is no exact analogue.  Using streams requires copying/allocating a new list where Lists.transform does not.  However in this case performance does not matter so using streams is better.", "author": "keith-turner", "createdAt": "2020-03-06T23:14:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NjQ1OA==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389186458", "bodyText": "Do we want this to loop indefinitely? If this is null, could it ever become non-null?", "author": "ctubbsii", "createdAt": "2020-03-06T23:06:08Z", "path": "test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java", "diffHunk": "@@ -158,7 +124,7 @@ public void testCachedTransport() throws InterruptedException {\n       while (fifth == null) {\n         try {\n           // Get a cached transport\n-          fifth = pool.getAnyTransport(servers, true).getSecond();\n+          fifth = pool.getAnyTransport(servers.subList(0, 1), true).getSecond();", "originalCommit": "18be6492c85c142e6ebf6cc1ed459fb9456f8c4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4OTI4OQ==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389189289", "bodyText": "The looping seemed kinda sketchy to me, but I didn't look into it in detail.", "author": "keith-turner", "createdAt": "2020-03-06T23:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NjQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5MTgwMQ==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389191801", "bodyText": "If on the first attempt it gets a TTransportException and on the 2nd attempt it succeeds then it seems like it could become non-null, right?  So maybe the looping is not so sketchy after all.", "author": "keith-turner", "createdAt": "2020-03-06T23:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NjQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5Mzk3MQ==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389193971", "bodyText": "I'm not really sure. I was confused by what the test was trying to do, and the possible outcomes it was trying to account for with the loop, since none of that is documented \ud83d\ude3a\nI will defer to you.", "author": "ctubbsii", "createdAt": "2020-03-06T23:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NjQ1OA=="}], "type": "inlineReview"}, {"oid": "766851b81c5620cc52559f0561929c0552cd9de0", "url": "https://github.com/apache/accumulo/commit/766851b81c5620cc52559f0561929c0552cd9de0", "message": "Update test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java\n\nCo-Authored-By: Christopher Tubbs <ctubbsii@apache.org>", "committedDate": "2020-03-06T23:11:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE5Nzg5NA==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389197894", "bodyText": "I think the imports need to be cleaned up after applying the suggested change to use Java streams. After that, this PR should be good to merge.", "author": "ctubbsii", "createdAt": "2020-03-06T23:54:41Z", "path": "test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java", "diffHunk": "@@ -18,87 +18,53 @@\n  */\n package org.apache.accumulo.test;\n \n-import static java.nio.charset.StandardCharsets.UTF_8;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertNotSame;\n import static org.junit.Assert.assertSame;\n \n-import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.accumulo.core.Constants;\n import org.apache.accumulo.core.client.Accumulo;\n import org.apache.accumulo.core.client.AccumuloClient;\n import org.apache.accumulo.core.clientImpl.ClientContext;\n import org.apache.accumulo.core.clientImpl.ThriftTransportKey;\n import org.apache.accumulo.core.clientImpl.ThriftTransportPool;\n import org.apache.accumulo.core.conf.ConfigurationTypeHelper;\n import org.apache.accumulo.core.conf.Property;\n-import org.apache.accumulo.core.util.ServerServices;\n-import org.apache.accumulo.core.util.ServerServices.Service;\n-import org.apache.accumulo.fate.zookeeper.ZooCache;\n+import org.apache.accumulo.core.util.HostAndPort;\n import org.apache.accumulo.harness.AccumuloClusterHarness;\n import org.apache.thrift.transport.TTransport;\n import org.apache.thrift.transport.TTransportException;\n import org.junit.Test;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import com.google.common.collect.Lists;", "originalCommit": "766851b81c5620cc52559f0561929c0552cd9de0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1NTU4MQ==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389655581", "bodyText": "How does getting the same transport from a list of one test anything?  The last assertSame now doesn't seem like it is testing anything.", "author": "milleruntime", "createdAt": "2020-03-09T13:21:24Z", "path": "test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java", "diffHunk": "@@ -148,7 +114,7 @@ public void testCachedTransport() throws InterruptedException {\n       while (fourth == null) {\n         try {\n           // Get a non-cached transport\n-          fourth = pool.getAnyTransport(servers, false).getSecond();\n+          fourth = pool.getAnyTransport(servers.subList(0, 1), false).getSecond();", "originalCommit": "766851b81c5620cc52559f0561929c0552cd9de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTczODQ0Ng==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389738446", "bodyText": "I think the test is similar between the first/second. Where those were checking basic caching behavior, this one was specifically testing LIFO behavior, as mentioned in the comment above: // ensure the LIFO scheme with a fourth and fifth entry\nHowever, there are still some nuances I don't understand. Like this fourth seems like it is supposed to be for the same server as one of first, second, or third. Fifth is supposed to make sure that it matches fourth, and not the same server from first/second/third (LIFO behavior). However, because we have more than one server, it doesn't seem like there's any guarantee that fourth/fifth refer to the same server as one of first/second/third, so this test might occasionally not test LIFO behavior, and basically do the same as first/second (basic caching) but for a different server than that one chose.\nI think some of this can be resolved if we select servers.subList(0,1) at the beginning of the test, and stick with that one the whole time, so we make sure we're testing with the same server.", "author": "ctubbsii", "createdAt": "2020-03-09T14:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1NTU4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5OTAxNQ==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389799015", "bodyText": "I made the following improvements to the test\n\nUse servers.subList(0,1) for everything\nStrengthened the LIFO check by pulling three things off to check for LIFO order instead of just one\nPulled the redundant while loops into a function\nImproved the comments", "author": "keith-turner", "createdAt": "2020-03-09T16:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1NTU4MQ=="}], "type": "inlineReview"}, {"oid": "4028704774f12419a6b945b318f352a6d72bdf3f", "url": "https://github.com/apache/accumulo/commit/4028704774f12419a6b945b318f352a6d72bdf3f", "message": "Improve test", "committedDate": "2020-03-09T15:48:31Z", "type": "commit"}, {"oid": "188c60ee4cd0478992b39a7ccf4b15bd3152cf16", "url": "https://github.com/apache/accumulo/commit/188c60ee4cd0478992b39a7ccf4b15bd3152cf16", "message": "Improve test", "committedDate": "2020-03-09T15:56:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzNjc4Mg==", "url": "https://github.com/apache/accumulo/pull/1552#discussion_r389836782", "bodyText": "Comment is incorrect:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  assertSame(\"Expected third and sixth transport to be the same instance\", second, seventh);\n          \n          \n            \n                  assertSame(\"Expected second and seventh transport to be the same instance\", second, seventh);", "author": "ctubbsii", "createdAt": "2020-03-09T17:15:15Z", "path": "test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java", "diffHunk": "@@ -49,122 +45,78 @@\n  */\n public class TransportCachingIT extends AccumuloClusterHarness {\n   private static final Logger log = LoggerFactory.getLogger(TransportCachingIT.class);\n-  private static int ATTEMPTS = 0;\n \n   @Test\n   public void testCachedTransport() throws InterruptedException {\n     try (AccumuloClient client = Accumulo.newClient().from(getClientProps()).build()) {\n-      while (client.instanceOperations().getTabletServers().isEmpty()) {\n+\n+      List<String> tservers;\n+\n+      while ((tservers = client.instanceOperations().getTabletServers()).isEmpty()) {\n         // sleep until a tablet server is up\n         Thread.sleep(50);\n       }\n+\n       ClientContext context = (ClientContext) client;\n       long rpcTimeout =\n           ConfigurationTypeHelper.getTimeInMillis(Property.GENERAL_RPC_TIMEOUT.getDefaultValue());\n \n-      ZooCache zc = context.getZooCache();\n-      final String zkRoot = context.getZooKeeperRoot();\n+      List<ThriftTransportKey> servers = tservers.stream().map(serverStr -> {\n+        return new ThriftTransportKey(HostAndPort.fromString(serverStr), rpcTimeout, context);\n+      }).collect(Collectors.toList());\n \n-      // wait until Zookeeper is populated\n-      List<String> children = zc.getChildren(zkRoot + Constants.ZTSERVERS);\n-      while (children.isEmpty()) {\n-        Thread.sleep(100);\n-        children = zc.getChildren(zkRoot + Constants.ZTSERVERS);\n-      }\n-\n-      ArrayList<ThriftTransportKey> servers = new ArrayList<>();\n-      while (servers.isEmpty()) {\n-        for (String tserver : children) {\n-          String path = zkRoot + Constants.ZTSERVERS + \"/\" + tserver;\n-          byte[] data = zc.getLockData(path);\n-          if (data != null) {\n-            String strData = new String(data, UTF_8);\n-            if (!strData.equals(\"master\"))\n-              servers.add(new ThriftTransportKey(\n-                  new ServerServices(strData).getAddress(Service.TSERV_CLIENT), rpcTimeout,\n-                  context));\n-          }\n-        }\n-        ATTEMPTS++;\n-        if (!servers.isEmpty())\n-          break;\n-        else {\n-          if (ATTEMPTS < 100) {\n-            log.warn(\"Making another attempt to add ThriftTransportKey servers\");\n-            Thread.sleep(100);\n-          } else {\n-            log.error(\"Failed to add ThriftTransportKey servers - Failing TransportCachingIT test\");\n-            org.junit.Assert\n-                .fail(\"Failed to add ThriftTransportKey servers - Failing TransportCachingIT test\");\n-          }\n-        }\n-      }\n+      // only want to use one server for all subsequent test\n+      servers = servers.subList(0, 1);\n \n       ThriftTransportPool pool = ThriftTransportPool.getInstance();\n-      TTransport first = null;\n-      while (first == null) {\n-        try {\n-          // Get a transport (cached or not)\n-          first = pool.getAnyTransport(servers, true).getSecond();\n-        } catch (TTransportException e) {\n-          log.warn(\"Failed to obtain transport to {}\", servers);\n-        }\n-      }\n+      TTransport first = getAnyTransport(servers, pool, true);\n \n       assertNotNull(first);\n       // Return it to unreserve it\n       pool.returnTransport(first);\n \n-      TTransport second = null;\n-      while (second == null) {\n-        try {\n-          // Get a cached transport (should be the first)\n-          second = pool.getAnyTransport(servers, true).getSecond();\n-        } catch (TTransportException e) {\n-          log.warn(\"Failed obtain 2nd transport to {}\", servers);\n-        }\n-      }\n+      TTransport second = getAnyTransport(servers, pool, true);\n \n       // We should get the same transport\n       assertSame(\"Expected the first and second to be the same instance\", first, second);\n-      // Return the 2nd\n       pool.returnTransport(second);\n \n-      TTransport third = null;\n-      while (third == null) {\n-        try {\n-          // Get a non-cached transport\n-          third = pool.getAnyTransport(servers, false).getSecond();\n-        } catch (TTransportException e) {\n-          log.warn(\"Failed obtain 3rd transport to {}\", servers);\n-        }\n-      }\n-\n+      // Ensure does not get cached connection just returned\n+      TTransport third = getAnyTransport(servers, pool, false);\n       assertNotSame(\"Expected second and third transport to be different instances\", second, third);\n-      pool.returnTransport(third);\n \n-      // ensure the LIFO scheme with a fourth and fifth entry\n-      TTransport fourth = null;\n-      while (fourth == null) {\n-        try {\n-          // Get a non-cached transport\n-          fourth = pool.getAnyTransport(servers, false).getSecond();\n-        } catch (TTransportException e) {\n-          log.warn(\"Failed obtain 4th transport to {}\", servers);\n-        }\n-      }\n+      TTransport fourth = getAnyTransport(servers, pool, false);\n+      assertNotSame(\"Expected third and fourth transport to be different instances\", third, fourth);\n+\n+      pool.returnTransport(third);\n       pool.returnTransport(fourth);\n-      TTransport fifth = null;\n-      while (fifth == null) {\n-        try {\n-          // Get a cached transport\n-          fifth = pool.getAnyTransport(servers, true).getSecond();\n-        } catch (TTransportException e) {\n-          log.warn(\"Failed obtain 5th transport to {}\", servers);\n-        }\n-      }\n+\n+      // The following three asserts ensure the per server queue is LIFO\n+      TTransport fifth = getAnyTransport(servers, pool, true);\n       assertSame(\"Expected fourth and fifth transport to be the same instance\", fourth, fifth);\n+\n+      TTransport sixth = getAnyTransport(servers, pool, true);\n+      assertSame(\"Expected third and sixth transport to be the same instance\", third, sixth);\n+\n+      TTransport seventh = getAnyTransport(servers, pool, true);\n+      assertSame(\"Expected third and sixth transport to be the same instance\", second, seventh);", "originalCommit": "188c60ee4cd0478992b39a7ccf4b15bd3152cf16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5f389e73205905fb6e93c49160f6625aee064429", "url": "https://github.com/apache/accumulo/commit/5f389e73205905fb6e93c49160f6625aee064429", "message": "Update test/src/main/java/org/apache/accumulo/test/TransportCachingIT.java\n\nCo-Authored-By: Christopher Tubbs <ctubbsii@apache.org>", "committedDate": "2020-03-09T17:32:03Z", "type": "commit"}]}