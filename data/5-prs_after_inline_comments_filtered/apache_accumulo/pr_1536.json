{"pr_number": 1536, "pr_title": "Improve master metrics reported via hadoop metrics", "pr_createdAt": "2020-02-27T23:54:01Z", "pr_url": "https://github.com/apache/accumulo/pull/1536", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDQ1OA==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385740458", "bodyText": "Since a lot of these legacy classes were removed in 2.x, I am not sure how productive it is to refactor them.  If it helps to differentiate between the legacy and the Hadoop2 metrics then I guess it is ok.", "author": "milleruntime", "createdAt": "2020-02-28T14:57:27Z", "path": "server/master/src/main/java/org/apache/accumulo/master/metrics/fate/FateLegacyJMXMetricsMBean.java", "diffHunk": "@@ -16,12 +16,12 @@\n  */\n package org.apache.accumulo.master.metrics.fate;\n \n-public interface FateMetricsMBean {\n+public interface FateLegacyJMXMetricsMBean {", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgyNjc1Mw==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385826753", "bodyText": "This was a rename so that on the merge forward, these JMX specific classes are drooped and hadoop2 metrics classes the can be named FateMetrics.  The interface name needed to change to match the JMX required naming convention", "author": "EdColeman", "createdAt": "2020-02-28T17:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0MDgwMQ==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385740801", "bodyText": "Logger name is wrong.", "author": "milleruntime", "createdAt": "2020-02-28T14:58:03Z", "path": "server/master/src/main/java/org/apache/accumulo/master/metrics/fate/FateMetricSnapshot.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.accumulo.master.metrics.fate;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.StringJoiner;\n+import java.util.TreeMap;\n+\n+import org.apache.accumulo.core.Constants;\n+import org.apache.accumulo.core.zookeeper.ZooUtil;\n+import org.apache.accumulo.fate.AdminUtil;\n+import org.apache.accumulo.fate.ReadOnlyTStore;\n+import org.apache.accumulo.fate.ZooStore;\n+import org.apache.accumulo.fate.zookeeper.ZooReaderWriter;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Immutable class that holds a snapshot of fate metric values - use builder to instantiate\n+ * instance.\n+ */\n+class FateMetricSnapshot {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FateLegacyJMXMetrics.class);", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwNA==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385756204", "bodyText": "Javadoc typo.", "author": "milleruntime", "createdAt": "2020-02-28T15:24:34Z", "path": "server/master/src/main/java/org/apache/accumulo/master/metrics/fate/FateHadoop2Metrics.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.accumulo.master.metrics.fate;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.accumulo.server.metrics.Metrics;\n+import org.apache.accumulo.server.metrics.MetricsSystemHelper;\n+import org.apache.accumulo.server.zookeeper.ZooReaderWriter;\n+import org.apache.hadoop.metrics2.MetricsCollector;\n+import org.apache.hadoop.metrics2.MetricsRecordBuilder;\n+import org.apache.hadoop.metrics2.MetricsSource;\n+import org.apache.hadoop.metrics2.MetricsSystem;\n+import org.apache.hadoop.metrics2.impl.MsInfo;\n+import org.apache.hadoop.metrics2.lib.Interns;\n+import org.apache.hadoop.metrics2.lib.MetricsRegistry;\n+import org.apache.hadoop.metrics2.lib.MutableGaugeLong;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateHadoop2Metrics implements Metrics, MetricsSource {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FateHadoop2Metrics.class);\n+\n+  // limit calls to update fate counters to guard against hammering zookeeper.\n+  private static final long DEFAULT_MIN_REFRESH_DELAY = TimeUnit.SECONDS.toMillis(10);\n+\n+  private volatile long minimumRefreshDelay;\n+\n+  // metrics tag / labels\n+  public static final String NAME = MASTER_NAME + \",sub=Fate\";\n+  public static final String DESCRIPTION = \"Fate Metrics\";\n+  public static final String CONTEXT = \"master\";\n+  public static final String RECORD = \"fate\";\n+\n+  // metric value names\n+  public static final String CUR_FATE_OPS = \"currentFateOps\";\n+  public static final String TOTAL_FATE_OPS = \"totalFateOps\";\n+  public static final String TOTAL_ZK_CONN_ERRORS = \"totalZkConnErrors\";\n+  private static final String FATE_TX_STATE_METRIC_PREFIX = \"FateTxState_\";\n+  private static final String FATE_OP_TYPE_METRIC_PREFIX = \"FateTxOpType_\";\n+\n+  // metric values\n+  private final MutableGaugeLong currentFateOps;\n+  private final MutableGaugeLong zkChildFateOpsTotal;\n+  private final MutableGaugeLong zkConnectionErrorsTotal;\n+  private final Map<String,MutableGaugeLong> fateTypeCounts = new TreeMap<>();\n+  private final Map<String,MutableGaugeLong> fateOpCounts = new TreeMap<>();\n+\n+  private FateMetricSnapshot metricSnapshot;\n+\n+  private final String instanceId;\n+  private final MetricsSystem metricsSystem;\n+  private final MetricsRegistry registry;\n+\n+  private final Lock metricsValuesLock = new ReentrantLock();\n+  private volatile long lastUpdate = 0;\n+\n+  private final ZooReaderWriter zoo;\n+\n+  public FateHadoop2Metrics(final String instanceId, final MetricsSystem metricsSystem,\n+      final long minimumRefreshDelay) {\n+\n+    this.instanceId = instanceId;\n+\n+    zoo = ZooReaderWriter.getInstance();\n+\n+    this.minimumRefreshDelay = Math.max(DEFAULT_MIN_REFRESH_DELAY, minimumRefreshDelay);\n+\n+    this.metricsSystem = metricsSystem;\n+    this.registry = new MetricsRegistry(Interns.info(NAME, DESCRIPTION));\n+    this.registry.tag(MsInfo.ProcessName, MetricsSystemHelper.getProcessName());\n+\n+    currentFateOps = registry.newGauge(CUR_FATE_OPS, \"Current number of FATE Ops\", 0L);\n+    zkChildFateOpsTotal = registry.newGauge(TOTAL_FATE_OPS, \"Total FATE Ops\", 0L);\n+    zkConnectionErrorsTotal =\n+        registry.newGauge(TOTAL_ZK_CONN_ERRORS, \"Total ZK Connection Errors\", 0L);\n+\n+  }\n+\n+  /**\n+   * For testing only: allow refresh delay to be set to any value, over riding the enforced minimum.\n+   *\n+   * @param minimumRefreshDelay\n+   *          set new min refresh value, in seconds.\n+   */\n+  void overrideRefresh(final long minimumRefreshDelay) {\n+    long delay = Math.max(0, minimumRefreshDelay);\n+    this.minimumRefreshDelay = TimeUnit.SECONDS.toMillis(delay);\n+  }\n+\n+  @Override\n+  public void register() {\n+    metricsSystem.register(NAME, DESCRIPTION, this);\n+  }\n+\n+  @Override\n+  public void add(String name, long time) {\n+    throw new UnsupportedOperationException(\"add() is not implemented\");\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  protected void prepareMetrics() {\n+\n+    metricsValuesLock.lock();\n+    try {\n+\n+      long now = System.currentTimeMillis();\n+\n+      if ((lastUpdate + minimumRefreshDelay) < now) {\n+\n+        log.trace(\"Update fate metrics, lastUpdate: {}, now {}\", lastUpdate, now);\n+\n+        metricSnapshot = FateMetricSnapshot.getFromZooKeeper(instanceId, zoo);\n+        lastUpdate = now;\n+\n+        recordValues();\n+      }\n+    } finally {\n+      metricsValuesLock.unlock();\n+    }\n+  }\n+\n+  /**\n+   * Update the metrics gauges from the measured values - this method assumes that concurrent access\n+   * is control externally to this method with the metricsValueLock, and that the lock has been", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MzQ0MA==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385763440", "bodyText": "I think this could be simplified with a computeIfAbsent()", "author": "milleruntime", "createdAt": "2020-02-28T15:36:04Z", "path": "server/master/src/main/java/org/apache/accumulo/master/metrics/fate/FateHadoop2Metrics.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.accumulo.master.metrics.fate;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.accumulo.server.metrics.Metrics;\n+import org.apache.accumulo.server.metrics.MetricsSystemHelper;\n+import org.apache.accumulo.server.zookeeper.ZooReaderWriter;\n+import org.apache.hadoop.metrics2.MetricsCollector;\n+import org.apache.hadoop.metrics2.MetricsRecordBuilder;\n+import org.apache.hadoop.metrics2.MetricsSource;\n+import org.apache.hadoop.metrics2.MetricsSystem;\n+import org.apache.hadoop.metrics2.impl.MsInfo;\n+import org.apache.hadoop.metrics2.lib.Interns;\n+import org.apache.hadoop.metrics2.lib.MetricsRegistry;\n+import org.apache.hadoop.metrics2.lib.MutableGaugeLong;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateHadoop2Metrics implements Metrics, MetricsSource {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FateHadoop2Metrics.class);\n+\n+  // limit calls to update fate counters to guard against hammering zookeeper.\n+  private static final long DEFAULT_MIN_REFRESH_DELAY = TimeUnit.SECONDS.toMillis(10);\n+\n+  private volatile long minimumRefreshDelay;\n+\n+  // metrics tag / labels\n+  public static final String NAME = MASTER_NAME + \",sub=Fate\";\n+  public static final String DESCRIPTION = \"Fate Metrics\";\n+  public static final String CONTEXT = \"master\";\n+  public static final String RECORD = \"fate\";\n+\n+  // metric value names\n+  public static final String CUR_FATE_OPS = \"currentFateOps\";\n+  public static final String TOTAL_FATE_OPS = \"totalFateOps\";\n+  public static final String TOTAL_ZK_CONN_ERRORS = \"totalZkConnErrors\";\n+  private static final String FATE_TX_STATE_METRIC_PREFIX = \"FateTxState_\";\n+  private static final String FATE_OP_TYPE_METRIC_PREFIX = \"FateTxOpType_\";\n+\n+  // metric values\n+  private final MutableGaugeLong currentFateOps;\n+  private final MutableGaugeLong zkChildFateOpsTotal;\n+  private final MutableGaugeLong zkConnectionErrorsTotal;\n+  private final Map<String,MutableGaugeLong> fateTypeCounts = new TreeMap<>();\n+  private final Map<String,MutableGaugeLong> fateOpCounts = new TreeMap<>();\n+\n+  private FateMetricSnapshot metricSnapshot;\n+\n+  private final String instanceId;\n+  private final MetricsSystem metricsSystem;\n+  private final MetricsRegistry registry;\n+\n+  private final Lock metricsValuesLock = new ReentrantLock();\n+  private volatile long lastUpdate = 0;\n+\n+  private final ZooReaderWriter zoo;\n+\n+  public FateHadoop2Metrics(final String instanceId, final MetricsSystem metricsSystem,\n+      final long minimumRefreshDelay) {\n+\n+    this.instanceId = instanceId;\n+\n+    zoo = ZooReaderWriter.getInstance();\n+\n+    this.minimumRefreshDelay = Math.max(DEFAULT_MIN_REFRESH_DELAY, minimumRefreshDelay);\n+\n+    this.metricsSystem = metricsSystem;\n+    this.registry = new MetricsRegistry(Interns.info(NAME, DESCRIPTION));\n+    this.registry.tag(MsInfo.ProcessName, MetricsSystemHelper.getProcessName());\n+\n+    currentFateOps = registry.newGauge(CUR_FATE_OPS, \"Current number of FATE Ops\", 0L);\n+    zkChildFateOpsTotal = registry.newGauge(TOTAL_FATE_OPS, \"Total FATE Ops\", 0L);\n+    zkConnectionErrorsTotal =\n+        registry.newGauge(TOTAL_ZK_CONN_ERRORS, \"Total ZK Connection Errors\", 0L);\n+\n+  }\n+\n+  /**\n+   * For testing only: allow refresh delay to be set to any value, over riding the enforced minimum.\n+   *\n+   * @param minimumRefreshDelay\n+   *          set new min refresh value, in seconds.\n+   */\n+  void overrideRefresh(final long minimumRefreshDelay) {\n+    long delay = Math.max(0, minimumRefreshDelay);\n+    this.minimumRefreshDelay = TimeUnit.SECONDS.toMillis(delay);\n+  }\n+\n+  @Override\n+  public void register() {\n+    metricsSystem.register(NAME, DESCRIPTION, this);\n+  }\n+\n+  @Override\n+  public void add(String name, long time) {\n+    throw new UnsupportedOperationException(\"add() is not implemented\");\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  protected void prepareMetrics() {\n+\n+    metricsValuesLock.lock();\n+    try {\n+\n+      long now = System.currentTimeMillis();\n+\n+      if ((lastUpdate + minimumRefreshDelay) < now) {\n+\n+        log.trace(\"Update fate metrics, lastUpdate: {}, now {}\", lastUpdate, now);\n+\n+        metricSnapshot = FateMetricSnapshot.getFromZooKeeper(instanceId, zoo);\n+        lastUpdate = now;\n+\n+        recordValues();\n+      }\n+    } finally {\n+      metricsValuesLock.unlock();\n+    }\n+  }\n+\n+  /**\n+   * Update the metrics gauges from the measured values - this method assumes that concurrent access\n+   * is control externally to this method with the metricsValueLock, and that the lock has been\n+   * acquired before calling this method.\n+   */\n+  private void recordValues() {\n+\n+    // update individual gauges that are reported.\n+    currentFateOps.set(metricSnapshot.getCurrentFateOps());\n+    zkChildFateOpsTotal.set(metricSnapshot.getZkFateChildOpsTotal());\n+    zkConnectionErrorsTotal.set(metricSnapshot.getZkConnectionErrors());\n+\n+    // the number FATE Tx states (NEW< IN_PROGRESS...) are fixed - the underlying\n+    // getTxStateCounters call will return a current valid count for each possible state.\n+    Map<String,Long> states = metricSnapshot.getTxStateCounters();\n+\n+    states.forEach((key, value) -> {\n+      MutableGaugeLong v = fateTypeCounts.get(key);\n+      if (v != null) {\n+        v.set(value);\n+      } else {\n+        v = registry.newGauge(metricNameHelper(FATE_TX_STATE_METRIC_PREFIX, key),\n+            \"By transaction state count for \" + key, value);\n+        fateTypeCounts.put(key, v);", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2Mzc5MQ==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385763791", "bodyText": "I think this could be simplified with a computeIfAbsent()", "author": "milleruntime", "createdAt": "2020-02-28T15:36:39Z", "path": "server/master/src/main/java/org/apache/accumulo/master/metrics/fate/FateHadoop2Metrics.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.accumulo.master.metrics.fate;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.apache.accumulo.server.metrics.Metrics;\n+import org.apache.accumulo.server.metrics.MetricsSystemHelper;\n+import org.apache.accumulo.server.zookeeper.ZooReaderWriter;\n+import org.apache.hadoop.metrics2.MetricsCollector;\n+import org.apache.hadoop.metrics2.MetricsRecordBuilder;\n+import org.apache.hadoop.metrics2.MetricsSource;\n+import org.apache.hadoop.metrics2.MetricsSystem;\n+import org.apache.hadoop.metrics2.impl.MsInfo;\n+import org.apache.hadoop.metrics2.lib.Interns;\n+import org.apache.hadoop.metrics2.lib.MetricsRegistry;\n+import org.apache.hadoop.metrics2.lib.MutableGaugeLong;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FateHadoop2Metrics implements Metrics, MetricsSource {\n+\n+  private static final Logger log = LoggerFactory.getLogger(FateHadoop2Metrics.class);\n+\n+  // limit calls to update fate counters to guard against hammering zookeeper.\n+  private static final long DEFAULT_MIN_REFRESH_DELAY = TimeUnit.SECONDS.toMillis(10);\n+\n+  private volatile long minimumRefreshDelay;\n+\n+  // metrics tag / labels\n+  public static final String NAME = MASTER_NAME + \",sub=Fate\";\n+  public static final String DESCRIPTION = \"Fate Metrics\";\n+  public static final String CONTEXT = \"master\";\n+  public static final String RECORD = \"fate\";\n+\n+  // metric value names\n+  public static final String CUR_FATE_OPS = \"currentFateOps\";\n+  public static final String TOTAL_FATE_OPS = \"totalFateOps\";\n+  public static final String TOTAL_ZK_CONN_ERRORS = \"totalZkConnErrors\";\n+  private static final String FATE_TX_STATE_METRIC_PREFIX = \"FateTxState_\";\n+  private static final String FATE_OP_TYPE_METRIC_PREFIX = \"FateTxOpType_\";\n+\n+  // metric values\n+  private final MutableGaugeLong currentFateOps;\n+  private final MutableGaugeLong zkChildFateOpsTotal;\n+  private final MutableGaugeLong zkConnectionErrorsTotal;\n+  private final Map<String,MutableGaugeLong> fateTypeCounts = new TreeMap<>();\n+  private final Map<String,MutableGaugeLong> fateOpCounts = new TreeMap<>();\n+\n+  private FateMetricSnapshot metricSnapshot;\n+\n+  private final String instanceId;\n+  private final MetricsSystem metricsSystem;\n+  private final MetricsRegistry registry;\n+\n+  private final Lock metricsValuesLock = new ReentrantLock();\n+  private volatile long lastUpdate = 0;\n+\n+  private final ZooReaderWriter zoo;\n+\n+  public FateHadoop2Metrics(final String instanceId, final MetricsSystem metricsSystem,\n+      final long minimumRefreshDelay) {\n+\n+    this.instanceId = instanceId;\n+\n+    zoo = ZooReaderWriter.getInstance();\n+\n+    this.minimumRefreshDelay = Math.max(DEFAULT_MIN_REFRESH_DELAY, minimumRefreshDelay);\n+\n+    this.metricsSystem = metricsSystem;\n+    this.registry = new MetricsRegistry(Interns.info(NAME, DESCRIPTION));\n+    this.registry.tag(MsInfo.ProcessName, MetricsSystemHelper.getProcessName());\n+\n+    currentFateOps = registry.newGauge(CUR_FATE_OPS, \"Current number of FATE Ops\", 0L);\n+    zkChildFateOpsTotal = registry.newGauge(TOTAL_FATE_OPS, \"Total FATE Ops\", 0L);\n+    zkConnectionErrorsTotal =\n+        registry.newGauge(TOTAL_ZK_CONN_ERRORS, \"Total ZK Connection Errors\", 0L);\n+\n+  }\n+\n+  /**\n+   * For testing only: allow refresh delay to be set to any value, over riding the enforced minimum.\n+   *\n+   * @param minimumRefreshDelay\n+   *          set new min refresh value, in seconds.\n+   */\n+  void overrideRefresh(final long minimumRefreshDelay) {\n+    long delay = Math.max(0, minimumRefreshDelay);\n+    this.minimumRefreshDelay = TimeUnit.SECONDS.toMillis(delay);\n+  }\n+\n+  @Override\n+  public void register() {\n+    metricsSystem.register(NAME, DESCRIPTION, this);\n+  }\n+\n+  @Override\n+  public void add(String name, long time) {\n+    throw new UnsupportedOperationException(\"add() is not implemented\");\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    return true;\n+  }\n+\n+  protected void prepareMetrics() {\n+\n+    metricsValuesLock.lock();\n+    try {\n+\n+      long now = System.currentTimeMillis();\n+\n+      if ((lastUpdate + minimumRefreshDelay) < now) {\n+\n+        log.trace(\"Update fate metrics, lastUpdate: {}, now {}\", lastUpdate, now);\n+\n+        metricSnapshot = FateMetricSnapshot.getFromZooKeeper(instanceId, zoo);\n+        lastUpdate = now;\n+\n+        recordValues();\n+      }\n+    } finally {\n+      metricsValuesLock.unlock();\n+    }\n+  }\n+\n+  /**\n+   * Update the metrics gauges from the measured values - this method assumes that concurrent access\n+   * is control externally to this method with the metricsValueLock, and that the lock has been\n+   * acquired before calling this method.\n+   */\n+  private void recordValues() {\n+\n+    // update individual gauges that are reported.\n+    currentFateOps.set(metricSnapshot.getCurrentFateOps());\n+    zkChildFateOpsTotal.set(metricSnapshot.getZkFateChildOpsTotal());\n+    zkConnectionErrorsTotal.set(metricSnapshot.getZkConnectionErrors());\n+\n+    // the number FATE Tx states (NEW< IN_PROGRESS...) are fixed - the underlying\n+    // getTxStateCounters call will return a current valid count for each possible state.\n+    Map<String,Long> states = metricSnapshot.getTxStateCounters();\n+\n+    states.forEach((key, value) -> {\n+      MutableGaugeLong v = fateTypeCounts.get(key);\n+      if (v != null) {\n+        v.set(value);\n+      } else {\n+        v = registry.newGauge(metricNameHelper(FATE_TX_STATE_METRIC_PREFIX, key),\n+            \"By transaction state count for \" + key, value);\n+        fateTypeCounts.put(key, v);\n+      }\n+    });\n+\n+    // the op types are dynamic and the metric gauges generated when first seen. After\n+    // that the values need to be cleared and set any new values present. This is so\n+    // that the metrics system will report \"known\" values once seen. In operation, the\n+    // number of types will be a fairly small set and should populate with normal operations.\n+\n+    // clear current values.\n+    fateOpCounts.forEach((key, value) -> value.set(0));\n+\n+    // update new counts, create new gauge if first time seen.\n+    Map<String,Long> opTypes = metricSnapshot.getOpTypeCounters();\n+\n+    log.trace(\"OP Counts Before: prev {}, updates {}\", fateOpCounts, opTypes);\n+\n+    opTypes.forEach((key, value) -> {\n+      MutableGaugeLong g = fateOpCounts.get(key);\n+      if (g != null) {\n+        g.set(value);\n+      } else {\n+        g = registry.newGauge(metricNameHelper(FATE_OP_TYPE_METRIC_PREFIX, key),\n+            \"By transaction op type count for \" + key, value);\n+        fateOpCounts.put(key, g);", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4Njc1Mg==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385786752", "bodyText": "Method is unused.  You could always call it in the test since you are checking the boolean.  You could also make the one in MastMetricsIT static to reuse it between the ITs and pass in the boolean.", "author": "milleruntime", "createdAt": "2020-02-28T16:16:32Z", "path": "test/src/main/java/org/apache/accumulo/test/functional/LegacyMetricsIT.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.test.functional;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.accumulo.core.client.AccumuloException;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.harness.AccumuloClusterHarness;\n+import org.apache.accumulo.minicluster.impl.MiniAccumuloConfigImpl;\n+import org.apache.accumulo.test.util.SlowOps;\n+import org.apache.hadoop.conf.Configuration;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Basic functional test to verify enabling legacy metrics does not kill master.\n+ */\n+public class LegacyMetricsIT extends AccumuloClusterHarness {\n+\n+  private static final Logger log = LoggerFactory.getLogger(LegacyMetricsIT.class);\n+\n+  // number of tables / concurrent compactions used during testing.\n+  private final int tableCount = 1;\n+\n+  private long maxWait = 15_000;\n+\n+  @Override\n+  public void configureMiniCluster(MiniAccumuloConfigImpl cfg, Configuration hadoopCoreSite) {\n+    cfg.setProperty(Property.GENERAL_LEGACY_METRICS, \"true\");\n+  }\n+\n+  /**\n+   * MANUAL TESTS ONLY - forces pause to allow jconsole connection\n+   */\n+  private final boolean PAUSE_FOR_MANUAL_TEST = false;\n+\n+  @Before\n+  public void setup() {}\n+\n+  @Override\n+  protected int defaultTimeoutSeconds() {\n+    return 4 * 60;\n+  }\n+\n+  /**\n+   * Validates that the expected metrics are published - this excludes the dynamic metrics derived\n+   * from operation types.\n+   */\n+  @Test\n+  public void useMaster() {\n+\n+    boolean legacyMetricsEnabled =\n+        cluster.getSiteConfiguration().getBoolean(Property.GENERAL_LEGACY_METRICS);\n+\n+    assertTrue(legacyMetricsEnabled);\n+\n+    List<SlowOps> tables = new ArrayList<>();\n+\n+    for (int i = 0; i < tableCount; i++) {\n+      String uniqueName = getUniqueNames(1)[0] + \"_\" + i;\n+      SlowOps gen = new SlowOps(getConnector(), uniqueName, maxWait, tableCount);\n+      tables.add(gen);\n+      gen.startCompactTask();\n+    }\n+\n+    // use calls that should need the master\n+\n+    try {\n+\n+      getConnector().instanceOperations().waitForBalance();\n+\n+      Map<String,String> configs = getConnector().instanceOperations().getSystemConfiguration();\n+      assertTrue(\"master config should not be empty\", !configs.isEmpty());\n+\n+    } catch (AccumuloException | AccumuloSecurityException ex) {\n+      fail(\"Could not get config from master\");\n+    }\n+\n+    // clean-up cancel running compactions\n+    for (SlowOps t : tables) {\n+      try {\n+        getConnector().tableOperations().cancelCompaction(t.getTableName());\n+        // block if compaction still running\n+        boolean cancelled = t.blockWhileCompactionRunning();\n+        if (!cancelled) {\n+          log.info(\"Failed to cancel compaction during multiple compaction test clean-up for {}\",\n+              t.getTableName());\n+        }\n+      } catch (AccumuloSecurityException | TableNotFoundException | AccumuloException ex) {\n+        log.debug(\"Exception thrown during multiple table test clean-up\", ex);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Pause for manual testing - allow time to connect with jconsole after launch.\n+   *\n+   * @param sleep_ms\n+   *          sleep duration in milliseconds\n+   */\n+  private void manual_test_pause(int sleep_ms) {", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3NTIxMQ==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385875211", "bodyText": "Being that I must be the only one that finds these markers helpful for recalling a good place to put a pause for manual testing with jconsole, I've removed the code.", "author": "EdColeman", "createdAt": "2020-02-28T19:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4Njc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NzI1Mg==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385787252", "bodyText": "Do you need the SlowOps to just verify Master is up and running?  Seems like this would just make the IT run longer.", "author": "milleruntime", "createdAt": "2020-02-28T16:17:26Z", "path": "test/src/main/java/org/apache/accumulo/test/functional/LegacyMetricsIT.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.test.functional;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.accumulo.core.client.AccumuloException;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.harness.AccumuloClusterHarness;\n+import org.apache.accumulo.minicluster.impl.MiniAccumuloConfigImpl;\n+import org.apache.accumulo.test.util.SlowOps;\n+import org.apache.hadoop.conf.Configuration;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Basic functional test to verify enabling legacy metrics does not kill master.\n+ */\n+public class LegacyMetricsIT extends AccumuloClusterHarness {\n+\n+  private static final Logger log = LoggerFactory.getLogger(LegacyMetricsIT.class);\n+\n+  // number of tables / concurrent compactions used during testing.\n+  private final int tableCount = 1;\n+\n+  private long maxWait = 15_000;\n+\n+  @Override\n+  public void configureMiniCluster(MiniAccumuloConfigImpl cfg, Configuration hadoopCoreSite) {\n+    cfg.setProperty(Property.GENERAL_LEGACY_METRICS, \"true\");\n+  }\n+\n+  /**\n+   * MANUAL TESTS ONLY - forces pause to allow jconsole connection\n+   */\n+  private final boolean PAUSE_FOR_MANUAL_TEST = false;\n+\n+  @Before\n+  public void setup() {}\n+\n+  @Override\n+  protected int defaultTimeoutSeconds() {\n+    return 4 * 60;\n+  }\n+\n+  /**\n+   * Validates that the expected metrics are published - this excludes the dynamic metrics derived\n+   * from operation types.\n+   */\n+  @Test\n+  public void useMaster() {\n+\n+    boolean legacyMetricsEnabled =\n+        cluster.getSiteConfiguration().getBoolean(Property.GENERAL_LEGACY_METRICS);\n+\n+    assertTrue(legacyMetricsEnabled);\n+\n+    List<SlowOps> tables = new ArrayList<>();\n+\n+    for (int i = 0; i < tableCount; i++) {\n+      String uniqueName = getUniqueNames(1)[0] + \"_\" + i;\n+      SlowOps gen = new SlowOps(getConnector(), uniqueName, maxWait, tableCount);\n+      tables.add(gen);\n+      gen.startCompactTask();\n+    }", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwODk1NQ==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385908955", "bodyText": "Changed to use table create / delete so master / tablets did have some work required.  The compaction only ran for a short while, but create/delete should be quicker.", "author": "EdColeman", "createdAt": "2020-02-28T20:32:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4NzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc4OTA4Ng==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385789086", "bodyText": "A glimpse into the future?? Haha", "author": "milleruntime", "createdAt": "2020-02-28T16:20:50Z", "path": "test/src/main/java/org/apache/accumulo/test/functional/MasterMetricsIT.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.test.functional;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.accumulo.core.client.AccumuloException;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.harness.AccumuloClusterHarness;\n+import org.apache.accumulo.minicluster.impl.MiniAccumuloConfigImpl;\n+import org.apache.accumulo.test.metrics.MetricsFileTailer;\n+import org.apache.accumulo.test.util.SlowOps;\n+import org.apache.hadoop.conf.Configuration;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Functional test that uses a hadoop metrics 2 file sink to read published metrics for\n+ * verification.\n+ */\n+public class MasterMetricsIT extends AccumuloClusterHarness {\n+\n+  private static final Logger log = LoggerFactory.getLogger(MasterMetricsIT.class);\n+\n+  private static final int NUM_TAIL_ATTEMPTS = 20;\n+  private static final long TAIL_DELAY = 5_000;\n+\n+  // number of tables / concurrent compactions used during testing.\n+  private final int tableCount = 4;\n+\n+  private long maxWait;\n+\n+  private static final Set<String> REQUIRED_METRIC_KEYS =\n+      new HashSet<>(Arrays.asList(\"currentFateOps\", \"totalFateOps\", \"totalZkConnErrors\",\n+          \"FateTxState_NEW\", \"FateTxState_IN_PROGRESS\", \"FateTxState_FAILED_IN_PROGRESS\",\n+          \"FateTxState_FAILED\", \"FateTxState_SUCCESSFUL\", \"FateTxState_UNKNOWN\"));\n+\n+  private static final Set<String> OPTIONAL_METRIC_KEYS =\n+      new HashSet<>(Collections.singletonList(\"FateTxOpType_CompactRange\"));\n+\n+  private MetricsFileTailer metricsTail = null;\n+\n+  /**\n+   * MANUAL TESTS ONLY - forces pause to allow jconsole connection\n+   */\n+  private final boolean PAUSE_FOR_MANUAL_TEST = false;\n+\n+  @Override\n+  public void configureMiniCluster(MiniAccumuloConfigImpl cfg, Configuration hadoopCoreSite) {\n+    cfg.setProperty(Property.GENERAL_LEGACY_METRICS, \"false\");\n+    cfg.setProperty(Property.MASTER_FATE_METRICS_ENABLED, \"true\");\n+  }\n+\n+  @Before\n+  public void setup() {\n+\n+    if (testDisabled()) {\n+      return;\n+    }\n+\n+    // accumuloClient = Accumulo.newClient().from(getClientProps()).build();", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5Mzc4Mg==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385793782", "bodyText": "Shouldn't this configuration validation be done in MasterMetricsFactory when the properties are read by the Master?  I didn't see any actual check for this.", "author": "milleruntime", "createdAt": "2020-02-28T16:29:08Z", "path": "test/src/main/java/org/apache/accumulo/test/functional/MasterMetricsIT.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.test.functional;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import org.apache.accumulo.core.client.AccumuloException;\n+import org.apache.accumulo.core.client.AccumuloSecurityException;\n+import org.apache.accumulo.core.client.TableNotFoundException;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.harness.AccumuloClusterHarness;\n+import org.apache.accumulo.minicluster.impl.MiniAccumuloConfigImpl;\n+import org.apache.accumulo.test.metrics.MetricsFileTailer;\n+import org.apache.accumulo.test.util.SlowOps;\n+import org.apache.hadoop.conf.Configuration;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Functional test that uses a hadoop metrics 2 file sink to read published metrics for\n+ * verification.\n+ */\n+public class MasterMetricsIT extends AccumuloClusterHarness {\n+\n+  private static final Logger log = LoggerFactory.getLogger(MasterMetricsIT.class);\n+\n+  private static final int NUM_TAIL_ATTEMPTS = 20;\n+  private static final long TAIL_DELAY = 5_000;\n+\n+  // number of tables / concurrent compactions used during testing.\n+  private final int tableCount = 4;\n+\n+  private long maxWait;\n+\n+  private static final Set<String> REQUIRED_METRIC_KEYS =\n+      new HashSet<>(Arrays.asList(\"currentFateOps\", \"totalFateOps\", \"totalZkConnErrors\",\n+          \"FateTxState_NEW\", \"FateTxState_IN_PROGRESS\", \"FateTxState_FAILED_IN_PROGRESS\",\n+          \"FateTxState_FAILED\", \"FateTxState_SUCCESSFUL\", \"FateTxState_UNKNOWN\"));\n+\n+  private static final Set<String> OPTIONAL_METRIC_KEYS =\n+      new HashSet<>(Collections.singletonList(\"FateTxOpType_CompactRange\"));\n+\n+  private MetricsFileTailer metricsTail = null;\n+\n+  /**\n+   * MANUAL TESTS ONLY - forces pause to allow jconsole connection\n+   */\n+  private final boolean PAUSE_FOR_MANUAL_TEST = false;\n+\n+  @Override\n+  public void configureMiniCluster(MiniAccumuloConfigImpl cfg, Configuration hadoopCoreSite) {\n+    cfg.setProperty(Property.GENERAL_LEGACY_METRICS, \"false\");\n+    cfg.setProperty(Property.MASTER_FATE_METRICS_ENABLED, \"true\");\n+  }\n+\n+  @Before\n+  public void setup() {\n+\n+    if (testDisabled()) {\n+      return;\n+    }\n+\n+    // accumuloClient = Accumulo.newClient().from(getClientProps()).build();\n+    maxWait = defaultTimeoutSeconds() <= 0 ? 60_000 : ((defaultTimeoutSeconds() * 1000) / 2);\n+\n+    metricsTail = new MetricsFileTailer(\"accumulo.sink.file-master\");\n+    Thread t1 = new Thread(metricsTail);\n+    t1.start();\n+\n+  }\n+\n+  @After\n+  public void cleanup() {\n+    if (metricsTail != null) {\n+      metricsTail.close();\n+    }\n+  }\n+\n+  @Override\n+  protected int defaultTimeoutSeconds() {\n+    return 4 * 60;\n+  }\n+\n+  /**\n+   * Validates that the expected metrics are published - this excludes the dynamic metrics derived\n+   * from operation types.\n+   */\n+  @Test\n+  public void metricsPublished() {\n+\n+    if (testDisabled()) {\n+      log.info(\"Skipping test - master metrics not enabled.\");\n+      return;\n+    }\n+\n+    // throw away first update - could be from previous test (possible with cluster\n+    // restarts in each test)\n+    MetricsFileTailer.LineUpdate firstUpdate =\n+        metricsTail.waitForUpdate(-1, NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    firstUpdate =\n+        metricsTail.waitForUpdate(firstUpdate.getLastUpdate(), NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    Map<String,Long> firstSeenMap = parseLine(firstUpdate.getLine());\n+\n+    log.debug(\"Line received: {}\", firstUpdate.getLine());\n+    log.info(\"Expected metrics count: {}\", REQUIRED_METRIC_KEYS.size());\n+    log.info(\"Received metrics count: {},  values:{}\", firstSeenMap.size(), firstSeenMap);\n+\n+    assertTrue(lookForExpectedKeys(firstSeenMap));\n+    sanity(firstSeenMap);\n+\n+    MetricsFileTailer.LineUpdate nextUpdate =\n+        metricsTail.waitForUpdate(firstUpdate.getLastUpdate(), NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    Map<String,Long> updateSeenMap = parseLine(nextUpdate.getLine());\n+\n+    log.debug(\"Line received:{}\", nextUpdate.getLine());\n+    log.trace(\"Mapped values:{}\", updateSeenMap);\n+\n+    assertTrue(lookForExpectedKeys(updateSeenMap));\n+    sanity(updateSeenMap);\n+\n+    validate(firstSeenMap, updateSeenMap);\n+  }\n+\n+  /**\n+   * Run a few compactions - this should trigger the a dynamic op type to be included in the\n+   * metrics.\n+   */\n+  @Test\n+  public void compactionMetrics() {\n+\n+    if (testDisabled()) {\n+      log.info(\"Skipping test - MASTER_FATE_METRICS_ENABLED is not enabled\");\n+      return;\n+    }\n+\n+    MetricsFileTailer.LineUpdate firstUpdate =\n+        metricsTail.waitForUpdate(-1, NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    List<SlowOps> tables = new ArrayList<>();\n+\n+    for (int i = 0; i < tableCount; i++) {\n+      String uniqueName = getUniqueNames(1)[0] + \"_\" + i;\n+      SlowOps gen = new SlowOps(getConnector(), uniqueName, maxWait, tableCount);\n+      tables.add(gen);\n+      gen.startCompactTask();\n+    }\n+\n+    // check file tailer here....\n+    MetricsFileTailer.LineUpdate nextUpdate =\n+        metricsTail.waitForUpdate(firstUpdate.getLastUpdate(), NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    log.info(\"Received metrics {}\", nextUpdate);\n+\n+    Map<String,String> results = blockForRequiredTables();\n+\n+    assertFalse(results.isEmpty());\n+    log.info(\"IN_PROGRESS: {}\", results.get(\"FateTxState_IN_PROGRESS\"));\n+\n+    assertTrue(Long.parseLong(results.get(\"FateTxState_IN_PROGRESS\")) >= tableCount);\n+    assertTrue(Long.parseLong(results.get(\"FateTxOpType_CompactRange\")) >= tableCount);\n+\n+    for (String k : OPTIONAL_METRIC_KEYS) {\n+      assertTrue(results.containsKey(k));\n+      assertTrue(Long.parseLong(results.get(k)) >= tableCount);\n+    }\n+\n+    manual_test_pause(60_000);\n+\n+    // clean-up cancel running compactions\n+    for (SlowOps t : tables) {\n+      try {\n+        getConnector().tableOperations().cancelCompaction(t.getTableName());\n+        // block if compaction still running\n+        boolean cancelled = t.blockWhileCompactionRunning();\n+        if (!cancelled) {\n+          log.info(\"Failed to cancel compaction during multiple compaction test clean-up for {}\",\n+              t.getTableName());\n+        }\n+      } catch (AccumuloSecurityException | TableNotFoundException | AccumuloException ex) {\n+        log.debug(\"Exception thrown during multiple table test clean-up\", ex);\n+      }\n+    }\n+\n+    // wait for one more metrics update after compactions cancelled.\n+    MetricsFileTailer.LineUpdate update =\n+        metricsTail.waitForUpdate(0L, NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    metricsTail.waitForUpdate(update.getLastUpdate(), NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    results = metricsTail.parseLine(\"\");\n+\n+    log.info(\"Received metrics {}\", results);\n+\n+    manual_test_pause(300_000);\n+  }\n+\n+  /**\n+   * Pause for manual testing - allow time to connect with jconsole after launch.\n+   *\n+   * @param sleep_ms\n+   *          sleep duration in milliseconds\n+   */\n+  private void manual_test_pause(int sleep_ms) {\n+    if (!PAUSE_FOR_MANUAL_TEST) {\n+      return;\n+    }\n+    try {\n+      Thread.sleep(sleep_ms);\n+    } catch (InterruptedException ex) {\n+      Thread.currentThread().interrupt();\n+    }\n+  }\n+\n+  private Map<String,String> blockForRequiredTables() {\n+\n+    MetricsFileTailer.LineUpdate update =\n+        metricsTail.waitForUpdate(0L, NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+    for (int i = 0; i < 20; i++) {\n+\n+      update = metricsTail.waitForUpdate(update.getLastUpdate(), NUM_TAIL_ATTEMPTS, TAIL_DELAY);\n+\n+      log.info(\"Received metrics update {}\", update);\n+\n+      Map<String,String> results = metricsTail.parseLine(\"\");\n+\n+      if (results != null && results.size() > 0\n+          && Long.parseLong(results.get(\"currentFateOps\")) >= tableCount) {\n+        log.info(\"Found required number of fate operations\");\n+        return results;\n+      }\n+      try {\n+        Thread.sleep(10_000);\n+      } catch (InterruptedException iex) {\n+        Thread.currentThread().interrupt();\n+        return Collections.emptyMap();\n+      }\n+\n+    }\n+    return Collections.emptyMap();\n+  }\n+\n+  /**\n+   * Validate metrics for consistency with in a run cycle.\n+   *\n+   * @param values\n+   *          map of values from one run cycle.\n+   */\n+  private void sanity(final Map<String,Long> values) {\n+\n+    assertTrue(values.get(\"currentFateOps\") <= values.get(\"totalFateOps\"));\n+\n+    long total = values.entrySet().stream().filter(x -> x.getKey().startsWith(\"FateTxState_\"))\n+        .mapToLong(Map.Entry::getValue).sum();\n+\n+    assertTrue(total >= values.get(\"currentFateOps\"));\n+  }\n+\n+  /**\n+   * A series of sanity checks for the metrics between different update cycles, some values should\n+   * be at least different, and some of the checks can include ordering.\n+   *\n+   * @param firstSeen\n+   *          map of first metric update\n+   * @param nextSeen\n+   *          map of a later metric update.\n+   */\n+  private void validate(Map<String,Long> firstSeen, Map<String,Long> nextSeen) {\n+    // total fate ops should not decrease.\n+    log.debug(\"Total fate ops.  Before:{}, Update:{}\", firstSeen.get(\"totalFateOps\"),\n+        nextSeen.get(\"totalFateOps\"));\n+    assertTrue(firstSeen.get(\"totalFateOps\") <= nextSeen.get(\"totalFateOps\"));\n+  }\n+\n+  /**\n+   * The hadoop metrics file sink published records as a line with comma separated key=value pairs.\n+   * This method parses the line and extracts the key, value pair from metrics that start with AccGc\n+   * and returns them in a sort map.\n+   *\n+   * @param line\n+   *          a line from the metrics system file sink.\n+   * @return a map of the metrics that match REQUIRED_METRICS_KEYS\n+   */\n+  private Map<String,Long> parseLine(final String line) {\n+\n+    if (line == null) {\n+      return Collections.emptyMap();\n+    }\n+\n+    Map<String,Long> m = new TreeMap<>();\n+\n+    String[] csvTokens = line.split(\",\");\n+\n+    for (String token : csvTokens) {\n+      token = token.trim();\n+      String[] parts = token.split(\"=\");\n+      if (REQUIRED_METRIC_KEYS.contains(parts[0])) {\n+        m.put(parts[0], Long.parseLong(parts[1]));\n+      }\n+    }\n+    return m;\n+  }\n+\n+  private boolean lookForExpectedKeys(final Map<String,Long> received) {\n+\n+    for (String e : REQUIRED_METRIC_KEYS) {\n+      if (!received.containsKey(e)) {\n+        log.info(\"Couldn't find {}\", e);\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * FATE metrics only valid when MASTER_FATE_METRICS_ENABLED=true and GENERAL_LEGACY_METRICS=flase\n+   *\n+   * @return true if test should run\n+   */\n+  private boolean testDisabled() {\n+\n+    boolean fateMetricsEnabled =\n+        cluster.getSiteConfiguration().getBoolean(Property.MASTER_FATE_METRICS_ENABLED);\n+\n+    boolean useLegacyMetrics =\n+        cluster.getSiteConfiguration().getBoolean(Property.GENERAL_LEGACY_METRICS);\n+\n+    if (!fateMetricsEnabled || useLegacyMetrics) {\n+\n+      log.info(\"master fate metrics are disabled - MASTER_FATE_METRICS_ENABLED={}, \"\n+          + \"GENERAL_LEGACY_METRICS={}\", fateMetricsEnabled, useLegacyMetrics);", "originalCommit": "b9fa99d96c6144f7e7280ac0b44959be8cf79b71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3NDM2NQ==", "url": "https://github.com/apache/accumulo/pull/1536#discussion_r385874365", "bodyText": "The tests are only valid with hadoop2 metrics - this prevents test failures if legancy metrics were enabled during the testing.  Added a warning if legacy metrics are enabled that additional FATE metrics added by this PR will not be available.", "author": "EdColeman", "createdAt": "2020-02-28T19:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5Mzc4Mg=="}], "type": "inlineReview"}, {"oid": "639e63c2e1e2bdb4472be741dd6e9f2541fe600d", "url": "https://github.com/apache/accumulo/commit/639e63c2e1e2bdb4472be741dd6e9f2541fe600d", "message": "Improve master metrics rported\n\nAdds FATE transaction state and op types reported via hadoop metrics2\nImproves metrics tests\nAdd IT to verify that enabling legacy metrics does not crash master\nAdded ZooReaderWriter getInstance() for testing.", "committedDate": "2020-03-05T17:14:11Z", "type": "commit"}, {"oid": "639e63c2e1e2bdb4472be741dd6e9f2541fe600d", "url": "https://github.com/apache/accumulo/commit/639e63c2e1e2bdb4472be741dd6e9f2541fe600d", "message": "Improve master metrics rported\n\nAdds FATE transaction state and op types reported via hadoop metrics2\nImproves metrics tests\nAdd IT to verify that enabling legacy metrics does not crash master\nAdded ZooReaderWriter getInstance() for testing.", "committedDate": "2020-03-05T17:14:11Z", "type": "forcePushed"}]}