{"pr_number": 1818, "pr_title": "Fixes #1808 - Stop server side VM on Error in Thread", "pr_createdAt": "2020-11-30T20:06:00Z", "pr_url": "https://github.com/apache/accumulo/pull/1818", "timeline": [{"oid": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "url": "https://github.com/apache/accumulo/commit/d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "message": "Fixes #1808 - Stop server side VM on Error in Thread\n\nModified the AccumuloUncaughtExceptionHandler to log Exception and\nError and Halt the VM if the system property HaltVMOnThreadError\nis set to true. Modified all Executors to use the NamingThreadFactory\nwhich uses AccumuloUncaughtExceptionHandler. When modifying\nSimpleTimer I found that some critical tasks could fail and only\nbe logged. Created SimpleCriticalTimer for the critical tasks.", "committedDate": "2020-11-30T20:00:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MjI3NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532882274", "bodyText": "We don't need String.format here. The slf4j logger supports substitution with {}\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.error(String.format(\"Caught an exception in %s.\", t), e);\n          \n          \n            \n                    log.error(\"Caught an exception in {}.\", t, e);", "author": "ctubbsii", "createdAt": "2020-11-30T20:26:34Z", "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+    } else {\n+      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n+        log.error(String.format(\"Caught an exception in %s.\", t), e);", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MzIyOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532883229", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n          \n          \n            \n                  log.error(\"Caught an exception in {}. Thread is dead.\", t, e);", "author": "ctubbsii", "createdAt": "2020-11-30T20:28:27Z", "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4MzU3OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532883579", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n          \n          \n            \n                    log.error(\"Caught an exception in {}. Thread is dead.\", t, e);", "author": "ctubbsii", "createdAt": "2020-11-30T20:29:05Z", "path": "core/src/main/java/org/apache/accumulo/core/util/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -26,10 +26,20 @@\n public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n   private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final String HALT_PROPERTY = \"HaltVMOnThreadError\";\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);\n+    } else {\n+      if (System.getProperty(HALT_PROPERTY, \"false\").equals(\"true\")) {\n+        log.error(String.format(\"Caught an exception in %s.\", t), e);\n+        Halt.halt(String.format(\"Caught an exception in %s. Halting VM, check the logs.\", t));\n+      } else {\n+        log.error(String.format(\"Caught an exception in %s. Thread is dead.\", t), e);", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NDk0Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532884946", "bodyText": "What differentiates this from SimpleTimer? Could improve the javadoc here with a high-level explanation.", "author": "ctubbsii", "createdAt": "2020-11-30T20:31:37Z", "path": "server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleCriticalTimer.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.server.util.time;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.AccumuloUncaughtExceptionHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Generic singleton timer for critical tasks.\n+ */\n+public class SimpleCriticalTimer extends SimpleTimer {", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4NjkzNA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532886934", "bodyText": "This is probably a little easier to read if you assign the ThreadFactory to a variable first, like the following (formatting probably isn't right):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ExecutorService tp = threads == 0\n          \n          \n            \n                    ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n          \n          \n            \n                    : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));\n          \n          \n            \n                var threadFactory = new NamingThreadFactory(\"GatherTableInformation\");\n          \n          \n            \n                ExecutorService tp = threads == 0\n          \n          \n            \n                    ? Executors.newCachedThreadPool(threadFactory)\n          \n          \n            \n                    : Executors.newFixedThreadPool(threads, threadFactory);", "author": "ctubbsii", "createdAt": "2020-11-30T20:35:32Z", "path": "server/manager/src/main/java/org/apache/accumulo/master/Master.java", "diffHunk": "@@ -884,8 +886,9 @@ private long balanceTablets() {\n       gatherTableInformation(Set<TServerInstance> currentServers) {\n     final long rpcTimeout = getConfiguration().getTimeInMillis(Property.GENERAL_RPC_TIMEOUT);\n     int threads = getConfiguration().getCount(Property.MASTER_STATUS_THREAD_POOL_SIZE);\n-    ExecutorService tp =\n-        threads == 0 ? Executors.newCachedThreadPool() : Executors.newFixedThreadPool(threads);\n+    ExecutorService tp = threads == 0\n+        ? Executors.newCachedThreadPool(new NamingThreadFactory(\"GatherTableInformation\"))\n+        : Executors.newFixedThreadPool(threads, new NamingThreadFactory(\"GatherTableInformation\"));", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4OTIwOA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532889208", "bodyText": "I'm curious what non-critical use cases we still have for this, that would warrant continuing to swallow OOM errors and such.", "author": "ctubbsii", "createdAt": "2020-11-30T20:39:40Z", "path": "server/base/src/main/java/org/apache/accumulo/server/util/time/SimpleTimer.java", "diffHunk": "@@ -100,10 +93,19 @@ static int getInstanceThreadPoolSize() {\n     return instanceThreadPoolSize;\n   }\n \n-  private SimpleTimer(int threadPoolSize) {\n+  protected SimpleTimer(int threadPoolSize) {\n     executor = Executors.newScheduledThreadPool(threadPoolSize,\n         new ThreadFactoryBuilder().setNameFormat(\"SimpleTimer-%d\").setDaemon(true)\n-            .setUncaughtExceptionHandler(new ExceptionHandler()).build());\n+            .setUncaughtExceptionHandler(getUncaughtExceptionHandler()).build());\n+  }\n+\n+  protected Thread.UncaughtExceptionHandler getUncaughtExceptionHandler() {\n+    return new Thread.UncaughtExceptionHandler() {\n+      @Override\n+      public void uncaughtException(Thread t, Throwable e) {\n+        log.warn(\"SimpleTimer task failed\", e);\n+      }\n+    };", "originalCommit": "d66ba42bc3ac227d85aaa0cbce98cf179dd01be8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwMDQ1Mw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532900453", "bodyText": "I agree, I'm not sure I have the ability to decide what is critical vs what is not. I came across a reference to new JVM parameters that may take OOME handling out of our hands: https://bugs.java.com/bugdatabase/view_bug.do?bug_id=8152669", "author": "dlmarion", "createdAt": "2020-11-30T21:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4OTIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkxMDM4Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r532910387", "bodyText": "It looks like this new parameter does not work in all cases. https://bugs.openjdk.java.net/browse/JDK-8155004.", "author": "dlmarion", "createdAt": "2020-11-30T21:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg4OTIwOA=="}], "type": "inlineReview"}, {"oid": "0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "url": "https://github.com/apache/accumulo/commit/0efa5901a38d42a1628fcbe8bd7cba46c9a0f8d0", "message": "re #1808 addressed some PR comments, added uncaught exception handler to Daemon", "committedDate": "2020-11-30T21:11:33Z", "type": "commit"}, {"oid": "de1846bcd05b9d967b760146580fa8eadc4545e8", "url": "https://github.com/apache/accumulo/commit/de1846bcd05b9d967b760146580fa8eadc4545e8", "message": "re *1808: wip, does not compile, working on consolidating all thread pool creation", "committedDate": "2020-12-01T22:26:55Z", "type": "commit"}, {"oid": "b2f62e73b96f0605a16099ec047b5ff41bdab380", "url": "https://github.com/apache/accumulo/commit/b2f62e73b96f0605a16099ec047b5ff41bdab380", "message": "re #1808 - consolidate Thread and ThreadPool creation down to one consistent code path", "committedDate": "2020-12-03T19:46:31Z", "type": "commit"}, {"oid": "5649ff9a81cc825cf46e32078a20e960d7b5e766", "url": "https://github.com/apache/accumulo/commit/5649ff9a81cc825cf46e32078a20e960d7b5e766", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/base/src/test/java/org/apache/accumulo/server/util/time/SimpleTimerTest.java", "committedDate": "2020-12-03T19:48:08Z", "type": "commit"}, {"oid": "3dad05e0f314a73e792da919661f1308645c7806", "url": "https://github.com/apache/accumulo/commit/3dad05e0f314a73e792da919661f1308645c7806", "message": "re #1808 - fixing build issues", "committedDate": "2020-12-03T21:01:58Z", "type": "commit"}, {"oid": "80faa9eb2b7840b77ba9adb0922c8b12d0111ed8", "url": "https://github.com/apache/accumulo/commit/80faa9eb2b7840b77ba9adb0922c8b12d0111ed8", "message": "re #1808 - javadoc fixes", "committedDate": "2020-12-03T21:39:33Z", "type": "commit"}, {"oid": "6af4545fad5c9d45632bce5ce29cb310fa4f60ca", "url": "https://github.com/apache/accumulo/commit/6af4545fad5c9d45632bce5ce29cb310fa4f60ca", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/tracer/src/main/java/org/apache/accumulo/tracer/ZooTraceClient.java", "committedDate": "2020-12-04T16:23:13Z", "type": "commit"}, {"oid": "79dfb9e5ab0a61a398fe167e73976d70709be698", "url": "https://github.com/apache/accumulo/commit/79dfb9e5ab0a61a398fe167e73976d70709be698", "message": "re #1808 - Remove almost all of the uses of Timer", "committedDate": "2020-12-04T18:55:03Z", "type": "commit"}, {"oid": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "url": "https://github.com/apache/accumulo/commit/4a8cd565976e1ebb9917a3adefc8d71c617498c8", "message": "re #1808 - removed property, always halt VM on Error in Thread.", "committedDate": "2020-12-04T19:34:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTI4Mg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525282", "bodyText": "Rather than create this new type, you can just have a different cleanup method in CleanerUtil that calls shutdownNow instead of close on the argument. It should be a much smaller change... and fewer types is good. I can help with this part, if you're not sure what I mean.", "author": "ctubbsii", "createdAt": "2020-12-05T06:16:40Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n+\n+    private final ThreadPoolExecutor tpe;\n+\n+    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n+      this.tpe = tpe;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+      this.tpe.shutdownNow();\n+    }\n+\n+  }", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTU0MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525541", "bodyText": "There's a few of these methods that don't do anything other than call the superclass implementation. These overriding methods can be removed, so the caller of these methods can call the superclass' implementation directly.", "author": "ctubbsii", "createdAt": "2020-12-05T06:18:14Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjg5NzM3MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536897371", "bodyText": "Yeah, these were leftovers from an earlier implementation idea.", "author": "dlmarion", "createdAt": "2020-12-05T21:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNTg5NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536525894", "bodyText": "This method, and how you based it on the property might be my favorite piece of code this year. \ud83d\ude3a  This was a great way to bring all the various implementations into one centralized place.", "author": "ctubbsii", "createdAt": "2020-12-05T06:20:49Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+import org.apache.accumulo.core.util.Threads.NamedRunnable;\n+import org.apache.htrace.wrappers.TraceCallable;\n+import org.apache.htrace.wrappers.TraceRunnable;\n+\n+public class ThreadPools {\n+\n+  /**\n+   * ThreadFactory that sets the name and optionally the priority on a newly created Thread.\n+   */\n+  private static class NamedThreadFactory implements ThreadFactory {\n+\n+    private static final String FORMAT = \"%s-%s-%d\";\n+\n+    private AtomicInteger threadNum = new AtomicInteger(1);\n+    private String name;\n+    private OptionalInt priority;\n+\n+    private NamedThreadFactory(String name) {\n+      this(name, OptionalInt.empty());\n+    }\n+\n+    private NamedThreadFactory(String name, OptionalInt priority) {\n+      this.name = name;\n+      this.priority = priority;\n+    }\n+\n+    @Override\n+    public Thread newThread(Runnable r) {\n+      String threadName = null;\n+      if (r instanceof NamedRunnable) {\n+        NamedRunnable nr = (NamedRunnable) r;\n+        threadName = String.format(FORMAT, name, nr.getName(), threadNum.getAndIncrement());\n+      } else {\n+        threadName =\n+            String.format(FORMAT, name, r.getClass().getSimpleName(), threadNum.getAndIncrement());\n+      }\n+      return Threads.createThread(threadName, priority, r);\n+    }\n+  }\n+\n+  /**\n+   * ScheduledThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor {\n+\n+    private TracingScheduledThreadPoolExecutor(int corePoolSize, ThreadFactory threadFactory) {\n+      super(corePoolSize, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  /**\n+   * ThreadPoolExecutor that traces executed tasks.\n+   */\n+  public static class TracingThreadPoolExecutor extends ThreadPoolExecutor {\n+\n+    private TracingThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime,\n+        TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {\n+      super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n+    }\n+\n+    @Override\n+    public void execute(Runnable command) {\n+      super.execute(new TraceRunnable(command));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Callable<T> task) {\n+      return super.submit(new TraceCallable<T>(task));\n+    }\n+\n+    @Override\n+    public <T> Future<T> submit(Runnable task, T result) {\n+      return super.submit(new TraceRunnable(task), result);\n+    }\n+\n+    @Override\n+    public Future<?> submit(Runnable task) {\n+      return super.submit(new TraceRunnable(task));\n+    }\n+\n+    private <T> Collection<? extends Callable<T>>\n+        wrapCollection(Collection<? extends Callable<T>> tasks) {\n+      List<Callable<T>> result = new ArrayList<Callable<T>>(tasks.size());\n+      tasks.forEach(t -> result.add(new TraceCallable<T>(t)));\n+      return result;\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+        TimeUnit unit) throws InterruptedException {\n+      return super.invokeAll(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException, ExecutionException {\n+      return super.invokeAny(wrapCollection(tasks));\n+    }\n+\n+    @Override\n+    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n+        throws InterruptedException, ExecutionException, TimeoutException {\n+      return super.invokeAny(wrapCollection(tasks), timeout, unit);\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      super.shutdown();\n+    }\n+\n+    @Override\n+    public List<Runnable> shutdownNow() {\n+      return super.shutdownNow();\n+    }\n+\n+  }\n+\n+  public static class CloseableThreadPoolExecutor implements AutoCloseable {\n+\n+    private final ThreadPoolExecutor tpe;\n+\n+    public CloseableThreadPoolExecutor(ThreadPoolExecutor tpe) {\n+      this.tpe = tpe;\n+    }\n+\n+    @Override\n+    public void close() throws Exception {\n+      this.tpe.shutdownNow();\n+    }\n+\n+  }\n+\n+  // the number of seconds before we allow a thread to terminate with non-use.\n+  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n+\n+  /**\n+   * Get a thread pool based on a thread pool related property\n+   *\n+   * @param conf\n+   *          accumulo configuration\n+   * @param p\n+   *          thread pool related property\n+   * @return ExecutorService impl\n+   * @throws RuntimeException\n+   *           if property is not handled\n+   */\n+  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjUyNjA5Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r536526096", "bodyText": "Let's move this to a subpackage of util. Util is pretty bloated, and in a subpackage, we can break out all the inner classes. Inner classes make it hard to follow the code. package-private classes would be better than private inner classes.", "author": "ctubbsii", "createdAt": "2020-12-05T06:22:06Z", "path": "core/src/main/java/org/apache/accumulo/core/util/ThreadPools.java", "diffHunk": "@@ -0,0 +1,368 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util;", "originalCommit": "4a8cd565976e1ebb9917a3adefc8d71c617498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fe29c4cfd724ae81cad630471775ceb335aeed6d", "url": "https://github.com/apache/accumulo/commit/fe29c4cfd724ae81cad630471775ceb335aeed6d", "message": "re #1808 - addressing comments from PR", "committedDate": "2020-12-05T22:10:31Z", "type": "commit"}, {"oid": "06209ca242705ff42c5f2b925e5bef8d2b5b7952", "url": "https://github.com/apache/accumulo/commit/06209ca242705ff42c5f2b925e5bef8d2b5b7952", "message": "Merge branch 'main' into 1808-thread-errors\n\nConflicts:\n\tserver/tserver/src/main/java/org/apache/accumulo/tserver/TabletServerResourceManager.java\n\tshell/src/main/java/org/apache/accumulo/shell/commands/ActiveCompactionHelper.java", "committedDate": "2020-12-14T15:48:15Z", "type": "commit"}, {"oid": "6a15ae5c2bd1b82ab2980a34ec655648edad1862", "url": "https://github.com/apache/accumulo/commit/6a15ae5c2bd1b82ab2980a34ec655648edad1862", "message": "Merge branch '1808-thread-errors' of github.com:dlmarion/accumulo into 1808-thread-errors\n\nConflicts:\n\tshell/src/main/java/org/apache/accumulo/shell/commands/ActiveCompactionHelper.java", "committedDate": "2020-12-14T16:01:49Z", "type": "commit"}, {"oid": "d7c1aeba61833a89e02c738a5841866810b04de4", "url": "https://github.com/apache/accumulo/commit/d7c1aeba61833a89e02c738a5841866810b04de4", "message": "re #1808 - don't log message in CleanerUtil if thread pool is already shut down", "committedDate": "2020-12-15T16:14:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ5ODEyMw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543498123", "bodyText": "Why cast here? Why not just make the type more restrictive in the method signature 4 lines above?", "author": "ctubbsii", "createdAt": "2020-12-15T16:33:18Z", "path": "core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java", "diffHunk": "@@ -107,10 +107,14 @@ public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n     requireNonNull(tpe);\n     requireNonNull(log);\n     return CLEANER.register(tpe, () -> {\n+      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;", "originalCommit": "d7c1aeba61833a89e02c738a5841866810b04de4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543500228", "bodyText": "We really should deregister the cleanable first, so we don't get duplicate exceptions from that if there's a problem calling the shutdown.", "author": "ctubbsii", "createdAt": "2020-12-15T16:36:01Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchReader.java", "diffHunk": "@@ -72,16 +72,15 @@ protected TabletServerBatchReader(ClientContext context, Class<?> scopeClass, Ta\n \n     queryThreadPool = ThreadPools.getFixedThreadPool(numQueryThreads,\n         \"batch scanner \" + batchReaderInstance + \"-\", false);\n+    // Call shutdown on this thread pool in case the caller does not call close().\n     cleanable = CleanerUtil.shutdownThreadPoolExecutor(queryThreadPool, log);\n   }\n \n   @Override\n   public void close() {\n     if (closed.compareAndSet(false, true)) {\n-      // deregister cleanable, but it won't run because it checks\n-      // the value of closed first, which is now true\n-      cleanable.clean();\n       queryThreadPool.shutdownNow();\n+      cleanable.clean();", "originalCommit": "d7c1aeba61833a89e02c738a5841866810b04de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUxNDkzNA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543514934", "bodyText": "So we really only need cleanable.clean() here as it deregisters and invokes the cleaning action.", "author": "dlmarion", "createdAt": "2020-12-15T16:53:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUzMTg0Mg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543531842", "bodyText": "In the next commit I left the order of calls the same. If we only use cleanable.clean() or put cleanable.clean() first, then we will always get the WARN log message: ThreadPoolExecutor found unreferenced without calling shutdown() or shutdownNow().", "author": "dlmarion", "createdAt": "2020-12-15T17:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU1ODU2OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543558569", "bodyText": "In the next commit I left the order of calls the same. If we only use cleanable.clean() or put cleanable.clean() first, then we will always get the WARN log message: ThreadPoolExecutor found unreferenced without calling shutdown() or shutdownNow().\n\nIf shutdown is only called in the close method, then it can be guarded with the closed variable that you are now passing to the cleaner. I guess what I don't know is if we ever want to call shutdown while leaving the containing object unclosed.", "author": "ctubbsii", "createdAt": "2020-12-15T17:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5ODg0OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556298849", "bodyText": "The reason to ensure the cleanable is deregistered first, is because the shutdownNow() could throw an exception, causing the cleanable to stick around until the object is garbage collected. In general, we don't want cleanables to stick around if they are going to be NOOPs later (the AtomicBoolean \"closed\" variable will ensure it's a NOOP, so we don't try to close it both inside the cleanable and outside).", "author": "ctubbsii", "createdAt": "2021-01-13T06:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMDIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUwMTc1OA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543501758", "bodyText": "The other cleanables pass in the closed atomic boolean, so they can detect whether the resource has already been closed, and the cleanable action isn't needed. I suggest following the same pattern, just for convenience, rather than follow a custom pattern here.", "author": "ctubbsii", "createdAt": "2020-12-15T16:37:47Z", "path": "core/src/main/java/org/apache/accumulo/core/util/cleaner/CleanerUtil.java", "diffHunk": "@@ -107,10 +107,14 @@ public static Cleanable shutdownThreadPoolExecutor(Object tpe, Logger log) {\n     requireNonNull(tpe);\n     requireNonNull(log);\n     return CLEANER.register(tpe, () -> {\n+      ThreadPoolExecutor pool = (ThreadPoolExecutor) tpe;\n+      if (pool.isShutdown()) {\n+        return;\n+      }", "originalCommit": "d7c1aeba61833a89e02c738a5841866810b04de4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "url": "https://github.com/apache/accumulo/commit/e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "message": "re #1808: addressing PR comments", "committedDate": "2020-12-15T17:21:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543599320", "bodyText": "In talking with @ivakegg and @drewfarris, this may be too severe as it does not run any shutdown hooks and does not perform a graceful shutdown of the application. For example, in TabletServer a normal shutdown will close the FileSystem and return leases on the files in HDFS. Or, maybe this remains the default action and we need to better handle the errors in the threads.\nThere is also the case where we may want to still catch Throwable in non-critical threads (e.g. QueryTask) so that a StackOverflowError does not shutdown the TabletServer, for example.", "author": "dlmarion", "createdAt": "2020-12-15T18:50:20Z", "path": "core/src/main/java/org/apache/accumulo/core/util/threads/AccumuloUncaughtExceptionHandler.java", "diffHunk": "@@ -16,20 +16,36 @@\n  * specific language governing permissions and limitations\n  * under the License.\n  */\n-package org.apache.accumulo.core.util;\n+package org.apache.accumulo.core.util.threads;\n \n import java.lang.Thread.UncaughtExceptionHandler;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-public class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n+/**\n+ * UncaughtExceptionHandler that logs all Exceptions and Errors thrown from a Thread. If an Error is\n+ * thrown, halt the JVM.\n+ *\n+ */\n+class AccumuloUncaughtExceptionHandler implements UncaughtExceptionHandler {\n \n-  private static final Logger log = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n+  private static final Logger LOG = LoggerFactory.getLogger(AccumuloUncaughtExceptionHandler.class);\n \n   @Override\n   public void uncaughtException(Thread t, Throwable e) {\n-    log.error(String.format(\"Caught an exception in %s.  Shutting down.\", t), e);\n+    if (e instanceof Exception) {\n+      LOG.error(\"Caught an Exception in {}. Thread is dead.\", t, e);\n+    } else if (e instanceof Error) {\n+      try {\n+        e.printStackTrace();\n+        System.err.println(\"Error thrown in thread: \" + t + \", halting VM.\");\n+      } catch (Throwable e1) {\n+        // If e == OutOfMemoryError, then it's probably that another Error might be\n+        // thrown when trying to print to System.err.\n+      } finally {\n+        Runtime.getRuntime().halt(-1);", "originalCommit": "e7dee3fec0bf84b225abe6d9b090d6e1159b0d1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYyODcwOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543628709", "bodyText": "I think we can't trust the TServer to shut down gracefully if we get to this state, and adding code to categorize and handle different threads each individually, would add too much (unmaintainable) complexity that would be prone to accruing technical debt and drifting from the original intent over time. I think it's simpler and safer to just stop everything in the TServer. Yes, it prevents some graceful shutdown steps from occurring... but it also prevents it from causing harm that is somewhat unpredictable. Rather than try to write protective shutdown code in uncertain emergency circumstances, our code complexity and development effort would be better spent on ensuring robust recovery, in my opinion.", "author": "ctubbsii", "createdAt": "2020-12-15T19:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYyOTU2Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543629566", "bodyText": "That said, I'm not sure if this particular method of killing the tserver in the face of errors is best or not.", "author": "ctubbsii", "createdAt": "2020-12-15T19:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNjgxNQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543636815", "bodyText": "That just means that we need to make sure that we are catching Exceptions appropriately in the non-critical threads so that it doesn't take down the server.", "author": "dlmarion", "createdAt": "2020-12-15T19:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3ODM1Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r543678356", "bodyText": "That just means that we need to make sure that we are catching Exceptions appropriately in the non-critical threads so that it doesn't take down the server.\n\nRight, but I would say all threads, regardless of critical or non-critical. The more we handle regular exceptions robustly, and recover robustly on restart, the less it matters that we didn't do a graceful shutdown under emergency (Error) conditions, because 1) it won't happen very often, and 2) we'll handle recovery well when we restart (or re-assign).", "author": "ctubbsii", "createdAt": "2020-12-15T20:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE0ODU5NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555148594", "bodyText": "From reading the discussion here, it sounds like there's some uncertainty of what action to take if we get here. Did Ivan or Drew ever weigh in again? I think Christopher's arguments make sense, but am just wondering if it's worth adding configuration to skip halting the tserver? The main reason I suggest that is if there's some unanticipated case where this is hit and it has a big impact on production systems. At least in such a case it could be disabled with a configuration change vs a re-release and deployment of Accumulo. I only suggest that given the uncertainty of whether or not this is too severe of a response to uncaught errors.", "author": "brianloss", "createdAt": "2021-01-11T15:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE5MDgxOA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555190818", "bodyText": "In the first commit for this PR I had put in some logic to only halt the server it a property was set, and then I set that property in the JVM arguments for the server processes. I can easily resurrect that code, but to your point, I think there are still differing opinions.", "author": "dlmarion", "createdAt": "2021-01-11T16:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjYzMjczNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556632737", "bodyText": "I would argue that there are potential subclasses of Error, that when appearing in a Scan thread should simply log and fail the scan, not halt the entire tserver. It's easy to agree that an OutOfMemoryError warrants halting, but what about a miss-configured context that leads to a UnsupportedClassVersionError or an IOError on a particular file? Particularly the scan threads need to have more flexibility since they are not necessarily running core code. One bad iterator/edge case should not be able to take a cluster down. If this is asking too much than having a configurable list of classes/subclasses that result in a halt would feel more comfortable.", "author": "FineAndDandy", "createdAt": "2021-01-13T15:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY0NTIzNQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556645235", "bodyText": "I would rather resurrect the system property from the first commit and make it enabled by default instead of making a configurable list of Error's that you want to ignore. If you don't want that functionality, then you don't set that property in your accumulo-env.sh file.", "author": "dlmarion", "createdAt": "2021-01-13T16:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNDIxOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r557014219", "bodyText": "a miss-configured context that leads to a UnsupportedClassVersionError or an IOError on a particular file\n\nI would argue that misconfigured class paths are much more serious of an issue than would be implied by trying to proceed in spite of errors caused by them. We should not be trying to proceed when an error occurs as the result of a misconfigured class path. If you can't trust the class path, you can't trust anything, and it is not safe to proceed.\nAs for IOError, see Mark Reinhold's explanation for that ; he specifically explains that it was added to be used in situations where an unrecoverable error (his words) occurs. Suggesting that we should try to recover from situations that are definition-ally unrecoverable seems a bit unreasonable to me.\n\nOne bad iterator/edge case should not be able to take a cluster down.\n\nI understand the motivation for pursuing this. However, thinking about worst case scenarios, I can imagine far worse things than being temporarily offline (data corruption, hijacking by malware, etc.) due to administrator error deploying a bad iterator.\nI think that baking in special handling for these (what should be exceedingly rare) edge cases would be a mistake for a number of reasons. However, persuasive arguments in favor of, or against, such a thing can be made in a subsequent effort, if there is a critical demand for such a thing. There's no need to block this PR on that. It would actually be much simpler to discuss that sort of thing on its own, rather than bundled with the other changes in this PR.", "author": "ctubbsii", "createdAt": "2021-01-14T03:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTMyMA=="}], "type": "inlineReview"}, {"oid": "4b818173015c5e9c42246b11836060d86a34d5c1", "url": "https://github.com/apache/accumulo/commit/4b818173015c5e9c42246b11836060d86a34d5c1", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-11T13:38:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMDM5NQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555100395", "bodyText": "Just curious why the initialization for failedMutations was moved into the constructor but the other nearby inline final initializations (violations, authorizationFailures, serverSideErrors) weren't?", "author": "brianloss", "createdAt": "2021-01-11T14:51:33Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -198,6 +197,8 @@ public long getTimeOut() {\n \n   public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config) {\n     this.context = context;\n+    this.executor = ThreadPools.getGeneralScheduledExecutorService(this.context.getConfiguration());\n+    this.failedMutations = new FailedMutations();", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE2OTg0OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555169849", "bodyText": "It's been almost a month since I looked at this. I don't remember the reason why I moved it and it should work if this line was reverted. I'm not sure if there is reason to do it one vs the other. I can easily change it back if necessary.", "author": "dlmarion", "createdAt": "2021-01-11T16:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMDM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE3MTI2OA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555171268", "bodyText": "No worries--I wasn't suggesting a change, but rather just trying to figure out if I missed something special about that one variable.", "author": "brianloss", "createdAt": "2021-01-11T16:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMDM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMTM0Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555101347", "bodyText": "It seems like maybe calling ThreadPools.getGeneralScheduledExecutorService depends on the configuration having a value for Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE. Should this logic be moved into ThreadPools.getGeneralScheduledExecutorService?", "author": "brianloss", "createdAt": "2021-01-11T14:52:58Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,20 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4NDE3MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555184171", "bodyText": "IIRC this was specific to the issue of the property not being in the Map<String,String> from which the ConfigurationCopy is based upon and the fact that ConfigurationCopy does not provide the default value in get(Property) but all of the other implementations do. Putting it here resolved this specific issue. I could move it into ThreadPools.getGeneralScheduledExecutorService but it would not be used for the most part. I'm indifferent, I can move it if we have others that think it's a good idea.", "author": "dlmarion", "createdAt": "2021-01-11T16:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMTM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4ODM2MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555188361", "bodyText": "That explanation makes sense to me--I just didn't have enough context. Sorry for the noise.", "author": "brianloss", "createdAt": "2021-01-11T16:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEwMTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExMDgyMg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555110822", "bodyText": "I like the fact that previously the timer thread would have BatchWriter in its name. Only latency timer makes it just a little harder to figure out when looking at a thread dump, IMO.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {\n          \n          \n            \n                  executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"BatchWriterLatencyTimer\", () -> {", "author": "brianloss", "createdAt": "2021-01-11T15:06:03Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -209,20 +210,17 @@ public TabletServerBatchWriter(ClientContext context, BatchWriterConfig config)\n     this.writer = new MutationWriter(config.getMaxWriteThreads());\n \n     if (this.maxLatency != Long.MAX_VALUE) {\n-      jtimer.schedule(new TimerTask() {\n-        @Override\n-        public void run() {\n-          try {\n-            synchronized (TabletServerBatchWriter.this) {\n-              if ((System.currentTimeMillis() - lastProcessingStartTime)\n-                  > TabletServerBatchWriter.this.maxLatency)\n-                startProcessing();\n-            }\n-          } catch (Throwable t) {\n-            updateUnknownErrors(\"Max latency task failed \" + t.getMessage(), t);\n+      executor.scheduleWithFixedDelay(Threads.createNamedRunnable(\"latency timer\", () -> {", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE3NDg0NQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555174845", "bodyText": "That's a good catch, I can change the thread name.", "author": "dlmarion", "createdAt": "2021-01-11T16:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExMDgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExNTcwOQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555115709", "bodyText": "Not a super strong opinion, but when I first started reading the code I thought maybe these methods could be returning cached/shared executors. I suggest considering changing all of the methods in this class from \"get*\" to \"create*\" (or \"new*\" to match the pattern in the java.util.concurrent.Executors class) to make it explicit that they are always creating a resource.", "author": "brianloss", "createdAt": "2021-01-11T15:13:05Z", "path": "core/src/main/java/org/apache/accumulo/core/util/threads/ThreadPools.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util.threads;\n+\n+import java.util.OptionalInt;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.accumulo.core.conf.AccumuloConfiguration;\n+import org.apache.accumulo.core.conf.Property;\n+\n+public class ThreadPools {\n+\n+  // the number of seconds before we allow a thread to terminate with non-use.\n+  public static final long DEFAULT_TIMEOUT_MILLISECS = 180000L;\n+\n+  /**\n+   * Get a thread pool based on a thread pool related property\n+   *\n+   * @param conf\n+   *          accumulo configuration\n+   * @param p\n+   *          thread pool related property\n+   * @return ExecutorService impl\n+   * @throws RuntimeException\n+   *           if property is not handled\n+   */\n+  public static ExecutorService getExecutorService(AccumuloConfiguration conf, Property p) {", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4NDcyMw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555184723", "bodyText": "I can change the method names to create*", "author": "dlmarion", "createdAt": "2021-01-11T16:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTExNTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555122748", "bodyText": "Just a nit, but it doesn't appear that the initialization of thread is any different based on the type of Runnable passed in. Why not move the initialization up? Maybe something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Thread thread = null;\n          \n          \n            \n                if (r instanceof NamedRunnable) {\n          \n          \n            \n                  NamedRunnable nr = (NamedRunnable) r;\n          \n          \n            \n                  thread = new Thread(r, name);\n          \n          \n            \n                  if (nr.getPriority().isPresent()) {\n          \n          \n            \n                    thread.setPriority(nr.getPriority().getAsInt());\n          \n          \n            \n                  } else if (priority.isPresent()) {\n          \n          \n            \n                    thread.setPriority(priority.getAsInt());\n          \n          \n            \n                  }\n          \n          \n            \n                } else {\n          \n          \n            \n                  thread = new Thread(r, name);\n          \n          \n            \n                  if (priority.isPresent()) {\n          \n          \n            \n                    thread.setPriority(priority.getAsInt());\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                Thread thread = new Thread(r, name);\n          \n          \n            \n                if (r instanceof NamedRunnable) {\n          \n          \n            \n                  NamedRunnable nr = (NamedRunnable) r;\n          \n          \n            \n                  if (nr.getPriority().isPresent()) {\n          \n          \n            \n                    priority = nr.getPriority();\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n                if (priority.isPresent()) {\n          \n          \n            \n                  thread.setPriority(priority.getAsInt());\n          \n          \n            \n                }", "author": "brianloss", "createdAt": "2021-01-11T15:22:56Z", "path": "core/src/main/java/org/apache/accumulo/core/util/threads/Threads.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.accumulo.core.util.threads;\n+\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.OptionalInt;\n+\n+public class Threads {\n+\n+  public static Runnable createNamedRunnable(String name, Runnable r) {\n+    return new NamedRunnable(name, r);\n+  }\n+\n+  public static Runnable createNamedRunnable(String name, OptionalInt priority, Runnable r) {\n+    return new NamedRunnable(name, priority, r);\n+  }\n+\n+  private static final UncaughtExceptionHandler UEH = new AccumuloUncaughtExceptionHandler();\n+\n+  public static Thread createThread(String name, Runnable r) {\n+    return createThread(name, OptionalInt.empty(), r);\n+  }\n+\n+  public static Thread createThread(String name, OptionalInt priority, Runnable r) {\n+    Thread thread = null;\n+    if (r instanceof NamedRunnable) {\n+      NamedRunnable nr = (NamedRunnable) r;\n+      thread = new Thread(r, name);\n+      if (nr.getPriority().isPresent()) {\n+        thread.setPriority(nr.getPriority().getAsInt());\n+      } else if (priority.isPresent()) {\n+        thread.setPriority(priority.getAsInt());\n+      }\n+    } else {\n+      thread = new Thread(r, name);\n+      if (priority.isPresent()) {\n+        thread.setPriority(priority.getAsInt());\n+      }\n+    }", "originalCommit": "4b818173015c5e9c42246b11836060d86a34d5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE4ODc2Mw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555188763", "bodyText": "I made this change (in the next commit), but I modified your suggestion such that if the priority is set in the NamedRunnable it is not overridden by the priority parameter.", "author": "dlmarion", "createdAt": "2021-01-11T16:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE5MjY5NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555192694", "bodyText": "I made this change (in the next commit), but I modified your suggestion such that if the priority is set in the NamedRunnable it is not overridden by the priority parameter.\n\nI think my suggestion would have done that too, since it overwrites the priority parameter on line 45, but if you missed that then my suggestion was too subtle so it's best not to use it. :)", "author": "brianloss", "createdAt": "2021-01-11T16:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE5NTkwMg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r555195902", "bodyText": "Ah, I see it now. My change should be functionally equivalent.", "author": "dlmarion", "createdAt": "2021-01-11T16:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyMjc0OA=="}], "type": "inlineReview"}, {"oid": "7957d8240581ce74a942c4858cf452bbb2067b90", "url": "https://github.com/apache/accumulo/commit/7957d8240581ce74a942c4858cf452bbb2067b90", "message": "re #1808: addressing PR comments", "committedDate": "2021-01-11T17:02:52Z", "type": "commit"}, {"oid": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "url": "https://github.com/apache/accumulo/commit/8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-13T05:44:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556290443", "bodyText": "This updates the context using the ConfigurationCopy instead of the contextConfigSupplier, which would provide it on-demand. Using the ConfigurationCopy means it will get the same initial value every time the thread executes, and will never see the updated value of VFS_CONTEXT_CLASSPATH_PROPERTY if it changes.", "author": "ctubbsii", "createdAt": "2021-01-13T06:32:14Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,20 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy cc = new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = cc.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      cc.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }\n+    ThreadPools.createGeneralScheduledExecutorService(cc)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, cc);\n+          Set<String> contextsInUse = cc\n+              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();", "originalCommit": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUyODM4NQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556528385", "bodyText": "The ContextClassLoaderFactory is initialized on server process start (AbstractServer constructor). I don't believe that this property was ever dynamic, it's not the table context classpath property which could change, it's the property to load system jars from VFS.", "author": "dlmarion", "createdAt": "2021-01-13T13:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0NDE3Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556544177", "bodyText": "Interesting Then what is this thread supposed to be cleaning up?", "author": "ctubbsii", "createdAt": "2021-01-13T14:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU1Mjg3MQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556552871", "bodyText": "I read the code wrong, I think I need more coffee.", "author": "dlmarion", "createdAt": "2021-01-13T14:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3MTE3Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556571177", "bodyText": "Resolved in latest commit.", "author": "dlmarion", "createdAt": "2021-01-13T14:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MjY4OQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556292689", "bodyText": "Would this work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n          \n          \n            \n                    run();\n          \n          \n            \n                  });\n          \n          \n            \n                  task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", this::run);", "author": "ctubbsii", "createdAt": "2021-01-13T06:38:59Z", "path": "core/src/main/java/org/apache/accumulo/core/clientImpl/TabletServerBatchWriter.java", "diffHunk": "@@ -571,13 +570,17 @@ private synchronized void addFailedMutations(MutationSet failedMutations) {\n     }\n   }\n \n-  private class FailedMutations extends TimerTask {\n+  private class FailedMutations {\n \n     private MutationSet recentFailures = null;\n     private long initTime;\n+    private final Runnable task;\n \n     FailedMutations() {\n-      jtimer.schedule(this, 0, 500);\n+      task = Threads.createNamedRunnable(\"failed mutationBatchWriterLatencyTimers handler\", () -> {\n+        run();\n+      });", "originalCommit": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUyNDA4Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556524086", "bodyText": "That should work, I can make that change.", "author": "dlmarion", "createdAt": "2021-01-13T13:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MjY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MzY5Ng==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556293696", "bodyText": "Is it legal to switch to a Daemon thread after it has already started executing? Will this have any effect?", "author": "ctubbsii", "createdAt": "2021-01-13T06:42:00Z", "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -51,9 +50,10 @@ public void run() {\n   public static void halt(final int status, Runnable runnable) {\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      new Thread() {\n         @Override\n         public void run() {\n+          setDaemon(true);", "originalCommit": "8b5cf51f46cb29c4e8428f20d30a9adf9a6a0180", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjUyMzA5MA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556523090", "bodyText": "Great catch. This won't work, I will fix.", "author": "dlmarion", "createdAt": "2021-01-13T13:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI5MzY5Ng=="}], "type": "inlineReview"}, {"oid": "30f63b14b8d638ed6d641d493379586cf5f9e42d", "url": "https://github.com/apache/accumulo/commit/30f63b14b8d638ed6d641d493379586cf5f9e42d", "message": "re #1808 - addressing PR comments", "committedDate": "2021-01-13T13:55:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556541601", "bodyText": "We should avoid using Hadoop's Daemon. I doubt that is stable public API. Even if it is, we don't want to increase our dependency on Hadoop library code for this. It should be simple to construct the object assigned to a local variable, set it to daemon, and start it in 3 statements, rather than rely on a the Hadoop library.", "author": "ctubbsii", "createdAt": "2021-01-13T14:03:32Z", "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -50,10 +51,9 @@ public void run() {\n   public static void halt(final int status, Runnable runnable) {\n     try {\n       // give ourselves a little time to try and do something\n-      new Thread() {\n+      new Daemon() {", "originalCommit": "30f63b14b8d638ed6d641d493379586cf5f9e42d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU1Mjk1Nw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556552957", "bodyText": "I didn't even notice that it was a Hadoop class.", "author": "dlmarion", "createdAt": "2021-01-13T14:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU1NjYyMw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556556623", "bodyText": "We had one of our own, but I think you may have deleted it elsewhere in this PR (which is a good thing, as we don't really need a dedicated class for that, especially with all your thread factory stuff being consolidated into one place).", "author": "ctubbsii", "createdAt": "2021-01-13T14:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3MTExNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556571117", "bodyText": "Resolved in latest commit.", "author": "dlmarion", "createdAt": "2021-01-13T14:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU0MTYwMQ=="}], "type": "inlineReview"}, {"oid": "137f7859f81a89744da60c7b0849a1041b178119", "url": "https://github.com/apache/accumulo/commit/137f7859f81a89744da60c7b0849a1041b178119", "message": "re #1808 - don't use Hadoop Daemon class and other changes", "committedDate": "2021-01-13T14:41:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3ODUwMg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556578502", "bodyText": "Reading properties other than those that start with the VFS_CONTEXT_CLASSPATH_PROPERTY won't work here, because the contextConfigSupplier already filters out all other properties. So, you can't read the SIMPLETIMER properties from this map.", "author": "ctubbsii", "createdAt": "2021-01-13T14:53:52Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,23 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }", "originalCommit": "137f7859f81a89744da60c7b0849a1041b178119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY1NTI4Mg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556655282", "bodyText": "Changed in latest commit", "author": "dlmarion", "createdAt": "2021-01-13T16:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU3ODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4MDgyMA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556580820", "bodyText": "Placing it in a new ConfigurationCopy to use the method that strips the property prefix out seems a bit more work than the old code did. The contextConfigSupplier already filters matching items, so all we need to do is strip out the prefix. We can avoid creating a new ConfigurationCopy object for this.", "author": "ctubbsii", "createdAt": "2021-01-13T14:56:39Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -59,18 +60,23 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n   }\n \n   private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+    final ConfigurationCopy threadPoolProperties =\n+        new ConfigurationCopy(contextConfigSupplier.get());\n+    String size = threadPoolProperties.get(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE);\n+    if (null == size || size.isEmpty()) {\n+      threadPoolProperties.set(Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE,\n+          Property.GENERAL_SIMPLETIMER_THREADPOOL_SIZE.getDefaultValue());\n+    }\n+    ThreadPools.createGeneralScheduledExecutorService(threadPoolProperties)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          ConfigurationCopy contextCleanerProperties =\n+              new ConfigurationCopy(contextConfigSupplier.get());\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, threadPoolProperties);\n+          Set<String> contextsInUse = contextCleanerProperties\n+              .getAllPropertiesWithPrefixStripped(Property.VFS_CONTEXT_CLASSPATH_PROPERTY).keySet();", "originalCommit": "137f7859f81a89744da60c7b0849a1041b178119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY1NTMzNg==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556655336", "bodyText": "Changed in latest commit", "author": "dlmarion", "createdAt": "2021-01-13T16:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4MDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4NDEyNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556584127", "bodyText": "With a lambda, this would be slightly shorter:\n      Threads.createThread(\"Halt Thread\", () -> {\n        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n        Runtime.getRuntime().halt(status);\n      }).start();", "author": "ctubbsii", "createdAt": "2021-01-13T15:00:41Z", "path": "core/src/main/java/org/apache/accumulo/core/util/Halt.java", "diffHunk": "@@ -49,15 +49,16 @@ public void run() {\n   }\n \n   public static void halt(final int status, Runnable runnable) {\n+\n     try {\n       // give ourselves a little time to try and do something\n-      new Daemon() {\n+      Threads.createThread(\"Halt Thread\", new Runnable() {\n         @Override\n         public void run() {\n           sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n           Runtime.getRuntime().halt(status);\n         }\n-      }.start();\n+      }).start();", "originalCommit": "137f7859f81a89744da60c7b0849a1041b178119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4OTUyNw==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556689527", "bodyText": "Resolved in latest commit", "author": "dlmarion", "createdAt": "2021-01-13T17:09:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjU4NDEyNw=="}], "type": "inlineReview"}, {"oid": "370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "url": "https://github.com/apache/accumulo/commit/370bb25fb6fb640647a2e8ce0076a6e3600b3b79", "message": "re #1808: Don't create two ConfigurationCopy instances", "committedDate": "2021-01-13T16:10:14Z", "type": "commit"}, {"oid": "c479969590703e3ce7f99485f7389fda24f03259", "url": "https://github.com/apache/accumulo/commit/c479969590703e3ce7f99485f7389fda24f03259", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-13T16:41:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4MDE4MA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556680180", "bodyText": "Two things are wrong with this filter line:\n\nThis is using the enum name(), when it should be filtering on the enum's getKey() method, and\nIt's not even necessary to execute this filter, because the contextConfigSupplier already performs this filter.", "author": "ctubbsii", "createdAt": "2021-01-13T16:56:24Z", "path": "core/src/main/java/org/apache/accumulo/core/classloader/DefaultContextClassLoaderFactory.java", "diffHunk": "@@ -55,22 +56,21 @@ public DefaultContextClassLoaderFactory(final AccumuloConfiguration accConf) {\n         () -> accConf.getAllPropertiesWithPrefix(Property.VFS_CONTEXT_CLASSPATH_PROPERTY);\n     AccumuloVFSClassLoader.setContextConfig(contextConfigSupplier);\n     LOG.debug(\"ContextManager configuration set\");\n-    startCleanupThread(contextConfigSupplier);\n+    startCleanupThread(accConf, contextConfigSupplier);\n   }\n \n-  private static void startCleanupThread(final Supplier<Map<String,String>> contextConfigSupplier) {\n-    new Timer(className + \"-cleanup\", true).scheduleAtFixedRate(new TimerTask() {\n-      @Override\n-      public void run() {\n-        Map<String,String> contextConfigs = contextConfigSupplier.get();\n-        LOG.trace(\"{}-cleanup thread, properties: {}\", className, contextConfigs);\n-        int prefixlen = Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey().length();\n-        Set<String> contextsInUse = contextConfigs.keySet().stream()\n-            .map(k -> k.substring(prefixlen)).collect(Collectors.toSet());\n-        LOG.trace(\"{}-cleanup thread, contexts in use: {}\", className, contextsInUse);\n-        AccumuloVFSClassLoader.removeUnusedContexts(contextsInUse);\n-      }\n-    }, 60_000, 60_000);\n+  private static void startCleanupThread(final AccumuloConfiguration conf,\n+      final Supplier<Map<String,String>> contextConfigSupplier) {\n+    ThreadPools.createGeneralScheduledExecutorService(conf)\n+        .scheduleWithFixedDelay(Threads.createNamedRunnable(className + \"-cleanup\", () -> {\n+          LOG.trace(\"{}-cleanup thread, properties: {}\", className, conf);\n+          Set<String> contextsInUse = contextConfigSupplier.get().keySet().stream()\n+              .filter(k -> k.startsWith(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.name()))", "originalCommit": "c479969590703e3ce7f99485f7389fda24f03259", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4OTg1NA==", "url": "https://github.com/apache/accumulo/pull/1818#discussion_r556689854", "bodyText": "Thanks for catching that, I went down one path, then another, and left that in by mistake. Resolved in latest commit.", "author": "dlmarion", "createdAt": "2021-01-13T17:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY4MDE4MA=="}], "type": "inlineReview"}, {"oid": "5153181e5002cc4ea8ade6b747fac66659e64e99", "url": "https://github.com/apache/accumulo/commit/5153181e5002cc4ea8ade6b747fac66659e64e99", "message": "re #1808 - simplify Halt daemon thread, remove errant filter command", "committedDate": "2021-01-13T17:08:50Z", "type": "commit"}, {"oid": "da18f062d8a64757f9bf0a31b09c91f7ac225866", "url": "https://github.com/apache/accumulo/commit/da18f062d8a64757f9bf0a31b09c91f7ac225866", "message": "Merge branch '1808-thread-errors' of github.com:dlmarion/accumulo into 1808-thread-errors", "committedDate": "2021-01-13T17:10:46Z", "type": "commit"}, {"oid": "35657242bedbc6c0850cfef9bdef44bd9de82256", "url": "https://github.com/apache/accumulo/commit/35657242bedbc6c0850cfef9bdef44bd9de82256", "message": "Merge branch 'main' into 1808-thread-errors", "committedDate": "2021-01-19T11:53:20Z", "type": "commit"}]}