{"pr_number": 1404, "pr_title": "SAMZA-2562: [Scala cleanup] Clean up Scala in samza-kv-inmemory and samza-kv-couchbase", "pr_createdAt": "2020-07-27T18:12:46Z", "pr_url": "https://github.com/apache/samza/pull/1404", "timeline": [{"oid": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "url": "https://github.com/apache/samza/commit/4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "message": "SAMZA-2562: [Scala cleanup] Clean up Scala in samza-kv-inmemory and samza-kv-couchbase", "committedDate": "2020-07-27T17:58:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDM1NA==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461224354", "bodyText": "link the jira?", "author": "bkonold", "createdAt": "2020-07-27T23:18:33Z", "path": "samza-kv-inmemory/src/main/java/org/apache/samza/storage/kv/inmemory/InMemoryKeyValueStore.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv.inmemory;\n+\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.UnsignedBytes;\n+import org.apache.samza.checkpoint.CheckpointId;\n+import org.apache.samza.storage.kv.Entry;\n+import org.apache.samza.storage.kv.KeyValueIterator;\n+import org.apache.samza.storage.kv.KeyValueSnapshot;\n+import org.apache.samza.storage.kv.KeyValueStore;\n+import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+\n+\n+/**\n+ * In-memory implementation of a {@link KeyValueStore}.\n+ *\n+ * This uses a {@link ConcurrentSkipListMap} to store the keys in order.\n+ */\n+public class InMemoryKeyValueStore implements KeyValueStore<byte[], byte[]> {\n+  private final KeyValueStoreMetrics metrics;\n+  private final ConcurrentSkipListMap<byte[], byte[]> underlying;\n+\n+  /**\n+   * @param metrics A metrics instance to publish key-value store related statistics\n+   */\n+  public InMemoryKeyValueStore(KeyValueStoreMetrics metrics) {\n+    this.metrics = metrics;\n+    this.underlying = new ConcurrentSkipListMap<>(UnsignedBytes.lexicographicalComparator());\n+  }\n+\n+  @Override\n+  public byte[] get(byte[] key) {\n+    this.metrics.gets().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    byte[] found = this.underlying.get(key);\n+    if (found != null) {\n+      metrics.bytesRead().inc(found.length);\n+    }\n+    return found;\n+  }\n+\n+  @Override\n+  public void put(byte[] key, byte[] value) {\n+    this.metrics.puts().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    if (value == null) {\n+      this.metrics.deletes().inc();\n+      this.underlying.remove(key);\n+    } else {\n+      this.metrics.bytesWritten().inc(key.length + value.length);\n+      this.underlying.put(key, value);\n+    }\n+  }\n+\n+  @Override\n+  public void putAll(List<Entry<byte[], byte[]>> entries) {\n+    // TreeMap's putAll requires a map, so we'd need to iterate over all the entries anyway\n+    // to use it, in order to putAll here.  Therefore, just iterate here.\n+    for (Entry<byte[], byte[]> next : entries) {\n+      put(next.getKey(), next.getValue());\n+    }\n+  }\n+\n+  @Override\n+  public void delete(byte[] key) {\n+    // TODO Bug: This double counts deletes for metrics, because put also counts a delete", "originalCommit": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIyNDM4Nw==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461224387", "bodyText": "link the jira?", "author": "bkonold", "createdAt": "2020-07-27T23:18:40Z", "path": "samza-kv-inmemory/src/main/java/org/apache/samza/storage/kv/inmemory/InMemoryKeyValueStore.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage.kv.inmemory;\n+\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import com.google.common.base.Preconditions;\n+import com.google.common.primitives.UnsignedBytes;\n+import org.apache.samza.checkpoint.CheckpointId;\n+import org.apache.samza.storage.kv.Entry;\n+import org.apache.samza.storage.kv.KeyValueIterator;\n+import org.apache.samza.storage.kv.KeyValueSnapshot;\n+import org.apache.samza.storage.kv.KeyValueStore;\n+import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+\n+\n+/**\n+ * In-memory implementation of a {@link KeyValueStore}.\n+ *\n+ * This uses a {@link ConcurrentSkipListMap} to store the keys in order.\n+ */\n+public class InMemoryKeyValueStore implements KeyValueStore<byte[], byte[]> {\n+  private final KeyValueStoreMetrics metrics;\n+  private final ConcurrentSkipListMap<byte[], byte[]> underlying;\n+\n+  /**\n+   * @param metrics A metrics instance to publish key-value store related statistics\n+   */\n+  public InMemoryKeyValueStore(KeyValueStoreMetrics metrics) {\n+    this.metrics = metrics;\n+    this.underlying = new ConcurrentSkipListMap<>(UnsignedBytes.lexicographicalComparator());\n+  }\n+\n+  @Override\n+  public byte[] get(byte[] key) {\n+    this.metrics.gets().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    byte[] found = this.underlying.get(key);\n+    if (found != null) {\n+      metrics.bytesRead().inc(found.length);\n+    }\n+    return found;\n+  }\n+\n+  @Override\n+  public void put(byte[] key, byte[] value) {\n+    this.metrics.puts().inc();\n+    Preconditions.checkArgument(key != null, \"Null argument 'key' not allowed\");\n+    if (value == null) {\n+      this.metrics.deletes().inc();\n+      this.underlying.remove(key);\n+    } else {\n+      this.metrics.bytesWritten().inc(key.length + value.length);\n+      this.underlying.put(key, value);\n+    }\n+  }\n+\n+  @Override\n+  public void putAll(List<Entry<byte[], byte[]>> entries) {\n+    // TreeMap's putAll requires a map, so we'd need to iterate over all the entries anyway\n+    // to use it, in order to putAll here.  Therefore, just iterate here.\n+    for (Entry<byte[], byte[]> next : entries) {\n+      put(next.getKey(), next.getValue());\n+    }\n+  }\n+\n+  @Override\n+  public void delete(byte[] key) {\n+    // TODO Bug: This double counts deletes for metrics, because put also counts a delete\n+    metrics.deletes().inc();\n+    put(key, null);\n+  }\n+\n+  @Override\n+  public KeyValueIterator<byte[], byte[]> range(byte[] from, byte[] to) {\n+    this.metrics.ranges().inc();\n+    Preconditions.checkArgument(from != null, \"Null argument 'from' not allowed\");\n+    Preconditions.checkArgument(to != null, \"Null argument 'to' not allowed\");\n+    return new InMemoryIterator(this.underlying.subMap(from, to).entrySet().iterator(), this.metrics);\n+  }\n+\n+  @Override\n+  public KeyValueSnapshot<byte[], byte[]> snapshot(byte[] from, byte[] to) {\n+    // TODO: Bug: This does not satisfy the immutability constraint, since the entrySet is backed by the underlying map.", "originalCommit": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMDIxNw==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461230217", "bodyText": "is there an edge case this is intended to test that testPut doesn't cover?", "author": "bkonold", "createdAt": "2020-07-27T23:36:29Z", "path": "samza-kv-inmemory/src/test/java/org/apache/samza/storage/kv/inmemory/TestInMemoryKeyValueStore.java", "diffHunk": "@@ -19,66 +19,501 @@\n \n package org.apache.samza.storage.kv.inmemory;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import com.google.common.collect.Iterators;\n import com.google.common.primitives.Ints;\n-import org.apache.samza.metrics.MetricsRegistryMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.metrics.Counter;\n import org.apache.samza.storage.kv.Entry;\n import org.apache.samza.storage.kv.KeyValueIterator;\n import org.apache.samza.storage.kv.KeyValueSnapshot;\n import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.Mockito.when;\n+\n \n public class TestInMemoryKeyValueStore {\n+  private static final String DEFAULT_KEY_PREFIX = \"key_prefix\";\n+  private static final String OTHER_KEY_PREFIX = \"other_key_prefix\";\n+  /**\n+   * Keep the lengths of the values longer so that metrics validations for key and value sizes don't collide.\n+   */\n+  private static final String DEFAULT_VALUE_PREFIX = \"value_prefix_value_prefix\";\n+  private static final String OTHER_VALUE_PREFIX = \"other_value_prefix_value_prefix\";\n+\n+  @Mock\n+  private KeyValueStoreMetrics keyValueStoreMetrics;\n+  @Mock\n+  private Counter getsCounter;\n+  @Mock\n+  private Counter bytesReadCounter;\n+  @Mock\n+  private Counter putsCounter;\n+  @Mock\n+  private Counter bytesWrittenCounter;\n+  @Mock\n+  private Counter deletesCounter;\n+\n+  private InMemoryKeyValueStore inMemoryKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    when(this.keyValueStoreMetrics.gets()).thenReturn(this.getsCounter);\n+    when(this.keyValueStoreMetrics.bytesRead()).thenReturn(this.bytesReadCounter);\n+    when(this.keyValueStoreMetrics.puts()).thenReturn(this.putsCounter);\n+    when(this.keyValueStoreMetrics.bytesWritten()).thenReturn(this.bytesWrittenCounter);\n+    when(this.keyValueStoreMetrics.deletes()).thenReturn(this.deletesCounter);\n+    this.inMemoryKeyValueStore = new InMemoryKeyValueStore(this.keyValueStoreMetrics);\n+  }\n+\n+  @Test\n+  public void testGet() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.getsCounter, times(2)).inc();\n+    verify(this.bytesReadCounter).inc(value(0).length);\n+    verify(this.bytesReadCounter).inc(value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testGetEmpty() {\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testGetAfterDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testPut() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(OTHER_KEY_PREFIX, 1).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutExistingEntry() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutEmpty() {\n+    byte[] emptyValue = new byte[0];\n+    this.inMemoryKeyValueStore.put(key(0), emptyValue);\n+\n+    assertEquals(0, this.inMemoryKeyValueStore.get(key(0)).length);\n+    verify(this.putsCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length);\n+  }", "originalCommit": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyNzc0OA==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461727748", "bodyText": "Yes, this tests when the value has zero length. testPut is puts a non-empty value.", "author": "cameronlee314", "createdAt": "2020-07-28T16:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0MDI4Nw==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461740287", "bodyText": "Sorry should have been more clear. What code path is this testing that testPut isn't? Does the implementation behave differently when the length is 0?", "author": "bkonold", "createdAt": "2020-07-28T17:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMDIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc1MzU5OA==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461753598", "bodyText": "With the current implementation, it doesn't test a different code path. It just seemed like an edge case that would be good to cover.", "author": "cameronlee314", "createdAt": "2020-07-28T17:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMDIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMTUwMw==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461231503", "bodyText": "doesn't this assume that key(0) and value(0) lengths are the same as key(i) and value(i) from the loop? can we re-write this so it more obviously matches the 10 writes that happen in the loop or add a comment indicating this assumption? or perhaps define a constant that represents the length of an integer key / value... just to make this more readable.\nsame comment applies to other occurrences of loops in your tests", "author": "bkonold", "createdAt": "2020-07-27T23:40:32Z", "path": "samza-kv-inmemory/src/test/java/org/apache/samza/storage/kv/inmemory/TestInMemoryKeyValueStore.java", "diffHunk": "@@ -19,66 +19,501 @@\n \n package org.apache.samza.storage.kv.inmemory;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import com.google.common.collect.Iterators;\n import com.google.common.primitives.Ints;\n-import org.apache.samza.metrics.MetricsRegistryMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.metrics.Counter;\n import org.apache.samza.storage.kv.Entry;\n import org.apache.samza.storage.kv.KeyValueIterator;\n import org.apache.samza.storage.kv.KeyValueSnapshot;\n import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.Mockito.when;\n+\n \n public class TestInMemoryKeyValueStore {\n+  private static final String DEFAULT_KEY_PREFIX = \"key_prefix\";\n+  private static final String OTHER_KEY_PREFIX = \"other_key_prefix\";\n+  /**\n+   * Keep the lengths of the values longer so that metrics validations for key and value sizes don't collide.\n+   */\n+  private static final String DEFAULT_VALUE_PREFIX = \"value_prefix_value_prefix\";\n+  private static final String OTHER_VALUE_PREFIX = \"other_value_prefix_value_prefix\";\n+\n+  @Mock\n+  private KeyValueStoreMetrics keyValueStoreMetrics;\n+  @Mock\n+  private Counter getsCounter;\n+  @Mock\n+  private Counter bytesReadCounter;\n+  @Mock\n+  private Counter putsCounter;\n+  @Mock\n+  private Counter bytesWrittenCounter;\n+  @Mock\n+  private Counter deletesCounter;\n+\n+  private InMemoryKeyValueStore inMemoryKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    when(this.keyValueStoreMetrics.gets()).thenReturn(this.getsCounter);\n+    when(this.keyValueStoreMetrics.bytesRead()).thenReturn(this.bytesReadCounter);\n+    when(this.keyValueStoreMetrics.puts()).thenReturn(this.putsCounter);\n+    when(this.keyValueStoreMetrics.bytesWritten()).thenReturn(this.bytesWrittenCounter);\n+    when(this.keyValueStoreMetrics.deletes()).thenReturn(this.deletesCounter);\n+    this.inMemoryKeyValueStore = new InMemoryKeyValueStore(this.keyValueStoreMetrics);\n+  }\n+\n+  @Test\n+  public void testGet() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.getsCounter, times(2)).inc();\n+    verify(this.bytesReadCounter).inc(value(0).length);\n+    verify(this.bytesReadCounter).inc(value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testGetEmpty() {\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testGetAfterDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testPut() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(OTHER_KEY_PREFIX, 1).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutExistingEntry() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutEmpty() {\n+    byte[] emptyValue = new byte[0];\n+    this.inMemoryKeyValueStore.put(key(0), emptyValue);\n+\n+    assertEquals(0, this.inMemoryKeyValueStore.get(key(0)).length);\n+    verify(this.putsCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length);\n+  }\n+\n+  @Test\n+  public void testPutNull() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), null);\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.deletesCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAll() {\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    verify(this.putsCounter, times(10)).inc();\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAllUpdate() {\n+    // check that an existing value is overridden\n+    this.inMemoryKeyValueStore.put(key(0), value(1234));\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    // 1 time for initial value to be overridden, 10 times for \"regular\" puts\n+    verify(this.putsCounter, times(11)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(1234).length);\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);", "originalCommit": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc0NDc5MQ==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461744791", "bodyText": "Yep, it does assume that, good point. Thanks for the suggestion. I defined a constant and added some more javadocs to clarify this.", "author": "cameronlee314", "createdAt": "2020-07-28T17:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzAxMg==", "url": "https://github.com/apache/samza/pull/1404#discussion_r461233012", "bodyText": "ty for noting the bug; will make it easy to fix when tests fail once the bug is fixed", "author": "bkonold", "createdAt": "2020-07-27T23:45:04Z", "path": "samza-kv-inmemory/src/test/java/org/apache/samza/storage/kv/inmemory/TestInMemoryKeyValueStore.java", "diffHunk": "@@ -19,66 +19,501 @@\n \n package org.apache.samza.storage.kv.inmemory;\n \n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import com.google.common.collect.Iterators;\n import com.google.common.primitives.Ints;\n-import org.apache.samza.metrics.MetricsRegistryMap;\n+import org.apache.samza.SamzaException;\n+import org.apache.samza.metrics.Counter;\n import org.apache.samza.storage.kv.Entry;\n import org.apache.samza.storage.kv.KeyValueIterator;\n import org.apache.samza.storage.kv.KeyValueSnapshot;\n import org.apache.samza.storage.kv.KeyValueStoreMetrics;\n+import org.junit.Before;\n import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-\n+import static org.junit.Assert.assertArrayEquals;\n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.Mockito.when;\n+\n \n public class TestInMemoryKeyValueStore {\n+  private static final String DEFAULT_KEY_PREFIX = \"key_prefix\";\n+  private static final String OTHER_KEY_PREFIX = \"other_key_prefix\";\n+  /**\n+   * Keep the lengths of the values longer so that metrics validations for key and value sizes don't collide.\n+   */\n+  private static final String DEFAULT_VALUE_PREFIX = \"value_prefix_value_prefix\";\n+  private static final String OTHER_VALUE_PREFIX = \"other_value_prefix_value_prefix\";\n+\n+  @Mock\n+  private KeyValueStoreMetrics keyValueStoreMetrics;\n+  @Mock\n+  private Counter getsCounter;\n+  @Mock\n+  private Counter bytesReadCounter;\n+  @Mock\n+  private Counter putsCounter;\n+  @Mock\n+  private Counter bytesWrittenCounter;\n+  @Mock\n+  private Counter deletesCounter;\n+\n+  private InMemoryKeyValueStore inMemoryKeyValueStore;\n+\n+  @Before\n+  public void setup() {\n+    MockitoAnnotations.initMocks(this);\n+    when(this.keyValueStoreMetrics.gets()).thenReturn(this.getsCounter);\n+    when(this.keyValueStoreMetrics.bytesRead()).thenReturn(this.bytesReadCounter);\n+    when(this.keyValueStoreMetrics.puts()).thenReturn(this.putsCounter);\n+    when(this.keyValueStoreMetrics.bytesWritten()).thenReturn(this.bytesWrittenCounter);\n+    when(this.keyValueStoreMetrics.deletes()).thenReturn(this.deletesCounter);\n+    this.inMemoryKeyValueStore = new InMemoryKeyValueStore(this.keyValueStoreMetrics);\n+  }\n+\n+  @Test\n+  public void testGet() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.getsCounter, times(2)).inc();\n+    verify(this.bytesReadCounter).inc(value(0).length);\n+    verify(this.bytesReadCounter).inc(value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testGetEmpty() {\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testGetAfterDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.getsCounter).inc();\n+    verifyZeroInteractions(this.bytesReadCounter);\n+  }\n+\n+  @Test\n+  public void testPut() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(OTHER_KEY_PREFIX, 1), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(0), this.inMemoryKeyValueStore.get(key(0)));\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(OTHER_KEY_PREFIX, 1)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(OTHER_KEY_PREFIX, 1).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutExistingEntry() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), value(OTHER_VALUE_PREFIX, 1));\n+\n+    assertArrayEquals(value(OTHER_VALUE_PREFIX, 1), this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(OTHER_VALUE_PREFIX, 1).length);\n+  }\n+\n+  @Test\n+  public void testPutEmpty() {\n+    byte[] emptyValue = new byte[0];\n+    this.inMemoryKeyValueStore.put(key(0), emptyValue);\n+\n+    assertEquals(0, this.inMemoryKeyValueStore.get(key(0)).length);\n+    verify(this.putsCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length);\n+  }\n+\n+  @Test\n+  public void testPutNull() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.put(key(0), null);\n+\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+    verify(this.putsCounter, times(2)).inc();\n+    verify(this.deletesCounter).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAll() {\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    verify(this.putsCounter, times(10)).inc();\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAllUpdate() {\n+    // check that an existing value is overridden\n+    this.inMemoryKeyValueStore.put(key(0), value(1234));\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+    }\n+    // 1 time for initial value to be overridden, 10 times for \"regular\" puts\n+    verify(this.putsCounter, times(11)).inc();\n+    verify(this.bytesWrittenCounter).inc(key(0).length + value(1234).length);\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+  }\n+\n+  @Test\n+  public void testPutAllWithNull() {\n+    List<Entry<byte[], byte[]>> entries = new ArrayList<>();\n+    for (int i = 0; i < 10; i++) {\n+      entries.add(new Entry<>(key(i), value(i)));\n+    }\n+    this.inMemoryKeyValueStore.putAll(entries);\n+\n+    List<Entry<byte[], byte[]>> deleteEntries = new ArrayList<>();\n+    for (int i = 0; i < 3; i++) {\n+      deleteEntries.add(new Entry<>(key(i), null));\n+    }\n+    this.inMemoryKeyValueStore.putAll(deleteEntries);\n+\n+    for (int i = 0; i < 10; i++) {\n+      if (i < 3) {\n+        assertNull(this.inMemoryKeyValueStore.get(key(i)));\n+      } else {\n+        assertArrayEquals(value(i), this.inMemoryKeyValueStore.get(key(i)));\n+      }\n+    }\n+    // 10 times for \"regular\" puts, 3 times for deletion puts\n+    verify(this.putsCounter, times(13)).inc();\n+    // 10 \"regular\" puts all have same size for key/value\n+    verify(this.bytesWrittenCounter, times(10)).inc(key(0).length + value(0).length);\n+    verifyNoMoreInteractions(this.bytesWrittenCounter);\n+    verify(this.deletesCounter, times(3)).inc();\n+  }\n+\n+  @Test\n+  public void testDelete() {\n+    this.inMemoryKeyValueStore.put(key(0), value(0));\n+    this.inMemoryKeyValueStore.delete(key(0));\n+    assertNull(this.inMemoryKeyValueStore.get(key(0)));\n+\n+    /*\n+     * There is a bug in which deletes are double counted in metrics. This deletesCounter should only be invoked once", "originalCommit": "4807acf6b01bedbfd2a6a7f4d13df76f2840ca59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9720188aaf7ba0d2e2ec1a899acf38a4903e325d", "url": "https://github.com/apache/samza/commit/9720188aaf7ba0d2e2ec1a899acf38a4903e325d", "message": "added JIRA tickets, clarified metrics validations", "committedDate": "2020-07-28T17:25:40Z", "type": "commit"}]}