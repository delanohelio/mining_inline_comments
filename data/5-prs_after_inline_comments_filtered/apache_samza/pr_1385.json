{"pr_number": 1385, "pr_title": "SAMZA-2550: Move side input processing to use RunLoop", "pr_createdAt": "2020-06-17T00:14:10Z", "pr_url": "https://github.com/apache/samza/pull/1385", "timeline": [{"oid": "f88203e76acfc8277e682e250bad211d70ad9626", "url": "https://github.com/apache/samza/commit/f88203e76acfc8277e682e250bad211d70ad9626", "message": "move side inputs onto runloop", "committedDate": "2020-06-16T23:21:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NjQ5MQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r442646491", "bodyText": "RunLoopTask doc says that if async commit is enabled then process and commit could happen in parallel. Since SideInputTask implements this interface, should we think about adding \"synchronized\" to SideInputTask.process and SideInputTask.commit methods?\nFrom our offline discussion, I understand that these two methods wont be parallel cause the sideInputRunLoop has asycnCommit = false hard coded and it is always single threaded.\nHowever, purely from the interface guarantee point of view, shouldnt this impl of RunLoopTask guard against async commits?", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T06:00:31Z", "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5NDk0Ng==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443894946", "bodyText": "I don't have strong feelings on this. I am leaning toward including synchronized to indicate explicitly that async commit is not yet supported here, regardless of how it is configured within RunLoop.\nJust realizing this now, but it would also allow us to more exactly mimic the process & commit exclusivity we had before (with the flush and process thread, one task could be flushing while another processes). We would mark async commit as true in this case, and provide a thread pool to RunLoop to execute commit operations in.\n@mynameborat thoughts?", "author": "bkonold", "createdAt": "2020-06-23T00:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NjQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxMjM4MQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r444312381", "bodyText": "I am not sure I follow the later part of the comment @bkonold. The exclusivity holds regardless due to the fact that the side input handler has synchronization between flush & process. SideInputTask in the current state is also not likely impacted because all it does it delegate calls to handler & increment metrics.\nHandling async commit might be a bit more involved than just synchronizing process & commit. I'd need to think a bit more on this. I'd suggest we have a validation if possible to throw if async commit is enabled for now.\nTo Manasa's point, the fact that process & commit can happen concurrently doesn't translate to thread safety concerns for all implementations. It is possible that the implementations of process & commit don't need synchronization. However, it is useful to call out that synchronization between those were explicitly ignored due to the state of current implementation.", "author": "mynameborat", "createdAt": "2020-06-23T15:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NjQ5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc5MTU5MA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r462791590", "bodyText": "Yeah you are right. Not sure what I was thinking.\nI'll mark both process and commit as synchronized to be more clear - this makes it more clear that concurrent process and commit is not supported with checkpointing.", "author": "bkonold", "createdAt": "2020-07-30T07:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY0NjQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzU2Ng==", "url": "https://github.com/apache/samza/pull/1385#discussion_r442653566", "bodyText": "Since regular task's process and side input task's process are both essentially treated the same (as they both implement RunLoopTask.process) - will this not increase the process_ns metric of the task to include side input processing time?\nFrom our offline discussion, I understand that prefixing the source with \"side-input\" will avoid this issue.\nAdditional doubt: was there a metric for process_ns of side input processing time before your change in this PR? are we changing the metric name as seen by the end user? if so, i think we might have to count it as API change", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T06:24:09Z", "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {\n+    return this.taskName;\n+  }\n+\n+  @Override\n+  public void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator,\n+      TaskCallbackFactory callbackFactory) {\n+    TaskCallback callback = callbackFactory.createCallback();\n+    this.metrics.processes().inc();", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4OTMxNA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443889314", "bodyText": "There was no process_ns for side inputs previously. The metrics that were there before (offset gauge, and any metrics that stem from SystemConsumers) are preserved in addition to introducing a new set of SamzaContainerMetrics specific to side inputs.", "author": "bkonold", "createdAt": "2020-06-23T00:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzODIxOQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443038219", "bodyText": "Minor: why do we have taskName instead of getTaskName for a getter method? This PR is not introducing the methods but implementing them, so its not really a comment for this PR :)  I wanted to know for my understanding if we changed the guidelines/conventions recently.", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T20:48:55Z", "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MDcxNA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443890714", "bodyText": "Method names were left as-is when extracting RunLoopTask from TaskInstance. TaskInstance is written in scala and as a result, some of the \"getter\" method names here are named as the vals defined by the scala class.", "author": "bkonold", "createdAt": "2020-06-23T00:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzODIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MDIxNA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443040214", "bodyText": "minor: init() so far has been a high-level method one calling helpers to do the actual stuff. So when i read it, I could easily get the steps init is taking without having to understand how to the steps are performed. Hence, wondering if there is value in moving this piece into a helper similar to getStartingoffsets?\nI feel it serves two purposes - keeps init a quick read and also clarifies what this step is in a single glance.. java doc for this helper would be a nice bonus ;)", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T20:55:23Z", "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -119,6 +125,17 @@ public void init() {\n \n     this.startingOffsets = getStartingOffsets(fileOffsets, getOldestOffsets());\n     LOG.info(\"Starting offsets for the task {}: {}\", taskName, startingOffsets);\n+\n+    this.sspOffsetsToBlockUntil = new HashMap<>();\n+    for (SystemStreamPartition ssp : this.sspToStores.keySet()) {\n+      SystemStreamMetadata metadata = this.streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n+      if (metadata != null) {\n+        String offset = metadata.getSystemStreamPartitionMetadata().get(ssp.getPartition()).getNewestOffset();\n+        this.sspOffsetsToBlockUntil.put(ssp, offset);\n+      }\n+    }\n+", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5NTIzNw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443895237", "bodyText": "Sure. I don't mind refactoring this into its own method.", "author": "bkonold", "createdAt": "2020-06-23T00:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0OTExNg==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443049116", "bodyText": "Im confused: starting offset could be the last processed offset on file (or oldest from source), and offsetToBlockUntil is essentially the newest offset from metadata cache right. In this case, isnt the starting offset <= newest offset - \"=\" if nothing is present after the last processed offset and \"<\" if something is present after the last processed offset.\nThis confusion might be arising from: my understanding (or messy understanding) of metadata cache and last processed offset on file.", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T21:23:27Z", "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -259,6 +277,44 @@ public void stop() {\n     return oldestOffsets;\n   }\n \n+  /**\n+   * Checks if whether the given offset for the SSP has reached the latest offset (determined at init),\n+   * removing it from the list of SSPs to catch up. Once the set of SSPs to catch up becomes empty, the latch for the\n+   * task will count down, notifying {@link ContainerStorageManager} that it is caught up.\n+   *\n+   * @param ssp The SSP to be checked\n+   * @param currentOffset The offset to be checked\n+   * @param isStartingOffset Indicates whether the offset being checked is the starting offset of the SSP (and thus has\n+   *                         not yet been processed). This will be set to true when each SSP's starting offset is checked\n+   *                         on init, and false when checking if an ssp is caught up after processing an envelope.\n+   */\n+  private void checkCaughtUp(SystemStreamPartition ssp, String currentOffset, boolean isStartingOffset) {\n+    String offsetToBlockUntil = this.sspOffsetsToBlockUntil.get(ssp);\n+\n+    LOG.trace(\"Checking offset {} against {} for {}. isStartingOffset: {}\", currentOffset, offsetToBlockUntil, ssp, isStartingOffset);\n+\n+    Integer comparatorResult;\n+    if (currentOffset == null || offsetToBlockUntil == null) {\n+      comparatorResult = -1;\n+    } else {\n+      SystemAdmin systemAdmin = systemAdmins.getSystemAdmin(ssp.getSystem());\n+      comparatorResult = systemAdmin.offsetComparator(currentOffset, offsetToBlockUntil);\n+    }\n+\n+    // If the starting offset, it must be greater (since the envelope at the starting offset will not yet have been processed)", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NzkyNA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443067924", "bodyText": "from offline discussion, clarification was provided that TaskSideInputHandler.getStartingOffset's java doc needs slight correction that starting offset is not exactly the last processed offset but the NEXT offset as specified in the storageManagerUtil.getStartingOffset", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T22:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0OTExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5NTYxMg==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443895612", "bodyText": "Indeed, the docs are misleading as they indicate that a lastProcessedOffset would be used as-is as a starting offset. As you point out, this it not the case. Will update the doc.", "author": "bkonold", "createdAt": "2020-06-23T00:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0OTExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODIyNQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443058225", "bodyText": "Not a comment: Are we not using the RunLoopFactory because we dont need to figure out the type of task or to avoid log statements?", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T21:56:40Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +744,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);\n-    }\n+        RunLoopTask sideInputTask = new SideInputTask(taskName, taskSSPs, taskSideInputHandlers.get(taskName), sideInputTaskMetrics.get(taskName));\n+\n+        sideInputTasks.put(taskName, sideInputTask);\n+      });\n \n     // start the systemConsumers for consuming input\n     this.sideInputSystemConsumers.start();\n \n+    TaskConfig taskConfig = new TaskConfig(this.config);\n+    SamzaContainerMetrics sideInputContainerMetrics =\n+        new SamzaContainerMetrics(SIDEINPUTS_METRICS_PREFIX + this.samzaContainerMetrics.source(),\n+            this.samzaContainerMetrics.registry());\n+\n+    this.sideInputRunLoop = new RunLoop(sideInputTasks,", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MDc0MQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443890741", "bodyText": "RunLoopFactory pulls construction values from config, not all of which we want to use here.", "author": "bkonold", "createdAt": "2020-06-23T00:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODY5NA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443058694", "bodyText": "This is supposed to be maxThrottlingDelayMs - as in milli seconds right.. why are we giving a value of 1 to this instead of 1 second?\nSamzaContainer uses the default of TimeUnit.SECONDS.toMillis(1) which is 1 second converted to milliseconds", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T21:58:42Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +744,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);\n-    }\n+        RunLoopTask sideInputTask = new SideInputTask(taskName, taskSSPs, taskSideInputHandlers.get(taskName), sideInputTaskMetrics.get(taskName));\n+\n+        sideInputTasks.put(taskName, sideInputTask);\n+      });\n \n     // start the systemConsumers for consuming input\n     this.sideInputSystemConsumers.start();\n \n+    TaskConfig taskConfig = new TaskConfig(this.config);\n+    SamzaContainerMetrics sideInputContainerMetrics =\n+        new SamzaContainerMetrics(SIDEINPUTS_METRICS_PREFIX + this.samzaContainerMetrics.source(),\n+            this.samzaContainerMetrics.registry());\n+\n+    this.sideInputRunLoop = new RunLoop(sideInputTasks,\n+        null, // all operations are executed in the main runloop thread\n+        this.sideInputSystemConsumers,\n+        1, // single message in flight per task\n+        -1, // no windowing\n+        taskConfig.getCommitMs(),\n+        taskConfig.getCallbackTimeoutMs(),\n+        1, // default taken from SamzaContainer", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MzcwMQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443893701", "bodyText": "This is a good catch. Perhaps I should just refactor the config access from SamzaContainer into a config class and reuse the method here. Thoughts?", "author": "bkonold", "createdAt": "2020-06-23T00:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxNTY4Mg==", "url": "https://github.com/apache/samza/pull/1385#discussion_r462815682", "bodyText": "i'll do this in a separate PR", "author": "bkonold", "createdAt": "2020-07-30T07:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1ODY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzAwNw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443063007", "bodyText": "so flush (aka commit) was happening in a separate thread right.. now we have moved that into the same thread as read (where the side input runloop now is). Why did we have two threads for read and flush earlier and what is the effect of removing the flush thread?", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T22:16:34Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -154,17 +149,13 @@\n   private final Map<TaskName, Map<String, Set<SystemStreamPartition>>> taskSideInputStoreSSPs;\n   private final Map<SystemStreamPartition, TaskSideInputHandler> sspSideInputHandlers;\n   private SystemConsumers sideInputSystemConsumers;\n-  private final Map<SystemStreamPartition, SystemStreamMetadata.SystemStreamPartitionMetadata> initialSideInputSSPMetadata\n-      = new ConcurrentHashMap<>(); // Recorded sspMetadata of the taskSideInputSSPs recorded at start, used to determine when sideInputs are caughtup and container init can proceed\n-  private volatile CountDownLatch sideInputsCaughtUp; // Used by the sideInput-read thread to signal to the main thread\n+  private volatile Map<TaskName, CountDownLatch> sideInputTaskLatches; // Used by the sideInput-read thread to signal to the main thread\n   private volatile boolean shouldShutdown = false;\n+  private RunLoop sideInputRunLoop;\n \n   private final ExecutorService sideInputsReadExecutor = Executors.newSingleThreadExecutor(\n       new ThreadFactoryBuilder().setDaemon(true).setNameFormat(SIDEINPUTS_READ_THREAD_NAME).build());\n \n-  private final ScheduledExecutorService sideInputsFlushExecutor = Executors.newSingleThreadScheduledExecutor(\n-      new ThreadFactoryBuilder().setDaemon(true).setNameFormat(SIDEINPUTS_FLUSH_THREAD_NAME).build());\n-  private ScheduledFuture sideInputsFlushFuture;", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MTg3Mw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443891873", "bodyText": "@mynameborat @rmatharu I am not clear on the historical context here. Can one of you comment on why it was written this way?\nFrom what I can tell, the change introduced to threading by my PR is that commit of one task will no longer be able to run concurrently with process of another task.", "author": "bkonold", "createdAt": "2020-06-23T00:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ3MzA0OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448473049", "bodyText": "CSM originally only handled state restoration which didn't require any commit/flush semantics. Eventually side inputs got rolled into CSM to pay way for standby and side inputs needed to be flushed in our commit cadence. The need for a separate timer thread to trigger flush/commit on task.commit.ms cadence was required. Instead of having logic to coordinate signals between read thread and the timer thread, flush was embedded as part of the timer thread and synchronization was introduced between process & commit.\nWith run loop, the internal timer thread run loop maintains does this job of signaling commit readiness to the task  and hence you don't need a separate flush thread. However, one thing to note is, previously we can potentially have two operations (process & flush) in parallel for different side inputs but with the new setup, we will need a thread pool size of (number of side input tasks + 1) to ensure parity. We will eventually support parallelism across stores/side input tasks as part of transaction state support (i guess).\nSo it is fine to leave it as is.", "author": "mynameborat", "createdAt": "2020-07-01T16:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2MzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NjQ1OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443066459", "bodyText": "please clarify what caught up means - because when starting offset = newest offset - it is caught up but the comparator result says not caught up. Oe does consuming newset offset qualify as caught up?", "author": "lakshmi-manasa-g", "createdAt": "2020-06-19T22:32:31Z", "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -259,6 +277,44 @@ public void stop() {\n     return oldestOffsets;\n   }\n \n+  /**\n+   * Checks if whether the given offset for the SSP has reached the latest offset (determined at init),", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5NTM1OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443895359", "bodyText": "+1 I will clarify the doc.", "author": "bkonold", "createdAt": "2020-06-23T00:28:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA2NjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0MzYxOQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443743619", "bodyText": "minor: maybe we can call this thread just \"sideInputs thread\" as it does both read and flush?", "author": "lakshmi-manasa-g", "createdAt": "2020-06-22T18:18:43Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -111,13 +109,10 @@\n   private static final Logger LOG = LoggerFactory.getLogger(ContainerStorageManager.class);\n   private static final String RESTORE_THREAD_NAME = \"Samza Restore Thread-%d\";\n   private static final String SIDEINPUTS_READ_THREAD_NAME = \"SideInputs Read Thread\";", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MTk4MA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443891980", "bodyText": "Agreed", "author": "bkonold", "createdAt": "2020-06-23T00:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0MzYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0ODUxMQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443848511", "bodyText": "just confirming: the check is the same now because StorageManagerUtil.getStartingOffset will get the Upcoming offset and from the definition of Upcoming and Newest offset - Upcoming > Newest.  So, although the new checkCaughtUp replacing this method is not explicitly using the OffsetTypes, it is still achieving the same.", "author": "lakshmi-manasa-g", "createdAt": "2020-06-22T21:56:31Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +744,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MzQ3NA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443893474", "bodyText": "Yes, the check remains the same. Rather than conditioning the comparator input on upcoming vs newest, we now always check against newest but treat the comparator result slightly differently (i.e. now the startingOffset must be greater than the newest offset when checked initially, rather than before checking equality on the upcoming offset).\nIs that clear enough?", "author": "bkonold", "createdAt": "2020-06-23T00:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0ODUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxNTQ4OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r462815489", "bodyText": "reverting this to keep the original logic", "author": "bkonold", "createdAt": "2020-07-30T07:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0ODUxMQ=="}], "type": "inlineReview"}, {"oid": "8b2a2041889ad7ded52744a0366017be3e0e680b", "url": "https://github.com/apache/samza/commit/8b2a2041889ad7ded52744a0366017be3e0e680b", "message": "incorporating review feedback", "committedDate": "2020-06-23T05:50:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4OTU0Mw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r443689543", "bodyText": "I understand these don't get called for side input tasks. Do we still want to throw exceptions or log warnings here as a safe guard?\nMaybe consider this for other methods that aren't implemented as part of the interface.", "author": "mynameborat", "createdAt": "2020-06-22T16:39:18Z", "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {\n+    return this.taskName;\n+  }\n+\n+  @Override\n+  public void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator,\n+      TaskCallbackFactory callbackFactory) {\n+    TaskCallback callback = callbackFactory.createCallback();\n+    this.metrics.processes().inc();\n+    try {\n+      this.taskSideInputHandler.process(envelope);\n+      this.metrics.messagesActuallyProcessed().inc();\n+      callback.complete();\n+    } catch (Exception e) {\n+      callback.failure(e);\n+    }\n+  }\n+\n+  @Override\n+  public void window(ReadableCoordinator coordinator) {\n+\n+  }\n+\n+  @Override\n+  public void scheduler(ReadableCoordinator coordinator) {\n+\n+  }", "originalCommit": "f88203e76acfc8277e682e250bad211d70ad9626", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2NTM5NA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r456765394", "bodyText": "I think an exception (akin to UnsupportedOperationException) would be fitting here. If these methods are called for a side input task, it probably means something undesirable is going on.", "author": "bkonold", "createdAt": "2020-07-18T08:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4OTU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTE3Ng==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448021176", "bodyText": "minor: extract false to meaningful name to help readability.", "author": "mynameborat", "createdAt": "2020-06-30T22:48:01Z", "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -119,6 +125,28 @@ public void init() {\n \n     this.startingOffsets = getStartingOffsets(fileOffsets, getOldestOffsets());\n     LOG.info(\"Starting offsets for the task {}: {}\", taskName, startingOffsets);\n+\n+    this.sspOffsetsToBlockUntil = getOffsetsToBlockUntil();\n+    LOG.info(\"Task {} will catch up to offsets {}\", this.taskName, this.sspOffsetsToBlockUntil);\n+\n+    this.startingOffsets.forEach((ssp, offset) -> checkCaughtUp(ssp, offset, true));\n+  }\n+\n+  /**\n+   * Retrieves the newest offset for each SSP\n+   *\n+   * @return a map of SSP to newest offset\n+   */\n+  private Map<SystemStreamPartition, String> getOffsetsToBlockUntil() {\n+    Map<SystemStreamPartition, String> offsetsToBlockUntil = new HashMap<>();\n+    for (SystemStreamPartition ssp : this.sspToStores.keySet()) {\n+      SystemStreamMetadata metadata = this.streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNjA4Nw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448026087", "bodyText": "New side input processing metrics emitted by SamzaContainerMetrics and TaskInstanceMetrics are given their own namespace in order to differentiate from the primary container / run loop.\n\nDoes this mean post this change, the old metrics emitted (if any) wouldn't work. If we didn't emit metrics for these prior to this change well and good. If not, would suggest updating the API changes description about metrics", "author": "mynameborat", "createdAt": "2020-06-30T23:02:32Z", "path": "samza-core/src/main/java/org/apache/samza/storage/SideInputTask.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.storage;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.container.RunLoopTask;\n+import org.apache.samza.container.TaskInstanceMetrics;\n+import org.apache.samza.container.TaskName;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallback;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * This class encapsulates the processing logic for side input streams. It is executed by {@link org.apache.samza.container.RunLoop}\n+ */\n+public class SideInputTask implements RunLoopTask {\n+  private final TaskName taskName;\n+  private final Set<SystemStreamPartition> taskSSPs;\n+  private final TaskSideInputHandler taskSideInputHandler;\n+  private final TaskInstanceMetrics metrics;\n+\n+  public SideInputTask(\n+      TaskName taskName,\n+      Set<SystemStreamPartition> taskSSPs,\n+      TaskSideInputHandler taskSideInputHandler,\n+      TaskInstanceMetrics metrics) {\n+    this.taskName = taskName;\n+    this.taskSSPs = taskSSPs;\n+    this.taskSideInputHandler = taskSideInputHandler;\n+    this.metrics = metrics;\n+  }\n+\n+  @Override\n+  public TaskName taskName() {\n+    return this.taskName;\n+  }\n+\n+  @Override\n+  public void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator,\n+      TaskCallbackFactory callbackFactory) {\n+    TaskCallback callback = callbackFactory.createCallback();\n+    this.metrics.processes().inc();\n+    try {\n+      this.taskSideInputHandler.process(envelope);\n+      this.metrics.messagesActuallyProcessed().inc();", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2Mzk2Nw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r456763967", "bodyText": "No, the only existing side input metrics were emitted out of system consumers, and those will remain the same as the SystemConsumers instance remains the same but is just passed into RunLoop.\nThe metrics (after this change) tracked in SamzaContainerMetrics and TaskInstanceMetrics are new. Can add this to the API section if you'd like, but there are no backwards incompatibilities.", "author": "bkonold", "createdAt": "2020-07-18T08:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNjA4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA3Mjk1OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r462072959", "bodyText": "Noting this hear so I don't forget: I didn't realize that source does not actually translate to metric prefix. I'll need to add a \"prefix\" param to the constructors of both SamzaContainerMetrics and TaskInstanceMetrics and an override implementation for the MetricsHelper.getPrefix method.", "author": "bkonold", "createdAt": "2020-07-29T06:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNjA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQwODc5OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448408799", "bodyText": "nit: indicates to CSM would be simpler yet accurate. It requires the entire e2e picture and how CSM interacts with container to understand this comment.", "author": "mynameborat", "createdAt": "2020-07-01T14:36:44Z", "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -63,19 +65,23 @@\n   private final Map<String, SideInputsProcessor> storeToProcessor;\n   private final SystemAdmins systemAdmins;\n   private final StreamMetadataCache streamMetadataCache;\n+  // indicates to container that all side input ssps in this task are caught up", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2NDAzNg==", "url": "https://github.com/apache/samza/pull/1385#discussion_r456764036", "bodyText": "Ah good catch. I'll change this comment to make that more clear.", "author": "bkonold", "createdAt": "2020-07-18T08:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQwODc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQxOTM0NA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448419344", "bodyText": "minor: would be good to extract the boolean argument to variable for readability.", "author": "mynameborat", "createdAt": "2020-07-01T14:51:44Z", "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -119,6 +125,28 @@ public void init() {\n \n     this.startingOffsets = getStartingOffsets(fileOffsets, getOldestOffsets());\n     LOG.info(\"Starting offsets for the task {}: {}\", taskName, startingOffsets);\n+\n+    this.sspOffsetsToBlockUntil = getOffsetsToBlockUntil();\n+    LOG.info(\"Task {} will catch up to offsets {}\", this.taskName, this.sspOffsetsToBlockUntil);\n+\n+    this.startingOffsets.forEach((ssp, offset) -> checkCaughtUp(ssp, offset, true));\n+  }\n+\n+  /**\n+   * Retrieves the newest offset for each SSP\n+   *\n+   * @return a map of SSP to newest offset\n+   */\n+  private Map<SystemStreamPartition, String> getOffsetsToBlockUntil() {\n+    Map<SystemStreamPartition, String> offsetsToBlockUntil = new HashMap<>();\n+    for (SystemStreamPartition ssp : this.sspToStores.keySet()) {\n+      SystemStreamMetadata metadata = this.streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2NTMxMQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r456765311", "bodyText": "Fine suggestion, I'll modify this.", "author": "bkonold", "createdAt": "2020-07-18T08:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQxOTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQzOTczNQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448439735", "bodyText": "can we keep the existing functionality as is in this PR? why do we need to differentiate this being checked during starting vs process?", "author": "mynameborat", "createdAt": "2020-07-01T15:22:27Z", "path": "samza-core/src/main/java/org/apache/samza/storage/TaskSideInputHandler.java", "diffHunk": "@@ -259,6 +288,44 @@ public void stop() {\n     return oldestOffsets;\n   }\n \n+  /**\n+   * An SSP is considered caught up once the offset indicated for it in {@link #sspOffsetsToBlockUntil} has been\n+   * processed. Once the set of SSPs to catch up becomes empty, the latch for the task will count down, notifying\n+   * {@link ContainerStorageManager} that it is caught up.\n+   *\n+   * @param ssp The SSP to be checked\n+   * @param currentOffset The offset to be checked\n+   * @param isStartingOffset Indicates whether the offset being checked is the starting offset of the SSP (and thus has\n+   *                         not yet been processed). This will be set to true when each SSP's starting offset is checked\n+   *                         on init, and false when checking if an ssp is caught up after processing an envelope.\n+   */\n+  private void checkCaughtUp(SystemStreamPartition ssp, String currentOffset, boolean isStartingOffset) {\n+    String offsetToBlockUntil = this.sspOffsetsToBlockUntil.get(ssp);\n+\n+    LOG.trace(\"Checking offset {} against {} for {}. isStartingOffset: {}\", currentOffset, offsetToBlockUntil, ssp, isStartingOffset);\n+\n+    Integer comparatorResult;\n+    if (currentOffset == null || offsetToBlockUntil == null) {\n+      comparatorResult = -1;\n+    } else {\n+      SystemAdmin systemAdmin = systemAdmins.getSystemAdmin(ssp.getSystem());\n+      comparatorResult = systemAdmin.offsetComparator(currentOffset, offsetToBlockUntil);\n+    }\n+\n+    // If the starting offset, it must be greater (since the envelope at the starting offset will not yet have been processed)\n+    // If not the starting offset, it must be greater than OR equal\n+    if (comparatorResult != null && ((isStartingOffset && comparatorResult > 0) || (!isStartingOffset && comparatorResult >= 0))) {\n+      LOG.info(\"Side input ssp {} has caught up to offset {}.\", ssp, offsetToBlockUntil);", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgxNTEwMg==", "url": "https://github.com/apache/samza/pull/1385#discussion_r462815102", "bodyText": "yea i'll change it back. at startup we need to check starting offsets against upcoming, but after each process we compare the envelope's offset to newest.", "author": "bkonold", "createdAt": "2020-07-30T07:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQzOTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ0NzYwMw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448447603", "bodyText": "can we update the comment here? this latch is used to check for caught up status currently. The side input exceptions get populated by the runloop flow.\nAlso, I'd suggest to rename this to something like SIDE_INPUT_CAUGHT_CHECK_TIMEOUT instead of of latch as one needs to figure out what this latch is used for. Maybe clarify in the comment that the check timeout applies across all the side inputs.", "author": "mynameborat", "createdAt": "2020-07-01T15:34:14Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -110,14 +108,12 @@\n public class ContainerStorageManager {\n   private static final Logger LOG = LoggerFactory.getLogger(ContainerStorageManager.class);\n   private static final String RESTORE_THREAD_NAME = \"Samza Restore Thread-%d\";\n-  private static final String SIDEINPUTS_READ_THREAD_NAME = \"SideInputs Read Thread\";\n-  private static final String SIDEINPUTS_FLUSH_THREAD_NAME = \"SideInputs Flush Thread\";\n+  private static final String SIDEINPUTS_THREAD_NAME = \"SideInputs Thread\";\n   private static final String SIDEINPUTS_METRICS_PREFIX = \"side-inputs-\";\n   // We use a prefix to differentiate the SystemConsumersMetrics for sideInputs from the ones in SamzaContainer\n \n-  private static final int SIDE_INPUT_READ_THREAD_TIMEOUT_SECONDS = 10; // Timeout with which sideinput read thread checks for exceptions\n-  private static final Duration SIDE_INPUT_FLUSH_TIMEOUT = Duration.ofMinutes(1); // Period with which sideinputs are flushed\n-\n+  private static final int SIDE_INPUT_LATCH_TIMEOUT_SECONDS = 10; // Timeout with which sideinput thread checks for exceptions", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2NDc0NQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r456764745", "bodyText": "I agree the name can be improved but I don't follow the first part of your comment. This purpose of this timeout remains the same as it was before the change: pausing every 10 seconds to check if either the tasks are all caught up, or if an exception has occurred. The fact that RunLoop is now the component throwing an exception is irrelevant; it still gets caught the same way within the thread and dumped into sideInputException.\nPerhaps just SIDE_INPUT_CHECK_TIMEOUT?", "author": "bkonold", "createdAt": "2020-07-18T08:14:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ0NzYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MDA1OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448450059", "bodyText": "can we extract this into a constant in some common file and use the constant in both places(here & SamzaContainer)?", "author": "mynameborat", "createdAt": "2020-07-01T15:38:04Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -758,41 +745,50 @@ public void run() {\n       sideInputSystemConsumers.register(ssp, startingOffset);\n       taskInstanceMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n           ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+      sideInputTaskMetrics.get(this.sspSideInputHandlers.get(ssp).getTaskName()).addOffsetGauge(\n+          ssp, ScalaJavaUtil.toScalaFunction(() -> this.sspSideInputHandlers.get(ssp).getLastProcessedOffset(ssp)));\n+    }\n \n-      SystemStreamMetadata systemStreamMetadata = streamMetadataCache.getSystemStreamMetadata(ssp.getSystemStream(), false);\n-      SystemStreamMetadata.SystemStreamPartitionMetadata sspMetadata =\n-          (systemStreamMetadata == null) ? null : systemStreamMetadata.getSystemStreamPartitionMetadata().get(ssp.getPartition());\n+    Map<TaskName, TaskSideInputHandler> taskSideInputHandlers = this.sspSideInputHandlers.values().stream()\n+        .distinct()\n+        .collect(Collectors.toMap(TaskSideInputHandler::getTaskName, Function.identity()));\n \n-      // record a copy of the sspMetadata, to later check if its caught up\n-      initialSideInputSSPMetadata.put(ssp, sspMetadata);\n+    Map<TaskName, RunLoopTask> sideInputTasks = new HashMap<>();\n+    this.taskSideInputStoreSSPs.forEach((taskName, storesToSSPs) -> {\n+        Set<SystemStreamPartition> taskSSPs = this.taskSideInputStoreSSPs.get(taskName).values().stream()\n+            .flatMap(Set::stream)\n+            .collect(Collectors.toSet());\n \n-      // check if the ssp is caught to upcoming, even at start\n-      checkSideInputCaughtUp(ssp, startingOffset, SystemStreamMetadata.OffsetType.UPCOMING, false);\n-    }\n+        RunLoopTask sideInputTask = new SideInputTask(taskName, taskSSPs, taskSideInputHandlers.get(taskName), sideInputTaskMetrics.get(taskName));\n+\n+        sideInputTasks.put(taskName, sideInputTask);\n+      });\n \n     // start the systemConsumers for consuming input\n     this.sideInputSystemConsumers.start();\n \n+    TaskConfig taskConfig = new TaskConfig(this.config);\n+    SamzaContainerMetrics sideInputContainerMetrics =\n+        new SamzaContainerMetrics(SIDEINPUTS_METRICS_PREFIX + this.samzaContainerMetrics.source(),\n+            this.samzaContainerMetrics.registry());\n+\n+    this.sideInputRunLoop = new RunLoop(sideInputTasks,\n+        null, // all operations are executed in the main runloop thread\n+        this.sideInputSystemConsumers,\n+        1, // single message in flight per task\n+        -1, // no windowing\n+        taskConfig.getCommitMs(),\n+        taskConfig.getCallbackTimeoutMs(),\n+        this.config.getLong(\"container.disk.quota.delay.max.ms\", TimeUnit.SECONDS.toMillis(1)),", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2NDg3Nw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r456764877", "bodyText": "Seems there are a few places where we use container.* configs. Should we refactor them all into a related *Config class?", "author": "bkonold", "createdAt": "2020-07-18T08:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MDA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxODY2Ng==", "url": "https://github.com/apache/samza/pull/1385#discussion_r464518666", "bodyText": "I am fine if we can create a follow up ticket and knock them out all at once. Considered resolved once you have a follow up TODO created.", "author": "mynameborat", "createdAt": "2020-08-03T16:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MDA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczNzQxOQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r466737419", "bodyText": "created a ticket and added a todo", "author": "bkonold", "createdAt": "2020-08-06T23:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MDA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MTg4Mw==", "url": "https://github.com/apache/samza/pull/1385#discussion_r448451883", "bodyText": "why do we need granular latches? Can we not use one latch with the size of number of side input tasks & check that reaches 0 instead?", "author": "mynameborat", "createdAt": "2020-07-01T15:41:09Z", "path": "samza-core/src/main/scala/org/apache/samza/storage/ContainerStorageManager.java", "diffHunk": "@@ -604,6 +597,9 @@ private StorageEngine createStore(String storeName, TaskName taskName, TaskModel\n           Map<String, StorageEngine> sideInputStores = getSideInputStores(taskName);\n           Map<String, Set<SystemStreamPartition>> sideInputStoresToSSPs = new HashMap<>();\n \n+          CountDownLatch taskCountDownLatch = new CountDownLatch(1);\n+          this.sideInputTaskLatches.put(taskName, taskCountDownLatch);", "originalCommit": "8b2a2041889ad7ded52744a0366017be3e0e680b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc2NTI3OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r456765279", "bodyText": "IMO this is safer as it eliminates sharing of objects between class instances. E.g. in the shared case a task could mistakenly countDown the latch more than once, which would be logically incorrect. The way it's written now, that would not be possible.\nI think it is also more readable; a dev can read through and understand the latch within TaskSideInputHandler without needing to know the relationship to CSM.\nI don't see an obvious shortcoming to the approach I've taken, can you explain if your preference is to use one latch and why?", "author": "bkonold", "createdAt": "2020-07-18T08:20:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MTg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIwMjY5MQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r463202691", "bodyText": "Can you elaborate on this if this is a blocking issue?", "author": "bkonold", "createdAt": "2020-07-30T18:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MTg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyNjIwNg==", "url": "https://github.com/apache/samza/pull/1385#discussion_r464526206", "bodyText": "Now that I think about it a bit more, I think you can do away without latches here. Since you will anyways need some form of callback to the runloop within CSM to denote completion of a message, can you actually not piggy back on the callback for particular end offset to count down the latches? With this, you can reuse the same approach for transactional state support for standbys.\nUnless you have a rationale of handling that part differently and not tie that into the initial catch up scenario.", "author": "mynameborat", "createdAt": "2020-08-03T16:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MTg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczNzYxMA==", "url": "https://github.com/apache/samza/pull/1385#discussion_r466737610", "bodyText": "did we resolve this offline? i remembering discussing that callbacks wouldn't quite work. ok to leave as-is?", "author": "bkonold", "createdAt": "2020-08-06T23:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MTg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc1ODQ2OQ==", "url": "https://github.com/apache/samza/pull/1385#discussion_r466758469", "bodyText": "yeah. we can leave it as is.", "author": "mynameborat", "createdAt": "2020-08-07T00:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1MTg4Mw=="}], "type": "inlineReview"}, {"oid": "c5c27cbc3ad1b1f63c1e84d4464a71a134a58a0c", "url": "https://github.com/apache/samza/commit/c5c27cbc3ad1b1f63c1e84d4464a71a134a58a0c", "message": "Merge branch 'master' into side_input_to_runloop", "committedDate": "2020-07-21T06:39:24Z", "type": "commit"}, {"oid": "1b715386f34b60d592224527d8bc2eca4cd8726c", "url": "https://github.com/apache/samza/commit/1b715386f34b60d592224527d8bc2eca4cd8726c", "message": "responding to PR feedback", "committedDate": "2020-07-30T18:44:48Z", "type": "commit"}, {"oid": "ce8b044327d1ff6ad88a6c89a0b73d7c580ada3d", "url": "https://github.com/apache/samza/commit/ce8b044327d1ff6ad88a6c89a0b73d7c580ada3d", "message": "Merge branch 'master' into side_input_to_runloop", "committedDate": "2020-07-30T18:50:16Z", "type": "commit"}, {"oid": "5f1b6e53c4410c7fdff286bad616b6a2b3dedeb7", "url": "https://github.com/apache/samza/commit/5f1b6e53c4410c7fdff286bad616b6a2b3dedeb7", "message": "Eliminating unnecessary object creation for side input tasks / handlers\n\nEnd of stream should just be a no-op rather than throw unsupported", "committedDate": "2020-08-06T10:00:34Z", "type": "commit"}, {"oid": "eb4c03c3fb0610fabef68597b5829ae3ed025133", "url": "https://github.com/apache/samza/commit/eb4c03c3fb0610fabef68597b5829ae3ed025133", "message": "Merge branch 'master' into side_input_to_runloop", "committedDate": "2020-08-06T10:13:25Z", "type": "commit"}, {"oid": "1274dcb791728c73bbcd8bfe1c9e07207326e6b0", "url": "https://github.com/apache/samza/commit/1274dcb791728c73bbcd8bfe1c9e07207326e6b0", "message": "add todo for config consolidation", "committedDate": "2020-08-06T23:08:55Z", "type": "commit"}]}