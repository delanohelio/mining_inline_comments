{"pr_number": 1355, "pr_title": "SAMZA-2519: Support duplicate timer registration", "pr_createdAt": "2020-05-05T21:01:24Z", "pr_url": "https://github.com/apache/samza/pull/1355", "timeline": [{"oid": "bca3c9043fda8a9be6d1afb47e3bf102841440cf", "url": "https://github.com/apache/samza/commit/bca3c9043fda8a9be6d1afb47e3bf102841440cf", "message": "SAMZA-2519: Support duplicate timer registration", "committedDate": "2020-05-05T20:49:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5ODY3MQ==", "url": "https://github.com/apache/samza/pull/1355#discussion_r421798671", "bodyText": "Probably need this to be warn level logging here.", "author": "xinyuiscool", "createdAt": "2020-05-07T21:15:06Z", "path": "samza-core/src/main/java/org/apache/samza/scheduler/EpochTimeScheduler.java", "diffHunk": "@@ -57,9 +58,33 @@ private EpochTimeScheduler(ScheduledExecutorService executor) {\n     this.executor = executor;\n   }\n \n+  @VisibleForTesting\n+  Map<Object, ScheduledFuture> getScheduledFutures() {\n+    return scheduledFutures;\n+  }\n+\n   public <K> void setTimer(K key, long timestamp, ScheduledCallback<K> callback) {\n-    checkState(!scheduledFutures.containsKey(key),\n-        String.format(\"Duplicate key %s registration for the same timer\", key));\n+    if (scheduledFutures.containsKey(key)) {\n+      LOG.warn(\"Registering duplicate callback for key: {}. Attempting to cancel the previous callback\", key);\n+      ScheduledFuture<?> scheduledFuture = scheduledFutures.get(key);\n+\n+      /*\n+       * We can have a race between the time we check for the presence of the key and the time we attempt to cancel;\n+       * Hence we check for non-null criteria to ensure the executor hasn't kicked off the callback for the key which\n+       * removes the future from the map before invoking onTimer.\n+       *  1. In the event that callback is running then we will not attempt to interrupt the action and\n+       *     cancel will return as unsuccessful.\n+       *  2. In case of the callback successfully executed, we want to allow duplicate registration to keep the\n+       *     behavior consistent with the scenario where the callback is already executed or in progress even before\n+       *     we entered this condition.\n+       */\n+      if (scheduledFuture != null\n+          && !scheduledFuture.cancel(false)\n+          && !scheduledFuture.isDone()) {\n+        LOG.debug(\"Failed to cancel the previous callback successfully. Ignoring the current request to register new callback\");", "originalCommit": "bca3c9043fda8a9be6d1afb47e3bf102841440cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "057a159888c90ac003aa3277a2052ab8b8e0c425", "url": "https://github.com/apache/samza/commit/057a159888c90ac003aa3277a2052ab8b8e0c425", "message": "Address Xinyu's comments", "committedDate": "2020-05-08T04:42:48Z", "type": "commit"}]}