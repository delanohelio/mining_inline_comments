{"pr_number": 1393, "pr_title": "SAMZA-2554: Fix the handling of join condition against remote table", "pr_createdAt": "2020-06-25T16:42:30Z", "pr_url": "https://github.com/apache/samza/pull/1393", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0OTUwNw==", "url": "https://github.com/apache/samza/pull/1393#discussion_r446549507", "bodyText": "could we add tests that go thru' the below code and fail ? If you plan to add them as part of your nested struct support, please feel free to drop this.", "author": "atoomula", "createdAt": "2020-06-27T17:44:54Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/translator/JoinTranslator.java", "diffHunk": "@@ -193,88 +215,133 @@ private void validateJoinQuery(LogicalJoin join, JoinInputNode.InputType inputTy\n           dumpRelPlanForNode(join));\n     }\n \n-    if (joinRelType.compareTo(JoinRelType.LEFT) == 0 && isTablePosOnLeft && !isTablePosOnRight) {\n+    if (joinRelType.compareTo(JoinRelType.LEFT) == 0 && isTablePosOnLeft) {\n       throw new SamzaException(\"Invalid query for outer left join. Left side of the join should be a 'stream' and \"\n           + \"right side of join should be a 'table'. \" + dumpRelPlanForNode(join));\n     }\n \n-    if (joinRelType.compareTo(JoinRelType.RIGHT) == 0 && isTablePosOnRight && !isTablePosOnLeft) {\n+    if (joinRelType.compareTo(JoinRelType.RIGHT) == 0 && isTablePosOnRight) {\n       throw new SamzaException(\"Invalid query for outer right join. Left side of the join should be a 'table' and \"\n           + \"right side of join should be a 'stream'. \" + dumpRelPlanForNode(join));\n     }\n \n-    validateJoinCondition(join.getCondition());\n-  }\n-\n-  private void validateJoinCondition(RexNode operand) {\n-    if (!(operand instanceof RexCall)) {\n-      throw new SamzaException(\"SQL Query is not supported. Join condition operand \" + operand +\n-          \" is of type \" + operand.getClass());\n-    }\n-\n-    RexCall condition = (RexCall) operand;\n+    final List<RexNode> conjunctionList = new ArrayList<>();\n+    decomposeAndValidateConjunction(join.getCondition(), conjunctionList);\n \n-    if (condition.isAlwaysTrue()) {\n+    if (conjunctionList.isEmpty()) {\n       throw new SamzaException(\"Query results in a cross join, which is not supported. Please optimize the query.\"\n           + \" It is expected that the joins should include JOIN ON operator in the sql query.\");\n     }\n-\n-    if (condition.getKind() != SqlKind.EQUALS && condition.getKind() != SqlKind.AND) {\n-      throw new SamzaException(\"Only equi-joins and AND operator is supported in join condition.\");\n-    }\n-  }\n-\n-  // Fetch the stream and table key indices corresponding to the fields given in the join condition by parsing through\n-  // the condition. Stream and table key indices are populated in streamKeyIds and tableKeyIds respectively.\n-  private void populateStreamAndTableKeyIds(List<RexNode> operands, final LogicalJoin join, boolean isTablePosOnRight,\n-      List<Integer> streamKeyIds, List<Integer> tableKeyIds) {\n-\n-    // All non-leaf operands in the join condition should be expressions.\n-    if (operands.get(0) instanceof RexCall) {\n-      operands.forEach(operand -> {\n-        validateJoinCondition(operand);\n-        populateStreamAndTableKeyIds(((RexCall) operand).getOperands(), join, isTablePosOnRight, streamKeyIds, tableKeyIds);\n-      });\n+    //TODO Not sure why we can not allow literal as part of the join condition will revisit this in another scope\n+    conjunctionList.forEach(rexNode -> rexNode.accept(new RexShuttle(){\n+      @Override\n+      public RexNode visitLiteral(RexLiteral literal) {\n+        throw new SamzaException(\n+            \"Join Condition can not allow literal \" + literal.toString() + \" join node\" + join.getDigest());\n+      }\n+    }));\n+    final JoinInputNode.InputType rootTableInput = isTablePosOnRight ? inputTypeOnRight : inputTypeOnLeft;\n+    if (rootTableInput.compareTo(JoinInputNode.InputType.REMOTE_TABLE) != 0) {\n+      // it is not a remote table all is good we do not have to validate the project on key Column\n       return;\n     }\n \n-    // We are at the leaf of the join condition. Only binary operators are supported.\n-    Validate.isTrue(operands.size() == 2);\n+    /*\n+    For remote Table we need to validate The join Condition and The project that is above remote table scan.\n+     - As of today Filter need to be exactly one equi-join using the __key__ column (see SAMZA-2554)\n+     - The Project on the top of the remote table has to contain only simple input references to any of the column used in the join.\n+    */\n+\n+    // First let's collect the ref of columns used by the join condition.\n+    List<RexInputRef> refCollector = new ArrayList<>();\n+    join.getCondition().accept(new RexShuttle(){\n+      @Override\n+      public RexNode visitInputRef(RexInputRef inputRef) {\n+        refCollector.add(inputRef);\n+        return inputRef;\n+      }\n+    });\n+    // start index of the Remote table within the Join Row\n+    final int tableStartIndex = isTablePosOnRight ? join.getLeft().getRowType().getFieldCount() : 0;\n+    // end index of the Remote table withing the Join Row\n+    final int tableEndIndex =\n+        isTablePosOnRight ? join.getRowType().getFieldCount() : join.getLeft().getRowType().getFieldCount();\n+\n+    List<Integer> tableRefsIdx = refCollector.stream()\n+        .map(x -> x.getIndex())\n+        .filter(x -> tableStartIndex <= x && x < tableEndIndex) // collect all the refs form table side\n+        .map(x -> x - tableStartIndex) // re-adjust the offset\n+        .sorted()\n+        .collect(Collectors.toList()); // we have a list with all the input from table side with 0 based index.\n+\n+    // Validate the Condition must contain a ref to remote table primary key column.\n+\n+    if (conjunctionList.size() != 1 || tableRefsIdx.size() != 1) {\n+      //TODO We can relax this by allowing another filter to be evaluated post lookup see SAMZA-2554\n+      throw new SamzaException(\n+          \"Invalid query for join condition must contain exactly one predicate for remote table on __key__ column \"\n+              + dumpRelPlanForNode(join));\n+    }\n \n-    // Only reference operands are supported in row expressions and not constants.\n-    // a.key = b.key is supported with a.key and b.key being reference operands.\n-    // a.key = \"constant\" is not yet supported.\n-    if (!(operands.get(0) instanceof RexInputRef) || !(operands.get(1) instanceof RexInputRef)) {\n-      throw new SamzaException(\"SQL query is not supported. Join condition \" + join.getCondition() + \" should have \"\n-          + \"reference operands but the types are \" + operands.get(0).getClass() + \" and \" + operands.get(1).getClass());\n+    // Validate the Project, follow each input and ensure that it is a simple ref with no rexCall in the way.\n+    if (!isValidRemoteJoinRef(tableRefsIdx.get(0), isTablePosOnRight ? join.getRight() : join.getLeft())) {\n+      throw new SamzaException(\"Invalid query for join condition can not have an expression and must be reference \"\n+          + SamzaSqlRelMessage.KEY_NAME + \" column \" + dumpRelPlanForNode(join));\n     }\n+  }\n \n-    // Join condition is commutative, meaning, a.key = b.key is equivalent to b.key = a.key.\n-    // Calcite assigns the indices to the fields based on the order a and b are specified in\n-    // the sql 'from' clause. Let's put the operand with smaller index in leftRef and larger\n-    // index in rightRef so that the order of operands in the join condition is in the order\n-    // the stream and table are specified in the 'from' clause.\n+  /**\n+   * Helper method to check if the join condition can be evaluated by the remote table.\n+   * It does follow single path  using the index ref path checking if it is a simple reference all the way to table scan.\n+   * In case any RexCall is encountered will stop an return null as a marker otherwise will return Column Name.\n+   *\n+   * @param inputRexIndex rex ref index\n+   * @param relNode current Rel Node\n+   * @return false if any Relational Expression is encountered on the path, true if is simple ref to __key__ column.\n+   */\n+  private static boolean isValidRemoteJoinRef(int inputRexIndex, RelNode relNode){\n+    if (relNode instanceof TableScan) {\n+      return relNode.getRowType().getFieldList().get(inputRexIndex).getName().equals(SamzaSqlRelMessage.KEY_NAME);\n+    }\n+    // has to be a single rel kind filter/project/table scan", "originalCommit": "042bcf2acfa6c62754da25afd5f0ba664551523d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE2MzI1MA==", "url": "https://github.com/apache/samza/pull/1393#discussion_r447163250", "bodyText": "@atoomula  this is hard to get done here because we can not handle any operator between TS and Join yet aka the NPE will come first, thus will add test for this case later.", "author": "b-slim", "createdAt": "2020-06-29T18:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0OTUwNw=="}], "type": "inlineReview"}, {"oid": "231853b2aa9da3444ee53a8e05dfd336feb88a15", "url": "https://github.com/apache/samza/commit/231853b2aa9da3444ee53a8e05dfd336feb88a15", "message": "SAMZA-2554: Fix the handling of join condition against remote tables.", "committedDate": "2020-06-29T18:04:32Z", "type": "commit"}, {"oid": "38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "url": "https://github.com/apache/samza/commit/38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "message": "Fixed one tests failing and ignored one complex mocking test", "committedDate": "2020-06-29T18:04:32Z", "type": "commit"}, {"oid": "38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "url": "https://github.com/apache/samza/commit/38a27c1047feb50e0bb9f2f2b4674d3f5bfcc910", "message": "Fixed one tests failing and ignored one complex mocking test", "committedDate": "2020-06-29T18:04:32Z", "type": "forcePushed"}, {"oid": "8a061d4db7955dc87687d2136ef767bfe66bb937", "url": "https://github.com/apache/samza/commit/8a061d4db7955dc87687d2136ef767bfe66bb937", "message": "Fix the style issues", "committedDate": "2020-06-29T18:52:26Z", "type": "commit"}]}