{"pr_number": 1366, "pr_title": "SAMZA-2529: Extract interface from TaskInstance for reuse of RunLoop", "pr_createdAt": "2020-05-22T17:51:51Z", "pr_url": "https://github.com/apache/samza/pull/1366", "timeline": [{"oid": "6a5a0ef61414edd77bcfdf04351a17d4502f7771", "url": "https://github.com/apache/samza/commit/6a5a0ef61414edd77bcfdf04351a17d4502f7771", "message": "Refactoring TaskInstance methods used by RunLoop into new interface RunLoopTask", "committedDate": "2020-05-22T08:15:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r429404171", "bodyText": "Can we add some java docs for this class?", "author": "mynameborat", "createdAt": "2020-05-22T18:50:33Z", "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {", "originalCommit": "6a5a0ef61414edd77bcfdf04351a17d4502f7771", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyMTM2Nw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r429421367", "bodyText": "yes, i'll add add a description to the class declaration.", "author": "bkonold", "createdAt": "2020-05-22T19:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzcxOA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430537718", "bodyText": "Let us take this opportunity to document more details about runloop and its interaction with the implementations of this interface.\n\nExclusivity between process, window, scheduler, commit. & endOfStream with the exception of async commit.\nNot thread safe and needs synchronization of shared objects between instances, between commit & other methods in case of async commit enabled within an instance\nLifecycle of this class if applicable; which brings a question on does this need init() and close();", "author": "mynameborat", "createdAt": "2020-05-26T16:15:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4NzYzNQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430587635", "bodyText": "+1 regarding adding docs to each method. Ideally, there would have already been more docs in TaskInstance, but it is more useful now that this is an interface.", "author": "cameronlee314", "createdAt": "2020-05-26T17:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0MTQzNA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430741434", "bodyText": "I've updated with better class-level and method-level docs.", "author": "bkonold", "createdAt": "2020-05-26T22:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0MzkxMw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430743913", "bodyText": "Regarding life cycle... RunLoop currently does not manage life cycle of the tasks it executes. This is done at the scope of SamzaContainer (i.e. the entity creating and running the RunLoop).\nSince this interface is targeted to the relationship between RunLoop and the tasks it executes, I don't think life cycle management belongs here.\nWhat do you think @mynameborat @cameronlee314 ?", "author": "bkonold", "createdAt": "2020-05-26T22:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1OTkzOQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430759939", "bodyText": "Discussed with @mynameborat and we think that unifying on lifecycle management will (eventually) be more necessary once we've moved side inputs back to using run loop (though a different instance at first). To consolidate to only a single RunLoop instance within container, we'd want some unified way to init/close a RunLoopTask whether it be a TaskInstance or \"NotYetImplementedSideInputTask\".\n@cameronlee314 Feel free to offer your thoughts but for now I think we can consider the life cycle issue out of scope for this PR.", "author": "bkonold", "createdAt": "2020-05-26T23:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTEwOA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r429405108", "bodyText": "minor: can we either group the methods and order them by ones that require implementation vs default", "author": "mynameborat", "createdAt": "2020-05-22T18:52:56Z", "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {", "originalCommit": "6a5a0ef61414edd77bcfdf04351a17d4502f7771", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxODI0NQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r429418245", "bodyText": "sure. i'll move the default methods to the end of the class. what do you mean by group?", "author": "bkonold", "createdAt": "2020-05-22T19:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MTEyMA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r429451120", "bodyText": "I have seen multiple patterns of grouping methods related to functionalities, access modifiers or just plan alphabetical.I wanted to suggest the grouping on access modifiers but pushing all the default methods down addresses that.", "author": "mynameborat", "createdAt": "2020-05-22T21:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTgwNg==", "url": "https://github.com/apache/samza/pull/1366#discussion_r429405806", "bodyText": "can we make this interface free of scala and have the implementors or callers adapt to scala if necessary?", "author": "mynameborat", "createdAt": "2020-05-22T18:54:48Z", "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+import scala.collection.JavaConversions;\n+\n+\n+public interface RunLoopTask {\n+\n+  TaskName taskName();\n+\n+  default boolean isWindowableTask() {\n+    return false;\n+  }\n+\n+  default boolean isAsyncTask() {\n+    return false;\n+  }\n+\n+  default EpochTimeScheduler epochTimeScheduler() {\n+    return null;\n+  }\n+\n+  default scala.collection.immutable.Set<String> intermediateStreams() {\n+    return JavaConversions.asScalaSet(Collections.emptySet()).toSet();\n+  }\n+\n+  scala.collection.immutable.Set<SystemStreamPartition> systemStreamPartitions();", "originalCommit": "6a5a0ef61414edd77bcfdf04351a17d4502f7771", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyMTU1OA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r429421558", "bodyText": "sure. this isn't that much more of a change and makes the interactions in RunLoop cleaner.", "author": "bkonold", "createdAt": "2020-05-22T19:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQwNTgwNg=="}], "type": "inlineReview"}, {"oid": "09f14114336565d54c88c4d076e852bb6be7bc57", "url": "https://github.com/apache/samza/commit/09f14114336565d54c88c4d076e852bb6be7bc57", "message": "Addressing review feedback", "committedDate": "2020-05-22T19:39:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5MzIyMA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430593220", "bodyText": "In my opinion, default implementations should be used when most of the implementors do not need to implement the methods or when you want to evolve an interface in a backwards compatible way. It doesn't sound like that is the case here, so maybe just require all implementors to implement these methods. The disadvantage of default implementations is that someone could unintentionally forget to implement them when they were supposed to implement them. Requiring implementations makes things explicit, and sometimes that is helpful.", "author": "cameronlee314", "createdAt": "2020-05-26T17:43:52Z", "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopTask.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.samza.container;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import org.apache.samza.checkpoint.OffsetManager;\n+import org.apache.samza.scheduler.EpochTimeScheduler;\n+import org.apache.samza.system.IncomingMessageEnvelope;\n+import org.apache.samza.system.SystemStreamPartition;\n+import org.apache.samza.task.ReadableCoordinator;\n+import org.apache.samza.task.TaskCallbackFactory;\n+\n+\n+/**\n+ * The interface required for a task's execution to be managed within {@link RunLoop}.\n+ */\n+public interface RunLoopTask {\n+\n+  TaskName taskName();\n+\n+  Set<SystemStreamPartition> systemStreamPartitions();\n+\n+  TaskInstanceMetrics metrics();\n+\n+  void process(IncomingMessageEnvelope envelope, ReadableCoordinator coordinator, TaskCallbackFactory callbackFactory);\n+\n+  void endOfStream(ReadableCoordinator coordinator);\n+\n+  void window(ReadableCoordinator coordinator);\n+\n+  void scheduler(ReadableCoordinator coordinator);\n+\n+  void commit();\n+\n+  default boolean isWindowableTask() {\n+    return false;\n+  }\n+\n+  default boolean isAsyncTask() {\n+    return false;\n+  }\n+\n+  default EpochTimeScheduler epochTimeScheduler() {\n+    return null;\n+  }\n+\n+  default Set<String> intermediateStreams() {\n+    return Collections.emptySet();\n+  }\n+\n+  default OffsetManager offsetManager() {\n+    return null;\n+  }", "originalCommit": "09f14114336565d54c88c4d076e852bb6be7bc57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY4NDg3Mw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430684873", "bodyText": "I agree; in retrospect this was motivated out of convenience rather than function. I'll remove the default modifiers.", "author": "bkonold", "createdAt": "2020-05-26T20:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5MzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NzQ4MA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r430597480", "bodyText": "Should RunLoopTask now be mocked in this test instead of using a concrete TaskInstance? It could help to validate your extraction of the interface and simplify the test to not depend on TaskInstance.", "author": "cameronlee314", "createdAt": "2020-05-26T17:51:07Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -236,7 +236,7 @@ public void testProcessMultipleTasks() throws Exception {\n     TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n     TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();", "originalCommit": "09f14114336565d54c88c4d076e852bb6be7bc57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MjM3Mg==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431492372", "bodyText": "Removed TaskInstance and instead had TestTask be an implementer of RunLoopTask interface.", "author": "bkonold", "createdAt": "2020-05-27T23:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU5NzQ4MA=="}], "type": "inlineReview"}, {"oid": "81683f1d64d81c7cf5fe7ff57a293e9d5204ade7", "url": "https://github.com/apache/samza/commit/81683f1d64d81c7cf5fe7ff57a293e9d5204ade7", "message": "Add documentation to RunLoopTask, remove 'isAsyncTask' from RunLoopTask/TaskInstance/RunLoopFactory", "committedDate": "2020-05-26T22:17:39Z", "type": "commit"}, {"oid": "09dd479a4dac6eb97c48eee523c0d2d4dadf12fd", "url": "https://github.com/apache/samza/commit/09dd479a4dac6eb97c48eee523c0d2d4dadf12fd", "message": "Clarify thread safety of process", "committedDate": "2020-05-26T23:15:57Z", "type": "commit"}, {"oid": "3ef784b0166d0abac080a5de1267c2ef7e00899c", "url": "https://github.com/apache/samza/commit/3ef784b0166d0abac080a5de1267c2ef7e00899c", "message": "Adapt TaskInstance tests for removal of isAsyncTask", "committedDate": "2020-05-27T05:33:16Z", "type": "commit"}, {"oid": "350f1bccd83e0f6e608df513f2090be2ae84a0f0", "url": "https://github.com/apache/samza/commit/350f1bccd83e0f6e608df513f2090be2ae84a0f0", "message": "Removing use of TaskInstance from TestRunLoop", "committedDate": "2020-05-27T05:35:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTExNw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431471117", "bodyText": "Was this validation moved somewhere else? Or is it no longer necessary?", "author": "cameronlee314", "createdAt": "2020-05-27T22:09:22Z", "path": "samza-core/src/main/java/org/apache/samza/container/RunLoopFactory.java", "diffHunk": "@@ -52,18 +50,6 @@ public static Runnable createRunLoop(scala.collection.immutable.Map<TaskName, Ta\n \n     log.info(\"Got commit milliseconds: {}.\", taskCommitMs);\n \n-    int asyncTaskCount = taskInstances.values().count(new AbstractFunction1<TaskInstance, Object>() {\n-      @Override\n-      public Boolean apply(TaskInstance t) {\n-        return t.isAsyncTask();\n-      }\n-    });\n-\n-    // asyncTaskCount should be either 0 or the number of all taskInstances\n-    if (asyncTaskCount > 0 && asyncTaskCount < taskInstances.size()) {\n-      throw new SamzaException(\"Mixing StreamTask and AsyncStreamTask is not supported\");\n-    }", "originalCommit": "350f1bccd83e0f6e608df513f2090be2ae84a0f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NDEzMQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431484131", "bodyText": "Thanks for asking. I think I should update the PR description to include details on this.\nIt is no longer necessary. In SamzaContainer, we will always wrap instances of StreamTask into AsyncStreamTaskAdapter. Thus, isAsyncTask is redundant since it is always true.", "author": "bkonold", "createdAt": "2020-05-27T22:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MDI0OA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432050248", "bodyText": "Updated PR description with these details.", "author": "bkonold", "createdAt": "2020-05-28T18:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTUyNg==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431475526", "bodyText": "Is this unused now? Could you please check the other tests to see if there are other unused variables too?", "author": "cameronlee314", "createdAt": "2020-05-27T22:20:25Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -231,14 +251,12 @@ public void testProcessMultipleTasks() throws Exception {\n     when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);", "originalCommit": "350f1bccd83e0f6e608df513f2090be2ae84a0f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MzgyMA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432043820", "bodyText": "Done", "author": "bkonold", "createdAt": "2020-05-28T18:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTg0OQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431475849", "bodyText": "Was this intended to be removed?", "author": "cameronlee314", "createdAt": "2020-05-27T22:21:15Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -390,23 +401,21 @@ public void testCommitSingleTask() throws Exception {\n     when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n+    TestTask task0 = spy(createTestTask(true, true, false, task0ProcessedMessagesLatch, 0, taskName0, ssp0, offsetManager));\n     task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    TestTask task1 = spy(createTestTask(true, false, true, task1ProcessedMessagesLatch, 0, taskName1, ssp1, offsetManager));\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n     when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n         .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n+//            task0ProcessedMessagesLatch.await();", "originalCommit": "350f1bccd83e0f6e608df513f2090be2ae84a0f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5MTQ3MQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431491471", "bodyText": "I was fiddling around with this as I was unsure whether the test actually required it (I see lots of copy pasta in this file). Looks like I also left one of the tests commented out as well.\nI'll comb back through to correct these.", "author": "bkonold", "createdAt": "2020-05-27T23:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MzU1MQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432043551", "bodyText": "Resolving this as I've rewritten all tests to instead use mocks, and tried to clean up cruft I found along the way while doing that.", "author": "bkonold", "createdAt": "2020-05-28T18:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NTg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NzA2MA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431477060", "bodyText": "times(1) is the default for verify, so you don't need to pass as an argument.", "author": "cameronlee314", "createdAt": "2020-05-27T22:24:18Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -538,6 +533,9 @@ public void testEndOfStreamWithMultipleTasks() throws Exception {\n     task0ProcessedMessagesLatch.await();\n     task1ProcessedMessagesLatch.await();\n \n+    verify(task0, times(1)).endOfStream(any());", "originalCommit": "350f1bccd83e0f6e608df513f2090be2ae84a0f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ4NzMyMw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r431487323", "bodyText": "Thanks, didn't know this.", "author": "bkonold", "createdAt": "2020-05-27T22:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NzA2MA=="}], "type": "inlineReview"}, {"oid": "71d5e80637bf8444b41c1a519df6bde6fb13a747", "url": "https://github.com/apache/samza/commit/71d5e80637bf8444b41c1a519df6bde6fb13a747", "message": "Cleaning up tests per review feedback", "committedDate": "2020-05-28T01:07:07Z", "type": "commit"}, {"oid": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "url": "https://github.com/apache/samza/commit/2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "message": "An attempt at improving RunLoop tests", "committedDate": "2020-05-28T17:53:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzU0Ng==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432127546", "bodyText": "Nit: Should this be envelope11?", "author": "cameronlee314", "createdAt": "2020-05-28T21:14:33Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");", "originalCommit": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTQzMA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432165430", "bodyText": "Yeah, I should probably change this. I was using the second digit more to indicate that it is used in tests as the \"0th\" message for ssp1. But it not matching the offset is confusing.", "author": "bkonold", "createdAt": "2020-05-28T22:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODI1Nw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432128257", "bodyText": "Should this be when(task1.taskName()).thenReturn(taskName1);? Although if the test passed, then does that mean the test doesn't need the result of taskName()?", "author": "cameronlee314", "createdAt": "2020-05-28T21:16:01Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n+  private final IncomingMessageEnvelope envelope01 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n   private final IncomingMessageEnvelope ssp0EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp0);\n   private final IncomingMessageEnvelope ssp1EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp1);\n \n-  TaskInstance createTaskInstance(AsyncStreamTask task, TaskName taskName, SystemStreamPartition ssp, OffsetManager manager, SystemConsumers consumers) {\n-    TaskModel taskModel = mock(TaskModel.class);\n-    when(taskModel.getTaskName()).thenReturn(taskName);\n-    TaskInstanceMetrics taskInstanceMetrics = new TaskInstanceMetrics(\"task\", new MetricsRegistryMap());\n-    scala.collection.immutable.Set<SystemStreamPartition> sspSet = JavaConverters.asScalaSetConverter(Collections.singleton(ssp)).asScala().toSet();\n-    return new TaskInstance(task,\n-        taskModel,\n-        taskInstanceMetrics,\n-        null,\n-        consumers,\n-        mock(TaskInstanceCollector.class),\n-        manager,\n-        null,\n-        null,\n-        sspSet,\n-        new TaskInstanceExceptionHandler(taskInstanceMetrics, new scala.collection.immutable.HashSet<String>()),\n-        null,\n-        null,\n-        null,\n-        null,\n-        mock(JobContext.class),\n-        mock(ContainerContext.class),\n-        Option.apply(null),\n-        Option.apply(null),\n-        Option.apply(null));\n-  }\n-\n-  interface TestCode {\n-    void run(TaskCallback callback);\n-  }\n-\n-  class TestTask implements AsyncStreamTask, WindowableTask, EndOfStreamListenerTask {\n-    private final boolean shutdown;\n-    private final boolean commit;\n-    private final boolean success;\n-    private final ExecutorService callbackExecutor = Executors.newFixedThreadPool(4);\n-\n-    private AtomicInteger completed = new AtomicInteger(0);\n-    private TestCode callbackHandler = null;\n-    private TestCode commitHandler = null;\n-    private TaskCoordinator.RequestScope commitRequest = null;\n-    private TaskCoordinator.RequestScope shutdownRequest = TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER;\n-\n-    private CountDownLatch processedMessagesLatch = null;\n-\n-    private volatile int windowCount = 0;\n-    private volatile int processed = 0;\n-    private volatile int committed = 0;\n-\n-    private int maxMessagesInFlight;\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown, CountDownLatch processedMessagesLatch) {\n-      this.success = success;\n-      this.shutdown = shutdown;\n-      this.commit = commit;\n-      this.processedMessagesLatch = processedMessagesLatch;\n-    }\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown,\n-             CountDownLatch processedMessagesLatch, int maxMessagesInFlight) {\n-      this(success, commit, shutdown, processedMessagesLatch);\n-      this.maxMessagesInFlight = maxMessagesInFlight;\n-    }\n-\n-    @Override\n-    public void processAsync(IncomingMessageEnvelope envelope, MessageCollector collector, TaskCoordinator coordinator, TaskCallback callback) {\n-\n-      if (maxMessagesInFlight == 1) {\n-        assertEquals(processed, completed.get());\n-      }\n-\n-      processed++;\n-\n-      if (commit) {\n-        if (commitHandler != null) {\n-          callbackExecutor.submit(() -> commitHandler.run(callback));\n-        }\n-        if (commitRequest != null) {\n-          coordinator.commit(commitRequest);\n-        }\n-        committed++;\n-      }\n-\n-      if (shutdown) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-\n-      callbackExecutor.submit(() -> {\n-          if (callbackHandler != null) {\n-            callbackHandler.run(callback);\n-          }\n-\n-          completed.incrementAndGet();\n-\n-          if (success) {\n-            callback.complete();\n-          } else {\n-            callback.failure(new Exception(\"process failure\"));\n-          }\n-\n-          if (processedMessagesLatch != null) {\n-            processedMessagesLatch.countDown();\n-          }\n-        });\n-    }\n-\n-    @Override\n-    public void window(MessageCollector collector, TaskCoordinator coordinator) throws Exception {\n-      windowCount++;\n-\n-      if (shutdown && windowCount == 4) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-    }\n-\n-    @Override\n-    public void onEndOfStream(MessageCollector collector, TaskCoordinator coordinator) {\n-      coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    }\n-\n-    void setShutdownRequest(TaskCoordinator.RequestScope shutdownRequest) {\n-      this.shutdownRequest = shutdownRequest;\n-    }\n-\n-    void setCommitRequest(TaskCoordinator.RequestScope commitRequest) {\n-      this.commitRequest = commitRequest;\n-    }\n-  }\n-\n   @Rule\n   public Timeout maxTestDurationInSeconds = Timeout.seconds(120);\n \n   @Test\n   public void testProcessMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task0Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(task0Metrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task1Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task1.systemStreamPartitions()).thenReturn(Collections.singleton(ssp1));\n+    when(task1.metrics()).thenReturn(task1Metrics);\n+    when(task0.taskName()).thenReturn(taskName1);", "originalCommit": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NTU1OA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432165558", "bodyText": "Good catch. I should use getMockRunLoopTask here instead of creating the mock inline.", "author": "bkonold", "createdAt": "2020-05-28T22:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNzI2NQ==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432137265", "bodyText": "Would it be good to use containerMetrics to verify that you saw all of the messages?", "author": "cameronlee314", "createdAt": "2020-05-28T21:34:38Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n+  private final IncomingMessageEnvelope envelope01 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n   private final IncomingMessageEnvelope ssp0EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp0);\n   private final IncomingMessageEnvelope ssp1EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp1);\n \n-  TaskInstance createTaskInstance(AsyncStreamTask task, TaskName taskName, SystemStreamPartition ssp, OffsetManager manager, SystemConsumers consumers) {\n-    TaskModel taskModel = mock(TaskModel.class);\n-    when(taskModel.getTaskName()).thenReturn(taskName);\n-    TaskInstanceMetrics taskInstanceMetrics = new TaskInstanceMetrics(\"task\", new MetricsRegistryMap());\n-    scala.collection.immutable.Set<SystemStreamPartition> sspSet = JavaConverters.asScalaSetConverter(Collections.singleton(ssp)).asScala().toSet();\n-    return new TaskInstance(task,\n-        taskModel,\n-        taskInstanceMetrics,\n-        null,\n-        consumers,\n-        mock(TaskInstanceCollector.class),\n-        manager,\n-        null,\n-        null,\n-        sspSet,\n-        new TaskInstanceExceptionHandler(taskInstanceMetrics, new scala.collection.immutable.HashSet<String>()),\n-        null,\n-        null,\n-        null,\n-        null,\n-        mock(JobContext.class),\n-        mock(ContainerContext.class),\n-        Option.apply(null),\n-        Option.apply(null),\n-        Option.apply(null));\n-  }\n-\n-  interface TestCode {\n-    void run(TaskCallback callback);\n-  }\n-\n-  class TestTask implements AsyncStreamTask, WindowableTask, EndOfStreamListenerTask {\n-    private final boolean shutdown;\n-    private final boolean commit;\n-    private final boolean success;\n-    private final ExecutorService callbackExecutor = Executors.newFixedThreadPool(4);\n-\n-    private AtomicInteger completed = new AtomicInteger(0);\n-    private TestCode callbackHandler = null;\n-    private TestCode commitHandler = null;\n-    private TaskCoordinator.RequestScope commitRequest = null;\n-    private TaskCoordinator.RequestScope shutdownRequest = TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER;\n-\n-    private CountDownLatch processedMessagesLatch = null;\n-\n-    private volatile int windowCount = 0;\n-    private volatile int processed = 0;\n-    private volatile int committed = 0;\n-\n-    private int maxMessagesInFlight;\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown, CountDownLatch processedMessagesLatch) {\n-      this.success = success;\n-      this.shutdown = shutdown;\n-      this.commit = commit;\n-      this.processedMessagesLatch = processedMessagesLatch;\n-    }\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown,\n-             CountDownLatch processedMessagesLatch, int maxMessagesInFlight) {\n-      this(success, commit, shutdown, processedMessagesLatch);\n-      this.maxMessagesInFlight = maxMessagesInFlight;\n-    }\n-\n-    @Override\n-    public void processAsync(IncomingMessageEnvelope envelope, MessageCollector collector, TaskCoordinator coordinator, TaskCallback callback) {\n-\n-      if (maxMessagesInFlight == 1) {\n-        assertEquals(processed, completed.get());\n-      }\n-\n-      processed++;\n-\n-      if (commit) {\n-        if (commitHandler != null) {\n-          callbackExecutor.submit(() -> commitHandler.run(callback));\n-        }\n-        if (commitRequest != null) {\n-          coordinator.commit(commitRequest);\n-        }\n-        committed++;\n-      }\n-\n-      if (shutdown) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-\n-      callbackExecutor.submit(() -> {\n-          if (callbackHandler != null) {\n-            callbackHandler.run(callback);\n-          }\n-\n-          completed.incrementAndGet();\n-\n-          if (success) {\n-            callback.complete();\n-          } else {\n-            callback.failure(new Exception(\"process failure\"));\n-          }\n-\n-          if (processedMessagesLatch != null) {\n-            processedMessagesLatch.countDown();\n-          }\n-        });\n-    }\n-\n-    @Override\n-    public void window(MessageCollector collector, TaskCoordinator coordinator) throws Exception {\n-      windowCount++;\n-\n-      if (shutdown && windowCount == 4) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-    }\n-\n-    @Override\n-    public void onEndOfStream(MessageCollector collector, TaskCoordinator coordinator) {\n-      coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    }\n-\n-    void setShutdownRequest(TaskCoordinator.RequestScope shutdownRequest) {\n-      this.shutdownRequest = shutdownRequest;\n-    }\n-\n-    void setCommitRequest(TaskCoordinator.RequestScope commitRequest) {\n-      this.commitRequest = commitRequest;\n-    }\n-  }\n-\n   @Rule\n   public Timeout maxTestDurationInSeconds = Timeout.seconds(120);\n \n   @Test\n   public void testProcessMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task0Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(task0Metrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task1Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task1.systemStreamPartitions()).thenReturn(Collections.singleton(ssp1));\n+    when(task1.metrics()).thenReturn(task1Metrics);\n+    when(task0.taskName()).thenReturn(taskName1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task1).process(eq(envelope10), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(2L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n+    assertEquals(4L, containerMetrics.envelopes().getCount());\n   }\n \n   @Test\n-  public void testProcessInOrder() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n+  public void testProcessInOrder() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics taskMetrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(taskMetrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n+    Map<TaskName, RunLoopTask> tasks = ImmutableMap.of(taskName0, task0);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    // Wait till the tasks completes processing all the messages.\n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n-    assertEquals(2L, t0.metrics().asyncCallbackCompleted().getCount());\n-    assertEquals(1L, t1.metrics().asyncCallbackCompleted().getCount());\n-  }\n-\n-  private TestCode buildOutofOrderCallback(final TestTask task) {\n-    final CountDownLatch latch = new CountDownLatch(1);\n-    return new TestCode() {\n-      @Override\n-      public void run(TaskCallback callback) {\n-        IncomingMessageEnvelope envelope = ((TaskCallbackImpl) callback).getEnvelope();\n-        if (envelope.equals(envelope0)) {\n-          // process first message will wait till the second one is processed\n-          try {\n-            latch.await();\n-          } catch (InterruptedException e) {\n-            e.printStackTrace();\n-          }\n-        } else {\n-          // second envelope complete first\n-          assertEquals(0, task.completed.get());\n-          latch.countDown();\n-        }\n-      }\n-    };\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n   }\n \n   @Test\n-  public void testProcessOutOfOrder() throws Exception {\n+  public void testProcessCallbacksCompletedOutOfOrder() {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n+\n+    InOrder inOrderOffsetManager = inOrder(offsetManager);\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope00.getOffset()));\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope01.getOffset()));\n \n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n+    assertEquals(3L, containerMetrics.envelopes().getCount());\n+    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testWindow() throws Exception {\n-    TestTask task0 = new TestTask(true, true, false, null);\n-    TestTask task1 = new TestTask(true, false, true, null);\n-\n+  public void testWindow() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    int maxMessagesInFlight = 1;\n+    long windowMs = 1;\n+    RunLoopTask task = mock(RunLoopTask.class);\n+    when(task.isWindowableTask()).thenReturn(true);\n+\n+    final AtomicInteger windowCount = new AtomicInteger(0);\n+    doAnswer(x -> {\n+        windowCount.incrementAndGet();\n+        if (windowCount.get() == 4) {\n+          x.getArgumentAt(0, ReadableCoordinator.class).shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        }\n+        Thread.sleep(windowMs);\n+        return null;\n+      }).when(task).window(any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task);\n \n-    long windowMs = 1;\n-    int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false)).thenReturn(null);\n     runLoop.run();\n \n-    assertEquals(4, task1.windowCount);\n+    verify(task, times(4)).window(any());\n   }\n \n   @Test\n-  public void testCommitSingleTask() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitSingleTask() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager, never()).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager, never()).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1, never()).commit();\n   }\n \n   @Test\n-  public void testCommitAllTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitAllTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+        coordinator.commit(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n+        callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n+\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1).commit();\n   }\n \n   @Test\n-  public void testShutdownOnConsensus() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testShutdownOnConsensus() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, true, task0ProcessedMessagesLatch);\n-    task0.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    task1.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    tasks.put(taskName1, createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer));\n \n     int maxMessagesInFlight = 1;\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task1).process(eq(envelope10), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     // consensus is reached after envelope1 is processed.\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(2L, containerMetrics.envelopes().getCount());\n     assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testEndOfStreamWithMultipleTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false))\n-      .thenReturn(envelope0)\n-      .thenReturn(envelope1)\n+      .thenReturn(envelope00)\n+      .thenReturn(envelope10)\n       .thenReturn(ssp0EndOfStream)\n       .thenReturn(ssp1EndOfStream)\n       .thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task0).endOfStream(any());\n+\n+    verify(task1).process(eq(envelope10), any(), any());\n+    verify(task1).endOfStream(any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(4L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithOutOfOrderProcess() throws Exception {\n+  public void testEndOfStreamWaitsForInFlightMessages() throws Exception {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(2);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    doAnswer(invocation -> {\n+        assertEquals(0, task0.metrics().messagesInFlight().getValue());\n+        return null;\n+      }).when(task0).endOfStream(any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(null).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream)\n+        .thenAnswer(invocation -> {\n+            // this ensures that the end of stream message has passed through run loop BEFORE the last remaining in flight message completes\n+            firstMessageBarrier.countDown();\n+            return null;\n+          });\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());", "originalCommit": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2ODE0MA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432168140", "bodyText": "Good point. I think this should be added to the Answer for the mocked endOfStream call. When endOfStream is finally called, the task should have seen all messages at that point. If we have the check later, it might be possible for the test to pass with bad behavior, e.g. if RunLoop were to somehow touch the process metric after endOfStream is called.\nWhat do you think?", "author": "bkonold", "createdAt": "2020-05-28T22:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNzI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3NjMxMw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432176313", "bodyText": "Whichever you prefer", "author": "cameronlee314", "createdAt": "2020-05-28T23:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzNzI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjAwNw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432142007", "bodyText": "Do you know if InOrder keeps track of when a method initially is called or when a method finishes execution? If it keeps track of the initial call, then this seems ok. However, if it tracks when the method finishes, then this test could end up being flaky, since it looks possible for commit to finish before the second process is done.\nMaybe InOrder isn't really necessary for this test, since the latches take care of the ordering.", "author": "cameronlee314", "createdAt": "2020-05-28T21:45:28Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestRunLoop.java", "diffHunk": "@@ -85,725 +62,484 @@\n   private final TaskName taskName1 = new TaskName(p1.toString());\n   private final SystemStreamPartition ssp0 = new SystemStreamPartition(\"testSystem\", \"testStream\", p0);\n   private final SystemStreamPartition ssp1 = new SystemStreamPartition(\"testSystem\", \"testStream\", p1);\n-  private final IncomingMessageEnvelope envelope0 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-  private final IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n-  private final IncomingMessageEnvelope envelope3 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope00 = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n+  private final IncomingMessageEnvelope envelope10 = new IncomingMessageEnvelope(ssp1, \"1\", \"key1\", \"value1\");\n+  private final IncomingMessageEnvelope envelope01 = new IncomingMessageEnvelope(ssp0, \"1\", \"key0\", \"value0\");\n   private final IncomingMessageEnvelope ssp0EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp0);\n   private final IncomingMessageEnvelope ssp1EndOfStream = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp1);\n \n-  TaskInstance createTaskInstance(AsyncStreamTask task, TaskName taskName, SystemStreamPartition ssp, OffsetManager manager, SystemConsumers consumers) {\n-    TaskModel taskModel = mock(TaskModel.class);\n-    when(taskModel.getTaskName()).thenReturn(taskName);\n-    TaskInstanceMetrics taskInstanceMetrics = new TaskInstanceMetrics(\"task\", new MetricsRegistryMap());\n-    scala.collection.immutable.Set<SystemStreamPartition> sspSet = JavaConverters.asScalaSetConverter(Collections.singleton(ssp)).asScala().toSet();\n-    return new TaskInstance(task,\n-        taskModel,\n-        taskInstanceMetrics,\n-        null,\n-        consumers,\n-        mock(TaskInstanceCollector.class),\n-        manager,\n-        null,\n-        null,\n-        sspSet,\n-        new TaskInstanceExceptionHandler(taskInstanceMetrics, new scala.collection.immutable.HashSet<String>()),\n-        null,\n-        null,\n-        null,\n-        null,\n-        mock(JobContext.class),\n-        mock(ContainerContext.class),\n-        Option.apply(null),\n-        Option.apply(null),\n-        Option.apply(null));\n-  }\n-\n-  interface TestCode {\n-    void run(TaskCallback callback);\n-  }\n-\n-  class TestTask implements AsyncStreamTask, WindowableTask, EndOfStreamListenerTask {\n-    private final boolean shutdown;\n-    private final boolean commit;\n-    private final boolean success;\n-    private final ExecutorService callbackExecutor = Executors.newFixedThreadPool(4);\n-\n-    private AtomicInteger completed = new AtomicInteger(0);\n-    private TestCode callbackHandler = null;\n-    private TestCode commitHandler = null;\n-    private TaskCoordinator.RequestScope commitRequest = null;\n-    private TaskCoordinator.RequestScope shutdownRequest = TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER;\n-\n-    private CountDownLatch processedMessagesLatch = null;\n-\n-    private volatile int windowCount = 0;\n-    private volatile int processed = 0;\n-    private volatile int committed = 0;\n-\n-    private int maxMessagesInFlight;\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown, CountDownLatch processedMessagesLatch) {\n-      this.success = success;\n-      this.shutdown = shutdown;\n-      this.commit = commit;\n-      this.processedMessagesLatch = processedMessagesLatch;\n-    }\n-\n-    TestTask(boolean success, boolean commit, boolean shutdown,\n-             CountDownLatch processedMessagesLatch, int maxMessagesInFlight) {\n-      this(success, commit, shutdown, processedMessagesLatch);\n-      this.maxMessagesInFlight = maxMessagesInFlight;\n-    }\n-\n-    @Override\n-    public void processAsync(IncomingMessageEnvelope envelope, MessageCollector collector, TaskCoordinator coordinator, TaskCallback callback) {\n-\n-      if (maxMessagesInFlight == 1) {\n-        assertEquals(processed, completed.get());\n-      }\n-\n-      processed++;\n-\n-      if (commit) {\n-        if (commitHandler != null) {\n-          callbackExecutor.submit(() -> commitHandler.run(callback));\n-        }\n-        if (commitRequest != null) {\n-          coordinator.commit(commitRequest);\n-        }\n-        committed++;\n-      }\n-\n-      if (shutdown) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-\n-      callbackExecutor.submit(() -> {\n-          if (callbackHandler != null) {\n-            callbackHandler.run(callback);\n-          }\n-\n-          completed.incrementAndGet();\n-\n-          if (success) {\n-            callback.complete();\n-          } else {\n-            callback.failure(new Exception(\"process failure\"));\n-          }\n-\n-          if (processedMessagesLatch != null) {\n-            processedMessagesLatch.countDown();\n-          }\n-        });\n-    }\n-\n-    @Override\n-    public void window(MessageCollector collector, TaskCoordinator coordinator) throws Exception {\n-      windowCount++;\n-\n-      if (shutdown && windowCount == 4) {\n-        coordinator.shutdown(shutdownRequest);\n-      }\n-    }\n-\n-    @Override\n-    public void onEndOfStream(MessageCollector collector, TaskCoordinator coordinator) {\n-      coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    }\n-\n-    void setShutdownRequest(TaskCoordinator.RequestScope shutdownRequest) {\n-      this.shutdownRequest = shutdownRequest;\n-    }\n-\n-    void setCommitRequest(TaskCoordinator.RequestScope commitRequest) {\n-      this.commitRequest = commitRequest;\n-    }\n-  }\n-\n   @Rule\n   public Timeout maxTestDurationInSeconds = Timeout.seconds(120);\n \n   @Test\n   public void testProcessMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task0Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(task0Metrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics task1Metrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task1.systemStreamPartitions()).thenReturn(Collections.singleton(ssp1));\n+    when(task1.metrics()).thenReturn(task1Metrics);\n+    when(task0.taskName()).thenReturn(taskName1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task1).process(eq(envelope10), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(2L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n+    assertEquals(4L, containerMetrics.envelopes().getCount());\n   }\n \n   @Test\n-  public void testProcessInOrder() throws Exception {\n-    CountDownLatch task0ProcessedMessages = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessages = new CountDownLatch(1);\n+  public void testProcessInOrder() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessages);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessages);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task0 = mock(RunLoopTask.class);\n+    TaskInstanceMetrics taskMetrics = new TaskInstanceMetrics(\"test\", new MetricsRegistryMap());\n+    when(task0.systemStreamPartitions()).thenReturn(Collections.singleton(ssp0));\n+    when(task0.metrics()).thenReturn(taskMetrics);\n+    when(task0.taskName()).thenReturn(taskName0);\n \n+    Map<TaskName, RunLoopTask> tasks = ImmutableMap.of(taskName0, task0);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    // Wait till the tasks completes processing all the messages.\n-    task0ProcessedMessages.await();\n-    task1ProcessedMessages.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n-    assertEquals(2L, t0.metrics().asyncCallbackCompleted().getCount());\n-    assertEquals(1L, t1.metrics().asyncCallbackCompleted().getCount());\n-  }\n-\n-  private TestCode buildOutofOrderCallback(final TestTask task) {\n-    final CountDownLatch latch = new CountDownLatch(1);\n-    return new TestCode() {\n-      @Override\n-      public void run(TaskCallback callback) {\n-        IncomingMessageEnvelope envelope = ((TaskCallbackImpl) callback).getEnvelope();\n-        if (envelope.equals(envelope0)) {\n-          // process first message will wait till the second one is processed\n-          try {\n-            latch.await();\n-          } catch (InterruptedException e) {\n-            e.printStackTrace();\n-          }\n-        } else {\n-          // second envelope complete first\n-          assertEquals(0, task.completed.get());\n-          latch.countDown();\n-        }\n-      }\n-    };\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n   }\n \n   @Test\n-  public void testProcessOutOfOrder() throws Exception {\n+  public void testProcessCallbacksCompletedOutOfOrder() {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n+\n+    InOrder inOrderOffsetManager = inOrder(offsetManager);\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope00.getOffset()));\n+    inOrderOffsetManager.verify(offsetManager).update(eq(taskName0), eq(ssp0), eq(envelope01.getOffset()));\n \n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n+    assertEquals(3L, containerMetrics.envelopes().getCount());\n+    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testWindow() throws Exception {\n-    TestTask task0 = new TestTask(true, true, false, null);\n-    TestTask task1 = new TestTask(true, false, true, null);\n-\n+  public void testWindow() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    int maxMessagesInFlight = 1;\n+    long windowMs = 1;\n+    RunLoopTask task = mock(RunLoopTask.class);\n+    when(task.isWindowableTask()).thenReturn(true);\n+\n+    final AtomicInteger windowCount = new AtomicInteger(0);\n+    doAnswer(x -> {\n+        windowCount.incrementAndGet();\n+        if (windowCount.get() == 4) {\n+          x.getArgumentAt(0, ReadableCoordinator.class).shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        }\n+        Thread.sleep(windowMs);\n+        return null;\n+      }).when(task).window(any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task);\n \n-    long windowMs = 1;\n-    int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false)).thenReturn(null);\n     runLoop.run();\n \n-    assertEquals(4, task1.windowCount);\n+    verify(task, times(4)).window(any());\n   }\n \n   @Test\n-  public void testCommitSingleTask() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitSingleTask() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager, never()).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager, never()).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1, never()).commit();\n   }\n \n   @Test\n-  public void testCommitAllTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testCommitAllTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+        coordinator.commit(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+        coordinator.shutdown(TaskCoordinator.RequestScope.ALL_TASKS_IN_CONTAINER);\n+\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(this.taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n+        callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n     //have a null message in between to make sure task0 finishes processing and invoke the commit\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0)\n-        .thenAnswer(x -> {\n-            task0ProcessedMessagesLatch.await();\n-            return null;\n-          }).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n+\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    verify(task0).commit();\n+    verify(task1).commit();\n   }\n \n   @Test\n-  public void testShutdownOnConsensus() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testShutdownOnConsensus() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    TestTask task0 = new TestTask(true, true, true, task0ProcessedMessagesLatch);\n-    task0.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, true, task1ProcessedMessagesLatch);\n-    task1.setShutdownRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    tasks.put(taskName1, createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer));\n \n     int maxMessagesInFlight = 1;\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+\n+        TaskCallback callback = callbackFactory.createCallback();\n+        coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        callback.complete();\n+        return null;\n+      }).when(task1).process(eq(envelope10), any(), any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     // consensus is reached after envelope1 is processed.\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope10).thenReturn(null);\n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(any(), any(), any());\n+    verify(task1).process(any(), any(), any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(2L, containerMetrics.envelopes().getCount());\n     assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithMultipleTasks() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testEndOfStreamWithMultipleTasks() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    RunLoopTask task1 = getMockRunLoopTask(taskName1, ssp1);\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    tasks.put(taskName0, task0);\n+    tasks.put(taskName1, task1);\n \n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n                                             () -> 0L, false);\n     when(consumerMultiplexer.choose(false))\n-      .thenReturn(envelope0)\n-      .thenReturn(envelope1)\n+      .thenReturn(envelope00)\n+      .thenReturn(envelope10)\n       .thenReturn(ssp0EndOfStream)\n       .thenReturn(ssp1EndOfStream)\n       .thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    verify(task0).process(eq(envelope00), any(), any());\n+    verify(task0).endOfStream(any());\n+\n+    verify(task1).process(eq(envelope10), any(), any());\n+    verify(task1).endOfStream(any());\n \n-    assertEquals(1, task0.processed);\n-    assertEquals(1, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n     assertEquals(4L, containerMetrics.envelopes().getCount());\n-    assertEquals(2L, containerMetrics.processes().getCount());\n   }\n \n   @Test\n-  public void testEndOfStreamWithOutOfOrderProcess() throws Exception {\n+  public void testEndOfStreamWaitsForInFlightMessages() throws Exception {\n     int maxMessagesInFlight = 2;\n-\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(2);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(1);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    TestTask task0 = new TestTask(true, true, false, task0ProcessedMessagesLatch, maxMessagesInFlight);\n-    TestTask task1 = new TestTask(true, true, false, task1ProcessedMessagesLatch, maxMessagesInFlight);\n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(2);\n+    doAnswer(invocation -> {\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+        callback.complete();\n+        firstMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n+    doAnswer(invocation -> {\n+        assertEquals(0, task0.metrics().messagesInFlight().getValue());\n+        return null;\n+      }).when(task0).endOfStream(any());\n+\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    task0.callbackHandler = buildOutofOrderCallback(task0);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope3).thenReturn(envelope1).thenReturn(null).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(ssp0EndOfStream)\n+        .thenAnswer(invocation -> {\n+            // this ensures that the end of stream message has passed through run loop BEFORE the last remaining in flight message completes\n+            firstMessageBarrier.countDown();\n+            return null;\n+          });\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n-\n-    assertEquals(2, task0.processed);\n-    assertEquals(2, task0.completed.get());\n-    assertEquals(1, task1.processed);\n-    assertEquals(1, task1.completed.get());\n-    assertEquals(5L, containerMetrics.envelopes().getCount());\n-    assertEquals(3L, containerMetrics.processes().getCount());\n+    verify(task0).endOfStream(any());\n   }\n \n   @Test\n-  public void testEndOfStreamCommitBehavior() throws Exception {\n-    CountDownLatch task0ProcessedMessagesLatch = new CountDownLatch(1);\n-    CountDownLatch task1ProcessedMessagesLatch = new CountDownLatch(1);\n-\n+  public void testEndOfStreamCommitBehavior() {\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    //explicitly configure to disable commits inside process or window calls and invoke commit from end of stream\n-    TestTask task0 = new TestTask(true, false, false, task0ProcessedMessagesLatch);\n-    TestTask task1 = new TestTask(true, false, false, task1ProcessedMessagesLatch);\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(0, ReadableCoordinator.class);\n+\n+        coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+        return null;\n+      }).when(task0).endOfStream(any());\n \n-    TaskInstance t0 = createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer);\n-    TaskInstance t1 = createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n \n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    tasks.put(taskName0, t0);\n-    tasks.put(taskName1, t1);\n     int maxMessagesInFlight = 1;\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n                                             callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope0).thenReturn(envelope1).thenReturn(null).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(ssp0EndOfStream).thenReturn(null);\n \n     runLoop.run();\n \n-    task0ProcessedMessagesLatch.await();\n-    task1ProcessedMessagesLatch.await();\n+    InOrder inOrder = inOrder(task0);\n \n-    verify(offsetManager).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    verify(offsetManager).buildCheckpoint(eq(taskName1));\n-    verify(offsetManager).writeCheckpoint(eq(taskName1), any(Checkpoint.class));\n+    inOrder.verify(task0).endOfStream(any());\n+    inOrder.verify(task0).commit();\n   }\n \n   @Test\n-  public void testEndOfStreamOffsetManagement() throws Exception {\n-    //explicitly configure to disable commits inside process or window calls and invoke commit from end of stream\n-    TestTask mockStreamTask1 = new TestTask(true, false, false, null);\n-    TestTask mockStreamTask2 = new TestTask(true, false, false, null);\n-\n-    Partition p1 = new Partition(1);\n-    Partition p2 = new Partition(2);\n-    SystemStreamPartition ssp1 = new SystemStreamPartition(\"system1\", \"stream1\", p1);\n-    SystemStreamPartition ssp2 = new SystemStreamPartition(\"system1\", \"stream2\", p2);\n-    IncomingMessageEnvelope envelope1 = new IncomingMessageEnvelope(ssp2, \"1\", \"key1\", \"message1\");\n-    IncomingMessageEnvelope envelope2 = new IncomingMessageEnvelope(ssp2, \"2\", \"key1\", \"message1\");\n-    IncomingMessageEnvelope envelope3 = IncomingMessageEnvelope.buildEndOfStreamEnvelope(ssp2);\n-\n-    Map<SystemStreamPartition, List<IncomingMessageEnvelope>> sspMap = new HashMap<>();\n-    List<IncomingMessageEnvelope> messageList = new ArrayList<>();\n-    messageList.add(envelope1);\n-    messageList.add(envelope2);\n-    messageList.add(envelope3);\n-    sspMap.put(ssp2, messageList);\n-\n-    SystemConsumer mockConsumer = mock(SystemConsumer.class);\n-    when(mockConsumer.poll(anyObject(), anyLong())).thenReturn(sspMap);\n-\n-    SystemAdmins systemAdmins = Mockito.mock(SystemAdmins.class);\n-    Mockito.when(systemAdmins.getSystemAdmin(\"system1\")).thenReturn(Mockito.mock(SystemAdmin.class));\n-    Mockito.when(systemAdmins.getSystemAdmin(\"testSystem\")).thenReturn(Mockito.mock(SystemAdmin.class));\n-\n-    HashMap<String, SystemConsumer> systemConsumerMap = new HashMap<>();\n-    systemConsumerMap.put(\"system1\", mockConsumer);\n-\n-    SystemConsumers consumers = TestSystemConsumers.getSystemConsumers(systemConsumerMap, systemAdmins);\n-\n-    TaskName taskName1 = new TaskName(\"task1\");\n-    TaskName taskName2 = new TaskName(\"task2\");\n-\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n-\n-    when(offsetManager.getLastProcessedOffset(taskName1, ssp1)).thenReturn(Option.apply(\"3\"));\n-    when(offsetManager.getLastProcessedOffset(taskName2, ssp2)).thenReturn(Option.apply(\"0\"));\n-    when(offsetManager.getStartingOffset(taskName1, ssp1)).thenReturn(Option.apply(IncomingMessageEnvelope.END_OF_STREAM_OFFSET));\n-    when(offsetManager.getStartingOffset(taskName2, ssp2)).thenReturn(Option.apply(\"1\"));\n-    when(offsetManager.getStartpoint(anyObject(), anyObject())).thenReturn(Option.empty());\n-\n-    TaskInstance taskInstance1 = createTaskInstance(mockStreamTask1, taskName1, ssp1, offsetManager, consumers);\n-    TaskInstance taskInstance2 = createTaskInstance(mockStreamTask2, taskName2, ssp2, offsetManager, consumers);\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-    tasks.put(taskName1, taskInstance1);\n-    tasks.put(taskName2, taskInstance2);\n-\n-    taskInstance1.registerConsumers();\n-    taskInstance2.registerConsumers();\n-    consumers.start();\n-\n-    int maxMessagesInFlight = 1;\n-    RunLoop runLoop = new RunLoop(tasks, executor, consumers, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-\n-    runLoop.run();\n-  }\n-\n-  //@Test\n-  public void testCommitBehaviourWhenAsyncCommitIsEnabled() throws InterruptedException {\n+  public void testCommitWithMessageInFlightWhenAsyncCommitIsEnabled() {\n+    int maxMessagesInFlight = 2;\n+    ExecutorService taskExecutor = Executors.newFixedThreadPool(2);\n     SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n     OffsetManager offsetManager = mock(OffsetManager.class);\n \n-    int maxMessagesInFlight = 3;\n-    TestTask task0 = new TestTask(true, true, false, null, maxMessagesInFlight);\n-    task0.setCommitRequest(TaskCoordinator.RequestScope.CURRENT_TASK);\n-    TestTask task1 = new TestTask(true, false, false, null, maxMessagesInFlight);\n-\n-    IncomingMessageEnvelope firstMsg = new IncomingMessageEnvelope(ssp0, \"0\", \"key0\", \"value0\");\n-    IncomingMessageEnvelope secondMsg = new IncomingMessageEnvelope(ssp0, \"1\", \"key1\", \"value1\");\n-    IncomingMessageEnvelope thirdMsg = new IncomingMessageEnvelope(ssp0, \"2\", \"key0\", \"value0\");\n-\n-    final CountDownLatch firstMsgCompletionLatch = new CountDownLatch(1);\n-    final CountDownLatch secondMsgCompletionLatch = new CountDownLatch(1);\n-    task0.callbackHandler = callback -> {\n-      IncomingMessageEnvelope envelope = ((TaskCallbackImpl) callback).getEnvelope();\n-      try {\n-        if (envelope.equals(firstMsg)) {\n-          firstMsgCompletionLatch.await();\n-        } else if (envelope.equals(secondMsg)) {\n-          firstMsgCompletionLatch.countDown();\n-          secondMsgCompletionLatch.await();\n-        } else if (envelope.equals(thirdMsg)) {\n-          secondMsgCompletionLatch.countDown();\n-          // OffsetManager.update with firstMsg offset, task.commit has happened when second message callback has not completed.\n-          verify(offsetManager).update(eq(taskName0), eq(firstMsg.getSystemStreamPartition()), eq(firstMsg.getOffset()));\n-        }\n-      } catch (Exception e) {\n-        e.printStackTrace();\n-      }\n-    };\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    tasks.put(taskName1, createTaskInstance(task1, taskName1, ssp1, offsetManager, consumerMultiplexer));\n-    when(consumerMultiplexer.choose(false)).thenReturn(firstMsg).thenReturn(secondMsg).thenReturn(thirdMsg).thenReturn(envelope1).thenReturn(ssp0EndOfStream).thenReturn(ssp1EndOfStream).thenReturn(null);\n-\n-    RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, false);\n-\n-    runLoop.run();\n-\n-    firstMsgCompletionLatch.await();\n-    secondMsgCompletionLatch.await();\n+    RunLoopTask task0 = getMockRunLoopTask(taskName0, ssp0);\n+    when(task0.offsetManager()).thenReturn(offsetManager);\n+    CountDownLatch firstMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        taskExecutor.submit(() -> {\n+            firstMessageBarrier.await();\n+            coordinator.commit(TaskCoordinator.RequestScope.CURRENT_TASK);\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope00), any(), any());\n+\n+    CountDownLatch secondMessageBarrier = new CountDownLatch(1);\n+    doAnswer(invocation -> {\n+        ReadableCoordinator coordinator = invocation.getArgumentAt(1, ReadableCoordinator.class);\n+        TaskCallbackFactory callbackFactory = invocation.getArgumentAt(2, TaskCallbackFactory.class);\n+        TaskCallback callback = callbackFactory.createCallback();\n+\n+        taskExecutor.submit(() -> {\n+            // let the first message proceed to ask for a commit\n+            firstMessageBarrier.countDown();\n+            // block this message until commit is executed\n+            secondMessageBarrier.await();\n+            coordinator.shutdown(TaskCoordinator.RequestScope.CURRENT_TASK);\n+            callback.complete();\n+            return null;\n+          });\n+        return null;\n+      }).when(task0).process(eq(envelope01), any(), any());\n \n-    verify(offsetManager, atLeastOnce()).buildCheckpoint(eq(taskName0));\n-    verify(offsetManager, atLeastOnce()).writeCheckpoint(eq(taskName0), any(Checkpoint.class));\n-    assertEquals(3, task0.processed);\n-    assertEquals(3, task0.committed);\n-    assertEquals(1, task1.processed);\n-    assertEquals(0, task1.committed);\n-  }\n+    doAnswer(invocation -> {\n+        assertEquals(1, task0.metrics().asyncCallbackCompleted().getCount());\n+        assertEquals(1, task0.metrics().messagesInFlight().getValue());\n \n-  @Test\n-  public void testProcessBehaviourWhenAsyncCommitIsEnabled() throws InterruptedException {\n-    int maxMessagesInFlight = 2;\n+        secondMessageBarrier.countDown();\n+        return null;\n+      }).when(task0).commit();\n \n-    SystemConsumers consumerMultiplexer = mock(SystemConsumers.class);\n-    when(consumerMultiplexer.pollIntervalMs()).thenReturn(10);\n-    OffsetManager offsetManager = mock(OffsetManager.class);\n+    Map<TaskName, RunLoopTask> tasks = new HashMap<>();\n+    tasks.put(taskName0, task0);\n \n-    TestTask task0 = new TestTask(true, true, false, null, maxMessagesInFlight);\n-    CountDownLatch commitLatch = new CountDownLatch(1);\n-    task0.commitHandler = callback -> {\n-      TaskCallbackImpl taskCallback = (TaskCallbackImpl) callback;\n-      if (taskCallback.getEnvelope().equals(envelope3)) {\n-        try {\n-          commitLatch.await();\n-        } catch (InterruptedException e) {\n-          e.printStackTrace();\n-        }\n-      }\n-    };\n-\n-    task0.callbackHandler = callback -> {\n-      TaskCallbackImpl taskCallback = (TaskCallbackImpl) callback;\n-      if (taskCallback.getEnvelope().equals(envelope0)) {\n-        // Both the process call has gone through when the first commit is in progress.\n-        assertEquals(2, containerMetrics.processes().getCount());\n-        assertEquals(0, containerMetrics.commits().getCount());\n-        commitLatch.countDown();\n-      }\n-    };\n-\n-    Map<TaskName, TaskInstance> tasks = new HashMap<>();\n-\n-    tasks.put(taskName0, createTaskInstance(task0, taskName0, ssp0, offsetManager, consumerMultiplexer));\n-    when(consumerMultiplexer.choose(false)).thenReturn(envelope3).thenReturn(envelope0).thenReturn(ssp0EndOfStream).thenReturn(null);\n     RunLoop runLoop = new RunLoop(tasks, executor, consumerMultiplexer, maxMessagesInFlight, windowMs, commitMs,\n-                                            callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics,\n-                                            () -> 0L, true);\n-\n+        callbackTimeoutMs, maxThrottlingDelayMs, maxIdleMs, containerMetrics, () -> 0L, true);\n+    when(consumerMultiplexer.choose(false)).thenReturn(envelope00).thenReturn(envelope01).thenReturn(null);\n     runLoop.run();\n \n-    commitLatch.await();\n+    InOrder inOrder = inOrder(task0);\n+    inOrder.verify(task0).process(eq(envelope00), any(), any());\n+    inOrder.verify(task0).process(eq(envelope01), any(), any());\n+    inOrder.verify(task0).commit();", "originalCommit": "2bcab11777cd2e0a60f04e60d68be1f302a6d0af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3NjE1Nw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432176157", "bodyText": "RunLoopTask.process and RunLoopTask.commit are all invoked from the same thread, and should be completed in this order.\nAre you referring to callback completion order?", "author": "bkonold", "createdAt": "2020-05-28T23:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3OTc4MA==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432179780", "bodyText": "Oh, I see. I got confused between the executor and the taskExecutor. I was thinking the thread pool was running the RunLoopTask.process and RunLoopTask.commit, but that's not the case.\nMy comment doesn't apply then.", "author": "cameronlee314", "createdAt": "2020-05-28T23:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4MDgzMw==", "url": "https://github.com/apache/samza/pull/1366#discussion_r432180833", "bodyText": "Cool.\nOne thing to note is that the current set of tests does not verify what happens when RunLoop is passed a non-null executor and can execute window/commit/scheduler in a separate thread from process. This was the case before as well but wanted to call that out.", "author": "bkonold", "createdAt": "2020-05-28T23:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MjAwNw=="}], "type": "inlineReview"}, {"oid": "e6038e0dece3582a98ab06b1f782881014a5408a", "url": "https://github.com/apache/samza/commit/e6038e0dece3582a98ab06b1f782881014a5408a", "message": "Add assertion on completed callbacks into testEndofStreamWaitsForInFlightMessages\n\nFix flakiness of testProcessCallbacksCompletedOutOfOrder\n\nIn testWindow, use a task that has non-empty set of ssps so endOfStream isn't triggered to shut down the task", "committedDate": "2020-05-29T00:18:06Z", "type": "commit"}]}