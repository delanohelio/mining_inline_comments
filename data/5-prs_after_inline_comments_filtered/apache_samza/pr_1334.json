{"pr_number": 1334, "pr_title": "SAMZA-2496: TestContainerHeartbeatMonitor does not properly stop the ContainerHeartbeatMonitor", "pr_createdAt": "2020-03-27T18:47:44Z", "pr_url": "https://github.com/apache/samza/pull/1334", "timeline": [{"oid": "9ab7fc7347ee39eada9c815bef5df85b1c524e76", "url": "https://github.com/apache/samza/commit/9ab7fc7347ee39eada9c815bef5df85b1c524e76", "message": "SAMZA-2496: TestContainerHeartbeatMonitor does not properly stop the ContainerHeartbeatMonitor", "committedDate": "2020-03-27T18:24:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA==", "url": "https://github.com/apache/samza/pull/1334#discussion_r399517388", "bodyText": "I see you are not the author of tests. But, do we need to wait for 2 seconds here for this test? Isn't verifying the scheduler for no task submissions below sufficient?", "author": "mynameborat", "createdAt": "2020-03-27T20:19:33Z", "path": "samza-core/src/test/java/org/apache/samza/container/TestContainerHeartbeatMonitor.java", "diffHunk": "@@ -20,44 +20,77 @@\n package org.apache.samza.container;\n \n import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n-import junit.framework.Assert;\n import org.junit.Test;\n \n-import static org.mockito.Mockito.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n \n-public class TestContainerHeartbeatMonitor {\n \n+public class TestContainerHeartbeatMonitor {\n   @Test\n-  public void testCallbackWhenHeartbeatDead()\n-      throws InterruptedException {\n+  public void testCallbackWhenHeartbeatDead() throws InterruptedException {\n     ContainerHeartbeatClient mockClient = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(false);\n     when(mockClient.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, mockClient, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);\n-    Assert.assertTrue(success);\n+    assertTrue(success);\n+    // check that the shutdown task got submitted, but don't actually execute it since it will shut down the process\n+    verify(scheduler).schedule(any(Runnable.class), eq((long) ContainerHeartbeatMonitor.SHUTDOWN_TIMOUT_MS),\n+        eq(TimeUnit.MILLISECONDS));\n+\n+    monitor.stop();\n+    verify(scheduler).shutdown();\n   }\n \n   @Test\n-  public void testDoesNotCallbackWhenHeartbeatAlive()\n-      throws InterruptedException {\n+  public void testDoesNotCallbackWhenHeartbeatAlive() throws InterruptedException {\n     ContainerHeartbeatClient client = mock(ContainerHeartbeatClient.class);\n     CountDownLatch countDownLatch = new CountDownLatch(1);\n-    Runnable onExpired = () -> {\n-      countDownLatch.countDown();\n-    };\n-    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client);\n+    Runnable onExpired = countDownLatch::countDown;\n     ContainerHeartbeatResponse response = new ContainerHeartbeatResponse(true);\n     when(client.requestHeartbeat()).thenReturn(response);\n+    ScheduledExecutorService scheduler = buildScheduledExecutorService();\n+    ContainerHeartbeatMonitor monitor = new ContainerHeartbeatMonitor(onExpired, client, scheduler);\n     monitor.start();\n     boolean success = countDownLatch.await(2, TimeUnit.SECONDS);", "originalCommit": "9ab7fc7347ee39eada9c815bef5df85b1c524e76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyMDgzMw==", "url": "https://github.com/apache/samza/pull/1334#discussion_r399520833", "bodyText": "The task executes asynchronously, so this 2 seconds gives some time to make sure that it doesn't actually execute. If we check for no task submission immediately, and there was a bug which caused the task to be submitted, it's possible that the test would still pass because the verification happened before the async execution.", "author": "cameronlee314", "createdAt": "2020-03-27T20:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyMjgwMg==", "url": "https://github.com/apache/samza/pull/1334#discussion_r399522802", "bodyText": "I see that makes sense. Then can we have buildScheduledExecutorService take a CountDownLatch and call run on the Runnable directly instead of spinning up a thread and finally decrementing the lathc?", "author": "mynameborat", "createdAt": "2020-03-27T20:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU1MTI2Ng==", "url": "https://github.com/apache/samza/pull/1334#discussion_r399551266", "bodyText": "Good idea. This prevents the extra 2s wait and it allows for some common initialization. Updated the tests.", "author": "cameronlee314", "createdAt": "2020-03-27T21:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNzM4OA=="}], "type": "inlineReview"}, {"oid": "43eb82acf9cc576cf5b9771cfe70e29c4c74bcf5", "url": "https://github.com/apache/samza/commit/43eb82acf9cc576cf5b9771cfe70e29c4c74bcf5", "message": "refactor test to prevent waiting", "committedDate": "2020-03-27T21:39:17Z", "type": "commit"}]}