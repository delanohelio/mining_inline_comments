{"pr_number": 1384, "pr_title": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "pr_createdAt": "2020-06-14T16:50:13Z", "pr_url": "https://github.com/apache/samza/pull/1384", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyMzQxMw==", "url": "https://github.com/apache/samza/pull/1384#discussion_r440323413", "bodyText": "This is basically tricking the planner to use Enum Convention plus Volcano planner to generate a Plan with Convention of  EnumerableConvention.INSTANCE. This will lead to complex branches down the line when doing the conversion as a follow up stage. You don't think the best way to do this is by using Calcite Conventions where Rules and Translation is happening at the same time to avoid complex code and very cryptic comments on what to expect when doing the translation ?", "author": "b-slim", "createdAt": "2020-06-15T17:10:07Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -140,16 +171,46 @@ public RelRoot plan(String query) {\n           .operatorTable(new ChainedSqlOperatorTable(sqlOperatorTables))\n           .sqlToRelConverterConfig(SqlToRelConverter.Config.DEFAULT)\n           .traitDefs(traitDefs)\n-          .context(Contexts.EMPTY_CONTEXT)\n-          .costFactory(null)\n+          .programs(Programs.hep(rules, true, DefaultRelMetadataProvider.INSTANCE))\n           .build();\n-      Planner planner = Frameworks.getPlanner(frameworkConfig);\n+      planner = Frameworks.getPlanner(frameworkConfig);\n+      return planner;\n+    } catch (Exception e) {\n+      String errorMsg = \"Failed to create planner.\";\n+      LOG.error(errorMsg, e);\n+      throw new SamzaException(errorMsg, e);\n+    }\n+  }\n \n+  private RelRoot optimize(RelRoot relRoot) {\n+    RelTraitSet relTraitSet = RelTraitSet.createEmpty();\n+    relTraitSet = relTraitSet.plus(EnumerableConvention.INSTANCE);", "originalCommit": "1d85cbeb832ed5b3411599f52d505790aef5a76e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMjYzNA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r440602634", "bodyText": "This is vestige from my earlier attempt to enable volcano planner. I removed it now.", "author": "atoomula", "createdAt": "2020-06-16T05:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyMzQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNTY3OA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r440325678", "bodyText": "When would you turn off the optimization ? if it is just optimization it should be always turned on ?", "author": "b-slim", "createdAt": "2020-06-15T17:14:26Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -140,16 +171,46 @@ public RelRoot plan(String query) {\n           .operatorTable(new ChainedSqlOperatorTable(sqlOperatorTables))\n           .sqlToRelConverterConfig(SqlToRelConverter.Config.DEFAULT)\n           .traitDefs(traitDefs)\n-          .context(Contexts.EMPTY_CONTEXT)\n-          .costFactory(null)\n+          .programs(Programs.hep(rules, true, DefaultRelMetadataProvider.INSTANCE))\n           .build();\n-      Planner planner = Frameworks.getPlanner(frameworkConfig);\n+      planner = Frameworks.getPlanner(frameworkConfig);\n+      return planner;\n+    } catch (Exception e) {\n+      String errorMsg = \"Failed to create planner.\";\n+      LOG.error(errorMsg, e);\n+      throw new SamzaException(errorMsg, e);\n+    }\n+  }\n \n+  private RelRoot optimize(RelRoot relRoot) {\n+    RelTraitSet relTraitSet = RelTraitSet.createEmpty();\n+    relTraitSet = relTraitSet.plus(EnumerableConvention.INSTANCE);\n+    try {\n+      RelRoot optimizedRelRoot =\n+          RelRoot.of(getPlanner().transform(0, relTraitSet, relRoot.project()), SqlKind.SELECT);\n+      LOG.info(\"query plan with optimization:\\n\"\n+          + RelOptUtil.toString(optimizedRelRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES));\n+      return optimizedRelRoot;\n+    } catch (Exception e) {\n+      String errorMsg =\n+          \"Error while optimizing query plan:\\n\" + RelOptUtil.toString(relRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n+      LOG.error(errorMsg, e);\n+      throw new SamzaException(errorMsg, e);\n+    }\n+  }\n+\n+  public RelRoot plan(String query) {\n+    try {\n+      Planner planner = getPlanner();\n       SqlNode sql = planner.parse(query);\n       SqlNode validatedSql = planner.validate(sql);\n       RelRoot relRoot = planner.rel(validatedSql);\n-      LOG.info(\"query plan:\\n\" + RelOptUtil.toString(relRoot.rel, SqlExplainLevel.ALL_ATTRIBUTES));\n-      return relRoot;\n+      LOG.info(\"query plan without optimization:\\n\"\n+          + RelOptUtil.toString(relRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES));", "originalCommit": "1d85cbeb832ed5b3411599f52d505790aef5a76e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwMzI5MA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r440603290", "bodyText": "I'm considering this as experimental right now considering this is the first version. Once we vet it thru' the real use-cases and gain confidence, we can enable it by default.", "author": "atoomula", "createdAt": "2020-06-16T05:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxOTI3MQ==", "url": "https://github.com/apache/samza/pull/1384#discussion_r444319271", "bodyText": "If the main concern is that planning will fail with the new rules my suggestion is to have it on by default and catch the exception and re-plan without optimization. In this way we can learn the logs. It is up to you if you think this can be too much work", "author": "b-slim", "createdAt": "2020-06-23T15:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNTY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjcxMTgzMQ==", "url": "https://github.com/apache/samza/pull/1384#discussion_r446711831", "bodyText": "I'm not strongly against turning it on by default. I turned it on by default now.", "author": "atoomula", "createdAt": "2020-06-28T23:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNTY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNzUxMA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r440327510", "bodyText": "As far I can tell it is only testing if filter is on the good side of the join, seems to me most of the work can be done at the onMatch, we can just extend and override onMatch ?", "author": "b-slim", "createdAt": "2020-06-15T17:17:44Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/SamzaSqlFilterRemoteJoinRule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.samza.sql.planner;\n+\n+import java.util.Map;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.samza.sql.interfaces.SqlIOConfig;\n+import org.apache.samza.sql.translator.JoinInputNode;\n+import org.apache.samza.sql.translator.JoinInputNode.InputType;\n+\n+/**\n+ * Planner rule for remote table joins that pushes filters above and\n+ * within a join node into its children nodes.\n+ * This class is customized form of Calcite's {@link org.apache.calcite.rel.rules.FilterJoinRule} for\n+ * remote table joins.\n+ */\n+public abstract class SamzaSqlFilterRemoteJoinRule extends RelOptRule {\n+  /** Whether to try to strengthen join-type. */\n+  private final boolean smart;\n+\n+  Map<String, SqlIOConfig> systemStreamConfigBySource;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a FilterJoinRule with an explicit root operand and\n+   * factories.\n+   */\n+  protected SamzaSqlFilterRemoteJoinRule(RelOptRuleOperand operand, String id,\n+      boolean smart, RelBuilderFactory relBuilderFactory, Map<String, SqlIOConfig> systemStreamConfigBySource) {\n+    super(operand, relBuilderFactory, \"SamzaSqlFilterRemoteJoinRule:\" + id);\n+    this.smart = smart;\n+    this.systemStreamConfigBySource = systemStreamConfigBySource;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void perform(RelOptRuleCall call, Filter filter,", "originalCommit": "1d85cbeb832ed5b3411599f52d505790aef5a76e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYwNDM4Ng==", "url": "https://github.com/apache/samza/pull/1384#discussion_r440604386", "bodyText": "I plan to add JoinConditionPushRule as well in next iteration (with no filter) which will reuse most of the code here and onMatch will be different.", "author": "atoomula", "createdAt": "2020-06-16T06:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyMTEyMA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r444321120", "bodyText": "In my opinion if we can minimize the copy and past that will be ideal and have the rest in a follow up, but it is up to you this is not a blocking point.", "author": "b-slim", "createdAt": "2020-06-23T15:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyNzUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxNzIwNg==", "url": "https://github.com/apache/samza/pull/1384#discussion_r444317206", "bodyText": "The planner is a closable resource I think it would be better to use it within a try block or make sure to close it when done.", "author": "b-slim", "createdAt": "2020-06-23T15:34:03Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -109,15 +124,19 @@ private void registerSourceSchemas(SchemaPlus rootSchema) {\n     }\n   }\n \n-  public RelRoot plan(String query) {\n+  private Planner getPlanner() {", "originalCommit": "3f0587201e2ec9a8bd4d5e0aac7362986894036b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjcxMTg1MQ==", "url": "https://github.com/apache/samza/pull/1384#discussion_r446711851", "bodyText": "Sure. Added code to close it now.", "author": "atoomula", "createdAt": "2020-06-28T23:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMxNzIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyMTg5MQ==", "url": "https://github.com/apache/samza/pull/1384#discussion_r444321891", "bodyText": "Why are we turning off for local tables things work fine, not sure I am getting this ?", "author": "b-slim", "createdAt": "2020-06-23T15:41:08Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/SamzaSqlFilterRemoteJoinRule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.samza.sql.planner;\n+\n+import java.util.Map;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.samza.sql.interfaces.SqlIOConfig;\n+import org.apache.samza.sql.translator.JoinInputNode;\n+import org.apache.samza.sql.translator.JoinInputNode.InputType;\n+\n+/**\n+ * Planner rule for remote table joins that pushes filters above and\n+ * within a join node into its children nodes.\n+ * This class is customized form of Calcite's {@link org.apache.calcite.rel.rules.FilterJoinRule} for\n+ * remote table joins.\n+ */\n+public abstract class SamzaSqlFilterRemoteJoinRule extends RelOptRule {\n+  /** Whether to try to strengthen join-type. */\n+  private final boolean smart;\n+\n+  Map<String, SqlIOConfig> systemStreamConfigBySource;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a FilterJoinRule with an explicit root operand and\n+   * factories.\n+   */\n+  protected SamzaSqlFilterRemoteJoinRule(RelOptRuleOperand operand, String id,\n+      boolean smart, RelBuilderFactory relBuilderFactory, Map<String, SqlIOConfig> systemStreamConfigBySource) {\n+    super(operand, relBuilderFactory, \"SamzaSqlFilterRemoteJoinRule:\" + id);\n+    this.smart = smart;\n+    this.systemStreamConfigBySource = systemStreamConfigBySource;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+      Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+\n+    boolean donotOptimizeLeft = false;\n+    boolean donotOptimizeRight = false;\n+\n+    JoinInputNode.InputType inputTypeOnLeft =\n+        JoinInputNode.getInputType(join.getLeft(), systemStreamConfigBySource);\n+    JoinInputNode.InputType inputTypeOnRight =\n+        JoinInputNode.getInputType(join.getRight(), systemStreamConfigBySource);\n+\n+    // Disable this optimnization for queries using local table.\n+    if (inputTypeOnLeft == InputType.LOCAL_TABLE || inputTypeOnRight == InputType.LOCAL_TABLE) {", "originalCommit": "3f0587201e2ec9a8bd4d5e0aac7362986894036b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjcxMTg2NA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r446711864", "bodyText": "There could be more optimizations done for local table as local tables do not have the limitations that remote tables have. We could directly enable Calcite's FilterJoinRule for local tables.", "author": "atoomula", "createdAt": "2020-06-28T23:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDMyMTg5MQ=="}], "type": "inlineReview"}, {"oid": "8044b6a237328e32ffa7881a1b44b57803745927", "url": "https://github.com/apache/samza/commit/8044b6a237328e32ffa7881a1b44b57803745927", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "cc7863f3531465ff1a1a48509d302cf327ef6ab6", "url": "https://github.com/apache/samza/commit/cc7863f3531465ff1a1a48509d302cf327ef6ab6", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "853bcbbfae61207e0b3d9fd81ac149f440086090", "url": "https://github.com/apache/samza/commit/853bcbbfae61207e0b3d9fd81ac149f440086090", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "1086936fe36c9486e73bfdf8f7b7177161a964c9", "url": "https://github.com/apache/samza/commit/1086936fe36c9486e73bfdf8f7b7177161a964c9", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "4bbdd2c1d427cc7127c276adb8ac657c10359a83", "url": "https://github.com/apache/samza/commit/4bbdd2c1d427cc7127c276adb8ac657c10359a83", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "1b4e5d5f4f508f5d6f9bdf4f9d6cf1ea314da008", "url": "https://github.com/apache/samza/commit/1b4e5d5f4f508f5d6f9bdf4f9d6cf1ea314da008", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "f73f4801af6f8d93436d52c961d67a25b40b12e3", "url": "https://github.com/apache/samza/commit/f73f4801af6f8d93436d52c961d67a25b40b12e3", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "63e101db7b87e089b8d101a094b824588532e162", "url": "https://github.com/apache/samza/commit/63e101db7b87e089b8d101a094b824588532e162", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "477d95f95bfc290e876735575112a153d26cc742", "url": "https://github.com/apache/samza/commit/477d95f95bfc290e876735575112a153d26cc742", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "ced116cfc3778171a73c37646c56e6dd987f975b", "url": "https://github.com/apache/samza/commit/ced116cfc3778171a73c37646c56e6dd987f975b", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "1b6d375cc82492d55e85fd6bc2bccfda1cffa7d9", "url": "https://github.com/apache/samza/commit/1b6d375cc82492d55e85fd6bc2bccfda1cffa7d9", "message": "Fix checkstyle errors", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "6b75106bd8931ab81048db2b3fa76fc3e0b8f32a", "url": "https://github.com/apache/samza/commit/6b75106bd8931ab81048db2b3fa76fc3e0b8f32a", "message": "Fix checkstyle errors", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "url": "https://github.com/apache/samza/commit/1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "message": "Fix checkstyle errors", "committedDate": "2020-07-01T02:32:07Z", "type": "commit"}, {"oid": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "url": "https://github.com/apache/samza/commit/1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "message": "Fix checkstyle errors", "committedDate": "2020-07-01T02:32:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAwMjI2Mg==", "url": "https://github.com/apache/samza/pull/1384#discussion_r441002262", "bodyText": "Nit:\n\nBy default, Logger adds \\n to EOL. Unnecessary to explicitly add it.\nAlso, it's better to capitalize all the log-messages.", "author": "shanthoosh", "createdAt": "2020-06-16T16:56:04Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -140,16 +166,45 @@ public RelRoot plan(String query) {\n           .operatorTable(new ChainedSqlOperatorTable(sqlOperatorTables))\n           .sqlToRelConverterConfig(SqlToRelConverter.Config.DEFAULT)\n           .traitDefs(traitDefs)\n-          .context(Contexts.EMPTY_CONTEXT)\n-          .costFactory(null)\n+          .programs(Programs.hep(rules, true, DefaultRelMetadataProvider.INSTANCE))\n           .build();\n-      Planner planner = Frameworks.getPlanner(frameworkConfig);\n+      planner = Frameworks.getPlanner(frameworkConfig);\n+      return planner;\n+    } catch (Exception e) {\n+      String errorMsg = \"Failed to create planner.\";\n+      LOG.error(errorMsg, e);\n+      throw new SamzaException(errorMsg, e);\n+    }\n+  }\n \n+  private RelRoot optimize(RelRoot relRoot) {\n+    RelTraitSet relTraitSet = RelTraitSet.createEmpty();\n+    try {\n+      RelRoot optimizedRelRoot =\n+          RelRoot.of(getPlanner().transform(0, relTraitSet, relRoot.project()), SqlKind.SELECT);\n+      LOG.info(\"query plan with optimization:\\n\"", "originalCommit": "3f0587201e2ec9a8bd4d5e0aac7362986894036b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMjM0Nw==", "url": "https://github.com/apache/samza/pull/1384#discussion_r456932347", "bodyText": "\\n is not for EOL. It is for separating the log.\nYou mean all log messages in Samza or just this ? And what is the point of capitalizing ? Is it to catch the eye while going thru logs ? If yes, we don't need to as their format makes them stand out in the logs,\n\n2020-07-19 10:11:16.814 [main] [] QueryPlanner [INFO] query plan without optimization:\nLogicalProject(key=[$9], pageKey=[$9], companyName=['N/A'], profileName=[$2], profileAddress=[$4])\nLogicalFilter(condition=[AND(=($2, 'Mike'), =($10, 1))])\nLogicalProject(key=[$0], id=[$1], name=[$2], companyId=[$3], address=[$4], selfEmployed=[$5], phoneNumbers=[$6], mapValues=[$7], __key__0=[$8], pageKey=[$9], profileId=[$10])\nLogicalJoin(condition=[=($0, $11)], joinType=[inner])\nLogicalTableScan(table=[[testRemoteStore, Profile, $table]])\nLogicalProject(key=[$0], pageKey=[$1], profileId=[$2], $f3=[BuildOutputRecord('id', $2)])\nLogicalTableScan(table=[[testavro, PAGEVIEW]])\n2020-07-19 10:11:16.816 [main] [] QueryPlanner [INFO] query plan with optimization:\nLogicalProject(key=[$9], pageKey=[$9], companyName=['N/A'], profileName=[$2], profileAddress=[$4])\nLogicalFilter(condition=[=($2, 'Mike')])\nLogicalJoin(condition=[=($0, $11)], joinType=[inner])\nLogicalTableScan(table=[[testRemoteStore, Profile, $table]])\nLogicalFilter(condition=[=($2, 1)])\nLogicalProject(key=[$0], pageKey=[$1], profileId=[$2], $f3=[BuildOutputRecord('id', $2)])\nLogicalTableScan(table=[[testavro, PAGEVIEW]])", "author": "atoomula", "createdAt": "2020-07-19T17:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAwMjI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAwNDkwMQ==", "url": "https://github.com/apache/samza/pull/1384#discussion_r441004901", "bodyText": "What is the rationale for recreating the planner for every sql-statement in the app?", "author": "shanthoosh", "createdAt": "2020-06-16T17:00:15Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/dsl/SamzaSqlDslConverter.java", "diffHunk": "@@ -52,9 +52,9 @@\n   public Collection<RelRoot> convertDsl(String dsl) {\n     // TODO: Introduce an API to parse a dsl string and return one or more sql statements\n     List<String> sqlStmts = fetchSqlFromConfig(config);\n-    QueryPlanner planner = getQueryPlanner(getSqlConfig(sqlStmts, config));\n     List<RelRoot> relRoots = new LinkedList<>();\n     for (String sql: sqlStmts) {\n+      QueryPlanner planner = getQueryPlanner(getSqlConfig(Collections.singletonList(sql), config));", "originalCommit": "3f0587201e2ec9a8bd4d5e0aac7362986894036b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMjY1Mw==", "url": "https://github.com/apache/samza/pull/1384#discussion_r456932653", "bodyText": "Good question. Calcite Planner as it stands today does not seem to be supported for reuse. Although the intent is there as they have exposed reset API. But it does not work. But it is such low cost to create new planner for each sql.", "author": "atoomula", "createdAt": "2020-07-19T17:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAwNDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTM4Nw==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453771387", "bodyText": "Would be better to create a follow-up ticket for this action-item.", "author": "shanthoosh", "createdAt": "2020-07-13T16:22:07Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -129,6 +142,13 @@ public RelRoot plan(String query) {\n       sqlOperatorTables.add(new SamzaSqlOperatorTable());\n       sqlOperatorTables.add(new SamzaSqlUdfOperatorTable(samzaSqlFunctions));\n \n+      // TODO: Introduce a pluggable rule factory.", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMjY1NQ==", "url": "https://github.com/apache/samza/pull/1384#discussion_r456932655", "bodyText": "Sure", "author": "atoomula", "createdAt": "2020-07-19T17:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMDcyOA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453820728", "bodyText": "nit: %s/optimnization/optimization", "author": "shanthoosh", "createdAt": "2020-07-13T17:43:28Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/SamzaSqlFilterRemoteJoinRule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.samza.sql.planner;\n+\n+import java.util.Map;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.samza.sql.interfaces.SqlIOConfig;\n+import org.apache.samza.sql.translator.JoinInputNode;\n+import org.apache.samza.sql.translator.JoinInputNode.InputType;\n+\n+/**\n+ * Planner rule for remote table joins that pushes filters above and\n+ * within a join node into its children nodes.\n+ * This class is customized form of Calcite's {@link org.apache.calcite.rel.rules.FilterJoinRule} for\n+ * remote table joins.\n+ */\n+public abstract class SamzaSqlFilterRemoteJoinRule extends RelOptRule {\n+  /** Whether to try to strengthen join-type. */\n+  private final boolean smart;\n+\n+  Map<String, SqlIOConfig> systemStreamConfigBySource;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a SamzaSqlFilterRemoteJoinRule with an explicit root operand and\n+   * factories.\n+   */\n+  protected SamzaSqlFilterRemoteJoinRule(RelOptRuleOperand operand, String id,\n+      boolean smart, RelBuilderFactory relBuilderFactory, Map<String, SqlIOConfig> systemStreamConfigBySource) {\n+    super(operand, relBuilderFactory, \"SamzaSqlFilterRemoteJoinRule:\" + id);\n+    this.smart = smart;\n+    this.systemStreamConfigBySource = systemStreamConfigBySource;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+      Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+\n+    boolean donotOptimizeLeft = false;\n+    boolean donotOptimizeRight = false;\n+\n+    JoinInputNode.InputType inputTypeOnLeft =\n+        JoinInputNode.getInputType(join.getLeft(), systemStreamConfigBySource);\n+    JoinInputNode.InputType inputTypeOnRight =\n+        JoinInputNode.getInputType(join.getRight(), systemStreamConfigBySource);\n+\n+    // Disable this optimnization for queries using local table.", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyMTExOA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453821118", "bodyText": "Please import the ImmutableList class and don't hardcode the package paths. There're multiple occurrences in this file and else-where.", "author": "shanthoosh", "createdAt": "2020-07-13T17:44:10Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/SamzaSqlFilterRemoteJoinRule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.samza.sql.planner;\n+\n+import java.util.Map;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.samza.sql.interfaces.SqlIOConfig;\n+import org.apache.samza.sql.translator.JoinInputNode;\n+import org.apache.samza.sql.translator.JoinInputNode.InputType;\n+\n+/**\n+ * Planner rule for remote table joins that pushes filters above and\n+ * within a join node into its children nodes.\n+ * This class is customized form of Calcite's {@link org.apache.calcite.rel.rules.FilterJoinRule} for\n+ * remote table joins.\n+ */\n+public abstract class SamzaSqlFilterRemoteJoinRule extends RelOptRule {\n+  /** Whether to try to strengthen join-type. */\n+  private final boolean smart;\n+\n+  Map<String, SqlIOConfig> systemStreamConfigBySource;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a SamzaSqlFilterRemoteJoinRule with an explicit root operand and\n+   * factories.\n+   */\n+  protected SamzaSqlFilterRemoteJoinRule(RelOptRuleOperand operand, String id,\n+      boolean smart, RelBuilderFactory relBuilderFactory, Map<String, SqlIOConfig> systemStreamConfigBySource) {\n+    super(operand, relBuilderFactory, \"SamzaSqlFilterRemoteJoinRule:\" + id);\n+    this.smart = smart;\n+    this.systemStreamConfigBySource = systemStreamConfigBySource;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+      Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+\n+    boolean donotOptimizeLeft = false;\n+    boolean donotOptimizeRight = false;\n+\n+    JoinInputNode.InputType inputTypeOnLeft =\n+        JoinInputNode.getInputType(join.getLeft(), systemStreamConfigBySource);\n+    JoinInputNode.InputType inputTypeOnRight =\n+        JoinInputNode.getInputType(join.getRight(), systemStreamConfigBySource);\n+\n+    // Disable this optimnization for queries using local table.\n+    if (inputTypeOnLeft == InputType.LOCAL_TABLE || inputTypeOnRight == InputType.LOCAL_TABLE) {\n+      donotOptimizeLeft = true;\n+      donotOptimizeRight = true;\n+    }\n+\n+    // There is nothing to optimize on the remote table side as the lookup needs to happen first before filtering.\n+    if (inputTypeOnLeft == InputType.REMOTE_TABLE) {\n+      donotOptimizeLeft = true;\n+    }\n+    if (inputTypeOnRight == InputType.REMOTE_TABLE) {\n+      donotOptimizeRight = true;\n+    }\n+\n+    // If there is only the joinRel,\n+    // make sure it does not match a cartesian product joinRel\n+    // (with \"true\" condition), otherwise this rule will be applied\n+    // again on the new cartesian product joinRel.\n+    if (filter == null && joinFilters.isEmpty()) {\n+      return;\n+    }\n+\n+    final List<RexNode> aboveFilters =\n+        filter != null\n+            ? RelOptUtil.conjunctions(filter.getCondition())\n+            : new ArrayList<>();\n+    final com.google.common.collect.ImmutableList<RexNode> origAboveFilters =", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgzNzU5NQ==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453837595", "bodyText": "Just curious. Why did we comment this out? If this is not necessary, then can we please remove it?", "author": "shanthoosh", "createdAt": "2020-07-13T18:12:23Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/util/SamzaSqlQueryParser.java", "diffHunk": "@@ -165,6 +165,7 @@ private static Planner createPlanner() {\n         .traitDefs(traitDefs)\n         .context(Contexts.EMPTY_CONTEXT)\n         .costFactory(null)\n+        //.programs(Programs.CALC_PROGRAM)", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0OTY1OA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453849658", "bodyText": "Just curious. Can you please clarify if we should use aboveFilters here for third argument? From the semantics  of classifyFilters method, it seems like appropriate choice. Might be better to rename the variable to something better(other than aboveFilters).", "author": "shanthoosh", "createdAt": "2020-07-13T18:32:42Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/SamzaSqlFilterRemoteJoinRule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.samza.sql.planner;\n+\n+import java.util.Map;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.samza.sql.interfaces.SqlIOConfig;\n+import org.apache.samza.sql.translator.JoinInputNode;\n+import org.apache.samza.sql.translator.JoinInputNode.InputType;\n+\n+/**\n+ * Planner rule for remote table joins that pushes filters above and\n+ * within a join node into its children nodes.\n+ * This class is customized form of Calcite's {@link org.apache.calcite.rel.rules.FilterJoinRule} for\n+ * remote table joins.\n+ */\n+public abstract class SamzaSqlFilterRemoteJoinRule extends RelOptRule {\n+  /** Whether to try to strengthen join-type. */\n+  private final boolean smart;\n+\n+  Map<String, SqlIOConfig> systemStreamConfigBySource;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a SamzaSqlFilterRemoteJoinRule with an explicit root operand and\n+   * factories.\n+   */\n+  protected SamzaSqlFilterRemoteJoinRule(RelOptRuleOperand operand, String id,\n+      boolean smart, RelBuilderFactory relBuilderFactory, Map<String, SqlIOConfig> systemStreamConfigBySource) {\n+    super(operand, relBuilderFactory, \"SamzaSqlFilterRemoteJoinRule:\" + id);\n+    this.smart = smart;\n+    this.systemStreamConfigBySource = systemStreamConfigBySource;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+      Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+\n+    boolean donotOptimizeLeft = false;\n+    boolean donotOptimizeRight = false;\n+\n+    JoinInputNode.InputType inputTypeOnLeft =\n+        JoinInputNode.getInputType(join.getLeft(), systemStreamConfigBySource);\n+    JoinInputNode.InputType inputTypeOnRight =\n+        JoinInputNode.getInputType(join.getRight(), systemStreamConfigBySource);\n+\n+    // Disable this optimnization for queries using local table.\n+    if (inputTypeOnLeft == InputType.LOCAL_TABLE || inputTypeOnRight == InputType.LOCAL_TABLE) {\n+      donotOptimizeLeft = true;\n+      donotOptimizeRight = true;\n+    }\n+\n+    // There is nothing to optimize on the remote table side as the lookup needs to happen first before filtering.\n+    if (inputTypeOnLeft == InputType.REMOTE_TABLE) {\n+      donotOptimizeLeft = true;\n+    }\n+    if (inputTypeOnRight == InputType.REMOTE_TABLE) {\n+      donotOptimizeRight = true;\n+    }\n+\n+    // If there is only the joinRel,\n+    // make sure it does not match a cartesian product joinRel\n+    // (with \"true\" condition), otherwise this rule will be applied\n+    // again on the new cartesian product joinRel.\n+    if (filter == null && joinFilters.isEmpty()) {\n+      return;\n+    }\n+\n+    final List<RexNode> aboveFilters =\n+        filter != null\n+            ? RelOptUtil.conjunctions(filter.getCondition())\n+            : new ArrayList<>();\n+    final com.google.common.collect.ImmutableList<RexNode> origAboveFilters =\n+        com.google.common.collect.ImmutableList.copyOf(aboveFilters);\n+\n+    // Simplify Outer Joins\n+    JoinRelType joinType = join.getJoinType();\n+    if (smart\n+        && !origAboveFilters.isEmpty()\n+        && join.getJoinType() != JoinRelType.INNER) {\n+      joinType = RelOptUtil.simplifyJoin(join, origAboveFilters, joinType);\n+    }\n+\n+    final List<RexNode> leftFilters = new ArrayList<>();\n+    final List<RexNode> rightFilters = new ArrayList<>();\n+\n+    // TODO - add logic to derive additional filters.  E.g., from\n+    // (t1.a = 1 AND t2.a = 2) OR (t1.b = 3 AND t2.b = 4), you can\n+    // derive table filters:\n+    // (t1.a = 1 OR t1.b = 3)\n+    // (t2.a = 2 OR t2.b = 4)\n+\n+    // Try to push down above filters. These are typically where clause\n+    // filters. They can be pushed down if they are not on the NULL\n+    // generating side.\n+    // We do not push into join condition as we do not benefit much. There is also correctness issue\n+    // with remote table as we will not have values for the remote table before the join/lookup.\n+    boolean filterPushed = false;\n+    if (RelOptUtil.classifyFilters(\n+        join,\n+        aboveFilters,\n+        joinType,\n+        false, // Let's not push into join filter\n+        !joinType.generatesNullsOnLeft() && !donotOptimizeLeft,\n+        !joinType.generatesNullsOnRight() && !donotOptimizeRight,\n+        joinFilters,\n+        leftFilters,\n+        rightFilters)) {\n+      filterPushed = true;\n+    }\n+\n+    // If no filter got pushed after validate, reset filterPushed flag\n+    if (leftFilters.isEmpty()\n+        && rightFilters.isEmpty()) {\n+      filterPushed = false;\n+    }\n+\n+    boolean isAntiJoin = joinType == JoinRelType.ANTI;\n+\n+    // Try to push down filters in ON clause. A ON clause filter can only be\n+    // pushed down if it does not affect the non-matching set, i.e. it is\n+    // not on the side which is preserved.\n+    // A ON clause filter of anti-join can not be pushed down.\n+    if (!isAntiJoin && RelOptUtil.classifyFilters(\n+        join,\n+        joinFilters,", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1MjMyNg==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453852326", "bodyText": "Leftfilters and rightFilters are initialized and are not modified. It's very hard to find where they're populated. Please add a comment here that leftFilters and rightFilters will be populated by this classifyFilters method.", "author": "shanthoosh", "createdAt": "2020-07-13T18:37:15Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/SamzaSqlFilterRemoteJoinRule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.samza.sql.planner;\n+\n+import java.util.Map;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.samza.sql.interfaces.SqlIOConfig;\n+import org.apache.samza.sql.translator.JoinInputNode;\n+import org.apache.samza.sql.translator.JoinInputNode.InputType;\n+\n+/**\n+ * Planner rule for remote table joins that pushes filters above and\n+ * within a join node into its children nodes.\n+ * This class is customized form of Calcite's {@link org.apache.calcite.rel.rules.FilterJoinRule} for\n+ * remote table joins.\n+ */\n+public abstract class SamzaSqlFilterRemoteJoinRule extends RelOptRule {\n+  /** Whether to try to strengthen join-type. */\n+  private final boolean smart;\n+\n+  Map<String, SqlIOConfig> systemStreamConfigBySource;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a SamzaSqlFilterRemoteJoinRule with an explicit root operand and\n+   * factories.\n+   */\n+  protected SamzaSqlFilterRemoteJoinRule(RelOptRuleOperand operand, String id,\n+      boolean smart, RelBuilderFactory relBuilderFactory, Map<String, SqlIOConfig> systemStreamConfigBySource) {\n+    super(operand, relBuilderFactory, \"SamzaSqlFilterRemoteJoinRule:\" + id);\n+    this.smart = smart;\n+    this.systemStreamConfigBySource = systemStreamConfigBySource;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+      Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+\n+    boolean donotOptimizeLeft = false;\n+    boolean donotOptimizeRight = false;\n+\n+    JoinInputNode.InputType inputTypeOnLeft =\n+        JoinInputNode.getInputType(join.getLeft(), systemStreamConfigBySource);\n+    JoinInputNode.InputType inputTypeOnRight =\n+        JoinInputNode.getInputType(join.getRight(), systemStreamConfigBySource);\n+\n+    // Disable this optimnization for queries using local table.\n+    if (inputTypeOnLeft == InputType.LOCAL_TABLE || inputTypeOnRight == InputType.LOCAL_TABLE) {\n+      donotOptimizeLeft = true;\n+      donotOptimizeRight = true;\n+    }\n+\n+    // There is nothing to optimize on the remote table side as the lookup needs to happen first before filtering.\n+    if (inputTypeOnLeft == InputType.REMOTE_TABLE) {\n+      donotOptimizeLeft = true;\n+    }\n+    if (inputTypeOnRight == InputType.REMOTE_TABLE) {\n+      donotOptimizeRight = true;\n+    }\n+\n+    // If there is only the joinRel,\n+    // make sure it does not match a cartesian product joinRel\n+    // (with \"true\" condition), otherwise this rule will be applied\n+    // again on the new cartesian product joinRel.\n+    if (filter == null && joinFilters.isEmpty()) {\n+      return;\n+    }\n+\n+    final List<RexNode> aboveFilters =\n+        filter != null\n+            ? RelOptUtil.conjunctions(filter.getCondition())\n+            : new ArrayList<>();\n+    final com.google.common.collect.ImmutableList<RexNode> origAboveFilters =\n+        com.google.common.collect.ImmutableList.copyOf(aboveFilters);\n+\n+    // Simplify Outer Joins\n+    JoinRelType joinType = join.getJoinType();\n+    if (smart\n+        && !origAboveFilters.isEmpty()\n+        && join.getJoinType() != JoinRelType.INNER) {\n+      joinType = RelOptUtil.simplifyJoin(join, origAboveFilters, joinType);\n+    }\n+\n+    final List<RexNode> leftFilters = new ArrayList<>();\n+    final List<RexNode> rightFilters = new ArrayList<>();\n+\n+    // TODO - add logic to derive additional filters.  E.g., from\n+    // (t1.a = 1 AND t2.a = 2) OR (t1.b = 3 AND t2.b = 4), you can\n+    // derive table filters:\n+    // (t1.a = 1 OR t1.b = 3)\n+    // (t2.a = 2 OR t2.b = 4)\n+\n+    // Try to push down above filters. These are typically where clause\n+    // filters. They can be pushed down if they are not on the NULL\n+    // generating side.\n+    // We do not push into join condition as we do not benefit much. There is also correctness issue\n+    // with remote table as we will not have values for the remote table before the join/lookup.\n+    boolean filterPushed = false;\n+    if (RelOptUtil.classifyFilters(\n+        join,\n+        aboveFilters,\n+        joinType,\n+        false, // Let's not push into join filter\n+        !joinType.generatesNullsOnLeft() && !donotOptimizeLeft,\n+        !joinType.generatesNullsOnRight() && !donotOptimizeRight,\n+        joinFilters,\n+        leftFilters,\n+        rightFilters)) {\n+      filterPushed = true;\n+    }\n+\n+    // If no filter got pushed after validate, reset filterPushed flag\n+    if (leftFilters.isEmpty()\n+        && rightFilters.isEmpty()) {\n+      filterPushed = false;\n+    }\n+\n+    boolean isAntiJoin = joinType == JoinRelType.ANTI;\n+\n+    // Try to push down filters in ON clause. A ON clause filter can only be\n+    // pushed down if it does not affect the non-matching set, i.e. it is\n+    // not on the side which is preserved.\n+    // A ON clause filter of anti-join can not be pushed down.\n+    if (!isAntiJoin && RelOptUtil.classifyFilters(\n+        join,\n+        joinFilters,\n+        joinType,\n+        false,\n+        !joinType.generatesNullsOnLeft() && !donotOptimizeLeft,\n+        !joinType.generatesNullsOnRight() && !donotOptimizeRight,\n+        joinFilters,\n+        leftFilters,", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NDkwNw==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453854907", "bodyText": "Please capitalize log messages and remove \\n at the end(which gets added by default).", "author": "shanthoosh", "createdAt": "2020-07-13T18:41:49Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -140,16 +160,48 @@ public RelRoot plan(String query) {\n           .operatorTable(new ChainedSqlOperatorTable(sqlOperatorTables))\n           .sqlToRelConverterConfig(SqlToRelConverter.Config.DEFAULT)\n           .traitDefs(traitDefs)\n-          .context(Contexts.EMPTY_CONTEXT)\n-          .costFactory(null)\n+          .programs(Programs.hep(rules, true, DefaultRelMetadataProvider.INSTANCE))\n           .build();\n-      Planner planner = Frameworks.getPlanner(frameworkConfig);\n+      planner = Frameworks.getPlanner(frameworkConfig);\n+      return planner;\n+    } catch (Exception e) {\n+      String errorMsg = \"Failed to create planner.\";\n+      LOG.error(errorMsg, e);\n+      if (planner != null) {\n+        planner.close();\n+      }\n+      throw new SamzaException(errorMsg, e);\n+    }\n+  }\n \n+  private RelRoot optimize(Planner planner, RelRoot relRoot) {\n+    RelTraitSet relTraitSet = RelTraitSet.createEmpty();\n+    try {\n+      RelRoot optimizedRelRoot =\n+          RelRoot.of(planner.transform(0, relTraitSet, relRoot.project()), SqlKind.SELECT);\n+      LOG.info(\"query plan with optimization:\\n\"\n+          + RelOptUtil.toString(optimizedRelRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES));\n+      return optimizedRelRoot;\n+    } catch (Exception e) {\n+      String errorMsg =\n+          \"Error while optimizing query plan:\\n\" + RelOptUtil.toString(relRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n+      LOG.error(errorMsg, e);\n+      planner.close();\n+      throw new SamzaException(errorMsg, e);\n+    }\n+  }\n+\n+  public RelRoot plan(String query) {\n+    try (Planner planner = getPlanner()) {\n       SqlNode sql = planner.parse(query);\n       SqlNode validatedSql = planner.validate(sql);\n       RelRoot relRoot = planner.rel(validatedSql);\n-      LOG.info(\"query plan:\\n\" + RelOptUtil.toString(relRoot.rel, SqlExplainLevel.ALL_ATTRIBUTES));\n-      return relRoot;\n+      LOG.info(\n+          \"query plan without optimization:\\n\" + RelOptUtil.toString(relRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES));", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMjk3OA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r456932978", "bodyText": "Responded in earlier comment.", "author": "atoomula", "createdAt": "2020-07-19T17:19:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1NDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1Nzc1Mw==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453857753", "bodyText": "Calling close() here seems unnecessary, It's already closed at the caller already with try-with-resources-closeable.", "author": "shanthoosh", "createdAt": "2020-07-13T18:46:43Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -140,16 +160,48 @@ public RelRoot plan(String query) {\n           .operatorTable(new ChainedSqlOperatorTable(sqlOperatorTables))\n           .sqlToRelConverterConfig(SqlToRelConverter.Config.DEFAULT)\n           .traitDefs(traitDefs)\n-          .context(Contexts.EMPTY_CONTEXT)\n-          .costFactory(null)\n+          .programs(Programs.hep(rules, true, DefaultRelMetadataProvider.INSTANCE))\n           .build();\n-      Planner planner = Frameworks.getPlanner(frameworkConfig);\n+      planner = Frameworks.getPlanner(frameworkConfig);\n+      return planner;\n+    } catch (Exception e) {\n+      String errorMsg = \"Failed to create planner.\";\n+      LOG.error(errorMsg, e);\n+      if (planner != null) {\n+        planner.close();\n+      }\n+      throw new SamzaException(errorMsg, e);\n+    }\n+  }\n \n+  private RelRoot optimize(Planner planner, RelRoot relRoot) {\n+    RelTraitSet relTraitSet = RelTraitSet.createEmpty();\n+    try {\n+      RelRoot optimizedRelRoot =\n+          RelRoot.of(planner.transform(0, relTraitSet, relRoot.project()), SqlKind.SELECT);\n+      LOG.info(\"query plan with optimization:\\n\"\n+          + RelOptUtil.toString(optimizedRelRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES));\n+      return optimizedRelRoot;\n+    } catch (Exception e) {\n+      String errorMsg =\n+          \"Error while optimizing query plan:\\n\" + RelOptUtil.toString(relRoot.rel, SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n+      LOG.error(errorMsg, e);\n+      planner.close();", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMzE4Mw==", "url": "https://github.com/apache/samza/pull/1384#discussion_r456933183", "bodyText": "oh yeah.. good point!", "author": "atoomula", "createdAt": "2020-07-19T17:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1Nzc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODU0OA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453858548", "bodyText": "Is there a way to determine if these rel-rules are applied on a rel-plan and emit a metric(or log it before/after the optimization) for debugging purposes.", "author": "shanthoosh", "createdAt": "2020-07-13T18:47:58Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/QueryPlanner.java", "diffHunk": "@@ -129,6 +142,13 @@ public RelRoot plan(String query) {\n       sqlOperatorTables.add(new SamzaSqlOperatorTable());\n       sqlOperatorTables.add(new SamzaSqlUdfOperatorTable(samzaSqlFunctions));\n \n+      // TODO: Introduce a pluggable rule factory.\n+      List<RelOptRule> rules = ImmutableList.of(", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMzM4MA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r456933380", "bodyText": "AFAIK, only Hex/VolcanoPlanners make such decisions. Not sure if we can determine that in the rule itself.", "author": "atoomula", "createdAt": "2020-07-19T17:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2MTE1MA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r453861150", "bodyText": "Just curious. There seems to be considerable duplication with FilterJoinRule calcite native-class. Post CALCITE-3170, calcite supports anti-join on conditions push-down natively. If we upgrade to 1.21.0 rel-planner, then wouldn't overriding match suffice here?", "author": "shanthoosh", "createdAt": "2020-07-13T18:52:35Z", "path": "samza-sql/src/main/java/org/apache/samza/sql/planner/SamzaSqlFilterRemoteJoinRule.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.samza.sql.planner;\n+\n+import java.util.Map;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.samza.sql.interfaces.SqlIOConfig;\n+import org.apache.samza.sql.translator.JoinInputNode;\n+import org.apache.samza.sql.translator.JoinInputNode.InputType;\n+\n+/**\n+ * Planner rule for remote table joins that pushes filters above and\n+ * within a join node into its children nodes.\n+ * This class is customized form of Calcite's {@link org.apache.calcite.rel.rules.FilterJoinRule} for\n+ * remote table joins.\n+ */\n+public abstract class SamzaSqlFilterRemoteJoinRule extends RelOptRule {", "originalCommit": "1642990a74d740ff7e464b2dd3fec9ea3c6bdd34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMzY0OA==", "url": "https://github.com/apache/samza/pull/1384#discussion_r456933648", "bodyText": "Are you talking about just anti-joins or in general about this rule ? If latter, Slim has a comment on this as well and I responded to him. I will have add another rule for join condition which reuses the same logic. Let me see at that time if I can inherit from Calcite rule and just override match.", "author": "atoomula", "createdAt": "2020-07-19T17:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg2MTE1MA=="}], "type": "inlineReview"}, {"oid": "e46ca37d3039c9b4d31c6b5040ce6ff51c8c8922", "url": "https://github.com/apache/samza/commit/e46ca37d3039c9b4d31c6b5040ce6ff51c8c8922", "message": "SAMZA-2549 - Samza-sql: Add query optimizations for remote table joins", "committedDate": "2020-07-19T17:26:22Z", "type": "commit"}]}