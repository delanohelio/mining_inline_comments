{"pr_number": 252, "pr_title": "Enable CancellationToken support and Split Storage client to Sync and Async.", "pr_createdAt": "2020-07-07T01:49:14Z", "pr_url": "https://github.com/Azure/azure-sdk-for-android/pull/252", "timeline": [{"oid": "4b1a7ed9e2390fefa93a3a7dbf634b2a80b252e9", "url": "https://github.com/Azure/azure-sdk-for-android/commit/4b1a7ed9e2390fefa93a3a7dbf634b2a80b252e9", "message": "Adding CancellationToken type.", "committedDate": "2020-07-07T01:41:32Z", "type": "commit"}, {"oid": "a99e2badb246fe11628de31c430f4a4362e5d429", "url": "https://github.com/Azure/azure-sdk-for-android/commit/a99e2badb246fe11628de31c430f4a4362e5d429", "message": "Enable CancellationToken param in StorageClient APIs.", "committedDate": "2020-07-07T01:45:01Z", "type": "commit"}, {"oid": "03957e41b3a976b3e64a5429339b24dbe88b7d5f", "url": "https://github.com/Azure/azure-sdk-for-android/commit/03957e41b3a976b3e64a5429339b24dbe88b7d5f", "message": "Updating Download|Upload Handlers to use CancellationToken APIs", "committedDate": "2020-07-07T01:45:40Z", "type": "commit"}, {"oid": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "url": "https://github.com/Azure/azure-sdk-for-android/commit/e56243ce565f712c5c462f3b4ad333bf63e311ef", "message": "Updating sample and test to use updated storage APIs.", "committedDate": "2020-07-07T01:46:20Z", "type": "commit"}, {"oid": "3f4b449c199154fdb6a408470ace58d49a64a9ed", "url": "https://github.com/Azure/azure-sdk-for-android/commit/3f4b449c199154fdb6a408470ace58d49a64a9ed", "message": "Renaming StorageBlobClient to StorageBlobAsyncClient (next step: extract sync client).", "committedDate": "2020-07-07T04:38:18Z", "type": "commit"}, {"oid": "0dd60b67b7c4e500e5b5b4030883de5da6c274e6", "url": "https://github.com/Azure/azure-sdk-for-android/commit/0dd60b67b7c4e500e5b5b4030883de5da6c274e6", "message": "Sync client: StorageBlobClient.", "committedDate": "2020-07-07T05:33:14Z", "type": "commit"}, {"oid": "13458470149bf4b73ce04ab1ec1227931f5a7d14", "url": "https://github.com/Azure/azure-sdk-for-android/commit/13458470149bf4b73ce04ab1ec1227931f5a7d14", "message": "Cleaning up AsyncClient (removing sync methods those exists in StorageBlobClient)", "committedDate": "2020-07-07T05:35:52Z", "type": "commit"}, {"oid": "ab6e9b33ffdd892f7bd6d2ed1c50091c6a87ebee", "url": "https://github.com/Azure/azure-sdk-for-android/commit/ab6e9b33ffdd892f7bd6d2ed1c50091c6a87ebee", "message": "Updating storage tests to use sync client as well.", "committedDate": "2020-07-07T05:36:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxOTQ3Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450619473", "bodyText": "I wonder what the use of CountDownLatch here is? Were tests failing otherwise? Additionally, for extremely quick operations like these tests, would customers need to use such a mechanism as well?", "author": "vcolin7", "createdAt": "2020-07-07T05:29:58Z", "path": "sdk/storage/azure-storage-blob/src/test/java/com/azure/android/storage/blob/StorageBlobClientTest.java", "diffHunk": "@@ -103,27 +103,35 @@ public void getBlobsInPage_withCallback() {\n \n         mockWebServer.enqueue(mockResponse);\n \n-        ServiceCall serviceCall = storageBlobClient.getBlobsInPage(null,\n+        CountDownLatch latch = new CountDownLatch(1);", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3MTEzMw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450971133", "bodyText": "Tests were not failing, but there is a possibility of \"synchronous\" test methods exit before the \"async API call\" it makes completes, this is because, the test method and callbacks execute in different threads, for\ncorrectness, we need some way to synchronize these two threads; the count-latch is used to make the sync test method wait until async API completes.", "author": "anuchandy", "createdAt": "2020-07-07T15:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxOTQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3MTQ0NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450971444", "bodyText": "Apps (customers) don\u2019t have to use this unless they mix its sync logic with our async API, but in that case, we\u2019ve sync client.", "author": "anuchandy", "createdAt": "2020-07-07T15:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYxOTQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMDA3MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450620070", "bodyText": "This will only be relevant once (and if) we decide to go with this proposal and merge these changes, but if i recall correctly for using the Apache license we need to give proper credit to the author of the content this is based on and a link to the content itself.", "author": "vcolin7", "createdAt": "2020-07-07T05:31:54Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3MTc0MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450971740", "bodyText": "Thanks for sharing the details, I\u2019ll make sure to add explicit links.", "author": "anuchandy", "createdAt": "2020-07-07T15:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMDk3OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450620979", "bodyText": "Just curious: What does CAS stand for?", "author": "vcolin7", "createdAt": "2020-07-07T05:35:36Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3MjE2NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450972165", "bodyText": "It stands for Compare And Swap; it is used to build non-blocking logic (i.e., avoid using lock/synchronized keyword).", "author": "anuchandy", "createdAt": "2020-07-07T15:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMDk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMjI4Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450622283", "bodyText": "I just learned about this annotation. Maybe we could consider using this across our libraries instead of an implementation directory for all the classes we want to mark as internal but need to be public?", "author": "vcolin7", "createdAt": "2020-07-07T05:40:32Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3MjgyOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450972829", "bodyText": "This annotation won't be detected by standard the maven JavaDoc plugin, but good thing is - Android studio gave a warning if app tries to use such annotated methods.", "author": "anuchandy", "createdAt": "2020-07-07T15:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyMjI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNDI3OA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450624278", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    static final OnCancelNode FREEZED = new OnCancelNode(null);\n          \n          \n            \n                    static final OnCancelNode FROZEN = new OnCancelNode(null);", "author": "vcolin7", "createdAt": "2020-07-07T05:47:29Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race in registering Callback.\n+     *\n+     * @param id The registration id for the onCancel Callback.\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull String id, @NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(id, onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Unregister the onCancel Callback.\n+     *\n+     * This operation of unregistering the CallBack is non-blocking and thread-safe.\n+     *\n+     * @param id The id of the onCancel Callback to unregister.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void unregisterOnCancel(@NonNull String id) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode itr = this.onCancelNodes;\n+        // Step_1: Locate the node and mark it as logically deleted.\n+        //\n+        while (itr != null) {\n+            if (this.onCancelNodes == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in progressing.\n+                return;\n+            }\n+            if (itr.id != null && itr.id.equals(id)) {\n+                // Mark the node as logically deleted.\n+                itr.markDeleted();\n+                break;\n+            }\n+        }\n+        if (itr == null) {\n+            // A node with id was not found.\n+            return;\n+        }\n+\n+        // Step_2: Sweep to unlink all logically deleted nodes.\n+        //\n+        boolean hadRace;\n+        do {\n+            // Outer 'do-while' to retry on any race during sweep.\n+            hadRace = false;\n+            OnCancelNode predecessor = null;\n+            OnCancelNode current = this.onCancelNodes; // re-fetch the volatile head for each retry.\n+            if (current == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in sweeping.\n+                return;\n+            }\n+            OnCancelNode successor;\n+            // Inner 'while' to sweep & unlink all logically deleted nodes.\n+            while (current != null) {\n+                successor = current.next;\n+                if (current.isDeleted()) {\n+                    // Un-linking 'current' node.\n+                    if (predecessor == null) {\n+                        // The 'current' node has no 'predecessor' hence it's head, try CAS head with 'successor'.\n+                        if (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, current, successor)) {\n+                            // Raced with\n+                            //     1. another thread calling registerOnCancelCallback.\n+                            //     2. OR the 'cancel()' call.\n+                            // need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    } else {\n+                        // The 'current' node has a 'predecessor'.\n+                        predecessor.next = successor;\n+                        if (predecessor.isDeleted()) {\n+                            // Raced with another thread that unlinked 'predecessor', need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    // We aren't un-linking 'current' node, update 'predecessor'.\n+                    predecessor = current;\n+                }\n+                current = successor;\n+            }\n+        } while (hadRace);\n+    }\n+\n+    /**\n+     * Try to atomically add an onCancel node to the list.\n+     *\n+     * @param newNode The node holding onCancel Callback.\n+     *\n+     * @return false if the list got frozen hence onCancel Callback node is\n+     * not added to the list, true otherwise.\n+     */\n+    private boolean tryAddOnCancelNode(OnCancelNode newNode) {\n+        //fetch the head pointing to the callback list.\n+        OnCancelNode headNode = this.onCancelNodes;\n+        if (headNode == OnCancelNode.FREEZED) {\n+            return false;\n+        }\n+        // busy-loop to atomically insert the new node to the list.\n+        do {\n+            newNode.next = headNode;\n+            // insert the new node to the list by making it the head and it's next\n+            // referencing to the old list.\n+            // Do this only if the head was not updated since last fetch, it is possible\n+            // that another thread added a new node in mean time, in that case, this thread's\n+            // local reference, headNode, to the head is outdated.\n+            if (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, headNode, newNode)) {\n+                // head was changed since last fetched, re-fetch.\n+                headNode = this.onCancelNodes;\n+            } else {\n+                // able to insert the new node (hence the head update) so return.\n+                return true;\n+            }\n+        } while (headNode != OnCancelNode.FREEZED);\n+\n+        // if the busy-loop detect that the list got frozen then it won't add\n+        // the callback to the list. This happens if the token is already cancelled.\n+        return false;\n+    }\n+\n+    /**\n+     * Atomically mark the onCancel Callback list as frozen.\n+     *\n+     * @return The reference to the head of the onCancel Callback list.\n+     */\n+    private OnCancelNode freezeCallbackNodes() {\n+        OnCancelNode headNode;\n+        // busy-loop for atomic freezing of the list.\n+        do {\n+            headNode = this.onCancelNodes;\n+        } while (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, headNode, OnCancelNode.FREEZED));\n+\n+        return headNode;\n+    }\n+\n+    /**\n+     * Atomically mark the onCancel Callback list as frozen and get the Callbacks\n+     * in the order those were added through {@link this#registerOnCancel(Runnable)}.\n+     *\n+     * @return The reference to the onCancel Callback list.\n+     */\n+    private OnCancelNode freezeAndGetCallbackNodes() {\n+        OnCancelNode current = this.freezeCallbackNodes();\n+        // The list has to be reversed since the onCancel callback needs to be\n+        // called in the order that they were originally added.\n+        OnCancelNode reversed = null;\n+        while (current != null) {\n+            OnCancelNode tmp = current;\n+            current = current.next;\n+            tmp.next = reversed;\n+            reversed = tmp;\n+        }\n+        return reversed;\n+    }\n+\n+    /**\n+     * Execute all the onCancel Callbacks in the order they were added through\n+     * {@link this#registerOnCancel(Runnable)}.\n+     */\n+    private void invokeCallbacks() {\n+        OnCancelNode next = this.freezeAndGetCallbackNodes();\n+        while (next != null) {\n+            next.invokeOnCancel();\n+            next = next.next;\n+        }\n+    }\n+\n+    /**\n+     * Represents a node in the OnCancel Callback list.\n+     */\n+    private static final class OnCancelNode {\n+        // a node to indicate that the list is frozen hence no more\n+        // node can be added to the list.\n+        static final OnCancelNode FREEZED = new OnCancelNode(null);", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNDM1MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450624351", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (this.onCancelNodes == OnCancelNode.FREEZED) {\n          \n          \n            \n                        if (this.onCancelNodes == OnCancelNode.FROZEN) {", "author": "vcolin7", "createdAt": "2020-07-07T05:47:47Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race in registering Callback.\n+     *\n+     * @param id The registration id for the onCancel Callback.\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull String id, @NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(id, onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Unregister the onCancel Callback.\n+     *\n+     * This operation of unregistering the CallBack is non-blocking and thread-safe.\n+     *\n+     * @param id The id of the onCancel Callback to unregister.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void unregisterOnCancel(@NonNull String id) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode itr = this.onCancelNodes;\n+        // Step_1: Locate the node and mark it as logically deleted.\n+        //\n+        while (itr != null) {\n+            if (this.onCancelNodes == OnCancelNode.FREEZED) {", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNDQwMA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450624400", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (current == OnCancelNode.FREEZED) {\n          \n          \n            \n                        if (current == OnCancelNode.FROZEN) {", "author": "vcolin7", "createdAt": "2020-07-07T05:47:58Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race in registering Callback.\n+     *\n+     * @param id The registration id for the onCancel Callback.\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull String id, @NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(id, onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Unregister the onCancel Callback.\n+     *\n+     * This operation of unregistering the CallBack is non-blocking and thread-safe.\n+     *\n+     * @param id The id of the onCancel Callback to unregister.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void unregisterOnCancel(@NonNull String id) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode itr = this.onCancelNodes;\n+        // Step_1: Locate the node and mark it as logically deleted.\n+        //\n+        while (itr != null) {\n+            if (this.onCancelNodes == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in progressing.\n+                return;\n+            }\n+            if (itr.id != null && itr.id.equals(id)) {\n+                // Mark the node as logically deleted.\n+                itr.markDeleted();\n+                break;\n+            }\n+        }\n+        if (itr == null) {\n+            // A node with id was not found.\n+            return;\n+        }\n+\n+        // Step_2: Sweep to unlink all logically deleted nodes.\n+        //\n+        boolean hadRace;\n+        do {\n+            // Outer 'do-while' to retry on any race during sweep.\n+            hadRace = false;\n+            OnCancelNode predecessor = null;\n+            OnCancelNode current = this.onCancelNodes; // re-fetch the volatile head for each retry.\n+            if (current == OnCancelNode.FREEZED) {", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNDQ4MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450624481", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (headNode == OnCancelNode.FREEZED) {\n          \n          \n            \n                    if (headNode == OnCancelNode.FROZEN) {", "author": "vcolin7", "createdAt": "2020-07-07T05:48:15Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race in registering Callback.\n+     *\n+     * @param id The registration id for the onCancel Callback.\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull String id, @NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(id, onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Unregister the onCancel Callback.\n+     *\n+     * This operation of unregistering the CallBack is non-blocking and thread-safe.\n+     *\n+     * @param id The id of the onCancel Callback to unregister.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void unregisterOnCancel(@NonNull String id) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode itr = this.onCancelNodes;\n+        // Step_1: Locate the node and mark it as logically deleted.\n+        //\n+        while (itr != null) {\n+            if (this.onCancelNodes == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in progressing.\n+                return;\n+            }\n+            if (itr.id != null && itr.id.equals(id)) {\n+                // Mark the node as logically deleted.\n+                itr.markDeleted();\n+                break;\n+            }\n+        }\n+        if (itr == null) {\n+            // A node with id was not found.\n+            return;\n+        }\n+\n+        // Step_2: Sweep to unlink all logically deleted nodes.\n+        //\n+        boolean hadRace;\n+        do {\n+            // Outer 'do-while' to retry on any race during sweep.\n+            hadRace = false;\n+            OnCancelNode predecessor = null;\n+            OnCancelNode current = this.onCancelNodes; // re-fetch the volatile head for each retry.\n+            if (current == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in sweeping.\n+                return;\n+            }\n+            OnCancelNode successor;\n+            // Inner 'while' to sweep & unlink all logically deleted nodes.\n+            while (current != null) {\n+                successor = current.next;\n+                if (current.isDeleted()) {\n+                    // Un-linking 'current' node.\n+                    if (predecessor == null) {\n+                        // The 'current' node has no 'predecessor' hence it's head, try CAS head with 'successor'.\n+                        if (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, current, successor)) {\n+                            // Raced with\n+                            //     1. another thread calling registerOnCancelCallback.\n+                            //     2. OR the 'cancel()' call.\n+                            // need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    } else {\n+                        // The 'current' node has a 'predecessor'.\n+                        predecessor.next = successor;\n+                        if (predecessor.isDeleted()) {\n+                            // Raced with another thread that unlinked 'predecessor', need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    // We aren't un-linking 'current' node, update 'predecessor'.\n+                    predecessor = current;\n+                }\n+                current = successor;\n+            }\n+        } while (hadRace);\n+    }\n+\n+    /**\n+     * Try to atomically add an onCancel node to the list.\n+     *\n+     * @param newNode The node holding onCancel Callback.\n+     *\n+     * @return false if the list got frozen hence onCancel Callback node is\n+     * not added to the list, true otherwise.\n+     */\n+    private boolean tryAddOnCancelNode(OnCancelNode newNode) {\n+        //fetch the head pointing to the callback list.\n+        OnCancelNode headNode = this.onCancelNodes;\n+        if (headNode == OnCancelNode.FREEZED) {", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNDU0MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450624540", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } while (headNode != OnCancelNode.FREEZED);\n          \n          \n            \n                    } while (headNode != OnCancelNode.FROZEN);", "author": "vcolin7", "createdAt": "2020-07-07T05:48:25Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race in registering Callback.\n+     *\n+     * @param id The registration id for the onCancel Callback.\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull String id, @NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(id, onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Unregister the onCancel Callback.\n+     *\n+     * This operation of unregistering the CallBack is non-blocking and thread-safe.\n+     *\n+     * @param id The id of the onCancel Callback to unregister.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void unregisterOnCancel(@NonNull String id) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode itr = this.onCancelNodes;\n+        // Step_1: Locate the node and mark it as logically deleted.\n+        //\n+        while (itr != null) {\n+            if (this.onCancelNodes == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in progressing.\n+                return;\n+            }\n+            if (itr.id != null && itr.id.equals(id)) {\n+                // Mark the node as logically deleted.\n+                itr.markDeleted();\n+                break;\n+            }\n+        }\n+        if (itr == null) {\n+            // A node with id was not found.\n+            return;\n+        }\n+\n+        // Step_2: Sweep to unlink all logically deleted nodes.\n+        //\n+        boolean hadRace;\n+        do {\n+            // Outer 'do-while' to retry on any race during sweep.\n+            hadRace = false;\n+            OnCancelNode predecessor = null;\n+            OnCancelNode current = this.onCancelNodes; // re-fetch the volatile head for each retry.\n+            if (current == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in sweeping.\n+                return;\n+            }\n+            OnCancelNode successor;\n+            // Inner 'while' to sweep & unlink all logically deleted nodes.\n+            while (current != null) {\n+                successor = current.next;\n+                if (current.isDeleted()) {\n+                    // Un-linking 'current' node.\n+                    if (predecessor == null) {\n+                        // The 'current' node has no 'predecessor' hence it's head, try CAS head with 'successor'.\n+                        if (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, current, successor)) {\n+                            // Raced with\n+                            //     1. another thread calling registerOnCancelCallback.\n+                            //     2. OR the 'cancel()' call.\n+                            // need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    } else {\n+                        // The 'current' node has a 'predecessor'.\n+                        predecessor.next = successor;\n+                        if (predecessor.isDeleted()) {\n+                            // Raced with another thread that unlinked 'predecessor', need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    // We aren't un-linking 'current' node, update 'predecessor'.\n+                    predecessor = current;\n+                }\n+                current = successor;\n+            }\n+        } while (hadRace);\n+    }\n+\n+    /**\n+     * Try to atomically add an onCancel node to the list.\n+     *\n+     * @param newNode The node holding onCancel Callback.\n+     *\n+     * @return false if the list got frozen hence onCancel Callback node is\n+     * not added to the list, true otherwise.\n+     */\n+    private boolean tryAddOnCancelNode(OnCancelNode newNode) {\n+        //fetch the head pointing to the callback list.\n+        OnCancelNode headNode = this.onCancelNodes;\n+        if (headNode == OnCancelNode.FREEZED) {\n+            return false;\n+        }\n+        // busy-loop to atomically insert the new node to the list.\n+        do {\n+            newNode.next = headNode;\n+            // insert the new node to the list by making it the head and it's next\n+            // referencing to the old list.\n+            // Do this only if the head was not updated since last fetch, it is possible\n+            // that another thread added a new node in mean time, in that case, this thread's\n+            // local reference, headNode, to the head is outdated.\n+            if (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, headNode, newNode)) {\n+                // head was changed since last fetched, re-fetch.\n+                headNode = this.onCancelNodes;\n+            } else {\n+                // able to insert the new node (hence the head update) so return.\n+                return true;\n+            }\n+        } while (headNode != OnCancelNode.FREEZED);", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYyNDYyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450624627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } while (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, headNode, OnCancelNode.FREEZED));\n          \n          \n            \n                    } while (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, headNode, OnCancelNode.FROZEN));", "author": "vcolin7", "createdAt": "2020-07-07T05:48:39Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race in registering Callback.\n+     *\n+     * @param id The registration id for the onCancel Callback.\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull String id, @NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(id, onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Unregister the onCancel Callback.\n+     *\n+     * This operation of unregistering the CallBack is non-blocking and thread-safe.\n+     *\n+     * @param id The id of the onCancel Callback to unregister.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void unregisterOnCancel(@NonNull String id) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode itr = this.onCancelNodes;\n+        // Step_1: Locate the node and mark it as logically deleted.\n+        //\n+        while (itr != null) {\n+            if (this.onCancelNodes == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in progressing.\n+                return;\n+            }\n+            if (itr.id != null && itr.id.equals(id)) {\n+                // Mark the node as logically deleted.\n+                itr.markDeleted();\n+                break;\n+            }\n+        }\n+        if (itr == null) {\n+            // A node with id was not found.\n+            return;\n+        }\n+\n+        // Step_2: Sweep to unlink all logically deleted nodes.\n+        //\n+        boolean hadRace;\n+        do {\n+            // Outer 'do-while' to retry on any race during sweep.\n+            hadRace = false;\n+            OnCancelNode predecessor = null;\n+            OnCancelNode current = this.onCancelNodes; // re-fetch the volatile head for each retry.\n+            if (current == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in sweeping.\n+                return;\n+            }\n+            OnCancelNode successor;\n+            // Inner 'while' to sweep & unlink all logically deleted nodes.\n+            while (current != null) {\n+                successor = current.next;\n+                if (current.isDeleted()) {\n+                    // Un-linking 'current' node.\n+                    if (predecessor == null) {\n+                        // The 'current' node has no 'predecessor' hence it's head, try CAS head with 'successor'.\n+                        if (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, current, successor)) {\n+                            // Raced with\n+                            //     1. another thread calling registerOnCancelCallback.\n+                            //     2. OR the 'cancel()' call.\n+                            // need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    } else {\n+                        // The 'current' node has a 'predecessor'.\n+                        predecessor.next = successor;\n+                        if (predecessor.isDeleted()) {\n+                            // Raced with another thread that unlinked 'predecessor', need to retry.\n+                            hadRace = true;\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    // We aren't un-linking 'current' node, update 'predecessor'.\n+                    predecessor = current;\n+                }\n+                current = successor;\n+            }\n+        } while (hadRace);\n+    }\n+\n+    /**\n+     * Try to atomically add an onCancel node to the list.\n+     *\n+     * @param newNode The node holding onCancel Callback.\n+     *\n+     * @return false if the list got frozen hence onCancel Callback node is\n+     * not added to the list, true otherwise.\n+     */\n+    private boolean tryAddOnCancelNode(OnCancelNode newNode) {\n+        //fetch the head pointing to the callback list.\n+        OnCancelNode headNode = this.onCancelNodes;\n+        if (headNode == OnCancelNode.FREEZED) {\n+            return false;\n+        }\n+        // busy-loop to atomically insert the new node to the list.\n+        do {\n+            newNode.next = headNode;\n+            // insert the new node to the list by making it the head and it's next\n+            // referencing to the old list.\n+            // Do this only if the head was not updated since last fetch, it is possible\n+            // that another thread added a new node in mean time, in that case, this thread's\n+            // local reference, headNode, to the head is outdated.\n+            if (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, headNode, newNode)) {\n+                // head was changed since last fetched, re-fetch.\n+                headNode = this.onCancelNodes;\n+            } else {\n+                // able to insert the new node (hence the head update) so return.\n+                return true;\n+            }\n+        } while (headNode != OnCancelNode.FREEZED);\n+\n+        // if the busy-loop detect that the list got frozen then it won't add\n+        // the callback to the list. This happens if the token is already cancelled.\n+        return false;\n+    }\n+\n+    /**\n+     * Atomically mark the onCancel Callback list as frozen.\n+     *\n+     * @return The reference to the head of the onCancel Callback list.\n+     */\n+    private OnCancelNode freezeCallbackNodes() {\n+        OnCancelNode headNode;\n+        // busy-loop for atomic freezing of the list.\n+        do {\n+            headNode = this.onCancelNodes;\n+        } while (!ON_CANCEL_NODES_UPDATER.compareAndSet(this, headNode, OnCancelNode.FREEZED));", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMTU2MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450631560", "bodyText": "Since we don't change what itr refers to, maybe we can put this before the while loop just to improve readability :)", "author": "vcolin7", "createdAt": "2020-07-07T06:11:03Z", "path": "sdk/core/azure-core/src/main/java/com/azure/android/core/internal/util/CancellationTokenImpl.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Copyright (C) 2007 The Guava Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+/*\n+ * Portions Copyright (c) Microsoft Corporation\n+ */\n+\n+package com.azure.android.core.internal.util;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RestrictTo;\n+\n+import com.azure.android.core.util.CancellationToken;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+/**\n+ * Internal implementation of {@link CancellationToken}.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+public final class CancellationTokenImpl extends CancellationToken {\n+    // the reference to the head of the OnCancelNode list (each node hold an onCancel Callback).\n+    private volatile OnCancelNode onCancelNodes;\n+    // CAS Updater to update the above OnCancelNode list head field.\n+    private static final AtomicReferenceFieldUpdater<CancellationTokenImpl, OnCancelNode> ON_CANCEL_NODES_UPDATER\n+        = AtomicReferenceFieldUpdater.newUpdater(CancellationTokenImpl.class,  OnCancelNode.class, \"onCancelNodes\");\n+    // Ensures side-effect of app calling cancel() happens only once.\n+    private final AtomicBoolean isCancelled = new AtomicBoolean(false);\n+\n+    @Override\n+    public void cancel() {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        if (this.isCancelled.compareAndSet(false, true)) {\n+            this.invokeCallbacks();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race.\n+     *\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Registers the onCancel Callback that will be called when this CancellationToken is canceled.\n+     *\n+     * This operation of registering the CallBack is non-blocking and thread-safe. If the token\n+     * is already in the cancelled state then the provided CallBack will be immediately executed.\n+     *\n+     * This is O(1) in best case and O(k) in worst, where k is number of concurrent threads in case\n+     * of race in registering Callback.\n+     *\n+     * @param id The registration id for the onCancel Callback.\n+     * @param onCancel The onCancel Callback.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void registerOnCancel(@NonNull String id, @NonNull Runnable onCancel) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode node = new OnCancelNode(id, onCancel);\n+        final boolean added = this.tryAddOnCancelNode(node);\n+        if (!added) {\n+            // Couldn't add since the list was frozen as a result of cancellation,\n+            // invoke this onCancel Callback immediately.\n+            node.invokeOnCancel();\n+        }\n+    }\n+\n+    /**\n+     * Unregister the onCancel Callback.\n+     *\n+     * This operation of unregistering the CallBack is non-blocking and thread-safe.\n+     *\n+     * @param id The id of the onCancel Callback to unregister.\n+     */\n+    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)\n+    public void unregisterOnCancel(@NonNull String id) {\n+        if (this == CancellationToken.NONE) {\n+            return;\n+        }\n+        OnCancelNode itr = this.onCancelNodes;\n+        // Step_1: Locate the node and mark it as logically deleted.\n+        //\n+        while (itr != null) {\n+            if (this.onCancelNodes == OnCancelNode.FREEZED) {\n+                // The token is cancelled, no use in progressing.\n+                return;\n+            }\n+            if (itr.id != null && itr.id.equals(id)) {\n+                // Mark the node as logically deleted.\n+                itr.markDeleted();\n+                break;\n+            }\n+        }\n+        if (itr == null) {", "originalCommit": "e56243ce565f712c5c462f3b4ad333bf63e311ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3MzM0MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r450973341", "bodyText": "actually there was a bug in the code, which I just fixed.", "author": "anuchandy", "createdAt": "2020-07-07T15:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDYzMTU2MA=="}], "type": "inlineReview"}, {"oid": "0bf64151b8f9468c0d3e291cce5bd52db07d1fba", "url": "https://github.com/Azure/azure-sdk-for-android/commit/0bf64151b8f9468c0d3e291cce5bd52db07d1fba", "message": "Rename static var FREEZED to FROZEN\n\nCo-authored-by: vcolin7 <vicolina@microsoft.com>", "committedDate": "2020-07-07T15:47:20Z", "type": "commit"}, {"oid": "092fca922070c1d75ff8e32e058c3ce7e9301f1a", "url": "https://github.com/Azure/azure-sdk-for-android/commit/092fca922070c1d75ff8e32e058c3ce7e9301f1a", "message": "Correcting node lookup logic in unregister OnCancel.", "committedDate": "2020-07-07T15:54:08Z", "type": "commit"}, {"oid": "8c395b27058b935d93592eaaa9359158a66ac3d9", "url": "https://github.com/Azure/azure-sdk-for-android/commit/8c395b27058b935d93592eaaa9359158a66ac3d9", "message": "CancellationToken is optional, hence if null is passed then map it to CancellationToken.NONE", "committedDate": "2020-07-08T22:36:21Z", "type": "commit"}, {"oid": "871f338d6f584e76d60480c4e191e1a84cf1c19c", "url": "https://github.com/Azure/azure-sdk-for-android/commit/871f338d6f584e76d60480c4e191e1a84cf1c19c", "message": "Using the same prefix 'setTransfer' for all transfer specific setters in the builder.", "committedDate": "2020-07-08T22:43:27Z", "type": "commit"}, {"oid": "60f3ceabd32054780ecbf6fb7a390e578e9e75ec", "url": "https://github.com/Azure/azure-sdk-for-android/commit/60f3ceabd32054780ecbf6fb7a390e578e9e75ec", "message": "Documenting more details of callback tracking.", "committedDate": "2020-07-08T22:59:28Z", "type": "commit"}, {"oid": "592c7a89d73312f99c178cd1fa4d39d749a29257", "url": "https://github.com/Azure/azure-sdk-for-android/commit/592c7a89d73312f99c178cd1fa4d39d749a29257", "message": "Merge branch 'dev' of github.com:Azure/azure-sdk-for-android into cancellation-token", "committedDate": "2020-07-08T23:02:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUxOTcyOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452519729", "bodyText": "Nit: The indentation for some of these is off.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void getBlobsInPage(String pageId,\n          \n          \n            \n                                           String containerName,\n          \n          \n            \n                                           ListBlobsOptions options,\n          \n          \n            \n                                           Callback<List<BlobItem>> callback) {\n          \n          \n            \n                void getBlobsInPage(String pageId,\n          \n          \n            \n                                    String containerName,\n          \n          \n            \n                                    ListBlobsOptions options,\n          \n          \n            \n                                    Callback<List<BlobItem>> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:15:00Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -85,26 +86,28 @@\n             options.getMaxResultsPerPage(),\n             options.getDetails().toList(),\n             null,\n-            null);\n+            null,\n+            CancellationToken.NONE);\n \n         return response.getValue().getSegment() == null\n             ? new ArrayList<>(0)\n             : response.getValue().getSegment().getBlobItems();\n     }\n \n-    ServiceCall getBlobsInPage(String pageId,\n+    void getBlobsInPage(String pageId,\n                                String containerName,\n                                ListBlobsOptions options,\n                                Callback<List<BlobItem>> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyMjc0OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452522749", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void getBlobsInPageWithRestResponse(String pageId,\n          \n          \n            \n                                                           String containerName,\n          \n          \n            \n                                                           String prefix,\n          \n          \n            \n                                                           Integer maxResults,\n          \n          \n            \n                                                           List<ListBlobsIncludeItem> include,\n          \n          \n            \n                                                           Integer timeout,\n          \n          \n            \n                                                           String requestId,\n          \n          \n            \n                                                           CancellationToken cancellationToken,\n          \n          \n            \n                void getBlobsInPageWithRestResponse(String pageId,\n          \n          \n            \n                                                    String containerName,\n          \n          \n            \n                                                    String prefix,\n          \n          \n            \n                                                    Integer maxResults,\n          \n          \n            \n                                                    List<ListBlobsIncludeItem> include,\n          \n          \n            \n                                                    Integer timeout,\n          \n          \n            \n                                                    String requestId,\n          \n          \n            \n                                                    CancellationToken cancellationToken,", "author": "vcolin7", "createdAt": "2020-07-09T22:23:14Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -128,24 +131,36 @@ ContainersListBlobFlatSegmentResponse getBlobsInPageWithRestResponse(String page\n                                                                          Integer maxResults,\n                                                                          List<ListBlobsIncludeItem> include,\n                                                                          Integer timeout,\n-                                                                         String requestId) {\n-        return this.getBlobsInPageWithRestResponseIntern(pageId, containerName,\n+                                                                         String requestId,\n+                                                                         CancellationToken cancellationToken) {\n+        cancellationToken = cancellationToken == null ? CancellationToken.NONE : cancellationToken;\n+        CallAndOptionalResult<ContainersListBlobFlatSegmentResponse> callAndOptionalResult =\n+            this.getBlobsInPageWithRestResponseIntern(pageId, containerName,\n             prefix,\n             maxResults,\n             include,\n             timeout,\n             requestId,\n-            null).getResult();\n+            null);\n+\n+        final Call call = callAndOptionalResult.getCall();\n+        ((CancellationTokenImpl) cancellationToken).registerOnCancel(() -> {\n+            call.cancel();\n+        });\n+\n+        return callAndOptionalResult.getResult();\n     }\n \n-    ServiceCall getBlobsInPageWithRestResponse(String pageId,\n+    void getBlobsInPageWithRestResponse(String pageId,\n                                                String containerName,\n                                                String prefix,\n                                                Integer maxResults,\n                                                List<ListBlobsIncludeItem> include,\n                                                Integer timeout,\n                                                String requestId,\n+                                               CancellationToken cancellationToken,", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNTc4Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452525787", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void getBlobProperties(String containerName,\n          \n          \n            \n                                              String blobName,\n          \n          \n            \n                                              Callback<BlobGetPropertiesHeaders> callback) {\n          \n          \n            \n                void getBlobProperties(String containerName,\n          \n          \n            \n                                       String blobName,\n          \n          \n            \n                                       Callback<BlobGetPropertiesHeaders> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:32:10Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -187,17 +206,18 @@ BlobGetPropertiesHeaders getBlobProperties(String containerName,\n      * @param blobName      The blob name.\n      * @param callback      Callback that receives the response.\n      */\n-    ServiceCall getBlobProperties(String containerName,\n+    void getBlobProperties(String containerName,\n                                   String blobName,\n                                   Callback<BlobGetPropertiesHeaders> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNjU3NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452526574", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void getBlobPropertiesWithRestResponse(String containerName,\n          \n          \n            \n                                                              String blobName,\n          \n          \n            \n                                                              String snapshot,\n          \n          \n            \n                                                              Integer timeout,\n          \n          \n            \n                                                              String version,\n          \n          \n            \n                                                              String leaseId,\n          \n          \n            \n                                                              String requestId,\n          \n          \n            \n                                                              CpkInfo cpkInfo,\n          \n          \n            \n                                                              CancellationToken cancellationToken,\n          \n          \n            \n                                                              Callback<BlobGetPropertiesResponse> callback) {\n          \n          \n            \n                void getBlobPropertiesWithRestResponse(String containerName,\n          \n          \n            \n                                                       String blobName,\n          \n          \n            \n                                                       String snapshot,\n          \n          \n            \n                                                       Integer timeout,\n          \n          \n            \n                                                       String version,\n          \n          \n            \n                                                       String leaseId,\n          \n          \n            \n                                                       String requestId,\n          \n          \n            \n                                                       CpkInfo cpkInfo,\n          \n          \n            \n                                                       CancellationToken cancellationToken,\n          \n          \n            \n                                                       Callback<BlobGetPropertiesResponse> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:34:30Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -258,15 +287,17 @@ BlobGetPropertiesResponse getBlobPropertiesWithRestResponse(String containerName\n      * @param cpkInfo       Additional parameters for the operation.\n      * @param callback      Callback that receives the response.\n      */\n-    ServiceCall getBlobPropertiesWithRestResponse(String containerName,\n+    void getBlobPropertiesWithRestResponse(String containerName,\n                                                   String blobName,\n                                                   String snapshot,\n                                                   Integer timeout,\n                                                   String version,\n                                                   String leaseId,\n                                                   String requestId,\n                                                   CpkInfo cpkInfo,\n+                                                  CancellationToken cancellationToken,\n                                                   Callback<BlobGetPropertiesResponse> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNjY1Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452526653", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void download(String containerName,\n          \n          \n            \n                                     String blobName,\n          \n          \n            \n                                     Callback<ResponseBody> callback) {\n          \n          \n            \n                void download(String containerName,\n          \n          \n            \n                              String blobName,\n          \n          \n            \n                              Callback<ResponseBody> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:34:45Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -314,10 +349,10 @@ ResponseBody download(String containerName,\n      * @param blobName      The blob name.\n      * @param callback      Callback that receives the response.\n      */\n-    ServiceCall download(String containerName,\n+    void download(String containerName,\n                          String blobName,\n                          Callback<ResponseBody> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNjgwOA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452526808", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void downloadWithRestResponse(String containerName,\n          \n          \n            \n                                                     String blobName,\n          \n          \n            \n                                                     String snapshot,\n          \n          \n            \n                                                     Integer timeout,\n          \n          \n            \n                void downloadWithRestResponse(String containerName,\n          \n          \n            \n                                              String blobName,\n          \n          \n            \n                                              String snapshot,\n          \n          \n            \n                                              Integer timeout,", "author": "vcolin7", "createdAt": "2020-07-09T22:35:09Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -434,7 +479,7 @@ BlobDownloadResponse downloadWithRestResponse(String containerName,\n      * @param cpkInfo              Additional parameters for the operation.\n      * @param callback             Callback that receives the response.\n      */\n-    ServiceCall downloadWithRestResponse(String containerName,\n+    void downloadWithRestResponse(String containerName,\n                                          String blobName,\n                                          String snapshot,\n                                          Integer timeout,", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNTQ0MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452535440", "bodyText": "I couldn't select the whole thing :(", "author": "vcolin7", "createdAt": "2020-07-09T23:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNjkwOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452526909", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void stageBlock(String containerName,\n          \n          \n            \n                                       String blobName,\n          \n          \n            \n                                       String base64BlockId,\n          \n          \n            \n                                       byte[] blockContent,\n          \n          \n            \n                                       byte[] contentMd5,\n          \n          \n            \n                                       Callback<Void> callback) {\n          \n          \n            \n                void stageBlock(String containerName,\n          \n          \n            \n                                String blobName,\n          \n          \n            \n                                String base64BlockId,\n          \n          \n            \n                                byte[] blockContent,\n          \n          \n            \n                                byte[] contentMd5,\n          \n          \n            \n                                Callback<Void> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:35:27Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -484,16 +534,17 @@ Void stageBlock(String containerName,\n             null,\n             null,\n             null,\n-            null).getValue();\n+            null,\n+            CancellationToken.NONE).getValue();\n     }\n \n-    ServiceCall stageBlock(String containerName,\n+    void stageBlock(String containerName,\n                            String blobName,\n                            String base64BlockId,\n                            byte[] blockContent,\n                            byte[] contentMd5,\n                            Callback<Void> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNjk4NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452526985", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void stageBlockWithRestResponse(String containerName,\n          \n          \n            \n                                                       String blobName,\n          \n          \n            \n                                                       String base64BlockId,\n          \n          \n            \n                                                       byte[] blockContent,\n          \n          \n            \n                void stageBlockWithRestResponse(String containerName,\n          \n          \n            \n                                                String blobName,\n          \n          \n            \n                                                String base64BlockId,\n          \n          \n            \n                                                byte[] blockContent,", "author": "vcolin7", "createdAt": "2020-07-09T22:35:41Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -536,10 +590,17 @@ BlockBlobsStageBlockResponse stageBlockWithRestResponse(String containerName,\n             leaseId,\n             requestId,\n             cpkInfo,\n-            null).getResult();\n+            null);\n+\n+        final Call call = callAndOptionalResult.getCall();\n+        ((CancellationTokenImpl) cancellationToken).registerOnCancel(() -> {\n+            call.cancel();\n+        });\n+\n+        return callAndOptionalResult.getResult();\n     }\n \n-    ServiceCall stageBlockWithRestResponse(String containerName,\n+    void stageBlockWithRestResponse(String containerName,\n                                            String blobName,\n                                            String base64BlockId,\n                                            byte[] blockContent,", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNTY5OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452535699", "bodyText": "I couldn't select the whole thing.", "author": "vcolin7", "createdAt": "2020-07-09T23:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUyNjk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMTgxMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452531812", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void commitBlockList(String containerName,\n          \n          \n            \n                                            String blobName,\n          \n          \n            \n                                            List<String> base64BlockIds,\n          \n          \n            \n                                            boolean overwrite,\n          \n          \n            \n                void commitBlockList(String containerName,\n          \n          \n            \n                                     String blobName,\n          \n          \n            \n                                     List<String> base64BlockIds,\n          \n          \n            \n                                     boolean overwrite,", "author": "vcolin7", "createdAt": "2020-07-09T22:50:53Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -587,12 +653,13 @@ BlockBlobItem commitBlockList(String containerName,\n             requestConditions,\n             null,\n             null,\n-            null);\n+            null,\n+            CancellationToken.NONE);\n \n         return response.getBlockBlobItem();\n     }\n \n-    ServiceCall commitBlockList(String containerName,\n+    void commitBlockList(String containerName,\n                                 String blobName,\n                                 List<String> base64BlockIds,\n                                 boolean overwrite,", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNTgwNQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452535805", "bodyText": "I couldn't select the whole thing.", "author": "vcolin7", "createdAt": "2020-07-09T23:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMTgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMTk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452531941", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void commitBlockListWithRestResponse(String containerName,\n          \n          \n            \n                                                            String blobName,\n          \n          \n            \n                                                            List<String> base64BlockIds,\n          \n          \n            \n                                                            byte[] transactionalContentMD5,\n          \n          \n            \n                void commitBlockListWithRestResponse(String containerName,\n          \n          \n            \n                                                     String blobName,\n          \n          \n            \n                                                     List<String> base64BlockIds,\n          \n          \n            \n                                                     byte[] transactionalContentMD5,", "author": "vcolin7", "createdAt": "2020-07-09T22:51:15Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -652,10 +722,17 @@ BlockBlobsCommitBlockListResponse commitBlockListWithRestResponse(String contain\n             requestId,\n             cpkInfo,\n             tier,\n-            null).getResult();\n+            null);\n+\n+        final Call call = callAndOptionalResult.getCall();\n+        ((CancellationTokenImpl) cancellationToken).registerOnCancel(() -> {\n+            call.cancel();\n+        });\n+\n+        return callAndOptionalResult.getResult();\n     }\n \n-    ServiceCall commitBlockListWithRestResponse(String containerName,\n+    void commitBlockListWithRestResponse(String containerName,\n                                                 String blobName,\n                                                 List<String> base64BlockIds,\n                                                 byte[] transactionalContentMD5,", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNTkxNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452535914", "bodyText": "I couldn't select the whole thing.", "author": "vcolin7", "createdAt": "2020-07-09T23:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMTk5OA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452531998", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void delete(String containerName,\n          \n          \n            \n                                   String blobName,\n          \n          \n            \n                                   Callback<Void> callback) {\n          \n          \n            \n                void delete(String containerName,\n          \n          \n            \n                            String blobName,\n          \n          \n            \n                            Callback<Void> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:51:25Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -716,10 +799,10 @@ Void delete(String containerName,\n      * @param callback      Callback that receives the response.\n      * @return A handle to the service call.\n      */\n-    ServiceCall delete(String containerName,\n+    void delete(String containerName,\n                        String blobName,\n                        Callback<Void> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMjA2NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452532064", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void deleteWithResponse(String containerName,\n          \n          \n            \n                                               String blobName,\n          \n          \n            \n                                               String snapshot,\n          \n          \n            \n                                               Integer timeout,\n          \n          \n            \n                void deleteWithResponse(String containerName,\n          \n          \n            \n                                        String blobName,\n          \n          \n            \n                                        String snapshot,\n          \n          \n            \n                                        Integer timeout,", "author": "vcolin7", "createdAt": "2020-07-09T22:51:36Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -850,7 +943,7 @@ BlobDeleteResponse deleteWithResponse(String containerName,\n      * @param callback          Callback that receives the response.\n      * @return A handle to the service call.\n      */\n-    ServiceCall deleteWithResponse(String containerName,\n+    void deleteWithResponse(String containerName,\n                                    String blobName,\n                                    String snapshot,\n                                    Integer timeout,", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNjE0Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452536142", "bodyText": "I couldn't select the whole thing.", "author": "vcolin7", "createdAt": "2020-07-09T23:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMjA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMjc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452532777", "bodyText": "Nit: The indentation for some of these is off.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void getBlobsInPage(String pageId,\n          \n          \n            \n                                                  String containerName,\n          \n          \n            \n                                                  ListBlobsOptions options,\n          \n          \n            \n                                                  Callback<List<BlobItem>> callback) {\n          \n          \n            \n                public void getBlobsInPage(String pageId,\n          \n          \n            \n                                           String containerName,\n          \n          \n            \n                                           ListBlobsOptions options,\n          \n          \n            \n                                           Callback<List<BlobItem>> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:53:52Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMzAzMw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452533033", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void getBlobsInPageWithRestResponse(String pageId,\n          \n          \n            \n                                                                  String containerName,\n          \n          \n            \n                                                                  String prefix,\n          \n          \n            \n                                                                  Integer maxResults,\n          \n          \n            \n                                                                  List<ListBlobsIncludeItem> include,\n          \n          \n            \n                                                                  Integer timeout,\n          \n          \n            \n                                                                  String requestId,\n          \n          \n            \n                                                                  CancellationToken cancellationToken,\n          \n          \n            \n                                                                  Callback<ContainersListBlobFlatSegmentResponse> callback) {\n          \n          \n            \n                public void getBlobsInPageWithRestResponse(String pageId,\n          \n          \n            \n                                                           String containerName,\n          \n          \n            \n                                                           String prefix,\n          \n          \n            \n                                                           Integer maxResults,\n          \n          \n            \n                                                           List<ListBlobsIncludeItem> include,\n          \n          \n            \n                                                           Integer timeout,\n          \n          \n            \n                                                           String requestId,\n          \n          \n            \n                                                           CancellationToken cancellationToken,\n          \n          \n            \n                                                           Callback<ContainersListBlobFlatSegmentResponse> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:54:40Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMzM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452533391", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void getBlobProperties(String containerName,\n          \n          \n            \n                                                     String blobName,\n          \n          \n            \n                                                     Callback<BlobGetPropertiesHeaders> callback) {\n          \n          \n            \n                public void getBlobProperties(String containerName,\n          \n          \n            \n                                              String blobName,\n          \n          \n            \n                                              Callback<BlobGetPropertiesHeaders> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:55:35Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMzU0Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452533542", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void getBlobPropertiesWithRestResponse(String containerName,\n          \n          \n            \n                                                                     String blobName,\n          \n          \n            \n                                                                     String snapshot,\n          \n          \n            \n                                                                     Integer timeout,\n          \n          \n            \n                                                                     String version,\n          \n          \n            \n                                                                     BlobRequestConditions blobRequestConditions,\n          \n          \n            \n                                                                     String requestId,\n          \n          \n            \n                                                                     CpkInfo cpkInfo,\n          \n          \n            \n                                                                     CancellationToken cancellationToken,\n          \n          \n            \n                                                                     Callback<BlobGetPropertiesResponse> callback) {\n          \n          \n            \n                public void getBlobPropertiesWithRestResponse(String containerName,\n          \n          \n            \n                                                              String blobName,\n          \n          \n            \n                                                              String snapshot,\n          \n          \n            \n                                                              Integer timeout,\n          \n          \n            \n                                                              String version,\n          \n          \n            \n                                                              BlobRequestConditions blobRequestConditions,\n          \n          \n            \n                                                              String requestId,\n          \n          \n            \n                                                              CpkInfo cpkInfo,\n          \n          \n            \n                                                              CancellationToken cancellationToken,\n          \n          \n            \n                                                              Callback<BlobGetPropertiesResponse> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:56:01Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMzc1NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452533755", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void rawDownload(String containerName,\n          \n          \n            \n                                               String blobName,\n          \n          \n            \n                                               Callback<ResponseBody> callback) {\n          \n          \n            \n                public void rawDownload(String containerName,\n          \n          \n            \n                                        String blobName,\n          \n          \n            \n                                        Callback<ResponseBody> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:56:36Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMzg3Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452533877", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void rawDownloadWithRestResponse(String containerName,\n          \n          \n            \n                                                               String blobName,\n          \n          \n            \n                                                               String snapshot,\n          \n          \n            \n                                                               Integer timeout,\n          \n          \n            \n                                                               BlobRange range,\n          \n          \n            \n                                                               BlobRequestConditions blobRequestConditions,\n          \n          \n            \n                                                               Boolean getRangeContentMd5,\n          \n          \n            \n                                                               Boolean getRangeContentCrc64,\n          \n          \n            \n                                                               String version,\n          \n          \n            \n                                                               String requestId,\n          \n          \n            \n                                                               CpkInfo cpkInfo,\n          \n          \n            \n                                                               CancellationToken cancellationToken,\n          \n          \n            \n                                                               Callback<BlobDownloadResponse> callback) {\n          \n          \n            \n                public void rawDownloadWithRestResponse(String containerName,\n          \n          \n            \n                                                        String blobName,\n          \n          \n            \n                                                        String snapshot,\n          \n          \n            \n                                                        Integer timeout,\n          \n          \n            \n                                                        BlobRange range,\n          \n          \n            \n                                                        BlobRequestConditions blobRequestConditions,\n          \n          \n            \n                                                        Boolean getRangeContentMd5,\n          \n          \n            \n                                                        Boolean getRangeContentCrc64,\n          \n          \n            \n                                                        String version,\n          \n          \n            \n                                                        String requestId,\n          \n          \n            \n                                                        CpkInfo cpkInfo,\n          \n          \n            \n                                                        CancellationToken cancellationToken,\n          \n          \n            \n                                                        Callback<BlobDownloadResponse> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:56:58Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {\n+        storageBlobServiceClient.download(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a range of bytes from a blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param range                 Return only the bytes of the blob in the specified range.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely optional.\n+     * @param getRangeContentMd5    When set to true and specified together with the Range, the service returns the\n+     *                              MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param getRangeContentCrc64  When set to true and specified together with the Range, the service returns the\n+     *                              CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void rawDownloadWithRestResponse(String containerName,\n+                                                   String blobName,\n+                                                   String snapshot,\n+                                                   Integer timeout,\n+                                                   BlobRange range,\n+                                                   BlobRequestConditions blobRequestConditions,\n+                                                   Boolean getRangeContentMd5,\n+                                                   Boolean getRangeContentCrc64,\n+                                                   String version,\n+                                                   String requestId,\n+                                                   CpkInfo cpkInfo,\n+                                                   CancellationToken cancellationToken,\n+                                                   Callback<BlobDownloadResponse> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzMzk5MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452533990", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void stageBlock(String containerName,\n          \n          \n            \n                                              String blobName,\n          \n          \n            \n                                              String base64BlockId,\n          \n          \n            \n                                              byte[] blockContent,\n          \n          \n            \n                                              byte[] contentMd5,\n          \n          \n            \n                                              Callback<Void> callback) {\n          \n          \n            \n                public void stageBlock(String containerName,\n          \n          \n            \n                                       String blobName,\n          \n          \n            \n                                       String base64BlockId,\n          \n          \n            \n                                       byte[] blockContent,\n          \n          \n            \n                                       byte[] contentMd5,\n          \n          \n            \n                                       Callback<Void> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:57:18Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {\n+        storageBlobServiceClient.download(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a range of bytes from a blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param range                 Return only the bytes of the blob in the specified range.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely optional.\n+     * @param getRangeContentMd5    When set to true and specified together with the Range, the service returns the\n+     *                              MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param getRangeContentCrc64  When set to true and specified together with the Range, the service returns the\n+     *                              CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void rawDownloadWithRestResponse(String containerName,\n+                                                   String blobName,\n+                                                   String snapshot,\n+                                                   Integer timeout,\n+                                                   BlobRange range,\n+                                                   BlobRequestConditions blobRequestConditions,\n+                                                   Boolean getRangeContentMd5,\n+                                                   Boolean getRangeContentCrc64,\n+                                                   String version,\n+                                                   String requestId,\n+                                                   CpkInfo cpkInfo,\n+                                                   CancellationToken cancellationToken,\n+                                                   Callback<BlobDownloadResponse> callback) {\n+        range = range == null ? new BlobRange(0) : range;\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.downloadWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            range.toHeaderValue(),\n+            blobRequestConditions.getLeaseId(),\n+            getRangeContentMd5,\n+            getRangeContentCrc64,\n+            blobRequestConditions.getIfModifiedSince(),\n+            blobRequestConditions.getIfUnmodifiedSince(),\n+            blobRequestConditions.getIfMatch(),\n+            blobRequestConditions.getIfNoneMatch(),\n+            version,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param base64BlockId A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                      be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                      for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent  The block content in bytes.\n+     * @param contentMd5    The transactional MD5 for the body, to be validated by the service.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void stageBlock(String containerName,\n+                                  String blobName,\n+                                  String base64BlockId,\n+                                  byte[] blockContent,\n+                                  byte[] contentMd5,\n+                                  Callback<Void> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNDEzNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452534134", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void stageBlockWithRestResponse(String containerName,\n          \n          \n            \n                                                              String blobName,\n          \n          \n            \n                                                              String base64BlockId,\n          \n          \n            \n                                                              byte[] blockContent,\n          \n          \n            \n                                                              byte[] contentMd5,\n          \n          \n            \n                                                              byte[] contentCrc64,\n          \n          \n            \n                                                              Integer timeout,\n          \n          \n            \n                                                              String leaseId,\n          \n          \n            \n                                                              String requestId,\n          \n          \n            \n                                                              CpkInfo cpkInfo,\n          \n          \n            \n                                                              CancellationToken cancellationToken,\n          \n          \n            \n                                                              Callback<BlockBlobsStageBlockResponse> callback) {\n          \n          \n            \n                public void stageBlockWithRestResponse(String containerName,\n          \n          \n            \n                                                       String blobName,\n          \n          \n            \n                                                       String base64BlockId,\n          \n          \n            \n                                                       byte[] blockContent,\n          \n          \n            \n                                                       byte[] contentMd5,\n          \n          \n            \n                                                       byte[] contentCrc64,\n          \n          \n            \n                                                       Integer timeout,\n          \n          \n            \n                                                       String leaseId,\n          \n          \n            \n                                                       String requestId,\n          \n          \n            \n                                                       CpkInfo cpkInfo,\n          \n          \n            \n                                                       CancellationToken cancellationToken,\n          \n          \n            \n                                                       Callback<BlockBlobsStageBlockResponse> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:57:45Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {\n+        storageBlobServiceClient.download(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a range of bytes from a blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param range                 Return only the bytes of the blob in the specified range.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely optional.\n+     * @param getRangeContentMd5    When set to true and specified together with the Range, the service returns the\n+     *                              MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param getRangeContentCrc64  When set to true and specified together with the Range, the service returns the\n+     *                              CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void rawDownloadWithRestResponse(String containerName,\n+                                                   String blobName,\n+                                                   String snapshot,\n+                                                   Integer timeout,\n+                                                   BlobRange range,\n+                                                   BlobRequestConditions blobRequestConditions,\n+                                                   Boolean getRangeContentMd5,\n+                                                   Boolean getRangeContentCrc64,\n+                                                   String version,\n+                                                   String requestId,\n+                                                   CpkInfo cpkInfo,\n+                                                   CancellationToken cancellationToken,\n+                                                   Callback<BlobDownloadResponse> callback) {\n+        range = range == null ? new BlobRange(0) : range;\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.downloadWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            range.toHeaderValue(),\n+            blobRequestConditions.getLeaseId(),\n+            getRangeContentMd5,\n+            getRangeContentCrc64,\n+            blobRequestConditions.getIfModifiedSince(),\n+            blobRequestConditions.getIfUnmodifiedSince(),\n+            blobRequestConditions.getIfMatch(),\n+            blobRequestConditions.getIfNoneMatch(),\n+            version,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param base64BlockId A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                      be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                      for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent  The block content in bytes.\n+     * @param contentMd5    The transactional MD5 for the body, to be validated by the service.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void stageBlock(String containerName,\n+                                  String blobName,\n+                                  String base64BlockId,\n+                                  byte[] blockContent,\n+                                  byte[] contentMd5,\n+                                  Callback<Void> callback) {\n+        this.storageBlobServiceClient.stageBlock(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockId     A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                          be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                          for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent      The block content in bytes.\n+     * @param contentMd5        The transactional MD5 for the block content, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the block content, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param leaseId           If specified, the staging only succeeds if the resource's lease is active and matches this ID.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded.\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void stageBlockWithRestResponse(String containerName,\n+                                                  String blobName,\n+                                                  String base64BlockId,\n+                                                  byte[] blockContent,\n+                                                  byte[] contentMd5,\n+                                                  byte[] contentCrc64,\n+                                                  Integer timeout,\n+                                                  String leaseId,\n+                                                  String requestId,\n+                                                  CpkInfo cpkInfo,\n+                                                  CancellationToken cancellationToken,\n+                                                  Callback<BlockBlobsStageBlockResponse> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNDM1OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452534359", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void commitBlockList(String containerName,\n          \n          \n            \n                                                   String blobName,\n          \n          \n            \n                                                   List<String> base64BlockIds,\n          \n          \n            \n                                                   boolean overwrite,\n          \n          \n            \n                                                   Callback<BlockBlobItem> callback) {\n          \n          \n            \n                public void commitBlockList(String containerName,\n          \n          \n            \n                                            String blobName,\n          \n          \n            \n                                            List<String> base64BlockIds,\n          \n          \n            \n                                            boolean overwrite,\n          \n          \n            \n                                            Callback<BlockBlobItem> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:58:27Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {\n+        storageBlobServiceClient.download(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a range of bytes from a blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param range                 Return only the bytes of the blob in the specified range.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely optional.\n+     * @param getRangeContentMd5    When set to true and specified together with the Range, the service returns the\n+     *                              MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param getRangeContentCrc64  When set to true and specified together with the Range, the service returns the\n+     *                              CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void rawDownloadWithRestResponse(String containerName,\n+                                                   String blobName,\n+                                                   String snapshot,\n+                                                   Integer timeout,\n+                                                   BlobRange range,\n+                                                   BlobRequestConditions blobRequestConditions,\n+                                                   Boolean getRangeContentMd5,\n+                                                   Boolean getRangeContentCrc64,\n+                                                   String version,\n+                                                   String requestId,\n+                                                   CpkInfo cpkInfo,\n+                                                   CancellationToken cancellationToken,\n+                                                   Callback<BlobDownloadResponse> callback) {\n+        range = range == null ? new BlobRange(0) : range;\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.downloadWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            range.toHeaderValue(),\n+            blobRequestConditions.getLeaseId(),\n+            getRangeContentMd5,\n+            getRangeContentCrc64,\n+            blobRequestConditions.getIfModifiedSince(),\n+            blobRequestConditions.getIfUnmodifiedSince(),\n+            blobRequestConditions.getIfMatch(),\n+            blobRequestConditions.getIfNoneMatch(),\n+            version,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param base64BlockId A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                      be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                      for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent  The block content in bytes.\n+     * @param contentMd5    The transactional MD5 for the body, to be validated by the service.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void stageBlock(String containerName,\n+                                  String blobName,\n+                                  String base64BlockId,\n+                                  byte[] blockContent,\n+                                  byte[] contentMd5,\n+                                  Callback<Void> callback) {\n+        this.storageBlobServiceClient.stageBlock(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockId     A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                          be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                          for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent      The block content in bytes.\n+     * @param contentMd5        The transactional MD5 for the block content, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the block content, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param leaseId           If specified, the staging only succeeds if the resource's lease is active and matches this ID.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded.\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void stageBlockWithRestResponse(String containerName,\n+                                                  String blobName,\n+                                                  String base64BlockId,\n+                                                  byte[] blockContent,\n+                                                  byte[] contentMd5,\n+                                                  byte[] contentCrc64,\n+                                                  Integer timeout,\n+                                                  String leaseId,\n+                                                  String requestId,\n+                                                  CpkInfo cpkInfo,\n+                                                  CancellationToken cancellationToken,\n+                                                  Callback<BlockBlobsStageBlockResponse> callback) {\n+        this.storageBlobServiceClient.stageBlockWithRestResponse(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            contentCrc64,\n+            timeout,\n+            leaseId,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob.\n+     * For a block to be written as part of a blob, the block must have been successfully written to the server in a prior\n+     * {@link StorageBlobAsyncClient#stageBlock(String, String, String, byte[], byte[], Callback)} operation. You can\n+     * call commit Block List to update a blob by uploading only those blocks that have changed, then committing the new\n+     * and existing blocks together. You can do this by specifying whether to commit a block from the committed block\n+     * list or from the uncommitted block list, or to commit the most recently uploaded version of the block,\n+     * whichever list it may belong to.\n+     *\n+     * @param containerName  The container name.\n+     * @param blobName       The blob name.\n+     * @param base64BlockIds The block IDs.\n+     * @param overwrite      Indicate whether to overwrite the block list if already exists.\n+     * @param callback       Callback that receives the response.\n+     */\n+    public void commitBlockList(String containerName,\n+                                       String blobName,\n+                                       List<String> base64BlockIds,\n+                                       boolean overwrite,\n+                                       Callback<BlockBlobItem> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNDQ3MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452534471", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void commitBlockListWithRestResponse(String containerName,\n          \n          \n            \n                                                                   String blobName,\n          \n          \n            \n                                                                   List<String> base64BlockIds,\n          \n          \n            \n                                                                   byte[] contentMD5,\n          \n          \n            \n                                                                   byte[] contentCrc64,\n          \n          \n            \n                                                                   Integer timeout,\n          \n          \n            \n                                                                   BlobHttpHeaders blobHttpHeaders,\n          \n          \n            \n                                                                   Map<String, String> metadata,\n          \n          \n            \n                                                                   BlobRequestConditions requestConditions,\n          \n          \n            \n                                                                   String requestId,\n          \n          \n            \n                                                                   CpkInfo cpkInfo,\n          \n          \n            \n                                                                   AccessTier tier,\n          \n          \n            \n                                                                   CancellationToken cancellationToken,\n          \n          \n            \n                                                                   Callback<BlockBlobsCommitBlockListResponse> callback) {\n          \n          \n            \n                public void commitBlockListWithRestResponse(String containerName,\n          \n          \n            \n                                                            String blobName,\n          \n          \n            \n                                                            List<String> base64BlockIds,\n          \n          \n            \n                                                            byte[] contentMD5,\n          \n          \n            \n                                                            byte[] contentCrc64,\n          \n          \n            \n                                                            Integer timeout,\n          \n          \n            \n                                                            BlobHttpHeaders blobHttpHeaders,\n          \n          \n            \n                                                            Map<String, String> metadata,\n          \n          \n            \n                                                            BlobRequestConditions requestConditions,\n          \n          \n            \n                                                            String requestId,\n          \n          \n            \n                                                            CpkInfo cpkInfo,\n          \n          \n            \n                                                            AccessTier tier,\n          \n          \n            \n                                                            CancellationToken cancellationToken,\n          \n          \n            \n                                                            Callback<BlockBlobsCommitBlockListResponse> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:58:52Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {\n+        storageBlobServiceClient.download(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a range of bytes from a blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param range                 Return only the bytes of the blob in the specified range.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely optional.\n+     * @param getRangeContentMd5    When set to true and specified together with the Range, the service returns the\n+     *                              MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param getRangeContentCrc64  When set to true and specified together with the Range, the service returns the\n+     *                              CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void rawDownloadWithRestResponse(String containerName,\n+                                                   String blobName,\n+                                                   String snapshot,\n+                                                   Integer timeout,\n+                                                   BlobRange range,\n+                                                   BlobRequestConditions blobRequestConditions,\n+                                                   Boolean getRangeContentMd5,\n+                                                   Boolean getRangeContentCrc64,\n+                                                   String version,\n+                                                   String requestId,\n+                                                   CpkInfo cpkInfo,\n+                                                   CancellationToken cancellationToken,\n+                                                   Callback<BlobDownloadResponse> callback) {\n+        range = range == null ? new BlobRange(0) : range;\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.downloadWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            range.toHeaderValue(),\n+            blobRequestConditions.getLeaseId(),\n+            getRangeContentMd5,\n+            getRangeContentCrc64,\n+            blobRequestConditions.getIfModifiedSince(),\n+            blobRequestConditions.getIfUnmodifiedSince(),\n+            blobRequestConditions.getIfMatch(),\n+            blobRequestConditions.getIfNoneMatch(),\n+            version,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param base64BlockId A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                      be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                      for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent  The block content in bytes.\n+     * @param contentMd5    The transactional MD5 for the body, to be validated by the service.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void stageBlock(String containerName,\n+                                  String blobName,\n+                                  String base64BlockId,\n+                                  byte[] blockContent,\n+                                  byte[] contentMd5,\n+                                  Callback<Void> callback) {\n+        this.storageBlobServiceClient.stageBlock(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockId     A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                          be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                          for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent      The block content in bytes.\n+     * @param contentMd5        The transactional MD5 for the block content, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the block content, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param leaseId           If specified, the staging only succeeds if the resource's lease is active and matches this ID.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded.\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void stageBlockWithRestResponse(String containerName,\n+                                                  String blobName,\n+                                                  String base64BlockId,\n+                                                  byte[] blockContent,\n+                                                  byte[] contentMd5,\n+                                                  byte[] contentCrc64,\n+                                                  Integer timeout,\n+                                                  String leaseId,\n+                                                  String requestId,\n+                                                  CpkInfo cpkInfo,\n+                                                  CancellationToken cancellationToken,\n+                                                  Callback<BlockBlobsStageBlockResponse> callback) {\n+        this.storageBlobServiceClient.stageBlockWithRestResponse(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            contentCrc64,\n+            timeout,\n+            leaseId,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob.\n+     * For a block to be written as part of a blob, the block must have been successfully written to the server in a prior\n+     * {@link StorageBlobAsyncClient#stageBlock(String, String, String, byte[], byte[], Callback)} operation. You can\n+     * call commit Block List to update a blob by uploading only those blocks that have changed, then committing the new\n+     * and existing blocks together. You can do this by specifying whether to commit a block from the committed block\n+     * list or from the uncommitted block list, or to commit the most recently uploaded version of the block,\n+     * whichever list it may belong to.\n+     *\n+     * @param containerName  The container name.\n+     * @param blobName       The blob name.\n+     * @param base64BlockIds The block IDs.\n+     * @param overwrite      Indicate whether to overwrite the block list if already exists.\n+     * @param callback       Callback that receives the response.\n+     */\n+    public void commitBlockList(String containerName,\n+                                       String blobName,\n+                                       List<String> base64BlockIds,\n+                                       boolean overwrite,\n+                                       Callback<BlockBlobItem> callback) {\n+        this.storageBlobServiceClient.commitBlockList(containerName,\n+            blobName,\n+            base64BlockIds,\n+            overwrite,\n+            callback);\n+    }\n+\n+    /**\n+     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob.\n+     * For a block to be written as part of a blob, the block must have been successfully written to the server in a prior\n+     * {@link StorageBlobAsyncClient#stageBlock(String, String, String, byte[], byte[], Callback)} operation. You can call\n+     * commit Block List to update a blob by uploading only those blocks that have changed, then committing the new and existing\n+     * blocks together. You can do this by specifying whether to commit a block from the committed block list or from\n+     * the uncommitted block list, or to commit the most recently uploaded version of the block, whichever list it may belong to.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockIds    The block IDs.\n+     * @param contentMD5        Specify the transactional md5 for the body, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the body, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param blobHttpHeaders   Additional Http headers for this operation.\n+     * @param metadata          Specifies a user-defined name-value pair associated with the blob.\n+     * @param requestConditions {@link BlobRequestConditions}.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param tier              Indicates the tier to be set on the blob.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void commitBlockListWithRestResponse(String containerName,\n+                                                       String blobName,\n+                                                       List<String> base64BlockIds,\n+                                                       byte[] contentMD5,\n+                                                       byte[] contentCrc64,\n+                                                       Integer timeout,\n+                                                       BlobHttpHeaders blobHttpHeaders,\n+                                                       Map<String, String> metadata,\n+                                                       BlobRequestConditions requestConditions,\n+                                                       String requestId,\n+                                                       CpkInfo cpkInfo,\n+                                                       AccessTier tier,\n+                                                       CancellationToken cancellationToken,\n+                                                       Callback<BlockBlobsCommitBlockListResponse> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNDUzNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452534537", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void delete(String containerName,\n          \n          \n            \n                                   String blobName,\n          \n          \n            \n                                   Callback<Void> callback) {\n          \n          \n            \n                void delete(String containerName,\n          \n          \n            \n                            String blobName,\n          \n          \n            \n                            Callback<Void> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:59:07Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {\n+        storageBlobServiceClient.download(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a range of bytes from a blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param range                 Return only the bytes of the blob in the specified range.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely optional.\n+     * @param getRangeContentMd5    When set to true and specified together with the Range, the service returns the\n+     *                              MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param getRangeContentCrc64  When set to true and specified together with the Range, the service returns the\n+     *                              CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void rawDownloadWithRestResponse(String containerName,\n+                                                   String blobName,\n+                                                   String snapshot,\n+                                                   Integer timeout,\n+                                                   BlobRange range,\n+                                                   BlobRequestConditions blobRequestConditions,\n+                                                   Boolean getRangeContentMd5,\n+                                                   Boolean getRangeContentCrc64,\n+                                                   String version,\n+                                                   String requestId,\n+                                                   CpkInfo cpkInfo,\n+                                                   CancellationToken cancellationToken,\n+                                                   Callback<BlobDownloadResponse> callback) {\n+        range = range == null ? new BlobRange(0) : range;\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.downloadWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            range.toHeaderValue(),\n+            blobRequestConditions.getLeaseId(),\n+            getRangeContentMd5,\n+            getRangeContentCrc64,\n+            blobRequestConditions.getIfModifiedSince(),\n+            blobRequestConditions.getIfUnmodifiedSince(),\n+            blobRequestConditions.getIfMatch(),\n+            blobRequestConditions.getIfNoneMatch(),\n+            version,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param base64BlockId A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                      be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                      for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent  The block content in bytes.\n+     * @param contentMd5    The transactional MD5 for the body, to be validated by the service.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void stageBlock(String containerName,\n+                                  String blobName,\n+                                  String base64BlockId,\n+                                  byte[] blockContent,\n+                                  byte[] contentMd5,\n+                                  Callback<Void> callback) {\n+        this.storageBlobServiceClient.stageBlock(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockId     A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                          be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                          for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent      The block content in bytes.\n+     * @param contentMd5        The transactional MD5 for the block content, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the block content, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param leaseId           If specified, the staging only succeeds if the resource's lease is active and matches this ID.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded.\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void stageBlockWithRestResponse(String containerName,\n+                                                  String blobName,\n+                                                  String base64BlockId,\n+                                                  byte[] blockContent,\n+                                                  byte[] contentMd5,\n+                                                  byte[] contentCrc64,\n+                                                  Integer timeout,\n+                                                  String leaseId,\n+                                                  String requestId,\n+                                                  CpkInfo cpkInfo,\n+                                                  CancellationToken cancellationToken,\n+                                                  Callback<BlockBlobsStageBlockResponse> callback) {\n+        this.storageBlobServiceClient.stageBlockWithRestResponse(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            contentCrc64,\n+            timeout,\n+            leaseId,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob.\n+     * For a block to be written as part of a blob, the block must have been successfully written to the server in a prior\n+     * {@link StorageBlobAsyncClient#stageBlock(String, String, String, byte[], byte[], Callback)} operation. You can\n+     * call commit Block List to update a blob by uploading only those blocks that have changed, then committing the new\n+     * and existing blocks together. You can do this by specifying whether to commit a block from the committed block\n+     * list or from the uncommitted block list, or to commit the most recently uploaded version of the block,\n+     * whichever list it may belong to.\n+     *\n+     * @param containerName  The container name.\n+     * @param blobName       The blob name.\n+     * @param base64BlockIds The block IDs.\n+     * @param overwrite      Indicate whether to overwrite the block list if already exists.\n+     * @param callback       Callback that receives the response.\n+     */\n+    public void commitBlockList(String containerName,\n+                                       String blobName,\n+                                       List<String> base64BlockIds,\n+                                       boolean overwrite,\n+                                       Callback<BlockBlobItem> callback) {\n+        this.storageBlobServiceClient.commitBlockList(containerName,\n+            blobName,\n+            base64BlockIds,\n+            overwrite,\n+            callback);\n+    }\n+\n+    /**\n+     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob.\n+     * For a block to be written as part of a blob, the block must have been successfully written to the server in a prior\n+     * {@link StorageBlobAsyncClient#stageBlock(String, String, String, byte[], byte[], Callback)} operation. You can call\n+     * commit Block List to update a blob by uploading only those blocks that have changed, then committing the new and existing\n+     * blocks together. You can do this by specifying whether to commit a block from the committed block list or from\n+     * the uncommitted block list, or to commit the most recently uploaded version of the block, whichever list it may belong to.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockIds    The block IDs.\n+     * @param contentMD5        Specify the transactional md5 for the body, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the body, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param blobHttpHeaders   Additional Http headers for this operation.\n+     * @param metadata          Specifies a user-defined name-value pair associated with the blob.\n+     * @param requestConditions {@link BlobRequestConditions}.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param tier              Indicates the tier to be set on the blob.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void commitBlockListWithRestResponse(String containerName,\n+                                                       String blobName,\n+                                                       List<String> base64BlockIds,\n+                                                       byte[] contentMD5,\n+                                                       byte[] contentCrc64,\n+                                                       Integer timeout,\n+                                                       BlobHttpHeaders blobHttpHeaders,\n+                                                       Map<String, String> metadata,\n+                                                       BlobRequestConditions requestConditions,\n+                                                       String requestId,\n+                                                       CpkInfo cpkInfo,\n+                                                       AccessTier tier,\n+                                                       CancellationToken cancellationToken,\n+                                                       Callback<BlockBlobsCommitBlockListResponse> callback) {\n+        this.storageBlobServiceClient.commitBlockListWithRestResponse(containerName,\n+            blobName,\n+            base64BlockIds,\n+            contentMD5,\n+            contentCrc64,\n+            timeout,\n+            blobHttpHeaders,\n+            metadata,\n+            requestConditions,\n+            requestId,\n+            cpkInfo,\n+            tier,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Deletes the specified blob or snapshot. Note that deleting a blob also deletes all its snapshots.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    void delete(String containerName,\n+                       String blobName,\n+                       Callback<Void> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNDY1Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452534653", "bodyText": "Nit: Indentation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void deleteWithResponse(String containerName,\n          \n          \n            \n                                               String blobName,\n          \n          \n            \n                                               String snapshot,\n          \n          \n            \n                                               Integer timeout,\n          \n          \n            \n                                               String version,\n          \n          \n            \n                                               String leaseId,\n          \n          \n            \n                                               DeleteSnapshotsOptionType deleteSnapshots,\n          \n          \n            \n                                               OffsetDateTime ifModifiedSince,\n          \n          \n            \n                                               OffsetDateTime ifUnmodifiedSince,\n          \n          \n            \n                                               String ifMatch,\n          \n          \n            \n                                               String ifNoneMatch,\n          \n          \n            \n                                               String requestId,\n          \n          \n            \n                                               CancellationToken cancellationToken,\n          \n          \n            \n                                               Callback<BlobDeleteResponse> callback) {\n          \n          \n            \n                void deleteWithResponse(String containerName,\n          \n          \n            \n                                        String blobName,\n          \n          \n            \n                                        String snapshot,\n          \n          \n            \n                                        Integer timeout,\n          \n          \n            \n                                        String version,\n          \n          \n            \n                                        String leaseId,\n          \n          \n            \n                                        DeleteSnapshotsOptionType deleteSnapshots,\n          \n          \n            \n                                        OffsetDateTime ifModifiedSince,\n          \n          \n            \n                                        OffsetDateTime ifUnmodifiedSince,\n          \n          \n            \n                                        String ifMatch,\n          \n          \n            \n                                        String ifNoneMatch,\n          \n          \n            \n                                        String requestId,\n          \n          \n            \n                                        CancellationToken cancellationToken,\n          \n          \n            \n                                        Callback<BlobDeleteResponse> callback) {", "author": "vcolin7", "createdAt": "2020-07-09T22:59:29Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobAsyncClient.java", "diffHunk": "@@ -0,0 +1,871 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob;\n+\n+import android.content.Context;\n+import android.net.Uri;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.RequiresApi;\n+import androidx.lifecycle.LiveData;\n+import androidx.work.Constraints;\n+import androidx.work.NetworkType;\n+\n+import com.azure.android.core.http.Callback;\n+import com.azure.android.core.http.ServiceClient;\n+import com.azure.android.core.http.interceptor.AddDateInterceptor;\n+import com.azure.android.core.internal.util.serializer.SerializerFormat;\n+import com.azure.android.core.util.CancellationToken;\n+import com.azure.android.core.util.CoreUtil;\n+import com.azure.android.storage.blob.models.AccessTier;\n+import com.azure.android.storage.blob.models.BlobDeleteResponse;\n+import com.azure.android.storage.blob.models.BlobDownloadResponse;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesHeaders;\n+import com.azure.android.storage.blob.models.BlobHttpHeaders;\n+import com.azure.android.storage.blob.models.BlobItem;\n+import com.azure.android.storage.blob.models.BlobRange;\n+import com.azure.android.storage.blob.models.BlobRequestConditions;\n+import com.azure.android.storage.blob.models.BlobGetPropertiesResponse;\n+import com.azure.android.storage.blob.models.BlockBlobItem;\n+import com.azure.android.storage.blob.models.BlockBlobsCommitBlockListResponse;\n+import com.azure.android.storage.blob.models.BlockBlobsStageBlockResponse;\n+import com.azure.android.storage.blob.models.ContainersListBlobFlatSegmentResponse;\n+import com.azure.android.storage.blob.models.CpkInfo;\n+import com.azure.android.storage.blob.models.DeleteSnapshotsOptionType;\n+import com.azure.android.storage.blob.models.ListBlobsIncludeItem;\n+import com.azure.android.storage.blob.models.ListBlobsOptions;\n+import com.azure.android.storage.blob.transfer.DownloadRequest;\n+import com.azure.android.storage.blob.transfer.StorageBlobClientMap;\n+import com.azure.android.storage.blob.transfer.TransferClient;\n+import com.azure.android.storage.blob.transfer.TransferInfo;\n+import com.azure.android.storage.blob.transfer.UploadRequest;\n+\n+import org.threeten.bp.OffsetDateTime;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import okhttp3.Interceptor;\n+import okhttp3.ResponseBody;\n+\n+/**\n+ * Client for Storage Blob service.\n+ *\n+ * <p>\n+ * This client is instantiated through {@link StorageBlobAsyncClient.Builder}.\n+ */\n+public class StorageBlobAsyncClient {\n+    private final String id;\n+    private final ServiceClient serviceClient;\n+    private final StorageBlobServiceImpl storageBlobServiceClient;\n+    private final Constraints transferConstraints;\n+\n+    private StorageBlobAsyncClient(String id, ServiceClient serviceClient, Constraints transferConstraints) {\n+        this.id = id;\n+        this.serviceClient = serviceClient;\n+        this.storageBlobServiceClient = new StorageBlobServiceImpl(this.serviceClient);\n+        this.transferConstraints = transferConstraints;\n+    }\n+\n+    /**\n+     * Creates a new {@link Builder} with initial configuration copied from this {@link StorageBlobAsyncClient}.\n+     *\n+     * @param storageBlobClientId The unique ID for the new {@link StorageBlobAsyncClient}. This identifier is used to\n+     *                            associate the {@link StorageBlobAsyncClient} with the upload and download transfers it\n+     *                            initiates. When a transfer is reloaded from disk (e.g. after an application crash),\n+     *                            it can only be resumed once a client with the same storageBlobClientId has been\n+     *                            initialized.\n+     * @return A new {@link Builder}.\n+     */\n+    public StorageBlobAsyncClient.Builder newBuilder(String storageBlobClientId) {\n+        return new Builder(storageBlobClientId, this);\n+    }\n+\n+    /**\n+     * Gets the blob service base URL.\n+     *\n+     * @return The blob service base URL.\n+     */\n+    public String getBlobServiceUrl() {\n+        return this.serviceClient.getBaseUrl();\n+    }\n+\n+    /**\n+     * Upload the content of a file.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param file          The local file to upload.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName, File file) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Upload content identified by a given URI.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to upload the file to.\n+     * @param blobName      The name of the target blob holding the uploaded file.\n+     * @param contentUri    The URI to the Content to upload, the contentUri is resolved using\n+     *                      {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)} with mode as\n+     *                      \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> upload(Context context,\n+                                         String containerName,\n+                                         String blobName,\n+                                         Uri contentUri) {\n+        final UploadRequest request = new UploadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .upload(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param file          The local file to download to.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           File file) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .file(file)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param context       The application context.\n+     * @param containerName The container to download the blob from.\n+     * @param blobName      The name of the target blob to download.\n+     * @param contentUri    The URI to the local content where the downloaded blob will be stored.\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(Context context,\n+                                           String containerName,\n+                                           String blobName,\n+                                           Uri contentUri) {\n+        final DownloadRequest request = new DownloadRequest.Builder()\n+            .storageClientId(this.id)\n+            .containerName(containerName)\n+            .blobName(blobName)\n+            .contentUri(context, contentUri)\n+            .constraints(this.transferConstraints)\n+            .build();\n+        return TransferClient.getInstance(context)\n+            .download(request);\n+    }\n+\n+    /**\n+     * Pause a transfer identified by the given transfer ID. The pause operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the pause, any observer observing on {@link LiveData} for this\n+     * transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#USER_PAUSED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to pause.\n+     */\n+    public void pause(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .pause(transferId);\n+    }\n+\n+    /**\n+     * Resume a paused transfer.\n+     *\n+     * @param context    The application context\n+     * @param transferId The transfer ID identifies the transfer to resume.\n+     * @return A LiveData that streams {@link TransferInfo} describing the current state of the transfer.\n+     */\n+    public LiveData<TransferInfo> resume(Context context, long transferId) {\n+        return TransferClient.getInstance(context)\n+            .resume(transferId);\n+    }\n+\n+    /**\n+     * Cancel a transfer identified by the given transfer ID. The cancel operation is a best-effort, and a transfer\n+     * that is already executing may continue to transfer.\n+     * <p>\n+     * Upon successful scheduling of the cancellation, any observer observing on {@link LiveData} for\n+     * this transfer receives a {@link TransferInfo} event with state {@link TransferInfo.State#CANCELLED}.\n+     *\n+     * @param context    The application context.\n+     * @param transferId The transfer ID identifies the transfer to cancel.\n+     */\n+    public void cancel(Context context, long transferId) {\n+        TransferClient.getInstance(context)\n+            .cancel(transferId);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId        Identifies the portion of the list to be returned.\n+     * @param containerName The container name.\n+     * @param options       The page options.\n+     * @param callback      Callback that receives the retrieved blob list.\n+     */\n+    public void getBlobsInPage(String pageId,\n+                                      String containerName,\n+                                      ListBlobsOptions options,\n+                                      Callback<List<BlobItem>> callback) {\n+        this.storageBlobServiceClient.getBlobsInPage(pageId,\n+            containerName,\n+            options,\n+            callback);\n+    }\n+\n+    /**\n+     * Gets a list of blobs identified by a page id in a given container.\n+     *\n+     * @param pageId            Identifies the portion of the list to be returned.\n+     * @param containerName     The container name.\n+     * @param prefix            Filters the results to return only blobs whose name begins with the specified prefix.\n+     * @param maxResults        Specifies the maximum number of blobs to return.\n+     * @param include           Include this parameter to specify one or more datasets to include in the response.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded in\n+     *                          the analytics logs when storage analytics logging is enabled.\n+     * @param callback          Callback that receives the response.\n+     * @param cancellationToken The token to request cancellation.\n+     */\n+    public void getBlobsInPageWithRestResponse(String pageId,\n+                                                      String containerName,\n+                                                      String prefix,\n+                                                      Integer maxResults,\n+                                                      List<ListBlobsIncludeItem> include,\n+                                                      Integer timeout,\n+                                                      String requestId,\n+                                                      CancellationToken cancellationToken,\n+                                                      Callback<ContainersListBlobFlatSegmentResponse> callback) {\n+        this.storageBlobServiceClient.getBlobsInPageWithRestResponse(pageId,\n+            containerName,\n+            prefix,\n+            maxResults,\n+            include,\n+            timeout,\n+            requestId,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the blob's metadata and properties.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void getBlobProperties(String containerName,\n+                                         String blobName,\n+                                         Callback<BlobGetPropertiesHeaders> callback) {\n+        storageBlobServiceClient.getBlobProperties(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a blob's metadata and properties.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely\n+     *                              optional.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void getBlobPropertiesWithRestResponse(String containerName,\n+                                                         String blobName,\n+                                                         String snapshot,\n+                                                         Integer timeout,\n+                                                         String version,\n+                                                         BlobRequestConditions blobRequestConditions,\n+                                                         String requestId,\n+                                                         CpkInfo cpkInfo,\n+                                                         CancellationToken cancellationToken,\n+                                                         Callback<BlobGetPropertiesResponse> callback) {\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.getBlobPropertiesWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            version,\n+            blobRequestConditions.getLeaseId(),\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads the entire blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void rawDownload(String containerName,\n+                                   String blobName,\n+                                   Callback<ResponseBody> callback) {\n+        storageBlobServiceClient.download(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Reads a range of bytes from a blob.\n+     *\n+     * <p>\n+     * This method will execute a raw HTTP GET in order to download a single blob to the destination.\n+     * It is **STRONGLY** recommended that you use the {@link StorageBlobAsyncClient#download(Context, String, String, File)}\n+     * or {@link StorageBlobAsyncClient#download(Context, String, String, Uri)} method instead - that method will\n+     * manage the transfer in the face of changing network conditions, and is able to transfer multiple\n+     * blocks in parallel.\n+     *\n+     * @param containerName         The container name.\n+     * @param blobName              The blob name.\n+     * @param snapshot              The snapshot parameter is an opaque DateTime value that, when present, specifies\n+     *                              the blob snapshot to retrieve. For more information on working with blob snapshots,\n+     *                              see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout               The timeout parameter is expressed in seconds. For more information, see\n+     *                              &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param range                 Return only the bytes of the blob in the specified range.\n+     * @param blobRequestConditions Object that contains values which will restrict the successful operation of a\n+     *                              variety of requests to the conditions present. These conditions are entirely optional.\n+     * @param getRangeContentMd5    When set to true and specified together with the Range, the service returns the\n+     *                              MD5 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param getRangeContentCrc64  When set to true and specified together with the Range, the service returns the\n+     *                              CRC64 hash for the range, as long as the range is less than or equal to 4 MB in size.\n+     * @param version               Specifies the version of the operation to use for this request.\n+     * @param requestId             Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                              recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo               Additional parameters for the operation.\n+     * @param cancellationToken     The token to request cancellation.\n+     * @param callback              Callback that receives the response.\n+     */\n+    public void rawDownloadWithRestResponse(String containerName,\n+                                                   String blobName,\n+                                                   String snapshot,\n+                                                   Integer timeout,\n+                                                   BlobRange range,\n+                                                   BlobRequestConditions blobRequestConditions,\n+                                                   Boolean getRangeContentMd5,\n+                                                   Boolean getRangeContentCrc64,\n+                                                   String version,\n+                                                   String requestId,\n+                                                   CpkInfo cpkInfo,\n+                                                   CancellationToken cancellationToken,\n+                                                   Callback<BlobDownloadResponse> callback) {\n+        range = range == null ? new BlobRange(0) : range;\n+        blobRequestConditions = blobRequestConditions == null ? new BlobRequestConditions() : blobRequestConditions;\n+\n+        storageBlobServiceClient.downloadWithRestResponse(containerName,\n+            blobName,\n+            snapshot,\n+            timeout,\n+            range.toHeaderValue(),\n+            blobRequestConditions.getLeaseId(),\n+            getRangeContentMd5,\n+            getRangeContentCrc64,\n+            blobRequestConditions.getIfModifiedSince(),\n+            blobRequestConditions.getIfUnmodifiedSince(),\n+            blobRequestConditions.getIfMatch(),\n+            blobRequestConditions.getIfNoneMatch(),\n+            version,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param base64BlockId A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                      be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                      for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent  The block content in bytes.\n+     * @param contentMd5    The transactional MD5 for the body, to be validated by the service.\n+     * @param callback      Callback that receives the response.\n+     */\n+    public void stageBlock(String containerName,\n+                                  String blobName,\n+                                  String base64BlockId,\n+                                  byte[] blockContent,\n+                                  byte[] contentMd5,\n+                                  Callback<Void> callback) {\n+        this.storageBlobServiceClient.stageBlock(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            callback);\n+    }\n+\n+    /**\n+     * Creates a new block to be committed as part of a blob.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockId     A valid Base64 string value that identifies the block. Prior to encoding, the string must\n+     *                          be less than or equal to 64 bytes in size. For a given blob, the length of the value specified\n+     *                          for the base64BlockId parameter must be the same size for each block.\n+     * @param blockContent      The block content in bytes.\n+     * @param contentMd5        The transactional MD5 for the block content, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the block content, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param leaseId           If specified, the staging only succeeds if the resource's lease is active and matches this ID.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded.\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void stageBlockWithRestResponse(String containerName,\n+                                                  String blobName,\n+                                                  String base64BlockId,\n+                                                  byte[] blockContent,\n+                                                  byte[] contentMd5,\n+                                                  byte[] contentCrc64,\n+                                                  Integer timeout,\n+                                                  String leaseId,\n+                                                  String requestId,\n+                                                  CpkInfo cpkInfo,\n+                                                  CancellationToken cancellationToken,\n+                                                  Callback<BlockBlobsStageBlockResponse> callback) {\n+        this.storageBlobServiceClient.stageBlockWithRestResponse(containerName,\n+            blobName,\n+            base64BlockId,\n+            blockContent,\n+            contentMd5,\n+            contentCrc64,\n+            timeout,\n+            leaseId,\n+            requestId,\n+            cpkInfo,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob.\n+     * For a block to be written as part of a blob, the block must have been successfully written to the server in a prior\n+     * {@link StorageBlobAsyncClient#stageBlock(String, String, String, byte[], byte[], Callback)} operation. You can\n+     * call commit Block List to update a blob by uploading only those blocks that have changed, then committing the new\n+     * and existing blocks together. You can do this by specifying whether to commit a block from the committed block\n+     * list or from the uncommitted block list, or to commit the most recently uploaded version of the block,\n+     * whichever list it may belong to.\n+     *\n+     * @param containerName  The container name.\n+     * @param blobName       The blob name.\n+     * @param base64BlockIds The block IDs.\n+     * @param overwrite      Indicate whether to overwrite the block list if already exists.\n+     * @param callback       Callback that receives the response.\n+     */\n+    public void commitBlockList(String containerName,\n+                                       String blobName,\n+                                       List<String> base64BlockIds,\n+                                       boolean overwrite,\n+                                       Callback<BlockBlobItem> callback) {\n+        this.storageBlobServiceClient.commitBlockList(containerName,\n+            blobName,\n+            base64BlockIds,\n+            overwrite,\n+            callback);\n+    }\n+\n+    /**\n+     * The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob.\n+     * For a block to be written as part of a blob, the block must have been successfully written to the server in a prior\n+     * {@link StorageBlobAsyncClient#stageBlock(String, String, String, byte[], byte[], Callback)} operation. You can call\n+     * commit Block List to update a blob by uploading only those blocks that have changed, then committing the new and existing\n+     * blocks together. You can do this by specifying whether to commit a block from the committed block list or from\n+     * the uncommitted block list, or to commit the most recently uploaded version of the block, whichever list it may belong to.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param base64BlockIds    The block IDs.\n+     * @param contentMD5        Specify the transactional md5 for the body, to be validated by the service.\n+     * @param contentCrc64      Specify the transactional crc64 for the body, to be validated by the service.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information,\n+     *                          see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param blobHttpHeaders   Additional Http headers for this operation.\n+     * @param metadata          Specifies a user-defined name-value pair associated with the blob.\n+     * @param requestConditions {@link BlobRequestConditions}.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is recorded\n+     *                          in the analytics logs when storage analytics logging is enabled.\n+     * @param cpkInfo           Additional parameters for the operation.\n+     * @param tier              Indicates the tier to be set on the blob.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    public void commitBlockListWithRestResponse(String containerName,\n+                                                       String blobName,\n+                                                       List<String> base64BlockIds,\n+                                                       byte[] contentMD5,\n+                                                       byte[] contentCrc64,\n+                                                       Integer timeout,\n+                                                       BlobHttpHeaders blobHttpHeaders,\n+                                                       Map<String, String> metadata,\n+                                                       BlobRequestConditions requestConditions,\n+                                                       String requestId,\n+                                                       CpkInfo cpkInfo,\n+                                                       AccessTier tier,\n+                                                       CancellationToken cancellationToken,\n+                                                       Callback<BlockBlobsCommitBlockListResponse> callback) {\n+        this.storageBlobServiceClient.commitBlockListWithRestResponse(containerName,\n+            blobName,\n+            base64BlockIds,\n+            contentMD5,\n+            contentCrc64,\n+            timeout,\n+            blobHttpHeaders,\n+            metadata,\n+            requestConditions,\n+            requestId,\n+            cpkInfo,\n+            tier,\n+            cancellationToken,\n+            callback);\n+    }\n+\n+    /**\n+     * Deletes the specified blob or snapshot. Note that deleting a blob also deletes all its snapshots.\n+     *\n+     * @param containerName The container name.\n+     * @param blobName      The blob name.\n+     * @param callback      Callback that receives the response.\n+     */\n+    void delete(String containerName,\n+                       String blobName,\n+                       Callback<Void> callback) {\n+        storageBlobServiceClient.delete(containerName,\n+            blobName,\n+            callback);\n+    }\n+\n+    /**\n+     * Deletes the specified blob or snapshot. Note that deleting a blob also deletes all its snapshots.\n+     * <p>\n+     * If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently\n+     * removed from the storage account. If the storage account's soft delete feature is enabled, then, when a blob\n+     * is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains\n+     * the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of\n+     * &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\"&gt; Storage service properties.&lt;/a&gt;.\n+     * After the specified number of days has passed, the blob's data is permanently removed from the storage account.\n+     * Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use\n+     * the List Blobs API and specify the \"include=deleted\" query parameter to discover which blobs and snapshots\n+     * have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other\n+     * operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404\n+     * (ResourceNotFound). If the storage account's automatic snapshot feature is enabled, then, when a blob is\n+     * deleted, an automatic snapshot is created. The blob becomes inaccessible immediately. All other operations on\n+     * the blob causes the service to return an HTTP status code of 404 (ResourceNotFound). You can access automatic\n+     * snapshot using snapshot timestamp or version ID. You can restore the blob by calling Put or Copy Blob API with\n+     * automatic snapshot as source. Deleting automatic snapshot requires shared key or special SAS/RBAC permissions.\n+     *\n+     * @param containerName     The container name.\n+     * @param blobName          The blob name.\n+     * @param snapshot          The snapshot parameter is an opaque DateTime value that, when present, specifies the\n+     *                          blob snapshot to retrieve. For more information on working with blob snapshots, see &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/creating-a-snapshot-of-a-blob\"&gt;Creating a Snapshot of a Blob.&lt;/a&gt;.\n+     * @param timeout           The timeout parameter is expressed in seconds. For more information, see\n+     *                          &lt;a href=\"https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations\"&gt;Setting Timeouts for Blob Service Operations.&lt;/a&gt;.\n+     * @param leaseId           If specified, the operation only succeeds if the resource's lease is active and\n+     *                          matches this ID.\n+     * @param deleteSnapshots   Required if the blob has associated snapshots. Specify one of the following two\n+     *                          options: include: Delete the base blob and all of its snapshots. only: Delete only the blob's snapshots and not the blob itself. Possible values include: 'include', 'only'.\n+     * @param ifModifiedSince   Specify this header value to operate only on a blob if it has been modified since the\n+     *                          specified date/time.\n+     * @param ifUnmodifiedSince Specify this header value to operate only on a blob if it has not been modified since\n+     *                          the specified date/time.\n+     * @param ifMatch           Specify an ETag value to operate only on blobs with a matching value.\n+     * @param ifNoneMatch       Specify an ETag value to operate only on blobs without a matching value.\n+     * @param requestId         Provides a client-generated, opaque value with a 1 KB character limit that is\n+     *                          recorded in the analytics logs when storage analytics logging is enabled.\n+     * @param cancellationToken The token to request cancellation.\n+     * @param callback          Callback that receives the response.\n+     */\n+    void deleteWithResponse(String containerName,\n+                                   String blobName,\n+                                   String snapshot,\n+                                   Integer timeout,\n+                                   String version,\n+                                   String leaseId,\n+                                   DeleteSnapshotsOptionType deleteSnapshots,\n+                                   OffsetDateTime ifModifiedSince,\n+                                   OffsetDateTime ifUnmodifiedSince,\n+                                   String ifMatch,\n+                                   String ifNoneMatch,\n+                                   String requestId,\n+                                   CancellationToken cancellationToken,\n+                                   Callback<BlobDeleteResponse> callback) {", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNzg5MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452537891", "bodyText": "I had not thought of this before: if the service call is going to be blocked and will either produce a result or fail before we reach this stage, is it any use registering the onCancel callback?", "author": "vcolin7", "createdAt": "2020-07-09T23:10:04Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/StorageBlobServiceImpl.java", "diffHunk": "@@ -128,24 +131,36 @@ ContainersListBlobFlatSegmentResponse getBlobsInPageWithRestResponse(String page\n                                                                          Integer maxResults,\n                                                                          List<ListBlobsIncludeItem> include,\n                                                                          Integer timeout,\n-                                                                         String requestId) {\n-        return this.getBlobsInPageWithRestResponseIntern(pageId, containerName,\n+                                                                         String requestId,\n+                                                                         CancellationToken cancellationToken) {\n+        cancellationToken = cancellationToken == null ? CancellationToken.NONE : cancellationToken;\n+        CallAndOptionalResult<ContainersListBlobFlatSegmentResponse> callAndOptionalResult =\n+            this.getBlobsInPageWithRestResponseIntern(pageId, containerName,\n             prefix,\n             maxResults,\n             include,\n             timeout,\n             requestId,\n-            null).getResult();\n+            null);\n+\n+        final Call call = callAndOptionalResult.getCall();\n+        ((CancellationTokenImpl) cancellationToken).registerOnCancel(() -> {\n+            call.cancel();\n+        });\n+\n+        return callAndOptionalResult.getResult();", "originalCommit": "592c7a89d73312f99c178cd1fa4d39d749a29257", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU2MjM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452562399", "bodyText": "In the case of blocking APIs like this, one way I see app using them is:\n// UI Thread\nCancellationToken token = CancellationToken.create();\nexecutorService.schedule(() -> {\n    // Thread-Pool Thread\n    client.getBlobProperties(.., cancellationToken);\n});\n// UIThread\nonButtonClient(() -> {\n    cancellationToken.cancel();\n});", "author": "anuchandy", "createdAt": "2020-07-10T00:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3ODM3MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452578370", "bodyText": "Wouldn't the call be completed before the onCancel callback with call.cancel() is registered on the token? The way I see it, the sync part of the internal call uses execute() which blocks the entire thing until it's done.", "author": "vcolin7", "createdAt": "2020-07-10T01:44:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU5MjA4Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/252#discussion_r452592083", "bodyText": "I see you're right, in sync case the registration is delayed. I'm fixing it.", "author": "anuchandy", "createdAt": "2020-07-10T02:40:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUzNzg5MQ=="}], "type": "inlineReview"}, {"oid": "b8946d0661e1d0814ae851176c1c8726e129d157", "url": "https://github.com/Azure/azure-sdk-for-android/commit/b8946d0661e1d0814ae851176c1c8726e129d157", "message": "Correcting indentation in StorageClientimpl type\n\nCo-authored-by: vcolin7 <vicolina@microsoft.com>", "committedDate": "2020-07-10T00:47:28Z", "type": "commit"}, {"oid": "1dffcfaee12254f9545d7d0098a18b601e2e4bb4", "url": "https://github.com/Azure/azure-sdk-for-android/commit/1dffcfaee12254f9545d7d0098a18b601e2e4bb4", "message": "cleaning up inttendation", "committedDate": "2020-07-10T01:01:18Z", "type": "commit"}, {"oid": "5aa0d5b02fbea5116ce54aece9703468afdc3490", "url": "https://github.com/Azure/azure-sdk-for-android/commit/5aa0d5b02fbea5116ce54aece9703468afdc3490", "message": "Fixing conflicts", "committedDate": "2020-07-10T01:06:28Z", "type": "commit"}, {"oid": "ec60446f517902d6cd7abca55604c073f806d30a", "url": "https://github.com/Azure/azure-sdk-for-android/commit/ec60446f517902d6cd7abca55604c073f806d30a", "message": "Merge branch 'dev' of github.com:Azure/azure-sdk-for-android into cancellation-token", "committedDate": "2020-07-10T01:06:40Z", "type": "commit"}, {"oid": "226d0806f82b51f24d09f8c927da9621cce60641", "url": "https://github.com/Azure/azure-sdk-for-android/commit/226d0806f82b51f24d09f8c927da9621cce60641", "message": "Sync: Register onCancel before blocking.", "committedDate": "2020-07-10T02:45:58Z", "type": "commit"}]}