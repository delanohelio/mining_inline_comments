{"pr_number": 237, "pr_title": "Support for providing Content URI of the content to be transferred", "pr_createdAt": "2020-05-19T19:52:32Z", "pr_url": "https://github.com/Azure/azure-sdk-for-android/pull/237", "timeline": [{"oid": "724ce0e8746658af2623039b01de0de1bfd57a3b", "url": "https://github.com/Azure/azure-sdk-for-android/commit/724ce0e8746658af2623039b01de0de1bfd57a3b", "message": "Basic infa to support Content URI", "committedDate": "2020-05-19T19:44:24Z", "type": "commit"}, {"oid": "90d0eefe17236b84212ffba05af7e99cdb138d0d", "url": "https://github.com/Azure/azure-sdk-for-android/commit/90d0eefe17236b84212ffba05af7e99cdb138d0d", "message": "using ContentResolver::query to get the content size.", "committedDate": "2020-05-19T23:05:33Z", "type": "commit"}, {"oid": "285e48ed6a52ed619e74d1b7165d70c96e458610", "url": "https://github.com/Azure/azure-sdk-for-android/commit/285e48ed6a52ed619e74d1b7165d70c96e458610", "message": "Updating sample to use upload API that takes ContentUri.", "committedDate": "2020-05-19T23:06:15Z", "type": "commit"}, {"oid": "c1ae319db3509aa98b20f2dfba2799dfebb58ac4", "url": "https://github.com/Azure/azure-sdk-for-android/commit/c1ae319db3509aa98b20f2dfba2799dfebb58ac4", "message": "Renaming ContentDescription to RedableContent to better indicate the purpose of type, Removing content specific columns from BlockUpload entity instead using the same from BlobUpload entity.", "committedDate": "2020-05-30T18:00:29Z", "type": "commit"}, {"oid": "09a828eb49a0bedc1b1438c1c8153da56464b364", "url": "https://github.com/Azure/azure-sdk-for-android/commit/09a828eb49a0bedc1b1438c1c8153da56464b364", "message": "Fix: Download BlockOffset calculation, Removing unncessary message dispatch in DownloadHandler.", "committedDate": "2020-05-30T18:07:13Z", "type": "commit"}, {"oid": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "url": "https://github.com/Azure/azure-sdk-for-android/commit/dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "message": "Adding WritableContent representing the content in device to store the downloaded blob, Updating types to use WritableContent.", "committedDate": "2020-05-30T18:13:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyMzc1Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433423756", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The URI to the content to store the downloaded blob.\n          \n          \n            \n                 * The URI to the content where the downloaded blob will be stored.", "author": "vcolin7", "createdAt": "2020-06-01T18:51:26Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java", "diffHunk": "@@ -51,10 +50,16 @@\n     public long blobSize;\n \n     /**\n-     * The absolute path to the file to be uploaded as blob.\n+     * The URI to the content to store the downloaded blob.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyNDM5MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433424390", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param content describes the content to store the downloaded blob.\n          \n          \n            \n                 * @param content Describes the content where the downloaded blob will be stored.", "author": "vcolin7", "createdAt": "2020-06-01T18:52:43Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobDownloadEntity.java", "diffHunk": "@@ -98,22 +103,26 @@ public BlobDownloadEntity() {}\n      * @param storageBlobClientId identifies the blob storage client to be used\n      * @param containerName The container name.\n      * @param blobName The blob name.\n-     * @param file The local file.\n+     * @param blobSize The blob size.\n+     * @param content describes the content to store the downloaded blob.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyODU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433428595", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"' is cannot be processed, failed to open the content to write.\", t));\n          \n          \n            \n                                    \"' cannot be processed, failed to open the content to write.\", t));", "author": "vcolin7", "createdAt": "2020-06-01T19:01:07Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -168,6 +168,16 @@ private void handleInit() {\n                     .onError(new UnresolvedStorageBlobClientIdException(this.blob.storageBlobClientId));\n                 this.getLooper().quit();\n             } else {\n+                this.content = new WritableContent(appContext,\n+                    Uri.parse(this.blob.contentUri),\n+                    this.blob.useContentResolver);\n+                try {\n+                    this.content.openForWrite(appContext);\n+                } catch (Throwable t) {\n+                    this.transferHandlerListener.onError(new RuntimeException(\"Download operation with id '\" + downloadId +\n+                        \"' is cannot be processed, failed to open the content to write.\", t));", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTI0OA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433429248", "bodyText": "Are we not creating a message because we are calling onComplete() and quitting the looper anyways?", "author": "vcolin7", "createdAt": "2020-06-01T19:02:33Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -205,8 +215,7 @@ private void handleDownloadCompleted(Message message) {\n             if (runningBlockDownloads.isEmpty()) {\n                 db.downloadDao().updateBlobState(downloadId, BlobTransferState.COMPLETED);\n \n-                Message nextMessage = DownloadHandlerMessage.createBlobDownloadCompletedMessage(DownloadHandler.this);\n-                nextMessage.sendToTarget();\n+                closeContent();", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3ODQxMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433478412", "bodyText": "Depending on when looper really quit - this message either gets ignored because looper quit before processing it OR this message processed again which results in extra DB calls that simply repeat what was already done.", "author": "anuchandy", "createdAt": "2020-06-01T20:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433429777", "bodyText": "Same as above.", "author": "vcolin7", "createdAt": "2020-06-01T19:03:39Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -230,13 +239,11 @@ private void handleDownloadFailed(Message message) {\n             pair.second.cancel();\n         }\n \n-        Throwable downloadError = failedPair.first.getDownloadError();\n+        closeContent();\n \n+        Throwable downloadError = failedPair.first.getDownloadError();\n         blob.setDownloadError(downloadError);\n \n-        Message nextMessage = DownloadHandlerMessage.createBlobDownloadFailedMessage(DownloadHandler.this);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4NTMzMw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433485333", "bodyText": "yes, reason for this is same as I explained above.", "author": "anuchandy", "createdAt": "2020-06-01T20:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQyOTc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTE3OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433431179", "bodyText": "What are the possible consequences of not being able to close a content instance?", "author": "vcolin7", "createdAt": "2020-06-01T19:06:30Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/DownloadHandler.java", "diffHunk": "@@ -330,6 +338,14 @@ public void onFailure(Throwable t) {\n         }\n     }\n \n+    private void closeContent() {", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4MDg1MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433480850", "bodyText": "it is a  wrapper over file so consequence will be the same as if the app doesn't close a file descriptor (or HTTP connection). But we are careful enough to close it when the work manager asks us to do the cleanup by calling onStop.", "author": "anuchandy", "createdAt": "2020-06-01T20:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTQxNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433431414", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Upload content of a file.\n          \n          \n            \n                 * Upload the content of a file.", "author": "vcolin7", "createdAt": "2020-06-01T19:06:57Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -73,7 +74,7 @@ private TransferClient(Context context,\n     }\n \n     /**\n-     * Upload a file.\n+     * Upload content of a file.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMjA3Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433432076", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri uri to the Content to upload, the contentUri is resolved using\n          \n          \n            \n                 * @param contentUri URI to the Content to upload, the contentUri is resolved using", "author": "vcolin7", "createdAt": "2020-06-01T19:08:12Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -83,7 +84,50 @@ private TransferClient(Context context,\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n         // UI_Thread\n+        return upload(storageBlobClientId, containerName, blobName,\n+            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Upload content identified by a given Uri.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param contentUri uri to the Content to upload, the contentUri is resolved using", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMjM3MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433432371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://\n          \n          \n            \n                 *   with mode as \"r\". The supported URI schemes are: 'content://', 'file://' and 'android.resource://'", "author": "vcolin7", "createdAt": "2020-06-01T19:08:47Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -83,7 +84,50 @@ private TransferClient(Context context,\n      */\n     public LiveData<TransferInfo> upload(String storageBlobClientId, String containerName, String blobName, File file) {\n         // UI_Thread\n+        return upload(storageBlobClientId, containerName, blobName,\n+            new ReadableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Upload content identified by a given Uri.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the upload\n+     * @param containerName the container to upload the file to\n+     * @param blobName the name of the target blob holding uploaded file\n+     * @param contentUri uri to the Content to upload, the contentUri is resolved using\n+     *   {@link android.content.ContentResolver#openAssetFileDescriptor(Uri, String)}\n+     *   with mode as \"r\". The supported  URI schemes are content:// file:// and android.resource://", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMzY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433433672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri The uri to the local content to write the downloaded blob\n          \n          \n            \n                 * @param contentUri The URI to the local content where the downloaded blob will be stored.", "author": "vcolin7", "createdAt": "2020-06-01T19:11:34Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -135,9 +182,51 @@ private TransferClient(Context context,\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param containerName The container to download the blob from.\n+     * @param blobName The name of the target blob to download.\n+     * @param contentUri The uri to the local content to write the downloaded blob", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433438522", "bodyText": "What is the difference with the upload() URI overload where the useContentResolver value is set to true? Are we setting it to false here because the content would not yet exist in storage when this is called?", "author": "vcolin7", "createdAt": "2020-06-01T19:21:37Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/TransferClient.java", "diffHunk": "@@ -135,9 +182,51 @@ private TransferClient(Context context,\n      * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n      */\n     public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, File file) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, Uri.fromFile(file), false));\n+    }\n+\n+    /**\n+     * Download a blob.\n+     *\n+     * @param storageBlobClientId the identifier of the blob storage client to use for the download\n+     * @param containerName The container to download the blob from.\n+     * @param blobName The name of the target blob to download.\n+     * @param contentUri The uri to the local content to write the downloaded blob\n+     * @return LiveData that streams {@link TransferInfo} describing the current state of the download.\n+     */\n+    public LiveData<TransferInfo> download(String storageBlobClientId, String containerName, String blobName, Uri contentUri) {\n+        return download(storageBlobClientId,\n+            containerName,\n+            blobName,\n+            new WritableContent(this.context, contentUri, false));", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4MzQ0NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433483444", "bodyText": "if useContentResolver is false, it means the user-provided already resolved File object hence it is ok to use the raw path. If useContentResolver is true then it means the user provided a contentUri which we treat as an opaque handle and we don't look into the raw path.", "author": "anuchandy", "createdAt": "2020-06-01T20:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMjU4Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433522587", "bodyText": "How probable do you think it is that we get an unresolved URI for download?", "author": "vcolin7", "createdAt": "2020-06-01T22:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzMzAyNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433533024", "bodyText": "How probably do you think it is that we get an \"unresolved URI\" for download?\nBy \"unresolved URI\" do you mean a URI that always needed to go through ContentResolver? If so I think recommendation is - we should always use ContentResolver when user explicitly provide URI. For example, if we take Android official DownloadManager source code, it always uses ContentResolver and never touches the raw-path.", "author": "anuchandy", "createdAt": "2020-06-01T22:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzMzc3MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433533770", "bodyText": "I missed the source code ref to DownloadManager. Here it is: https://android.googlesource.com/platform/packages/providers/DownloadProvider/+/refs/heads/master/src/com/android/providers/downloads/DownloadThread.java#559", "author": "anuchandy", "createdAt": "2020-06-01T23:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzOTEyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433539127", "bodyText": "If the question is opposite - i.e., what are the chances that user can provide a File object which somehow requires ContentResolver, then may be if a user wants he can make up one, but I don't know what he is trying to achieve :(\nI think our rules are simple:\n\nIf the user provides a File object, we expect the library can directly read/write to the path it points to. (i.e the first/existing impl of download)\nIf the user provides a Uri object, then the user assumes the library uses Content resolution guidelines. Just like any other android API's that take Uri.", "author": "anuchandy", "createdAt": "2020-06-01T23:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NDkyMw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433574923", "bodyText": "Sounds good to me. Based on that, shouldn't this particular overload (using contentUri) pass true to WritableContent?", "author": "vcolin7", "createdAt": "2020-06-02T01:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3Njg3MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433576870", "bodyText": "ah. I see, yes it should be true,thanks for catching \ud83d\udc4d", "author": "anuchandy", "createdAt": "2020-06-02T01:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzODUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzOTkwOQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433439909", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);\n          \n          \n            \n                            Log.e(TAG,  \"stageBlocks(): failure in reading content. Block id: \" + block.blockId + \". Thread name: \" + threadName(), t);", "author": "vcolin7", "createdAt": "2020-06-01T19:24:37Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/UploadHandler.java", "diffHunk": "@@ -277,10 +283,23 @@ private void stageBlocks(List<BlockUploadEntity> blocks) {\n         for (BlockUploadEntity block : blocks) {\n             this.finalizeIfStopped();\n             Log.v(TAG, \"stageBlocks(): Uploading block:\" + block.blockId + threadName());\n+            byte [] blockContent;\n+            try {\n+                blockContent = content.readBlock(block.blockOffset, block.blockSize);\n+            } catch (Throwable t) {\n+                Log.e(TAG,  \"stageBlocks(): failure in reading content:\" + block.blockId + threadName(), t);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MDY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433440683", "bodyText": "Making this a little easier to read. Although I would understand if you felt like explicitly talking about thread name and block id is not desired.", "author": "vcolin7", "createdAt": "2020-06-01T19:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzOTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MzUzMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433443532", "bodyText": "I feel weird reading isUse at the beginning although I understand it's based on a convention for boolean values. Would it be ok to rename this to isUsingContentResolver instead?", "author": "vcolin7", "createdAt": "2020-06-01T19:31:04Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4OTc1OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433489759", "bodyText": "Something I struggled when naming this property :) .. isUsingContentResolver is fine with me.", "author": "anuchandy", "createdAt": "2020-06-01T21:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0MzUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NDE4OQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433444189", "bodyText": "This could return 0 if the file does not exist. We might want to consider that for when we decide to throw. Source.", "author": "vcolin7", "createdAt": "2020-06-01T19:32:32Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NTI5MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433575291", "bodyText": "@anuchandy Although, you really can't tell if a returning 0 means there is no file, so we would probably need to make another check there.", "author": "vcolin7", "createdAt": "2020-06-02T01:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NzI1OA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433577258", "bodyText": "actually I changed the logic and this is taken care of in the last commit", "author": "anuchandy", "createdAt": "2020-06-02T01:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NDE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTYyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433445627", "bodyText": "Any reason you preferred to use Throwable here instead of a specific exception? I feel like using the latter would be more descriptive.", "author": "vcolin7", "createdAt": "2020-06-01T19:35:35Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5MjU2Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433492562", "bodyText": "good catch, I thought I got rid of Throwables :), will switch to something meaning full.", "author": "anuchandy", "createdAt": "2020-06-01T21:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ0NTk4MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433445980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n          \n          \n            \n                 * @return an array of bytes taken from the content in the range [blockOffset, blockOffset + blockSize]", "author": "vcolin7", "createdAt": "2020-06-01T19:36:17Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Mjk3MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433452971", "bodyText": "A little nitpick: maybe we can modify a little this to avoid code duplication? To be honest this is not really a big deal.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (this.useContentResolver) {\n          \n          \n            \n                        this.checkPersistableReadGranted();\n          \n          \n            \n                        // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n          \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        try (AssetFileDescriptor descriptor\n          \n          \n            \n                                 = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n          \n          \n            \n                            try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n          \n          \n            \n                                seek(fileInputStream, blockOffset);\n          \n          \n            \n                                byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                                read(fileInputStream, blockContent);\n          \n          \n            \n                                return blockContent;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        File file = new File(this.contentUri.getPath());\n          \n          \n            \n                        try (FileInputStream fileInputStream = new FileInputStream(file)) {\n          \n          \n            \n                            seek(fileInputStream, blockOffset);\n          \n          \n            \n                            byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                            read(fileInputStream, blockContent);\n          \n          \n            \n                            return blockContent;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                }\n          \n          \n            \n                    FileInputStream fileInputStream;\n          \n          \n            \n                    \n          \n          \n            \n                    if (this.useContentResolver) {\n          \n          \n            \n                        this.checkPersistableReadGranted();\n          \n          \n            \n                        // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n          \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        try (AssetFileDescriptor descriptor\n          \n          \n            \n                                 = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n          \n          \n            \n                            fileInputStream = descriptor.createInputStream();\n          \n          \n            \n                        }\n          \n          \n            \n                    } else {\n          \n          \n            \n                        File file = new File(this.contentUri.getPath());\n          \n          \n            \n                        fileInputStream = new FileInputStream(file);\n          \n          \n            \n                    }\n          \n          \n            \n                    \n          \n          \n            \n                    try {\n          \n          \n            \n                        seek(fileInputStream, blockOffset);\n          \n          \n            \n                        byte [] blockContent = new byte[blockSize];\n          \n          \n            \n                        read(fileInputStream, blockContent);\n          \n          \n            \n                        return blockContent;\n          \n          \n            \n                    } finally {\n          \n          \n            \n                        fileInputStream.close();\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "vcolin7", "createdAt": "2020-06-01T19:50:42Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NjUxMg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433496512", "bodyText": "yes, thanks for double-checking, I know we duplicate ~5 lines but I prefer the original one due to readability.", "author": "anuchandy", "createdAt": "2020-06-01T21:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Mjk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1MzQ0Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433453447", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param seekTo the seek position\n          \n          \n            \n                 * @param seekTo the stream position to seek", "author": "vcolin7", "createdAt": "2020-06-01T19:51:44Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDcwMQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433454701", "bodyText": "What does m stand for?", "author": "vcolin7", "createdAt": "2020-06-01T19:54:22Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NDU2Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433494567", "bodyText": "its number of bytes skipped, I'll change the variable name to be more readable.", "author": "anuchandy", "createdAt": "2020-06-01T21:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUyMTkyNw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433521927", "bodyText": "Thanks!", "author": "vcolin7", "createdAt": "2020-06-01T22:24:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDg3NQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433454875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Read the stream content into a buffer starting from stream's read cursor position.\n          \n          \n            \n                 * Read the stream content into a buffer starting from the stream's read cursor position.", "author": "vcolin7", "createdAt": "2020-06-01T19:54:45Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);\n+            if (m < 0) {\n+                throw new IOException(\"FileInputStream::seek returned negative value.\");\n+            }\n+            if (m == 0) {\n+                if (stream.read() == -1) {\n+                    return;\n+                } else {\n+                    skipped++;\n+                }\n+            } else {\n+                skipped += m;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the stream content into a buffer starting from stream's read cursor position.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NTA0MA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433455040", "bodyText": "Same as above.", "author": "vcolin7", "createdAt": "2020-06-01T19:55:03Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n+            try (AssetFileDescriptor descriptor\n+                     = this.context.getContentResolver().openAssetFileDescriptor(this.contentUri, \"r\")) {\n+                try (FileInputStream fileInputStream = descriptor.createInputStream()) {\n+                    seek(fileInputStream, blockOffset);\n+                    byte [] blockContent = new byte[blockSize];\n+                    read(fileInputStream, blockContent);\n+                    return blockContent;\n+                }\n+            }\n+        } else {\n+            File file = new File(this.contentUri.getPath());\n+            try (FileInputStream fileInputStream = new FileInputStream(file)) {\n+                seek(fileInputStream, blockOffset);\n+                byte [] blockContent = new byte[blockSize];\n+                read(fileInputStream, blockContent);\n+                return blockContent;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable read permission is granted on the content.\n+     *\n+     * @throws Throwable if permission is not granted\n+     */\n+    private void checkPersistableReadGranted() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            final List<UriPermission> permissions = this.context.getContentResolver().getPersistedUriPermissions();\n+            boolean grantedRead = false;\n+            for (UriPermission permission : permissions) {\n+                if (permission.isReadPermission()) {\n+                    grantedRead = true;\n+                    break;\n+                }\n+            }\n+            if (!grantedRead) {\n+                throw new IllegalStateException(\"Read permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Seek the stream read cursor to the given position.\n+     *\n+     * @param stream the stream\n+     * @param seekTo the seek position\n+     * @throws IOException if seek fails\n+     */\n+    private static void seek(FileInputStream stream, long seekTo) throws IOException {\n+        int skipped = 0;\n+        while(skipped < seekTo) {\n+            long m = stream.skip(seekTo - skipped);\n+            if (m < 0) {\n+                throw new IOException(\"FileInputStream::seek returned negative value.\");\n+            }\n+            if (m == 0) {\n+                if (stream.read() == -1) {\n+                    return;\n+                } else {\n+                    skipped++;\n+                }\n+            } else {\n+                skipped += m;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Read the stream content into a buffer starting from stream's read cursor position.\n+     *\n+     * @param stream the file stream\n+     * @param buffer the output buffer\n+     * @return the number of bytes read\n+     * @throws IOException if read fails\n+     */\n+    private static int read(FileInputStream stream, byte [] buffer) throws IOException {\n+        int bytesToRead = buffer.length;\n+        int bytesRead = 0;\n+        while (bytesRead < bytesToRead) {\n+            int m = stream.read(buffer, bytesRead, bytesToRead - bytesRead);", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NjM5NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433456394", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The URI to the content to be uploaded as blob.\n          \n          \n            \n                 * The URI to the content to be uploaded as a blob.", "author": "vcolin7", "createdAt": "2020-06-01T19:57:41Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/BlobUploadEntity.java", "diffHunk": "@@ -32,15 +31,20 @@\n     @ColumnInfo(name = \"key\")\n     public Long key;\n     /**\n-     * The absolute path to the file to be uploaded as blob.\n+     * The URI to the content to be uploaded as blob.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1Nzc1MQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433457751", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return true if resolving content URI requires content resolver.\n          \n          \n            \n                 * @return true if resolving content URI requires {@link android.content.ContentResolver}.", "author": "vcolin7", "createdAt": "2020-06-01T20:00:23Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1OTMxMQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433459311", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @throws IOException if fails to open underlying content resource in write mode\n          \n          \n            \n                 * @throws IOException if not possible to open underlying content resource in write mode", "author": "vcolin7", "createdAt": "2020-06-01T20:03:50Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MDA5Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433460097", "bodyText": "See comment above about the naming of this method on ReadableContent.", "author": "vcolin7", "createdAt": "2020-06-01T20:05:25Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5Njk0NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433496944", "bodyText": "I guess you mean isUsingContentResolver, will change it, thanks!", "author": "anuchandy", "createdAt": "2020-06-01T21:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MDA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MzAyNg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433463026", "bodyText": "Do we want to capitalize Content wherever its mentioned to make the distinction between ReadableContent/WritableContent and the word \"content\" in the general sense?", "author": "vcolin7", "createdAt": "2020-06-01T20:11:37Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri\n+     * @throws IllegalStateException if permission is not granted\n+     */\n+    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n+        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n+        boolean grantedWrite = false;\n+        for (UriPermission permission : permissions) {\n+            if (permission.isWritePermission()) {\n+                grantedWrite = true;\n+                break;\n+            }\n+        }\n+\n+        if (!grantedWrite) {\n+            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+        }\n+    }\n+\n+    /**\n+     * A Channel to write to a Content identified by a ContentUri.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5OTgwNA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433499804", "bodyText": "\"content\" is a general android term so it should be fine to use it in comments as \"content\", this specific code comment, maybe I should change from \"Content\" to \"content\".", "author": "anuchandy", "createdAt": "2020-06-01T21:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2MzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NDAyMQ==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433464021", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param context the context to resolve the content uri\n          \n          \n            \n                     * @param contentUri the uri of the content to write to using this Channel.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @throws IOException if fails to open underlying content resource in write mode\n          \n          \n            \n                     * @param context the context to resolve the content URI\n          \n          \n            \n                     * @param contentUri the URI of the content to write to using this Channel.\n          \n          \n            \n                     *\n          \n          \n            \n                     * @throws IOException if failed to open the underlying content resource in write mode", "author": "vcolin7", "createdAt": "2020-06-01T20:13:43Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri\n+     * @throws IllegalStateException if permission is not granted\n+     */\n+    private static void checkPersistableWriteGranted(Context context, Uri contentUri) throws IllegalStateException {\n+        final List<UriPermission> permissions = context.getContentResolver().getPersistedUriPermissions();\n+        boolean grantedWrite = false;\n+        for (UriPermission permission : permissions) {\n+            if (permission.isWritePermission()) {\n+                grantedWrite = true;\n+                break;\n+            }\n+        }\n+\n+        if (!grantedWrite) {\n+            throw new IllegalStateException(\"Write permission for the content '\" + contentUri + \"' is not granted or revoked.\");\n+        }\n+    }\n+\n+    /**\n+     * A Channel to write to a Content identified by a ContentUri.\n+     */\n+    private static class WriteToContentChannel implements Closeable {\n+        private final Context context;\n+        private final Uri contentUri;\n+        private final ParcelFileDescriptor parcelFileDescriptor;\n+        private final FileOutputStream fileOutputStream;\n+        private final FileChannel fileChannel;\n+        private final AtomicBoolean isClosed = new AtomicBoolean(false);\n+\n+        /**\n+         * Creates WriteToContentChannel to write to the Content identified by the given ContentUri.\n+         *\n+         * @param context the context to resolve the content uri\n+         * @param contentUri the uri of the content to write to using this Channel.\n+         *\n+         * @throws IOException if fails to open underlying content resource in write mode", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NTY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433465683", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Check a persistable write permission is granted on the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param context the context to access content resolver\n          \n          \n            \n                 * @param contentUri the content uri\n          \n          \n            \n                 * Check if persistable write permission is granted on the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param context the context to access {@link android.content.ContentResolver}\n          \n          \n            \n                 * @param contentUri the content URI", "author": "vcolin7", "createdAt": "2020-06-01T20:17:14Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails\n+     */\n+    void close() throws IOException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel != null) {\n+                    this.contentChannel.close();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check a persistable write permission is granted on the content.\n+     *\n+     * @param context the context to access content resolver\n+     * @param contentUri the content uri", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjE3Mg==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466172", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * close the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @throws IOException if close operation fails\n          \n          \n            \n                 * Close the content.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @throws IOException if the close operation fails", "author": "vcolin7", "createdAt": "2020-06-01T20:18:10Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    WritableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable write permission on the content.\n+     *\n+     * @throws IllegalStateException if write permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableWritePermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n+            checkPersistableWriteGranted(this.context, this.contentUri);\n+        }\n+    }\n+\n+    /**\n+     * Open the content for writing.\n+     *\n+     * @throws IOException if fails to open underlying content resource in write mode\n+     * @throws IllegalStateException if write permission to the content is not granted/revoked or\n+     *     the channel was already opened and disposed\n+     */\n+    void openForWrite(Context context) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            synchronized (this) {\n+                if (this.contentChannel == null) {\n+                    this.contentChannel = WriteToContentChannel.create(context, this.contentUri);\n+                } else if (this.contentChannel.isClosed()) {\n+                    throw new IllegalStateException(\"A closed Content Channel cannot be opened.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Write a block of bytes to the content.\n+     *\n+     * @param blockOffset the start offset to write the block to\n+     * @param block the block of bytes to write\n+     *\n+     * @throws IOException the IO error when attempting to write\n+     * @throws IllegalStateException if write permission is not granted or revoked\n+     */\n+    void writeBlock(long blockOffset, byte [] block) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            if (this.contentChannel == null) {\n+                throw new IOException(\"openForWrite(..) must be called before invoking writeBlock(..).\");\n+            }\n+            // When `useContentResolver` is true then ContentUri must be treated as an opaque handle\n+            // and the raw-path must not be used.\n+            // https://commonsware.com/blog/2016/03/15/how-consume-content-uri.html\n+            // Obtaining a RandomAccessFile requires the raw-path to the file backing the ContentUri.\n+            //\n+            // So to write to Content, instead of RandomAccessFile we will use FileChannel, specifically\n+            // we a shared instance of FileChannel to write the blocks downloaded by concurrent (OkHttp) threads.\n+            // Operations in FileChannel instance are concurrent safe.\n+            // https://developer.android.com/reference/java/nio/channels/FileChannel\n+            //\n+            // The FileChannel instance is obtained from a FileOutputStream for the ContentUri\n+            // (see WriteToContentChannel). Only one instance of FileOutputStream can be opened\n+            // in \"write-mode\" so we share the FileOutputStream instance and it's backing\n+            // FileChannel instance.\n+            // https://docs.oracle.com/javase/7/docs/api/java/io/FileOutputStream.html\n+            //\n+            this.contentChannel.writeBlock(blockOffset, block);\n+        } else {\n+            try (RandomAccessFile randomAccessFile = new RandomAccessFile(this.contentUri.getPath(), \"rw\")) {\n+                randomAccessFile.seek(blockOffset);\n+                randomAccessFile.write(block);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * close the content.\n+     *\n+     * @throws IOException if close operation fails", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NjY3NA==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466674", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri the content URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n          \n          \n            \n                 * @param contentUri the URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve", "author": "vcolin7", "createdAt": "2020-06-01T20:19:08Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/WritableContent.java", "diffHunk": "@@ -0,0 +1,253 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.net.Uri;\n+import android.os.ParcelFileDescriptor;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.Closeable;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device to which data can be written.\n+ */\n+final class WritableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+    // Channel to write to the Content if ContentResolver is required to resolve the Content,\n+    // i.e. when useContentResolver == true\n+    private WriteToContentChannel contentChannel;\n+\n+    /**\n+     * Create WritableContent describing a content in the device on which data can be written.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2Njk3Ng==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433466976", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // so that providers that returns subsection of file gets supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.\n          \n          \n            \n                        // so that providers that return subsections of a file are supported.\n          \n          \n            \n                        // The \"r\" (read) mode is used so that the content providers that don't support write can also be consumed.", "author": "vcolin7", "createdAt": "2020-06-01T20:19:45Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n+     *                           the content URI\n+     */\n+    ReadableContent(Context context, Uri contentUri, boolean useContentResolver) {\n+        this.context = context;\n+        this.contentUri = contentUri;\n+        this.useContentResolver = useContentResolver;\n+    }\n+\n+    /**\n+     * Get the {@link Uri} to the content.\n+     *\n+     * @return the content URI\n+     */\n+    Uri getUri() {\n+        return this.contentUri;\n+    }\n+\n+    /**\n+     * Check whether to use {@link android.content.ContentResolver} to resolve the content URI.\n+     *\n+     * @return true if resolving content URI requires content resolver.\n+     */\n+    boolean isUseContentResolver() {\n+        return this.useContentResolver;\n+    }\n+\n+    /**\n+     * Attempt to take persistable read permission on the content.\n+     *\n+     * @throws IllegalStateException if read permission is not granted\n+     */\n+    @MainThread\n+    void takePersistableReadPermission() throws IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.context.getContentResolver()\n+                .takePersistableUriPermission(this.contentUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);\n+            checkPersistableReadGranted();\n+        }\n+    }\n+\n+    /**\n+     * Get the total size of the content in bytes.\n+     *\n+     * @return the content size in bytes\n+     * @throws Throwable if retrieval of content length fails\n+     */\n+    long getLength() throws Throwable {\n+        final long contentLength;\n+        if (this.useContentResolver) {\n+            // https://developer.android.com/training/secure-file-sharing/retrieve-info\n+            final Cursor cursor = this.context.getContentResolver().query(this.contentUri, null, null, null, null);\n+            final int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);\n+            cursor.moveToFirst();\n+            contentLength = cursor.getLong(sizeIndex);\n+        } else {\n+            File file = new File(contentUri.getPath());\n+            contentLength = file.length();\n+        }\n+        if (contentLength == -1) {\n+            throw new Throwable(\"Unable to get size of the content '\" + contentUri + \"'.\");\n+        }\n+        return contentLength;\n+    }\n+\n+    /**\n+     * Read a block of bytes from the content.\n+     *\n+     * @param blockOffset the start offset of the block\n+     * @param blockSize the size of the block\n+     * @return block of bytes in the range [blockOffset, blockOffset + blockSize]\n+     * @throws IOException the IO error when attempting to read\n+     * @throws IllegalStateException if read permission is not granted or revoked\n+     */\n+    byte[] readBlock(int blockOffset, int blockSize) throws IOException, IllegalStateException {\n+        if (this.useContentResolver) {\n+            this.checkPersistableReadGranted();\n+            // ContentResolver::openFileDescriptor works but we use openAssetFileDescriptor\n+            // so that providers that returns subsection of file gets supported.\n+            // The \"r\" (read) mode is used so that the content providers that don't support write can also consumed.", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ2NzE4Nw==", "url": "https://github.com/Azure/azure-sdk-for-android/pull/237#discussion_r433467187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param contentUri the content URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve\n          \n          \n            \n                 * @param contentUri the URI identifying the content\n          \n          \n            \n                 * @param useContentResolver indicates whether to use {@link android.content.ContentResolver} to resolve", "author": "vcolin7", "createdAt": "2020-06-01T20:20:12Z", "path": "sdk/storage/azure-storage-blob/src/main/java/com/azure/android/storage/blob/transfer/ReadableContent.java", "diffHunk": "@@ -0,0 +1,203 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.android.storage.blob.transfer;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.UriPermission;\n+import android.content.res.AssetFileDescriptor;\n+import android.database.Cursor;\n+import android.net.Uri;\n+import android.provider.OpenableColumns;\n+\n+import androidx.annotation.MainThread;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.List;\n+\n+/**\n+ * Package private.\n+ *\n+ * A type that describes a content in the device from which data can be read.\n+ */\n+final class ReadableContent {\n+    private final Context context;\n+    private final Uri contentUri;\n+    private final boolean useContentResolver;\n+\n+    /**\n+     * Create ReadableContent representing a content in the device from which data can be read.\n+     *\n+     * @param context the context\n+     * @param contentUri the content URI identifying the content\n+     * @param useContentResolver indicate whether to use {@link android.content.ContentResolver} to resolve", "originalCommit": "dde79df7c53d9cfd66a21b7368977ba331c7d4c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "710f50b854de3eef4dab2e9637c0703de587be6b", "url": "https://github.com/Azure/azure-sdk-for-android/commit/710f50b854de3eef4dab2e9637c0703de587be6b", "message": "Cleaning up javadoc\n\nCo-authored-by: vcolin7 <vicolina@microsoft.com>", "committedDate": "2020-06-01T22:06:47Z", "type": "commit"}, {"oid": "d1d43844d8519f29a09c8cb127be02607210d632", "url": "https://github.com/Azure/azure-sdk-for-android/commit/d1d43844d8519f29a09c8cb127be02607210d632", "message": "More stable ReadableContent::getLength implementation, rename isUseContentResolver to isUsingContentResolver.", "committedDate": "2020-06-02T01:39:15Z", "type": "commit"}, {"oid": "2d974b2f0779e2cd0c5741dcc4505201f956262f", "url": "https://github.com/Azure/azure-sdk-for-android/commit/2d974b2f0779e2cd0c5741dcc4505201f956262f", "message": "Really passing useContentResolver:true for download(Uri), comment update Content to content", "committedDate": "2020-06-02T01:58:29Z", "type": "commit"}]}