{"pr_number": 1774, "pr_title": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "pr_createdAt": "2020-05-25T15:15:50Z", "pr_url": "https://github.com/apache/hbase/pull/1774", "timeline": [{"oid": "fe5a34849e61172d071f02a74e7b17b064326c54", "url": "https://github.com/apache/hbase/commit/fe5a34849e61172d071f02a74e7b17b064326c54", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-26T10:58:17Z", "type": "forcePushed"}, {"oid": "d286a1593bf1b2e9708315f6d4050009d32c1e0f", "url": "https://github.com/apache/hbase/commit/d286a1593bf1b2e9708315f6d4050009d32c1e0f", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-26T15:39:07Z", "type": "forcePushed"}, {"oid": "3a4e07df969f08994e3c4c5260a346854c098934", "url": "https://github.com/apache/hbase/commit/3a4e07df969f08994e3c4c5260a346854c098934", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-27T04:11:06Z", "type": "forcePushed"}, {"oid": "f3e1b6b393b62f56af3aa3af4ab3f5d36d7defc1", "url": "https://github.com/apache/hbase/commit/f3e1b6b393b62f56af3aa3af4ab3f5d36d7defc1", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-27T15:36:01Z", "type": "forcePushed"}, {"oid": "96ddfca354dcfa322a95a5151a7874d180127f8b", "url": "https://github.com/apache/hbase/commit/96ddfca354dcfa322a95a5151a7874d180127f8b", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-27T15:50:58Z", "type": "forcePushed"}, {"oid": "a0f79e992a0be1aaefc5b01528e6d152201d51b3", "url": "https://github.com/apache/hbase/commit/a0f79e992a0be1aaefc5b01528e6d152201d51b3", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-28T12:57:12Z", "type": "forcePushed"}, {"oid": "805d9f502f4d7aa37eeb780c3f71f9a8432c1b01", "url": "https://github.com/apache/hbase/commit/805d9f502f4d7aa37eeb780c3f71f9a8432c1b01", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-28T14:41:02Z", "type": "forcePushed"}, {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6", "url": "https://github.com/apache/hbase/commit/acc2946b315874fefa45d7853d23a8c2f52741f6", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-28T15:56:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NzMzNA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432057334", "bodyText": "This stuff committed already?", "author": "saintstack", "createdAt": "2020-05-28T19:05:15Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1403,6 +1409,21 @@ private static void deleteFromMetaTable(final Connection connection, final List<\n     }\n   }\n \n+  public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDeleteFrom,\n+    int numReplicasToRemove) {\n+    int absoluteIndex = replicaIndexToDeleteFrom + numReplicasToRemove;\n+    long now = EnvironmentEdgeManager.currentTime();\n+    Delete deleteReplicaLocations = new Delete(metaRow);\n+    for (int i = replicaIndexToDeleteFrom; i < absoluteIndex; i++) {\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getSeqNumColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getStartCodeColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerNameColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getRegionStateColumn(i), now);\n+    }\n+    return deleteReplicaLocations;\n+  }\n+", "originalCommit": "acc2946b315874fefa45d7853d23a8c2f52741f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NDIzMQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432194231", "bodyText": "No. This is for supportting MasterMetaBootstrap. We do not touch this class in the previous PR.", "author": "Apache9", "createdAt": "2020-05-29T00:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NzMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432062550", "bodyText": "Why we need locateType now and not previously?", "author": "saintstack", "createdAt": "2020-05-28T19:15:11Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "originalCommit": "acc2946b315874fefa45d7853d23a8c2f52741f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MzQxOA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432073418", "bodyText": "Why is this not just a case of Scan forward or Scan backward?", "author": "saintstack", "createdAt": "2020-05-28T19:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NDAxNQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432194015", "bodyText": "This is for abstraction, at this layer we do not care whether you are doing scan or what ever else, The only thing I care is how you want to locate a region through the given row, i.e, the direction.\nAnd we have this logic, at least for two years after we introduced async client. If you are talking about the code before async client, the locating logic is placed everywhere in code, which is not good.\nFor supporting reverse scan, we have special logic to locate to the previous region in this class\nhttps://github.com/apache/hbase/blob/branch-2/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ReversedScannerCallable.java", "author": "Apache9", "createdAt": "2020-05-29T00:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjYxOQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436436619", "bodyText": "'abstraction'? IIRC, this class is the access point for hbase:meta. It is all about Scans that take Visitors, Puts, and Deletes against hbase:meta; i.e. not 'abstractions'.", "author": "saintstack", "createdAt": "2020-06-08T02:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzODU0OA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436438548", "bodyText": "hmmm... Went back and saw the locateInMeta.  This replicates the head of that method? It should use this?", "author": "saintstack", "createdAt": "2020-06-08T03:12:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzg1OQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437117859", "bodyText": "We could be better orginzation of these methods in follow on patches, i.e, moving this method to other places to not mess up the MetaTableAccessor. I do not have strong feelings that this method must be put here.", "author": "Apache9", "createdAt": "2020-06-09T03:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432064229", "bodyText": "Two locators. Can we not have one?", "author": "saintstack", "createdAt": "2020-05-28T19:18:27Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "originalCommit": "acc2946b315874fefa45d7853d23a8c2f52741f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NTQ4Nw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432065487", "bodyText": "An AsyncNonMetaTableRegionLocator is for user-space Regions? We also have AsyncRegionLocator... and Abstract* Do we have to have this many classes?", "author": "saintstack", "createdAt": "2020-05-28T19:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5MDEyNw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432190127", "bodyText": "We do have these locators before this patch. Th AsyncRegionLocator is for the general interface to communicate with upper layer, and in the past, we have AsyncMetaRegionLocator and AsyncNonMetaRegionLocator, for dealing with meta table and non meta table.\nIn this patch, the old stuff in AsyncMetaRegionLocator has all been purged, and most of the logic in AsyncNonMetaRegionLocator have been moved to AsyncRegionLocator and AbstractAsyncTableRegionLocator. The latter one is created for sharing code between meta table and non meta table.\nWe can put all these logics in a single class, as all class inherits can also be done by a if in the code. But I think doing this is an anti-pattern in java, as it will introduce very big classes, which is already a big problem in HBase(think of the old AsyncProcess class, it is a nightmare to me...).", "author": "Apache9", "createdAt": "2020-05-29T00:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDM3MQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440371", "bodyText": "Ok. I'm reacting to our Interface => Abstract => Impl tiering.... We do it too often.", "author": "saintstack", "createdAt": "2020-06-08T03:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432075192", "bodyText": "Why we now need type?", "author": "saintstack", "createdAt": "2020-05-28T19:40:02Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "originalCommit": "acc2946b315874fefa45d7853d23a8c2f52741f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4ODEyMQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432188121", "bodyText": "Not now, the locateType is introduced at the same time with async client, for isolating all the locating related logic from upper layer. The magic is to construct different Scan object, with modified startRow, or include/exclude the startRow.\nWe have to support this, one of the most important reason is for supporting reverse scan, where we need to locate the region before the current region, but what we have is the start row of the current region, which is not part of the region before, so we need to use LocateType.BEFORE to get the location.", "author": "Apache9", "createdAt": "2020-05-29T00:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjk4MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436436980", "bodyText": "Has to be an abstract? If so, why?", "author": "saintstack", "createdAt": "2020-06-08T03:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzOTczNQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436439735", "bodyText": "I see, abstract to share code between user-space and meta-space table locators.", "author": "saintstack", "createdAt": "2020-06-08T03:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjYyMA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446446620", "bodyText": "Let me resolve. I see that this is just a move of code. My fault for not knowing this code well enough and realizing it not new.", "author": "saintstack", "createdAt": "2020-06-26T23:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}], "type": "inlineReview"}, {"oid": "960c288329e4f6bf9c918a556e73c927cb03fb2f", "url": "https://github.com/apache/hbase/commit/960c288329e4f6bf9c918a556e73c927cb03fb2f", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region", "committedDate": "2020-05-29T02:12:23Z", "type": "forcePushed"}, {"oid": "d989e78c4264120fb06765f8e7feb6b349c11c02", "url": "https://github.com/apache/hbase/commit/d989e78c4264120fb06765f8e7feb6b349c11c02", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-02T04:19:30Z", "type": "forcePushed"}, {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321", "url": "https://github.com/apache/hbase/commit/0f10bfe7a4c6a852fa56cfa479f62e2123bb5321", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-05T14:39:48Z", "type": "forcePushed"}, {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "url": "https://github.com/apache/hbase/commit/5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-08T02:50:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436432869", "bodyText": "Why we need this? The default is not to return offlined locations (as per the the original method impl). You ask for raw scan if you do want all including offlined.\ns/excludeOfflinedSplitParents/excludeSplitParents/ because split parents are offlined by definition?", "author": "saintstack", "createdAt": "2020-06-08T02:36:15Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/AsyncMetaTableAccessor.java", "diffHunk": "@@ -170,26 +170,27 @@\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-      AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "originalCommit": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNTIzNg==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436435236", "bodyText": "This is async version of\n// What happens here when 1M regions in hbase:meta? This won't scale?\n public static List<Pair<RegionInfo, ServerName>> getTableRegionsAndLocations(", "author": "saintstack", "createdAt": "2020-06-08T02:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTk4Mw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436475983", "bodyText": "At least for snapshot, we need to get the split parent.", "author": "Apache9", "createdAt": "2020-06-08T06:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDEzOQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440139", "bodyText": "Still this new Service? Not ConnectionRegistry?", "author": "saintstack", "createdAt": "2020-06-08T03:22:00Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MasterNotRunningException;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.exceptions.ClientExceptionsUtil;\n+import org.apache.hadoop.hbase.ipc.HBaseRpcController;\n+import org.apache.hadoop.hbase.ipc.ServerNotRunningYetException;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.protobuf.ByteString;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzQ3Ng==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436477476", "bodyText": "Just add two methods to the ClientMetaService, which is used by MasterConnectionRegistry. As said in the design doc, we can implement the logic in ConnectionRegistry, but can be a follow on issue, as we also need to support this in ZKConnectionRegistry, which is not necessary to make things work but will make a patch even bigger...", "author": "Apache9", "createdAt": "2020-06-08T06:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDU0MQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440541", "bodyText": "Whats this? One locator for meta and another for user-space Tables?", "author": "saintstack", "createdAt": "2020-06-08T03:25:04Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -44,25 +51,51 @@\n @InterfaceAudience.Private\n class AsyncRegionLocator {\n \n-  private static final Logger LOG = LoggerFactory.getLogger(AsyncRegionLocator.class);\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE =\n+    \"hbase.client.meta.max.concurrent.locate.per.table\";\n+\n+  private static final int DEFAULT_MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE = 8;\n+\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_META_REQUEST =\n+    \"hbase.client.meta.max.concurrent.locate\";\n+\n+  @VisibleForTesting\n+  static String LOCATE_PREFETCH_LIMIT = \"hbase.client.locate.prefetch.limit\";\n+\n+  private static final int DEFAULT_LOCATE_PREFETCH_LIMIT = 10;\n \n   private final HashedWheelTimer retryTimer;\n \n   private final AsyncConnectionImpl conn;\n \n-  private final AsyncMetaRegionLocator metaRegionLocator;\n+  private final int maxConcurrentLocateRequestPerTable;\n+\n+  private final int maxConcurrentLocateMetaRequest;\n+\n+  private final int locatePrefetchLimit;\n \n-  private final AsyncNonMetaRegionLocator nonMetaRegionLocator;\n+  private final boolean useMetaReplicas;\n \n-  AsyncRegionLocator(AsyncConnectionImpl conn, HashedWheelTimer retryTimer) {\n+  private final ConcurrentMap<TableName, AbstractAsyncTableRegionLocator> table2Locator =", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Nzk4OA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436477988", "bodyText": "Every table will have a locator. The cache is in the locator, and the concurrency locating limit is also implemented per table. We make it abstract is because we use different ways to locate meta and other table regions.", "author": "Apache9", "createdAt": "2020-06-08T06:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTU2MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436441560", "bodyText": "Just removed. We trying to add api in here https://docs.google.com/document/d/1OYrCfpmmLPkSa5-AepQw8hv09zNcNPaFzSXezhcMS7E/edit?ts=5ed4e463#heading=h.kxnc4cup53tk", "author": "saintstack", "createdAt": "2020-06-08T03:30:33Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -31,11 +30,6 @@\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n-  /**\n-   * Get the location of meta region(s).\n-   */\n-  CompletableFuture<RegionLocations> getMetaRegionLocations();", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MjA5MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436482090", "bodyText": "Can do this in https://issues.apache.org/jira/browse/HBASE-24459", "author": "Apache9", "createdAt": "2020-06-08T06:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTY3Mg==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436441672", "bodyText": "Not used any more?", "author": "saintstack", "createdAt": "2020-06-08T03:31:08Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -186,24 +186,6 @@ public long getNonceGroup() {\n     return Arrays.copyOf(row, row.length + 1);\n   }\n \n-  /**\n-   * Create a row before the specified row and very close to the specified row.\n-   */\n-  static byte[] createCloseRowBefore(byte[] row) {\n-    if (row.length == 0) {\n-      return MAX_BYTE_ARRAY;\n-    }\n-    if (row[row.length - 1] == 0) {\n-      return Arrays.copyOf(row, row.length - 1);\n-    } else {\n-      byte[] nextRow = new byte[row.length + MAX_BYTE_ARRAY.length];\n-      System.arraycopy(row, 0, nextRow, 0, row.length - 1);\n-      nextRow[row.length - 1] = (byte) ((row[row.length - 1] & 0xFF) - 1);\n-      System.arraycopy(MAX_BYTE_ARRAY, 0, nextRow, row.length, MAX_BYTE_ARRAY.length);\n-      return nextRow;\n-    }\n-  }\n-", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436442240", "bodyText": "Having trouble following what is going on. Excuse me.\nThis looks better. Gets RegionLocator from Connection.", "author": "saintstack", "createdAt": "2020-06-08T03:35:07Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjMyNw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436442327", "bodyText": "RegionLocator does the right thing based off table name?", "author": "saintstack", "createdAt": "2020-06-08T03:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MzM3Mg==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436483372", "bodyText": "The problem is that, for meta table we can not use the methods from ConnectionRegistry any more as now we could have multiple meta regions, so we change to use RegionLocator, and the RegionLocator could also deal with normal tables, so here we can unify them together.", "author": "Apache9", "createdAt": "2020-06-08T06:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1Mzc3MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437053770", "bodyText": "Looks good.", "author": "saintstack", "createdAt": "2020-06-08T23:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436443202", "bodyText": "Why is this wanted in proto now if we had it since async came in?", "author": "saintstack", "createdAt": "2020-06-08T03:40:24Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3537,4 +3538,30 @@ public static RSGroupInfo toGroupInfo(RSGroupProtos.RSGroupInfo proto) {\n     return RSGroupProtos.RSGroupInfo.newBuilder().setName(pojo.getName()).addAllServers(hostports)\n         .addAllTables(tables).build();\n   }\n+\n+  public static MasterProtos.RegionLocateType toProtoRegionLocateType(RegionLocateType pojo) {\n+    switch (pojo) {\n+      case BEFORE:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_BEFORE;\n+      case CURRENT:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_CURRENT;\n+      case AFTER:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown RegionLocateType: \" + pojo);\n+    }\n+  }\n+\n+  public static RegionLocateType toRegionLocateType(MasterProtos.RegionLocateType proto) {\n+    switch (proto) {\n+      case REGION_LOCATE_TYPE_BEFORE:\n+        return RegionLocateType.BEFORE;\n+      case REGION_LOCATE_TYPE_CURRENT:\n+        return RegionLocateType.CURRENT;\n+      case REGION_LOCATE_TYPE_AFTER:\n+        return RegionLocateType.AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown proto RegionLocateType: \" + proto);\n+    }\n+  }", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg1Ng==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436487856", "bodyText": "Because we introduced two new methods for locating meta? We do not need this before when locating meta, as there is only one meta region. And for locating normal regions, the code for supporting this 'locateType' is at client side, as we will scan the meta table. The 'locateType' will only effect the value of the startKey and also the inclusive/exclusive of the startKey.\nAnd here, as explained several times, I do not want to add full scan support when locating meta, so we have to pass the locateType as a parameter.", "author": "Apache9", "createdAt": "2020-06-08T06:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MzE0MQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437053141", "bodyText": "Could you transport this as a Scan? Convert the 'simple API' into a Scan behind the scenes so we don't have to do stuff like this?\n(I hear you on not wanting to support full Scan and have some sympathy but I am kicking against a simple API that seems arbitrary and unsatisfactory -- hence the questions. Pardon if annoying... also trying to figure what is going on in here... Takes me a while. I'm slow. Thanks).", "author": "saintstack", "createdAt": "2020-06-08T23:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDM4NA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444384", "bodyText": "This is hard-coding Master as host of hbase:meta locations?\nWe have MasterRegistry and the ZKRegistry and but Master is host for all meta locations? This skirts Registry?", "author": "saintstack", "createdAt": "2020-06-08T03:47:35Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/MasterObserver.java", "diffHunk": "@@ -1763,4 +1765,44 @@ default void preHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment>\n   default void postHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment> ctx,\n       String userName, List<Permission> permissions) throws IOException {\n   }\n+\n+  /**\n+   * Called before locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   */\n+  default void preLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType) throws IOException {\n+  }\n+\n+  /**\n+   * Called after locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   * @param locs the locations of the given meta region, including meta replicas if any.\n+   */\n+  default void postLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType, List<HRegionLocation> locs) throws IOException {\n+  }\n+\n+  /**\n+   * Called before getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   */\n+  default void preGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents) {\n+  }\n+\n+  /**\n+   * Called after getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @param locs the locations of all meta regions, including meta replicas if any.\n+   */\n+  default void postGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents, List<HRegionLocation> locs) {\n+  }", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTYzNQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436485635", "bodyText": "These ConnectionRegistries are only used at client side, not for master side. Before this patch, we just store the location of meta in zk, which is also hard coded at master.", "author": "Apache9", "createdAt": "2020-06-08T06:44:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444570", "bodyText": "Region State is in zk?", "author": "saintstack", "createdAt": "2020-06-08T03:48:48Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -868,8 +879,71 @@ protected void initializeZKBasedSystemTrackers()\n \n   // Will be overriden in test to inject customized AssignmentManager\n   @VisibleForTesting\n-  protected AssignmentManager createAssignmentManager(MasterServices master) {\n-    return new AssignmentManager(master);\n+  protected AssignmentManager createAssignmentManager(MasterServices master,\n+    MasterRegion masterRegion) {\n+    return new AssignmentManager(master, masterRegion);\n+  }\n+\n+  /**\n+   * Load the meta region state from the meta region server ZNode.\n+   * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation\n+   * @param replicaId the ID of the replica\n+   * @return regionstate\n+   * @throws KeeperException if a ZooKeeper operation fails\n+   */\n+  private static RegionState getMetaRegionState(ZKWatcher zkw, int replicaId)", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDY0OA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444648", "bodyText": "Perhaps this is old state? If so, maybe say so in doc?\nThe @return regionstate can be removed.", "author": "saintstack", "createdAt": "2020-06-08T03:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjA2NQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436486065", "bodyText": "For migrating the meta location from zk to the new local root table.", "author": "Apache9", "createdAt": "2020-06-08T06:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTA4MQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436445081", "bodyText": "Don't understand.", "author": "saintstack", "createdAt": "2020-06-08T03:51:48Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436445413", "bodyText": "This stuff is inline in HMaster class? Not out in Meta Table Accessor?", "author": "saintstack", "createdAt": "2020-06-08T03:53:38Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTM1MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436489350", "bodyText": "The logic is similar, that's why I also use several methods from MetaTableAccessor. But here we are scanning a region, not a table, so the API is a bit different. And at client side, now we will use the async API, which is also a bit different. You can see AsyncNonMetaTableRegionLocator.onScanNext.", "author": "Apache9", "createdAt": "2020-06-08T06:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MzE4OA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437043188", "bodyText": "MasterRegion deserves own accessor. MasterRegionAccessor", "author": "saintstack", "createdAt": "2020-06-08T22:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3Nzc3MQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437077771", "bodyText": "Can do this in a follow on issue? And the difference here is that, MasterRegion is not only used as root table, it is also usedas procedure store, which does not have the same access pattern.", "author": "Apache9", "createdAt": "2020-06-09T00:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NjQ4Nw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437876487", "bodyText": "Can be follow-on.", "author": "saintstack", "createdAt": "2020-06-10T05:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTcwNQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437021705", "bodyText": "master local region", "author": "saintstack", "createdAt": "2020-06-08T21:51:23Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "diffHunk": "@@ -2319,17 +2317,13 @@ private boolean skipReportingTransition(final RegionStateTransitionContext conte\n     if (code == TransitionCode.OPENED) {\n       Preconditions.checkArgument(hris != null && hris.length == 1);\n       if (hris[0].isMetaRegion()) {\n-        try {\n-          MetaTableLocator.setMetaLocation(getZooKeeper(), serverName,\n-              hris[0].getReplicaId(), RegionState.State.OPEN);\n-        } catch (KeeperException e) {\n-          LOG.info(\"Failed to update meta location\", e);\n-          return false;\n-        }\n+        LOG.warn(\n+          \"meta table location is stored in master local store, so we can not skip reporting\");", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437026028", "bodyText": "TABLENAME is 'master:store'. Should it be 'master:region'? Configs are hbase.master.store.region.* which is odd given we usually talk of region having a store, not other way around.", "author": "saintstack", "createdAt": "2020-06-08T22:02:02Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "diffHunk": "@@ -80,6 +83,10 @@\n   public static final byte[] PROC_FAMILY = Bytes.toBytes(\"proc\");", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjY0Ng==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437026646", "bodyText": "Too late to changes this?", "author": "saintstack", "createdAt": "2020-06-08T22:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODMxOA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437078318", "bodyText": "I think the 'store' here does not mean HRegion, it is something like the 'ProcedureStore'.", "author": "Apache9", "createdAt": "2020-06-09T00:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwMDkxNQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437100915", "bodyText": "Maybe later we have other implementations then we will change the configs to hbase.master.store.<alternate implementation>,*", "author": "Apache9", "createdAt": "2020-06-09T02:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNzE0Ng==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437027146", "bodyText": "We don't need to make sure meta is available first anymore? Or is this because we might be doing create meta table with this procedure going forward?", "author": "saintstack", "createdAt": "2020-06-08T22:04:56Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/CreateTableProcedure.java", "diffHunk": "@@ -365,8 +365,6 @@ protected static void moveTempDirectoryToHBaseRoot(\n       final List<RegionInfo> regions) throws IOException {\n     assert (regions != null && regions.size() > 0) : \"expected at least 1 region, got \" + regions;\n \n-    ProcedureSyncWait.waitMetaRegions(env);", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MTE5OQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437081199", "bodyText": "If we have multiple meta regions, I do not think it is a good idea to wait for them all being online? And the implementation will be much cmore omplicated, as in the past we just need a simple event and setMetaAssigned and setMetaUnassigned. But if we have multiple meta regions, we need to know the exact count of meta regions and do counting here?And we also need to deal with split/merge which could change the count.", "author": "Apache9", "createdAt": "2020-06-09T01:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NjE0NQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437876145", "bodyText": "Ok. Work to do here.", "author": "saintstack", "createdAt": "2020-06-10T05:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzOTMyMw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437039323", "bodyText": "Does MasterRegistry put meta location in zk?  If not, we'd mirror to zk here anyways even if we are using MasterRegistry?", "author": "saintstack", "createdAt": "2020-06-08T22:37:27Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "diffHunk": "@@ -224,23 +229,52 @@ public void start() throws IOException, KeeperException {\n     // Start the Assignment Thread\n     startAssignmentThread();\n \n-    // load meta region state\n-    ZKWatcher zkw = master.getZooKeeper();\n-    // it could be null in some tests\n-    if (zkw != null) {\n-      RegionState regionState = MetaTableLocator.getMetaRegionState(zkw);\n-      RegionStateNode regionNode =\n-        regionStates.getOrCreateRegionStateNode(RegionInfoBuilder.FIRST_META_REGIONINFO);\n-      regionNode.lock();\n-      try {\n-        regionNode.setRegionLocation(regionState.getServerName());\n-        regionNode.setState(regionState.getState());\n-        if (regionNode.getProcedure() != null) {\n-          regionNode.getProcedure().stateLoaded(this, regionNode);\n+    // load meta region states.\n+    // notice that, here we will load all replicas, and in MasterMetaBootstrap we may assign new\n+    // replicas, or remove excess replicas.\n+    try (RegionScanner scanner =\n+      masterRegion.getScanner(new Scan().addFamily(HConstants.CATALOG_FAMILY))) {\n+      List<Cell> cells = new ArrayList<>();\n+      boolean moreRows;\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n         }\n-        setMetaAssigned(regionState.getRegion(), regionState.getState() == State.OPEN);\n-      } finally {\n-        regionNode.unlock();\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionStateStore\n+          .visitMetaEntry((r, regionInfo, state, regionLocation, lastHost, openSeqNum) -> {\n+            RegionStateNode regionNode = regionStates.getOrCreateRegionStateNode(regionInfo);\n+            regionNode.lock();\n+            try {\n+              regionNode.setState(state);\n+              regionNode.setLastHost(lastHost);\n+              regionNode.setRegionLocation(regionLocation);\n+              regionNode.setOpenSeqNum(openSeqNum);\n+              if (regionNode.getProcedure() != null) {\n+                regionNode.getProcedure().stateLoaded(this, regionNode);\n+              }\n+              if (RegionReplicaUtil.isDefaultReplica(regionInfo)) {\n+                setMetaAssigned(regionInfo, state == State.OPEN);\n+              }\n+            } finally {\n+              regionNode.unlock();\n+            }\n+            if (regionInfo.isFirst()) {\n+              // for compatibility, mirror the meta region state to zookeeper\n+              try {\n+                regionStateStore.mirrorMetaLocation(regionInfo, regionLocation, state);", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODk3MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437078970", "bodyText": "As said earlier, ConnectionRegistry is only a read only interface used at client side, where MasterRegsitry is an implementation of ConnectionRegistry, so it will not write anything to zk. The mirror of the location here is to keep compatible with old clients, where they expect meta location is still on zk.", "author": "Apache9", "createdAt": "2020-06-09T00:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzOTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDUzMg==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437040532", "bodyText": "We'd not get this info from the Connection via Registry? Or is it that this is pure internal to Master? Reads the Master local Region content? If so, why the param? What internal needs this?", "author": "saintstack", "createdAt": "2020-06-08T22:40:57Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterServices.java", "diffHunk": "@@ -552,4 +553,12 @@ default SplitWALManager getSplitWALManager(){\n    * @return The state of the load balancer, or false if the load balancer isn't defined.\n    */\n   boolean isBalancerOn();\n+\n+  /**\n+   * Get locations for all meta regions.\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @return The locations of all the meta regions\n+   */\n+  List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)", "originalCommit": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDI2MA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437080260", "bodyText": "The ConnectionRegistry need to call this method to get the location. I still need to say, ConnectionRegistry is an interface which is only used at client side, it is not something at the bottom to support the cluster. Now the location of meta is stored in a master local region, you have to provide an rpc method for ConnectionRegistry to get the location...\nOn the parameter, maybe we do not need it in the rpc interface, for now, as in the RegionLocator interface there is no way to pass this parameter. But when doing snapshot, we do need to get the split parent. And maybe for HBCK we also need to get these things? Not sure, if you do not like it we can remove it. Can add it back later when necessary.", "author": "Apache9", "createdAt": "2020-06-09T01:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NTUzMw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437875533", "bodyText": "Ok. Helps. I dislike this parameter. It has the smell of 'more' params being needed as we progress... but perhaps not... We have method like this already over in Meta Accessor.", "author": "saintstack", "createdAt": "2020-06-10T05:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDUzMg=="}], "type": "inlineReview"}, {"oid": "1ed7861b942ee6d2ae8e56ad623ddb6ead048fee", "url": "https://github.com/apache/hbase/commit/1ed7861b942ee6d2ae8e56ad623ddb6ead048fee", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-09T03:02:35Z", "type": "forcePushed"}, {"oid": "6a1e44c42318493cf1b013e2ef32e1a2f53e39b8", "url": "https://github.com/apache/hbase/commit/6a1e44c42318493cf1b013e2ef32e1a2f53e39b8", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-21T10:14:09Z", "type": "forcePushed"}, {"oid": "7dfeb080a27e918c0a96b9083e0ca1d61b17cf48", "url": "https://github.com/apache/hbase/commit/7dfeb080a27e918c0a96b9083e0ca1d61b17cf48", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-24T15:08:03Z", "type": "forcePushed"}, {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "url": "https://github.com/apache/hbase/commit/ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-25T15:27:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTgwMA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446441800", "bodyText": "nit... should be LocateRegionType to match the method names in here.", "author": "saintstack", "createdAt": "2020-06-26T22:47:19Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/CatalogFamilyFormat.java", "diffHunk": "@@ -363,4 +370,27 @@ public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDelet\n     }\n     return deleteReplicaLocations;\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {", "originalCommit": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTU5NA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471594", "bodyText": "You mean the 'RegionLocateType'? Or just change the method name?", "author": "Apache9", "createdAt": "2020-06-27T02:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MzU0Mw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446443543", "bodyText": "Trying to understand why we need to support this flag excludeOfflinedSplitParents\nSnapshots need it? Are we trying to support snapshotting hbase:meta table?\nI was going to suggest we not do this but thinking on it, it is probably a useful utility to have.", "author": "saintstack", "createdAt": "2020-06-26T22:54:36Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ClientMetaTableAccessor.java", "diffHunk": "@@ -164,26 +164,27 @@ private ClientMetaTableAccessor() {\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "originalCommit": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTUxOA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471518", "bodyText": "At least in the Snapshot related code, we have special support for meta table. So at master side, we need to expose this parameter. On whether to expose this parameter at RPC level, I'm not sure yet. In the current design, the cache server will use the rpc method to fetch all the records in root table, maybe it is good to set this parameter to true so they will get all the records? Not sure.", "author": "Apache9", "createdAt": "2020-06-27T02:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446444671", "bodyText": "Why TableRegion rather than Region? The 'Table' is redundant and makes this class name a mouthful?", "author": "saintstack", "createdAt": "2020-06-26T22:59:30Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {", "originalCommit": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjI3Mw==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446446273", "bodyText": "I see you are doing this....\ndelete mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaRegionLocator.java\ncreate mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java\n.... you want to create new classes rather than just replace the old and the TableRegion is how you distingush the new set?", "author": "saintstack", "createdAt": "2020-06-26T23:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTQxMA==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471410", "bodyText": "The AbstractAsyncTableRegionLocator has a cache in it, for caching the location of regions of a table. That's why I added a 'Table' in the class name.", "author": "Apache9", "createdAt": "2020-06-27T02:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0ODc2Ng==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446448766", "bodyText": "Can't return an Interface rather than Abstract class?", "author": "saintstack", "createdAt": "2020-06-26T23:18:23Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -85,26 +118,41 @@ private boolean isMeta(TableName tableName) {\n     return TableName.isMetaTableName(tableName);\n   }\n \n+  private AbstractAsyncTableRegionLocator getOrCreateTableRegionLocator(TableName tableName) {", "originalCommit": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTY0Mg==", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471642", "bodyText": "This is internal so just use the implementation class directly. Can have an interface later if we think it is useful.", "author": "Apache9", "createdAt": "2020-06-27T02:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0ODc2Ng=="}], "type": "inlineReview"}, {"oid": "3da81b243c404194dab6dda8ef71be1144733067", "url": "https://github.com/apache/hbase/commit/3da81b243c404194dab6dda8ef71be1144733067", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-27T04:06:21Z", "type": "commit"}, {"oid": "3da81b243c404194dab6dda8ef71be1144733067", "url": "https://github.com/apache/hbase/commit/3da81b243c404194dab6dda8ef71be1144733067", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "committedDate": "2020-06-27T04:06:21Z", "type": "forcePushed"}]}