{"pr_number": 2009, "pr_title": "HBASE-21596 Delete for a specific cell version can bring back version\u2026", "pr_createdAt": "2020-07-01T09:29:58Z", "pr_url": "https://github.com/apache/hbase/pull/2009", "timeline": [{"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7", "url": "https://github.com/apache/hbase/commit/b1456fa439f98e96d04eb4c60bd35ab6aabd60a7", "message": "HBASE-21596 Delete for a specific cell version can bring back versions above VERSIONS limit", "committedDate": "2020-07-01T09:20:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxNDgxNQ==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448314815", "bodyText": "nit: private ?", "author": "virajjasani", "createdAt": "2020-07-01T12:01:51Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,", "originalCommit": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDA1Mg==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650052", "bodyText": "Had not done previously because original method modified was package private. Doing now.", "author": "wchevreuil", "createdAt": "2020-07-03T16:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxNDgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMjQ3OQ==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448322479", "bodyText": "nit: we can wrap it with ArrayList constructor: new ArrayList<>(deleteCells);", "author": "virajjasani", "createdAt": "2020-07-01T12:17:22Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);", "originalCommit": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDA5Ng==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650096", "bodyText": "Yes.", "author": "wchevreuil", "createdAt": "2020-07-03T16:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyNDkyNA==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448324924", "bodyText": "result sorting doesn't seem useful for this condition. Can we avoid sorting for this?\nif (result.size() < count) {\n..\n..\n  deleteCells.addAll(cells);\n  return;\n}\n\nresult.sort();\n\nif (result.size() > count){\n..\n..\n}else{\n..\n}\ndeleteCells.addAll(cells);", "author": "virajjasani", "createdAt": "2020-07-01T12:22:12Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    result.sort((cell1, cell2) -> {\n+      if(cell1.getTimestamp()>cell2.getTimestamp()){\n+        return -1;\n+      } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+        return 1;\n+      } else {\n+        if(CellUtil.isDelete(cell1)){\n+          return -1;\n+        } else if (CellUtil.isDelete(cell2)){\n+          return 1;\n+        }\n+      }\n+      return 0;\n+    });\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {", "originalCommit": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDE0OA==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650148", "bodyText": "Yes.", "author": "wchevreuil", "createdAt": "2020-07-03T16:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyNDkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMzNjE1Ng==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448336156", "bodyText": "Should we not deepClone cell, update timestamp and then add that cloned cell to cells list similar to above branch?", "author": "virajjasani", "createdAt": "2020-07-01T12:42:55Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    result.sort((cell1, cell2) -> {\n+      if(cell1.getTimestamp()>cell2.getTimestamp()){\n+        return -1;\n+      } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+        return 1;\n+      } else {\n+        if(CellUtil.isDelete(cell1)){\n+          return -1;\n+        } else if (CellUtil.isDelete(cell2)){\n+          return 1;\n+        }\n+      }\n+      return 0;\n+    });\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {\n       // Nothing to delete\n       PrivateCellUtil.updateLatestStamp(cell, byteNow);\n-      return;\n-    }\n-    if (result.size() > count) {\n-      throw new RuntimeException(\"Unexpected size: \" + result.size());\n+      cells.add(cell);\n+      deleteCells.addAll(cells);\n+    } else if (result.size() > count) {\n+      int currentVersion = 0;\n+      long latestCellTS = Long.MAX_VALUE;\n+      for(Cell getCell : result){\n+        if(!(CellUtil.matchingFamily(getCell, cell) && CellUtil.matchingQualifier(getCell, cell))){\n+          continue;\n+        }\n+        if(!PrivateCellUtil.isDeleteType(getCell) && getCell.getTimestamp()!=latestCellTS){\n+          if (currentVersion >= maxVersions) {\n+            Cell tempCell = null;\n+            try {\n+              tempCell = PrivateCellUtil.deepClone(cell);\n+            } catch (CloneNotSupportedException e) {\n+              throw new IOException(e);\n+            }\n+            PrivateCellUtil.setTimestamp(tempCell, getCell.getTimestamp());\n+            cells.add(tempCell);\n+          } else if (currentVersion == 0) {\n+            PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+            cells.add(cell);\n+          }\n+          currentVersion++;\n+        }\n+        latestCellTS = getCell.getTimestamp();\n+      }\n+\n+    } else {\n+      Cell getCell = result.get(0);\n+      PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+      cells.add(cell);", "originalCommit": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDY4MA==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650680", "bodyText": "It's been a while since I originally proposed this patch, but IIRC we don't need it here, because there's no extra version to fabricate a new delete marker.", "author": "wchevreuil", "createdAt": "2020-07-03T16:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMzNjE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMzODcyMQ==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448338721", "bodyText": "Would you prefer using a boolean to make single call to updateDeleteLatestVersionTimestamp?\n          boolean updateDelTs=false;\n          if (coprocessorHost != null) {\n            if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                byteNow, get)) {\n              updateDelTs=true;\n            }\n          } else {\n            updateDelTs=true;\n          }\n          if(updateDelTs){\n            updateDeleteLatestVersionTimestamp(cell, get, count,\n              this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n              byteNow, deleteCells);\n          }\n\nOnly if you feel this is more readable :)", "author": "virajjasani", "createdAt": "2020-07-01T12:47:45Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }", "originalCommit": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9137fc7d36f5065ced735440939a016544809d46", "url": "https://github.com/apache/hbase/commit/9137fc7d36f5065ced735440939a016544809d46", "message": "Fixing previous failed tests and addressing review comments", "committedDate": "2020-07-03T16:23:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg2MzYxMQ==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449863611", "bodyText": "I am not sure if sorting of result is required here. If not required, rest looks good.", "author": "virajjasani", "createdAt": "2020-07-05T10:55:53Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,87 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  private void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {\n       // Nothing to delete\n       PrivateCellUtil.updateLatestStamp(cell, byteNow);\n-      return;\n-    }\n-    if (result.size() > count) {\n-      throw new RuntimeException(\"Unexpected size: \" + result.size());\n+      cells.add(cell);\n+      deleteCells.addAll(cells);\n+    } else if (result.size() > count) {\n+      int currentVersion = 0;\n+      long latestCellTS = Long.MAX_VALUE;\n+      result.sort((cell1, cell2) -> {\n+        if(cell1.getTimestamp()>cell2.getTimestamp()){\n+          return -1;\n+        } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+          return 1;\n+        } else {\n+          if(CellUtil.isDelete(cell1)){\n+            return -1;\n+          } else if (CellUtil.isDelete(cell2)){\n+            return 1;\n+          }\n+        }\n+        return 0;\n+      });\n+      for(Cell getCell : result){\n+        if(!(CellUtil.matchingFamily(getCell, cell) && CellUtil.matchingQualifier(getCell, cell))){\n+          continue;\n+        }\n+        if(!PrivateCellUtil.isDeleteType(getCell) && getCell.getTimestamp()!=latestCellTS){\n+          if (currentVersion >= maxVersions) {\n+            Cell tempCell = null;\n+            try {\n+              tempCell = PrivateCellUtil.deepClone(cell);\n+            } catch (CloneNotSupportedException e) {\n+              throw new IOException(e);\n+            }\n+            PrivateCellUtil.setTimestamp(tempCell, getCell.getTimestamp());\n+            cells.add(tempCell);\n+          } else if (currentVersion == 0) {\n+            PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+            cells.add(cell);\n+          }\n+          currentVersion++;\n+        }\n+        latestCellTS = getCell.getTimestamp();\n+      }\n+\n+    } else {\n+      Cell getCell = result.get(0);", "originalCommit": "9137fc7d36f5065ced735440939a016544809d46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyOTE5Ng==", "url": "https://github.com/apache/hbase/pull/2009#discussion_r450329196", "bodyText": "It's not needed, because we don't have to worry about additional versions, we only need to put a single marker for current TS.", "author": "wchevreuil", "createdAt": "2020-07-06T16:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg2MzYxMQ=="}], "type": "inlineReview"}]}