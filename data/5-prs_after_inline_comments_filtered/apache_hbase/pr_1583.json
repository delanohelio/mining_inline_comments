{"pr_number": 1583, "pr_title": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor", "pr_createdAt": "2020-04-24T19:35:46Z", "pr_url": "https://github.com/apache/hbase/pull/1583", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NDc5NA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414894794", "bodyText": "nit: Move this to the top, make it a preconditions check?", "author": "bharathv", "createdAt": "2020-04-24T22:20:02Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))\n+        ? new String[] { \"sudo\", \"-u\", serviceUser }\n+        : new String[0];\n+    final String command = StringUtils.join(ArrayUtils.addAll(commandPrefix, cmd), \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // TODO: what happens if the intended action was killing a backup master?\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw unsupportedServiceType(service);", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NjU5OA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415986598", "bodyText": "Sure.", "author": "ndimiduk", "createdAt": "2020-04-27T16:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NDc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NjI5MA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414896290", "bodyText": "Is this possible given the check in L72?", "author": "bharathv", "createdAt": "2020-04-24T22:24:09Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTk3Mw==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414991973", "bodyText": "It's possible because HBASE_REGIONSERVER results in new String[0]?", "author": "liuml07", "createdAt": "2020-04-25T06:09:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NjI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NjQ3NQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415986475", "bodyText": "Is this possible given the check in L72?\n\nSeems it's possible someone is running master and region server as different users but in the same group. Obviously not the default.", "author": "ndimiduk", "createdAt": "2020-04-27T16:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NjI5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMjMyOQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r416022329", "bodyText": "Okay.", "author": "bharathv", "createdAt": "2020-04-27T17:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NjI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5Nzc1OA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414897758", "bodyText": "nit: odd indentation", "author": "bharathv", "createdAt": "2020-04-24T22:28:09Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4OTI4MQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415989281", "bodyText": "I don't see it. You don't like the extra newlines?", "author": "ndimiduk", "createdAt": "2020-04-27T17:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5Nzc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMjg1Ng==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r416022856", "bodyText": "I meant, we can condense that to fewer lines.", "author": "bharathv", "createdAt": "2020-04-27T17:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5Nzc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwODIzNw==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r417608237", "bodyText": "Sure, but doesn't readability count for something?", "author": "ndimiduk", "createdAt": "2020-04-29T21:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5Nzc1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NTc0Ng==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r417655746", "bodyText": "What I meant there was if there are more newlines than necessary (early breaks), my opinion is that it doesn't add anything to the readability and just bloats up the code. Again I get its a subjective opinion. I don't mind either way. It was a nitpick anyway.", "author": "bharathv", "createdAt": "2020-04-29T22:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5Nzc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5ODk2MQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414898961", "bodyText": "Don't fully understand this, is there a race?", "author": "bharathv", "createdAt": "2020-04-24T22:31:34Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MTc3OA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415991778", "bodyText": "Yes. The primary use-case is for the process to call kill -9 on itself. If we hold up the RPC waiting for a response, it never comes because the process dies. Then the client retry mechanism sends the RPC again, this time to the new active master, until we run out of masters.\nOur client doesn't let us say \"this RPC is intended for this one host only.\" So we get the above behavior. By making the invocation a set-and-forget, with a delay on execution, I'm giving the RPC a change to ACK back to the client before the host terminates itself.", "author": "ndimiduk", "createdAt": "2020-04-27T17:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMzYwMQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r416023601", "bodyText": "Ah, the kill -9 for chaos monkey.. now I see it. The method name \"shellExecAsync()\" gave an impression that it is a generic shell exec utility. Also I think you added the \"async\" version just so that it acks the RPC and sends a response back. I think we should do one of the following\n\nSince we already have a blocking version and async version is only for kill, a special command (IIUC) rename it to make it more self explanatory?\nIf you don't agree with above, add some comments why this async version exists?", "author": "bharathv", "createdAt": "2020-04-27T17:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY0NjAyMQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r417646021", "bodyText": "I've adjusted names and added comments. Please let me know if the confusion persists.", "author": "ndimiduk", "createdAt": "2020-04-29T22:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5ODk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTA3NA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414899074", "bodyText": "LOG.error?", "author": "bharathv", "createdAt": "2020-04-24T22:31:51Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MjE4NQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415992185", "bodyText": "I don't think interruption is an error. I buy warn though.", "author": "ndimiduk", "createdAt": "2020-04-27T17:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyODUxNA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r416028514", "bodyText": "sg", "author": "bharathv", "createdAt": "2020-04-27T17:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTEyOQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414899129", "bodyText": "LOG.error?", "author": "bharathv", "createdAt": "2020-04-24T22:32:02Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTk5Mw==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414899993", "bodyText": "This doesn't look right to me, shouldn't this be predicated on whether the thread above is successful? (You probably need to chain them?.. thenApply()...)", "author": "bharathv", "createdAt": "2020-04-24T22:34:31Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);\n+      }\n+    });\n+    done.run(ShellExecResponse.newBuilder().build());", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MzEwMA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415993100", "bodyText": "See my earlier comment. This isn't async in the CompletableFuture sense. It's a call without a response.", "author": "ndimiduk", "createdAt": "2020-04-27T17:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDYzMg==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414900632", "bodyText": "nit: I think in a true async mode, this should be async too :-)", "author": "bharathv", "createdAt": "2020-04-24T22:36:24Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MDM5Nw==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415990397", "bodyText": "The request is async in that the response is disconnected from the caller. It's more like a \"set-and-forget\" kind of method invocation. We submit the work to the background thread and there's no avenue for the caller to see the results.", "author": "ndimiduk", "createdAt": "2020-04-27T17:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDk4MQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414900981", "bodyText": "LOG.err()", "author": "bharathv", "createdAt": "2020-04-24T22:37:30Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);\n+      }\n+    });\n+    done.run(ShellExecResponse.newBuilder().build());\n+  }\n+\n+  private Shell.ShellCommandExecutor prepareShell(\n+    final ShellExecRequest request,\n+    final boolean async\n+  ) {\n+    final String command = request.getCommand();\n+    if (StringUtils.isBlank(command)) {\n+      throw new RuntimeException(\"Request contained an empty command.\");\n+    }\n+    final String msgFmt = \"Executing command\"\n+      + (async ? \" on a background thread\" : \"\") + \": {}\";\n+    LOG.info(msgFmt, command);\n+    final String[] subShellCmd = new String[] { \"/usr/bin/env\", \"bash\", \"-c\", command };\n+    return new Shell.ShellCommandExecutor(subShellCmd);\n+  }\n+\n+  private ShellExecResponse.Builder doExec(\n+    final Shell.ShellCommandExecutor shell,\n+    final ShellExecResponse.Builder builder\n+  ) throws IOException {\n+    try {\n+      shell.execute();\n+      builder\n+        .setExitCode(shell.getExitCode())\n+        .setStdout(shell.getOutput());\n+    } catch (Shell.ExitCodeException e) {\n+      LOG.info(\"Launched process failed\", e);", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MzMyNA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415993324", "bodyText": "Yep.", "author": "ndimiduk", "createdAt": "2020-04-27T17:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjMwNQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414902305", "bodyText": "How about reading back using a coprocessorCommand too? that checks the stdout codepaths (cat foo)", "author": "bharathv", "createdAt": "2020-04-24T22:41:36Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Test for the {@link ShellExecCoproc}.\n+ */\n+@Category(MediumTests.class)\n+public class TestShellExecCoproc {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestShellExecCoproc.class);\n+\n+  @ClassRule\n+  public static final MiniClusterRule miniClusterRule = MiniClusterRule.newBuilder()\n+    .setConfiguration(createConfiguration())\n+    .build();\n+\n+  @Rule\n+  public final ConnectionRule connectionRule =\n+    new ConnectionRule(miniClusterRule::createConnection);\n+\n+  @Test\n+  public void testShellExec() {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final String command = \"echo -n \\\"hello world\\\"\";\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    final ShellExecResponse resp = admin\n+      .<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+        ShellExecService::newStub,\n+        (stub, controller, callback) -> stub.shellExec(controller, req, callback))\n+      .join();\n+    assertEquals(0, resp.getExitCode());\n+    assertEquals(\"hello world\", resp.getStdout());\n+  }\n+\n+  @Test\n+  public void testShellExecAsync() throws IOException {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final File testDataDir = ensureTestDataDirExists(miniClusterRule.getTestingUtility());\n+    final File testFile = new File(testDataDir, \"shell_exec_async.txt\");\n+    assertTrue(testFile.createNewFile());\n+    assertEquals(0, testFile.length());\n+\n+    final String command = \"echo \\\"hello world\\\" >> \" + testFile.getAbsolutePath();\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    admin.<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+      ShellExecService::newStub,\n+      (stub, controller, callback) -> stub.shellExecAsync(controller, req, callback))\n+      .join();\n+\n+    Waiter.waitFor(conn.getConfiguration(), 5_000, () -> testFile.length() > 0);", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTU2Mg==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414991562", "bodyText": "This seems a good idea. Just concerned both testFile and cat can be empty, so...", "author": "liuml07", "createdAt": "2020-04-25T06:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NDU2NA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415994564", "bodyText": "How about reading back using a coprocessorCommand too? that checks the stdout codepaths (cat foo)\n\nThat would be testing the non-\"async\" method, which is out of scope of this test.", "author": "ndimiduk", "createdAt": "2020-04-27T17:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYyNTE5Ng==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r417625196", "bodyText": "This seems a good idea. Just concerned both testFile and cat can be empty, so...\n\nThis could be caught by the final assertEquals at the end of the test.", "author": "ndimiduk", "createdAt": "2020-04-29T21:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3MDMzOQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414970339", "bodyText": "Do we need the command again? Otherwise the output and exit code may not be related to command easily.\nLOG.info(\"Executed remote command: '{}', exit code: {}, output: {}\", command, ...)", "author": "liuml07", "createdAt": "2020-04-25T03:56:06Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))\n+        ? new String[] { \"sudo\", \"-u\", serviceUser }\n+        : new String[0];\n+    final String command = StringUtils.join(ArrayUtils.addAll(commandPrefix, cmd), \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // TODO: what happens if the intended action was killing a backup master?\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw unsupportedServiceType(service);\n+      }\n+\n+      LOG.info(\"Executed remote command, exit code:{} , output:{}\", resp.getExitCode(),", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NzY0NA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415987644", "bodyText": "Depends on if you log the thread name as well. Sure, it doesn't hurt. Although, since we call the async method, there's no response code or output available. Should just truncate the log message.", "author": "ndimiduk", "createdAt": "2020-04-27T17:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3MDMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3Mjk3Ng==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414972976", "bodyText": "Replace hbase.it.shellexeccoproc.async.delay with hbase.it.shellexeccoproc.async.delay.ms so we know this is for milliseconds?", "author": "liuml07", "createdAt": "2020-04-25T04:12:37Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4OTU5Mw==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415989593", "bodyText": "nod", "author": "ndimiduk", "createdAt": "2020-04-27T17:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3Mjk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTMyMw==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414991323", "bodyText": "By\n    final String content = Optional.of(testFile.toPath())\n      .map(val -> {\n        try {\n          return Files.readAllLines(val);\n        } catch (IOException e) {\n          return null;\n        }\n      })\n      .map(val -> StringUtils.join(val, \"\"))\n      .map(String::trim)\n      .orElseThrow(() -> new RuntimeException(\"Unable to parse file content\"));\n    assertEquals(\"hello world\", content);\n\nDo you mean:\n    final String content = new String(Files.readAllBytes(testFile.toPath()));\n    assertEquals(\"hello world\\n\", content);", "author": "liuml07", "createdAt": "2020-04-25T06:05:48Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Test for the {@link ShellExecCoproc}.\n+ */\n+@Category(MediumTests.class)\n+public class TestShellExecCoproc {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestShellExecCoproc.class);\n+\n+  @ClassRule\n+  public static final MiniClusterRule miniClusterRule = MiniClusterRule.newBuilder()\n+    .setConfiguration(createConfiguration())\n+    .build();\n+\n+  @Rule\n+  public final ConnectionRule connectionRule =\n+    new ConnectionRule(miniClusterRule::createConnection);\n+\n+  @Test\n+  public void testShellExec() {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final String command = \"echo -n \\\"hello world\\\"\";\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    final ShellExecResponse resp = admin\n+      .<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+        ShellExecService::newStub,\n+        (stub, controller, callback) -> stub.shellExec(controller, req, callback))\n+      .join();\n+    assertEquals(0, resp.getExitCode());\n+    assertEquals(\"hello world\", resp.getStdout());\n+  }\n+\n+  @Test\n+  public void testShellExecAsync() throws IOException {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final File testDataDir = ensureTestDataDirExists(miniClusterRule.getTestingUtility());\n+    final File testFile = new File(testDataDir, \"shell_exec_async.txt\");\n+    assertTrue(testFile.createNewFile());\n+    assertEquals(0, testFile.length());\n+\n+    final String command = \"echo \\\"hello world\\\" >> \" + testFile.getAbsolutePath();\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    admin.<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+      ShellExecService::newStub,\n+      (stub, controller, callback) -> stub.shellExecAsync(controller, req, callback))\n+      .join();\n+\n+    Waiter.waitFor(conn.getConfiguration(), 5_000, () -> testFile.length() > 0);\n+    final String content = Optional.of(testFile.toPath())", "originalCommit": "d2f14b585778bb1af1158a8da208145f464b2a7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NTA3MA==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415995070", "bodyText": "Well, add in a trim, but yes, I suppose I do. Thanks :)", "author": "ndimiduk", "createdAt": "2020-04-27T17:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTMyMw=="}], "type": "inlineReview"}, {"oid": "aed6fb2b6e3962cefac4512eadc17453b3e60070", "url": "https://github.com/apache/hbase/commit/aed6fb2b6e3962cefac4512eadc17453b3e60070", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution.", "committedDate": "2020-04-29T22:17:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1Njk0Mg==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r417656942", "bodyText": "stdout() could potentially spam the logs? Consider including it a lower logging level.", "author": "bharathv", "createdAt": "2020-04-29T22:47:40Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of coprocessor where possible. Only supports actions taken\n+ * against Master and Region Server hosts.\n+ */\n+@InterfaceAudience.Private\n+@SuppressWarnings(\"unused\") // no way to test this without a distributed cluster.\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+  private static final Set<ServiceType> supportedServices = buildSupportedServicesSet();\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    if (!supportedServices.contains(service)) {\n+      throw unsupportedServiceType(service);\n+    }\n+\n+    // We only support actions vs. Master or Region Server processes. We're issuing those actions\n+    // via the coprocessor that's running within those processes. Thus, there's no support for\n+    // honoring the configured service user.\n+    final String command = StringUtils.join(cmd, \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .setAwaitResponse(false)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // What happens if the intended action was killing a backup master? Right now we have\n+          // no `RestartBackupMasterAction` so it's probably fine.\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw new RuntimeException(\"should not happen\");\n+      }\n+\n+      LOG.info(\"Executed remote command: {}, exit code:{} , output:{}\", command, resp.getExitCode(),", "originalCommit": "aed6fb2b6e3962cefac4512eadc17453b3e60070", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0NjMwOQ==", "url": "https://github.com/apache/hbase/pull/1583#discussion_r418346309", "bodyText": "Sure. Guarded with a conditional.", "author": "ndimiduk", "createdAt": "2020-04-30T23:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1Njk0Mg=="}], "type": "inlineReview"}, {"oid": "7fbbda6aad0083abc8eaf3269da65f36c6e3d231", "url": "https://github.com/apache/hbase/commit/7fbbda6aad0083abc8eaf3269da65f36c6e3d231", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution.", "committedDate": "2020-04-30T23:32:10Z", "type": "forcePushed"}, {"oid": "f8274663b9658486ff5de995557e1a6a3372ee15", "url": "https://github.com/apache/hbase/commit/f8274663b9658486ff5de995557e1a6a3372ee15", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution.\n\nSigned-off-by: Bharath Vissapragada <bharathv@apache.org>", "committedDate": "2020-05-04T17:18:46Z", "type": "commit"}, {"oid": "f8274663b9658486ff5de995557e1a6a3372ee15", "url": "https://github.com/apache/hbase/commit/f8274663b9658486ff5de995557e1a6a3372ee15", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution.\n\nSigned-off-by: Bharath Vissapragada <bharathv@apache.org>", "committedDate": "2020-05-04T17:18:46Z", "type": "forcePushed"}]}