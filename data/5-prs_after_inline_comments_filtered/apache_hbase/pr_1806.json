{"pr_number": 1806, "pr_title": "HBASE-24471 The way we bootstrap meta table is confusing", "pr_createdAt": "2020-05-29T15:07:41Z", "pr_url": "https://github.com/apache/hbase/pull/1806", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NDk4MA==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432674980", "bodyText": "The purpose of this method is to check if rootdir exists right? If it can't get the Path obj, it throws Exception. If config for rootdir is not valid, it throws Exception. However, after assigning clusterId of the object, we don't really need to return path rd (hopefully, it's not getting mutated internally) which was passed in the argument already. I believe this method should be private void checkRootDir(). WDYT?", "author": "virajjasani", "createdAt": "2020-05-29T18:52:52Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java", "diffHunk": "@@ -245,61 +238,56 @@ public ClusterId getClusterId() {\n    *         directory with necessary bootup files).\n    */\n   private Path checkRootDir(final Path rd, final Configuration c, final FileSystem fs)", "originalCommit": "8a7cfbfc5c5aa13566dac2a3c448e5baa6922c16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3NjAxMQ==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432776011", "bodyText": "Indeed, static analysis tells me that this method's return value is never used. Perhaps this is the legacy at some attempt at a fluent style?", "author": "ndimiduk", "createdAt": "2020-05-29T23:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NDk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NzI1MA==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432677250", "bodyText": "Would you like to use placeholders {} for HConstants.HBASE_DIR and rd.toString()? Also, only rd should suffice.", "author": "virajjasani", "createdAt": "2020-05-29T18:57:50Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java", "diffHunk": "@@ -245,61 +238,56 @@ public ClusterId getClusterId() {\n    *         directory with necessary bootup files).\n    */\n   private Path checkRootDir(final Path rd, final Configuration c, final FileSystem fs)\n-      throws IOException {\n+    throws IOException {\n     // If FS is in safe mode wait till out of it.\n     FSUtils.waitOnSafeMode(c, c.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000));\n \n     // Filesystem is good. Go ahead and check for hbase.rootdir.\n+    FileStatus status;\n+    try {\n+      status = fs.getFileStatus(rd);\n+    } catch (FileNotFoundException e) {\n+      status = null;\n+    }\n     try {\n-      if (!fs.exists(rd)) {\n-        fs.mkdirs(rd);\n+      if (status == null) {\n+        if (!fs.mkdirs(rd)) {\n+          throw new IOException(\"Can not create root dir: \" + rd);\n+        }\n         // DFS leaves safe mode with 0 DNs when there are 0 blocks.\n         // We used to handle this by checking the current DN count and waiting until\n         // it is nonzero. With security, the check for datanode count doesn't work --\n         // it is a privileged op. So instead we adopt the strategy of the jobtracker\n         // and simply retry file creation during bootstrap indefinitely. As soon as\n         // there is one datanode it will succeed. Permission problems should have\n         // already been caught by mkdirs above.\n-        FSUtils.setVersion(fs, rd, c.getInt(HConstants.THREAD_WAKE_FREQUENCY,\n-          10 * 1000), c.getInt(HConstants.VERSION_FILE_WRITE_ATTEMPTS,\n-            HConstants.DEFAULT_VERSION_FILE_WRITE_ATTEMPTS));\n+        FSUtils.setVersion(fs, rd, c.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000), c.getInt(\n+          HConstants.VERSION_FILE_WRITE_ATTEMPTS, HConstants.DEFAULT_VERSION_FILE_WRITE_ATTEMPTS));\n       } else {\n-        if (!fs.isDirectory(rd)) {\n-          throw new IllegalArgumentException(rd.toString() + \" is not a directory\");\n+        if (!status.isDirectory()) {\n+          throw new IllegalArgumentException(rd + \" is not a directory\");\n         }\n         // as above\n-        FSUtils.checkVersion(fs, rd, true, c.getInt(HConstants.THREAD_WAKE_FREQUENCY,\n-          10 * 1000), c.getInt(HConstants.VERSION_FILE_WRITE_ATTEMPTS,\n+        FSUtils.checkVersion(fs, rd, true, c.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000),\n+          c.getInt(HConstants.VERSION_FILE_WRITE_ATTEMPTS,\n             HConstants.DEFAULT_VERSION_FILE_WRITE_ATTEMPTS));\n       }\n     } catch (DeserializationException de) {\n-      LOG.error(HBaseMarkers.FATAL, \"Please fix invalid configuration for \"\n-        + HConstants.HBASE_DIR, de);\n+      LOG.error(HBaseMarkers.FATAL, \"Please fix invalid configuration for \" + HConstants.HBASE_DIR,\n+        de);\n       throw new IOException(de);\n     } catch (IllegalArgumentException iae) {\n-      LOG.error(HBaseMarkers.FATAL, \"Please fix invalid configuration for \"\n-        + HConstants.HBASE_DIR + \" \" + rd.toString(), iae);\n+      LOG.error(HBaseMarkers.FATAL,\n+        \"Please fix invalid configuration for \" + HConstants.HBASE_DIR + \" \" + rd.toString(), iae);", "originalCommit": "8a7cfbfc5c5aa13566dac2a3c448e5baa6922c16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDU1OQ==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432680559", "bodyText": "Ok so performing bootstrap as part of the Procedure is the major change. Seems applicable to fresh clusters. \ud83d\udc4d", "author": "virajjasani", "createdAt": "2020-05-29T19:05:04Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/InitMetaProcedure.java", "diffHunk": "@@ -64,41 +72,68 @@ public TableOperationType getTableOperationType() {\n     return TableOperationType.CREATE;\n   }\n \n+  private static void writeFsLayout(Path rootDir, Configuration conf) throws IOException {\n+    LOG.info(\"BOOTSTRAP: creating hbase:meta region\");\n+    FileSystem fs = rootDir.getFileSystem(conf);\n+    Path tableDir = CommonFSUtils.getTableDir(rootDir, TableName.META_TABLE_NAME);\n+    if (fs.exists(tableDir) && !fs.delete(tableDir, true)) {\n+      LOG.warn(\"Can not delete partial created meta table, continue...\");\n+    }\n+    // Bootstrapping, make sure blockcache is off. Else, one will be\n+    // created here in bootstrap and it'll need to be cleaned up. Better to\n+    // not make it in first place. Turn off block caching for bootstrap.\n+    // Enable after.\n+    FSTableDescriptors.tryUpdateMetaTableDescriptor(conf, fs, rootDir,\n+      builder -> builder.setRegionReplication(\n+        conf.getInt(HConstants.META_REPLICAS_NUM, HConstants.DEFAULT_META_REPLICA_NUM)));\n+    TableDescriptor metaDescriptor = new FSTableDescriptors(conf).get(TableName.META_TABLE_NAME);\n+    HRegion\n+      .createHRegion(RegionInfoBuilder.FIRST_META_REGIONINFO, rootDir, conf, metaDescriptor, null)\n+      .close();\n+  }\n+\n   @Override\n   protected Flow executeFromState(MasterProcedureEnv env, InitMetaState state)\n-      throws ProcedureSuspendedException, ProcedureYieldException, InterruptedException {\n+    throws ProcedureSuspendedException, ProcedureYieldException, InterruptedException {\n     LOG.debug(\"Execute {}\", this);\n-    switch (state) {\n-      case INIT_META_ASSIGN_META:\n-        LOG.info(\"Going to assign meta\");\n-        addChildProcedure(env.getAssignmentManager()\n-          .createAssignProcedures(Arrays.asList(RegionInfoBuilder.FIRST_META_REGIONINFO)));\n-        setNextState(InitMetaState.INIT_META_CREATE_NAMESPACES);\n-        return Flow.HAS_MORE_STATE;\n-      case INIT_META_CREATE_NAMESPACES:\n-        LOG.info(\"Going to create {} and {} namespaces\", DEFAULT_NAMESPACE, SYSTEM_NAMESPACE);\n-        try {\n+    try {\n+      switch (state) {\n+        case INIT_META_WRITE_FS_LAYOUT:", "originalCommit": "8a7cfbfc5c5aa13566dac2a3c448e5baa6922c16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3NzQ0Mg==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432777442", "bodyText": "I know it's not your code, but mind unpacking these inline configuration lookups? They're terribly illegible.", "author": "ndimiduk", "createdAt": "2020-05-29T23:10:40Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java", "diffHunk": "@@ -245,61 +238,56 @@ public ClusterId getClusterId() {\n    *         directory with necessary bootup files).\n    */\n   private Path checkRootDir(final Path rd, final Configuration c, final FileSystem fs)\n-      throws IOException {\n+    throws IOException {\n     // If FS is in safe mode wait till out of it.\n     FSUtils.waitOnSafeMode(c, c.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000));\n \n     // Filesystem is good. Go ahead and check for hbase.rootdir.\n+    FileStatus status;\n+    try {\n+      status = fs.getFileStatus(rd);\n+    } catch (FileNotFoundException e) {\n+      status = null;\n+    }\n     try {\n-      if (!fs.exists(rd)) {\n-        fs.mkdirs(rd);\n+      if (status == null) {\n+        if (!fs.mkdirs(rd)) {\n+          throw new IOException(\"Can not create root dir: \" + rd);\n+        }\n         // DFS leaves safe mode with 0 DNs when there are 0 blocks.\n         // We used to handle this by checking the current DN count and waiting until\n         // it is nonzero. With security, the check for datanode count doesn't work --\n         // it is a privileged op. So instead we adopt the strategy of the jobtracker\n         // and simply retry file creation during bootstrap indefinitely. As soon as\n         // there is one datanode it will succeed. Permission problems should have\n         // already been caught by mkdirs above.\n-        FSUtils.setVersion(fs, rd, c.getInt(HConstants.THREAD_WAKE_FREQUENCY,\n-          10 * 1000), c.getInt(HConstants.VERSION_FILE_WRITE_ATTEMPTS,\n-            HConstants.DEFAULT_VERSION_FILE_WRITE_ATTEMPTS));\n+        FSUtils.setVersion(fs, rd, c.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000), c.getInt(", "originalCommit": "8a7cfbfc5c5aa13566dac2a3c448e5baa6922c16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc3Nzk5Mw==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432777993", "bodyText": "How about \"Configured '\" + HConstants.HBASE_DIR + \"' + rd + \" is not a directory.\" ?", "author": "ndimiduk", "createdAt": "2020-05-29T23:13:13Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterFileSystem.java", "diffHunk": "@@ -245,61 +238,56 @@ public ClusterId getClusterId() {\n    *         directory with necessary bootup files).\n    */\n   private Path checkRootDir(final Path rd, final Configuration c, final FileSystem fs)\n-      throws IOException {\n+    throws IOException {\n     // If FS is in safe mode wait till out of it.\n     FSUtils.waitOnSafeMode(c, c.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000));\n \n     // Filesystem is good. Go ahead and check for hbase.rootdir.\n+    FileStatus status;\n+    try {\n+      status = fs.getFileStatus(rd);\n+    } catch (FileNotFoundException e) {\n+      status = null;\n+    }\n     try {\n-      if (!fs.exists(rd)) {\n-        fs.mkdirs(rd);\n+      if (status == null) {\n+        if (!fs.mkdirs(rd)) {\n+          throw new IOException(\"Can not create root dir: \" + rd);\n+        }\n         // DFS leaves safe mode with 0 DNs when there are 0 blocks.\n         // We used to handle this by checking the current DN count and waiting until\n         // it is nonzero. With security, the check for datanode count doesn't work --\n         // it is a privileged op. So instead we adopt the strategy of the jobtracker\n         // and simply retry file creation during bootstrap indefinitely. As soon as\n         // there is one datanode it will succeed. Permission problems should have\n         // already been caught by mkdirs above.\n-        FSUtils.setVersion(fs, rd, c.getInt(HConstants.THREAD_WAKE_FREQUENCY,\n-          10 * 1000), c.getInt(HConstants.VERSION_FILE_WRITE_ATTEMPTS,\n-            HConstants.DEFAULT_VERSION_FILE_WRITE_ATTEMPTS));\n+        FSUtils.setVersion(fs, rd, c.getInt(HConstants.THREAD_WAKE_FREQUENCY, 10 * 1000), c.getInt(\n+          HConstants.VERSION_FILE_WRITE_ATTEMPTS, HConstants.DEFAULT_VERSION_FILE_WRITE_ATTEMPTS));\n       } else {\n-        if (!fs.isDirectory(rd)) {\n-          throw new IllegalArgumentException(rd.toString() + \" is not a directory\");\n+        if (!status.isDirectory()) {\n+          throw new IllegalArgumentException(rd + \" is not a directory\");", "originalCommit": "8a7cfbfc5c5aa13566dac2a3c448e5baa6922c16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzkwNA==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432783904", "bodyText": "The procedures are stored in the LocalStore/LocalRegion. The LocalRegion is backed by ${hbase.rootdir}/MasterData. How can we have a procedure that initializes hbase.rootdir? Isn't this a circular dependency?", "author": "ndimiduk", "createdAt": "2020-05-29T23:42:48Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/InitMetaProcedure.java", "diffHunk": "@@ -64,41 +72,68 @@ public TableOperationType getTableOperationType() {\n     return TableOperationType.CREATE;\n   }\n \n+  private static void writeFsLayout(Path rootDir, Configuration conf) throws IOException {\n+    LOG.info(\"BOOTSTRAP: creating hbase:meta region\");\n+    FileSystem fs = rootDir.getFileSystem(conf);\n+    Path tableDir = CommonFSUtils.getTableDir(rootDir, TableName.META_TABLE_NAME);\n+    if (fs.exists(tableDir) && !fs.delete(tableDir, true)) {\n+      LOG.warn(\"Can not delete partial created meta table, continue...\");\n+    }\n+    // Bootstrapping, make sure blockcache is off. Else, one will be\n+    // created here in bootstrap and it'll need to be cleaned up. Better to\n+    // not make it in first place. Turn off block caching for bootstrap.\n+    // Enable after.\n+    FSTableDescriptors.tryUpdateMetaTableDescriptor(conf, fs, rootDir,\n+      builder -> builder.setRegionReplication(\n+        conf.getInt(HConstants.META_REPLICAS_NUM, HConstants.DEFAULT_META_REPLICA_NUM)));\n+    TableDescriptor metaDescriptor = new FSTableDescriptors(conf).get(TableName.META_TABLE_NAME);\n+    HRegion\n+      .createHRegion(RegionInfoBuilder.FIRST_META_REGIONINFO, rootDir, conf, metaDescriptor, null)\n+      .close();\n+  }\n+\n   @Override\n   protected Flow executeFromState(MasterProcedureEnv env, InitMetaState state)\n-      throws ProcedureSuspendedException, ProcedureYieldException, InterruptedException {\n+    throws ProcedureSuspendedException, ProcedureYieldException, InterruptedException {\n     LOG.debug(\"Execute {}\", this);\n-    switch (state) {\n-      case INIT_META_ASSIGN_META:\n-        LOG.info(\"Going to assign meta\");\n-        addChildProcedure(env.getAssignmentManager()\n-          .createAssignProcedures(Arrays.asList(RegionInfoBuilder.FIRST_META_REGIONINFO)));\n-        setNextState(InitMetaState.INIT_META_CREATE_NAMESPACES);\n-        return Flow.HAS_MORE_STATE;\n-      case INIT_META_CREATE_NAMESPACES:\n-        LOG.info(\"Going to create {} and {} namespaces\", DEFAULT_NAMESPACE, SYSTEM_NAMESPACE);\n-        try {\n+    try {\n+      switch (state) {\n+        case INIT_META_WRITE_FS_LAYOUT:\n+          Configuration conf = env.getMasterConfiguration();\n+          Path rootDir = CommonFSUtils.getRootDir(conf);\n+          writeFsLayout(rootDir, conf);\n+          setNextState(InitMetaState.INIT_META_ASSIGN_META);\n+          return Flow.HAS_MORE_STATE;\n+        case INIT_META_ASSIGN_META:\n+          LOG.info(\"Going to assign meta\");\n+          addChildProcedure(env.getAssignmentManager()", "originalCommit": "8a7cfbfc5c5aa13566dac2a3c448e5baa6922c16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NDgyNw==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432784827", "bodyText": "Oh, it is because you use skipPersistence() down below? The ProcedureExecutor and ProcedureStore can function without the root filesystem being available?", "author": "ndimiduk", "createdAt": "2020-05-29T23:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NjAwOQ==", "url": "https://github.com/apache/hbase/pull/1806#discussion_r432786009", "bodyText": "You misunderstood the goal here...\nThe procedure is 'InitMetaProcedure', not 'InitRootDirProcedure', it is just for initializaing meta table. The code for initializing the root dir is still in MasterFileSystem, what you have reviewed above...", "author": "Apache9", "createdAt": "2020-05-29T23:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzkwNA=="}], "type": "inlineReview"}, {"oid": "1339e98a8fe896594c149ac55e666a68be394a5a", "url": "https://github.com/apache/hbase/commit/1339e98a8fe896594c149ac55e666a68be394a5a", "message": "HBASE-24471 The way we bootstrap meta table is confusing", "committedDate": "2020-05-30T00:42:36Z", "type": "commit"}, {"oid": "1339e98a8fe896594c149ac55e666a68be394a5a", "url": "https://github.com/apache/hbase/commit/1339e98a8fe896594c149ac55e666a68be394a5a", "message": "HBASE-24471 The way we bootstrap meta table is confusing", "committedDate": "2020-05-30T00:42:36Z", "type": "forcePushed"}]}