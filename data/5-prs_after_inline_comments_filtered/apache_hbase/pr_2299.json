{"pr_number": 2299, "pr_title": "HBASE-24620 : Add a ClusterManager which submits command to ZooKeeper and its Agent which picks and execute those Commands.", "pr_createdAt": "2020-08-24T08:49:36Z", "pr_url": "https://github.com/apache/hbase/pull/2299", "timeline": [{"oid": "dfb7c413baa5f8b97bdd02110ccbf6f26efea478", "url": "https://github.com/apache/hbase/commit/dfb7c413baa5f8b97bdd02110ccbf6f26efea478", "message": "Adding Destructive Chaos Functionality through ZK", "committedDate": "2020-08-24T08:47:13Z", "type": "commit"}, {"oid": "0b6d4152ac14016c8bf0cdba086dbdb7f4c33257", "url": "https://github.com/apache/hbase/commit/0b6d4152ac14016c8bf0cdba086dbdb7f4c33257", "message": "Adding license and removing -1's", "committedDate": "2020-08-24T14:07:58Z", "type": "commit"}, {"oid": "58a45a79f85cb91a8584a7b45efbde134faee4cf", "url": "https://github.com/apache/hbase/commit/58a45a79f85cb91a8584a7b45efbde134faee4cf", "message": "Adding InterfacrAudience", "committedDate": "2020-08-24T19:08:09Z", "type": "commit"}, {"oid": "266d467ddcb27d8675b3b6ec29f6962e5e9a9847", "url": "https://github.com/apache/hbase/commit/266d467ddcb27d8675b3b6ec29f6962e5e9a9847", "message": "removing patch file", "committedDate": "2020-08-24T19:11:45Z", "type": "commit"}, {"oid": "74b3d071a1fec6816440d766b6af0ad9de10814d", "url": "https://github.com/apache/hbase/commit/74b3d071a1fec6816440d766b6af0ad9de10814d", "message": "Merge branch 'master' of https://github.com/apache/hbase into HBASE-24620", "committedDate": "2020-11-23T12:39:10Z", "type": "commit"}, {"oid": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "url": "https://github.com/apache/hbase/commit/75319c812ad5d2ec73b7c82571728da46dbff8ee", "message": "Adding Design Doc as PDF", "committedDate": "2020-11-23T12:43:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU5MzQ3NQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529593475", "bodyText": "nit: Watchers ?", "author": "virajjasani", "createdAt": "2020-11-24T14:38:03Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU5OTYyOQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529599629", "bodyText": "nit: LoggerFactory.getLogger(ChaosAgent.class) should be enough.", "author": "virajjasani", "createdAt": "2020-11-24T14:46:09Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNTIxNQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529605215", "bodyText": "enum values are constants and should always be capitalized. If we need to use small letters, we can use enum with constructors.", "author": "virajjasani", "createdAt": "2020-11-24T14:53:05Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosService.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.AuthUtil;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.util.GenericOptionsParser;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.CommandLine;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.GnuParser;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Option;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Options;\n+\n+/**\n+ * Class used to start/stop Chaos related services (currently chaosagent)\n+ */\n+@InterfaceAudience.Private\n+public class ChaosService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosService.class.getName());\n+\n+  public static void execute(String[] args, Configuration conf) {\n+    LOG.info(\"arguments : \" + Arrays.toString(args));\n+\n+    try {\n+      CommandLine cmdline = new GnuParser().parse(getOptions(), args);\n+      if (cmdline.hasOption(ChaosServiceName.chaosagent.toString())) {\n+        String actionStr = cmdline.getOptionValue(ChaosServiceName.chaosagent.toString());\n+        try {\n+          ExecutorAction action = ExecutorAction.valueOf(actionStr.toLowerCase());\n+          if (action == ExecutorAction.start) {\n+            ChaosServiceStart(conf, ChaosServiceName.chaosagent);\n+          } else if (action == ExecutorAction.stop) {\n+            ChaosServiceStop();\n+          }\n+        } catch (IllegalArgumentException e) {\n+          LOG.error(\"action passed:\" + actionStr +\n+            \" . Unexpected action. Please provide only start/stop.\");\n+          throw new RuntimeException(e);\n+        }\n+      } else {\n+        LOG.error(\"Invalid Options\");\n+      }\n+    } catch (Exception e) {\n+      LOG.error(\"Error while starting ChaosService : \" + e);\n+    }\n+  }\n+\n+  private static void ChaosServiceStart(Configuration conf, ChaosServiceName serviceName) {\n+    switch (serviceName) {\n+      case chaosagent:\n+        ChaosAgent.stopChaosAgent.set(false);\n+        try {\n+          Thread t = new Thread(new ChaosAgent(conf,\n+            ChaosUtils.getZKQuorum(conf), ChaosUtils.getHostName()));\n+          t.start();\n+          t.join();\n+        } catch (InterruptedException | UnknownHostException e) {\n+          LOG.error(\"Failed while executing next task execution of ChaosAgent on : \" +\n+            serviceName + \" : \" + e);\n+        }\n+        break;\n+      default:\n+        LOG.error(\"Service Name not known : \" + serviceName.toString());\n+    }\n+  }\n+\n+  private static void ChaosServiceStop() {\n+    ChaosAgent.stopChaosAgent.set(true);\n+  }\n+\n+  private static Options getOptions() {\n+    Options options = new Options();\n+    options.addOption(new Option(\"c\", ChaosServiceName.chaosagent.toString(),\n+      true, \"expecting a start/stop argument\"));\n+    options.addOption(new Option(\"D\", ChaosServiceName.GENERIC.toString(),\n+      true, \"generic D param\"));\n+    LOG.info(Arrays.toString(new Collection[] { options.getOptions() }));\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    Configuration conf = HBaseConfiguration.create();\n+    new GenericOptionsParser(conf, args);\n+\n+    ChoreService choreChaosService = null;\n+    ScheduledChore authChore = AuthUtil.getAuthChore(conf);\n+\n+    try {\n+      if (authChore != null) {\n+        choreChaosService = new ChoreService(ChaosConstants.CHORE_SERVICE_PREFIX);\n+        choreChaosService.scheduleChore(authChore);\n+      }\n+\n+      execute(args, conf);\n+    } finally {\n+      if (authChore != null)\n+        choreChaosService.shutdown();\n+    }\n+  }\n+\n+  enum ChaosServiceName {\n+    chaosagent,", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwNTQ0MQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529605441", "bodyText": "same as above, should be capitalized.", "author": "virajjasani", "createdAt": "2020-11-24T14:53:19Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosService.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.AuthUtil;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.util.GenericOptionsParser;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.CommandLine;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.GnuParser;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Option;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Options;\n+\n+/**\n+ * Class used to start/stop Chaos related services (currently chaosagent)\n+ */\n+@InterfaceAudience.Private\n+public class ChaosService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosService.class.getName());\n+\n+  public static void execute(String[] args, Configuration conf) {\n+    LOG.info(\"arguments : \" + Arrays.toString(args));\n+\n+    try {\n+      CommandLine cmdline = new GnuParser().parse(getOptions(), args);\n+      if (cmdline.hasOption(ChaosServiceName.chaosagent.toString())) {\n+        String actionStr = cmdline.getOptionValue(ChaosServiceName.chaosagent.toString());\n+        try {\n+          ExecutorAction action = ExecutorAction.valueOf(actionStr.toLowerCase());\n+          if (action == ExecutorAction.start) {\n+            ChaosServiceStart(conf, ChaosServiceName.chaosagent);\n+          } else if (action == ExecutorAction.stop) {\n+            ChaosServiceStop();\n+          }\n+        } catch (IllegalArgumentException e) {\n+          LOG.error(\"action passed:\" + actionStr +\n+            \" . Unexpected action. Please provide only start/stop.\");\n+          throw new RuntimeException(e);\n+        }\n+      } else {\n+        LOG.error(\"Invalid Options\");\n+      }\n+    } catch (Exception e) {\n+      LOG.error(\"Error while starting ChaosService : \" + e);\n+    }\n+  }\n+\n+  private static void ChaosServiceStart(Configuration conf, ChaosServiceName serviceName) {\n+    switch (serviceName) {\n+      case chaosagent:\n+        ChaosAgent.stopChaosAgent.set(false);\n+        try {\n+          Thread t = new Thread(new ChaosAgent(conf,\n+            ChaosUtils.getZKQuorum(conf), ChaosUtils.getHostName()));\n+          t.start();\n+          t.join();\n+        } catch (InterruptedException | UnknownHostException e) {\n+          LOG.error(\"Failed while executing next task execution of ChaosAgent on : \" +\n+            serviceName + \" : \" + e);\n+        }\n+        break;\n+      default:\n+        LOG.error(\"Service Name not known : \" + serviceName.toString());\n+    }\n+  }\n+\n+  private static void ChaosServiceStop() {\n+    ChaosAgent.stopChaosAgent.set(true);\n+  }\n+\n+  private static Options getOptions() {\n+    Options options = new Options();\n+    options.addOption(new Option(\"c\", ChaosServiceName.chaosagent.toString(),\n+      true, \"expecting a start/stop argument\"));\n+    options.addOption(new Option(\"D\", ChaosServiceName.GENERIC.toString(),\n+      true, \"generic D param\"));\n+    LOG.info(Arrays.toString(new Collection[] { options.getOptions() }));\n+    return options;\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    Configuration conf = HBaseConfiguration.create();\n+    new GenericOptionsParser(conf, args);\n+\n+    ChoreService choreChaosService = null;\n+    ScheduledChore authChore = AuthUtil.getAuthChore(conf);\n+\n+    try {\n+      if (authChore != null) {\n+        choreChaosService = new ChoreService(ChaosConstants.CHORE_SERVICE_PREFIX);\n+        choreChaosService.scheduleChore(authChore);\n+      }\n+\n+      execute(args, conf);\n+    } finally {\n+      if (authChore != null)\n+        choreChaosService.shutdown();\n+    }\n+  }\n+\n+  enum ChaosServiceName {\n+    chaosagent,\n+    GENERIC\n+  }\n+\n+\n+  enum ExecutorAction {\n+    start,\n+    stop", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwOTQ0OA==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529609448", "bodyText": "nit: let's use placeholders and Exception as argument i.e:\n          LOG.error(\"action passed: {} . Unexpected action. Please provide only start/stop.\",\n            actionStr, e);", "author": "virajjasani", "createdAt": "2020-11-24T14:58:23Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosService.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.AuthUtil;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.util.GenericOptionsParser;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.CommandLine;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.GnuParser;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Option;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Options;\n+\n+/**\n+ * Class used to start/stop Chaos related services (currently chaosagent)\n+ */\n+@InterfaceAudience.Private\n+public class ChaosService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosService.class.getName());\n+\n+  public static void execute(String[] args, Configuration conf) {\n+    LOG.info(\"arguments : \" + Arrays.toString(args));\n+\n+    try {\n+      CommandLine cmdline = new GnuParser().parse(getOptions(), args);\n+      if (cmdline.hasOption(ChaosServiceName.chaosagent.toString())) {\n+        String actionStr = cmdline.getOptionValue(ChaosServiceName.chaosagent.toString());\n+        try {\n+          ExecutorAction action = ExecutorAction.valueOf(actionStr.toLowerCase());\n+          if (action == ExecutorAction.start) {\n+            ChaosServiceStart(conf, ChaosServiceName.chaosagent);\n+          } else if (action == ExecutorAction.stop) {\n+            ChaosServiceStop();\n+          }\n+        } catch (IllegalArgumentException e) {\n+          LOG.error(\"action passed:\" + actionStr +\n+            \" . Unexpected action. Please provide only start/stop.\");", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwOTgyMw==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529609823", "bodyText": "same as above, e should be last argument", "author": "virajjasani", "createdAt": "2020-11-24T14:58:50Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosService.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.AuthUtil;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.util.GenericOptionsParser;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.CommandLine;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.GnuParser;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Option;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Options;\n+\n+/**\n+ * Class used to start/stop Chaos related services (currently chaosagent)\n+ */\n+@InterfaceAudience.Private\n+public class ChaosService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosService.class.getName());\n+\n+  public static void execute(String[] args, Configuration conf) {\n+    LOG.info(\"arguments : \" + Arrays.toString(args));\n+\n+    try {\n+      CommandLine cmdline = new GnuParser().parse(getOptions(), args);\n+      if (cmdline.hasOption(ChaosServiceName.chaosagent.toString())) {\n+        String actionStr = cmdline.getOptionValue(ChaosServiceName.chaosagent.toString());\n+        try {\n+          ExecutorAction action = ExecutorAction.valueOf(actionStr.toLowerCase());\n+          if (action == ExecutorAction.start) {\n+            ChaosServiceStart(conf, ChaosServiceName.chaosagent);\n+          } else if (action == ExecutorAction.stop) {\n+            ChaosServiceStop();\n+          }\n+        } catch (IllegalArgumentException e) {\n+          LOG.error(\"action passed:\" + actionStr +\n+            \" . Unexpected action. Please provide only start/stop.\");\n+          throw new RuntimeException(e);\n+        }\n+      } else {\n+        LOG.error(\"Invalid Options\");\n+      }\n+    } catch (Exception e) {\n+      LOG.error(\"Error while starting ChaosService : \" + e);", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMDY2OA==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529610668", "bodyText": "same as above, placeholders + exception as arg", "author": "virajjasani", "createdAt": "2020-11-24T14:59:55Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosService.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.AuthUtil;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.util.GenericOptionsParser;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.CommandLine;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.GnuParser;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Option;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Options;\n+\n+/**\n+ * Class used to start/stop Chaos related services (currently chaosagent)\n+ */\n+@InterfaceAudience.Private\n+public class ChaosService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosService.class.getName());\n+\n+  public static void execute(String[] args, Configuration conf) {\n+    LOG.info(\"arguments : \" + Arrays.toString(args));\n+\n+    try {\n+      CommandLine cmdline = new GnuParser().parse(getOptions(), args);\n+      if (cmdline.hasOption(ChaosServiceName.chaosagent.toString())) {\n+        String actionStr = cmdline.getOptionValue(ChaosServiceName.chaosagent.toString());\n+        try {\n+          ExecutorAction action = ExecutorAction.valueOf(actionStr.toLowerCase());\n+          if (action == ExecutorAction.start) {\n+            ChaosServiceStart(conf, ChaosServiceName.chaosagent);\n+          } else if (action == ExecutorAction.stop) {\n+            ChaosServiceStop();\n+          }\n+        } catch (IllegalArgumentException e) {\n+          LOG.error(\"action passed:\" + actionStr +\n+            \" . Unexpected action. Please provide only start/stop.\");\n+          throw new RuntimeException(e);\n+        }\n+      } else {\n+        LOG.error(\"Invalid Options\");\n+      }\n+    } catch (Exception e) {\n+      LOG.error(\"Error while starting ChaosService : \" + e);\n+    }\n+  }\n+\n+  private static void ChaosServiceStart(Configuration conf, ChaosServiceName serviceName) {\n+    switch (serviceName) {\n+      case chaosagent:\n+        ChaosAgent.stopChaosAgent.set(false);\n+        try {\n+          Thread t = new Thread(new ChaosAgent(conf,\n+            ChaosUtils.getZKQuorum(conf), ChaosUtils.getHostName()));\n+          t.start();\n+          t.join();\n+        } catch (InterruptedException | UnknownHostException e) {\n+          LOG.error(\"Failed while executing next task execution of ChaosAgent on : \" +\n+            serviceName + \" : \" + e);", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxMjU4MQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529612581", "bodyText": "please provide e as argument for stacktrace", "author": "virajjasani", "createdAt": "2020-11-24T15:02:22Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());\n+\n+        LOG.info(\"Change in Tasks Node, checking for Tasks again.\");\n+        getTasks();\n+      }\n+\n+    }\n+  };\n+\n+  //CALLBACKS: Below are the Callbacks used by Chaos Agent\n+\n+  /**\n+   * Callback used while setting status of a given task, Logs given status.\n+   */\n+  AsyncCallback.StatCallback setStatusOfTaskZNodeCallback = (rc, path, ctx, stat) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        // Connection to the server was lost while setting status setting again.\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        setStatusOfTaskZNode(path, (String) ctx);\n+        break;\n+\n+      case OK:\n+        LOG.info(\"Status of Task has been set\");\n+        break;\n+\n+      case NONODE:\n+        LOG.error(\"Chaos Agent status node does not exists: \"\n+          + \"check for ZNode directory structure again.\");\n+        break;\n+\n+      default:\n+        LOG.error(\"Error while setting status of task ZNode: \" +\n+          path, KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Persistent ZNode tries to create\n+   * ZNode again if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Persistent ZNode: \" + path,\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Ephemeral ZNode tries to create ZNode again\n+   * if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createEphemeralZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createEphemeralZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Ephemeral ZNode: \",\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used by getTasksForAgentCallback while getting command,\n+   * after getting command successfully, it executes command and\n+   * set its status with respect to the command type.\n+   */\n+  AsyncCallback.DataCallback getTaskForExecutionCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connection to the server has been lost while getting task, getting data again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          zk.getData(path,\n+            false,\n+            getTaskForExecutionCallback,\n+            new String(data));\n+          break;\n+        case OK:\n+          String cmd = new String(data);\n+          LOG.info(\"Executing command : \" + cmd);\n+          String status = ChaosConstants.TASK_COMPLETION_STRING;\n+          try {\n+            String user = conf.get(ChaosConstants.CHAOSAGENT_SHELL_USER,\n+              ChaosConstants.DEFAULT_SHELL_USER);\n+            switch (cmd.substring(0, 4)) {\n+              case \"bool\":\n+                String ret = execWithRetries(user, cmd.substring(4)).getSecond();\n+                status = Boolean.toString(ret.length() > 0);\n+                break;\n+\n+              case \"exec\":\n+                execWithRetries(user, cmd.substring(4));\n+                break;\n+\n+              default:\n+                LOG.error(\"Unknown Command Type\");\n+                status = ChaosConstants.TASK_ERROR_STRING;\n+            }\n+          } catch (IOException e) {\n+            LOG.error(\"Got error while executing command : \" + cmd +\n+              \" On agent : \" + agentName + \" Error : \" + e);\n+            status = ChaosConstants.TASK_ERROR_STRING;\n+          }\n+\n+          try {\n+            setStatusOfTaskZNode(path, status);\n+            Thread.sleep(ChaosConstants.SET_STATUS_SLEEP_TIME);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error occured after setting status: \" + e);\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting data\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Callback used while getting Tasks for agent if call executed without Exception,\n+   * It creates a separate thread for each children to execute given Tasks parallely.\n+   */\n+  AsyncCallback.ChildrenCallback getTasksForAgentCallback = new AsyncCallback.ChildrenCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to the server has been lost, getting tasks again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          getTasks();\n+          break;\n+\n+        case OK:\n+          if (children != null) {\n+            try {\n+\n+              LOG.info(\"Executing each task as a separate thread\");\n+              List<Thread> tasksList = new ArrayList<>();\n+              for (String task : children) {\n+                String threadName = agentName + \"_\" + task;\n+                Thread t = new Thread(() -> {\n+\n+                  LOG.info(\"Executing task : \" + task + \" of agent : \" + agentName);\n+                  zk.getData(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + task,\n+                    false,\n+                    getTaskForExecutionCallback,\n+                    task);\n+\n+                });\n+                t.setName(threadName);\n+                t.start();\n+                tasksList.add(t);\n+\n+                for (Thread thread : tasksList) {\n+                  thread.join();\n+                }\n+              }\n+            } catch (InterruptedException e) {\n+              LOG.error(\"Error scheduling next task : \" +\n+                \" for agent : \" + agentName + \" Error : \" + e);\n+            }\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting task\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Function to create PERSISTENT ZNODE with given path and data given as params\n+   * @param path Path at which ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.PERSISTENT,\n+      createZNodeCallback,\n+      data);\n+  }\n+\n+  /***\n+   * Function to create EPHEMERAL ZNODE with given path and data as params.\n+   * @param path Path at which Ephemeral ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createEphemeralZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.EPHEMERAL,\n+      createEphemeralZNodeCallback,\n+      data);\n+  }\n+\n+  /**\n+   * Checks if given ZNode exists, if not creates a PERSISTENT ZNODE for same.\n+   *\n+   * @param path Path to check for ZNode\n+   */\n+  private void createIfZNodeNotExists(String path) {\n+    try {\n+      if (zk.exists(path,\n+        false) == null) {\n+        createZNode(path, new byte[0]);\n+      }\n+    } catch (KeeperException | InterruptedException e) {\n+      LOG.error(\"Error checking given node : \" + path + \" \" + e);\n+    }\n+  }\n+\n+  /**\n+   * sets given Status for Task Znode\n+   *\n+   * @param taskZNode ZNode to set status\n+   * @param status Status value\n+   */\n+  public void setStatusOfTaskZNode(String taskZNode, String status) {\n+    LOG.info(\"Setting status of Task ZNode: \" + taskZNode + \" status : \" + status);\n+    zk.setData(taskZNode,\n+      status.getBytes(),\n+      -1,\n+      setStatusOfTaskZNodeCallback,\n+      null);\n+  }\n+\n+  /**\n+   * registration of ChaosAgent by checking and creating necessary ZNodes.\n+   */\n+  private void register() {\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_TEST_ROOT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName);\n+\n+    createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+  }\n+\n+  /***\n+   * Gets tasks for execution, basically sets Watch on it's respective host's Znode and\n+   * waits for tasks to be assigned, also has a getTasksForAgentCallback\n+   * which handles execution of task.\n+   */\n+  private void getTasks() {\n+    LOG.info(\"Getting Tasks for Agent: \" + agentName + \"and setting watch for new Tasks\");\n+    zk.getChildren(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+        ChaosConstants.ZNODE_PATH_SEPARATOR + agentName,\n+      newTaskCreatedWatcher,\n+      getTasksForAgentCallback,\n+      null);\n+  }\n+\n+  /**\n+   * Below function executes command with retries with given user.\n+   * Uses LocalShell to execute a command.\n+   *\n+   * @param user user name, default none\n+   * @param cmd Command to execute\n+   * @return A pair of Exit Code and Shell output\n+   * @throws IOException Exception while executing shell command\n+   */\n+  private Pair<Integer, String> execWithRetries(String user, String cmd) throws IOException {\n+    RetryCounter retryCounter = retryCounterFactory.create();\n+    while (true) {\n+      try {\n+        return exec(user, cmd);\n+      } catch (IOException e) {\n+        retryOrThrow(retryCounter, e, user, cmd);\n+      }\n+      try {\n+        retryCounter.sleepUntilNextRetry();\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"Sleep Interrupted: \" + e);\n+      }\n+    }\n+  }\n+\n+  private Pair<Integer, String> exec(String user, String cmd) throws IOException {\n+    LOG.info(\"Executing Shell command: \" + cmd + \" , user: \" + user);\n+\n+    LocalShell shell = new LocalShell(user, cmd);\n+    try {\n+      shell.execute();\n+    } catch (Shell.ExitCodeException e) {\n+      String output = shell.getOutput();\n+      throw new Shell.ExitCodeException(e.getExitCode(), \"stderr: \" + e.getMessage()\n+        + \", stdout: \" + output);\n+    }\n+    LOG.info(\"Executed Shell command, exit code: \" + shell.getExitCode() +\n+      \" , output:\" + shell.getOutput());\n+\n+    return new Pair<>(shell.getExitCode(), shell.getOutput());\n+  }\n+\n+  private <E extends Exception> void retryOrThrow(RetryCounter retryCounter, E ex,\n+    String user, String cmd) throws E {\n+    if (retryCounter.shouldRetry()) {\n+      LOG.warn(\"Local command: \" + cmd + \" , user:\" + user\n+        + \" failed at attempt \" + retryCounter.getAttemptTimes() + \". Retrying until maxAttempts: \"\n+        + retryCounter.getMaxAttempts() + \". Exception: \" + ex.getMessage());\n+      return;\n+    }\n+    throw ex;\n+  }\n+\n+  private boolean isConnected() {\n+    return connected;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    LOG.info(\"Closing ZooKeeper Connection for Chaos Agent : \" + agentName);\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while closing ZooKeeper Connection.\");\n+    }\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      LOG.info(\"Running Chaos Agent on : \" + agentName);\n+      while (!this.isConnected()) {\n+        Thread.sleep(100);\n+      }\n+      this.getTasks();\n+      while (!stopChaosAgent.get()) {\n+        Thread.sleep(500);\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while running Chaos Agent\");", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxOTczMA==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529619730", "bodyText": "Can you explore using ExecutorService here with singleThreadExecutor builder? In order to block on ChaosAgent execution, this might require ChaosAgent to implement Callable instead of Runnable.\nIf this is too much of change, it's ok to leave as is but having ExecutorService is definitely beneficial than executing single Thread without any pool.", "author": "virajjasani", "createdAt": "2020-11-24T15:11:25Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosService.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.net.UnknownHostException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.AuthUtil;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.util.GenericOptionsParser;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.CommandLine;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.GnuParser;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Option;\n+import org.apache.hbase.thirdparty.org.apache.commons.cli.Options;\n+\n+/**\n+ * Class used to start/stop Chaos related services (currently chaosagent)\n+ */\n+@InterfaceAudience.Private\n+public class ChaosService {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosService.class.getName());\n+\n+  public static void execute(String[] args, Configuration conf) {\n+    LOG.info(\"arguments : \" + Arrays.toString(args));\n+\n+    try {\n+      CommandLine cmdline = new GnuParser().parse(getOptions(), args);\n+      if (cmdline.hasOption(ChaosServiceName.chaosagent.toString())) {\n+        String actionStr = cmdline.getOptionValue(ChaosServiceName.chaosagent.toString());\n+        try {\n+          ExecutorAction action = ExecutorAction.valueOf(actionStr.toLowerCase());\n+          if (action == ExecutorAction.start) {\n+            ChaosServiceStart(conf, ChaosServiceName.chaosagent);\n+          } else if (action == ExecutorAction.stop) {\n+            ChaosServiceStop();\n+          }\n+        } catch (IllegalArgumentException e) {\n+          LOG.error(\"action passed:\" + actionStr +\n+            \" . Unexpected action. Please provide only start/stop.\");\n+          throw new RuntimeException(e);\n+        }\n+      } else {\n+        LOG.error(\"Invalid Options\");\n+      }\n+    } catch (Exception e) {\n+      LOG.error(\"Error while starting ChaosService : \" + e);\n+    }\n+  }\n+\n+  private static void ChaosServiceStart(Configuration conf, ChaosServiceName serviceName) {\n+    switch (serviceName) {\n+      case chaosagent:\n+        ChaosAgent.stopChaosAgent.set(false);\n+        try {\n+          Thread t = new Thread(new ChaosAgent(conf,\n+            ChaosUtils.getZKQuorum(conf), ChaosUtils.getHostName()));\n+          t.start();\n+          t.join();", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3Nzg4MQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r541777881", "bodyText": "@virajjasani Can I take this change as a follow up, it'll require some changes in whole.", "author": "lokiore", "createdAt": "2020-12-12T20:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxOTczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3MjcwMg==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r545872702", "bodyText": "Sure, this can be follow up.", "author": "virajjasani", "createdAt": "2020-12-18T14:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxOTczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyMjAyMw==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529622023", "bodyText": "instead of this assert, let's have an if condition to assert this? if the condition is false, we exit and don't print log, get tasks etc", "author": "virajjasani", "createdAt": "2020-11-24T15:14:27Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTkwNzM3OQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r545907379", "bodyText": "@lokiore I this here we can provide better Exception than assert. Something like:\nif (!(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath()) {\n    throw new RuntimeException(xxx); // or something better\n}", "author": "virajjasani", "createdAt": "2020-12-18T15:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyMjAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNzA4NA==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529627084", "bodyText": "Throwing RTE within finally might complicate debugging. Let's keep everything in try block:\n  private void recreateZKConnection() throws Exception {\n    try {\n      zk.close();\n      createZKConnection(newTaskCreatedWatcher);\n      createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n        ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n    } catch (InterruptedException | IOException e) {\n      LOG.error(\"Error recreating new ZK Connection for agent: {}\", agentName, e);\n      throw e;\n    }\n  }", "author": "virajjasani", "createdAt": "2020-11-24T15:20:31Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());\n+\n+        LOG.info(\"Change in Tasks Node, checking for Tasks again.\");\n+        getTasks();\n+      }\n+\n+    }\n+  };\n+\n+  //CALLBACKS: Below are the Callbacks used by Chaos Agent\n+\n+  /**\n+   * Callback used while setting status of a given task, Logs given status.\n+   */\n+  AsyncCallback.StatCallback setStatusOfTaskZNodeCallback = (rc, path, ctx, stat) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        // Connection to the server was lost while setting status setting again.\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        setStatusOfTaskZNode(path, (String) ctx);\n+        break;\n+\n+      case OK:\n+        LOG.info(\"Status of Task has been set\");\n+        break;\n+\n+      case NONODE:\n+        LOG.error(\"Chaos Agent status node does not exists: \"\n+          + \"check for ZNode directory structure again.\");\n+        break;\n+\n+      default:\n+        LOG.error(\"Error while setting status of task ZNode: \" +\n+          path, KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Persistent ZNode tries to create\n+   * ZNode again if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Persistent ZNode: \" + path,\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Ephemeral ZNode tries to create ZNode again\n+   * if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createEphemeralZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createEphemeralZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Ephemeral ZNode: \",\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used by getTasksForAgentCallback while getting command,\n+   * after getting command successfully, it executes command and\n+   * set its status with respect to the command type.\n+   */\n+  AsyncCallback.DataCallback getTaskForExecutionCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connection to the server has been lost while getting task, getting data again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          zk.getData(path,\n+            false,\n+            getTaskForExecutionCallback,\n+            new String(data));\n+          break;\n+        case OK:\n+          String cmd = new String(data);\n+          LOG.info(\"Executing command : \" + cmd);\n+          String status = ChaosConstants.TASK_COMPLETION_STRING;\n+          try {\n+            String user = conf.get(ChaosConstants.CHAOSAGENT_SHELL_USER,\n+              ChaosConstants.DEFAULT_SHELL_USER);\n+            switch (cmd.substring(0, 4)) {\n+              case \"bool\":\n+                String ret = execWithRetries(user, cmd.substring(4)).getSecond();\n+                status = Boolean.toString(ret.length() > 0);\n+                break;\n+\n+              case \"exec\":\n+                execWithRetries(user, cmd.substring(4));\n+                break;\n+\n+              default:\n+                LOG.error(\"Unknown Command Type\");\n+                status = ChaosConstants.TASK_ERROR_STRING;\n+            }\n+          } catch (IOException e) {\n+            LOG.error(\"Got error while executing command : \" + cmd +\n+              \" On agent : \" + agentName + \" Error : \" + e);\n+            status = ChaosConstants.TASK_ERROR_STRING;\n+          }\n+\n+          try {\n+            setStatusOfTaskZNode(path, status);\n+            Thread.sleep(ChaosConstants.SET_STATUS_SLEEP_TIME);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error occured after setting status: \" + e);\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting data\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Callback used while getting Tasks for agent if call executed without Exception,\n+   * It creates a separate thread for each children to execute given Tasks parallely.\n+   */\n+  AsyncCallback.ChildrenCallback getTasksForAgentCallback = new AsyncCallback.ChildrenCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to the server has been lost, getting tasks again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          getTasks();\n+          break;\n+\n+        case OK:\n+          if (children != null) {\n+            try {\n+\n+              LOG.info(\"Executing each task as a separate thread\");\n+              List<Thread> tasksList = new ArrayList<>();\n+              for (String task : children) {\n+                String threadName = agentName + \"_\" + task;\n+                Thread t = new Thread(() -> {\n+\n+                  LOG.info(\"Executing task : \" + task + \" of agent : \" + agentName);\n+                  zk.getData(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + task,\n+                    false,\n+                    getTaskForExecutionCallback,\n+                    task);\n+\n+                });\n+                t.setName(threadName);\n+                t.start();\n+                tasksList.add(t);\n+\n+                for (Thread thread : tasksList) {\n+                  thread.join();\n+                }\n+              }\n+            } catch (InterruptedException e) {\n+              LOG.error(\"Error scheduling next task : \" +\n+                \" for agent : \" + agentName + \" Error : \" + e);\n+            }\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting task\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Function to create PERSISTENT ZNODE with given path and data given as params\n+   * @param path Path at which ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.PERSISTENT,\n+      createZNodeCallback,\n+      data);\n+  }\n+\n+  /***\n+   * Function to create EPHEMERAL ZNODE with given path and data as params.\n+   * @param path Path at which Ephemeral ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createEphemeralZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.EPHEMERAL,\n+      createEphemeralZNodeCallback,\n+      data);\n+  }\n+\n+  /**\n+   * Checks if given ZNode exists, if not creates a PERSISTENT ZNODE for same.\n+   *\n+   * @param path Path to check for ZNode\n+   */\n+  private void createIfZNodeNotExists(String path) {\n+    try {\n+      if (zk.exists(path,\n+        false) == null) {\n+        createZNode(path, new byte[0]);\n+      }\n+    } catch (KeeperException | InterruptedException e) {\n+      LOG.error(\"Error checking given node : \" + path + \" \" + e);\n+    }\n+  }\n+\n+  /**\n+   * sets given Status for Task Znode\n+   *\n+   * @param taskZNode ZNode to set status\n+   * @param status Status value\n+   */\n+  public void setStatusOfTaskZNode(String taskZNode, String status) {\n+    LOG.info(\"Setting status of Task ZNode: \" + taskZNode + \" status : \" + status);\n+    zk.setData(taskZNode,\n+      status.getBytes(),\n+      -1,\n+      setStatusOfTaskZNodeCallback,\n+      null);\n+  }\n+\n+  /**\n+   * registration of ChaosAgent by checking and creating necessary ZNodes.\n+   */\n+  private void register() {\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_TEST_ROOT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName);\n+\n+    createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+  }\n+\n+  /***\n+   * Gets tasks for execution, basically sets Watch on it's respective host's Znode and\n+   * waits for tasks to be assigned, also has a getTasksForAgentCallback\n+   * which handles execution of task.\n+   */\n+  private void getTasks() {\n+    LOG.info(\"Getting Tasks for Agent: \" + agentName + \"and setting watch for new Tasks\");\n+    zk.getChildren(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+        ChaosConstants.ZNODE_PATH_SEPARATOR + agentName,\n+      newTaskCreatedWatcher,\n+      getTasksForAgentCallback,\n+      null);\n+  }\n+\n+  /**\n+   * Below function executes command with retries with given user.\n+   * Uses LocalShell to execute a command.\n+   *\n+   * @param user user name, default none\n+   * @param cmd Command to execute\n+   * @return A pair of Exit Code and Shell output\n+   * @throws IOException Exception while executing shell command\n+   */\n+  private Pair<Integer, String> execWithRetries(String user, String cmd) throws IOException {\n+    RetryCounter retryCounter = retryCounterFactory.create();\n+    while (true) {\n+      try {\n+        return exec(user, cmd);\n+      } catch (IOException e) {\n+        retryOrThrow(retryCounter, e, user, cmd);\n+      }\n+      try {\n+        retryCounter.sleepUntilNextRetry();\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"Sleep Interrupted: \" + e);\n+      }\n+    }\n+  }\n+\n+  private Pair<Integer, String> exec(String user, String cmd) throws IOException {\n+    LOG.info(\"Executing Shell command: \" + cmd + \" , user: \" + user);\n+\n+    LocalShell shell = new LocalShell(user, cmd);\n+    try {\n+      shell.execute();\n+    } catch (Shell.ExitCodeException e) {\n+      String output = shell.getOutput();\n+      throw new Shell.ExitCodeException(e.getExitCode(), \"stderr: \" + e.getMessage()\n+        + \", stdout: \" + output);\n+    }\n+    LOG.info(\"Executed Shell command, exit code: \" + shell.getExitCode() +\n+      \" , output:\" + shell.getOutput());\n+\n+    return new Pair<>(shell.getExitCode(), shell.getOutput());\n+  }\n+\n+  private <E extends Exception> void retryOrThrow(RetryCounter retryCounter, E ex,\n+    String user, String cmd) throws E {\n+    if (retryCounter.shouldRetry()) {\n+      LOG.warn(\"Local command: \" + cmd + \" , user:\" + user\n+        + \" failed at attempt \" + retryCounter.getAttemptTimes() + \". Retrying until maxAttempts: \"\n+        + retryCounter.getMaxAttempts() + \". Exception: \" + ex.getMessage());\n+      return;\n+    }\n+    throw ex;\n+  }\n+\n+  private boolean isConnected() {\n+    return connected;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    LOG.info(\"Closing ZooKeeper Connection for Chaos Agent : \" + agentName);\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while closing ZooKeeper Connection.\");\n+    }\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      LOG.info(\"Running Chaos Agent on : \" + agentName);\n+      while (!this.isConnected()) {\n+        Thread.sleep(100);\n+      }\n+      this.getTasks();\n+      while (!stopChaosAgent.get()) {\n+        Thread.sleep(500);\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while running Chaos Agent\");\n+    }\n+\n+  }\n+\n+  @Override\n+  public void process(WatchedEvent watchedEvent) {\n+    LOG.info(\"Processing event: \" + watchedEvent.toString());\n+    if (watchedEvent.getType() == Event.EventType.None) {\n+      switch (watchedEvent.getState()) {\n+        case SyncConnected:\n+          connected = true;\n+          break;\n+        case Disconnected:\n+          connected = false;\n+          break;\n+        case Expired:\n+          connected = false;\n+          LOG.error(\"Session expired creating again\");\n+          try {\n+            createZKConnection(null);\n+          } catch (IOException e) {\n+            LOG.error(\"Error creating Zookeeper connection\");\n+          }\n+        default:\n+          LOG.error(\"Unknown State\");\n+          break;\n+      }\n+    }\n+  }\n+\n+  private void recreateZKConnection() throws Exception{\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error closing ZK connection : \" + e);\n+      throw new RuntimeException(e) ;\n+    } finally {\n+      try {\n+        createZKConnection(newTaskCreatedWatcher);\n+        createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+      } catch (IOException e) {\n+        LOG.error(\"Error creating new ZK COnnection for agent: \" + agentName + e);\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNzgyOA==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529627828", "bodyText": "Inner class should be static", "author": "virajjasani", "createdAt": "2020-11-24T15:21:25Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());\n+\n+        LOG.info(\"Change in Tasks Node, checking for Tasks again.\");\n+        getTasks();\n+      }\n+\n+    }\n+  };\n+\n+  //CALLBACKS: Below are the Callbacks used by Chaos Agent\n+\n+  /**\n+   * Callback used while setting status of a given task, Logs given status.\n+   */\n+  AsyncCallback.StatCallback setStatusOfTaskZNodeCallback = (rc, path, ctx, stat) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        // Connection to the server was lost while setting status setting again.\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        setStatusOfTaskZNode(path, (String) ctx);\n+        break;\n+\n+      case OK:\n+        LOG.info(\"Status of Task has been set\");\n+        break;\n+\n+      case NONODE:\n+        LOG.error(\"Chaos Agent status node does not exists: \"\n+          + \"check for ZNode directory structure again.\");\n+        break;\n+\n+      default:\n+        LOG.error(\"Error while setting status of task ZNode: \" +\n+          path, KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Persistent ZNode tries to create\n+   * ZNode again if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Persistent ZNode: \" + path,\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Ephemeral ZNode tries to create ZNode again\n+   * if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createEphemeralZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createEphemeralZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Ephemeral ZNode: \",\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used by getTasksForAgentCallback while getting command,\n+   * after getting command successfully, it executes command and\n+   * set its status with respect to the command type.\n+   */\n+  AsyncCallback.DataCallback getTaskForExecutionCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connection to the server has been lost while getting task, getting data again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          zk.getData(path,\n+            false,\n+            getTaskForExecutionCallback,\n+            new String(data));\n+          break;\n+        case OK:\n+          String cmd = new String(data);\n+          LOG.info(\"Executing command : \" + cmd);\n+          String status = ChaosConstants.TASK_COMPLETION_STRING;\n+          try {\n+            String user = conf.get(ChaosConstants.CHAOSAGENT_SHELL_USER,\n+              ChaosConstants.DEFAULT_SHELL_USER);\n+            switch (cmd.substring(0, 4)) {\n+              case \"bool\":\n+                String ret = execWithRetries(user, cmd.substring(4)).getSecond();\n+                status = Boolean.toString(ret.length() > 0);\n+                break;\n+\n+              case \"exec\":\n+                execWithRetries(user, cmd.substring(4));\n+                break;\n+\n+              default:\n+                LOG.error(\"Unknown Command Type\");\n+                status = ChaosConstants.TASK_ERROR_STRING;\n+            }\n+          } catch (IOException e) {\n+            LOG.error(\"Got error while executing command : \" + cmd +\n+              \" On agent : \" + agentName + \" Error : \" + e);\n+            status = ChaosConstants.TASK_ERROR_STRING;\n+          }\n+\n+          try {\n+            setStatusOfTaskZNode(path, status);\n+            Thread.sleep(ChaosConstants.SET_STATUS_SLEEP_TIME);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error occured after setting status: \" + e);\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting data\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Callback used while getting Tasks for agent if call executed without Exception,\n+   * It creates a separate thread for each children to execute given Tasks parallely.\n+   */\n+  AsyncCallback.ChildrenCallback getTasksForAgentCallback = new AsyncCallback.ChildrenCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to the server has been lost, getting tasks again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          getTasks();\n+          break;\n+\n+        case OK:\n+          if (children != null) {\n+            try {\n+\n+              LOG.info(\"Executing each task as a separate thread\");\n+              List<Thread> tasksList = new ArrayList<>();\n+              for (String task : children) {\n+                String threadName = agentName + \"_\" + task;\n+                Thread t = new Thread(() -> {\n+\n+                  LOG.info(\"Executing task : \" + task + \" of agent : \" + agentName);\n+                  zk.getData(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + task,\n+                    false,\n+                    getTaskForExecutionCallback,\n+                    task);\n+\n+                });\n+                t.setName(threadName);\n+                t.start();\n+                tasksList.add(t);\n+\n+                for (Thread thread : tasksList) {\n+                  thread.join();\n+                }\n+              }\n+            } catch (InterruptedException e) {\n+              LOG.error(\"Error scheduling next task : \" +\n+                \" for agent : \" + agentName + \" Error : \" + e);\n+            }\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting task\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Function to create PERSISTENT ZNODE with given path and data given as params\n+   * @param path Path at which ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.PERSISTENT,\n+      createZNodeCallback,\n+      data);\n+  }\n+\n+  /***\n+   * Function to create EPHEMERAL ZNODE with given path and data as params.\n+   * @param path Path at which Ephemeral ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createEphemeralZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.EPHEMERAL,\n+      createEphemeralZNodeCallback,\n+      data);\n+  }\n+\n+  /**\n+   * Checks if given ZNode exists, if not creates a PERSISTENT ZNODE for same.\n+   *\n+   * @param path Path to check for ZNode\n+   */\n+  private void createIfZNodeNotExists(String path) {\n+    try {\n+      if (zk.exists(path,\n+        false) == null) {\n+        createZNode(path, new byte[0]);\n+      }\n+    } catch (KeeperException | InterruptedException e) {\n+      LOG.error(\"Error checking given node : \" + path + \" \" + e);\n+    }\n+  }\n+\n+  /**\n+   * sets given Status for Task Znode\n+   *\n+   * @param taskZNode ZNode to set status\n+   * @param status Status value\n+   */\n+  public void setStatusOfTaskZNode(String taskZNode, String status) {\n+    LOG.info(\"Setting status of Task ZNode: \" + taskZNode + \" status : \" + status);\n+    zk.setData(taskZNode,\n+      status.getBytes(),\n+      -1,\n+      setStatusOfTaskZNodeCallback,\n+      null);\n+  }\n+\n+  /**\n+   * registration of ChaosAgent by checking and creating necessary ZNodes.\n+   */\n+  private void register() {\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_TEST_ROOT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName);\n+\n+    createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+  }\n+\n+  /***\n+   * Gets tasks for execution, basically sets Watch on it's respective host's Znode and\n+   * waits for tasks to be assigned, also has a getTasksForAgentCallback\n+   * which handles execution of task.\n+   */\n+  private void getTasks() {\n+    LOG.info(\"Getting Tasks for Agent: \" + agentName + \"and setting watch for new Tasks\");\n+    zk.getChildren(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+        ChaosConstants.ZNODE_PATH_SEPARATOR + agentName,\n+      newTaskCreatedWatcher,\n+      getTasksForAgentCallback,\n+      null);\n+  }\n+\n+  /**\n+   * Below function executes command with retries with given user.\n+   * Uses LocalShell to execute a command.\n+   *\n+   * @param user user name, default none\n+   * @param cmd Command to execute\n+   * @return A pair of Exit Code and Shell output\n+   * @throws IOException Exception while executing shell command\n+   */\n+  private Pair<Integer, String> execWithRetries(String user, String cmd) throws IOException {\n+    RetryCounter retryCounter = retryCounterFactory.create();\n+    while (true) {\n+      try {\n+        return exec(user, cmd);\n+      } catch (IOException e) {\n+        retryOrThrow(retryCounter, e, user, cmd);\n+      }\n+      try {\n+        retryCounter.sleepUntilNextRetry();\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"Sleep Interrupted: \" + e);\n+      }\n+    }\n+  }\n+\n+  private Pair<Integer, String> exec(String user, String cmd) throws IOException {\n+    LOG.info(\"Executing Shell command: \" + cmd + \" , user: \" + user);\n+\n+    LocalShell shell = new LocalShell(user, cmd);\n+    try {\n+      shell.execute();\n+    } catch (Shell.ExitCodeException e) {\n+      String output = shell.getOutput();\n+      throw new Shell.ExitCodeException(e.getExitCode(), \"stderr: \" + e.getMessage()\n+        + \", stdout: \" + output);\n+    }\n+    LOG.info(\"Executed Shell command, exit code: \" + shell.getExitCode() +\n+      \" , output:\" + shell.getOutput());\n+\n+    return new Pair<>(shell.getExitCode(), shell.getOutput());\n+  }\n+\n+  private <E extends Exception> void retryOrThrow(RetryCounter retryCounter, E ex,\n+    String user, String cmd) throws E {\n+    if (retryCounter.shouldRetry()) {\n+      LOG.warn(\"Local command: \" + cmd + \" , user:\" + user\n+        + \" failed at attempt \" + retryCounter.getAttemptTimes() + \". Retrying until maxAttempts: \"\n+        + retryCounter.getMaxAttempts() + \". Exception: \" + ex.getMessage());\n+      return;\n+    }\n+    throw ex;\n+  }\n+\n+  private boolean isConnected() {\n+    return connected;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    LOG.info(\"Closing ZooKeeper Connection for Chaos Agent : \" + agentName);\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while closing ZooKeeper Connection.\");\n+    }\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      LOG.info(\"Running Chaos Agent on : \" + agentName);\n+      while (!this.isConnected()) {\n+        Thread.sleep(100);\n+      }\n+      this.getTasks();\n+      while (!stopChaosAgent.get()) {\n+        Thread.sleep(500);\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while running Chaos Agent\");\n+    }\n+\n+  }\n+\n+  @Override\n+  public void process(WatchedEvent watchedEvent) {\n+    LOG.info(\"Processing event: \" + watchedEvent.toString());\n+    if (watchedEvent.getType() == Event.EventType.None) {\n+      switch (watchedEvent.getState()) {\n+        case SyncConnected:\n+          connected = true;\n+          break;\n+        case Disconnected:\n+          connected = false;\n+          break;\n+        case Expired:\n+          connected = false;\n+          LOG.error(\"Session expired creating again\");\n+          try {\n+            createZKConnection(null);\n+          } catch (IOException e) {\n+            LOG.error(\"Error creating Zookeeper connection\");\n+          }\n+        default:\n+          LOG.error(\"Unknown State\");\n+          break;\n+      }\n+    }\n+  }\n+\n+  private void recreateZKConnection() throws Exception{\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error closing ZK connection : \" + e);\n+      throw new RuntimeException(e) ;\n+    } finally {\n+      try {\n+        createZKConnection(newTaskCreatedWatcher);\n+        createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+      } catch (IOException e) {\n+        LOG.error(\"Error creating new ZK COnnection for agent: \" + agentName + e);\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Executes Command locally.\n+   */\n+  protected class LocalShell extends Shell.ShellCommandExecutor {", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyOTUyNw==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529629527", "bodyText": "same as other log comments: placeholders + exception as last argument", "author": "virajjasani", "createdAt": "2020-11-24T15:23:34Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());\n+\n+        LOG.info(\"Change in Tasks Node, checking for Tasks again.\");\n+        getTasks();\n+      }\n+\n+    }\n+  };\n+\n+  //CALLBACKS: Below are the Callbacks used by Chaos Agent\n+\n+  /**\n+   * Callback used while setting status of a given task, Logs given status.\n+   */\n+  AsyncCallback.StatCallback setStatusOfTaskZNodeCallback = (rc, path, ctx, stat) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        // Connection to the server was lost while setting status setting again.\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        setStatusOfTaskZNode(path, (String) ctx);\n+        break;\n+\n+      case OK:\n+        LOG.info(\"Status of Task has been set\");\n+        break;\n+\n+      case NONODE:\n+        LOG.error(\"Chaos Agent status node does not exists: \"\n+          + \"check for ZNode directory structure again.\");\n+        break;\n+\n+      default:\n+        LOG.error(\"Error while setting status of task ZNode: \" +\n+          path, KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Persistent ZNode tries to create\n+   * ZNode again if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Persistent ZNode: \" + path,\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Ephemeral ZNode tries to create ZNode again\n+   * if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createEphemeralZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createEphemeralZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Ephemeral ZNode: \",\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used by getTasksForAgentCallback while getting command,\n+   * after getting command successfully, it executes command and\n+   * set its status with respect to the command type.\n+   */\n+  AsyncCallback.DataCallback getTaskForExecutionCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connection to the server has been lost while getting task, getting data again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          zk.getData(path,\n+            false,\n+            getTaskForExecutionCallback,\n+            new String(data));\n+          break;\n+        case OK:\n+          String cmd = new String(data);\n+          LOG.info(\"Executing command : \" + cmd);\n+          String status = ChaosConstants.TASK_COMPLETION_STRING;\n+          try {\n+            String user = conf.get(ChaosConstants.CHAOSAGENT_SHELL_USER,\n+              ChaosConstants.DEFAULT_SHELL_USER);\n+            switch (cmd.substring(0, 4)) {\n+              case \"bool\":\n+                String ret = execWithRetries(user, cmd.substring(4)).getSecond();\n+                status = Boolean.toString(ret.length() > 0);\n+                break;\n+\n+              case \"exec\":\n+                execWithRetries(user, cmd.substring(4));\n+                break;\n+\n+              default:\n+                LOG.error(\"Unknown Command Type\");\n+                status = ChaosConstants.TASK_ERROR_STRING;\n+            }\n+          } catch (IOException e) {\n+            LOG.error(\"Got error while executing command : \" + cmd +\n+              \" On agent : \" + agentName + \" Error : \" + e);\n+            status = ChaosConstants.TASK_ERROR_STRING;\n+          }\n+\n+          try {\n+            setStatusOfTaskZNode(path, status);\n+            Thread.sleep(ChaosConstants.SET_STATUS_SLEEP_TIME);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error occured after setting status: \" + e);\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting data\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Callback used while getting Tasks for agent if call executed without Exception,\n+   * It creates a separate thread for each children to execute given Tasks parallely.\n+   */\n+  AsyncCallback.ChildrenCallback getTasksForAgentCallback = new AsyncCallback.ChildrenCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to the server has been lost, getting tasks again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          getTasks();\n+          break;\n+\n+        case OK:\n+          if (children != null) {\n+            try {\n+\n+              LOG.info(\"Executing each task as a separate thread\");\n+              List<Thread> tasksList = new ArrayList<>();\n+              for (String task : children) {\n+                String threadName = agentName + \"_\" + task;\n+                Thread t = new Thread(() -> {\n+\n+                  LOG.info(\"Executing task : \" + task + \" of agent : \" + agentName);\n+                  zk.getData(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + task,\n+                    false,\n+                    getTaskForExecutionCallback,\n+                    task);\n+\n+                });\n+                t.setName(threadName);\n+                t.start();\n+                tasksList.add(t);\n+\n+                for (Thread thread : tasksList) {\n+                  thread.join();\n+                }\n+              }\n+            } catch (InterruptedException e) {\n+              LOG.error(\"Error scheduling next task : \" +\n+                \" for agent : \" + agentName + \" Error : \" + e);\n+            }\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting task\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Function to create PERSISTENT ZNODE with given path and data given as params\n+   * @param path Path at which ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.PERSISTENT,\n+      createZNodeCallback,\n+      data);\n+  }\n+\n+  /***\n+   * Function to create EPHEMERAL ZNODE with given path and data as params.\n+   * @param path Path at which Ephemeral ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createEphemeralZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.EPHEMERAL,\n+      createEphemeralZNodeCallback,\n+      data);\n+  }\n+\n+  /**\n+   * Checks if given ZNode exists, if not creates a PERSISTENT ZNODE for same.\n+   *\n+   * @param path Path to check for ZNode\n+   */\n+  private void createIfZNodeNotExists(String path) {\n+    try {\n+      if (zk.exists(path,\n+        false) == null) {\n+        createZNode(path, new byte[0]);\n+      }\n+    } catch (KeeperException | InterruptedException e) {\n+      LOG.error(\"Error checking given node : \" + path + \" \" + e);\n+    }\n+  }\n+\n+  /**\n+   * sets given Status for Task Znode\n+   *\n+   * @param taskZNode ZNode to set status\n+   * @param status Status value\n+   */\n+  public void setStatusOfTaskZNode(String taskZNode, String status) {\n+    LOG.info(\"Setting status of Task ZNode: \" + taskZNode + \" status : \" + status);\n+    zk.setData(taskZNode,\n+      status.getBytes(),\n+      -1,\n+      setStatusOfTaskZNodeCallback,\n+      null);\n+  }\n+\n+  /**\n+   * registration of ChaosAgent by checking and creating necessary ZNodes.\n+   */\n+  private void register() {\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_TEST_ROOT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName);\n+\n+    createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+  }\n+\n+  /***\n+   * Gets tasks for execution, basically sets Watch on it's respective host's Znode and\n+   * waits for tasks to be assigned, also has a getTasksForAgentCallback\n+   * which handles execution of task.\n+   */\n+  private void getTasks() {\n+    LOG.info(\"Getting Tasks for Agent: \" + agentName + \"and setting watch for new Tasks\");\n+    zk.getChildren(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+        ChaosConstants.ZNODE_PATH_SEPARATOR + agentName,\n+      newTaskCreatedWatcher,\n+      getTasksForAgentCallback,\n+      null);\n+  }\n+\n+  /**\n+   * Below function executes command with retries with given user.\n+   * Uses LocalShell to execute a command.\n+   *\n+   * @param user user name, default none\n+   * @param cmd Command to execute\n+   * @return A pair of Exit Code and Shell output\n+   * @throws IOException Exception while executing shell command\n+   */\n+  private Pair<Integer, String> execWithRetries(String user, String cmd) throws IOException {\n+    RetryCounter retryCounter = retryCounterFactory.create();\n+    while (true) {\n+      try {\n+        return exec(user, cmd);\n+      } catch (IOException e) {\n+        retryOrThrow(retryCounter, e, user, cmd);\n+      }\n+      try {\n+        retryCounter.sleepUntilNextRetry();\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"Sleep Interrupted: \" + e);\n+      }\n+    }\n+  }\n+\n+  private Pair<Integer, String> exec(String user, String cmd) throws IOException {\n+    LOG.info(\"Executing Shell command: \" + cmd + \" , user: \" + user);\n+\n+    LocalShell shell = new LocalShell(user, cmd);\n+    try {\n+      shell.execute();\n+    } catch (Shell.ExitCodeException e) {\n+      String output = shell.getOutput();\n+      throw new Shell.ExitCodeException(e.getExitCode(), \"stderr: \" + e.getMessage()\n+        + \", stdout: \" + output);\n+    }\n+    LOG.info(\"Executed Shell command, exit code: \" + shell.getExitCode() +\n+      \" , output:\" + shell.getOutput());\n+\n+    return new Pair<>(shell.getExitCode(), shell.getOutput());\n+  }\n+\n+  private <E extends Exception> void retryOrThrow(RetryCounter retryCounter, E ex,\n+    String user, String cmd) throws E {\n+    if (retryCounter.shouldRetry()) {\n+      LOG.warn(\"Local command: \" + cmd + \" , user:\" + user\n+        + \" failed at attempt \" + retryCounter.getAttemptTimes() + \". Retrying until maxAttempts: \"\n+        + retryCounter.getMaxAttempts() + \". Exception: \" + ex.getMessage());", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzNDI2Mg==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529634262", "bodyText": "Same here, if we can pass Callable to ExecutorServer and get blocked by Future.get() on each submission of callable impl, it would be great option.", "author": "virajjasani", "createdAt": "2020-11-24T15:27:32Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());\n+\n+        LOG.info(\"Change in Tasks Node, checking for Tasks again.\");\n+        getTasks();\n+      }\n+\n+    }\n+  };\n+\n+  //CALLBACKS: Below are the Callbacks used by Chaos Agent\n+\n+  /**\n+   * Callback used while setting status of a given task, Logs given status.\n+   */\n+  AsyncCallback.StatCallback setStatusOfTaskZNodeCallback = (rc, path, ctx, stat) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        // Connection to the server was lost while setting status setting again.\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        setStatusOfTaskZNode(path, (String) ctx);\n+        break;\n+\n+      case OK:\n+        LOG.info(\"Status of Task has been set\");\n+        break;\n+\n+      case NONODE:\n+        LOG.error(\"Chaos Agent status node does not exists: \"\n+          + \"check for ZNode directory structure again.\");\n+        break;\n+\n+      default:\n+        LOG.error(\"Error while setting status of task ZNode: \" +\n+          path, KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Persistent ZNode tries to create\n+   * ZNode again if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Persistent ZNode: \" + path,\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Ephemeral ZNode tries to create ZNode again\n+   * if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createEphemeralZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createEphemeralZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Ephemeral ZNode: \",\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used by getTasksForAgentCallback while getting command,\n+   * after getting command successfully, it executes command and\n+   * set its status with respect to the command type.\n+   */\n+  AsyncCallback.DataCallback getTaskForExecutionCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connection to the server has been lost while getting task, getting data again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          zk.getData(path,\n+            false,\n+            getTaskForExecutionCallback,\n+            new String(data));\n+          break;\n+        case OK:\n+          String cmd = new String(data);\n+          LOG.info(\"Executing command : \" + cmd);\n+          String status = ChaosConstants.TASK_COMPLETION_STRING;\n+          try {\n+            String user = conf.get(ChaosConstants.CHAOSAGENT_SHELL_USER,\n+              ChaosConstants.DEFAULT_SHELL_USER);\n+            switch (cmd.substring(0, 4)) {\n+              case \"bool\":\n+                String ret = execWithRetries(user, cmd.substring(4)).getSecond();\n+                status = Boolean.toString(ret.length() > 0);\n+                break;\n+\n+              case \"exec\":\n+                execWithRetries(user, cmd.substring(4));\n+                break;\n+\n+              default:\n+                LOG.error(\"Unknown Command Type\");\n+                status = ChaosConstants.TASK_ERROR_STRING;\n+            }\n+          } catch (IOException e) {\n+            LOG.error(\"Got error while executing command : \" + cmd +\n+              \" On agent : \" + agentName + \" Error : \" + e);\n+            status = ChaosConstants.TASK_ERROR_STRING;\n+          }\n+\n+          try {\n+            setStatusOfTaskZNode(path, status);\n+            Thread.sleep(ChaosConstants.SET_STATUS_SLEEP_TIME);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error occured after setting status: \" + e);\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting data\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Callback used while getting Tasks for agent if call executed without Exception,\n+   * It creates a separate thread for each children to execute given Tasks parallely.\n+   */\n+  AsyncCallback.ChildrenCallback getTasksForAgentCallback = new AsyncCallback.ChildrenCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to the server has been lost, getting tasks again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          getTasks();\n+          break;\n+\n+        case OK:\n+          if (children != null) {\n+            try {\n+\n+              LOG.info(\"Executing each task as a separate thread\");\n+              List<Thread> tasksList = new ArrayList<>();\n+              for (String task : children) {\n+                String threadName = agentName + \"_\" + task;\n+                Thread t = new Thread(() -> {", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg3MzQ2Mg==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r545873462", "bodyText": "This can also be follow up.", "author": "virajjasani", "createdAt": "2020-12-18T14:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzNDI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzNjE4Nw==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529636187", "bodyText": "Using { } would better differentiate the boundaries of each case:\n        case CONNECTIONLOSS: {\n        }\n        case OK: {\n        }", "author": "virajjasani", "createdAt": "2020-11-24T15:28:54Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());\n+\n+        LOG.info(\"Change in Tasks Node, checking for Tasks again.\");\n+        getTasks();\n+      }\n+\n+    }\n+  };\n+\n+  //CALLBACKS: Below are the Callbacks used by Chaos Agent\n+\n+  /**\n+   * Callback used while setting status of a given task, Logs given status.\n+   */\n+  AsyncCallback.StatCallback setStatusOfTaskZNodeCallback = (rc, path, ctx, stat) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        // Connection to the server was lost while setting status setting again.\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        setStatusOfTaskZNode(path, (String) ctx);\n+        break;\n+\n+      case OK:\n+        LOG.info(\"Status of Task has been set\");\n+        break;\n+\n+      case NONODE:\n+        LOG.error(\"Chaos Agent status node does not exists: \"\n+          + \"check for ZNode directory structure again.\");\n+        break;\n+\n+      default:\n+        LOG.error(\"Error while setting status of task ZNode: \" +\n+          path, KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Persistent ZNode tries to create\n+   * ZNode again if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Persistent ZNode: \" + path,\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Ephemeral ZNode tries to create ZNode again\n+   * if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createEphemeralZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createEphemeralZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Ephemeral ZNode: \",\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used by getTasksForAgentCallback while getting command,\n+   * after getting command successfully, it executes command and\n+   * set its status with respect to the command type.\n+   */\n+  AsyncCallback.DataCallback getTaskForExecutionCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connection to the server has been lost while getting task, getting data again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          zk.getData(path,\n+            false,\n+            getTaskForExecutionCallback,\n+            new String(data));\n+          break;\n+        case OK:\n+          String cmd = new String(data);\n+          LOG.info(\"Executing command : \" + cmd);\n+          String status = ChaosConstants.TASK_COMPLETION_STRING;\n+          try {\n+            String user = conf.get(ChaosConstants.CHAOSAGENT_SHELL_USER,\n+              ChaosConstants.DEFAULT_SHELL_USER);\n+            switch (cmd.substring(0, 4)) {\n+              case \"bool\":\n+                String ret = execWithRetries(user, cmd.substring(4)).getSecond();\n+                status = Boolean.toString(ret.length() > 0);\n+                break;\n+\n+              case \"exec\":\n+                execWithRetries(user, cmd.substring(4));\n+                break;\n+\n+              default:\n+                LOG.error(\"Unknown Command Type\");\n+                status = ChaosConstants.TASK_ERROR_STRING;\n+            }\n+          } catch (IOException e) {\n+            LOG.error(\"Got error while executing command : \" + cmd +\n+              \" On agent : \" + agentName + \" Error : \" + e);\n+            status = ChaosConstants.TASK_ERROR_STRING;\n+          }\n+\n+          try {\n+            setStatusOfTaskZNode(path, status);\n+            Thread.sleep(ChaosConstants.SET_STATUS_SLEEP_TIME);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error occured after setting status: \" + e);\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting data\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Callback used while getting Tasks for agent if call executed without Exception,\n+   * It creates a separate thread for each children to execute given Tasks parallely.\n+   */\n+  AsyncCallback.ChildrenCallback getTasksForAgentCallback = new AsyncCallback.ChildrenCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to the server has been lost, getting tasks again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          getTasks();\n+          break;\n+", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzNzY5MQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529637691", "bodyText": "Is this being used?", "author": "virajjasani", "createdAt": "2020-11-24T15:29:59Z", "path": "hbase-it/src/main/java/org/apache/hadoop/hbase/chaos/ChaosAgent.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.chaos;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.hadoop.hbase.util.RetryCounter;\n+import org.apache.hadoop.hbase.util.RetryCounterFactory;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/***\n+ * An agent for executing destructive actions for ChaosMonkey.\n+ * Uses ZooKeeper Watchersc and LocalShell, to do the killing\n+ * and getting status of service on targeted host without SSH.\n+ * uses given ZNode Structure:\n+ *  /perfChaosTest (root)\n+ *              |\n+ *              |\n+ *              /chaosAgents (Used for registration has\n+ *              hostname ephemeral nodes as children)\n+ *              |\n+ *              |\n+ *              /chaosAgentTaskStatus (Used for task\n+ *              Execution, has hostname persistent\n+ *              nodes as child with tasks as their children)\n+ *                          |\n+ *                          |\n+ *                          /hostname\n+ *                                |\n+ *                                |\n+ *                                /task0000001 (command as data)\n+ *                                (has two types of command :\n+ *                                     1: starts with \"exec\"\n+ *                                       for executing a destructive action.\n+ *                                     2: starts with \"bool\" for getting\n+ *                                       only status of service.\n+ *\n+ */\n+@InterfaceAudience.Private\n+public class ChaosAgent implements Watcher, Closeable, Runnable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosAgent.class.getName());\n+  static AtomicBoolean stopChaosAgent = new AtomicBoolean();\n+  private ZooKeeper zk;\n+  private String quorum;\n+  private String agentName;\n+  private Configuration conf;\n+  private RetryCounterFactory retryCounterFactory;\n+  private volatile boolean connected = false;\n+\n+  public ChaosAgent(Configuration conf, String quorum, String agentName) {\n+    initChaosAgent(conf, quorum, agentName);\n+  }\n+\n+  /***\n+   * sets global params and initiates connection with ZooKeeper then does registration.\n+   * @param conf initial configuration to use\n+   * @param quorum ZK Quorum\n+   * @param agentName AgentName to use\n+   */\n+  private void initChaosAgent(Configuration conf, String quorum, String agentName) {\n+    this.conf = conf;\n+    this.quorum = quorum;\n+    this.agentName = agentName;\n+    this.retryCounterFactory = new RetryCounterFactory(new RetryCounter.RetryConfig()\n+      .setMaxAttempts(conf.getInt(ChaosConstants.RETRY_ATTEMPTS_KEY,\n+        ChaosConstants.DEFAULT_RETRY_ATTEMPTS)).setSleepInterval(\n+          conf.getLong(ChaosConstants.RETRY_SLEEP_INTERVAL_KEY,\n+            ChaosConstants.DEFAULT_RETRY_SLEEP_INTERVAL)));\n+    try {\n+      this.createZKConnection(null);\n+      this.register();\n+    } catch (IOException e) {\n+      LOG.error(\"Error Creating Connection: \" + e);\n+    }\n+  }\n+\n+  /***\n+   * Creates Connection with ZooKeeper.\n+   * @throws IOException if something goes wrong\n+   */\n+  private void createZKConnection(Watcher watcher) throws IOException {\n+    if(watcher == null) {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, this);\n+    } else {\n+      zk = new ZooKeeper(quorum, ChaosConstants.SESSION_TIMEOUT_ZK, watcher);\n+    }\n+    LOG.info(\"ZooKeeper Connection created for ChaosAgent: \" + agentName);\n+  }\n+\n+  //WATCHERS: Below are the Watches used by ChaosAgent\n+\n+  /***\n+   * Watcher for notifying if any task is assigned to agent or not,\n+   * by seeking if any Node is being added to agent as Child.\n+   */\n+  Watcher newTaskCreatedWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged) {\n+        assert (ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName).equals(watchedEvent.getPath());\n+\n+        LOG.info(\"Change in Tasks Node, checking for Tasks again.\");\n+        getTasks();\n+      }\n+\n+    }\n+  };\n+\n+  //CALLBACKS: Below are the Callbacks used by Chaos Agent\n+\n+  /**\n+   * Callback used while setting status of a given task, Logs given status.\n+   */\n+  AsyncCallback.StatCallback setStatusOfTaskZNodeCallback = (rc, path, ctx, stat) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        // Connection to the server was lost while setting status setting again.\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        setStatusOfTaskZNode(path, (String) ctx);\n+        break;\n+\n+      case OK:\n+        LOG.info(\"Status of Task has been set\");\n+        break;\n+\n+      case NONODE:\n+        LOG.error(\"Chaos Agent status node does not exists: \"\n+          + \"check for ZNode directory structure again.\");\n+        break;\n+\n+      default:\n+        LOG.error(\"Error while setting status of task ZNode: \" +\n+          path, KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Persistent ZNode tries to create\n+   * ZNode again if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Persistent ZNode: \" + path,\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used while creating a Ephemeral ZNode tries to create ZNode again\n+   * if Connection was lost in previous try.\n+   */\n+  AsyncCallback.StringCallback createEphemeralZNodeCallback = (rc, path, ctx, name) -> {\n+    switch (KeeperException.Code.get(rc)) {\n+      case CONNECTIONLOSS:\n+        try {\n+          recreateZKConnection();\n+        } catch (Exception e) {\n+          break;\n+        }\n+        createEphemeralZNode(path, (byte[]) ctx);\n+        break;\n+      case OK:\n+        LOG.info(\"ZNode created : \" + path);\n+        break;\n+      case NODEEXISTS:\n+        LOG.warn(\"ZNode already registered: \" + path);\n+        break;\n+      default:\n+        LOG.error(\"Error occurred while creating Ephemeral ZNode: \",\n+          KeeperException.create(KeeperException.Code.get(rc), path));\n+    }\n+  };\n+\n+  /**\n+   * Callback used by getTasksForAgentCallback while getting command,\n+   * after getting command successfully, it executes command and\n+   * set its status with respect to the command type.\n+   */\n+  AsyncCallback.DataCallback getTaskForExecutionCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connection to the server has been lost while getting task, getting data again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          zk.getData(path,\n+            false,\n+            getTaskForExecutionCallback,\n+            new String(data));\n+          break;\n+        case OK:\n+          String cmd = new String(data);\n+          LOG.info(\"Executing command : \" + cmd);\n+          String status = ChaosConstants.TASK_COMPLETION_STRING;\n+          try {\n+            String user = conf.get(ChaosConstants.CHAOSAGENT_SHELL_USER,\n+              ChaosConstants.DEFAULT_SHELL_USER);\n+            switch (cmd.substring(0, 4)) {\n+              case \"bool\":\n+                String ret = execWithRetries(user, cmd.substring(4)).getSecond();\n+                status = Boolean.toString(ret.length() > 0);\n+                break;\n+\n+              case \"exec\":\n+                execWithRetries(user, cmd.substring(4));\n+                break;\n+\n+              default:\n+                LOG.error(\"Unknown Command Type\");\n+                status = ChaosConstants.TASK_ERROR_STRING;\n+            }\n+          } catch (IOException e) {\n+            LOG.error(\"Got error while executing command : \" + cmd +\n+              \" On agent : \" + agentName + \" Error : \" + e);\n+            status = ChaosConstants.TASK_ERROR_STRING;\n+          }\n+\n+          try {\n+            setStatusOfTaskZNode(path, status);\n+            Thread.sleep(ChaosConstants.SET_STATUS_SLEEP_TIME);\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error occured after setting status: \" + e);\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting data\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Callback used while getting Tasks for agent if call executed without Exception,\n+   * It creates a separate thread for each children to execute given Tasks parallely.\n+   */\n+  AsyncCallback.ChildrenCallback getTasksForAgentCallback = new AsyncCallback.ChildrenCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, List<String> children) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to the server has been lost, getting tasks again.\n+          try {\n+            recreateZKConnection();\n+          } catch (Exception e) {\n+            break;\n+          }\n+          getTasks();\n+          break;\n+\n+        case OK:\n+          if (children != null) {\n+            try {\n+\n+              LOG.info(\"Executing each task as a separate thread\");\n+              List<Thread> tasksList = new ArrayList<>();\n+              for (String task : children) {\n+                String threadName = agentName + \"_\" + task;\n+                Thread t = new Thread(() -> {\n+\n+                  LOG.info(\"Executing task : \" + task + \" of agent : \" + agentName);\n+                  zk.getData(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName +\n+                      ChaosConstants.ZNODE_PATH_SEPARATOR + task,\n+                    false,\n+                    getTaskForExecutionCallback,\n+                    task);\n+\n+                });\n+                t.setName(threadName);\n+                t.start();\n+                tasksList.add(t);\n+\n+                for (Thread thread : tasksList) {\n+                  thread.join();\n+                }\n+              }\n+            } catch (InterruptedException e) {\n+              LOG.error(\"Error scheduling next task : \" +\n+                \" for agent : \" + agentName + \" Error : \" + e);\n+            }\n+          }\n+\n+        default:\n+          LOG.error(\"Error occurred while getting task\",\n+            KeeperException.create(KeeperException.Code.get(rc), path));\n+      }\n+    }\n+  };\n+\n+  /***\n+   * Function to create PERSISTENT ZNODE with given path and data given as params\n+   * @param path Path at which ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.PERSISTENT,\n+      createZNodeCallback,\n+      data);\n+  }\n+\n+  /***\n+   * Function to create EPHEMERAL ZNODE with given path and data as params.\n+   * @param path Path at which Ephemeral ZNode to create\n+   * @param data Data to put under ZNode\n+   */\n+  public void createEphemeralZNode(String path, byte[] data) {\n+    zk.create(path,\n+      data,\n+      ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+      CreateMode.EPHEMERAL,\n+      createEphemeralZNodeCallback,\n+      data);\n+  }\n+\n+  /**\n+   * Checks if given ZNode exists, if not creates a PERSISTENT ZNODE for same.\n+   *\n+   * @param path Path to check for ZNode\n+   */\n+  private void createIfZNodeNotExists(String path) {\n+    try {\n+      if (zk.exists(path,\n+        false) == null) {\n+        createZNode(path, new byte[0]);\n+      }\n+    } catch (KeeperException | InterruptedException e) {\n+      LOG.error(\"Error checking given node : \" + path + \" \" + e);\n+    }\n+  }\n+\n+  /**\n+   * sets given Status for Task Znode\n+   *\n+   * @param taskZNode ZNode to set status\n+   * @param status Status value\n+   */\n+  public void setStatusOfTaskZNode(String taskZNode, String status) {\n+    LOG.info(\"Setting status of Task ZNode: \" + taskZNode + \" status : \" + status);\n+    zk.setData(taskZNode,\n+      status.getBytes(),\n+      -1,\n+      setStatusOfTaskZNodeCallback,\n+      null);\n+  }\n+\n+  /**\n+   * registration of ChaosAgent by checking and creating necessary ZNodes.\n+   */\n+  private void register() {\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_TEST_ROOT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE);\n+    createIfZNodeNotExists(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName);\n+\n+    createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+      ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+  }\n+\n+  /***\n+   * Gets tasks for execution, basically sets Watch on it's respective host's Znode and\n+   * waits for tasks to be assigned, also has a getTasksForAgentCallback\n+   * which handles execution of task.\n+   */\n+  private void getTasks() {\n+    LOG.info(\"Getting Tasks for Agent: \" + agentName + \"and setting watch for new Tasks\");\n+    zk.getChildren(ChaosConstants.CHAOS_AGENT_STATUS_PERSISTENT_ZNODE +\n+        ChaosConstants.ZNODE_PATH_SEPARATOR + agentName,\n+      newTaskCreatedWatcher,\n+      getTasksForAgentCallback,\n+      null);\n+  }\n+\n+  /**\n+   * Below function executes command with retries with given user.\n+   * Uses LocalShell to execute a command.\n+   *\n+   * @param user user name, default none\n+   * @param cmd Command to execute\n+   * @return A pair of Exit Code and Shell output\n+   * @throws IOException Exception while executing shell command\n+   */\n+  private Pair<Integer, String> execWithRetries(String user, String cmd) throws IOException {\n+    RetryCounter retryCounter = retryCounterFactory.create();\n+    while (true) {\n+      try {\n+        return exec(user, cmd);\n+      } catch (IOException e) {\n+        retryOrThrow(retryCounter, e, user, cmd);\n+      }\n+      try {\n+        retryCounter.sleepUntilNextRetry();\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"Sleep Interrupted: \" + e);\n+      }\n+    }\n+  }\n+\n+  private Pair<Integer, String> exec(String user, String cmd) throws IOException {\n+    LOG.info(\"Executing Shell command: \" + cmd + \" , user: \" + user);\n+\n+    LocalShell shell = new LocalShell(user, cmd);\n+    try {\n+      shell.execute();\n+    } catch (Shell.ExitCodeException e) {\n+      String output = shell.getOutput();\n+      throw new Shell.ExitCodeException(e.getExitCode(), \"stderr: \" + e.getMessage()\n+        + \", stdout: \" + output);\n+    }\n+    LOG.info(\"Executed Shell command, exit code: \" + shell.getExitCode() +\n+      \" , output:\" + shell.getOutput());\n+\n+    return new Pair<>(shell.getExitCode(), shell.getOutput());\n+  }\n+\n+  private <E extends Exception> void retryOrThrow(RetryCounter retryCounter, E ex,\n+    String user, String cmd) throws E {\n+    if (retryCounter.shouldRetry()) {\n+      LOG.warn(\"Local command: \" + cmd + \" , user:\" + user\n+        + \" failed at attempt \" + retryCounter.getAttemptTimes() + \". Retrying until maxAttempts: \"\n+        + retryCounter.getMaxAttempts() + \". Exception: \" + ex.getMessage());\n+      return;\n+    }\n+    throw ex;\n+  }\n+\n+  private boolean isConnected() {\n+    return connected;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    LOG.info(\"Closing ZooKeeper Connection for Chaos Agent : \" + agentName);\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while closing ZooKeeper Connection.\");\n+    }\n+  }\n+\n+  @Override\n+  public void run() {\n+    try {\n+      LOG.info(\"Running Chaos Agent on : \" + agentName);\n+      while (!this.isConnected()) {\n+        Thread.sleep(100);\n+      }\n+      this.getTasks();\n+      while (!stopChaosAgent.get()) {\n+        Thread.sleep(500);\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error while running Chaos Agent\");\n+    }\n+\n+  }\n+\n+  @Override\n+  public void process(WatchedEvent watchedEvent) {\n+    LOG.info(\"Processing event: \" + watchedEvent.toString());\n+    if (watchedEvent.getType() == Event.EventType.None) {\n+      switch (watchedEvent.getState()) {\n+        case SyncConnected:\n+          connected = true;\n+          break;\n+        case Disconnected:\n+          connected = false;\n+          break;\n+        case Expired:\n+          connected = false;\n+          LOG.error(\"Session expired creating again\");\n+          try {\n+            createZKConnection(null);\n+          } catch (IOException e) {\n+            LOG.error(\"Error creating Zookeeper connection\");\n+          }\n+        default:\n+          LOG.error(\"Unknown State\");\n+          break;\n+      }\n+    }\n+  }\n+\n+  private void recreateZKConnection() throws Exception{\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error closing ZK connection : \" + e);\n+      throw new RuntimeException(e) ;\n+    } finally {\n+      try {\n+        createZKConnection(newTaskCreatedWatcher);\n+        createEphemeralZNode(ChaosConstants.CHAOS_AGENT_REGISTRATION_EPIMERAL_ZNODE +\n+          ChaosConstants.ZNODE_PATH_SEPARATOR + agentName, new byte[0]);\n+      } catch (IOException e) {\n+        LOG.error(\"Error creating new ZK COnnection for agent: \" + agentName + e);\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Executes Command locally.\n+   */\n+  protected class LocalShell extends Shell.ShellCommandExecutor {\n+\n+    private String user;\n+    private String execCommand;\n+\n+    public LocalShell(String user, String execCommand) {\n+      super(new String[]{execCommand});\n+      this.user = user;\n+      this.execCommand = execCommand;\n+    }\n+\n+    public LocalShell(String[] execString, File dir, Map<String, String> env, long timeout) {", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0NTU3Nw==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529645577", "bodyText": "nit: keep it final?", "author": "virajjasani", "createdAt": "2020-11-24T15:35:40Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ChaosZKClient.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.hbase.util.Threads;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@InterfaceAudience.Private\n+public class ChaosZKClient {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosZKClient.class.getName());\n+  private static final String CHAOS_AGENT_PARENT_ZNODE = \"/hbase/chaosAgents\";\n+  private static final String CHAOS_AGENT_STATUS_ZNODE = \"/hbase/chaosAgentTaskStatus\";\n+  private static final String ZNODE_PATH_SEPARATOR = \"/\";\n+  private static final String TASK_PREFIX = \"task_\";\n+  private static final String TASK_ERROR_STRING = \"error\";\n+  private static final String TASK_COMPLETION_STRING = \"done\";\n+  private static final String TASK_BOOLEAN_TRUE = \"true\";\n+  private static final String TASK_BOOLEAN_FALSE = \"false\";\n+  private static final String CONNECTION_LOSS = \"ConnectionLoss\";\n+  private static final int SESSION_TIMEOUT_ZK = 10 * 60 * 1000;\n+  private static final int TASK_EXECUTION_TIMEOUT = 5 * 60 * 1000;\n+  private volatile String taskStatus = null;\n+\n+  private String quorum;", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0Njg1Mw==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529646853", "bodyText": "nit: let's keep both as final", "author": "virajjasani", "createdAt": "2020-11-24T15:36:29Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ChaosZKClient.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.hbase.util.Threads;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@InterfaceAudience.Private\n+public class ChaosZKClient {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosZKClient.class.getName());\n+  private static final String CHAOS_AGENT_PARENT_ZNODE = \"/hbase/chaosAgents\";\n+  private static final String CHAOS_AGENT_STATUS_ZNODE = \"/hbase/chaosAgentTaskStatus\";\n+  private static final String ZNODE_PATH_SEPARATOR = \"/\";\n+  private static final String TASK_PREFIX = \"task_\";\n+  private static final String TASK_ERROR_STRING = \"error\";\n+  private static final String TASK_COMPLETION_STRING = \"done\";\n+  private static final String TASK_BOOLEAN_TRUE = \"true\";\n+  private static final String TASK_BOOLEAN_FALSE = \"false\";\n+  private static final String CONNECTION_LOSS = \"ConnectionLoss\";\n+  private static final int SESSION_TIMEOUT_ZK = 10 * 60 * 1000;\n+  private static final int TASK_EXECUTION_TIMEOUT = 5 * 60 * 1000;\n+  private volatile String taskStatus = null;\n+\n+  private String quorum;\n+  private ZooKeeper zk;\n+\n+  public ChaosZKClient(String quorum) {\n+    this.quorum = quorum;\n+    try {\n+      this.createNewZKConnection();\n+    } catch (IOException e) {\n+      LOG.error(\"Error creating ZooKeeper Connection: \" + e);\n+    }\n+  }\n+\n+  /**\n+   * Creates connection with ZooKeeper\n+   * @throws IOException when not able to create connection properly\n+   */\n+  public void createNewZKConnection() throws IOException {\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent watchedEvent) {\n+        LOG.info(\"Created ZooKeeper Connection For executing task\");\n+      }\n+    };\n+\n+    this.zk = new ZooKeeper(quorum, SESSION_TIMEOUT_ZK, watcher);\n+  }\n+\n+  /**\n+   * Checks if ChaosAgent is running or not on target host by checking its ZNode.\n+   * @param hostname hostname to check for chaosagent\n+   * @return true/false whether agent is running or not\n+   */\n+  private boolean isChaosAgentRunning(String hostname) {\n+    try {\n+      return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+        false) != null;\n+    } catch (KeeperException e) {\n+      if (e.toString().contains(CONNECTION_LOSS)) {\n+        recreateZKConnection();\n+        try {\n+          return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+            false) != null;\n+        } catch (KeeperException  | InterruptedException ie) {\n+          LOG.error(\"ERROR \" + ie);\n+        }\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error checking for given hostname: \" + hostname + \" ERROR: \" + e);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates tasks for target hosts by creating ZNodes.\n+   * Waits for a limited amount of time to complete task to execute.\n+   * @param taskObject Object data represents command\n+   * @return returns status\n+   */\n+  public String submitTask(final TaskObject taskObject) {\n+    if (isChaosAgentRunning(taskObject.getTaskHostname())) {\n+      LOG.info(\"Creating task node\");\n+      zk.create(CHAOS_AGENT_STATUS_ZNODE + ZNODE_PATH_SEPARATOR +\n+          taskObject.getTaskHostname() + ZNODE_PATH_SEPARATOR + TASK_PREFIX,\n+        taskObject.getCommand().getBytes(),\n+        ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+        CreateMode.EPHEMERAL_SEQUENTIAL,\n+        submitTaskCallback,\n+        taskObject);\n+      long start = System.currentTimeMillis();\n+\n+      while ((System.currentTimeMillis() - start) < TASK_EXECUTION_TIMEOUT) {\n+        if(taskStatus != null) {\n+          return taskStatus;\n+        }\n+        Threads.sleep(500);\n+      }\n+    } else {\n+      LOG.info(\"EHHHHH!  ChaosAgent Not running\");\n+    }\n+    return TASK_ERROR_STRING;\n+  }\n+\n+  /**\n+   * To get status of task submitted\n+   * @param path path at which to get status\n+   * @param ctx path context\n+   */\n+  private void getStatus(String path , Object ctx) {\n+    LOG.info(\"Getting Status of task: \" + path);\n+    zk.getData(path,\n+      false,\n+      getStatusCallback,\n+      ctx);\n+  }\n+\n+  /**\n+   * Set a watch on task submitted\n+   * @param name ZNode name to set a watch\n+   * @param taskObject context for ZNode name\n+   */\n+  private void setStatusWatch(String name, TaskObject taskObject) {\n+    LOG.info(\"Checking for ZNode and Setting watch for task : \" + name);\n+    zk.exists(name,\n+      setStatusWatcher,\n+      setStatusWatchCallback,\n+      taskObject);\n+  }\n+\n+  /**\n+   * Delete task after getting its status\n+   * @param path path to delete ZNode\n+   */\n+  private void deleteTask(String path) {\n+    LOG.info(\"Deleting task: \" + path);\n+    zk.delete(path,\n+      -1,\n+      taskDeleteCallback,\n+      null);\n+  }\n+\n+  //WATCHERS:\n+\n+  /**\n+   * Watcher to get notification whenever status of task changes.\n+   */\n+  Watcher setStatusWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      LOG.info(\"Setting status watch for task: \" + watchedEvent.getPath());\n+      if(watchedEvent.getType() == Event.EventType.NodeDataChanged) {\n+        assert watchedEvent.getPath().contains(TASK_PREFIX);\n+        getStatus(watchedEvent.getPath(), (Object) watchedEvent.getPath());\n+\n+      }\n+    }\n+  };\n+\n+  //CALLBACKS\n+\n+  AsyncCallback.DataCallback getStatusCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while getting status of task, getting again\n+          recreateZKConnection();\n+          getStatus(path, ctx);\n+          break;\n+\n+        case OK:\n+          if (ctx!=null) {\n+\n+            String status = new String(data);\n+            taskStatus = status;\n+            switch (status) {\n+              case TASK_COMPLETION_STRING:\n+              case TASK_BOOLEAN_TRUE:\n+              case TASK_BOOLEAN_FALSE:\n+                LOG.info(\"Task executed completely : Status --> \" + status);\n+                break;\n+\n+              case TASK_ERROR_STRING:\n+                LOG.info(\"There was error while executing task : Status --> \" + status);\n+                break;\n+\n+              default:\n+                LOG.warn(\"Status of task is undefined!! : Status --> \" + status);\n+            }\n+\n+            deleteTask(path);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while getting status of task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StatCallback setStatusWatchCallback = new AsyncCallback.StatCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //ConnectionLoss while setting watch on status ZNode, setting again.\n+          recreateZKConnection();\n+          setStatusWatch(path, (TaskObject) ctx);\n+          break;\n+\n+        case OK:\n+          if(stat != null) {\n+            getStatus(path, null);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while setting watch on task ZNode: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StringCallback submitTaskCallback = new AsyncCallback.StringCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, String name) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to server was lost while submitting task, submitting again.\n+          recreateZKConnection();\n+          submitTask((TaskObject) ctx);\n+          break;\n+\n+        case OK:\n+          LOG.info(\"Task created : \" + name);\n+          setStatusWatch(name, (TaskObject) ctx);\n+          break;\n+\n+        default:\n+          LOG.error(\"Error submitting task: \" + name + \" ERROR:\" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.VoidCallback taskDeleteCallback = new AsyncCallback.VoidCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while deleting task, deleting again\n+          recreateZKConnection();\n+          deleteTask(path);\n+          break;\n+\n+        case OK:\n+          LOG.info(\"Task Deleted successfully!\");\n+          LOG.info(\"Closing ZooKeeper Connection\");\n+          try {\n+            zk.close();\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error while closing ZooKeeper Connection.\");\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while deleting task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+\n+  private void recreateZKConnection() {\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error closing ZK connection : \" + e);\n+    } finally {\n+      try {\n+        createNewZKConnection();\n+      } catch (IOException e) {\n+        LOG.error(\"Error creating new ZK COnnection for agent: \" + e);\n+      }\n+    }\n+  }\n+\n+  static class TaskObject {\n+    private String command;\n+    private String taskHostname;", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0NzcxOQ==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529647719", "bodyText": "same as others: log should have Exception as arg", "author": "virajjasani", "createdAt": "2020-11-24T15:37:06Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ChaosZKClient.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.hbase.util.Threads;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@InterfaceAudience.Private\n+public class ChaosZKClient {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosZKClient.class.getName());\n+  private static final String CHAOS_AGENT_PARENT_ZNODE = \"/hbase/chaosAgents\";\n+  private static final String CHAOS_AGENT_STATUS_ZNODE = \"/hbase/chaosAgentTaskStatus\";\n+  private static final String ZNODE_PATH_SEPARATOR = \"/\";\n+  private static final String TASK_PREFIX = \"task_\";\n+  private static final String TASK_ERROR_STRING = \"error\";\n+  private static final String TASK_COMPLETION_STRING = \"done\";\n+  private static final String TASK_BOOLEAN_TRUE = \"true\";\n+  private static final String TASK_BOOLEAN_FALSE = \"false\";\n+  private static final String CONNECTION_LOSS = \"ConnectionLoss\";\n+  private static final int SESSION_TIMEOUT_ZK = 10 * 60 * 1000;\n+  private static final int TASK_EXECUTION_TIMEOUT = 5 * 60 * 1000;\n+  private volatile String taskStatus = null;\n+\n+  private String quorum;\n+  private ZooKeeper zk;\n+\n+  public ChaosZKClient(String quorum) {\n+    this.quorum = quorum;\n+    try {\n+      this.createNewZKConnection();\n+    } catch (IOException e) {\n+      LOG.error(\"Error creating ZooKeeper Connection: \" + e);\n+    }\n+  }\n+\n+  /**\n+   * Creates connection with ZooKeeper\n+   * @throws IOException when not able to create connection properly\n+   */\n+  public void createNewZKConnection() throws IOException {\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent watchedEvent) {\n+        LOG.info(\"Created ZooKeeper Connection For executing task\");\n+      }\n+    };\n+\n+    this.zk = new ZooKeeper(quorum, SESSION_TIMEOUT_ZK, watcher);\n+  }\n+\n+  /**\n+   * Checks if ChaosAgent is running or not on target host by checking its ZNode.\n+   * @param hostname hostname to check for chaosagent\n+   * @return true/false whether agent is running or not\n+   */\n+  private boolean isChaosAgentRunning(String hostname) {\n+    try {\n+      return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+        false) != null;\n+    } catch (KeeperException e) {\n+      if (e.toString().contains(CONNECTION_LOSS)) {\n+        recreateZKConnection();\n+        try {\n+          return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+            false) != null;\n+        } catch (KeeperException  | InterruptedException ie) {\n+          LOG.error(\"ERROR \" + ie);\n+        }\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error checking for given hostname: \" + hostname + \" ERROR: \" + e);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates tasks for target hosts by creating ZNodes.\n+   * Waits for a limited amount of time to complete task to execute.\n+   * @param taskObject Object data represents command\n+   * @return returns status\n+   */\n+  public String submitTask(final TaskObject taskObject) {\n+    if (isChaosAgentRunning(taskObject.getTaskHostname())) {\n+      LOG.info(\"Creating task node\");\n+      zk.create(CHAOS_AGENT_STATUS_ZNODE + ZNODE_PATH_SEPARATOR +\n+          taskObject.getTaskHostname() + ZNODE_PATH_SEPARATOR + TASK_PREFIX,\n+        taskObject.getCommand().getBytes(),\n+        ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+        CreateMode.EPHEMERAL_SEQUENTIAL,\n+        submitTaskCallback,\n+        taskObject);\n+      long start = System.currentTimeMillis();\n+\n+      while ((System.currentTimeMillis() - start) < TASK_EXECUTION_TIMEOUT) {\n+        if(taskStatus != null) {\n+          return taskStatus;\n+        }\n+        Threads.sleep(500);\n+      }\n+    } else {\n+      LOG.info(\"EHHHHH!  ChaosAgent Not running\");\n+    }\n+    return TASK_ERROR_STRING;\n+  }\n+\n+  /**\n+   * To get status of task submitted\n+   * @param path path at which to get status\n+   * @param ctx path context\n+   */\n+  private void getStatus(String path , Object ctx) {\n+    LOG.info(\"Getting Status of task: \" + path);\n+    zk.getData(path,\n+      false,\n+      getStatusCallback,\n+      ctx);\n+  }\n+\n+  /**\n+   * Set a watch on task submitted\n+   * @param name ZNode name to set a watch\n+   * @param taskObject context for ZNode name\n+   */\n+  private void setStatusWatch(String name, TaskObject taskObject) {\n+    LOG.info(\"Checking for ZNode and Setting watch for task : \" + name);\n+    zk.exists(name,\n+      setStatusWatcher,\n+      setStatusWatchCallback,\n+      taskObject);\n+  }\n+\n+  /**\n+   * Delete task after getting its status\n+   * @param path path to delete ZNode\n+   */\n+  private void deleteTask(String path) {\n+    LOG.info(\"Deleting task: \" + path);\n+    zk.delete(path,\n+      -1,\n+      taskDeleteCallback,\n+      null);\n+  }\n+\n+  //WATCHERS:\n+\n+  /**\n+   * Watcher to get notification whenever status of task changes.\n+   */\n+  Watcher setStatusWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      LOG.info(\"Setting status watch for task: \" + watchedEvent.getPath());\n+      if(watchedEvent.getType() == Event.EventType.NodeDataChanged) {\n+        assert watchedEvent.getPath().contains(TASK_PREFIX);\n+        getStatus(watchedEvent.getPath(), (Object) watchedEvent.getPath());\n+\n+      }\n+    }\n+  };\n+\n+  //CALLBACKS\n+\n+  AsyncCallback.DataCallback getStatusCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while getting status of task, getting again\n+          recreateZKConnection();\n+          getStatus(path, ctx);\n+          break;\n+\n+        case OK:\n+          if (ctx!=null) {\n+\n+            String status = new String(data);\n+            taskStatus = status;\n+            switch (status) {\n+              case TASK_COMPLETION_STRING:\n+              case TASK_BOOLEAN_TRUE:\n+              case TASK_BOOLEAN_FALSE:\n+                LOG.info(\"Task executed completely : Status --> \" + status);\n+                break;\n+\n+              case TASK_ERROR_STRING:\n+                LOG.info(\"There was error while executing task : Status --> \" + status);\n+                break;\n+\n+              default:\n+                LOG.warn(\"Status of task is undefined!! : Status --> \" + status);\n+            }\n+\n+            deleteTask(path);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while getting status of task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StatCallback setStatusWatchCallback = new AsyncCallback.StatCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //ConnectionLoss while setting watch on status ZNode, setting again.\n+          recreateZKConnection();\n+          setStatusWatch(path, (TaskObject) ctx);\n+          break;\n+\n+        case OK:\n+          if(stat != null) {\n+            getStatus(path, null);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while setting watch on task ZNode: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StringCallback submitTaskCallback = new AsyncCallback.StringCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, String name) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to server was lost while submitting task, submitting again.\n+          recreateZKConnection();\n+          submitTask((TaskObject) ctx);\n+          break;\n+\n+        case OK:\n+          LOG.info(\"Task created : \" + name);\n+          setStatusWatch(name, (TaskObject) ctx);\n+          break;\n+\n+        default:\n+          LOG.error(\"Error submitting task: \" + name + \" ERROR:\" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.VoidCallback taskDeleteCallback = new AsyncCallback.VoidCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while deleting task, deleting again\n+          recreateZKConnection();\n+          deleteTask(path);\n+          break;\n+\n+        case OK:\n+          LOG.info(\"Task Deleted successfully!\");\n+          LOG.info(\"Closing ZooKeeper Connection\");\n+          try {\n+            zk.close();\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error while closing ZooKeeper Connection.\");\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while deleting task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+\n+  private void recreateZKConnection() {\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error closing ZK connection : \" + e);\n+    } finally {\n+      try {\n+        createNewZKConnection();\n+      } catch (IOException e) {\n+        LOG.error(\"Error creating new ZK COnnection for agent: \" + e);", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0ODE5Mg==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529648192", "bodyText": "same as others: log should have Exception as arg", "author": "virajjasani", "createdAt": "2020-11-24T15:37:25Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ChaosZKClient.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.hbase.util.Threads;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@InterfaceAudience.Private\n+public class ChaosZKClient {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosZKClient.class.getName());\n+  private static final String CHAOS_AGENT_PARENT_ZNODE = \"/hbase/chaosAgents\";\n+  private static final String CHAOS_AGENT_STATUS_ZNODE = \"/hbase/chaosAgentTaskStatus\";\n+  private static final String ZNODE_PATH_SEPARATOR = \"/\";\n+  private static final String TASK_PREFIX = \"task_\";\n+  private static final String TASK_ERROR_STRING = \"error\";\n+  private static final String TASK_COMPLETION_STRING = \"done\";\n+  private static final String TASK_BOOLEAN_TRUE = \"true\";\n+  private static final String TASK_BOOLEAN_FALSE = \"false\";\n+  private static final String CONNECTION_LOSS = \"ConnectionLoss\";\n+  private static final int SESSION_TIMEOUT_ZK = 10 * 60 * 1000;\n+  private static final int TASK_EXECUTION_TIMEOUT = 5 * 60 * 1000;\n+  private volatile String taskStatus = null;\n+\n+  private String quorum;\n+  private ZooKeeper zk;\n+\n+  public ChaosZKClient(String quorum) {\n+    this.quorum = quorum;\n+    try {\n+      this.createNewZKConnection();\n+    } catch (IOException e) {\n+      LOG.error(\"Error creating ZooKeeper Connection: \" + e);\n+    }\n+  }\n+\n+  /**\n+   * Creates connection with ZooKeeper\n+   * @throws IOException when not able to create connection properly\n+   */\n+  public void createNewZKConnection() throws IOException {\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent watchedEvent) {\n+        LOG.info(\"Created ZooKeeper Connection For executing task\");\n+      }\n+    };\n+\n+    this.zk = new ZooKeeper(quorum, SESSION_TIMEOUT_ZK, watcher);\n+  }\n+\n+  /**\n+   * Checks if ChaosAgent is running or not on target host by checking its ZNode.\n+   * @param hostname hostname to check for chaosagent\n+   * @return true/false whether agent is running or not\n+   */\n+  private boolean isChaosAgentRunning(String hostname) {\n+    try {\n+      return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+        false) != null;\n+    } catch (KeeperException e) {\n+      if (e.toString().contains(CONNECTION_LOSS)) {\n+        recreateZKConnection();\n+        try {\n+          return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+            false) != null;\n+        } catch (KeeperException  | InterruptedException ie) {\n+          LOG.error(\"ERROR \" + ie);\n+        }\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error checking for given hostname: \" + hostname + \" ERROR: \" + e);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates tasks for target hosts by creating ZNodes.\n+   * Waits for a limited amount of time to complete task to execute.\n+   * @param taskObject Object data represents command\n+   * @return returns status\n+   */\n+  public String submitTask(final TaskObject taskObject) {\n+    if (isChaosAgentRunning(taskObject.getTaskHostname())) {\n+      LOG.info(\"Creating task node\");\n+      zk.create(CHAOS_AGENT_STATUS_ZNODE + ZNODE_PATH_SEPARATOR +\n+          taskObject.getTaskHostname() + ZNODE_PATH_SEPARATOR + TASK_PREFIX,\n+        taskObject.getCommand().getBytes(),\n+        ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+        CreateMode.EPHEMERAL_SEQUENTIAL,\n+        submitTaskCallback,\n+        taskObject);\n+      long start = System.currentTimeMillis();\n+\n+      while ((System.currentTimeMillis() - start) < TASK_EXECUTION_TIMEOUT) {\n+        if(taskStatus != null) {\n+          return taskStatus;\n+        }\n+        Threads.sleep(500);\n+      }\n+    } else {\n+      LOG.info(\"EHHHHH!  ChaosAgent Not running\");\n+    }\n+    return TASK_ERROR_STRING;\n+  }\n+\n+  /**\n+   * To get status of task submitted\n+   * @param path path at which to get status\n+   * @param ctx path context\n+   */\n+  private void getStatus(String path , Object ctx) {\n+    LOG.info(\"Getting Status of task: \" + path);\n+    zk.getData(path,\n+      false,\n+      getStatusCallback,\n+      ctx);\n+  }\n+\n+  /**\n+   * Set a watch on task submitted\n+   * @param name ZNode name to set a watch\n+   * @param taskObject context for ZNode name\n+   */\n+  private void setStatusWatch(String name, TaskObject taskObject) {\n+    LOG.info(\"Checking for ZNode and Setting watch for task : \" + name);\n+    zk.exists(name,\n+      setStatusWatcher,\n+      setStatusWatchCallback,\n+      taskObject);\n+  }\n+\n+  /**\n+   * Delete task after getting its status\n+   * @param path path to delete ZNode\n+   */\n+  private void deleteTask(String path) {\n+    LOG.info(\"Deleting task: \" + path);\n+    zk.delete(path,\n+      -1,\n+      taskDeleteCallback,\n+      null);\n+  }\n+\n+  //WATCHERS:\n+\n+  /**\n+   * Watcher to get notification whenever status of task changes.\n+   */\n+  Watcher setStatusWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      LOG.info(\"Setting status watch for task: \" + watchedEvent.getPath());\n+      if(watchedEvent.getType() == Event.EventType.NodeDataChanged) {\n+        assert watchedEvent.getPath().contains(TASK_PREFIX);\n+        getStatus(watchedEvent.getPath(), (Object) watchedEvent.getPath());\n+\n+      }\n+    }\n+  };\n+\n+  //CALLBACKS\n+\n+  AsyncCallback.DataCallback getStatusCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while getting status of task, getting again\n+          recreateZKConnection();\n+          getStatus(path, ctx);\n+          break;\n+\n+        case OK:\n+          if (ctx!=null) {\n+\n+            String status = new String(data);\n+            taskStatus = status;\n+            switch (status) {\n+              case TASK_COMPLETION_STRING:\n+              case TASK_BOOLEAN_TRUE:\n+              case TASK_BOOLEAN_FALSE:\n+                LOG.info(\"Task executed completely : Status --> \" + status);\n+                break;\n+\n+              case TASK_ERROR_STRING:\n+                LOG.info(\"There was error while executing task : Status --> \" + status);\n+                break;\n+\n+              default:\n+                LOG.warn(\"Status of task is undefined!! : Status --> \" + status);\n+            }\n+\n+            deleteTask(path);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while getting status of task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StatCallback setStatusWatchCallback = new AsyncCallback.StatCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //ConnectionLoss while setting watch on status ZNode, setting again.\n+          recreateZKConnection();\n+          setStatusWatch(path, (TaskObject) ctx);\n+          break;\n+\n+        case OK:\n+          if(stat != null) {\n+            getStatus(path, null);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while setting watch on task ZNode: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StringCallback submitTaskCallback = new AsyncCallback.StringCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, String name) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          // Connection to server was lost while submitting task, submitting again.\n+          recreateZKConnection();\n+          submitTask((TaskObject) ctx);\n+          break;\n+\n+        case OK:\n+          LOG.info(\"Task created : \" + name);\n+          setStatusWatch(name, (TaskObject) ctx);\n+          break;\n+\n+        default:\n+          LOG.error(\"Error submitting task: \" + name + \" ERROR:\" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.VoidCallback taskDeleteCallback = new AsyncCallback.VoidCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while deleting task, deleting again\n+          recreateZKConnection();\n+          deleteTask(path);\n+          break;\n+\n+        case OK:\n+          LOG.info(\"Task Deleted successfully!\");\n+          LOG.info(\"Closing ZooKeeper Connection\");\n+          try {\n+            zk.close();\n+          } catch (InterruptedException e) {\n+            LOG.error(\"Error while closing ZooKeeper Connection.\");\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while deleting task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+\n+  private void recreateZKConnection() {\n+    try {\n+      zk.close();\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error closing ZK connection : \" + e);", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MDEwMg==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529650102", "bodyText": "nit: use lambda similar to setStatusOfTaskZNodeCallback?", "author": "virajjasani", "createdAt": "2020-11-24T15:38:46Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ChaosZKClient.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.hbase.util.Threads;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@InterfaceAudience.Private\n+public class ChaosZKClient {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosZKClient.class.getName());\n+  private static final String CHAOS_AGENT_PARENT_ZNODE = \"/hbase/chaosAgents\";\n+  private static final String CHAOS_AGENT_STATUS_ZNODE = \"/hbase/chaosAgentTaskStatus\";\n+  private static final String ZNODE_PATH_SEPARATOR = \"/\";\n+  private static final String TASK_PREFIX = \"task_\";\n+  private static final String TASK_ERROR_STRING = \"error\";\n+  private static final String TASK_COMPLETION_STRING = \"done\";\n+  private static final String TASK_BOOLEAN_TRUE = \"true\";\n+  private static final String TASK_BOOLEAN_FALSE = \"false\";\n+  private static final String CONNECTION_LOSS = \"ConnectionLoss\";\n+  private static final int SESSION_TIMEOUT_ZK = 10 * 60 * 1000;\n+  private static final int TASK_EXECUTION_TIMEOUT = 5 * 60 * 1000;\n+  private volatile String taskStatus = null;\n+\n+  private String quorum;\n+  private ZooKeeper zk;\n+\n+  public ChaosZKClient(String quorum) {\n+    this.quorum = quorum;\n+    try {\n+      this.createNewZKConnection();\n+    } catch (IOException e) {\n+      LOG.error(\"Error creating ZooKeeper Connection: \" + e);\n+    }\n+  }\n+\n+  /**\n+   * Creates connection with ZooKeeper\n+   * @throws IOException when not able to create connection properly\n+   */\n+  public void createNewZKConnection() throws IOException {\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent watchedEvent) {\n+        LOG.info(\"Created ZooKeeper Connection For executing task\");\n+      }\n+    };\n+\n+    this.zk = new ZooKeeper(quorum, SESSION_TIMEOUT_ZK, watcher);\n+  }\n+\n+  /**\n+   * Checks if ChaosAgent is running or not on target host by checking its ZNode.\n+   * @param hostname hostname to check for chaosagent\n+   * @return true/false whether agent is running or not\n+   */\n+  private boolean isChaosAgentRunning(String hostname) {\n+    try {\n+      return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+        false) != null;\n+    } catch (KeeperException e) {\n+      if (e.toString().contains(CONNECTION_LOSS)) {\n+        recreateZKConnection();\n+        try {\n+          return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+            false) != null;\n+        } catch (KeeperException  | InterruptedException ie) {\n+          LOG.error(\"ERROR \" + ie);\n+        }\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error checking for given hostname: \" + hostname + \" ERROR: \" + e);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates tasks for target hosts by creating ZNodes.\n+   * Waits for a limited amount of time to complete task to execute.\n+   * @param taskObject Object data represents command\n+   * @return returns status\n+   */\n+  public String submitTask(final TaskObject taskObject) {\n+    if (isChaosAgentRunning(taskObject.getTaskHostname())) {\n+      LOG.info(\"Creating task node\");\n+      zk.create(CHAOS_AGENT_STATUS_ZNODE + ZNODE_PATH_SEPARATOR +\n+          taskObject.getTaskHostname() + ZNODE_PATH_SEPARATOR + TASK_PREFIX,\n+        taskObject.getCommand().getBytes(),\n+        ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+        CreateMode.EPHEMERAL_SEQUENTIAL,\n+        submitTaskCallback,\n+        taskObject);\n+      long start = System.currentTimeMillis();\n+\n+      while ((System.currentTimeMillis() - start) < TASK_EXECUTION_TIMEOUT) {\n+        if(taskStatus != null) {\n+          return taskStatus;\n+        }\n+        Threads.sleep(500);\n+      }\n+    } else {\n+      LOG.info(\"EHHHHH!  ChaosAgent Not running\");\n+    }\n+    return TASK_ERROR_STRING;\n+  }\n+\n+  /**\n+   * To get status of task submitted\n+   * @param path path at which to get status\n+   * @param ctx path context\n+   */\n+  private void getStatus(String path , Object ctx) {\n+    LOG.info(\"Getting Status of task: \" + path);\n+    zk.getData(path,\n+      false,\n+      getStatusCallback,\n+      ctx);\n+  }\n+\n+  /**\n+   * Set a watch on task submitted\n+   * @param name ZNode name to set a watch\n+   * @param taskObject context for ZNode name\n+   */\n+  private void setStatusWatch(String name, TaskObject taskObject) {\n+    LOG.info(\"Checking for ZNode and Setting watch for task : \" + name);\n+    zk.exists(name,\n+      setStatusWatcher,\n+      setStatusWatchCallback,\n+      taskObject);\n+  }\n+\n+  /**\n+   * Delete task after getting its status\n+   * @param path path to delete ZNode\n+   */\n+  private void deleteTask(String path) {\n+    LOG.info(\"Deleting task: \" + path);\n+    zk.delete(path,\n+      -1,\n+      taskDeleteCallback,\n+      null);\n+  }\n+\n+  //WATCHERS:\n+\n+  /**\n+   * Watcher to get notification whenever status of task changes.\n+   */\n+  Watcher setStatusWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      LOG.info(\"Setting status watch for task: \" + watchedEvent.getPath());\n+      if(watchedEvent.getType() == Event.EventType.NodeDataChanged) {\n+        assert watchedEvent.getPath().contains(TASK_PREFIX);\n+        getStatus(watchedEvent.getPath(), (Object) watchedEvent.getPath());\n+\n+      }\n+    }\n+  };\n+\n+  //CALLBACKS\n+\n+  AsyncCallback.DataCallback getStatusCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while getting status of task, getting again\n+          recreateZKConnection();\n+          getStatus(path, ctx);\n+          break;\n+\n+        case OK:\n+          if (ctx!=null) {\n+\n+            String status = new String(data);\n+            taskStatus = status;\n+            switch (status) {\n+              case TASK_COMPLETION_STRING:\n+              case TASK_BOOLEAN_TRUE:\n+              case TASK_BOOLEAN_FALSE:\n+                LOG.info(\"Task executed completely : Status --> \" + status);\n+                break;\n+\n+              case TASK_ERROR_STRING:\n+                LOG.info(\"There was error while executing task : Status --> \" + status);\n+                break;\n+\n+              default:\n+                LOG.warn(\"Status of task is undefined!! : Status --> \" + status);\n+            }\n+\n+            deleteTask(path);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while getting status of task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StatCallback setStatusWatchCallback = new AsyncCallback.StatCallback() {", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MDk3Mw==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529650973", "bodyText": "nit: use lambda similar to setStatusOfTaskZNodeCallback?", "author": "virajjasani", "createdAt": "2020-11-24T15:39:26Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ChaosZKClient.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.hbase.util.Threads;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@InterfaceAudience.Private\n+public class ChaosZKClient {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosZKClient.class.getName());\n+  private static final String CHAOS_AGENT_PARENT_ZNODE = \"/hbase/chaosAgents\";\n+  private static final String CHAOS_AGENT_STATUS_ZNODE = \"/hbase/chaosAgentTaskStatus\";\n+  private static final String ZNODE_PATH_SEPARATOR = \"/\";\n+  private static final String TASK_PREFIX = \"task_\";\n+  private static final String TASK_ERROR_STRING = \"error\";\n+  private static final String TASK_COMPLETION_STRING = \"done\";\n+  private static final String TASK_BOOLEAN_TRUE = \"true\";\n+  private static final String TASK_BOOLEAN_FALSE = \"false\";\n+  private static final String CONNECTION_LOSS = \"ConnectionLoss\";\n+  private static final int SESSION_TIMEOUT_ZK = 10 * 60 * 1000;\n+  private static final int TASK_EXECUTION_TIMEOUT = 5 * 60 * 1000;\n+  private volatile String taskStatus = null;\n+\n+  private String quorum;\n+  private ZooKeeper zk;\n+\n+  public ChaosZKClient(String quorum) {\n+    this.quorum = quorum;\n+    try {\n+      this.createNewZKConnection();\n+    } catch (IOException e) {\n+      LOG.error(\"Error creating ZooKeeper Connection: \" + e);\n+    }\n+  }\n+\n+  /**\n+   * Creates connection with ZooKeeper\n+   * @throws IOException when not able to create connection properly\n+   */\n+  public void createNewZKConnection() throws IOException {\n+    Watcher watcher = new Watcher() {\n+      @Override\n+      public void process(WatchedEvent watchedEvent) {\n+        LOG.info(\"Created ZooKeeper Connection For executing task\");\n+      }\n+    };\n+\n+    this.zk = new ZooKeeper(quorum, SESSION_TIMEOUT_ZK, watcher);\n+  }\n+\n+  /**\n+   * Checks if ChaosAgent is running or not on target host by checking its ZNode.\n+   * @param hostname hostname to check for chaosagent\n+   * @return true/false whether agent is running or not\n+   */\n+  private boolean isChaosAgentRunning(String hostname) {\n+    try {\n+      return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+        false) != null;\n+    } catch (KeeperException e) {\n+      if (e.toString().contains(CONNECTION_LOSS)) {\n+        recreateZKConnection();\n+        try {\n+          return zk.exists(CHAOS_AGENT_PARENT_ZNODE + ZNODE_PATH_SEPARATOR + hostname,\n+            false) != null;\n+        } catch (KeeperException  | InterruptedException ie) {\n+          LOG.error(\"ERROR \" + ie);\n+        }\n+      }\n+    } catch (InterruptedException e) {\n+      LOG.error(\"Error checking for given hostname: \" + hostname + \" ERROR: \" + e);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Creates tasks for target hosts by creating ZNodes.\n+   * Waits for a limited amount of time to complete task to execute.\n+   * @param taskObject Object data represents command\n+   * @return returns status\n+   */\n+  public String submitTask(final TaskObject taskObject) {\n+    if (isChaosAgentRunning(taskObject.getTaskHostname())) {\n+      LOG.info(\"Creating task node\");\n+      zk.create(CHAOS_AGENT_STATUS_ZNODE + ZNODE_PATH_SEPARATOR +\n+          taskObject.getTaskHostname() + ZNODE_PATH_SEPARATOR + TASK_PREFIX,\n+        taskObject.getCommand().getBytes(),\n+        ZooDefs.Ids.OPEN_ACL_UNSAFE,\n+        CreateMode.EPHEMERAL_SEQUENTIAL,\n+        submitTaskCallback,\n+        taskObject);\n+      long start = System.currentTimeMillis();\n+\n+      while ((System.currentTimeMillis() - start) < TASK_EXECUTION_TIMEOUT) {\n+        if(taskStatus != null) {\n+          return taskStatus;\n+        }\n+        Threads.sleep(500);\n+      }\n+    } else {\n+      LOG.info(\"EHHHHH!  ChaosAgent Not running\");\n+    }\n+    return TASK_ERROR_STRING;\n+  }\n+\n+  /**\n+   * To get status of task submitted\n+   * @param path path at which to get status\n+   * @param ctx path context\n+   */\n+  private void getStatus(String path , Object ctx) {\n+    LOG.info(\"Getting Status of task: \" + path);\n+    zk.getData(path,\n+      false,\n+      getStatusCallback,\n+      ctx);\n+  }\n+\n+  /**\n+   * Set a watch on task submitted\n+   * @param name ZNode name to set a watch\n+   * @param taskObject context for ZNode name\n+   */\n+  private void setStatusWatch(String name, TaskObject taskObject) {\n+    LOG.info(\"Checking for ZNode and Setting watch for task : \" + name);\n+    zk.exists(name,\n+      setStatusWatcher,\n+      setStatusWatchCallback,\n+      taskObject);\n+  }\n+\n+  /**\n+   * Delete task after getting its status\n+   * @param path path to delete ZNode\n+   */\n+  private void deleteTask(String path) {\n+    LOG.info(\"Deleting task: \" + path);\n+    zk.delete(path,\n+      -1,\n+      taskDeleteCallback,\n+      null);\n+  }\n+\n+  //WATCHERS:\n+\n+  /**\n+   * Watcher to get notification whenever status of task changes.\n+   */\n+  Watcher setStatusWatcher = new Watcher() {\n+    @Override\n+    public void process(WatchedEvent watchedEvent) {\n+      LOG.info(\"Setting status watch for task: \" + watchedEvent.getPath());\n+      if(watchedEvent.getType() == Event.EventType.NodeDataChanged) {\n+        assert watchedEvent.getPath().contains(TASK_PREFIX);\n+        getStatus(watchedEvent.getPath(), (Object) watchedEvent.getPath());\n+\n+      }\n+    }\n+  };\n+\n+  //CALLBACKS\n+\n+  AsyncCallback.DataCallback getStatusCallback = new AsyncCallback.DataCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //Connectionloss while getting status of task, getting again\n+          recreateZKConnection();\n+          getStatus(path, ctx);\n+          break;\n+\n+        case OK:\n+          if (ctx!=null) {\n+\n+            String status = new String(data);\n+            taskStatus = status;\n+            switch (status) {\n+              case TASK_COMPLETION_STRING:\n+              case TASK_BOOLEAN_TRUE:\n+              case TASK_BOOLEAN_FALSE:\n+                LOG.info(\"Task executed completely : Status --> \" + status);\n+                break;\n+\n+              case TASK_ERROR_STRING:\n+                LOG.info(\"There was error while executing task : Status --> \" + status);\n+                break;\n+\n+              default:\n+                LOG.warn(\"Status of task is undefined!! : Status --> \" + status);\n+            }\n+\n+            deleteTask(path);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while getting status of task: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StatCallback setStatusWatchCallback = new AsyncCallback.StatCallback() {\n+    @Override\n+    public void processResult(int rc, String path, Object ctx, Stat stat) {\n+      switch (KeeperException.Code.get(rc)) {\n+        case CONNECTIONLOSS:\n+          //ConnectionLoss while setting watch on status ZNode, setting again.\n+          recreateZKConnection();\n+          setStatusWatch(path, (TaskObject) ctx);\n+          break;\n+\n+        case OK:\n+          if(stat != null) {\n+            getStatus(path, null);\n+          }\n+          break;\n+\n+        default:\n+          LOG.error(\"ERROR while setting watch on task ZNode: \" + path + \" ERROR: \" +\n+            KeeperException.create(KeeperException.Code.get(rc)));\n+      }\n+    }\n+  };\n+\n+  AsyncCallback.StringCallback submitTaskCallback = new AsyncCallback.StringCallback() {", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY1MjM1MA==", "url": "https://github.com/apache/hbase/pull/2299#discussion_r529652350", "bodyText": "Exception as last argument", "author": "virajjasani", "createdAt": "2020-11-24T15:40:20Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ChaosZKClient.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.hbase.util.Threads;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.apache.zookeeper.AsyncCallback;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.WatchedEvent;\n+import org.apache.zookeeper.Watcher;\n+import org.apache.zookeeper.ZooDefs;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@InterfaceAudience.Private\n+public class ChaosZKClient {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ChaosZKClient.class.getName());\n+  private static final String CHAOS_AGENT_PARENT_ZNODE = \"/hbase/chaosAgents\";\n+  private static final String CHAOS_AGENT_STATUS_ZNODE = \"/hbase/chaosAgentTaskStatus\";\n+  private static final String ZNODE_PATH_SEPARATOR = \"/\";\n+  private static final String TASK_PREFIX = \"task_\";\n+  private static final String TASK_ERROR_STRING = \"error\";\n+  private static final String TASK_COMPLETION_STRING = \"done\";\n+  private static final String TASK_BOOLEAN_TRUE = \"true\";\n+  private static final String TASK_BOOLEAN_FALSE = \"false\";\n+  private static final String CONNECTION_LOSS = \"ConnectionLoss\";\n+  private static final int SESSION_TIMEOUT_ZK = 10 * 60 * 1000;\n+  private static final int TASK_EXECUTION_TIMEOUT = 5 * 60 * 1000;\n+  private volatile String taskStatus = null;\n+\n+  private String quorum;\n+  private ZooKeeper zk;\n+\n+  public ChaosZKClient(String quorum) {\n+    this.quorum = quorum;\n+    try {\n+      this.createNewZKConnection();\n+    } catch (IOException e) {\n+      LOG.error(\"Error creating ZooKeeper Connection: \" + e);", "originalCommit": "75319c812ad5d2ec73b7c82571728da46dbff8ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1579f3229989c1601d170b0ba202f3f54162d550", "url": "https://github.com/apache/hbase/commit/1579f3229989c1601d170b0ba202f3f54162d550", "message": "nits", "committedDate": "2020-12-12T20:44:59Z", "type": "commit"}, {"oid": "676fd6bd93e74cafa680654222da6934689c4699", "url": "https://github.com/apache/hbase/commit/676fd6bd93e74cafa680654222da6934689c4699", "message": "nits", "committedDate": "2020-12-12T20:46:23Z", "type": "commit"}, {"oid": "4ef2f586a6d290d8db0db4200927db563df9dd48", "url": "https://github.com/apache/hbase/commit/4ef2f586a6d290d8db0db4200927db563df9dd48", "message": "Merge branch 'master' of https://github.com/apache/hbase into HBASE-24620", "committedDate": "2020-12-19T10:20:26Z", "type": "commit"}, {"oid": "c1bb1e5ea3791791acc8b6131ebef2ffd2a1798a", "url": "https://github.com/apache/hbase/commit/c1bb1e5ea3791791acc8b6131ebef2ffd2a1798a", "message": "Removing asserts", "committedDate": "2020-12-19T10:27:35Z", "type": "commit"}]}