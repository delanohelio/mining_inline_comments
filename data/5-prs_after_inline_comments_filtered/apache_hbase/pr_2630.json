{"pr_number": 2630, "pr_title": "HBASE-25242 Add Increment/Append support to RowMutations", "pr_createdAt": "2020-11-07T14:16:30Z", "pr_url": "https://github.com/apache/hbase/pull/2630", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDE1MQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r520340151", "bodyText": "Let's also test for Append and keep the last else branch throwing DoNotRetryIOException?", "author": "Apache9", "createdAt": "2020-11-10T07:19:22Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3657,9 +3657,10 @@ public static CheckAndMutate toCheckAndMutate(ClientProtos.Condition condition,\n           return builder.build((Put) m);\n         } else if (m instanceof Delete) {\n           return builder.build((Delete) m);\n+        } else if (m instanceof Increment) {\n+          return builder.build((Increment) m);\n         } else {\n-          throw new DoNotRetryIOException(\"Unsupported mutate type: \" + mutations.get(0)\n-            .getClass().getSimpleName().toUpperCase());\n+          return builder.build((Append) m);", "originalCommit": "d086fea73cd92687610bc15882f59a1a6a771902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMzMyMA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r522923320", "bodyText": "After this change, only Put/Delete/Increment/Append inherit Mutation. Do we still need to test for Append and keep the last else branch throwing DoNotRetryIOException?", "author": "brfrn169", "createdAt": "2020-11-13T12:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNTM5MQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528205391", "bodyText": "This is for safety. Maybe in the future someone other than us two will implement a new type of Mutation and we will throw a DoNotRetryIOException directly here which will be easy to know what's wrong here, otherwise the behavior will be confusing.", "author": "Apache9", "createdAt": "2020-11-21T15:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxMzMyOA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528213328", "bodyText": "Sure. I will add testing for Append and keep the last else branch throwing DoNotRetryIOException.", "author": "brfrn169", "createdAt": "2020-11-21T16:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDUzNw==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r520340537", "bodyText": "Why this change?", "author": "Apache9", "createdAt": "2020-11-10T07:20:22Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/CheckAndMutate.java", "diffHunk": "@@ -60,7 +53,7 @@\n  */\n @InterfaceAudience.Public\n @InterfaceStability.Evolving\n-public final class CheckAndMutate extends Mutation {\n+public final class CheckAndMutate implements Row {", "originalCommit": "d086fea73cd92687610bc15882f59a1a6a771902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyMDg4NA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r522920884", "bodyText": "In HBASE-24996 and HBASE-24210, I gave up treating CheckAndMutate as Mutation where we can perform CheckAndMutate with other mutations atomically. Given that, I thought it would be better to make CheckAndMutate implement Row because CheckAndMutate had a lot of unsupported methods. What do you think?", "author": "brfrn169", "createdAt": "2020-11-13T12:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNTYyNQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528205625", "bodyText": "OK, I'm fine with it, but since this is IA.Public, we need to make sure that we haven't release this class out yet? There will be a 2.4.0 release soon.", "author": "Apache9", "createdAt": "2020-11-21T15:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxMzA2OA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528213068", "bodyText": "We haven't released the CheckAndMutate class yet. It's introduced in 2.4.0. We need to commit this change before releasing 2.4.0.", "author": "brfrn169", "createdAt": "2020-11-21T16:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MjExOQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r520342119", "bodyText": "This is an optimization?", "author": "Apache9", "createdAt": "2020-11-10T07:24:19Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3900,33 +3903,51 @@ public void prepareMiniBatchOperations(MiniBatchOperationInProgress<Mutation> mi\n             Bytes.toBytes(timestamp));\n           miniBatchOp.incrementNumOfDeletes();\n         } else if (mutation instanceof Increment || mutation instanceof Append) {\n+          boolean returnResults;\n+          if (mutation instanceof Increment) {\n+            returnResults = ((Increment) mutation).isReturnResults();\n+          } else {\n+            returnResults = ((Append) mutation).isReturnResults();\n+          }\n+\n           // For nonce operations\n           canProceed[index] = startNonceOperation(nonceGroup, nonce);\n           if (!canProceed[index]) {\n-            // convert duplicate increment/append to get\n-            List<Cell> results = region.get(toGet(mutation), false, nonceGroup, nonce);\n-            retCodeDetails[index] = new OperationStatus(OperationStatusCode.SUCCESS,\n-              Result.create(results));\n+            Result result;\n+            if (returnResults) {", "originalCommit": "d086fea73cd92687610bc15882f59a1a6a771902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNjg3NA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r522926874", "bodyText": "This change is that if Increment/Append.isReturnResults() is true, we will return an empty result in case of the retry situation. Originally, it looks like in case of the retry situation, we returned actual result whatever Increment/Append.isReturnResults() is.", "author": "brfrn169", "createdAt": "2020-11-13T12:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MjExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0Njc4Nw==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r520346787", "bodyText": "At least for JDK8, stream is slow so let's avoid stream on critical read/write path as much as possible for now.", "author": "Apache9", "createdAt": "2020-11-10T07:35:11Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8303,11 +8289,23 @@ void metricsUpdateForGet(List<Cell> results, long before) {\n   }\n \n   @Override\n-  public void mutateRow(RowMutations rm) throws IOException {\n-    // Don't need nonces here - RowMutations only supports puts and deletes\n+  public Result mutateRow(RowMutations rm) throws IOException {\n     final List<Mutation> m = rm.getMutations();\n-    batchMutate(m.toArray(new Mutation[m.size()]), true, HConstants.NO_NONCE,\n-        HConstants.NO_NONCE);\n+    OperationStatus[] operationStatuses = batchMutate(m.toArray(new Mutation[0]), true,\n+      HConstants.NO_NONCE, HConstants.NO_NONCE);\n+\n+    List<Result> results = Arrays.stream(operationStatuses)", "originalCommit": "d086fea73cd92687610bc15882f59a1a6a771902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNzQ3MQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r522927471", "bodyText": "Sure, I will change it not to use stream. Thanks.", "author": "brfrn169", "createdAt": "2020-11-13T12:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0Njc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzM5NA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r520347394", "bodyText": "Why change to AssertionError?", "author": "Apache9", "createdAt": "2020-11-10T07:36:37Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java", "diffHunk": "@@ -620,8 +622,22 @@ private CheckAndMutateResult checkAndMutate(HRegion region, List<ClientProtos.Ac\n             spaceQuotaEnforcement.getPolicyEnforcement(region).check(del);\n             mutations.add(del);\n             break;\n+          case INCREMENT:\n+            Increment increment = ProtobufUtil.toIncrement(action.getMutation(), cellScanner);\n+            ++countOfCompleteMutation;\n+            checkCellSizeLimit(region, increment);\n+            spaceQuotaEnforcement.getPolicyEnforcement(region).check(increment);\n+            mutations.add(increment);\n+            break;\n+          case APPEND:\n+            Append append = ProtobufUtil.toAppend(action.getMutation(), cellScanner);\n+            ++countOfCompleteMutation;\n+            checkCellSizeLimit(region, append);\n+            spaceQuotaEnforcement.getPolicyEnforcement(region).check(append);\n+            mutations.add(append);\n+            break;\n           default:\n-            throw new DoNotRetryIOException(\"Atomic put and/or delete only, not \" + type.name());\n+            throw new AssertionError(\"invalid mutation type : \" + type);", "originalCommit": "d086fea73cd92687610bc15882f59a1a6a771902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzMDEzNQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r522930135", "bodyText": "MutationType can be set to only Put/Delete/Increment/Append. And this switch statement has all the cases (Put/Delete/Increment/Append) after this change, so it is impossible to go the default case. That's why I change it to AssertionError, which means if we hit this AssertionError, it's something a bug. Do you think we should still use DoNotRetryIOException?", "author": "brfrn169", "createdAt": "2020-11-13T12:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNTg3Mw==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528205873", "bodyText": "I think what you said is also reasonable, but since this is an rpc method, we can not make sure whether the remote side has the same code with us at server side, so I still prefer a DoNotRetryIOException here. Let's not change it for now.", "author": "Apache9", "createdAt": "2020-11-21T15:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxMzUzNQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528213535", "bodyText": "Sure. I will revert this change.", "author": "brfrn169", "createdAt": "2020-11-21T16:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzgxMQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r520347811", "bodyText": "Why remove atomic?", "author": "Apache9", "createdAt": "2020-11-10T07:37:36Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java", "diffHunk": "@@ -972,11 +1003,41 @@ private void doBatchOp(final RegionActionResult.Builder builder, final HRegion r\n \n       OperationStatus[] codes = region.batchMutate(mArray, atomic, HConstants.NO_NONCE,\n         HConstants.NO_NONCE);\n+      if (atomic) {\n+        LinkedList<ResultOrException> resultOrExceptions = new LinkedList<>();\n+        List<Result> results = new ArrayList<>();\n+        for (i = 0; i < codes.length; i++) {\n+          if (codes[i].getResult() != null) {\n+            results.add(codes[i].getResult());\n+          }\n+          if (i != 0) {\n+            resultOrExceptions.add(getResultOrException(\n+              ClientProtos.Result.getDefaultInstance(), i));\n+          }\n+        }\n+\n+        if (results.isEmpty()) {\n+          resultOrExceptions.addFirst(getResultOrException(\n+            ClientProtos.Result.getDefaultInstance(), 0));\n+        } else {\n+          // Set the result of the Increment/Append operations to the first element of the\n+          // ResultOrException list\n+          Result result = Result.create(results.stream()\n+            .filter(r -> r.rawCells() != null)\n+            .flatMap(r -> Arrays.stream(r.rawCells()))\n+            .collect(Collectors.toList()));\n+          resultOrExceptions.addFirst(getResultOrException(ProtobufUtil.toResult(result), 0));\n+        }\n+\n+        builder.addAllResultOrException(resultOrExceptions);\n+        return;\n+      }\n+\n       for (i = 0; i < codes.length; i++) {\n         Mutation currentMutation = mArray[i];\n         ClientProtos.Action currentAction = mutationActionMap.get(currentMutation);\n-        int index = currentAction.hasIndex() || !atomic ? currentAction.getIndex() : i;\n-        Exception e = null;\n+        int index = currentAction.hasIndex() ? currentAction.getIndex() : i;", "originalCommit": "d086fea73cd92687610bc15882f59a1a6a771902", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkzMzI5Ng==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r522933296", "bodyText": "This is because I added if statement when atomic is true the above. So atomic is always false here.", "author": "brfrn169", "createdAt": "2020-11-13T12:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzY4OQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528207689", "bodyText": "OK, just saw that there is a return above.", "author": "Apache9", "createdAt": "2020-11-21T15:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0NzgxMQ=="}], "type": "inlineReview"}, {"oid": "399e3fd41fb02d0ec45bd91fe368c63828ca721b", "url": "https://github.com/apache/hbase/commit/399e3fd41fb02d0ec45bd91fe368c63828ca721b", "message": "HBASE-25242 Add Increment/Append support to RowMutations", "committedDate": "2020-11-13T13:32:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNjY5Mw==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528206693", "bodyText": "nits: could remove the empty throws so we could fix on checkstyle warning.", "author": "Apache9", "createdAt": "2020-11-21T15:12:45Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/Table.java", "diffHunk": "@@ -459,9 +459,10 @@ default CheckAndMutateResult checkAndMutate(CheckAndMutate checkAndMutate) throw\n    * {@link Put} and {@link Delete} are supported.\n    *\n    * @param rm object that specifies the set of mutations to perform atomically\n+   * @return results of Increment/Append operations\n    * @throws IOException", "originalCommit": "399e3fd41fb02d0ec45bd91fe368c63828ca721b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxMzEyNg==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528213126", "bodyText": "Sure. I will do that.", "author": "brfrn169", "createdAt": "2020-11-21T16:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNjY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzAzNA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528207034", "bodyText": "Mind explaing a bit about this change here? Seems the logic is changed?", "author": "Apache9", "createdAt": "2020-11-21T15:16:04Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ResponseConverter.java", "diffHunk": "@@ -158,52 +156,30 @@ public static SingleResponse getResult(final ClientProtos.MutateRequest request,\n         // If there is an exception from the server, the exception is set at\n         // the RegionActionResult level, which has been handled above.\n         if (actions.hasCondition()) {\n-          Result result = null;\n-          if (actionResult.getResultOrExceptionCount() > 0) {\n-            ResultOrException roe = actionResult.getResultOrException(0);\n-            if (roe.hasResult()) {\n-              Result r = ProtobufUtil.toResult(roe.getResult(), cells);\n-              if (!r.isEmpty()) {\n-                result = r;\n-              }\n-            }\n-          }\n-          responseValue = new CheckAndMutateResult(actionResult.getProcessed(), result);\n+          results.add(regionName, index, getCheckAndMutateResult(actionResult, cells));\n         } else {\n-          responseValue = actionResult.getProcessed() ?\n-            ProtobufUtil.EMPTY_RESULT_EXISTS_TRUE :\n-            ProtobufUtil.EMPTY_RESULT_EXISTS_FALSE;\n+          results.add(regionName, index, getMutateRowResult(actionResult, cells));\n         }\n-        results.add(regionName, index, responseValue);\n         continue;\n       }\n \n       if (actions.hasCondition()) {\n-        Result result = null;\n-        if (actionResult.getResultOrExceptionCount() > 0) {\n-          ResultOrException roe = actionResult.getResultOrException(0);\n-          Result r = ProtobufUtil.toResult(roe.getResult(), cells);\n-          if (!r.isEmpty()) {\n-            result = r;\n-          }\n-        }\n-        responseValue = new CheckAndMutateResult(actionResult.getProcessed(), result);\n-        results.add(regionName, 0, responseValue);\n+        results.add(regionName, 0, getCheckAndMutateResult(actionResult, cells));\n       } else {\n+        if (actionResult.hasProcessed()) {", "originalCommit": "399e3fd41fb02d0ec45bd91fe368c63828ca721b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxNTE4Mw==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528215183", "bodyText": "The case where actions.hasCondition() is false and actionResult.hasProcessed() is true is the case for a result of mutateRow(). After this change, mutateRow() can return results of Increment/Append operations. That's why we need to add this logic here.", "author": "brfrn169", "createdAt": "2020-11-21T16:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzI3MQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528207271", "bodyText": "Good. It is usually dangerous to use byte[] as the key of a HashMap...", "author": "Apache9", "createdAt": "2020-11-21T15:18:35Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4008,28 +4029,10 @@ private static Get toGet(final Mutation mutation) throws IOException {\n       return get;\n     }\n \n-    /**\n-     * Do coprocessor pre-increment or pre-append after row lock call.\n-     * @return Result returned out of the coprocessor, which means bypass all further processing\n-     *   and return the preferred Result instead, or null which means proceed.\n-     */\n-    private Result doCoprocessorPreCallAfterRowLock(Mutation mutation) throws IOException {\n-      assert mutation instanceof Increment || mutation instanceof Append;\n-      Result result = null;\n-      if (region.coprocessorHost != null) {\n-        if (mutation instanceof Increment) {\n-          result = region.coprocessorHost.preIncrementAfterRowLock((Increment) mutation);\n-        } else {\n-          result = region.coprocessorHost.preAppendAfterRowLock((Append) mutation);\n-        }\n-      }\n-      return result;\n-    }\n-\n     private Map<byte[], List<Cell>> reckonDeltas(Mutation mutation, List<Cell> results,\n       long now) throws IOException {\n       assert mutation instanceof Increment || mutation instanceof Append;\n-      Map<byte[], List<Cell>> ret = new HashMap<>();\n+      Map<byte[], List<Cell>> ret = new TreeMap<>(Bytes.BYTES_COMPARATOR);", "originalCommit": "399e3fd41fb02d0ec45bd91fe368c63828ca721b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzg0OA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528207848", "bodyText": "Better to use ArrayList instead of LinkedList. ArrayList is faster than LinkedList for most cases. I can not recall the exact number but at least for thousands elements ArrayList is still faster.", "author": "Apache9", "createdAt": "2020-11-21T15:24:24Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java", "diffHunk": "@@ -972,11 +1002,44 @@ private void doBatchOp(final RegionActionResult.Builder builder, final HRegion r\n \n       OperationStatus[] codes = region.batchMutate(mArray, atomic, HConstants.NO_NONCE,\n         HConstants.NO_NONCE);\n+      if (atomic) {\n+        LinkedList<ResultOrException> resultOrExceptions = new LinkedList<>();", "originalCommit": "399e3fd41fb02d0ec45bd91fe368c63828ca721b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIxNDY3NQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528214675", "bodyText": "The reason why I use LinkedList here is that I need to add a element at the beginning of the list as follows:\nhttps://github.com/apache/hbase/pull/2630/files#diff-e4052cd5a1f1c93375e3fbc931dc4df220deebc78c0d53fd2435b47fd04cd807R1019-R1020\nhttps://github.com/apache/hbase/pull/2630/files#diff-e4052cd5a1f1c93375e3fbc931dc4df220deebc78c0d53fd2435b47fd04cd807R1031\nStill ArrayList is faster in that case?", "author": "brfrn169", "createdAt": "2020-11-21T16:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODMzMjc3NQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528332775", "bodyText": "Oh, if we want to add element at first then ArrayList is not suitable. But usually we could use other array based data structure such as ArrayDeque. Let me take a look at the code.", "author": "Apache9", "createdAt": "2020-11-22T13:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIwNzg0OA=="}], "type": "inlineReview"}, {"oid": "2a3bf95c4ace9218bb5aa2ca264287b50b7de3b4", "url": "https://github.com/apache/hbase/commit/2a3bf95c4ace9218bb5aa2ca264287b50b7de3b4", "message": "HBASE-25242 Add Increment/Append support to RowMutations", "committedDate": "2020-11-22T00:50:32Z", "type": "forcePushed"}, {"oid": "2baf627e968559cd48e02581092e422e413ca3fb", "url": "https://github.com/apache/hbase/commit/2baf627e968559cd48e02581092e422e413ca3fb", "message": "HBASE-25242 Add Increment/Append support to RowMutations", "committedDate": "2020-11-22T02:24:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM0OTA4Nw==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528349087", "bodyText": "I think here we could just call builder.addResultOrException directly to add the first ResultOrException? And then call addAllResultOrException to add the remaining ResultOrExceptions in the list, so we do not need to add a new element in front?", "author": "Apache9", "createdAt": "2020-11-22T15:12:30Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java", "diffHunk": "@@ -972,11 +1001,44 @@ private void doBatchOp(final RegionActionResult.Builder builder, final HRegion r\n \n       OperationStatus[] codes = region.batchMutate(mArray, atomic, HConstants.NO_NONCE,\n         HConstants.NO_NONCE);\n+      if (atomic) {\n+        List<ResultOrException> resultOrExceptions = new ArrayList<>();\n+        List<Result> results = new ArrayList<>();\n+        for (i = 0; i < codes.length; i++) {\n+          if (codes[i].getResult() != null) {\n+            results.add(codes[i].getResult());\n+          }\n+          if (i != 0) {\n+            resultOrExceptions.add(getResultOrException(\n+              ClientProtos.Result.getDefaultInstance(), i));\n+          }\n+        }\n+\n+        if (results.isEmpty()) {\n+          resultOrExceptions.add(0, getResultOrException(", "originalCommit": "2baf627e968559cd48e02581092e422e413ca3fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM1MTUxOQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528351519", "bodyText": "Yes, you are right. I will do that. Thanks.", "author": "brfrn169", "createdAt": "2020-11-22T15:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM0OTA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM0OTIxMA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528349210", "bodyText": "Mind explaining a bit about the logic here?  I think batchMutate is for multiple operations? Why here we could merge the cells from different Results? We can make sure they are always for the same row?", "author": "Apache9", "createdAt": "2020-11-22T15:13:49Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/RSRpcServices.java", "diffHunk": "@@ -972,11 +1001,44 @@ private void doBatchOp(final RegionActionResult.Builder builder, final HRegion r\n \n       OperationStatus[] codes = region.batchMutate(mArray, atomic, HConstants.NO_NONCE,\n         HConstants.NO_NONCE);\n+      if (atomic) {\n+        List<ResultOrException> resultOrExceptions = new ArrayList<>();\n+        List<Result> results = new ArrayList<>();\n+        for (i = 0; i < codes.length; i++) {\n+          if (codes[i].getResult() != null) {\n+            results.add(codes[i].getResult());\n+          }\n+          if (i != 0) {\n+            resultOrExceptions.add(getResultOrException(\n+              ClientProtos.Result.getDefaultInstance(), i));\n+          }\n+        }\n+\n+        if (results.isEmpty()) {\n+          resultOrExceptions.add(0, getResultOrException(\n+            ClientProtos.Result.getDefaultInstance(), 0));\n+        } else {\n+          // Set the result of the Increment/Append operations to the first element of the\n+          // ResultOrException list\n+          List<Cell> cellList = new ArrayList<>();", "originalCommit": "2baf627e968559cd48e02581092e422e413ca3fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM1MTI0NA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r528351244", "bodyText": "batchMutate can also be used by mutateRow(), and the case that atomic is true is when a client calls mutateRow(). In this case, of course, the results are always for the same row, and we need to return the results of Increment/Append operations as one Result object. That's why we need to merge the cell from different Results. And this logic sets the result to the first element of the ResultOrException list. Thanks.", "author": "brfrn169", "createdAt": "2020-11-22T15:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM0OTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA1NzExNA==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r530057114", "bodyText": "Seems my comment is disappeared, maybe I forgot to push the comment button. The concern here is how we can make sure that when arriving this branch, we are going to treat the result for mutateRow. Here we are in doBatchOp method, which will be called in RSRpcService.multi method, and the atomic flag is read from the protobuf message. This means the only place where we set atomic to true is for mutateRow? Maybe this is the case as for atomic batching we need to use the MultiRowMutationEndpoint, just asking. And I suggest that if this is the case then we should add more comments in the code to explicitly say this so other developers will not be confusing.", "author": "Apache9", "createdAt": "2020-11-25T01:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM0OTIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDM0MDM1OQ==", "url": "https://github.com/apache/hbase/pull/2630#discussion_r530340359", "bodyText": "Here we are in doBatchOp method, which will be called in RSRpcService.multi method, and the atomic flag is read from the protobuf message. This means the only place where we set atomic to true is for mutateRow? Maybe this is the case as for atomic batching we need to use the MultiRowMutationEndpoint, just asking.\n\nYes, the only place where we set atomic to true is for mutateRow. In case of MultiRowMutationEndpoint, it calls Region.mutateRowsWithLocks() directly. So it doesn't call the doBatchOp method.\n\nI suggest that if this is the case then we should add more comments in the code to explicitly say this so other developers will not be confusing.\n\nSure I will add some more comments. Thanks.", "author": "brfrn169", "createdAt": "2020-11-25T12:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODM0OTIxMA=="}], "type": "inlineReview"}, {"oid": "c58d7787b1558e1bc49c73762c3f43d484873298", "url": "https://github.com/apache/hbase/commit/c58d7787b1558e1bc49c73762c3f43d484873298", "message": "HBASE-25242 Add Increment/Append support to RowMutations", "committedDate": "2020-11-22T15:35:39Z", "type": "forcePushed"}, {"oid": "66a915d41ed3d2c752d6c93d5692ea48d2dab087", "url": "https://github.com/apache/hbase/commit/66a915d41ed3d2c752d6c93d5692ea48d2dab087", "message": "HBASE-25242 Add Increment/Append support to RowMutations", "committedDate": "2020-11-25T12:38:02Z", "type": "forcePushed"}, {"oid": "b76370a4118f586e73d073ea8dcd21e93368065c", "url": "https://github.com/apache/hbase/commit/b76370a4118f586e73d073ea8dcd21e93368065c", "message": "HBASE-25242 Add Increment/Append support to RowMutations", "committedDate": "2020-11-25T16:41:10Z", "type": "commit"}, {"oid": "b76370a4118f586e73d073ea8dcd21e93368065c", "url": "https://github.com/apache/hbase/commit/b76370a4118f586e73d073ea8dcd21e93368065c", "message": "HBASE-25242 Add Increment/Append support to RowMutations", "committedDate": "2020-11-25T16:41:10Z", "type": "forcePushed"}]}