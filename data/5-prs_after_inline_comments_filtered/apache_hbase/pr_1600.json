{"pr_number": 1600, "pr_title": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API", "pr_createdAt": "2020-04-28T22:20:27Z", "pr_url": "https://github.com/apache/hbase/pull/1600", "timeline": [{"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411", "url": "https://github.com/apache/hbase/commit/64df57cf6647d0edaa3a52a883a74ba6eadbd411", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works.", "committedDate": "2020-04-28T22:34:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2ODkyMw==", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417068923", "bodyText": "Fancy!", "author": "saintstack", "createdAt": "2020-04-29T05:06:16Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/MockHttpApiRule.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.BiConsumer;\n+import java.util.regex.Pattern;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.RequestLog;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.server.Slf4jRequestLog;\n+import org.eclipse.jetty.server.handler.AbstractHandler;\n+import org.eclipse.jetty.util.RegexSet;\n+import org.junit.rules.ExternalResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A {@link org.junit.Rule} that manages a simple http server. The caller registers request\n+ * handlers to URI path regexp.\n+ */\n+public class MockHttpApiRule extends ExternalResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MockHttpApiRule.class);\n+\n+  private MockHandler handler;\n+  private Server server;\n+\n+  /**\n+   * Register a callback handler for the specified path target.\n+   */\n+  public MockHttpApiRule addRegistration(\n+    final String pathRegex,\n+    final BiConsumer<String, HttpServletResponse> responder\n+  ) {\n+    handler.register(pathRegex, responder);\n+    return this;\n+  }\n+\n+  /**\n+   * Shortcut method for calling {@link #addRegistration(String, BiConsumer)} with a 200 response.\n+   */\n+  public MockHttpApiRule registerOk(final String pathRegex, final String responseBody) {\n+    return addRegistration(pathRegex, (target, resp) -> {\n+      try {\n+        resp.setStatus(HttpServletResponse.SC_OK);\n+        resp.setCharacterEncoding(\"UTF-8\");\n+        resp.setContentType(MediaType.APPLICATION_JSON_TYPE.toString());\n+        final PrintWriter writer = resp.getWriter();\n+        writer.write(responseBody);\n+        writer.flush();\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+  }\n+\n+  public void clearRegistrations() {\n+    handler.clearRegistrations();\n+  }\n+\n+  /**\n+   * Retrieve the service URI for this service.\n+   */\n+  public URI getURI() {\n+    if (server == null || !server.isRunning()) {\n+      throw new IllegalStateException(\"server is not running\");\n+    }\n+    return server.getURI();\n+  }\n+\n+  @Override\n+  protected void before() throws Exception {\n+    handler = new MockHandler();\n+    server = new Server();\n+    final ServerConnector http = new ServerConnector(server);\n+    http.setHost(\"localhost\");\n+    server.addConnector(http);\n+    server.setStopAtShutdown(true);\n+    server.setHandler(handler);\n+    server.setRequestLog(buildRequestLog());\n+    server.start();\n+  }\n+\n+  @Override\n+  protected void after() {\n+    try {\n+      server.stop();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static RequestLog buildRequestLog() {\n+    final Slf4jRequestLog requestLog = new Slf4jRequestLog();\n+    requestLog.setLoggerName(LOG.getName() + \".RequestLog\");\n+    requestLog.setExtended(true);\n+    return requestLog;\n+  }\n+\n+  private static class MockHandler extends AbstractHandler {\n+\n+    private final ReadWriteLock responseMappingLock = new ReentrantReadWriteLock();\n+    private final Map<String, BiConsumer<String, HttpServletResponse>> responseMapping =\n+      new HashMap<>();\n+    private final RegexSet regexSet = new RegexSet();\n+\n+    void register(\n+      final String pathRegex,\n+      final BiConsumer<String, HttpServletResponse> responder\n+    ) {\n+      LOG.debug(\"Registering responder to '{}'\", pathRegex);\n+      responseMappingLock.writeLock().lock();\n+      try {\n+        responseMapping.put(pathRegex, responder);\n+        regexSet.add(pathRegex);\n+      } finally {\n+        responseMappingLock.writeLock().unlock();\n+      }\n+    }\n+\n+    void clearRegistrations() {\n+      LOG.debug(\"Clearing registrations\");\n+      responseMappingLock.writeLock().lock();\n+      try {\n+        responseMapping.clear();\n+        regexSet.clear();\n+      } finally {\n+        responseMappingLock.writeLock().unlock();\n+      }\n+    }\n+\n+    @Override\n+    public void handle(\n+      final String target,\n+      final Request baseRequest,\n+      final HttpServletRequest request,\n+      final HttpServletResponse response\n+    ) {\n+      responseMappingLock.readLock().lock();\n+      try {\n+        if (!regexSet.matches(target)) {\n+          response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n+          return;\n+        }\n+        responseMapping.entrySet()\n+          .stream()\n+          .filter(e -> Pattern.matches(e.getKey(), target))\n+          .findAny()\n+          .map(Map.Entry::getValue)\n+          .orElseThrow(() -> noMatchFound(target))\n+          .accept(target, response);\n+      } finally {\n+        responseMappingLock.readLock().unlock();\n+      }\n+    }\n+\n+    private static RuntimeException noMatchFound(final String target) {\n+      return new RuntimeException(\n+        String.format(\"Target path '%s' matches no registered regex.\", target));\n+    }\n+  }\n+}", "originalCommit": "64df57cf6647d0edaa3a52a883a74ba6eadbd411", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NTIwMw==", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417485203", "bodyText": "Maybe this eventually gets moved into wherever else we have http clients that need testing.", "author": "ndimiduk", "createdAt": "2020-04-29T17:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2ODkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI0OQ==", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417069249", "bodyText": "oh. it never worked?", "author": "saintstack", "createdAt": "2020-04-29T05:07:31Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/RESTApiClusterManager.java", "diffHunk": "@@ -334,7 +334,7 @@ public String toString() {\n     roleServiceType.put(ServiceType.HBASE_REGIONSERVER, Service.HBASE);\n   }\n \n-  private enum Service {\n+  enum Service {\n     HBASE, HDFS, MAPREDUCE\n   }\n }", "originalCommit": "64df57cf6647d0edaa3a52a883a74ba6eadbd411", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NjQ3NA==", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417486474", "bodyText": "I suspect it worked before the switch to GSON.", "author": "ndimiduk", "createdAt": "2020-04-29T17:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NjMxNg==", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417486316", "bodyText": "This is the meat of the fix. toJsonTree is for serializing an object to json, not for reading an object from json. It was returning a JsonPrimitive<String> instead of parsing the string content.", "author": "ndimiduk", "createdAt": "2020-04-29T17:26:48Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/RESTApiClusterManager.java", "diffHunk": "@@ -238,16 +236,18 @@ private String getHostId(String hostname) throws IOException {\n \n   // Execute GET against URI, returning a JsonNode object to be traversed.\n   private JsonElement getJsonNodeFromURIGet(URI uri) throws IOException {\n-    LOG.info(\"Executing GET against \" + uri + \"...\");\n-    WebTarget webTarget = client.target(uri);\n-    Invocation.Builder invocationBuilder = webTarget.request(MediaType.APPLICATION_JSON);\n-    Response response = invocationBuilder.get();\n+    LOG.debug(\"Executing GET against \" + uri + \"...\");\n+    final Response response = client.target(uri)\n+      .request(MediaType.APPLICATION_JSON_TYPE)\n+      .get();\n     int statusCode = response.getStatus();\n     if (statusCode != Response.Status.OK.getStatusCode()) {\n       throw new HTTPException(statusCode);\n     }\n     // This API folds information as the value to an \"items\" attribute.\n-    return GSON.toJsonTree(response.readEntity(String.class)).getAsJsonObject().get(\"items\");\n+    return parser.parse(response.readEntity(String.class))", "originalCommit": "64df57cf6647d0edaa3a52a883a74ba6eadbd411", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NzcxMQ==", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417487711", "bodyText": "Building these json strings by hand is awful. Maybe better to populate maps, or define POJOs? None of it is particularly elegant.", "author": "ndimiduk", "createdAt": "2020-04-29T17:29:08Z", "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestRESTApiClusterManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertTrue;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ClusterManager.ServiceType;\n+import org.apache.hadoop.hbase.RESTApiClusterManager.Service;\n+import org.apache.hadoop.hbase.testclassification.SmallTests;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TestName;\n+\n+@Category(SmallTests.class)\n+public class TestRESTApiClusterManager {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestRESTApiClusterManager.class);\n+\n+  @ClassRule\n+  public static MockHttpApiRule mockHttpApi = new MockHttpApiRule();\n+\n+  @Rule\n+  public final TestName testName = new TestName();\n+\n+  private static HBaseCommonTestingUtility testingUtility;\n+  private ClusterManager clusterManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    testingUtility = new HBaseCommonTestingUtility();\n+    configureClusterManager(testingUtility.getConfiguration());\n+  }\n+\n+  @Before\n+  public void before() {\n+    mockHttpApi.clearRegistrations();\n+    final Configuration methodConf = new Configuration(testingUtility.getConfiguration());\n+    methodConf.set(\"hbase.it.clustermanager.restapi.clustername\", testName.getMethodName());\n+    clusterManager = new RESTApiClusterManager();\n+    clusterManager.setConf(methodConf);\n+  }\n+\n+  @Test\n+  public void isRunningPositive() throws IOException {\n+    final String clusterName = testName.getMethodName();\n+    final String hostName = \"somehost\";\n+    final String serviceName = \"hbase\";\n+    final String hostId = \"some-id\";\n+    registerServiceName(clusterName, Service.HBASE, serviceName);\n+    registerHost(hostName, hostId);\n+    final Map<String, String> hostProperties = new HashMap<>();\n+    hostProperties.put(\"roleState\", \"STARTED\");\n+    hostProperties.put(\"healthSummary\", \"GOOD\");\n+    registerHostProperties(\n+      clusterName, serviceName, hostId, ServiceType.HBASE_MASTER, hostProperties);\n+    assertTrue(clusterManager.isRunning(ServiceType.HBASE_MASTER, hostName, -1));\n+  }\n+\n+  private static void configureClusterManager(final Configuration conf) {\n+    conf.set(\"hbase.it.clustermanager.restapi.hostname\", mockHttpApi.getURI().toString());\n+  }\n+\n+  private static void registerServiceName(\n+    final String clusterName,\n+    final Service service,\n+    final String serviceName\n+  ) {\n+    final String target = String.format(\"^/api/v6/clusters/%s/services\", clusterName);\n+    final String response = String.format(\n+      \"{ \\\"items\\\": [ { \\\"type\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\" } ] }\", service, serviceName);", "originalCommit": "64df57cf6647d0edaa3a52a883a74ba6eadbd411", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "53579a3ca66a9b6995b6227925e7e669647ec7b6", "url": "https://github.com/apache/hbase/commit/53579a3ca66a9b6995b6227925e7e669647ec7b6", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works.\n\nSigned-off-by: stack <stack@apache.org>", "committedDate": "2020-04-29T20:02:01Z", "type": "commit"}, {"oid": "53579a3ca66a9b6995b6227925e7e669647ec7b6", "url": "https://github.com/apache/hbase/commit/53579a3ca66a9b6995b6227925e7e669647ec7b6", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works.\n\nSigned-off-by: stack <stack@apache.org>", "committedDate": "2020-04-29T20:02:01Z", "type": "forcePushed"}]}