{"pr_number": 2021, "pr_title": "HBASE-24665 MultiWAL : Avoid rolling of ALL WALs when one of the WAL needs a roll", "pr_createdAt": "2020-07-06T03:50:32Z", "pr_url": "https://github.com/apache/hbase/pull/2021", "timeline": [{"oid": "d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "url": "https://github.com/apache/hbase/commit/d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "message": "HBASE-24665 all wal of RegionGroupingProvider together roll", "committedDate": "2020-07-06T03:47:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4NjQ0OQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r451686449", "bodyText": "The actual fix is this alone right?", "author": "anoopsjohn", "createdAt": "2020-07-08T16:48:58Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -178,14 +177,17 @@ public void run() {\n         for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n           .hasNext();) {\n           Entry<WAL, Boolean> entry = iter.next();\n+          if (!periodic && !entry.getValue()) {", "originalCommit": "d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4ODEyMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r451688123", "bodyText": "Not on this patch directly.\nWe have the periodic WAL roll.. Every WAL should get rolled as per this period.  When one WAL gets rolled, we will change the lastRollTime and so it can happen that some WALs will ever get rolled!\nThis issue will be visible now as we will selectively roll WAL files after this patch.  Actually we need to track the lastRollTime per WAL instance.", "author": "anoopsjohn", "createdAt": "2020-07-08T16:51:34Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,10 +148,9 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n+      boolean periodic = (now - this.lastRollTime) > this.rollPeriod;", "originalCommit": "d2ee29ffdfcbdb761f4f038f066fac34ee2ce6c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjY1ODQzMg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r452658432", "bodyText": "It's like this, I ignored it. Thanks for reminding", "author": "WenFeiYi", "createdAt": "2020-07-10T07:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4ODEyMw=="}], "type": "inlineReview"}, {"oid": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "url": "https://github.com/apache/hbase/commit/07afe84ba265901552e2938bdc27a1ba5af8fcff", "message": "fix period roll", "committedDate": "2020-07-10T11:01:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE5MDk2OQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453190969", "bodyText": "isRollRequested() can be the better name?", "author": "anoopsjohn", "createdAt": "2020-07-11T12:36:02Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +248,35 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    boolean isRequestRoll;\n+    long lastRollTime;\n+\n+    RollController() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    void finishRoll() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public boolean isRequestRoll() {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE5MTIxNw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453191217", "bodyText": "This is exposed for test cases only.  This is a private class.. So its ok to change the return type.  The new RollController gives clear idea whether a wal instance needs roll because of periodic roll or being explicitly asked for. So that is better.\nA return type of Map<WAL, RollController>\nAny way then we dont need synchronized block.  Else, if we have to do as what is being done below in patch, we would need synchronized block", "author": "anoopsjohn", "createdAt": "2020-07-11T12:39:59Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/LogRoller.java", "diffHunk": "@@ -66,6 +67,10 @@ protected void scheduleFlush(String encodedRegionName, List<byte[]> families) {\n \n   @VisibleForTesting\n   Map<WAL, Boolean> getWalNeedsRoll() {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIwNzMwNQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453207305", "bodyText": "We add all WAL instances into this once it is created. We can just call it wals?", "author": "anoopsjohn", "createdAt": "2020-07-11T15:47:01Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,14 +57,13 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> walNeedsRoll = new ConcurrentHashMap<>();", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIwNzgyOA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453207828", "bodyText": "A better name ?  needsPeriodicRoll ?", "author": "anoopsjohn", "createdAt": "2020-07-11T15:53:50Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +248,35 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    boolean isRequestRoll;\n+    long lastRollTime;\n+\n+    RollController() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    void finishRoll() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public boolean isRequestRoll() {\n+      return isRequestRoll;\n+    }\n+\n+    boolean isPeriodRoll(long now) {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMjEzNA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453212134", "bodyText": "This name is bit confusing. This is not called once roll is finished. We can just call this resetStatus()? Give proper comment that this resets rollReq status as well as lastRollTime. We can pass the ts as param 'lastRollTime' so that this is clear.", "author": "anoopsjohn", "createdAt": "2020-07-11T16:41:33Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +248,35 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    boolean isRequestRoll;\n+    long lastRollTime;\n+\n+    RollController() {\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    void finishRoll() {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMjU2Mw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453212563", "bodyText": "We can have a single method in RollController which says this WAL needs roll?     RollController#needsRoll().", "author": "anoopsjohn", "createdAt": "2020-07-11T16:46:16Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -174,18 +170,21 @@ public void run() {\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n+          RollController controller = entry.getValue();\n+          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzQ4OQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453213489", "bodyText": "This log is not much value added now as we dont say for which log(s) need this periodic roll.  We can clearly say WAL roll period {} elapsed for one of the WAL.\nBelow we can make sure we log which wal(s) are getting rolled for what purpose", "author": "anoopsjohn", "createdAt": "2020-07-11T16:56:18Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,16 +146,14 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n+      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n         // Time for periodic roll, fall through\n         LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzUwMg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453213502", "bodyText": "Same as above comment", "author": "anoopsjohn", "createdAt": "2020-07-11T16:56:30Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,16 +146,14 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n+      if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isPeriodRoll(now))) {\n         // Time for periodic roll, fall through\n         LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n       } else {\n         synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(Boolean::booleanValue)) {\n+          if (walNeedsRoll.values().stream().anyMatch(rc -> rc.isRequestRoll)) {\n             // WAL roll requested, fall through\n             LOG.debug(\"WAL roll requested\");", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzY5Nw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453213697", "bodyText": "Ideally we need this call also within a synchronized block. This is an existing issue.", "author": "anoopsjohn", "createdAt": "2020-07-11T16:59:01Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -174,18 +170,21 @@ public void run() {\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = walNeedsRoll.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n+          RollController controller = entry.getValue();\n+          if (!controller.isRequestRoll && !controller.isPeriodRoll(now)) {\n+            continue;\n+          }\n           WAL wal = entry.getKey();\n           // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          walNeedsRoll.put(wal, Boolean.FALSE);\n+          controller.finishRoll();", "originalCommit": "07afe84ba265901552e2938bdc27a1ba5af8fcff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ0OTYzMQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453449631", "bodyText": "Thank you very much for your tips", "author": "WenFeiYi", "createdAt": "2020-07-13T05:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxMzY5Nw=="}], "type": "inlineReview"}, {"oid": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "url": "https://github.com/apache/hbase/commit/8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "message": "fix", "committedDate": "2020-07-13T05:54:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1NjEzMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453456133", "bodyText": "This is overall coming good now.  Much more clean than what we had before. Thanks\nOne issue here though.  We have rollWal() and requestRoll() under same lock now.. That is not good. The requestRoll should not wait for ongoing roll to be finished. The request call is in hot path.", "author": "anoopsjohn", "createdAt": "2020-07-13T06:18:51Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +244,42 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    private final WAL wal;\n+    private boolean isRequestRoll;\n+    private long lastRollTime;\n+\n+    RollController(WAL wal) {\n+      this.wal = wal;\n+      this.isRequestRoll = false;\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public synchronized void requestRoll() {\n+      this.isRequestRoll = true;\n+    }\n+\n+    public synchronized Map<byte[], List<byte[]>> rollWal(long lastRollTime) throws IOException {", "originalCommit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzQ1Njc3MA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r453456770", "bodyText": "Previously, when we are going for a roll because of periodic roll, then also we used to keep the value in Map as TRUE right?  Means here we checked that also.  Because of any reason, the WAL is marked for roll, dont do this check.  So here that is missing now.", "author": "anoopsjohn", "createdAt": "2020-07-13T06:20:44Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -115,9 +113,9 @@ protected AbstractWALRoller(String name, Configuration conf, T abortable) {\n    */\n   private void checkLowReplication(long now) {\n     try {\n-      for (Entry<WAL, Boolean> entry : walNeedsRoll.entrySet()) {\n+      for (Entry<WAL, RollController> entry : wals.entrySet()) {\n         WAL wal = entry.getKey();\n-        boolean needRollAlready = entry.getValue();\n+        boolean needRollAlready = entry.getValue().isRollRequested();", "originalCommit": "8b427b3be54a59b2cf1ac4bf45f494e0d3f7ad65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "15cdba79082d52995c1ad69703007207dbffca41", "url": "https://github.com/apache/hbase/commit/15cdba79082d52995c1ad69703007207dbffca41", "message": "fix RollController and TestLogRoller", "committedDate": "2020-07-14T09:02:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1MTUwNg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r456451506", "bodyText": "Am not sure whether this way of count based thing also correct. Like say 2 times req roll happened before the actual rolling thread picks up this work. Effectively we need to do roll only once right. Even if 2 or more times being asked. But now as per this change it will try do roll again and again.\nSo a boolean based thing is enough\nWhat we can do is make the requestRoll being synchronized and within rollWal have a synchronized block where you can reset it ad then go ahead with actual roll call.\nOr we just need an AtomicBoolean only?", "author": "anoopsjohn", "createdAt": "2020-07-17T13:44:36Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +247,45 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    private final WAL wal;\n+    // avoid missing roll request before we return from rollWriter\n+    private final AtomicInteger rollRequestCounter;\n+    private long lastRollTime;\n+\n+    RollController(WAL wal) {\n+      this.wal = wal;\n+      this.rollRequestCounter = new AtomicInteger(0);\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public void requestRoll() {\n+      this.rollRequestCounter.incrementAndGet();", "originalCommit": "15cdba79082d52995c1ad69703007207dbffca41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3c1a4807a3f938d009e5b1326f30db271d68f9d8", "url": "https://github.com/apache/hbase/commit/3c1a4807a3f938d009e5b1326f30db271d68f9d8", "message": "fix", "committedDate": "2020-07-20T08:15:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457274033", "bodyText": "Hey this is where we need to reset it even before we do actual roll work.. We were doing that.  We had a comment also.\n// reset the flag in front to avoid missing roll request before we return from rollWriter.", "author": "anoopsjohn", "createdAt": "2020-07-20T10:49:42Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -249,4 +247,43 @@ public void close() {\n     running = false;\n     interrupt();\n   }\n+\n+  /**\n+   * Independently control the roll of each wal. When use multiwal,\n+   * can avoid all wal roll together. see HBASE-24665 for detail\n+   */\n+  protected class RollController {\n+    private final WAL wal;\n+    private final AtomicBoolean rollRequest;\n+    private long lastRollTime;\n+\n+    RollController(WAL wal) {\n+      this.wal = wal;\n+      this.rollRequest = new AtomicBoolean(false);\n+      this.lastRollTime = System.currentTimeMillis();\n+    }\n+\n+    public void requestRoll() {\n+      this.rollRequest.set(true);\n+    }\n+\n+    public Map<byte[], List<byte[]>> rollWal(long now) throws IOException {\n+      this.lastRollTime = now;\n+      Map<byte[], List<byte[]>> regionsToFlush = wal.rollWriter(true);\n+      this.rollRequest.set(false);", "originalCommit": "3c1a4807a3f938d009e5b1326f30db271d68f9d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5MTMzMg==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457291332", "bodyText": "thank you very much! I also noticed this, but in order to avoid repeated roll, so fix to that. if use boolean, roll at most once, the impact can be ignored. Thanks for review", "author": "WenFeiYi", "createdAt": "2020-07-20T11:18:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwNjQwOA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457306408", "bodyText": "Sorry did not get.  How AtomicBoolean is different compared to boolean wrt repeated roll possibility.  In the past we used to keep the Boolean state in a Map.  Now in this object.", "author": "anoopsjohn", "createdAt": "2020-07-20T11:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1ODU3NA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457858574", "bodyText": "after reset flag, before roll is complete, if have a roll request, that will also cause an extra roll.", "author": "WenFeiYi", "createdAt": "2020-07-21T06:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyMDg4Ng==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457920886", "bodyText": "Yes. That is happening now also.  We intentionally reset the boolean when we start roll itself.\n// reset the flag in front to avoid missing roll request before we return from rollWriter.\nSo there is no change for that right now.", "author": "anoopsjohn", "createdAt": "2020-07-21T08:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2NTU4NA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457965584", "bodyText": "yes, I go it", "author": "WenFeiYi", "createdAt": "2020-07-21T09:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI3NDAzMw=="}], "type": "inlineReview"}, {"oid": "11e9e134606753f1706c89699a541bbb2a64195d", "url": "https://github.com/apache/hbase/commit/11e9e134606753f1706c89699a541bbb2a64195d", "message": "fix", "committedDate": "2020-07-20T11:10:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4Mzk0Nw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457983947", "bodyText": "Seems this boolean is not needed now. Can u pls delete", "author": "anoopsjohn", "createdAt": "2020-07-21T10:06:05Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,53 +147,52 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(Boolean::booleanValue)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n           WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          walNeedsRoll.put(wal, Boolean.FALSE);\n-          Map<byte[], List<byte[]>> regionsToFlush = null;\n+          RollController controller = entry.getValue();\n+          boolean isRequestRoll;", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4ODA1OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457988058", "bodyText": "Checking its usage, I think this API impl is already buggy.   This just checks the status of the boolean. Once we start a roll on a WAL, we reset the boolean (Even before this patch).  So it is not clearly telling anything abt the roll status. This can return true even while an active wal roll is going on.  We can keep it as an another jira and fix (if required).. Just add some TODO comments here.\nWe might need another boolean in Controller which clearly tracks whether we are ongoing a roll. So this really need to check that status as well as a requested roll status.", "author": "anoopsjohn", "createdAt": "2020-07-21T10:13:32Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -232,7 +230,7 @@ private boolean isWaiting() {\n    * @return true if all WAL roll finished\n    */\n   public boolean walRollFinished() {\n-    return walNeedsRoll.values().stream().allMatch(needRoll -> !needRoll) && isWaiting();", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk4ODg1OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457988858", "bodyText": "Here rather than isRollRequested, we need needsRoll?", "author": "anoopsjohn", "createdAt": "2020-07-21T10:15:00Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -232,7 +230,7 @@ private boolean isWaiting() {\n    * @return true if all WAL roll finished\n    */\n   public boolean walRollFinished() {\n-    return walNeedsRoll.values().stream().allMatch(needRoll -> !needRoll) && isWaiting();\n+    return wals.values().stream().noneMatch(RollController::isRollRequested) && isWaiting();", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MTI1NQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457991255", "bodyText": "We need a 3 sec sleep here? !", "author": "anoopsjohn", "createdAt": "2020-07-21T10:19:18Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java", "diffHunk": "@@ -43,53 +49,104 @@\n   public static final HBaseClassTestRule CLASS_RULE =\n       HBaseClassTestRule.forClass(TestLogRoller.class);\n \n-  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n \n-  private static final int logRollPeriod = 20 * 1000;\n+  private static final int LOG_ROLL_PERIOD = 20 * 1000;\n+  private static final String LOG_DIR = \"WALs\";\n+  private static final String ARCHIVE_DIR = \"archiveWALs\";\n+  private static final String WAL_PREFIX = \"test-log-roller\";\n+  private static Configuration CONF;\n+  private static LogRoller ROLLER;\n+  private static Path ROOT_DIR;\n+  private static FileSystem FS;\n \n   @Before\n   public void setup() throws Exception {\n-    TEST_UTIL.getConfiguration().setInt(\"hbase.regionserver.logroll.period\", logRollPeriod);\n-    TEST_UTIL.startMiniCluster(1);\n-    TableName name = TableName.valueOf(\"Test\");\n-    TEST_UTIL.createTable(name, Bytes.toBytes(\"cf\"));\n-    TEST_UTIL.waitTableAvailable(name);\n+    CONF = TEST_UTIL.getConfiguration();\n+    CONF.setInt(\"hbase.regionserver.logroll.period\", LOG_ROLL_PERIOD);\n+    CONF.setInt(HConstants.THREAD_WAKE_FREQUENCY, 300);\n+    ROOT_DIR = TEST_UTIL.getRandomDir();\n+    FS = FileSystem.get(CONF);\n+    RegionServerServices services = Mockito.mock(RegionServerServices.class);\n+    Mockito.when(services.getConfiguration()).thenReturn(CONF);\n+    ROLLER = new LogRoller(services);\n+    ROLLER.start();\n   }\n \n   @After\n   public void tearDown() throws Exception {\n+    ROLLER.close();\n+    FS.close();\n     TEST_UTIL.shutdownMiniCluster();\n   }\n \n   @Test\n   public void testRemoveClosedWAL() throws Exception {\n-    HRegionServer rs = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0);\n-    Configuration conf = rs.getConfiguration();\n-    LogRoller logRoller = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0).getWalRoller();\n-    int originalSize = logRoller.getWalNeedsRoll().size();\n-    FSHLog wal1 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-        AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal1);\n-    FSHLog wal2 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal2);\n-    FSHLog wal3 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal3);\n-\n-    assertEquals(originalSize + 3, logRoller.getWalNeedsRoll().size());\n-    assertTrue(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal1.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize + 2, logRoller.getWalNeedsRoll().size());\n-    assertFalse(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal2.close();\n-    wal3.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize, logRoller.getWalNeedsRoll().size());\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      ROLLER.addWAL(wal);\n+    }\n+\n+    assertEquals(3, ROLLER.getWalNeedsRoll().size());\n+    Iterator<WAL> it = ROLLER.getWalNeedsRoll().keySet().iterator();\n+    WAL wal = it.next();\n+    assertTrue(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(2, ROLLER.getWalNeedsRoll().size());\n+    assertFalse(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal = it.next();\n+    wal.close();\n+    wal = it.next();\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+  }\n+\n+  /**\n+   * verify that each wal roll separately\n+   */\n+  @Test\n+  public void testRequestRollWithMultiWal() throws Exception {\n+    // add multiple wal\n+    Map<FSHLog, Path> wals = new HashMap<>();\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      wal.init();\n+      wals.put(wal, wal.getCurrentFileName());\n+      ROLLER.addWAL(wal);\n+      Thread.sleep(3000);", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MzQyMw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457993423", "bodyText": "We want 3 WALs will different periodic roll time period?  Why we need? If so, can we limit the time to be 1 sec or lesser?", "author": "anoopsjohn", "createdAt": "2020-07-21T10:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk5MjE0Ng==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r457992146", "bodyText": "Good...", "author": "anoopsjohn", "createdAt": "2020-07-21T10:20:54Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestLogRoller.java", "diffHunk": "@@ -43,53 +49,104 @@\n   public static final HBaseClassTestRule CLASS_RULE =\n       HBaseClassTestRule.forClass(TestLogRoller.class);\n \n-  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n \n-  private static final int logRollPeriod = 20 * 1000;\n+  private static final int LOG_ROLL_PERIOD = 20 * 1000;\n+  private static final String LOG_DIR = \"WALs\";\n+  private static final String ARCHIVE_DIR = \"archiveWALs\";\n+  private static final String WAL_PREFIX = \"test-log-roller\";\n+  private static Configuration CONF;\n+  private static LogRoller ROLLER;\n+  private static Path ROOT_DIR;\n+  private static FileSystem FS;\n \n   @Before\n   public void setup() throws Exception {\n-    TEST_UTIL.getConfiguration().setInt(\"hbase.regionserver.logroll.period\", logRollPeriod);\n-    TEST_UTIL.startMiniCluster(1);\n-    TableName name = TableName.valueOf(\"Test\");\n-    TEST_UTIL.createTable(name, Bytes.toBytes(\"cf\"));\n-    TEST_UTIL.waitTableAvailable(name);\n+    CONF = TEST_UTIL.getConfiguration();\n+    CONF.setInt(\"hbase.regionserver.logroll.period\", LOG_ROLL_PERIOD);\n+    CONF.setInt(HConstants.THREAD_WAKE_FREQUENCY, 300);\n+    ROOT_DIR = TEST_UTIL.getRandomDir();\n+    FS = FileSystem.get(CONF);\n+    RegionServerServices services = Mockito.mock(RegionServerServices.class);\n+    Mockito.when(services.getConfiguration()).thenReturn(CONF);\n+    ROLLER = new LogRoller(services);\n+    ROLLER.start();\n   }\n \n   @After\n   public void tearDown() throws Exception {\n+    ROLLER.close();\n+    FS.close();\n     TEST_UTIL.shutdownMiniCluster();\n   }\n \n   @Test\n   public void testRemoveClosedWAL() throws Exception {\n-    HRegionServer rs = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0);\n-    Configuration conf = rs.getConfiguration();\n-    LogRoller logRoller = TEST_UTIL.getMiniHBaseCluster().getRegionServer(0).getWalRoller();\n-    int originalSize = logRoller.getWalNeedsRoll().size();\n-    FSHLog wal1 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-        AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal1);\n-    FSHLog wal2 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal2);\n-    FSHLog wal3 = new FSHLog(rs.getWALFileSystem(), rs.getWALRootDir(),\n-      AbstractFSWALProvider.getWALDirectoryName(rs.getServerName().getServerName()), conf);\n-    logRoller.addWAL(wal3);\n-\n-    assertEquals(originalSize + 3, logRoller.getWalNeedsRoll().size());\n-    assertTrue(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal1.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize + 2, logRoller.getWalNeedsRoll().size());\n-    assertFalse(logRoller.getWalNeedsRoll().containsKey(wal1));\n-\n-    wal2.close();\n-    wal3.close();\n-    Thread.sleep(2 * logRollPeriod);\n-\n-    assertEquals(originalSize, logRoller.getWalNeedsRoll().size());\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      ROLLER.addWAL(wal);\n+    }\n+\n+    assertEquals(3, ROLLER.getWalNeedsRoll().size());\n+    Iterator<WAL> it = ROLLER.getWalNeedsRoll().keySet().iterator();\n+    WAL wal = it.next();\n+    assertTrue(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(2, ROLLER.getWalNeedsRoll().size());\n+    assertFalse(ROLLER.getWalNeedsRoll().containsKey(wal));\n+\n+    wal = it.next();\n+    wal.close();\n+    wal = it.next();\n+    wal.close();\n+    Thread.sleep(LOG_ROLL_PERIOD + 5000);\n+\n+    assertEquals(0, ROLLER.getWalNeedsRoll().size());\n+  }\n+\n+  /**\n+   * verify that each wal roll separately\n+   */\n+  @Test\n+  public void testRequestRollWithMultiWal() throws Exception {\n+    // add multiple wal\n+    Map<FSHLog, Path> wals = new HashMap<>();\n+    for (int i = 1; i <= 3; i++) {\n+      FSHLog wal = new FSHLog(FS, ROOT_DIR, LOG_DIR, ARCHIVE_DIR, CONF, null,\n+        true, WAL_PREFIX, getWALSuffix(i));\n+      wal.init();\n+      wals.put(wal, wal.getCurrentFileName());\n+      ROLLER.addWAL(wal);\n+      Thread.sleep(3000);\n+    }\n+\n+    // request roll\n+    Iterator<Map.Entry<FSHLog, Path>> it = wals.entrySet().iterator();\n+    Map.Entry<FSHLog, Path> walEntry = it.next();\n+    walEntry.getKey().requestLogRoll();\n+    Thread.sleep(5000);\n+\n+    assertNotEquals(walEntry.getValue(), walEntry.getKey().getCurrentFileName());\n+    walEntry.setValue(walEntry.getKey().getCurrentFileName());\n+    while (it.hasNext()) {\n+      walEntry = it.next();\n+      assertEquals(walEntry.getValue(), walEntry.getKey().getCurrentFileName());", "originalCommit": "11e9e134606753f1706c89699a541bbb2a64195d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "url": "https://github.com/apache/hbase/commit/18bfdf715d063b64b50f3364dee726ffe1d6716a", "message": "fix", "committedDate": "2020-07-21T12:02:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459223780", "bodyText": "walRolls? instead of wals?", "author": "ramkrish86", "createdAt": "2020-07-23T05:37:58Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,31 +58,31 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> wals = new ConcurrentHashMap<>();", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzNTI4NA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459235284", "bodyText": "rollWals? more suitable\uff1f", "author": "WenFeiYi", "createdAt": "2020-07-23T06:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI1NjM5OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459256398", "bodyText": "This will have all wal entries once the wal instance is created.  Not just when it needs a roll. So ya these were wals which needed roll at some point.  So wals name also fine IMO.", "author": "anoopsjohn", "createdAt": "2020-07-23T07:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM3NDgwNw==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459374807", "bodyText": "Ok", "author": "ramkrish86", "createdAt": "2020-07-23T11:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyMzc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNDE4OA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459224188", "bodyText": "Is this talking about what this PR is trying to do?", "author": "ramkrish86", "createdAt": "2020-07-23T05:39:51Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,31 +58,31 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> wals = new ConcurrentHashMap<>();\n   protected final T abortable;\n-  private volatile long lastRollTime = System.currentTimeMillis();\n   // Period to roll log.\n   private final long rollPeriod;\n   private final int threadWakeFrequency;\n   // The interval to check low replication on hlog's pipeline\n-  private long checkLowReplicationInterval;\n+  private final long checkLowReplicationInterval;\n \n   private volatile boolean running = true;\n \n   public void addWAL(WAL wal) {\n     // check without lock first\n-    if (walNeedsRoll.containsKey(wal)) {\n+    if (wals.containsKey(wal)) {\n       return;\n     }\n     // this is to avoid race between addWAL and requestRollAll.\n     synchronized (this) {\n-      if (walNeedsRoll.putIfAbsent(wal, Boolean.FALSE) == null) {\n+      if (wals.putIfAbsent(wal, new RollController(wal)) == null) {\n         wal.registerWALActionsListener(new WALActionsListener() {\n           @Override\n           public void logRollRequested(WALActionsListener.RollRequestReason reason) {\n             // TODO logs will contend with each other here, replace with e.g. DelayedQueue", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzMzUyOA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459233528", "bodyText": "No, the todo is pre-existing.", "author": "WenFeiYi", "createdAt": "2020-07-23T06:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNDE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIzODUzNA==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459238534", "bodyText": "@ramkrish86 the purpose of this PR is to make each wal separate roll when using multiwal. thanks review.", "author": "WenFeiYi", "createdAt": "2020-07-23T06:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNDE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NDU5NQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459384595", "bodyText": "This is they key. We ensure we only roll if one of the condition is met (if either size reach caused a log roll ) or the time elapsed. That is also tracked per wal.", "author": "ramkrish86", "createdAt": "2020-07-23T11:34:28Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -148,53 +147,49 @@ private void abort(String reason, Throwable cause) {\n   @Override\n   public void run() {\n     while (running) {\n-      boolean periodic = false;\n       long now = System.currentTimeMillis();\n       checkLowReplication(now);\n-      periodic = (now - this.lastRollTime) > this.rollPeriod;\n-      if (periodic) {\n-        // Time for periodic roll, fall through\n-        LOG.debug(\"WAL roll period {} ms elapsed\", this.rollPeriod);\n-      } else {\n-        synchronized (this) {\n-          if (walNeedsRoll.values().stream().anyMatch(Boolean::booleanValue)) {\n-            // WAL roll requested, fall through\n-            LOG.debug(\"WAL roll requested\");\n-          } else {\n-            try {\n-              wait(this.threadWakeFrequency);\n-            } catch (InterruptedException e) {\n-              // restore the interrupt state\n-              Thread.currentThread().interrupt();\n-            }\n-            // goto the beginning to check whether again whether we should fall through to roll\n-            // several WALs, and also check whether we should quit.\n-            continue;\n+      synchronized (this) {\n+        if (wals.values().stream().noneMatch(rc -> rc.needsRoll(now))) {\n+          try {\n+            wait(this.threadWakeFrequency);\n+          } catch (InterruptedException e) {\n+            // restore the interrupt state\n+            Thread.currentThread().interrupt();\n           }\n+          // goto the beginning to check whether again whether we should fall through to roll\n+          // several WALs, and also check whether we should quit.\n+          continue;\n         }\n       }\n       try {\n-        this.lastRollTime = System.currentTimeMillis();\n-        for (Iterator<Entry<WAL, Boolean>> iter = walNeedsRoll.entrySet().iterator(); iter\n-          .hasNext();) {\n-          Entry<WAL, Boolean> entry = iter.next();\n+        for (Iterator<Entry<WAL, RollController>> iter = wals.entrySet().iterator();\n+             iter.hasNext();) {\n+          Entry<WAL, RollController> entry = iter.next();\n           WAL wal = entry.getKey();\n-          // reset the flag in front to avoid missing roll request before we return from rollWriter.\n-          walNeedsRoll.put(wal, Boolean.FALSE);\n-          Map<byte[], List<byte[]>> regionsToFlush = null;\n+          RollController controller = entry.getValue();\n+          if (controller.isRollRequested()) {\n+            // WAL roll requested, fall through\n+            LOG.debug(\"WAL {} roll requested\", wal);\n+          } else if (controller.needsPeriodicRoll(now)){\n+            // Time for periodic roll, fall through\n+            LOG.debug(\"WAL {} roll period {} ms elapsed\", wal, this.rollPeriod);\n+          } else {\n+            continue;", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459628419", "bodyText": "We have already done wals.putIfAbsent(wal, new RollController(wal)) above.\nHence, wals.computeIfAbsent() is needed here? Should we not directly get the value with RollController controller = wals.get(wal) and expect non-null object?", "author": "virajjasani", "createdAt": "2020-07-23T17:57:04Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/wal/AbstractWALRoller.java", "diffHunk": "@@ -58,31 +58,31 @@\n \n   protected static final String WAL_ROLL_PERIOD_KEY = \"hbase.regionserver.logroll.period\";\n \n-  protected final ConcurrentMap<WAL, Boolean> walNeedsRoll = new ConcurrentHashMap<>();\n+  protected final ConcurrentMap<WAL, RollController> wals = new ConcurrentHashMap<>();\n   protected final T abortable;\n-  private volatile long lastRollTime = System.currentTimeMillis();\n   // Period to roll log.\n   private final long rollPeriod;\n   private final int threadWakeFrequency;\n   // The interval to check low replication on hlog's pipeline\n-  private long checkLowReplicationInterval;\n+  private final long checkLowReplicationInterval;\n \n   private volatile boolean running = true;\n \n   public void addWAL(WAL wal) {\n     // check without lock first\n-    if (walNeedsRoll.containsKey(wal)) {\n+    if (wals.containsKey(wal)) {\n       return;\n     }\n     // this is to avoid race between addWAL and requestRollAll.\n     synchronized (this) {\n-      if (walNeedsRoll.putIfAbsent(wal, Boolean.FALSE) == null) {\n+      if (wals.putIfAbsent(wal, new RollController(wal)) == null) {\n         wal.registerWALActionsListener(new WALActionsListener() {\n           @Override\n           public void logRollRequested(WALActionsListener.RollRequestReason reason) {\n             // TODO logs will contend with each other here, replace with e.g. DelayedQueue\n             synchronized (AbstractWALRoller.this) {\n-              walNeedsRoll.put(wal, Boolean.TRUE);\n+              RollController controller = wals.computeIfAbsent(wal, rc -> new RollController(wal));", "originalCommit": "18bfdf715d063b64b50f3364dee726ffe1d6716a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1NzgwOQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459857809", "bodyText": "Good Q.  In fact I also thought when reviewed this.  Ideally speaking we should get the addWAL call 1st which will add the instance to the Map. When we get call here the wal should be in the map already.  But if u see the cur impl, there is no such contract enforcing.  It just add the WAL with True value.  So  believe while making patch, @WenFeiYi  went with similar lines.\nWe can consider this.. Need to see any chance we get a rollReq before adding.. While RS start, we do some rollReq on WALs.. This introduced some bug in the past.   We need to see that closely..   If we can confirm that we can add that contract enforcing and so what u suggested.  I would say add a TODO here and raise another issue. This went through multiple cycles of changes. :-)  U ok Viraj?", "author": "anoopsjohn", "createdAt": "2020-07-24T05:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4MjQ1Ng==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459882456", "bodyText": "yes, this is my idea, if there is a change, the impact will be greater, it will be far away from the purpose of the issue.", "author": "WenFeiYi", "createdAt": "2020-07-24T06:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg4NjIzMQ==", "url": "https://github.com/apache/hbase/pull/2021#discussion_r459886231", "bodyText": "Sure, this is critical code anyways, we can live with bit extra atomic calls on Concurrent Map. Sounds good, TODO should make this better :)\nNice work @WenFeiYi .", "author": "virajjasani", "createdAt": "2020-07-24T07:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyODQxOQ=="}], "type": "inlineReview"}]}