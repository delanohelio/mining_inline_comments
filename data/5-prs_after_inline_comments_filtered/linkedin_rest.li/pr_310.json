{"pr_number": 310, "pr_title": "[Relative Load Balancing] D2 relative strategy update health score", "pr_createdAt": "2020-05-27T06:49:06Z", "pr_url": "https://github.com/linkedin/rest.li/pull/310", "timeline": [{"oid": "7be0ad220af21126850d11d8813b3413ddcba1a4", "url": "https://github.com/linkedin/rest.li/commit/7be0ad220af21126850d11d8813b3413ddcba1a4", "message": "[Relative Load Balancing][Not ready for review] Update the health score of tracker clients", "committedDate": "2020-05-27T06:01:22Z", "type": "commit"}, {"oid": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "url": "https://github.com/linkedin/rest.li/commit/861078ce308f85d1cc12a253ee7adb5e8786ff53", "message": "[Relative Load Balancing][Not ready for review] Update doc", "committedDate": "2020-05-27T06:36:34Z", "type": "commit"}, {"oid": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "url": "https://github.com/linkedin/rest.li/commit/05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "message": "Added quarantine implementation", "committedDate": "2020-05-29T07:46:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1ODAxMA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432158010", "bodyText": "prefer\nMIN_HEALTH_SCORE\nMAX_HEALTH_SCORE\nSLOW_START_INITIAL_HEALTH_SCORE (can remove comment)", "author": "zhang-chris", "createdAt": "2020-05-28T22:25:36Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;", "originalCommit": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1ODM5OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432158399", "bodyText": "prefer not using comments unless absolutely necessary. Instead we should improve naming, etc. In this case I think the variable name is clear enough.", "author": "zhang-chris", "createdAt": "2020-05-28T22:26:41Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition", "originalCommit": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDEyMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432160121", "bodyText": "This line should go into the lock so it's only created once.", "author": "zhang-chris", "createdAt": "2020-05-28T22:31:50Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);", "originalCommit": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0NTMzOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r437145339", "bodyText": "Updated the lock logic", "author": "rachelhanhan", "createdAt": "2020-06-09T05:27:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MDEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MTExMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432161112", "bodyText": "We want a blocking lock here instead. And another if !_partitionLoadBalancerStateMap.containsKey(partitionId) check so we don't initialize more than once.", "author": "zhang-chris", "createdAt": "2020-05-28T22:34:33Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())", "originalCommit": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0NTQyMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r437145421", "bodyText": "Fixed", "author": "rachelhanhan", "createdAt": "2020-06-09T05:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2MTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE2NDMwOA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432164308", "bodyText": "Prefer updateState and put request usage in the javadoc.", "author": "zhang-chris", "createdAt": "2020-05-28T22:44:25Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)", "originalCommit": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MTgwOA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432171808", "bodyText": "Add javadoc", "author": "zhang-chris", "createdAt": "2020-05-28T23:07:11Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override", "originalCommit": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3MjM4OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r432172389", "bodyText": "Comment unnecessary", "author": "zhang-chris", "createdAt": "2020-05-28T23:09:01Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final double LOWEST_HEALTH_SCORE = 0.0;\n+  private static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously", "originalCommit": "861078ce308f85d1cc12a253ee7adb5e8786ff53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2Njg5Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433366897", "bodyText": "comment unnecessary", "author": "zhang-chris", "createdAt": "2020-06-01T17:03:50Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition", "originalCommit": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2Nzg1NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433367854", "bodyText": "Should this be setting the TrackerClients in _partitionLoadBalancerStateMap instead of passing them directly?", "author": "zhang-chris", "createdAt": "2020-06-01T17:05:44Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));", "originalCommit": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM2OTcxNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433369714", "bodyText": "I prefer using value directly instead of Optional", "author": "zhang-chris", "createdAt": "2020-06-01T17:09:29Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      updateStateForPartition(_partitionLoadBalancerStateMap.get(partitionId).getTrackerClients(), partitionId, Optional.empty());\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    updateHealthScoreAndState(trackerClients, partitionId, maybeClusterGenerationId);\n+    // Step 2: TODO check if we can enable quarantine, we enable quarantine only if at least one of the clients return success for the checking.\n+    // Step 3: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(_partitionLoadBalancerStateMap.get(partitionId));\n+    // Step 4: TODO Calculate the new ring for each partition\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    if (maybeClusterGenerationId.isPresent())", "originalCommit": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NTA0Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433385043", "bodyText": "I'd rather keep decision making in this class instead of TrackerClientState since this is very similar to what Degrader was doing.", "author": "zhang-chris", "createdAt": "2020-06-01T17:38:17Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      updateStateForPartition(_partitionLoadBalancerStateMap.get(partitionId).getTrackerClients(), partitionId, Optional.empty());\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    updateHealthScoreAndState(trackerClients, partitionId, maybeClusterGenerationId);\n+    // Step 2: TODO check if we can enable quarantine, we enable quarantine only if at least one of the clients return success for the checking.\n+    // Step 3: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(_partitionLoadBalancerStateMap.get(partitionId));\n+    // Step 4: TODO Calculate the new ring for each partition\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          trackerClientStateMap.remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineMap().remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineHistory().remove(trackerClient);\n+          partitionLoadBalancerState.getRecoveryMap().remove(trackerClient);\n+        }\n+      }\n+    }\n+\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionId);\n+\n+    // Update cluster generation id if it's changed\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      _partitionLoadBalancerStateMap.get(partitionId).setClusterGenerationId(maybeClusterGenerationId.get());\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, int partitionId)\n+  {\n+    // Snap stats for each tracker client, we want to get snap the stats because they can change any time during we calculate the new health score\n+    long sumAvgLatency = 0;\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getLatestCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      sumAvgLatency += Math.round(latestCallStats.getCallTimeStats().getAverage());\n+    }\n+    long clusterAvgLatency = sumAvgLatency / trackerClients.size();\n+    partitionLoadBalancerState.setClusterAvgLatency(clusterAvgLatency);\n+\n+    // Update health score\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = latestCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount();\n+        double errorRate = TrackerClientState.getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long latency = Math.round(latestCallStats.getCallTimeStats().getAverage());\n+        // If it is an existing tracker client\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+        if (TrackerClientState.isUnhealthy(trackerClientState, clusterAvgLatency, callCount, latency, errorRate,", "originalCommit": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4Njk0NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433386944", "bodyText": "Calculating cluster avg latency is not this simple. See rfc for formula.", "author": "zhang-chris", "createdAt": "2020-06-01T17:41:48Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  public static final double LOWEST_HEALTH_SCORE = 0.0;\n+  public static final double HEALTHY_HEALTH_SCORE = 1.0;\n+  // If slow start is enabled, it will always start from 0.01\n+  private static final double SLOW_START_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+\n+  // Keeps the state of each partition\n+  private ConcurrentMap<Integer, PartitionLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.schedule(this::updateState, _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateStateByRequest(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      PartitionLoadBalancerState partitionLoadBalancerState =  new PartitionLoadBalancerState(partitionId);\n+      // If it is the very first request for the partition, update the state synchronously\n+      if(partitionLoadBalancerState.getLock().tryLock())\n+      {\n+        try\n+        {\n+          _partitionLoadBalancerStateMap.put(partitionId,partitionLoadBalancerState);\n+          updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId));\n+        }\n+        finally\n+        {\n+          partitionLoadBalancerState.getLock().unlock();\n+        }\n+      }\n+    } else if (_partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId() != clusterGenerationId)\n+    {\n+      // If there are uris change in the cluster, use executor to update the state asynchronously\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, Optional.of(clusterGenerationId)));\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      updateStateForPartition(_partitionLoadBalancerStateMap.get(partitionId).getTrackerClients(), partitionId, Optional.empty());\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    updateHealthScoreAndState(trackerClients, partitionId, maybeClusterGenerationId);\n+    // Step 2: TODO check if we can enable quarantine, we enable quarantine only if at least one of the clients return success for the checking.\n+    // Step 3: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(_partitionLoadBalancerStateMap.get(partitionId));\n+    // Step 4: TODO Calculate the new ring for each partition\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients, int partitionId, Optional<Long> maybeClusterGenerationId)\n+  {\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          trackerClientStateMap.remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineMap().remove(trackerClient);\n+          partitionLoadBalancerState.getQuarantineHistory().remove(trackerClient);\n+          partitionLoadBalancerState.getRecoveryMap().remove(trackerClient);\n+        }\n+      }\n+    }\n+\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionId);\n+\n+    // Update cluster generation id if it's changed\n+    if (maybeClusterGenerationId.isPresent())\n+    {\n+      _partitionLoadBalancerStateMap.get(partitionId).setClusterGenerationId(maybeClusterGenerationId.get());\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, int partitionId)\n+  {\n+    // Snap stats for each tracker client, we want to get snap the stats because they can change any time during we calculate the new health score\n+    long sumAvgLatency = 0;\n+    PartitionLoadBalancerState partitionLoadBalancerState = _partitionLoadBalancerStateMap.get(partitionId);\n+    ConcurrentMap<TrackerClient, TrackerClientState> trackerClientStateMap = partitionLoadBalancerState.getTrackerClientStateMap();\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getLatestCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      sumAvgLatency += Math.round(latestCallStats.getCallTimeStats().getAverage());\n+    }\n+    long clusterAvgLatency = sumAvgLatency / trackerClients.size();", "originalCommit": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0NTQ5NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r437145494", "bodyText": "Fixed", "author": "rachelhanhan", "createdAt": "2020-06-09T05:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4Njk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4ODE2MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433388161", "bodyText": "maybe ServerHealthState instead?", "author": "zhang-chris", "createdAt": "2020-06-01T17:44:01Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientState.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+\n+\n+/**\n+ * Keeps the state of each tracker client for a partition\n+ */\n+public class TrackerClientState {", "originalCommit": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0NTgzNg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r437145836", "bodyText": "Hmm the concept of \"server\" is not explicitly mentioned, if the state is just tracking the state of each TrackerClient, it has a mapping relationship, I think TrackerClientState should be good", "author": "rachelhanhan", "createdAt": "2020-06-09T05:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4ODE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4ODc0NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r433388745", "bodyText": "redundant. also does this class need to know if it's healthy or not? Shouldn't the state updater calculate that and use it? Why temporarily store in this class?", "author": "zhang-chris", "createdAt": "2020-06-01T17:45:09Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientState.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.util.degrader.ErrorType;\n+import java.util.Map;\n+\n+\n+/**\n+ * Keeps the state of each tracker client for a partition\n+ */\n+public class TrackerClientState {\n+  private int _callCount;\n+  // TODO: update adjusted min call count\n+  private int _adjustedMinCallCount;\n+  private double _healthScore;\n+  private boolean _isUnhealthy;\n+  private boolean _isHealthy;", "originalCommit": "05d8e3584d8925d2fd845786a8ad1b8fadc48b91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0NTk1NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r437145955", "bodyText": "I changed to use an enum as you suggested during out meeting", "author": "rachelhanhan", "createdAt": "2020-06-09T05:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4ODc0NQ=="}], "type": "inlineReview"}, {"oid": "1aafeb5c256b073798f2e033b522db0893a7acbb", "url": "https://github.com/linkedin/rest.li/commit/1aafeb5c256b073798f2e033b522db0893a7acbb", "message": "Added quarantine and state updater logic, the code roughly covers the major logics in load balancer in this version", "committedDate": "2020-06-03T05:36:07Z", "type": "commit"}, {"oid": "fe72d543894820a617b9ea59cf8c2dead6f81a45", "url": "https://github.com/linkedin/rest.li/commit/fe72d543894820a617b9ea59cf8c2dead6f81a45", "message": "Added minor changes including: stateListener interface, getRing synchorous execution and some logs", "committedDate": "2020-06-04T23:41:33Z", "type": "commit"}, {"oid": "614689cc01d45d62c61bc792a7b083658ced2769", "url": "https://github.com/linkedin/rest.li/commit/614689cc01d45d62c61bc792a7b083658ced2769", "message": "Change to async update state for cluster change, also changed quarantine latency calculation", "committedDate": "2020-06-09T05:10:08Z", "type": "commit"}, {"oid": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "url": "https://github.com/linkedin/rest.li/commit/9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "message": "Added error regex handling and some other minor changes", "committedDate": "2020-06-10T04:41:55Z", "type": "commit"}, {"oid": "d4138ce76b0c13130c96b4b343a2120ace31a459", "url": "https://github.com/linkedin/rest.li/commit/d4138ce76b0c13130c96b4b343a2120ace31a459", "message": "Added unit test", "committedDate": "2020-06-13T01:37:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk1NjY3MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438956670", "bodyText": "use public static string defined in RelativeLoadBalancerStrategy.", "author": "zhang-chris", "createdAt": "2020-06-11T17:39:02Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/D2ClientBuilder.java", "diffHunk": "@@ -506,6 +507,10 @@ public D2ClientBuilder setD2JmxManagerPrefix(String d2JmxManagerPrefix)\n     loadBalancerStrategyFactories.putIfAbsent(\"degraderV3\", degraderStrategyFactoryV3);\n     loadBalancerStrategyFactories.putIfAbsent(\"degraderV2_1\", degraderStrategyFactoryV3);\n \n+    final RelativeLoadBalancerStrategyFactory relativeLoadBalancerStrategyFactory = new RelativeLoadBalancerStrategyFactory(\n+        _config._executorService, _config.healthCheckOperations, Collections.emptyList(), _config.eventEmitter);\n+    loadBalancerStrategyFactories.putIfAbsent(\"relative\", relativeLoadBalancerStrategyFactory);", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk2NTE4Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438965187", "bodyText": "I'd rather use a Predicate instead of this null pattern.", "author": "zhang-chris", "createdAt": "2020-06-11T17:49:37Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -81,6 +87,23 @@ public TrackerClientImpl(URI uri, Map<Integer, PartitionData> partitionDataMap,\n     _transportClient = transportClient;\n     _callTracker = new CallTrackerImpl(interval, clock);\n     _errorStatusPattern = errorStatusPattern;\n+    _errorStatusRanges = null;", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDExMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438980111", "bodyText": "finish javadoc", "author": "zhang-chris", "createdAt": "2020-06-11T18:12:23Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/ClientSelector.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * The selector that selects a {@link TrackerClient} from the ring to route the request to\n+ */\n+public interface ClientSelector\n+{\n+  /**\n+   * @param request\n+   * @param requestContext\n+   * @param ring\n+   * @param trackerClients\n+   * @return", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MDE1OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438980159", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-06-11T18:12:29Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/ClientSelector.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * The selector that selects a {@link TrackerClient} from the ring to route the request to\n+ */\n+public interface ClientSelector\n+{\n+  /**\n+   * @param request\n+   * @param requestContext\n+   * @param ring\n+   * @param trackerClients\n+   * @return\n+   */\n+  @Nullable\n+  TrackerClient getTrackerClient(Request request, RequestContext requestContext, Ring<URI> ring,\n+      Map<URI, TrackerClient> trackerClients);\n+\n+  HashFunction<Request> getRequestHashFunction();", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjI1MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438982250", "bodyText": "thoughts on renaming to StateUpdateListener?", "author": "zhang-chris", "createdAt": "2020-06-11T18:16:26Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/PartitionLoadBalancerStateListener.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.strategies.relative.PartitionRelativeLoadBalancerState;\n+\n+\n+/**\n+ * The listener that listens to the change of a partition in relative load balancer\n+ */\n+public interface PartitionLoadBalancerStateListener<T>", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ4Mzg1NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440483855", "bodyText": "@ChaoLinkedIn What do you think on this?", "author": "rachelhanhan", "createdAt": "2020-06-15T22:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjYwMA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438982600", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-06-11T18:17:06Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/StateUpdater.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * Update the state of a strategy periodically\n+ */\n+public interface StateUpdater\n+{\n+  /**\n+   * Update the state of the strategy from a new incoming request\n+   * The actual update will only be performed if there is any change in cluster hosts or during initialization.\n+   * Otherwise, the state is updated by the executor service based on fixed intervals, this method will invoke no operation internally\n+   *\n+   * @param trackerClients The potential tracker clients to choose from\n+   * @param partitionId The partition id of the request\n+   * @param clusterGenerationId The id that identifies a unique set of uris in the current cluster\n+   */\n+  void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId);\n+\n+  Ring<URI> getRing(int partitionId);", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjgyMw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438982823", "bodyText": "expand", "author": "zhang-chris", "createdAt": "2020-06-11T18:17:31Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MjY1Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440382657", "bodyText": "Having wildcard in static import is fine in other mps' coding style, especially for voyager-api. Is there a different rule about this in pegasus?", "author": "rachelhanhan", "createdAt": "2020-06-15T18:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4MjgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NDcxMw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438984713", "bodyText": "a", "author": "zhang-chris", "createdAt": "2020-06-11T18:21:05Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = trackerClients.get(targetHostUri);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    if (trackerClient == null)\n+    {\n+      // Pick a one from the tracker clients passed from the request if there is no one selected from the ring\n+      trackerClient = trackerClients.values().stream().findAny().orElse(null);\n+      warn(LOG, \"Did not find a valid client from the ring, picked {} instead\", trackerClient.getUri());", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NTE4Ng==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r438985186", "bodyText": "check if possible", "author": "zhang-chris", "createdAt": "2020-06-11T18:22:05Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = trackerClients.get(targetHostUri);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    if (trackerClient == null)\n+    {\n+      // Pick a one from the tracker clients passed from the request if there is no one selected from the ring\n+      trackerClient = trackerClients.values().stream().findAny().orElse(null);\n+      warn(LOG, \"Did not find a valid client from the ring, picked {} instead\", trackerClient.getUri());\n+    }\n+\n+    addToExcludedHosts(trackerClient, requestContext);\n+\n+    return trackerClient;\n+  }\n+\n+  private void addToExcludedHosts(TrackerClient trackerClient, RequestContext requestContext)\n+  {\n+    if (trackerClient != null)\n+    {\n+      LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, trackerClient.getUri());\n+    }\n+  }\n+\n+  private TrackerClient getTrackerClientFromRing(Request request,\n+                                                 RequestContext requestContext,\n+                                                 Ring<URI> ring,\n+                                                 Map<URI, TrackerClient> trackerClients)\n+  {\n+    if (ring == null)", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MzIzMA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439063230", "bodyText": "thoughts on RelativeLoadBalancerState or PartitionedRelativeLoadBalancerState?", "author": "zhang-chris", "createdAt": "2020-06-11T20:49:48Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionRelativeLoadBalancerState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each partitionLoadBalancerState corresponds to a partition for a particular service\n+ * It keeps the tracker clients and the ring for the partition\n+ */\n+public class PartitionRelativeLoadBalancerState", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3ODg5MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440378891", "bodyText": "The name with partition will indicate this is the state for one partition, not for the entire RelativeLoadBalancer", "author": "rachelhanhan", "createdAt": "2020-06-15T18:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MzIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ4NjQ4MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440486481", "bodyText": "Will re-name it to PartitionState.", "author": "rachelhanhan", "createdAt": "2020-06-15T22:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2MzIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2Mzc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439063785", "bodyText": "a", "author": "zhang-chris", "createdAt": "2020-06-11T20:51:00Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionRelativeLoadBalancerState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each partitionLoadBalancerState corresponds to a partition for a particular service\n+ * It keeps the tracker clients and the ring for the partition\n+ */\n+public class PartitionRelativeLoadBalancerState\n+{\n+  private final int _partitionId;\n+  private final Lock _lock;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionRelativeLoadBalancerState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NDE4Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439064182", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-06-11T20:51:42Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionRelativeLoadBalancerState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each partitionLoadBalancerState corresponds to a partition for a particular service\n+ * It keeps the tracker clients and the ring for the partition\n+ */\n+public class PartitionRelativeLoadBalancerState\n+{\n+  private final int _partitionId;\n+  private final Lock _lock;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionRelativeLoadBalancerState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Lock lock, List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _lock = lock;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  private PartitionRelativeLoadBalancerState(int partitionId, Lock lock, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Set<TrackerClient> recoveryTrackerClients, long clusterGenerationId,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory,\n+      Map<TrackerClient, TrackerClientState> trackerClientStateMap,\n+      List<PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _lock = lock;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+    _recoveryTrackerClients = recoveryTrackerClients;\n+    _clusterGenerationId = clusterGenerationId;\n+    _quarantineMap = quarantineMap;\n+    _quarantineHistory = quarantineHistory;\n+    _trackerClientStateMap = trackerClientStateMap;\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  public PartitionRelativeLoadBalancerState copy()\n+  {\n+    return new PartitionRelativeLoadBalancerState(this.getPartitionId(),\n+        this.getLock(),\n+        this.getRingFactory(),\n+        this.getPointsPerWeight(),\n+        new HashSet<>(this.getRecoveryTrackerClients()),\n+        this.getClusterGenerationId(),\n+        new HashMap<>(this.getQuarantineMap()),\n+        new HashMap<>(this.getQuarantineHistory()),\n+        new HashMap<>(this.getTrackerClientStateMap()),\n+        this.getListeners());\n+  }\n+\n+  public Lock getLock()\n+  {\n+    return _lock;\n+  }\n+\n+  public int getPartitionId()\n+  {\n+    return _partitionId;\n+  }\n+\n+  public long getClusterGenerationId() {\n+    return _clusterGenerationId;\n+  }\n+\n+  public Map<TrackerClient, TrackerClientState> getTrackerClientStateMap()\n+  {\n+    return _trackerClientStateMap;\n+  }\n+\n+  public Set<TrackerClient> getTrackerClients()\n+  {\n+    return _trackerClientStateMap.keySet();\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineMap()\n+  {\n+    return _quarantineMap;\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineHistory()\n+  {\n+    return _quarantineHistory;\n+  }\n+\n+  public Set<TrackerClient> getRecoveryTrackerClients()\n+  {\n+    return _recoveryTrackerClients;\n+  }\n+\n+  public RingFactory<URI> getRingFactory()\n+  {\n+    return _ringFactory;\n+  }\n+\n+  public Ring<URI> getRing() {\n+    return _ring;\n+  }\n+\n+  public void setClusterGenerationId(long clusterGenerationId)\n+  {\n+    _clusterGenerationId = clusterGenerationId;\n+  }\n+\n+  public Map<URI, Integer> getPointsMap()\n+  {\n+    return _pointsMap;\n+  }\n+\n+  public void resetRing()", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTIwOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439065209", "bodyText": "MIN_SERVER_WEIGHT?", "author": "zhang-chris", "createdAt": "2020-06-11T20:53:59Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MjAzNg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439082036", "bodyText": "extract out", "author": "zhang-chris", "createdAt": "2020-06-11T21:33:05Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MjA5NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439082095", "bodyText": "javadoc and make more concise -> \"Limit the number of hosts to enable quarantine and prevent too many connections to be made at once when the downstream cluster is large.\"", "author": "zhang-chris", "createdAt": "2020-06-11T21:33:13Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MzI1OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439083259", "bodyText": "is this the right place to do this?", "author": "zhang-chris", "createdAt": "2020-06-11T21:36:06Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3NTYyMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440375622", "bodyText": "I think so, what would be a better place in your mind?", "author": "rachelhanhan", "createdAt": "2020-06-15T18:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MzI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5Mjg2OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440492869", "bodyText": "As we discussed offline, will put the healthCheckMap to the partitionState", "author": "rachelhanhan", "createdAt": "2020-06-15T23:01:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4Mzg1OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439083858", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-06-11T21:37:28Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MzkzNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439083934", "bodyText": "remove comments and below", "author": "zhang-chris", "createdAt": "2020-06-11T21:37:39Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NDE5Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439084193", "bodyText": "necessary?", "author": "zhang-chris", "createdAt": "2020-06-11T21:38:18Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODI2Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r441168263", "bodyText": "As discussed in the offline, we will compare the full list of quarantine map to see if we need to log after each iteration.", "author": "rachelhanhan", "createdAt": "2020-06-16T22:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NDE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NTQxNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439085417", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-06-11T21:41:33Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NTYzMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439085631", "bodyText": "else if new line", "author": "zhang-chris", "createdAt": "2020-06-11T21:42:07Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4NzgwNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439087804", "bodyText": "move to method level", "author": "zhang-chris", "createdAt": "2020-06-11T21:47:28Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    } else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double clientWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get()) {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient)) {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT\n+          && trackerClientState.isUnhealthy()) {\n+        /**\n+         * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+         * 1. its health score is less than or equal to the threshold (0.0).\n+         * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+         * 3. its clientWeight is greater than 0\n+         *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+         *    In this particular case, we should not put the tracker client into the quarantine).\n+         * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+         */", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4ODg3Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439088877", "bodyText": "a", "author": "zhang-chris", "createdAt": "2020-06-11T21:48:55Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    } else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double clientWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get()) {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient)) {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT\n+          && trackerClientState.isUnhealthy()) {\n+        /**\n+         * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+         * 1. its health score is less than or equal to the threshold (0.0).\n+         * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+         * 3. its clientWeight is greater than 0\n+         *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+         *    In this particular case, we should not put the tracker client into the quarantine).\n+         * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+         */\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null) {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        } else {\n+          LOG.error(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5NjY3MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440496671", "bodyText": "Will change this to warn level", "author": "rachelhanhan", "createdAt": "2020-06-15T23:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4ODg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4OTU3MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439089570", "bodyText": "check necessary?", "author": "zhang-chris", "createdAt": "2020-06-11T21:49:55Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  private static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_CLIENT_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final double _initialHealthScore;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+  private ConcurrentMap<TrackerClient, HealthCheck> _healthCheckMap;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      double initialHealthScore, ScheduledExecutorService executorService, Clock clock, long updateIntervalMs,\n+      double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _initialHealthScore = initialHealthScore;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+    _healthCheckMap = new ConcurrentHashMap<>();\n+  }\n+\n+  public void updateQuarantineState(PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionRelativeLoadBalancerState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionRelativeLoadBalancerState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionRelativeLoadBalancerState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionRelativeLoadBalancerState, oldPartitionRelativeLoadBalancerState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      Set<TrackerClient> trackerClients = partitionRelativeLoadBalancerState.getTrackerClients();\n+      _executorService.submit(() -> preCheckQuarantineState(trackerClients, quarantineLatency));\n+\n+    }\n+  }\n+\n+  private boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  private void preCheckQuarantineState(Set<TrackerClient> trackerClients, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new Callback<None>()\n+    {\n+      @Override\n+      public void onError(Throwable e)\n+      {\n+        if (!_quarantineEnabled.get())\n+        {\n+          _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+        }\n+      }\n+\n+      @Override\n+      public void onSuccess(None result)\n+      {\n+        if (tryEnableQuarantine())\n+        {\n+          LOG.info(\"Quarantine is enabled for service {}\", _serviceName);\n+        }\n+      }\n+    };\n+\n+    // Ideally we would like to healthchecking all the service hosts (ie all TrackerClients) because\n+    // this can help to warm up the R2 connections to the service hosts, thus speed up the initial access\n+    // speed when d2client starts to access those hosts. However this can expose/expedite the problem that\n+    // the d2client host needs too many connections or file handles to all the hosts, when the downstream\n+    // services have large amount of hosts. Before that problem is addressed, we limit the number of hosts\n+    // for pre-healthchecking to a small number\n+    trackerClients.stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = _healthCheckMap.get(client);\n+            if (healthCheckClient == null)\n+            {\n+              // create a new client if not exits\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              _healthCheckMap.put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+\n+    // also remove the entries that the corresponding trackerClientUpdaters do not exist anymore\n+    for (TrackerClient client : _healthCheckMap.keySet())\n+    {\n+      if (!trackerClients.contains(client))\n+      {\n+        _healthCheckMap.remove(client);\n+      }\n+    }\n+  }\n+\n+  private void checkAndRemoveQuarantine(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      // Check/update quarantine state if current client is already under quarantine\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(quarantine);\n+        quarantineHistory.put(trackerClient, quarantine);\n+        LOG.info(\"TrackerClient {} evicted from quarantine\", trackerClient.getUri());\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void handleClientsRecovery(PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState)\n+  {\n+    for (TrackerClient trackerClient : partitionRelativeLoadBalancerState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient),\n+            partitionRelativeLoadBalancerState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionRelativeLoadBalancerState newPartitionRelativeLoadBalancerState,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState, long clusterAvgLatency) {\n+    int partitionId = newPartitionRelativeLoadBalancerState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionRelativeLoadBalancerState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionRelativeLoadBalancerState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionRelativeLoadBalancerState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionRelativeLoadBalancerState.getTrackerClients()) {\n+      TrackerClientState trackerClientState = newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double clientWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, clientWeight, quarantineMap,\n+          quarantineHistory, newPartitionRelativeLoadBalancerState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, clientWeight, recoverySet,\n+          oldPartitionRelativeLoadBalancerState);\n+    }\n+  }\n+\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      } else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    } else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double clientWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get()) {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient)) {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT\n+          && trackerClientState.isUnhealthy()) {\n+        /**\n+         * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+         * 1. its health score is less than or equal to the threshold (0.0).\n+         * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+         * 3. its clientWeight is greater than 0\n+         *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+         *    In this particular case, we should not put the tracker client into the quarantine).\n+         * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+         */\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null) {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        } else {\n+          LOG.error(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void enrollClientInRecoverySet(boolean isQuarantined, TrackerClient trackerClient,\n+      TrackerClientState trackerClientState, double clientWeight, Set<TrackerClient> recoverySet,\n+      PartitionRelativeLoadBalancerState oldPartitionRelativeLoadBalancerState)\n+  {\n+    if (!isQuarantined\n+        && trackerClientState.getHealthScore() == RelativeStateUpdater.MIN_HEALTH_SCORE\n+        && clientWeight > MIN_ZOOKEEPER_CLIENT_WEIGHT)", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjU5NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440372595", "bodyText": "Let's discuss about this. This line is based on the previous implementation: https://jarvis.corp.linkedin.com/codesearch/result/?name=DegraderLoadBalancerStrategyV3.java&path=rest.li%2Fd2%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fd2%2Fbalancer%2Fstrategies%2Fdegrader&reponame=linkedin%2Frest.li#742", "author": "rachelhanhan", "createdAt": "2020-06-15T18:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4OTU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5MDU4OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439090588", "bodyText": "-1 instead of 0", "author": "zhang-chris", "createdAt": "2020-06-11T21:51:13Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerMonitorEventEmitter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.event.D2MonitorEventEmitter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.util.clock.Clock;\n+\n+\n+/**\n+ * Adapter for emitting D2 events from {@link RelativeStateUpdater}.\n+ */\n+public class RelativeLoadBalancerMonitorEventEmitter implements PartitionLoadBalancerStateListener<PartitionRelativeLoadBalancerState>\n+{\n+  private final D2MonitorEventEmitter _d2MonitorEventEmitter;\n+\n+  public RelativeLoadBalancerMonitorEventEmitter(D2MonitorEventEmitter d2MonitorEventEmitter)\n+  {\n+    _d2MonitorEventEmitter = d2MonitorEventEmitter;\n+  }\n+\n+  public void onUpdate(PartitionRelativeLoadBalancerState state)\n+  {\n+    // Please note that cluster level drop is deprecated in the relative load balancer, so there is no cluster level dropped calls and drop level", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5MDg5MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r439090890", "bodyText": "remove", "author": "zhang-chris", "createdAt": "2020-06-11T21:51:41Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategy.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * This strategy balances traffic to hosts within a service by dynamically adjusting a server's\n+ * health score based on call statistics compared relatively to the performance of the entire cluster.\n+ *\n+ * Health score is rated on a scale from 0.0 - 1.0, with 0.0 meaning most unhealthy (all traffic\n+ * routed away) and 1.0 meaning most healthy (no traffic routed away). Note that this behavior is\n+ * inverse of dropRate in the degrader strategy.\n+ *\n+ * @see com.linkedin.d2.D2RelativeStrategyProperties\n+ */\n+public class RelativeLoadBalancerStrategy implements LoadBalancerStrategy\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeLoadBalancerStrategy.class);\n+  public static final String RELATIVE_LOAD_BALANCER_STRATEGY_NAME = \"relative\";\n+\n+  /// We should probably directly use the interface name instead of the Impl name, because we should only access the public methods", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDUwMw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440340503", "bodyText": "maybe too tight. 1.4/1.3?", "author": "zhang-chris", "createdAt": "2020-06-15T17:41:21Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategyFactory.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.D2RingProperties;\n+import com.linkedin.d2.HashConfig;\n+import com.linkedin.d2.HashMethod;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.HttpStatusCodeRange;\n+import com.linkedin.d2.HttpStatusCodeRangeArray;\n+import com.linkedin.d2.balancer.config.RelativeStrategyPropertiesConverter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.event.NoopEventEmitter;\n+import com.linkedin.d2.balancer.properties.ServiceProperties;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategyFactory;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.URIRegexHash;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.util.clock.Clock;\n+import com.linkedin.util.clock.SystemClock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+\n+/**\n+ * Load balancer factory for {@link RelativeLoadBalancerStrategy}.\n+ */\n+public class RelativeLoadBalancerStrategyFactory implements LoadBalancerStrategyFactory<RelativeLoadBalancerStrategy>\n+{\n+  // Default load balancer property values\n+  public static final long DEFAULT_UPDATE_INTERVAL_MS = 5000L;\n+  private static final double DEFAULT_UP_STEP = 0.05;\n+  private static final double DEFAULT_DOWN_STEP = 0.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_HIGH_THRESHOLD_FACTOR = 1.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR = 1.1;", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MzkxNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r441193917", "bodyText": "We will decide the value after we perform more tests/simulations", "author": "rachelhanhan", "createdAt": "2020-06-16T23:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDk0MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440340941", "bodyText": "why 0", "author": "zhang-chris", "createdAt": "2020-06-15T17:42:12Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategyFactory.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.D2RingProperties;\n+import com.linkedin.d2.HashConfig;\n+import com.linkedin.d2.HashMethod;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.HttpStatusCodeRange;\n+import com.linkedin.d2.HttpStatusCodeRangeArray;\n+import com.linkedin.d2.balancer.config.RelativeStrategyPropertiesConverter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.event.NoopEventEmitter;\n+import com.linkedin.d2.balancer.properties.ServiceProperties;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategyFactory;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.URIRegexHash;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.util.clock.Clock;\n+import com.linkedin.util.clock.SystemClock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+\n+/**\n+ * Load balancer factory for {@link RelativeLoadBalancerStrategy}.\n+ */\n+public class RelativeLoadBalancerStrategyFactory implements LoadBalancerStrategyFactory<RelativeLoadBalancerStrategy>\n+{\n+  // Default load balancer property values\n+  public static final long DEFAULT_UPDATE_INTERVAL_MS = 5000L;\n+  private static final double DEFAULT_UP_STEP = 0.05;\n+  private static final double DEFAULT_DOWN_STEP = 0.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_HIGH_THRESHOLD_FACTOR = 1.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR = 1.1;\n+  private static final double DEFAULT_HIGH_ERROR_RATE = 1.1;\n+  private static final double DEFAULT_LOW_ERROR_RATE = 1.1;\n+  private static final int DEFAULT_MIN_CALL_COUNT = 1;\n+  private static final double DEFAULT_INITIAL_HEALTH_SCORE = 1.0;\n+  private static final double DEFAULT_SLOW_START_THRESHOLD = 0.0;\n+  private static final HttpStatusCodeRangeArray DEFAULT_ERROR_STATUS_FILTER =\n+      new HttpStatusCodeRangeArray(new HttpStatusCodeRange().setLowerBound(500).setUpperBound(599));\n+  private static final long DEFAULT_EMITTING_INTERVAL_MS = 0L;", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDQ4OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440370489", "bodyText": "Because it was 0 in the old config too: https://jarvis.corp.linkedin.com/codesearch/result/?name=DegraderLoadBalancerStrategyConfig.java&path=rest.li%2Fd2%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fd2%2Fbalancer%2Fstrategies%2Fdegrader&reponame=linkedin%2Frest.li#136\nIt means by default we do not emit monitor event", "author": "rachelhanhan", "createdAt": "2020-06-15T18:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTMzOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440341339", "bodyText": "same thing defined in Relative...Strategy", "author": "zhang-chris", "createdAt": "2020-06-15T17:42:59Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -62,6 +65,8 @@\n {\n   public static final String DEFAULT_ERROR_STATUS_REGEX = \"(5..)\";\n   public static final Pattern DEFAULT_ERROR_STATUS_PATTERN = Pattern.compile(DEFAULT_ERROR_STATUS_REGEX);\n+  public static final List<HttpStatusCodeRange> DEFAULT_ERROR_STATUS_RANGES = Arrays.asList(new HttpStatusCodeRange()", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2ODQxOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440368419", "bodyText": "Which line in RelativeLoadBalancerStrategy?", "author": "rachelhanhan", "createdAt": "2020-06-15T18:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NTQwMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440345401", "bodyText": "consider adding this to API so you don't need to cast to call this.", "author": "zhang-chris", "createdAt": "2020-06-15T17:50:25Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2Njc0Ng==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440366746", "bodyText": "This is only used by tests, the actual implementation only needs to access the ring. That's why I didn't put it to the interface", "author": "rachelhanhan", "createdAt": "2020-06-15T18:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NTQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Njk4MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440346980", "bodyText": "concurrency concern", "author": "zhang-chris", "createdAt": "2020-06-15T17:53:23Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionRelativeLoadBalancerState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null) {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionRelativeLoadBalancerState oldPartitionState, Long clusterGenerationId)\n+  {\n+    debug(LOG, \"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionRelativeLoadBalancerState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      emitMonitorEvents(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionRelativeLoadBalancerState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          partitionRelativeLoadBalancerState.removeTrackerClient(trackerClient);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avglatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          } else {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        } else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      } else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionRelativeLoadBalancerState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * (callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * (outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void emitMonitorEvents(PartitionRelativeLoadBalancerState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)\n+  {\n+    Integer connectExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CONNECT_EXCEPTION, 0);\n+    Integer closedChannelExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CLOSED_CHANNEL_EXCEPTION, 0);\n+    Integer serverErrorCount = errorTypeCounts.getOrDefault(ErrorType.SERVER_ERROR, 0);\n+    Integer timeoutExceptionCount = errorTypeCounts.getOrDefault(ErrorType.TIMEOUT_EXCEPTION, 0);\n+    return callCount == 0\n+        ? 0\n+        : (double) (connectExceptionCount + closedChannelExceptionCount + serverErrorCount + timeoutExceptionCount) / callCount;\n+  }\n+\n+  private void initializePartition(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    Lock lock = new ReentrantLock();", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MzM1OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r441193359", "bodyText": "I changed to use only one week in the StateUpdater, this will be safe, but may slow down the requests a little bit if multiple requests are sent to different partitions during initialization.", "author": "rachelhanhan", "createdAt": "2020-06-16T23:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Njk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0Nzc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440347785", "bodyText": "should we tryLock here?", "author": "zhang-chris", "createdAt": "2020-06-15T17:54:50Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionRelativeLoadBalancerState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null) {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionRelativeLoadBalancerState oldPartitionState, Long clusterGenerationId)\n+  {\n+    debug(LOG, \"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0OTY3NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r440349674", "bodyText": "rename to generic", "author": "zhang-chris", "createdAt": "2020-06-15T17:58:05Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionLoadBalancerStateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.d2.discovery.util.LogUtil.*;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionRelativeLoadBalancerState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionLoadBalancerStateListener.Factory<PartitionRelativeLoadBalancerState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    } else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionRelativeLoadBalancerState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  private void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionRelativeLoadBalancerState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null) {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  private void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionRelativeLoadBalancerState oldPartitionState, Long clusterGenerationId)\n+  {\n+    debug(LOG, \"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionRelativeLoadBalancerState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      emitMonitorEvents(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionRelativeLoadBalancerState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      for (TrackerClient trackerClient : trackerClientStateMap.keySet())\n+      {\n+        if (!trackerClients.contains(trackerClient))\n+        {\n+          partitionRelativeLoadBalancerState.removeTrackerClient(trackerClient);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionRelativeLoadBalancerState partitionRelativeLoadBalancerState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionRelativeLoadBalancerState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avglatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avglatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          } else {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        } else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      } else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionRelativeLoadBalancerState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * (callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * (outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void emitMonitorEvents(PartitionRelativeLoadBalancerState state)", "originalCommit": "9f1c0971e60d3ee1cedf299c6783d58cf63b47ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "url": "https://github.com/linkedin/rest.li/commit/17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "message": "Addressed review comments", "committedDate": "2020-06-16T23:13:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNDg5OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442424899", "bodyText": "minor - can move out getErrorStatusRanges() call", "author": "zhang-chris", "createdAt": "2020-06-18T18:34:40Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientFactory.java", "diffHunk": "@@ -176,18 +175,38 @@ private static Pattern getErrorStatusPattern(String loadBalancerStrategyName, Se\n     return errorPattern;\n   }\n \n+  private static List<HttpStatusCodeRange> getErrorStatusRanges(ServiceProperties serviceProperties)\n+  {\n+    if (serviceProperties.getRelativeStrategyProperties() == null\n+        || serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter() == null)\n+    {\n+      return RelativeLoadBalancerStrategyFactory.DEFAULT_ERROR_STATUS_FILTER;\n+    }\n+    return serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter();\n+  }\n+\n   private static TrackerClientImpl createTrackerClientImpl(URI uri,\n                                                            UriProperties uriProperties,\n                                                            ServiceProperties serviceProperties,\n                                                            String loadBalancerStrategyName,\n                                                            TransportClient transportClient,\n                                                            Clock clock)\n   {\n+    TrackerClientImpl.ErrorStatusMatch errorStatusRangeMatch = (status) -> {\n+      for(HttpStatusCodeRange statusCodeRange : getErrorStatusRanges(serviceProperties))", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzMDgzOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442430839", "bodyText": "javadoc\nErrorStatusMatcher?", "author": "zhang-chris", "createdAt": "2020-06-18T18:45:48Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -280,21 +290,21 @@ private boolean isServerError(Throwable throwable)\n       RestException restException = (RestException) throwable;\n       if (restException.getResponse() != null)\n       {\n-        return matchErrorStatus(restException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(restException.getResponse().getStatus());\n       }\n     }\n     else if (throwable instanceof StreamException)\n     {\n       StreamException streamException = (StreamException) throwable;\n       if (streamException.getResponse() != null)\n       {\n-        return matchErrorStatus(streamException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(streamException.getResponse().getStatus());\n       }\n     }\n     return false;\n   }\n \n-  private boolean matchErrorStatus(int status) {\n-    return _errorStatusPattern.matcher(Integer.toString(status)).matches();\n+  public interface ErrorStatusMatch {", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzNTQ1Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442435457", "bodyText": "I think we should still add to excluded hosts at the very end here. let's discuss", "author": "zhang-chris", "createdAt": "2020-06-18T18:54:21Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNTQ5Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443915497", "bodyText": "Discussed offline, will apply the logic to all the cases.", "author": "rachelhanhan", "createdAt": "2020-06-23T01:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzNTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzODcwNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442438704", "bodyText": "discuss here too", "author": "zhang-chris", "createdAt": "2020-06-18T19:00:01Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    return trackerClient;\n+  }\n+\n+  private void addToExcludedHosts(TrackerClient trackerClient, RequestContext requestContext)\n+  {\n+    if (trackerClient != null)\n+    {\n+      LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, trackerClient.getUri());\n+    }\n+  }\n+\n+  private TrackerClient getTrackerClientFromTarget(URI targetHostUri, RequestContext requestContext, Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient = trackerClients.get(targetHostUri);\n+\n+    if (trackerClient == null)\n+    {\n+      LOG.warn(\"No client found for \", targetHostUri, \". Target host specified is no longer part of cluster\");\n+    }\n+    else\n+    {\n+      // if this flag is set to be true, that means affinity routing is preferred but backup requests are still acceptable\n+      Boolean otherHostAcceptable = KeyMapper.TargetHostHints.getRequestContextOtherHostAcceptable(requestContext);", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk1ODMyOA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442958328", "bodyText": "Yes let's discuss about this, I saw this in the V3 implementation, so copied the exact same logic over.", "author": "rachelhanhan", "createdAt": "2020-06-19T17:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzODcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzOTI1OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442439258", "bodyText": "RelativeEventEmitter?", "author": "zhang-chris", "createdAt": "2020-06-18T19:00:57Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/MonitorEventEmitter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.event.D2MonitorEventEmitter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.util.clock.Clock;\n+\n+\n+/**\n+ * Adapter for emitting D2 events from {@link RelativeStateUpdater}.\n+ */\n+public class MonitorEventEmitter implements PartitionStateUpdateListener<PartitionState>", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk2MDEyNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442960127", "bodyText": "I didn't put Relative because it is under /relative package, do you think it's not clear?", "author": "rachelhanhan", "createdAt": "2020-06-19T17:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzOTI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNTYwNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443915604", "bodyText": "Will change to RelativeMonitorEventEmitter", "author": "rachelhanhan", "createdAt": "2020-06-23T01:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQzOTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MDk4MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442440980", "bodyText": "call other constructor", "author": "zhang-chris", "createdAt": "2020-06-18T19:04:23Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each {@link PartitionState} corresponds to a partition for a particular service in the relative load balancer\n+ * It keeps the tracker clients and the ring of the partition\n+ */\n+public class PartitionState\n+{\n+  private final int _partitionId;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionStateUpdateListener<PartitionState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<TrackerClient, HealthCheck> _healthCheckMap;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _healthCheckMap = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MTU0OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442441549", "bodyText": "is this used?", "author": "zhang-chris", "createdAt": "2020-06-18T19:05:29Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each {@link PartitionState} corresponds to a partition for a particular service in the relative load balancer\n+ * It keeps the tracker clients and the ring of the partition\n+ */\n+public class PartitionState\n+{\n+  private final int _partitionId;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionStateUpdateListener<PartitionState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<TrackerClient, HealthCheck> _healthCheckMap;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _healthCheckMap = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Set<TrackerClient> recoveryTrackerClients, long clusterGenerationId,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory,\n+      Map<TrackerClient, HealthCheck> healthCheckMap,\n+      Map<TrackerClient, TrackerClientState> trackerClientStateMap,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+    _recoveryTrackerClients = recoveryTrackerClients;\n+    _clusterGenerationId = clusterGenerationId;\n+    _quarantineMap = quarantineMap;\n+    _quarantineHistory = quarantineHistory;\n+    _healthCheckMap = healthCheckMap;\n+    _trackerClientStateMap = trackerClientStateMap;\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  public PartitionState copy()\n+  {\n+    return new PartitionState(this.getPartitionId(),\n+        this.getRingFactory(),\n+        this.getPointsPerWeight(),\n+        new HashSet<>(this.getRecoveryTrackerClients()),\n+        this.getClusterGenerationId(),\n+        new HashMap<>(this.getQuarantineMap()),\n+        new HashMap<>(this.getQuarantineHistory()),\n+        new HashMap<>(this.getHealthCheckMap()),\n+        new HashMap<>(this.getTrackerClientStateMap()),\n+        this.getListeners());\n+  }\n+\n+  public int getPartitionId()\n+  {\n+    return _partitionId;\n+  }\n+\n+  public long getClusterGenerationId()\n+  {\n+    return _clusterGenerationId;\n+  }\n+\n+  public Map<TrackerClient, TrackerClientState> getTrackerClientStateMap()\n+  {\n+    return _trackerClientStateMap;\n+  }\n+\n+  public Set<TrackerClient> getTrackerClients()\n+  {\n+    return _trackerClientStateMap.keySet();\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineMap()\n+  {\n+    return _quarantineMap;\n+  }\n+\n+  public Map<TrackerClient, LoadBalancerQuarantine> getQuarantineHistory()\n+  {\n+    return _quarantineHistory;\n+  }\n+\n+  public Map<TrackerClient, HealthCheck> getHealthCheckMap()\n+  {\n+    return _healthCheckMap;\n+  }\n+\n+  public Set<TrackerClient> getRecoveryTrackerClients()\n+  {\n+    return _recoveryTrackerClients;\n+  }\n+\n+  public RingFactory<URI> getRingFactory()\n+  {\n+    return _ringFactory;\n+  }\n+\n+  public Ring<URI> getRing()\n+  {\n+    return _ring;\n+  }\n+\n+  public void setClusterGenerationId(long clusterGenerationId)\n+  {\n+    _clusterGenerationId = clusterGenerationId;\n+  }\n+\n+  public Map<URI, Integer> getPointsMap()\n+  {\n+    return _pointsMap;\n+  }\n+\n+  /**\n+   * Reset the hash ring using the latest tracker clients and points map\n+   */\n+  public void resetRing()\n+  {\n+    Set<TrackerClient> trackerClients = _trackerClientStateMap.keySet();\n+    Map<URI, CallTracker> callTrackerMap = Collections.unmodifiableMap(trackerClients.stream()\n+        .collect(Collectors.toMap(TrackerClient::getUri, TrackerClient::getCallTracker)));\n+    _pointsMap = _trackerClientStateMap.entrySet().stream()\n+        .collect(Collectors.toMap(entry -> entry.getKey().getUri(),\n+            entry -> (int) Math.round(entry.getValue().getHealthScore() * entry.getKey().getPartitionWeight(_partitionId) * _pointsPerWeight)));\n+    _ring = _ringFactory.createRing(_pointsMap, callTrackerMap);\n+  }\n+\n+  public void setPartitionStats(double avgClusterLatency, long clusterCallCount, long clusterErrorCount)\n+  {\n+    _partitionStats = new PartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  public PartitionStats getPartitionStats()\n+  {\n+    return _partitionStats;\n+  }\n+\n+  public List<PartitionStateUpdateListener<PartitionState>> getListeners()\n+  {\n+    return Collections.unmodifiableList(_listeners);\n+  }\n+\n+  public void removeTrackerClient(TrackerClient trackerClient)", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5Njc5MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442996791", "bodyText": "removeTrackerClient is used in RelativeStateUpdater.java when the cluster generation id changed, we remove the hosts that de-announced", "author": "rachelhanhan", "createdAt": "2020-06-19T18:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MTU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MzMxNQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442443315", "bodyText": "-> QUARANTINE_MIN_REENTRY_TIME_MS", "author": "zhang-chris", "createdAt": "2020-06-18T19:09:10Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0NDU2Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442444562", "bodyText": "do you think state should be consolidated instead of split between here and partitionstate?", "author": "zhang-chris", "createdAt": "2020-06-18T19:11:38Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAwMTk1OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443001958", "bodyText": "We can discuss more about this. For quarantine in particular, if we enable quarantine for one partition, we should just enable it for all partitions. I think quarantineEnabled should be a state that is shared for multiple partitions under the same service name.", "author": "rachelhanhan", "createdAt": "2020-06-19T19:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0NDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1MjkxOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442452919", "bodyText": "doesnt need to be a separate method", "author": "zhang-chris", "createdAt": "2020-06-18T19:28:19Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAwNDI2Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443004263", "bodyText": "This is also used by unit test to explicitly enable quarantine, it encapsulates _quarantineEnabled from the direct access from unit tests.", "author": "rachelhanhan", "createdAt": "2020-06-19T19:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1MjkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjI1OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442466259", "bodyText": "handleSingleClientInRecovery?", "author": "zhang-chris", "createdAt": "2020-06-18T19:51:51Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjgzMA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442466830", "bodyText": "is this check necesary", "author": "zhang-chris", "createdAt": "2020-06-18T19:52:58Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNjA3Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443016077", "bodyText": "I just changed the 2nd logic, I think the previous 2nd condition was actually wrong.\nelse if (!_fastRecoveryEnabled\n|| trackerClientState.isUnhealthy()\n|| trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n{\n/**\n* Remove the client from the map if:\n* 1. fast recovery is not enabled OR\n* 2. the client is still unhealthy OR\n* 3. The health score is beyond 0.5, we will let it perform normal recovery\n*/\nrecoverySet.remove(trackerClient);\n}\nI think it is necessary to check the fast recovery, only if fast recovery is enabled, it makes sense to keep it in the recovery set.\nFor example, one host is quarantined, if fast recovery is not enabled, its health score can be recovered in the pattern: 0.00, 0.01, 0.06, 0.11....\nif fast recovery is enabled, the health score recovery pattern can be 0.00, 0.01, 0.02, 0.04, 0.08, 0.16 if it's not getting enough traffic.\nThere is no point to keep a host in the recovery set if fast recovery is not enabled. Because even if it's not getting enough traffic, we cannot perform fast recovery for the host.", "author": "rachelhanhan", "createdAt": "2020-06-19T19:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxNTg3NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443915874", "bodyText": "Will remove the fast recovery check here, instead, we will add the fast recovery check when we add a new client to the recovery set.", "author": "rachelhanhan", "createdAt": "2020-06-23T01:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3Njk0Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442476942", "bodyText": "when would points not be 0 if it's already in quarantine?", "author": "zhang-chris", "createdAt": "2020-06-18T20:12:59Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAxNzQxMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443017412", "bodyText": "I thought about this too, I think it will always be 0 as long as it is in quarantine state. I saw this logic in the V3 implementation, so I just didn't bother to reenforce the health score to be 0 again.\nI can remove this reset to 0 logic, it should always be 0, and doesn't need to be reset.", "author": "rachelhanhan", "createdAt": "2020-06-19T19:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3Njk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4MjgzOA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442482838", "bodyText": "imo the LBQ should have this logic internally \"(_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS\" instead of making user decide.", "author": "zhang-chris", "createdAt": "2020-06-18T20:25:34Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT\n+          && trackerClientState.isUnhealthy())\n+      {\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null)\n+          {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NDg5Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442484893", "bodyText": "isQuarantined", "author": "zhang-chris", "createdAt": "2020-06-18T20:29:55Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT\n+          && trackerClientState.isUnhealthy())\n+      {\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null)\n+          {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        }\n+        else\n+        {\n+          LOG.warn(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void enrollClientInRecoverySet(boolean isQuarantined, TrackerClient trackerClient,\n+      TrackerClientState trackerClientState, double serverWeight, Set<TrackerClient> recoverySet,\n+      PartitionState oldPartitionState)\n+  {\n+    if (!isQuarantined\n+        && trackerClientState.getHealthScore() == RelativeStateUpdater.MIN_HEALTH_SCORE\n+        && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT)\n+    {\n+      // Enroll the client to recovery set if the health score dropped to 0, but zookeeper does not set the client weight to be 0\n+      trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      if (!recoverySet.contains(trackerClient))\n+      {\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+\n+    // Also enroll new client into the recovery set if fast recovery and slow start are both enabled\n+    if (!recoverySet.contains(trackerClient)", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NTg4OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442485888", "bodyText": "debug? or rate limit", "author": "zhang-chris", "createdAt": "2020-06-18T20:32:01Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManager.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.None;\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.util.RateLimitedLogger;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckClientBuilder;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URISyntaxException;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Handles the quarantine and recovery logic, see {@link LoadBalancerQuarantine} to understand how quarantine works\n+ */\n+public class QuarantineManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(QuarantineManager.class);\n+  public static final double SLOW_START_ENABLED_THRESHOLD = 0;\n+  public static final double FAST_RECOVERY_HEALTH_SCORE_THRESHOLD = 0.5;\n+\n+  private static final double QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD = 0.0;\n+  private static final double FAST_RECOVERY_FACTOR = 2.0;\n+  private static final long QUARANTINE_REENTRY_TIME_MS = 30000;\n+  private static final double MIN_ZOOKEEPER_SERVER_WEIGHT = 0.0;\n+  private static final int MAX_RETRIES_TO_CHECK_QUARANTINE = 5;\n+  private static final int MAX_HOSTS_TO_PRE_CHECK_QUARANTINE = 10;\n+  private static final double INITIAL_RECOVERY_HEALTH_SCORE = 0.01;\n+  private static final long MIN_QUANRANTINE_LATENCY_MS = 300;\n+\n+  private final String _serviceName;\n+  private final String _servicePath;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final D2QuarantineProperties _quarantineProperties;\n+  private final boolean _slowStartEnabled;\n+  private final boolean _fastRecoveryEnabled;\n+  private final ScheduledExecutorService _executorService;\n+  private final Clock _clock;\n+  private final long _updateIntervalMs;\n+  private final double _relativeLatencyLowThresholdFactor;\n+  private final RateLimitedLogger _rateLimitedLogger;\n+\n+  private final AtomicBoolean _quarantineEnabled;\n+  private final AtomicInteger _quarantineRetries;\n+\n+  QuarantineManager(String serviceName, String servicePath, HealthCheckOperations healthCheckOperations,\n+      D2QuarantineProperties quarantineProperties, double slowStartThreshold, boolean fastRecoveryEnabled,\n+      ScheduledExecutorService executorService, Clock clock, long updateIntervalMs, double relativeLatencyLowThresholdFactor)\n+  {\n+    _serviceName = serviceName;\n+    _servicePath = servicePath;\n+    _healthCheckOperations = healthCheckOperations;\n+    _quarantineProperties = quarantineProperties;\n+    _slowStartEnabled = slowStartThreshold > SLOW_START_ENABLED_THRESHOLD;\n+    _fastRecoveryEnabled = fastRecoveryEnabled;\n+    _executorService = executorService;\n+    _clock = clock;\n+    _updateIntervalMs = updateIntervalMs;\n+    _relativeLatencyLowThresholdFactor = relativeLatencyLowThresholdFactor;\n+    _rateLimitedLogger = new RateLimitedLogger(LOG, RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS, clock);\n+\n+    _quarantineEnabled = new AtomicBoolean(false);\n+    _quarantineRetries = new AtomicInteger(0);\n+  }\n+\n+  /**\n+   * Update the health scores in {@link PartitionState} based on quarantine and recovery condition\n+   *\n+   * @param newPartitionState the new state of the load balancer\n+   * @param oldPartitionState the existing state of the load balancer\n+   * @param clusterAvgLatency The average latency of the cluster\n+   */\n+  public void updateQuarantineState(PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    long quarantineLatency = Math.max((long) (clusterAvgLatency * _relativeLatencyLowThresholdFactor),\n+        MIN_QUANRANTINE_LATENCY_MS);\n+    // Step 0: Pre-check if quarantine method works for clients, if it works, we will mark _quarantineEnabled as true\n+    preCheckQuarantine(newPartitionState, quarantineLatency);\n+    // Step 1: check if quarantine state still applies. If not, remove it from the quarantine map\n+    checkAndRemoveQuarantine(newPartitionState);\n+    // Step 2: Handle special clients recovery logic from the recovery map\n+    handleClientsRecovery(newPartitionState);\n+    // Step 3: Enroll new quarantine and recovery map\n+    enrollNewQuarantineAndRecovery(newPartitionState, oldPartitionState, quarantineLatency);\n+  }\n+\n+  /**\n+   * Before actually putting a client into quarantine, check if the specified quarantine method and path works\n+   */\n+  private void preCheckQuarantine(PartitionState partitionState, long quarantineLatency)\n+  {\n+    boolean isQuarantineConfigured = _quarantineProperties.hasQuarantineMaxPercent()\n+        && _quarantineProperties.getQuarantineMaxPercent() > QUARANTINE_ENABLED_PERCENTAGE_THRESHOLD;\n+    if (isQuarantineConfigured && !_quarantineEnabled.get()\n+        && _quarantineRetries.incrementAndGet() <= MAX_RETRIES_TO_CHECK_QUARANTINE)\n+    {\n+      // if quarantine is configured but not enabled, and we haven't tried MAX_RETRIES_TIMES,\n+      // check the hosts to see if the quarantine can be enabled.\n+      _executorService.submit(() -> preCheckQuarantineState(partitionState, quarantineLatency));\n+\n+    }\n+  }\n+\n+  boolean tryEnableQuarantine()\n+  {\n+    return _quarantineEnabled.compareAndSet(false, true);\n+  }\n+\n+  /**\n+   * Pre-check if quarantine can be enabled before directly enabling it\n+   * We limit the number of server hosts to prevent too many connections to be made at once when the downstream cluster is large\n+   *\n+   * @param partitionState The state of the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   */\n+  private void preCheckQuarantineState(PartitionState partitionState, long quarantineLatency)\n+  {\n+    Callback<None> healthCheckCallback = new HealthCheckCallBack<>();\n+    partitionState.getTrackerClients().stream().limit(MAX_HOSTS_TO_PRE_CHECK_QUARANTINE)\n+        .forEach(client -> {\n+          try\n+          {\n+            HealthCheck healthCheckClient = partitionState.getHealthCheckMap().get(client);\n+            if (healthCheckClient == null)\n+            {\n+              healthCheckClient =  new HealthCheckClientBuilder()\n+                  .setHealthCheckOperations(_healthCheckOperations)\n+                  .setHealthCheckPath(_quarantineProperties.getHealthCheckPath())\n+                  .setServicePath(_servicePath)\n+                  .setClock(_clock)\n+                  .setLatency(quarantineLatency)\n+                  .setMethod(_quarantineProperties.getHealthCheckMethod().toString())\n+                  .setClient(client)\n+                  .build();\n+              partitionState.getHealthCheckMap().put(client, healthCheckClient);\n+            }\n+            healthCheckClient.checkHealth(healthCheckCallback);\n+          }\n+          catch (URISyntaxException e)\n+          {\n+            LOG.error(\"Error to build healthCheckClient \", e);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Check if the quarantine still applies for each tracker client.\n+   * Remove it from the map if the quarantine is no long applicable. Put the client into recovery state right after the quarantine.\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void checkAndRemoveQuarantine(PartitionState partitionState)\n+  {\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = partitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = partitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      LoadBalancerQuarantine quarantine = quarantineMap.get(trackerClient);\n+      if (quarantine != null && quarantine.checkUpdateQuarantineState())\n+      {\n+        // Evict client from quarantine\n+        quarantineMap.remove(trackerClient);\n+        quarantineHistory.put(trackerClient, quarantine);\n+\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Handle the recovery for all the tracker clients in the recovery set\n+   *\n+   * @param partitionState The current state of the partition\n+   */\n+  private void handleClientsRecovery(PartitionState partitionState)\n+  {\n+    for (TrackerClient trackerClient : partitionState.getTrackerClients())\n+    {\n+      Set<TrackerClient> recoverySet = partitionState.getRecoveryTrackerClients();\n+      if (recoverySet.contains(trackerClient))\n+      {\n+        handleClientInRecoverySet(trackerClient, partitionState.getTrackerClientStateMap().get(trackerClient),\n+            partitionState.getRecoveryTrackerClients());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Enroll new tracker client to quarantine or recovery state\n+   *\n+   * @param newPartitionState The new state of the partition\n+   * @param oldPartitionState The old state of the partition\n+   * @param clusterAvgLatency The average latency of the cluster of last interval\n+   */\n+  private void enrollNewQuarantineAndRecovery(\n+      PartitionState newPartitionState,\n+      PartitionState oldPartitionState, long clusterAvgLatency)\n+  {\n+    int partitionId = newPartitionState.getPartitionId();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineMap = newPartitionState.getQuarantineMap();\n+    Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory = newPartitionState.getQuarantineHistory();\n+    Set<TrackerClient> recoverySet = newPartitionState.getRecoveryTrackerClients();\n+\n+    for (TrackerClient trackerClient : newPartitionState.getTrackerClients())\n+    {\n+      TrackerClientState trackerClientState = newPartitionState.getTrackerClientStateMap().get(trackerClient);\n+\n+      double serverWeight = trackerClient.getPartitionWeight(partitionId);\n+      // Check and enroll quarantine map\n+      boolean isQuarantined = enrollClientInQuarantineMap(trackerClient, trackerClientState, serverWeight, quarantineMap,\n+          quarantineHistory, newPartitionState.getTrackerClientStateMap().size(), clusterAvgLatency);\n+      // check and enroll recovery set\n+      enrollClientInRecoverySet(isQuarantined, trackerClient, trackerClientState, serverWeight, recoverySet,\n+          oldPartitionState);\n+    }\n+  }\n+\n+  /**\n+   * Perform fast recovery or regular recovery when necessary\n+   * Fast recovery will double the current health score when it is enabled\n+   *\n+   * @param trackerClient The {@link TrackerClient} to be recovered\n+   * @param trackerClientState The state of the {@link TrackerClient}\n+   * @param recoverySet A set of {@link TrackerClient} to be recovered\n+   */\n+  private void handleClientInRecoverySet(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      Set<TrackerClient> recoverySet)\n+  {\n+    if (trackerClientState.getCallCount() < trackerClientState.getAdjustedMinCallCount())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+      if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE)\n+      {\n+        // Reset the health score to initial recovery health score if health score dropped to 0 before\n+        trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      }\n+      else if (_fastRecoveryEnabled)\n+      {\n+        // If fast recovery is enabled, we perform fast recovery: double the health score\n+        healthScore *= FAST_RECOVERY_FACTOR;\n+        trackerClientState.setHealthScore(Math.min(healthScore, RelativeStateUpdater.MAX_HEALTH_SCORE));\n+      }\n+    }\n+    else if (!_fastRecoveryEnabled\n+        || !trackerClientState.isUnhealthy()\n+        || trackerClientState.getHealthScore() > FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      /**\n+       * Remove the client from the map if:\n+       * 1. fast recovery is not enabled OR\n+       * 2. the client is not unhealthy any more OR\n+       * 3. The health score is beyond 0.5, we will let it perform normal recovery\n+       */\n+      recoverySet.remove(trackerClient);\n+    }\n+  }\n+\n+  /**\n+   * To put a TrackerClient into quarantine, it needs to meet all the following criteria:\n+   * 1. its health score is less than or equal to the threshold (0.0).\n+   * 2. The call state in current interval is becoming worse, eg the latency or error rate is higher than the threshold.\n+   * 3. its clientWeight is greater than 0\n+   *    (ClientWeight can be 0 when the server's clientWeight in zookeeper is explicitly set to 0 in order to put the server into standby.\n+   *    In this particular case, we should not put the tracker client into the quarantine).\n+   * 4. The total clients in the quarantine is less than the pre-configured number max percentage\n+   *\n+   * @param trackerClient The server to be quarantined\n+   * @param trackerClientState The current state of the server\n+   * @param serverWeight The weight of the server host specified from Zookeeper\n+   * @param quarantineMap A map of current quarantined hosts\n+   * @param quarantineHistory The hosts that used to be quarantined\n+   * @param trackerClientSize The total number of hosts in the partition\n+   * @param quarantineLatency The quarantine latency threshold\n+   * @return True if the host is quarantined\n+   */\n+  private boolean enrollClientInQuarantineMap(TrackerClient trackerClient, TrackerClientState trackerClientState,\n+      double serverWeight, Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory, int trackerClientSize, long quarantineLatency)\n+  {\n+    if (_quarantineEnabled.get())\n+    {\n+      double healthScore = trackerClientState.getHealthScore();\n+\n+      if (quarantineMap.containsKey(trackerClient))\n+      {\n+        // If the client is still in quarantine, keep the points to 0 so no real traffic will be used\n+        trackerClientState.setHealthScore(RelativeStateUpdater.MIN_HEALTH_SCORE);\n+        return true;\n+      }\n+      else if (healthScore <= RelativeStateUpdater.MIN_HEALTH_SCORE\n+          && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT\n+          && trackerClientState.isUnhealthy())\n+      {\n+        if (quarantineMap.size() < Math.ceil(trackerClientSize * _quarantineProperties.getQuarantineMaxPercent()))\n+        {\n+          // If quarantine exists, reuse the same object\n+          LoadBalancerQuarantine quarantine = quarantineHistory.remove(trackerClient);\n+          if (quarantine == null)\n+          {\n+            quarantine = new LoadBalancerQuarantine(trackerClient, _executorService, _clock, _updateIntervalMs, quarantineLatency,\n+                _quarantineProperties.getHealthCheckMethod().toString(), _quarantineProperties.getHealthCheckPath(), _serviceName,\n+                _servicePath, _healthCheckOperations);\n+          }\n+          quarantine.reset((_clock.currentTimeMillis() - quarantine.getLastChecked()) > QUARANTINE_REENTRY_TIME_MS);\n+          quarantineMap.put(trackerClient, quarantine);\n+          return true;\n+        }\n+        else\n+        {\n+          LOG.warn(\"Quarantine for service {} is full! Could not add {}\", _serviceName, trackerClient);\n+        }\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private void enrollClientInRecoverySet(boolean isQuarantined, TrackerClient trackerClient,\n+      TrackerClientState trackerClientState, double serverWeight, Set<TrackerClient> recoverySet,\n+      PartitionState oldPartitionState)\n+  {\n+    if (!isQuarantined\n+        && trackerClientState.getHealthScore() == RelativeStateUpdater.MIN_HEALTH_SCORE\n+        && serverWeight > MIN_ZOOKEEPER_SERVER_WEIGHT)\n+    {\n+      // Enroll the client to recovery set if the health score dropped to 0, but zookeeper does not set the client weight to be 0\n+      trackerClientState.setHealthScore(INITIAL_RECOVERY_HEALTH_SCORE);\n+      if (!recoverySet.contains(trackerClient))\n+      {\n+        recoverySet.add(trackerClient);\n+      }\n+    }\n+\n+    // Also enroll new client into the recovery set if fast recovery and slow start are both enabled\n+    if (!recoverySet.contains(trackerClient)\n+        && !oldPartitionState.getTrackerClients().contains(trackerClient)\n+        && _fastRecoveryEnabled\n+        && _slowStartEnabled)\n+    {\n+      recoverySet.add(trackerClient);\n+    }\n+  }\n+\n+  private class HealthCheckCallBack<None> implements Callback<None>\n+  {\n+    @Override\n+    public void onError(Throwable e)\n+    {\n+      if (!_quarantineEnabled.get())\n+      {\n+        _rateLimitedLogger.warn(\"Error enabling quarantine. Health checking failed for service {}: \", _serviceName, e);\n+      }\n+    }\n+\n+    @Override\n+    public void onSuccess(None result)\n+    {\n+      if (tryEnableQuarantine())\n+      {\n+        LOG.info(\"Quarantine is enabled for service {}\", _serviceName);", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcwNDc0NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443704744", "bodyText": "This should be fine. This log will only happen once for each service, so it is actually information level to indicate the quarantine is now enabled.\nOnce _quarantineEnabled is set to true, we will not check quarantine again.", "author": "rachelhanhan", "createdAt": "2020-06-22T17:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4NzMzMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442487331", "bodyText": "say exposed for testing", "author": "zhang-chris", "createdAt": "2020-06-18T20:35:08Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategy.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This strategy balances traffic to hosts within a service by dynamically adjusting a server's\n+ * health score based on call statistics compared relatively to the performance of the entire cluster.\n+ *\n+ * Health score is rated on a scale from 0.0 - 1.0, with 0.0 meaning most unhealthy (all traffic\n+ * routed away) and 1.0 meaning most healthy (no traffic routed away). Note that this behavior is\n+ * inverse of dropRate in the degrader strategy.\n+ *\n+ * @see com.linkedin.d2.D2RelativeStrategyProperties\n+ */\n+public class RelativeLoadBalancerStrategy implements LoadBalancerStrategy\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeLoadBalancerStrategy.class);\n+  public static final String RELATIVE_LOAD_BALANCER_STRATEGY_NAME = \"relative\";\n+\n+  private final StateUpdater _stateUpdater;\n+  private final ClientSelector _clientSelector;\n+\n+  public RelativeLoadBalancerStrategy(StateUpdater stateUpdater,\n+                                      ClientSelector clientSelector)\n+  {\n+    _stateUpdater = stateUpdater;\n+    _clientSelector = clientSelector;\n+  }\n+\n+  @Override\n+  public String getName()\n+  {\n+    return RELATIVE_LOAD_BALANCER_STRATEGY_NAME;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        long clusterGenerationId,\n+                                        int partitionId,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    if (trackerClients == null || trackerClients.size() == 0)\n+    {\n+      LOG.warn(\"getTrackerClient called with null/empty trackerClients, so returning null\");\n+      return null;\n+    }\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients.values()), partitionId, clusterGenerationId);\n+    Ring<URI> ring = getRing(clusterGenerationId, partitionId, trackerClients);\n+    return _clientSelector.getTrackerClient(request, requestContext, ring, trackerClients);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Ring<URI> getRing(long clusterGenerationId, int partitionId, Map<URI, TrackerClient> trackerClients)\n+  {\n+    Ring<URI> ring = _stateUpdater.getRing(partitionId);\n+    if (ring == null)\n+    {\n+      // If there is no existing ring, we update the partition first\n+      _stateUpdater.updateState(new HashSet<>(trackerClients.values()), partitionId, clusterGenerationId);\n+    }\n+    return _stateUpdater.getRing(partitionId);\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4Nzk1NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442487954", "bodyText": "move to constructor and allow caller to inject.", "author": "zhang-chris", "createdAt": "2020-06-18T20:36:19Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategyFactory.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.D2RingProperties;\n+import com.linkedin.d2.HashConfig;\n+import com.linkedin.d2.HashMethod;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.HttpStatusCodeRange;\n+import com.linkedin.d2.HttpStatusCodeRangeArray;\n+import com.linkedin.d2.balancer.config.RelativeStrategyPropertiesConverter;\n+import com.linkedin.d2.balancer.event.EventEmitter;\n+import com.linkedin.d2.balancer.event.NoopEventEmitter;\n+import com.linkedin.d2.balancer.properties.ServiceProperties;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategyFactory;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.URIRegexHash;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.util.clock.Clock;\n+import com.linkedin.util.clock.SystemClock;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+\n+/**\n+ * Load balancer factory for {@link RelativeLoadBalancerStrategy}.\n+ */\n+public class RelativeLoadBalancerStrategyFactory implements LoadBalancerStrategyFactory<RelativeLoadBalancerStrategy>\n+{\n+  // Default load balancer property values\n+  public static final long DEFAULT_UPDATE_INTERVAL_MS = 5000L;\n+  public static final int DEFAULT_MIN_CALL_COUNT = 1;\n+  public static final double DEFAULT_INITIAL_HEALTH_SCORE = 1.0;\n+  public static final double DEFAULT_SLOW_START_THRESHOLD = 0.0;\n+  public static final double DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR = 1.1;\n+  public static final HttpStatusCodeRangeArray DEFAULT_ERROR_STATUS_FILTER =\n+      new HttpStatusCodeRangeArray(new HttpStatusCodeRange().setLowerBound(500).setUpperBound(599));\n+  private static final double DEFAULT_UP_STEP = 0.05;\n+  private static final double DEFAULT_DOWN_STEP = 0.2;\n+  private static final double DEFAULT_RELATIVE_LATENCY_HIGH_THRESHOLD_FACTOR = 1.3;\n+  private static final double DEFAULT_HIGH_ERROR_RATE = 1.1;\n+  private static final double DEFAULT_LOW_ERROR_RATE = 1.1;\n+  private static final long DEFAULT_EMITTING_INTERVAL_MS = 0L;\n+  private static final boolean DEFAULT_ENABLE_FAST_RECOVERY = false;\n+  // Default quarantine properties\n+  public static final double DEFAULT_QUARANTINE_MAX_PERCENT = 0.0;\n+  private static final HttpMethod DEFAULT_HTTP_METHOD = HttpMethod.OPTIONS;\n+  // Default ring properties\n+  private static final int DEFAULT_POINTS_PER_WEIGHT = 100;\n+\n+\n+  private final ScheduledExecutorService _executorService;\n+  private final HealthCheckOperations _healthCheckOperations;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _stateListenerFactories;\n+  private final EventEmitter _eventEmitter;\n+  private final Clock _clock;\n+\n+  public RelativeLoadBalancerStrategyFactory(ScheduledExecutorService executorService, HealthCheckOperations healthCheckOperations,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> stateListenerFactories, EventEmitter eventEmitter)\n+  {\n+    _executorService = executorService;\n+    _healthCheckOperations = healthCheckOperations;\n+    _stateListenerFactories = stateListenerFactories;\n+    _eventEmitter = (eventEmitter == null) ? new NoopEventEmitter() : eventEmitter;\n+    _clock = SystemClock.instance();", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxNTA4Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443715087", "bodyText": "The constructor of which class?", "author": "rachelhanhan", "createdAt": "2020-06-22T17:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4Nzk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5Mzg0Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442493842", "bodyText": "runnable necessary?", "author": "zhang-chris", "createdAt": "2020-06-18T20:48:22Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NjA1MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442496051", "bodyText": "use LogUtil.debug. in fact it's probably good practice to user logutil for every log call we make in this pr.", "author": "zhang-chris", "createdAt": "2020-06-18T20:53:02Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcxOTIwNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443719204", "bodyText": "I took a look into the implementation of LogUtil.debug, found it does nothing but just a check of log.isDebugEnabled(). Then I explicitly checked log4j implementation, it definitely takes care of the log level config too. So I just changed to use LOG directly since it's straightforward.", "author": "rachelhanhan", "createdAt": "2020-06-22T17:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NjA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxOTk2NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443919965", "bodyText": "Double checked on log4j implementation, it has exact same implementation of log level check and string array arguments. Will keep using log4j implementation directly.", "author": "rachelhanhan", "createdAt": "2020-06-23T02:04:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NjA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDMyNg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442500326", "bodyText": "can put in try block too", "author": "zhang-chris", "createdAt": "2020-06-18T21:01:40Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      notifyPartitionStateUpdateListener(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionState partitionState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      List<TrackerClient> trackerClientsToRemove = trackerClientStateMap.keySet().stream()\n+          .filter(oldTrackerClient -> !trackerClients.contains(oldTrackerClient))\n+          .collect(Collectors.toList());\n+      for (TrackerClient trackerClient : trackerClientsToRemove)\n+      {\n+        partitionState.removeTrackerClient(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionState partitionState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avgLatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          }\n+          else\n+          {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        }\n+        else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      }\n+      else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * ((double)callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * ((double)outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void notifyPartitionStateUpdateListener(PartitionState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)\n+  {\n+    Integer connectExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CONNECT_EXCEPTION, 0);\n+    Integer closedChannelExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CLOSED_CHANNEL_EXCEPTION, 0);\n+    Integer serverErrorCount = errorTypeCounts.getOrDefault(ErrorType.SERVER_ERROR, 0);\n+    Integer timeoutExceptionCount = errorTypeCounts.getOrDefault(ErrorType.TIMEOUT_EXCEPTION, 0);\n+    return callCount == 0\n+        ? 0\n+        : (double) (connectExceptionCount + closedChannelExceptionCount + serverErrorCount + timeoutExceptionCount) / callCount;\n+  }\n+\n+  private void initializePartition(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    PartitionState partitionState = new PartitionState(partitionId,", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDgxNQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442500815", "bodyText": "will they ever be null?", "author": "zhang-chris", "createdAt": "2020-06-18T21:02:34Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcyMDU2Ng==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443720566", "bodyText": "They will not, I will remove this.", "author": "rachelhanhan", "createdAt": "2020-06-22T17:35:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMDgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMTIyOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442501229", "bodyText": "this is also called during initialize so \"when there is a cluster uris change.\" is not accurate. would be good to summarize the update steps here.", "author": "zhang-chris", "createdAt": "2020-06-18T21:03:29Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcyNjQ2Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443726463", "bodyText": "Will update the doc", "author": "rachelhanhan", "createdAt": "2020-06-22T17:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMzY4OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442503688", "bodyText": "updateRing?", "author": "zhang-chris", "createdAt": "2020-06-18T21:08:49Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkyMjEyNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443922127", "bodyText": "Will change the naming", "author": "rachelhanhan", "createdAt": "2020-06-23T02:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMzY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNDMzMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442504332", "bodyText": "will this be null? seems better to do a comparison w/ old vs new and not present vs null.", "author": "zhang-chris", "createdAt": "2020-06-18T21:10:13Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcyODg1Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443728852", "bodyText": "Here is the place I used to have an optional variable. This is null if the cluster generation id does not change, it is only present if the cluster id changed. If it is changed, after all the update is done, we will update the clusterGeneratitionId of the new state.\nDo you think adding more java doc will help?", "author": "rachelhanhan", "createdAt": "2020-06-22T17:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNDMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkyMjM0OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443922348", "bodyText": "Will update to always pass the clusterGeneratitionId. If it's scheduled update, will pass the clusterGenerationId from the existing state instead", "author": "rachelhanhan", "createdAt": "2020-06-23T02:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNDMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODQwMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442508402", "bodyText": "can call this within updateHealthScoreAndState to slim down thisi method even more", "author": "zhang-chris", "createdAt": "2020-06-18T21:18:57Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzcyOTg0NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443729844", "bodyText": "I extracted avgClusterLatency because it is also used in quarantine calculation later, if I put it into #updateHealthScoreAndState, it's hard for me to pass the value into quarantine method.", "author": "rachelhanhan", "createdAt": "2020-06-22T17:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMTczMw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442511733", "bodyText": "getErrorRate more accurate", "author": "zhang-chris", "createdAt": "2020-06-18T21:26:14Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      notifyPartitionStateUpdateListener(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionState partitionState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      List<TrackerClient> trackerClientsToRemove = trackerClientStateMap.keySet().stream()\n+          .filter(oldTrackerClient -> !trackerClients.contains(oldTrackerClient))\n+          .collect(Collectors.toList());\n+      for (TrackerClient trackerClient : trackerClientsToRemove)\n+      {\n+        partitionState.removeTrackerClient(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionState partitionState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avgLatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          }\n+          else\n+          {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        }\n+        else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      }\n+      else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * ((double)callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * ((double)outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void notifyPartitionStateUpdateListener(PartitionState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyMzY5Ng==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442523696", "bodyText": "Can we separate out set up from actual test to reduce duplicate code and make tests slimmer? In a @BeforeMethod", "author": "zhang-chris", "createdAt": "2020-06-18T21:55:03Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Mocks mocks = new Mocks();\n+    Request request = Mockito.mock(Request.class);", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NTc0OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442495748", "bodyText": "Understood what you're doing here, but curious why -- isn't current regex cover all the cases? Why do we need to define errorSatusRanges?", "author": "cx-super", "createdAt": "2020-06-18T20:52:23Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientFactory.java", "diffHunk": "@@ -176,18 +175,38 @@ private static Pattern getErrorStatusPattern(String loadBalancerStrategyName, Se\n     return errorPattern;\n   }\n \n+  private static List<HttpStatusCodeRange> getErrorStatusRanges(ServiceProperties serviceProperties)\n+  {\n+    if (serviceProperties.getRelativeStrategyProperties() == null\n+        || serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter() == null)\n+    {\n+      return RelativeLoadBalancerStrategyFactory.DEFAULT_ERROR_STATUS_FILTER;\n+    }\n+    return serviceProperties.getRelativeStrategyProperties().getErrorStatusFilter();\n+  }\n+\n   private static TrackerClientImpl createTrackerClientImpl(URI uri,\n                                                            UriProperties uriProperties,\n                                                            ServiceProperties serviceProperties,\n                                                            String loadBalancerStrategyName,\n                                                            TransportClient transportClient,\n                                                            Clock clock)\n   {\n+    TrackerClientImpl.ErrorStatusMatch errorStatusRangeMatch = (status) -> {\n+      for(HttpStatusCodeRange statusCodeRange : getErrorStatusRanges(serviceProperties))\n+      {\n+        if (status >= statusCodeRange.getLowerBound() && status <= statusCodeRange.getUpperBound())\n+        {\n+          return true;\n+        }\n+      }\n+      return false;\n+    };", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczMjcxNQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443732715", "bodyText": "This is from DMRC's suggestions. I think it is easier if we want to do something such as [501 , 520] compared with using regex.", "author": "rachelhanhan", "createdAt": "2020-06-22T17:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NTc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczNjI5Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443736292", "bodyText": "DMRC doesn't like using regex because it's too generic.", "author": "zhang-chris", "createdAt": "2020-06-22T18:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NTc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg0OTAyNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443849024", "bodyText": "OK -- we're only compare against returncode. I'd argue generic is not a bad thing.", "author": "cx-super", "createdAt": "2020-06-22T21:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5ODQxMw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442498413", "bodyText": "How about just use Predicate?", "author": "cx-super", "createdAt": "2020-06-18T20:57:47Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/clients/TrackerClientImpl.java", "diffHunk": "@@ -280,21 +290,21 @@ private boolean isServerError(Throwable throwable)\n       RestException restException = (RestException) throwable;\n       if (restException.getResponse() != null)\n       {\n-        return matchErrorStatus(restException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(restException.getResponse().getStatus());\n       }\n     }\n     else if (throwable instanceof StreamException)\n     {\n       StreamException streamException = (StreamException) throwable;\n       if (streamException.getResponse() != null)\n       {\n-        return matchErrorStatus(streamException.getResponse().getStatus());\n+        return _errorStatusMatch.isError(streamException.getResponse().getStatus());\n       }\n     }\n     return false;\n   }\n \n-  private boolean matchErrorStatus(int status) {\n-    return _errorStatusPattern.matcher(Integer.toString(status)).matches();\n+  public interface ErrorStatusMatch {\n+    boolean isError(int status);\n   }", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkyMjQzMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443922431", "bodyText": "Sounds good", "author": "rachelhanhan", "createdAt": "2020-06-23T02:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5ODQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNjMxMw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442506313", "bodyText": "if 'fromTarget' returns null (ie the given host is not in the list), should we retry with a host from Ring?", "author": "cx-super", "createdAt": "2020-06-18T21:14:25Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczNzE1Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443737152", "bodyText": "I don't think so, if users are setting the fromTarget explicitly, they are expecting that host is the single host that should serve the request, if that host is not announced to d2, they should expect to get an error and fix it on their side.\nThis is the same logic we have in DegraderLoadBalancerStrategyV3 too.", "author": "rachelhanhan", "createdAt": "2020-06-22T18:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNjMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDY2NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442510664", "bodyText": "I'm trying to think how/when this will happen, because iterating through the trackerClients takes longer time. Guess it's safe because this happens rarely.", "author": "cx-super", "createdAt": "2020-06-18T21:23:50Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorImpl.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Implementation for {@link ClientSelector}\n+ */\n+public class ClientSelectorImpl implements ClientSelector\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(ClientSelectorImpl.class.getName());\n+\n+  private final HashFunction<Request> _requestHashFunction;\n+\n+  public ClientSelectorImpl(HashFunction<Request> requestHashFunction)\n+  {\n+    _requestHashFunction = requestHashFunction;\n+  }\n+\n+  /**\n+   * @return TrackerClient\n+   */\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        Ring<URI> ring,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient;\n+\n+    URI targetHostUri = KeyMapper.TargetHostHints.getRequestContextTargetHost(requestContext);\n+\n+    if (targetHostUri != null)\n+    {\n+      trackerClient = getTrackerClientFromTarget(targetHostUri, requestContext, trackerClients);\n+    }\n+    else\n+    {\n+      trackerClient = getTrackerClientFromRing(request, requestContext, ring, trackerClients);\n+    }\n+\n+    return trackerClient;\n+  }\n+\n+  private void addToExcludedHosts(TrackerClient trackerClient, RequestContext requestContext)\n+  {\n+    if (trackerClient != null)\n+    {\n+      LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, trackerClient.getUri());\n+    }\n+  }\n+\n+  private TrackerClient getTrackerClientFromTarget(URI targetHostUri, RequestContext requestContext, Map<URI, TrackerClient> trackerClients)\n+  {\n+    TrackerClient trackerClient = trackerClients.get(targetHostUri);\n+\n+    if (trackerClient == null)\n+    {\n+      LOG.warn(\"No client found for \", targetHostUri, \". Target host specified is no longer part of cluster\");\n+    }\n+    else\n+    {\n+      // if this flag is set to be true, that means affinity routing is preferred but backup requests are still acceptable\n+      Boolean otherHostAcceptable = KeyMapper.TargetHostHints.getRequestContextOtherHostAcceptable(requestContext);\n+      if (otherHostAcceptable != null && otherHostAcceptable)\n+      {\n+        addToExcludedHosts(trackerClient, requestContext);\n+      }\n+    }\n+    return trackerClient;\n+  }\n+\n+  private TrackerClient getTrackerClientFromRing(Request request,\n+                                                 RequestContext requestContext,\n+                                                 Ring<URI> ring,\n+                                                 Map<URI, TrackerClient> trackerClients)\n+  {\n+    Set<URI> excludedUris = LoadBalancerStrategy.ExcludedHostHints.getRequestContextExcludedHosts(requestContext) == null\n+        ? new HashSet<>()\n+        : LoadBalancerStrategy.ExcludedHostHints.getRequestContextExcludedHosts(requestContext);\n+    int hashCode = _requestHashFunction.hash(request);\n+    URI uri = ring.get(hashCode);\n+\n+    TrackerClient trackerClient = trackerClients.get(uri);\n+\n+    if (trackerClient == null || excludedUris.contains(uri))\n+    {\n+      // Find next available URI.\n+      Iterator<URI> ringIterator = ring.getIterator(hashCode);\n+\n+      while (ringIterator.hasNext())\n+      {\n+        uri = ringIterator.next();\n+        trackerClient = trackerClients.get(uri);\n+\n+        if (trackerClient != null && !excludedUris.contains(uri))\n+        {\n+          break;\n+        }\n+      }\n+      trackerClient = null;\n+    }\n+\n+    if (trackerClient == null)\n+    {\n+      // Pick one from the tracker clients passed from the request if the ring is completely out of date", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczOTkxNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443739917", "bodyText": "This may happen a little bit more often compared with the existing V3 implementation. Because we do more async partition state update, if a request comes in and the cluster uris just changed, because we use executor to trigger the update, we may end up with a completely out-of-date ring for this request if the cluster uri set is completely new. The possibility is higher than the old implementation, but it is still very rare.", "author": "rachelhanhan", "createdAt": "2020-06-22T18:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg1MTUzNg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443851536", "bodyText": "It's hardly to have a completely new list of URIs so agree it's rare.", "author": "cx-super", "createdAt": "2020-06-22T22:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzA3NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442517074", "bodyText": "shallowCopy?", "author": "cx-super", "createdAt": "2020-06-18T21:38:30Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/PartitionState.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+   Copyright (c) 2017 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheck;\n+import com.linkedin.util.degrader.CallTracker;\n+import java.net.URI;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+\n+/**\n+ * Each {@link PartitionState} corresponds to a partition for a particular service in the relative load balancer\n+ * It keeps the tracker clients and the ring of the partition\n+ */\n+public class PartitionState\n+{\n+  private final int _partitionId;\n+  private final int _pointsPerWeight;\n+  private final RingFactory<URI> _ringFactory;\n+  private final List<PartitionStateUpdateListener<PartitionState>> _listeners;\n+  private Set<TrackerClient> _recoveryTrackerClients;\n+  private long _clusterGenerationId;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap;\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineHistory;\n+  private Map<TrackerClient, HealthCheck> _healthCheckMap;\n+  private Map<URI, Integer> _pointsMap;\n+  private Ring<URI> _ring;\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap;\n+  private PartitionStats _partitionStats;\n+\n+  public PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _clusterGenerationId = -1;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+\n+    _recoveryTrackerClients = new HashSet<>();\n+    _quarantineMap = new HashMap<>();\n+    _quarantineHistory = new HashMap<>();\n+    _healthCheckMap = new HashMap<>();\n+    _trackerClientStateMap = new HashMap<>();\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  PartitionState(int partitionId, RingFactory<URI> ringFactory, int pointsPerWeight,\n+      Set<TrackerClient> recoveryTrackerClients, long clusterGenerationId,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineMap,\n+      Map<TrackerClient, LoadBalancerQuarantine> quarantineHistory,\n+      Map<TrackerClient, HealthCheck> healthCheckMap,\n+      Map<TrackerClient, TrackerClientState> trackerClientStateMap,\n+      List<PartitionStateUpdateListener<PartitionState>> listeners)\n+  {\n+    _partitionId = partitionId;\n+    _ringFactory = ringFactory;\n+    _pointsPerWeight = pointsPerWeight;\n+    _recoveryTrackerClients = recoveryTrackerClients;\n+    _clusterGenerationId = clusterGenerationId;\n+    _quarantineMap = quarantineMap;\n+    _quarantineHistory = quarantineHistory;\n+    _healthCheckMap = healthCheckMap;\n+    _trackerClientStateMap = trackerClientStateMap;\n+    _listeners = listeners;\n+    resetRing();\n+  }\n+\n+  public PartitionState copy()", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0MjczNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443742734", "bodyText": "It's not purely shallowCopy, especially for the Map variables. I created a new map for the new state, so that if we add new elements or remove outdated old elements in the new state, it will not change the old state. Want to keep the old state immutable.", "author": "rachelhanhan", "createdAt": "2020-06-22T18:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg1MjQ3Ng==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443852476", "bodyText": "Trying to come up a new name because copy/clone suggest reuse the objects. Maybe constructNew or build?", "author": "cx-super", "createdAt": "2020-06-22T22:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkyNDIxOA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443924218", "bodyText": "I changed it to a constructor instead, does this work better?\npublic PartitionState (PartitionState oldPartitionState)\n{\nthis(oldPartitionState.getPartitionId(),\noldPartitionState.getRingFactory(),\noldPartitionState.getPointsPerWeight(),\nnew HashSet<>(oldPartitionState.getRecoveryTrackerClients()),\noldPartitionState.getClusterGenerationId(),\nnew HashMap<>(oldPartitionState.getQuarantineMap()),\nnew HashMap<>(oldPartitionState.getQuarantineHistory()),\nnew HashMap<>(oldPartitionState.getHealthCheckMap()),\nnew HashMap<>(oldPartitionState.getTrackerClientStateMap()),\noldPartitionState.getListeners());\n}", "author": "rachelhanhan", "createdAt": "2020-06-23T02:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM2OTM2Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444369367", "bodyText": "Yes!", "author": "cx-super", "createdAt": "2020-06-23T16:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxNzA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODk4Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442528982", "bodyText": "So if an application just grab ring for their use case (ie only use getRing), it is possible the state will never be updated if ring is not null?\nWe may consider to always invoke #updateState here. #getTrackerClient needs to get ring anyway.", "author": "cx-super", "createdAt": "2020-06-18T22:08:41Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeLoadBalancerStrategy.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.ClientSelector;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.HashSet;\n+import java.util.Map;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This strategy balances traffic to hosts within a service by dynamically adjusting a server's\n+ * health score based on call statistics compared relatively to the performance of the entire cluster.\n+ *\n+ * Health score is rated on a scale from 0.0 - 1.0, with 0.0 meaning most unhealthy (all traffic\n+ * routed away) and 1.0 meaning most healthy (no traffic routed away). Note that this behavior is\n+ * inverse of dropRate in the degrader strategy.\n+ *\n+ * @see com.linkedin.d2.D2RelativeStrategyProperties\n+ */\n+public class RelativeLoadBalancerStrategy implements LoadBalancerStrategy\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeLoadBalancerStrategy.class);\n+  public static final String RELATIVE_LOAD_BALANCER_STRATEGY_NAME = \"relative\";\n+\n+  private final StateUpdater _stateUpdater;\n+  private final ClientSelector _clientSelector;\n+\n+  public RelativeLoadBalancerStrategy(StateUpdater stateUpdater,\n+                                      ClientSelector clientSelector)\n+  {\n+    _stateUpdater = stateUpdater;\n+    _clientSelector = clientSelector;\n+  }\n+\n+  @Override\n+  public String getName()\n+  {\n+    return RELATIVE_LOAD_BALANCER_STRATEGY_NAME;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public TrackerClient getTrackerClient(Request request,\n+                                        RequestContext requestContext,\n+                                        long clusterGenerationId,\n+                                        int partitionId,\n+                                        Map<URI, TrackerClient> trackerClients)\n+  {\n+    if (trackerClients == null || trackerClients.size() == 0)\n+    {\n+      LOG.warn(\"getTrackerClient called with null/empty trackerClients, so returning null\");\n+      return null;\n+    }\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients.values()), partitionId, clusterGenerationId);\n+    Ring<URI> ring = getRing(clusterGenerationId, partitionId, trackerClients);\n+    return _clientSelector.getTrackerClient(request, requestContext, ring, trackerClients);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Ring<URI> getRing(long clusterGenerationId, int partitionId, Map<URI, TrackerClient> trackerClients)\n+  {\n+    Ring<URI> ring = _stateUpdater.getRing(partitionId);\n+    if (ring == null)", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc0OTAxMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443749012", "bodyText": "That's a good point. The state will keep updating itself in every interval, because it is scheduled by the executor in the constructor of the state updater. So as long as it is initialized, it will still be updated. But one case I didn't take care of is the cluster generation id change, I will just always invoke updateState then.", "author": "rachelhanhan", "createdAt": "2020-06-22T18:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzYzMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442533631", "bodyText": "Not necessarily bit savings, but we can lock by partitionId.", "author": "cx-super", "createdAt": "2020-06-18T22:22:25Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,\n+        _relativeStrategyProperties.getUpdateIntervalMs(), TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public void updateState(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    if (!_partitionLoadBalancerStateMap.containsKey(partitionId))\n+    {\n+      // If the partition is not initialized, initialize the state synchronously\n+      initializePartition(trackerClients, partitionId, clusterGenerationId);\n+    }\n+    else if (clusterGenerationId != _partitionLoadBalancerStateMap.get(partitionId).getClusterGenerationId())\n+    {\n+      // Asynchronously update the state if it is from uri properties change\n+      PartitionState oldPartitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      _executorService.execute(() -> updateStateForPartition(trackerClients, partitionId, oldPartitionState, clusterGenerationId));\n+    }\n+  }\n+\n+  @Override\n+  public Ring<URI> getRing(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? null\n+        : _partitionLoadBalancerStateMap.get(partitionId).getRing();\n+  }\n+\n+  Map<URI, Integer> getPointsMap(int partitionId)\n+  {\n+    return _partitionLoadBalancerStateMap.get(partitionId) == null\n+        ? new HashMap<>()\n+        : _partitionLoadBalancerStateMap.get(partitionId).getPointsMap();\n+  }\n+\n+  /**\n+   * Update the partition state.\n+   * This is scheduled by executor, and the update should not involve any cluster change\n+   */\n+  void updateState()\n+  {\n+    // Update state for each partition\n+    for (Integer partitionId : _partitionLoadBalancerStateMap.keySet())\n+    {\n+      PartitionState partitionState = _partitionLoadBalancerStateMap.get(partitionId);\n+      if (partitionState != null)\n+      {\n+        updateStateForPartition(partitionState.getTrackerClients(), partitionId, partitionState, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Update the partition state when there is a cluster uris change.\n+   */\n+  void updateStateForPartition(Set<TrackerClient> trackerClients, int partitionId,\n+      PartitionState oldPartitionState, Long clusterGenerationId)\n+  {\n+    LOG.debug(\"Updating for partition: \" + partitionId + \", state: \" + oldPartitionState);\n+    PartitionState newPartitionState = oldPartitionState.copy();\n+\n+    // Step 1: Update the base health scores for each {@link TrackerClient} in the cluster\n+    Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap = new HashMap<>();\n+    long avgClusterLatency = getAvgClusterLatency(trackerClients, latestCallStatsMap);\n+    updateHealthScoreAndState(trackerClients, newPartitionState, avgClusterLatency, clusterGenerationId, latestCallStatsMap);\n+\n+    // Step 2: Handle quarantine and recovery for all tracker clients in this cluster\n+    // this will adjust the base health score if there is any change in quarantine and recovery map\n+    _quarantineManager.updateQuarantineState(newPartitionState,\n+        oldPartitionState, avgClusterLatency);\n+\n+    // Step 3: Calculate the new ring for each partition\n+    newPartitionState.resetRing();\n+\n+    if (clusterGenerationId != null)\n+    {\n+      newPartitionState.setClusterGenerationId(clusterGenerationId);\n+    }\n+    _partitionLoadBalancerStateMap.put(partitionId, newPartitionState);\n+\n+    // Step 4: Log and emit monitor event\n+    _executorService.execute(() -> {\n+      logState(oldPartitionState, newPartitionState, partitionId);\n+      notifyPartitionStateUpdateListener(newPartitionState);\n+    });\n+  }\n+\n+  /**\n+   * Update the health score of all tracker clients for the service\n+   * @param trackerClients All the tracker clients in this cluster\n+   */\n+  private void updateHealthScoreAndState(Set<TrackerClient> trackerClients,\n+      PartitionState partitionState, long clusterAvgLatency,\n+      Long clusterGenerationId, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    // Calculate the base health score before we override them when handling the quarantine and recovery\n+    calculateBaseHealthScore(trackerClients, partitionState, clusterAvgLatency, lastCallStatsMap);\n+\n+    // Remove the trackerClients from original map if there is any change in uri list\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+    if (clusterGenerationId != null)\n+    {\n+      List<TrackerClient> trackerClientsToRemove = trackerClientStateMap.keySet().stream()\n+          .filter(oldTrackerClient -> !trackerClients.contains(oldTrackerClient))\n+          .collect(Collectors.toList());\n+      for (TrackerClient trackerClient : trackerClientsToRemove)\n+      {\n+        partitionState.removeTrackerClient(trackerClient);\n+      }\n+    }\n+  }\n+\n+  private void calculateBaseHealthScore(Set<TrackerClient> trackerClients, PartitionState partitionState,\n+      long avgClusterLatency, Map<TrackerClient, CallTracker.CallStats> lastCallStatsMap)\n+  {\n+    Map<TrackerClient, TrackerClientState> trackerClientStateMap = partitionState.getTrackerClientStateMap();\n+\n+    // Update health score\n+    long clusterCallCount = 0;\n+    long clusterErrorCount = 0;\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = lastCallStatsMap.get(trackerClient);\n+\n+      if (trackerClientStateMap.containsKey(trackerClient))\n+      {\n+        TrackerClientState trackerClientState = trackerClientStateMap.get(trackerClient);\n+        int callCount = latestCallStats.getCallCount() + latestCallStats.getOutstandingCount();\n+        double errorRate = getErrorRateByType(latestCallStats.getErrorTypeCounts(), callCount);\n+        long avgLatency = getAvgHostLatency(latestCallStats);\n+        double oldHealthScore = trackerClientState.getHealthScore();\n+        double newHealthScore = oldHealthScore;\n+\n+        clusterCallCount += callCount;\n+        clusterErrorCount += errorRate * callCount;\n+\n+        if (isUnhealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          // If it is above high latency, we reduce the health score by down step\n+          newHealthScore = Double.max(trackerClientState.getHealthScore() - _relativeStrategyProperties.getDownStep(), MIN_HEALTH_SCORE);\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.UNHEALTHY);\n+        }\n+        else if (trackerClientState.getHealthScore() < MAX_HEALTH_SCORE\n+            && isHealthy(trackerClientState, avgClusterLatency, callCount, avgLatency, errorRate))\n+        {\n+          if (oldHealthScore < _relativeStrategyProperties.getSlowStartThreshold())\n+          {\n+            // If the client is healthy and slow start is enabled, we double the health score\n+            newHealthScore = oldHealthScore > MIN_HEALTH_SCORE\n+                ? Math.min(MAX_HEALTH_SCORE, SLOW_START_RECOVERY_FACTOR * oldHealthScore)\n+                : SLOW_START_INITIAL_HEALTH_SCORE;\n+          }\n+          else\n+          {\n+            // If slow start is not enabled, we just increase the health score by up step\n+            newHealthScore = Math.min(MAX_HEALTH_SCORE, oldHealthScore + _relativeStrategyProperties.getUpStep());\n+          }\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.HEALTHY);\n+        }\n+        else\n+        {\n+          trackerClientState.setHealthState(TrackerClientState.HealthState.NEUTRAL);\n+        }\n+        trackerClientState.setHealthScore(newHealthScore);\n+        trackerClientState.setCallCount(callCount);\n+      }\n+      else\n+      {\n+        // If it is a new client, we directly set health score as the initial health score to initialize\n+        trackerClientStateMap.put(trackerClient, new TrackerClientState(_relativeStrategyProperties.getInitialHealthScore(),\n+            _relativeStrategyProperties.getMinCallCount()));\n+      }\n+    }\n+    partitionState.setPartitionStats(avgClusterLatency, clusterCallCount, clusterErrorCount);\n+  }\n+\n+  private long getAvgClusterLatency(Set<TrackerClient> trackerClients, Map<TrackerClient, CallTracker.CallStats> latestCallStatsMap)\n+  {\n+    long latencySum = 0;\n+    long outstandingLatencySum = 0;\n+    int callCountSum = 0;\n+    int outstandingCallCountSum = 0;\n+\n+    for (TrackerClient trackerClient : trackerClients)\n+    {\n+      CallTracker.CallStats latestCallStats = trackerClient.getCallTracker().getCallStats();\n+      latestCallStatsMap.put(trackerClient, latestCallStats);\n+\n+      int callCount = latestCallStats.getCallCount();\n+      int outstandingCallCount = latestCallStats.getOutstandingCount();\n+      latencySum += latestCallStats.getCallTimeStats().getAverage() * callCount;\n+      outstandingLatencySum += latestCallStats.getOutstandingStartTimeAvg() * outstandingCallCount;\n+      callCountSum += callCount;\n+      outstandingCallCountSum += outstandingCallCount;\n+    }\n+\n+    return callCountSum + outstandingCallCountSum == 0\n+        ? 0\n+        : (latencySum + outstandingLatencySum) / (callCountSum + outstandingCallCountSum);\n+  }\n+\n+  private static long getAvgHostLatency(CallTracker.CallStats callStats)\n+  {\n+    double avgLatency = callStats.getCallTimeStats().getAverage();\n+    long avgOutstandingLatency = callStats.getOutstandingStartTimeAvg();\n+    int callCount = callStats.getCallCount();\n+    int outstandingCallCount = callStats.getOutstandingCount();\n+    return callCount + outstandingCallCount == 0\n+        ? 0\n+        : Math.round(avgLatency * ((double)callCount / (callCount + outstandingCallCount))\n+            + avgOutstandingLatency * ((double)outstandingCallCount / (callCount + outstandingCallCount)));\n+  }\n+\n+  /**\n+   * Identify if a client is unhealthy\n+   */\n+  private boolean isUnhealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency >= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyHighThresholdFactor()\n+        || errorRate >= _relativeStrategyProperties.getHighErrorRate());\n+  }\n+\n+  /**\n+   * Identify if a client is healthy\n+   */\n+  private boolean isHealthy(TrackerClientState trackerClientState, long avgClusterLatency,\n+      int callCount, long latency, double errorRate)\n+  {\n+    return callCount >= trackerClientState.getAdjustedMinCallCount()\n+        && (latency <= avgClusterLatency * _relativeStrategyProperties.getRelativeLatencyLowThresholdFactor()\n+        || errorRate <= _relativeStrategyProperties.getLowErrorRate());\n+  }\n+\n+  private void notifyPartitionStateUpdateListener(PartitionState state)\n+  {\n+    state.getListeners().forEach(listener -> listener.onUpdate(state));\n+  }\n+\n+  private static double getErrorRateByType(Map<ErrorType, Integer> errorTypeCounts, int callCount)\n+  {\n+    Integer connectExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CONNECT_EXCEPTION, 0);\n+    Integer closedChannelExceptionCount = errorTypeCounts.getOrDefault(ErrorType.CLOSED_CHANNEL_EXCEPTION, 0);\n+    Integer serverErrorCount = errorTypeCounts.getOrDefault(ErrorType.SERVER_ERROR, 0);\n+    Integer timeoutExceptionCount = errorTypeCounts.getOrDefault(ErrorType.TIMEOUT_EXCEPTION, 0);\n+    return callCount == 0\n+        ? 0\n+        : (double) (connectExceptionCount + closedChannelExceptionCount + serverErrorCount + timeoutExceptionCount) / callCount;\n+  }\n+\n+  private void initializePartition(Set<TrackerClient> trackerClients, int partitionId, long clusterGenerationId)\n+  {\n+    PartitionState partitionState = new PartitionState(partitionId,\n+            new DelegatingRingFactory<>(_relativeStrategyProperties.getRingProperties()),\n+            _relativeStrategyProperties.getRingProperties().getPointsPerWeight(),\n+            _listenerFactories.stream().map(factory -> factory.create(partitionId)).collect(Collectors.toList()));\n+\n+    _lock.lock();", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1MDkwMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443750902", "bodyText": "The partitionId is dynamically identified, when the RelativeStateUpdater class is initialized, we do not know how many partitions we are going to have, how can we lock by partitionId?", "author": "rachelhanhan", "createdAt": "2020-06-22T18:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg1MzkyOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443853929", "bodyText": "I'm thinking bitLock or lockMap. It's probably won't save us a lot given that not that many apps are using partitioning.", "author": "cx-super", "createdAt": "2020-06-22T22:10:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzU5Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442543597", "bodyText": "For the fixed-schedule update, if another update triggered by clusterVersion happens in the middle, it is possible that we do not have sufficient data to adjust the pointsMap. Do we need to do something? I can think of:\n\ncancel next update and reschedule a new time (complicated).\nSet some threshold so that if it does not meet, we do not calculate a new healthScore. How to pick the threshold though is hard though (this is becomes variable intervals).", "author": "cx-super", "createdAt": "2020-06-18T22:54:10Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/relative/RelativeStateUpdater.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.PartitionStateUpdateListener;\n+import com.linkedin.d2.balancer.strategies.StateUpdater;\n+import com.linkedin.d2.balancer.strategies.degrader.DelegatingRingFactory;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Update the state of the RelativeLoadBalancerStrategy periodically\n+ */\n+public class RelativeStateUpdater implements StateUpdater\n+{\n+  private static final Logger LOG = LoggerFactory.getLogger(RelativeStateUpdater.class);\n+  public static final double MIN_HEALTH_SCORE = 0.0;\n+  public static final double MAX_HEALTH_SCORE = 1.0;\n+  private static final double SLOW_START_INITIAL_HEALTH_SCORE = 0.01;\n+  private static final int SLOW_START_RECOVERY_FACTOR = 2;\n+  private static final int LOG_UNHEALTHY_CLIENT_NUMBERS = 10;\n+  private static final long EXECUTOR_INITIAL_DELAY = 10;\n+\n+  private final D2RelativeStrategyProperties _relativeStrategyProperties;\n+  private final QuarantineManager _quarantineManager;\n+  private final ScheduledExecutorService _executorService;\n+  private final Lock _lock;\n+  private final List<PartitionStateUpdateListener.Factory<PartitionState>> _listenerFactories;\n+\n+  private ConcurrentMap<Integer, PartitionState> _partitionLoadBalancerStateMap;\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+                       QuarantineManager quarantineManager,\n+                       ScheduledExecutorService executorService,\n+                       List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    this(relativeStrategyProperties, quarantineManager, executorService, new ConcurrentHashMap<>(), listenerFactories);\n+  }\n+\n+  RelativeStateUpdater(D2RelativeStrategyProperties relativeStrategyProperties,\n+      QuarantineManager quarantineManager,\n+      ScheduledExecutorService executorService,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap,\n+      List<PartitionStateUpdateListener.Factory<PartitionState>> listenerFactories)\n+  {\n+    _relativeStrategyProperties = relativeStrategyProperties;\n+    _quarantineManager = quarantineManager;\n+    _executorService = executorService;\n+    _listenerFactories = listenerFactories;\n+    _partitionLoadBalancerStateMap = partitionLoadBalancerStateMap;\n+    _lock = new ReentrantLock();\n+\n+    _executorService.scheduleWithFixedDelay((Runnable) this::updateState, EXECUTOR_INITIAL_DELAY,", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1NTU3NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443755574", "bodyText": "My understanding is that each TrackerClient has its own interval calculation which is independent from the load balancer strategy update,  the loadBalancerStrategy will not reset the intervals in each TrackerClient. Even if we have 2 updates in the same interval, the call tracker always returns us the latest stats of the last full interval based on its own timing calculation. So I'm not worried about having insufficient data.", "author": "rachelhanhan", "createdAt": "2020-06-22T18:42:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg1NjUyMg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443856522", "bodyText": "Good point -- forgot we're always reading stats from last reading window.", "author": "cx-super", "createdAt": "2020-06-22T22:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r442546420", "bodyText": "This interface really is LoadBalancerStrategy was targeted to do. Maybe we can combine them?", "author": "cx-super", "createdAt": "2020-06-18T23:03:41Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/strategies/ClientSelector.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.d2.balancer.strategies;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+\n+\n+/**\n+ * The selector that selects a {@link TrackerClient} from the ring to route the request to\n+ */\n+public interface ClientSelector", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc1OTM5NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443759395", "bodyText": "We have StateUpdater and ClientSelector interfaces to indicate there are 2 different steps in the load balancer strategy, so if there is one more version of strategy, we expect them to follow the same pattern to do host selection.\n@zhang-chris what do you think?", "author": "rachelhanhan", "createdAt": "2020-06-22T18:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg1NzY4NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443857685", "bodyText": "StateUpdater is really implementation details. From user interface perspective only clientSelector matters. If you want to keep the simplicity of clientSelector, how about let LoadbalanceStrategy extends clientSelector?", "author": "cx-super", "createdAt": "2020-06-22T22:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg1OTg0Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443859843", "bodyText": "In that sense, I'd rather remove ClientSelector and StateUpdater as interface. I don't think strategy should extend clientSelector. If one strategy extends client selector, we should let all strategies extend client selector.\nIf we don't think StateUpdater will ever expose public methods to other mps, I'm fine to remove it. @zhang-chris what do you think.", "author": "rachelhanhan", "createdAt": "2020-06-22T22:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk5MzQ0Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r443993443", "bodyText": "Removed the ClientSelector and StateUpdater interface.", "author": "rachelhanhan", "createdAt": "2020-06-23T06:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM3MjI0OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444372249", "bodyText": "Sorry, really did not mean to get rid of it.\nWhy let loadBalanceStrategy extend ClientSelector a bad idea? All existing strategies should still just need to implement LoadBalancerStrategy...", "author": "cx-super", "createdAt": "2020-06-23T16:58:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyOTU2OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444429568", "bodyText": "Because the ClientSelector is invoked by RelativeLoadBalancerStrategy.class, client selector is used in relativeLoadBalancer to find a host from the ring after the ring is updated. StateUpdater and ClientSelector are 2 steps in the new strategy.\nBecause I see the interface of client selector brings the confusion, and it's more internal to the strategy implementation, so I removed the interface.", "author": "rachelhanhan", "createdAt": "2020-06-23T18:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjQyMA=="}], "type": "inlineReview"}, {"oid": "45bb2989b15e0032c732be703262ca777b97568b", "url": "https://github.com/linkedin/rest.li/commit/45bb2989b15e0032c732be703262ca777b97568b", "message": "Addressed PR comments", "committedDate": "2020-06-23T06:36:24Z", "type": "commit"}, {"oid": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "url": "https://github.com/linkedin/rest.li/commit/485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "message": "Added some minor fixes including\n1. Removed unnecessary call triggered by concurrent cluster change requests\n2. Change \"toString\" implementation to make log more readable\n3. Other changes in unit tests", "committedDate": "2020-06-24T00:39:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyNjg4Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444426882", "bodyText": "I'm a fan of adding javadoc that links to the actual class\n\"Test for {@link ClientSelector}.\"", "author": "zhang-chris", "createdAt": "2020-06-23T18:33:40Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.HashFunction;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+", "originalCommit": "17d7b8dc2d69ad0ba0665daf3f63821cbb401c2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQyOTc0OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444429748", "bodyText": "move out any shared code; make tests as slim as possible. the only logic should be specific to what you're actually testing.", "author": "zhang-chris", "createdAt": "2020-06-23T18:38:59Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @BeforeMethod\n+  private void setup()\n+  {\n+    _clientSelector = new ClientSelector(new RandomHash());\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzMTMwMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444431301", "bodyText": "good practice to write the error message in the asserts too.", "author": "zhang-chris", "createdAt": "2020-06-23T18:41:35Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @BeforeMethod\n+  private void setup()\n+  {\n+    _clientSelector = new ClientSelector(new RandomHash());\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    KeyMapper.TargetHostHints.setRequestContextTargetHost(requestContext, URI_1);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient.getUri(), URI_1);", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNDU4Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445724582", "bodyText": "Do we normally add error message to every assert? Or just to the ones that are more flaky, so when the assert error actually happens, it tells what to check?\nIn most cases, we expect to pass 100% of the tests, so the error message won't show up at all.", "author": "rachelhanhan", "createdAt": "2020-06-25T17:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzMTMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODE5OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444438198", "bodyText": "add test for ring and clients only partially out of sync\nand for partial exclusion\nassert that Client added to excluded hosts", "author": "zhang-chris", "createdAt": "2020-06-23T18:53:53Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_1, TRACKER_CLIENT_1);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_2, TRACKER_CLIENT_2);\n+    DEFAULT_TRACKER_CLIENT_MAP.put(URI_3, TRACKER_CLIENT_3);\n+  }\n+\n+  @BeforeMethod\n+  private void setup()\n+  {\n+    _clientSelector = new ClientSelector(new RandomHash());\n+  }\n+\n+  @Test\n+  public void testGetTargetHost()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    KeyMapper.TargetHostHints.setRequestContextTargetHost(requestContext, URI_1);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient.getUri(), URI_1);\n+  }\n+\n+  @Test\n+  public void testGetTargetHostNotFound() throws URISyntaxException {\n+    URI newUri = new URI(\"new_uri\");\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    KeyMapper.TargetHostHints.setRequestContextTargetHost(requestContext, newUri);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient, null);\n+  }\n+\n+  @Test\n+  public void testGetHostFromRing()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertTrue(DEFAULT_TRACKER_CLIENT_MAP.containsKey(trackerClient.getUri()));\n+  }\n+\n+  @Test\n+  public void testAllClientsExcluded()\n+  {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, URI_1);\n+    LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, URI_2);\n+    LoadBalancerStrategy.ExcludedHostHints.addRequestContextExcludedHost(requestContext, URI_3);\n+\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, DEFAULT_TRACKER_CLIENT_MAP);\n+    assertEquals(trackerClient, null);\n+  }\n+\n+  @Test\n+  public void testRingAndHostInconsistency() throws URISyntaxException {\n+    Request request = Mockito.mock(Request.class);\n+    RequestContext requestContext = new RequestContext();\n+    URI newUri = new URI(\"new_uri\");\n+    TrackerClient newTrackerClient = Mockito.mock(TrackerClient.class);\n+    Mockito.when(newTrackerClient.getUri()).thenReturn(newUri);\n+    Map<URI, TrackerClient> newTrackerClientMap = new HashMap<>();\n+    newTrackerClientMap.put(newUri, newTrackerClient);\n+\n+    // Ring and the tracker clients are completely off so that they do not have any overlap\n+    TrackerClient trackerClient = _clientSelector.getTrackerClient(request, requestContext, DEFAULT_RING, newTrackerClientMap);\n+    assertEquals(trackerClient, newTrackerClient);\n+  }", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcxNTEwNQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445715105", "bodyText": "The partially out of sync unit test is #testSubstituteClientFromRing\nAre you suggesting we should always assert the picked client is added to the excluded host?", "author": "rachelhanhan", "createdAt": "2020-06-25T17:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODE5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5NTIwNQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r446795205", "bodyText": "Will add the test for partically excluded urls", "author": "rachelhanhan", "createdAt": "2020-06-29T06:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODg2OA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444438868", "bodyText": "should mock the ring so we can more easily test some of the cases suggested below", "author": "zhang-chris", "createdAt": "2020-06-23T18:55:03Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/ClientSelectorTest.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.KeyMapper;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.LoadBalancerStrategy;\n+import com.linkedin.d2.balancer.util.hashing.DistributionNonDiscreteRing;\n+import com.linkedin.d2.balancer.util.hashing.RandomHash;\n+import com.linkedin.d2.balancer.util.hashing.Ring;\n+import com.linkedin.r2.message.Request;\n+import com.linkedin.r2.message.RequestContext;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class ClientSelectorTest {\n+  private static URI URI_1;\n+  private static URI URI_2;\n+  private static URI URI_3;\n+  private static final TrackerClient TRACKER_CLIENT_1 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_2 = Mockito.mock(TrackerClient.class);\n+  private static final TrackerClient TRACKER_CLIENT_3 = Mockito.mock(TrackerClient.class);\n+  private static final Map<URI, Integer> DEFAULT_POINTS_MAP = new HashMap<>();\n+  private static final Ring<URI> DEFAULT_RING;\n+  private static final Map<URI, TrackerClient> DEFAULT_TRACKER_CLIENT_MAP = new HashMap<>();\n+  private ClientSelector _clientSelector;\n+\n+  static {\n+    try {\n+      URI_1 = new URI(\"dummy_uri_1\");\n+      URI_2 = new URI(\"dummy_uri_2\");\n+      URI_3 = new URI(\"dummy_uri_3\");\n+    } catch (URISyntaxException e) {\n+      // do nothing\n+    }\n+    Mockito.when(TRACKER_CLIENT_1.getUri()).thenReturn(URI_1);\n+    Mockito.when(TRACKER_CLIENT_2.getUri()).thenReturn(URI_2);\n+    Mockito.when(TRACKER_CLIENT_3.getUri()).thenReturn(URI_3);\n+    DEFAULT_POINTS_MAP.put(URI_1, 60);\n+    DEFAULT_POINTS_MAP.put(URI_2, 80);\n+    DEFAULT_POINTS_MAP.put(URI_3, 100);\n+    DEFAULT_RING = new DistributionNonDiscreteRing<>(DEFAULT_POINTS_MAP);", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc5NTc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r446795785", "bodyText": "For most tests I did not explicitly specify which host the ring should return. For the test that needs this, I just created a mock in that particular unit test.", "author": "rachelhanhan", "createdAt": "2020-06-29T06:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxOTI0Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444519242", "bodyText": "PartitionStateBuilder?", "author": "zhang-chris", "createdAt": "2020-06-23T21:28:50Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/PartitionStateDataBuilder.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * The helper class that builds an object of {@link PartitionState}\n+ */\n+public class PartitionStateDataBuilder {", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyNTY2NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444525664", "bodyText": "Is this only for tests? Can we move to test directory?", "author": "zhang-chris", "createdAt": "2020-06-23T21:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxOTI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNjEyNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445726127", "bodyText": "This is only for test, it is under test module already.", "author": "rachelhanhan", "createdAt": "2020-06-25T17:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxOTI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMTI5Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445731297", "bodyText": "I didn't really name it as PartitionStateBuilder because it can be confusing if one day we have an actual builder for PartitionState, the package name will be same for test data builder and non-test builder.\nI can rename it to PartitionStateTestDateBuilder if that is more clear.", "author": "rachelhanhan", "createdAt": "2020-06-25T17:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxOTI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyNjAwOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444526009", "bodyText": "should probably make this method idempotent", "author": "zhang-chris", "createdAt": "2020-06-23T21:44:09Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/PartitionStateDataBuilder.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * The helper class that builds an object of {@link PartitionState}\n+ */\n+public class PartitionStateDataBuilder {\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final int DEFAULT_POINTS_PER_WEIGHT = 100;\n+\n+  private final RingFactory<URI> _ringFactory;\n+  private long _clusterGenerationId;\n+  private Set<TrackerClient> _recoveryTrackerClients = new HashSet<>();\n+  private Map<TrackerClient, LoadBalancerQuarantine> _quarantineMap = new HashMap<>();\n+  private Map<TrackerClient, TrackerClientState> _trackerClientStateMap = new HashMap<>();\n+\n+  PartitionStateDataBuilder(RingFactory<URI> ringFactory)\n+  {\n+    _ringFactory = ringFactory;\n+    _clusterGenerationId = 0;\n+  }\n+\n+  PartitionStateDataBuilder setClusterGenerationId(long clusterGenerationId)\n+  {\n+    _clusterGenerationId = clusterGenerationId;\n+    return this;\n+  }\n+\n+  PartitionStateDataBuilder setTrackerClientStateMap(List<TrackerClient> trackerClients,\n+      List<Double> healthScores, List<TrackerClientState.HealthState> healthStates, List<Integer> callCountList,\n+      double initialHealthScore, int minCallCount)\n+  {\n+    if (trackerClients.size() != healthScores.size() || trackerClients.size() != healthStates.size() || trackerClients.size() != callCountList.size())\n+    {\n+      throw new IllegalArgumentException(\"The size of the tracker client and health scores have to match!\");\n+    }\n+    for (int index = 0; index < trackerClients.size(); index ++)\n+    {\n+      TrackerClientState trackerClientState = new TrackerClientState(initialHealthScore, minCallCount);\n+      trackerClientState.setHealthScore(healthScores.get(index));\n+      trackerClientState.setHealthState(healthStates.get(index));\n+      trackerClientState.setCallCount(callCountList.get(index));\n+      _trackerClientStateMap.put(trackerClients.get(index), trackerClientState);", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczODYwMA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445738600", "bodyText": "Need more clarification from you, not sure this is about this test method or TrackerClientState method.", "author": "rachelhanhan", "createdAt": "2020-06-25T17:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyNjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyNjQ4NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444526485", "bodyText": "Use SettableClock", "author": "zhang-chris", "createdAt": "2020-06-23T21:44:49Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyOTUxMw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r444529513", "bodyText": "2020", "author": "zhang-chris", "createdAt": "2020-06-23T21:51:26Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0MTgzNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445741837", "bodyText": "Good to know that we use the current year in copyright for new files", "author": "rachelhanhan", "createdAt": "2020-06-25T18:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUyOTUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MjM3NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445142375", "bodyText": "why mocking 2 in these tests?", "author": "zhang-chris", "createdAt": "2020-06-24T20:08:33Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc0NjUwMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445746501", "bodyText": "Are you asking why we only mock 2 tracker clients? To test the quarantine feature, 2 clients is enough: if we set quarantine max percentage to 50%, then we expect 1 host to be quarantined. Do you think 2 is too small?", "author": "rachelhanhan", "createdAt": "2020-06-25T18:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MjM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MzcyMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445143721", "bodyText": "put in assert message instead of comment here and everywhere else", "author": "zhang-chris", "createdAt": "2020-06-24T20:11:18Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc1MjUwNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445752507", "bodyText": "I think comment is for the developers to understand what we are verifying here, the assert error message is to tell why it is an error when the assert fails. I do not expect error log to give too much explanation on the purpose of the test case. For here, the error message would probably say \"we should only quarantine 2 hosts\"", "author": "rachelhanhan", "createdAt": "2020-06-25T18:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MzcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NTk5NA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445145994", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-06-24T20:15:55Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientMockHelper.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.stats.LongStats;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.CallTrackerImpl;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+\n+import static org.mockito.Matchers.anyInt;\n+\n+\n+/**\n+ * The helper class that builds quick mock of {@link TrackerClient}\n+ */\n+public class TrackerClientMockHelper {\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients) throws URISyntaxException {\n+    List<TrackerClient> trackerClients = new ArrayList<>();\n+    for (int index = 0; index < numTrackerClients; index ++)\n+    {\n+      URI uri = new URI(\"URI/\" + index);\n+      TrackerClient trackerClient = Mockito.mock(TrackerClient.class);\n+      Mockito.when(trackerClient.getCallTracker()).thenReturn(new CallTrackerImpl(RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS));\n+      Mockito.when(trackerClient.getUri()).thenReturn(uri);\n+      Mockito.when(trackerClient.getPartitionWeight(anyInt())).thenReturn(1.0);\n+      trackerClients.add(trackerClient);\n+    }\n+    return trackerClients;\n+  }\n+\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients, List<Integer> callCountList,", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NjA1OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445146059", "bodyText": "indentation", "author": "zhang-chris", "createdAt": "2020-06-24T20:16:03Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/TrackerClientMockHelper.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.common.stats.LongStats;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.util.degrader.CallTracker;\n+import com.linkedin.util.degrader.CallTrackerImpl;\n+import com.linkedin.util.degrader.ErrorType;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.mockito.Mockito;\n+\n+import static org.mockito.Matchers.anyInt;\n+\n+\n+/**\n+ * The helper class that builds quick mock of {@link TrackerClient}\n+ */\n+public class TrackerClientMockHelper {\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients) throws URISyntaxException {\n+    List<TrackerClient> trackerClients = new ArrayList<>();\n+    for (int index = 0; index < numTrackerClients; index ++)\n+    {\n+      URI uri = new URI(\"URI/\" + index);\n+      TrackerClient trackerClient = Mockito.mock(TrackerClient.class);\n+      Mockito.when(trackerClient.getCallTracker()).thenReturn(new CallTrackerImpl(RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS));\n+      Mockito.when(trackerClient.getUri()).thenReturn(uri);\n+      Mockito.when(trackerClient.getPartitionWeight(anyInt())).thenReturn(1.0);\n+      trackerClients.add(trackerClient);\n+    }\n+    return trackerClients;\n+  }\n+\n+  public static List<TrackerClient> mockTrackerClients(int numTrackerClients, List<Integer> callCountList,\n+      List<Integer> outstandingCallCountList, List<Long> latencyList, List<Long> outstandingLatencyList,\n+      List<Integer> errorCountList) throws URISyntaxException {\n+    List<TrackerClient> trackerClients = new ArrayList<>();\n+    for (int index = 0; index < numTrackerClients; index ++)\n+    {\n+      URI uri = new URI(\"URI/\" + index);\n+      TrackerClient trackerClient = Mockito.mock(TrackerClient.class);\n+      CallTracker callTracker = Mockito.mock(CallTracker.class);\n+      LongStats longStats = new LongStats(callCountList.get(index), latencyList.get(index), 0, 0, 0, 0, 0, 0, 0);\n+      Map<ErrorType, Integer> errorTypeCounts = new HashMap<>();\n+      errorTypeCounts.put(ErrorType.SERVER_ERROR, errorCountList.get(index));\n+\n+      CallTrackerImpl.CallTrackerStats callStats = new CallTrackerImpl.CallTrackerStats(RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+      0,", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODA1Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445148052", "bodyText": "kind of hard to read these blocks. maybe organize them in individual lines? and use [] instead of Arrays.asList?", "author": "zhang-chris", "createdAt": "2020-06-24T20:19:58Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2\n+    assertEquals(state.getQuarantineMap().size(), 2);\n+  }\n+\n+  @Test(dataProvider = \"quarantineCheckResult\")\n+  public void testQuarantineCheck(boolean quarantineCheckResult) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    LoadBalancerQuarantine quarantine = Mockito.mock(LoadBalancerQuarantine.class);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Map<TrackerClient, LoadBalancerQuarantine> existingQuarantineMap = new HashMap<>();\n+    existingQuarantineMap.put(trackerClients.get(0), quarantine);\n+    Mockito.when(quarantine.checkUpdateQuarantineState()).thenReturn(quarantineCheckResult);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.NEUTRAL, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMDQ2OQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r446810469", "bodyText": "I realized that if I change to array, I still have to do something like\nsetTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\nnew double[] {StateUpdater.MIN_HEALTH_SCORE, 0.6},\nI cannot directly put {A, B, C}. https://stackoverflow.com/questions/41658497/array-initializer-is-not-allowed-here", "author": "rachelhanhan", "createdAt": "2020-06-29T06:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0ODM3Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445148377", "bodyText": "reference constant", "author": "zhang-chris", "createdAt": "2020-06-24T20:20:35Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2\n+    assertEquals(state.getQuarantineMap().size(), 2);\n+  }\n+\n+  @Test(dataProvider = \"quarantineCheckResult\")\n+  public void testQuarantineCheck(boolean quarantineCheckResult) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    LoadBalancerQuarantine quarantine = Mockito.mock(LoadBalancerQuarantine.class);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Map<TrackerClient, LoadBalancerQuarantine> existingQuarantineMap = new HashMap<>();\n+    existingQuarantineMap.put(trackerClients.get(0), quarantine);\n+    Mockito.when(quarantine.checkUpdateQuarantineState()).thenReturn(quarantineCheckResult);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.NEUTRAL, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .setQuarantineMap(existingQuarantineMap)\n+        .build();\n+\n+    _quarantineManager.tryEnableQuarantine();\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (quarantineCheckResult)\n+    {\n+      // If quarantine check passed, verify the tracker client is put into recovery map, and the initial recovery rate is 0.01\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertEquals(state.getRecoveryTrackerClients().size(), 1);\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), 0.01);", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0OTY3Mg==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445149672", "bodyText": "could probably just use 1 dataprovider named \"truefalse\" or \"enable\"", "author": "zhang-chris", "createdAt": "2020-06-24T20:23:05Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/QuarantineManagerTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2QuarantineProperties;\n+import com.linkedin.d2.HttpMethod;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import com.linkedin.d2.balancer.strategies.degrader.LoadBalancerQuarantine;\n+import com.linkedin.d2.balancer.strategies.degrader.RingFactory;\n+import com.linkedin.d2.balancer.util.healthcheck.HealthCheckOperations;\n+import com.linkedin.util.clock.Clock;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class QuarantineManagerTest {\n+  private static final String SERVICE_NAME = \"dummyService\";\n+  private static final String SERVICE_PATH = \"dummyServicePath\";\n+  private static final HealthCheckOperations HEALTH_CHECK_OPERATIONS = new HealthCheckOperations();\n+  private static final long DEFAULT_AVG_CLUSTER_LATENCY = 100;\n+  private static final RingFactory<URI> RING_FACTORY = new DistributionNonDiscreteRingFactory<>();\n+  private static final Clock CLOCK = Mockito.mock(Clock.class);\n+\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+  private QuarantineManager _quarantineManager;\n+\n+  private void setup(double quarantineMaxPercent, boolean slowStartEnabled, boolean fastRecoveryEnabled)\n+  {\n+    double slowStartThreshold = slowStartEnabled ? 0.5 : 0;\n+    D2QuarantineProperties d2QuarantineProperties = new D2QuarantineProperties().setQuarantineMaxPercent(quarantineMaxPercent)\n+        .setHealthCheckMethod(HttpMethod.OPTIONS);\n+    _quarantineManager = new QuarantineManager(SERVICE_NAME, SERVICE_PATH, HEALTH_CHECK_OPERATIONS, d2QuarantineProperties,\n+        slowStartThreshold, fastRecoveryEnabled, _executorService, CLOCK,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_UPDATE_INTERVAL_MS,\n+        RelativeLoadBalancerStrategyFactory.DEFAULT_RELATIVE_LATENCY_LOW_THRESHOLD_FACTOR);\n+  }\n+\n+  @Test\n+  public void testQuarantineNotEnabledInConfig() throws URISyntaxException\n+  {\n+    setup(RelativeLoadBalancerStrategyFactory.DEFAULT_QUARANTINE_MAX_PERCENT, false, false);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(TrackerClientMockHelper.mockTrackerClients(2),\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is not enabled\n+    Mockito.verifyZeroInteractions(_executorService);\n+    assertTrue(state.getQuarantineMap().isEmpty());\n+  }\n+\n+  @Test(dataProvider = \"unhealthyHealthScore\")\n+  public void testQuarantineHost(double unhealthyHealthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(unhealthyHealthScore, StateUpdater.MAX_HEALTH_SCORE),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (unhealthyHealthScore == StateUpdater.MIN_HEALTH_SCORE)\n+    {\n+      // Verify quarantine is enabled and one client is quarantined\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+    else\n+    {\n+      // Verify quarantine map is empty\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+\n+  }\n+\n+  @DataProvider(name = \"unhealthyHealthScore\")\n+  Object[][] getUnhealthyHealthScore()\n+  {\n+    return new Object[][]\n+        {\n+            {StateUpdater.MIN_HEALTH_SCORE},\n+            {0.6},\n+            {0.8}\n+        };\n+  }\n+\n+  @Test\n+  public void testQuarantinedMaxPercentage() throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(4);\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients,\n+            Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, StateUpdater.MIN_HEALTH_SCORE, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    // Verify quarantine is enabled and 2 clients are quarantined.\n+    // In theory, there are 3 candidates, but because of the max percentage is 50%, we only quarantine 2\n+    assertEquals(state.getQuarantineMap().size(), 2);\n+  }\n+\n+  @Test(dataProvider = \"quarantineCheckResult\")\n+  public void testQuarantineCheck(boolean quarantineCheckResult) throws URISyntaxException\n+  {\n+    setup(0.5, false, false);\n+    LoadBalancerQuarantine quarantine = Mockito.mock(LoadBalancerQuarantine.class);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Map<TrackerClient, LoadBalancerQuarantine> existingQuarantineMap = new HashMap<>();\n+    existingQuarantineMap.put(trackerClients.get(0), quarantine);\n+    Mockito.when(quarantine.checkUpdateQuarantineState()).thenReturn(quarantineCheckResult);\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(StateUpdater.MIN_HEALTH_SCORE, 0.6, 0.6),\n+            Arrays.asList(TrackerClientState.HealthState.NEUTRAL, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .setQuarantineMap(existingQuarantineMap)\n+        .build();\n+\n+    _quarantineManager.tryEnableQuarantine();\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (quarantineCheckResult)\n+    {\n+      // If quarantine check passed, verify the tracker client is put into recovery map, and the initial recovery rate is 0.01\n+      assertTrue(state.getQuarantineMap().isEmpty());\n+      assertEquals(state.getRecoveryTrackerClients().size(), 1);\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), 0.01);\n+    } else\n+    {\n+      // Otherwise, the client stays in the quarantine map\n+      assertEquals(state.getQuarantineMap().size(), 1);\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+      assertTrue(state.getQuarantineMap().containsKey(trackerClients.get(0)));\n+    }\n+  }\n+\n+  @DataProvider(name = \"quarantineCheckResult\")\n+  Object[][] getQuarantineCheckResult()\n+  {\n+    return new Object[][]\n+        {\n+            {true},\n+            {false}\n+        };\n+  }\n+\n+  @Test(dataProvider = \"trackerClientState\")\n+  public void testFastRecoveryInRecoveryMap(int callCount, TrackerClientState.HealthState healthState, double healthScore) throws URISyntaxException\n+  {\n+    setup(0.5, false, true);\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3);\n+    Set<TrackerClient> recoverySet = new HashSet<>();\n+    recoverySet.add(trackerClients.get(0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(healthScore, 0.6, 0.6),\n+            Arrays.asList(healthState, TrackerClientState.HealthState.UNHEALTHY,\n+                TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(callCount, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .setRecoveryClients(recoverySet)\n+        .build();\n+\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    _quarantineManager.updateQuarantineState(state, state, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (callCount <= RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+    {\n+      // Verify the health score doubled\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), healthScore * 2);\n+      assertTrue(state.getRecoveryTrackerClients().contains(trackerClients.get(0)));\n+    } else if (healthState != TrackerClientState.HealthState.UNHEALTHY && healthScore <= QuarantineManager.FAST_RECOVERY_HEALTH_SCORE_THRESHOLD)\n+    {\n+      // Verify the health score keeps the same, and the client is still in recovery map\n+      assertEquals(state.getTrackerClientStateMap().get(trackerClients.get(0)).getHealthScore(), healthScore);\n+      assertTrue(state.getRecoveryTrackerClients().contains(trackerClients.get(0)));\n+    } else\n+    {\n+      // Verify the client comes out of recovery map\n+      assertTrue(state.getRecoveryTrackerClients().isEmpty());\n+    }\n+  }\n+\n+  @DataProvider(name = \"trackerClientState\")\n+  Object[][] getTrackerClientStates()\n+  {\n+    return new Object[][]\n+        {\n+            {0, TrackerClientState.HealthState.NEUTRAL, 0.01},\n+            {15, TrackerClientState.HealthState.UNHEALTHY, 0.01},\n+            {15, TrackerClientState.HealthState.UNHEALTHY, 0.6},\n+            {15, TrackerClientState.HealthState.HEALTHY, 0.01}\n+        };\n+  }\n+\n+  @Test(dataProvider = \"enableFastRecovery\")\n+  public void testEnrollNewClientInRecoveryMap(boolean fastRecoveryEnabled) throws URISyntaxException\n+  {\n+    setup(0.5, true, fastRecoveryEnabled);\n+    _quarantineManager.tryEnableQuarantine();\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2);\n+    PartitionState oldState = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(Collections.emptyList(), Collections.emptyList(), Collections.emptyList(),\n+            Collections.emptyList(), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+    PartitionState newState = new PartitionStateDataBuilder(RING_FACTORY)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(0.01, 0.01),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.UNHEALTHY),\n+            Arrays.asList(20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT).build();\n+\n+    _quarantineManager.updateQuarantineState(newState, oldState, DEFAULT_AVG_CLUSTER_LATENCY);\n+\n+    if (fastRecoveryEnabled)\n+    {\n+      assertEquals(newState.getRecoveryTrackerClients().size(), 2);\n+    } else\n+    {\n+      assertTrue(newState.getRecoveryTrackerClients().isEmpty());\n+    }\n+  }\n+\n+  @DataProvider(name = \"enableFastRecovery\")", "originalCommit": "45bb2989b15e0032c732be703262ca777b97568b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDMwMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445160301", "bodyText": "is this line necessary? it's a void method anyway.", "author": "zhang-chris", "createdAt": "2020-06-24T20:43:37Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());", "originalCommit": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgyNTQ0Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445825443", "bodyText": "Will remove this.", "author": "rachelhanhan", "createdAt": "2020-06-25T20:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MTkyMQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445161921", "bodyText": "test concurrency too", "author": "zhang-chris", "createdAt": "2020-06-24T20:46:43Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()", "originalCommit": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4NDczOQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445984739", "bodyText": "I just tried to add a unit test for multiple threads initializing a partition at the same time, I found it's hard to explicitly verify the lock is only obtained once.", "author": "rachelhanhan", "createdAt": "2020-06-26T06:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5NDYxNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r448194617", "bodyText": "Please take a look into the test I added and see if it works.", "author": "rachelhanhan", "createdAt": "2020-07-01T08:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzU2Ng==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445163566", "bodyText": "is factory passed in ever not a \"new DistributionNonDiscreteRingFactory\"? can we just hide that in the Builder?", "author": "zhang-chris", "createdAt": "2020-06-24T20:49:54Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())", "originalCommit": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NTI5MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445165290", "bodyText": "better if we verify that w ecreated a new partition state than that executor was called.", "author": "zhang-chris", "createdAt": "2020-06-24T20:53:10Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));", "originalCommit": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0ODYyNA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445948624", "bodyText": "OK will change this to wait for the execution", "author": "rachelhanhan", "createdAt": "2020-06-26T03:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NTI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzEzNw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445167137", "bodyText": "instead of 80 can we do heathypoints - downStep?", "author": "zhang-chris", "createdAt": "2020-06-24T20:56:43Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0), Arrays.asList(TrackerClientState.HealthState.HEALTHY,\n+            TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify one host's health score dropped to 80\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), 80);", "originalCommit": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0OTg4NQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445949885", "bodyText": "Are you trying to get rid of using the numbers directly in unit tests? For some integration test we are going to add, we will run multiple iterations, and I just use a number to match the final health score. My point is that each test may have different scenarios and we using the calculation formula may not be straightforward sometimes. I don't see a big problem directly using numbers.", "author": "rachelhanhan", "createdAt": "2020-06-26T03:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5Mzc3MA==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r448193770", "bodyText": "I changed to use variable reference whenever I can.", "author": "rachelhanhan", "createdAt": "2020-07-01T08:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Nzk5Mw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445167993", "bodyText": "what is small call count", "author": "zhang-chris", "createdAt": "2020-06-24T20:58:29Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0), Arrays.asList(TrackerClientState.HealthState.HEALTHY,\n+            TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify one host's health score dropped to 80\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), 80);\n+  }\n+\n+  @Test\n+  public void testUpdateMultiplePartitions()\n+  {\n+    /**\n+     * There are 2 partitions, and 4 tracker clients in total.\n+     * Partition 0 contains tracker client 1,2,3\n+     * Partition 1 contains tracker client 3,4\n+     * TrackerClient 3 will be unhealthy in partition 0, but not in partition 1\n+     */\n+    List<TrackerClient> trackerClients1 = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+    List<TrackerClient> trackerClients2 = TrackerClientMockHelper.mockTrackerClients(1,\n+        Arrays.asList(20), Arrays.asList(10), Arrays.asList(1000L),\n+        Arrays.asList(600L), Arrays.asList(0));\n+    trackerClients2.add(trackerClients1.get(2));\n+\n+    PartitionState state1 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients1, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+    PartitionState state2 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients2, Arrays.asList(1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(0, state1);\n+    partitionLoadBalancerStateMap.put(1, state2);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    URI overlapUri = trackerClients1.get(2).getUri();\n+\n+    // Verify the host has 80 points in partition 0, 100 points in partition 1\n+    assertEquals(partitionLoadBalancerStateMap.get(0).getPointsMap().get(overlapUri).intValue(), 80);\n+    assertEquals(partitionLoadBalancerStateMap.get(1).getPointsMap().get(overlapUri).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterUrisChange()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 220L, 1000L),\n+        Arrays.asList(100L, 110L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    // New tracker clients set only contains 2 out of 3 tracker clients from the old state\n+    Set<TrackerClient> newTrackerClientSet = new HashSet<>();\n+    newTrackerClientSet.add(trackerClients.get(0));\n+    newTrackerClientSet.add(trackerClients.get(1));\n+    _stateUpdater.updateStateForPartition(newTrackerClientSet, DEFAULT_PARTITION_ID, state, 1L);\n+\n+    // Verify there are only 2 URIs in the points map\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    assertEquals(pointsMap.size(), 2);\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test(dataProvider = \"trackerClients\")\n+  public void testHealthScoreDropByLatency(List<TrackerClient> trackerClients, double highLatencyFactor,\n+      double highErrorRate, boolean expectToDropHealthScore)\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties()\n+            .setRelativeLatencyHighThresholdFactor(highLatencyFactor).setHighErrorRate(highErrorRate),\n+        partitionLoadBalancerStateMap);\n+    _stateUpdater.updateState();\n+\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    if (!expectToDropHealthScore)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else\n+    {\n+      // Experiment 1 dropped because of latency, experiment 2 dropped because of outstanding latency\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 80);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    }\n+  }\n+\n+  @DataProvider(name = \"trackerClients\")\n+  Object[][] getTrackerClients()\n+  {\n+    List<Long> defaultLatencyList = Arrays.asList(100L, 100L, 100L);\n+    List<Long> defaultOutstandingLatencyList = Arrays.asList(20L, 20L, 20L);\n+    List<Integer> defaultCallCountList = Arrays.asList(20, 20, 20);\n+    List<Integer> defaultOutstandingCountList = Arrays.asList(10, 10, 10);\n+    List<Integer> defaultErrorCountList = Arrays.asList(0, 0, 0);\n+    double defaultHighLatencyFactor = 1.2;\n+    double defaultHighErrorRate = 0.2;\n+    int numTrackerClients = 3;\n+    return new Object[][]\n+        {\n+            // Test with different latency and outstanding latencies\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(200L, 220L, 200L), Arrays.asList(100L, 110L, 100L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 120L, 115L), Arrays.asList(20L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(100L, 120L, 115L), Arrays.asList(1000L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 500L, 600L), Arrays.asList(900L, 700L, 800L), defaultErrorCountList), 1.5, defaultHighErrorRate, false},\n+\n+            // Test with different error count and error rates\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, 0.09, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, 0.3, false}\n+        };\n+  }\n+\n+  @Test\n+  public void testSmallCallCount()", "originalCommit": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk0OTk2Nw==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445949967", "bodyText": "I can rename it to testCallCountBelowMinCallCount", "author": "rachelhanhan", "createdAt": "2020-06-26T03:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Nzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTE1MQ==", "url": "https://github.com/linkedin/rest.li/pull/310#discussion_r445169151", "bodyText": "add test that verifies the executor is scheduled to run updateState periodically.", "author": "zhang-chris", "createdAt": "2020-06-24T21:00:42Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/strategies/relative/StateUpdaterTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.strategies.relative;\n+\n+import com.linkedin.d2.D2RelativeStrategyProperties;\n+import com.linkedin.d2.balancer.clients.TrackerClient;\n+import com.linkedin.d2.balancer.strategies.degrader.DistributionNonDiscreteRingFactory;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import org.mockito.Mockito;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyLong;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+\n+public class StateUpdaterTest\n+{\n+  private static final int DEFAULT_PARTITION_ID = 0;\n+  private static final long DEFAULT_CLUSTER_GENERATION_ID = 0;\n+  private static final int HEALTHY_POINTS = 100;\n+  private StateUpdater _stateUpdater;\n+  private final ScheduledExecutorService _executorService = Mockito.mock(ScheduledExecutorService.class);\n+\n+  private void setup(D2RelativeStrategyProperties relativeStrategyProperties,\n+      ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap)\n+  {\n+    final QuarantineManager quarantineManager = Mockito.mock(QuarantineManager.class);\n+\n+    RelativeLoadBalancerStrategyFactory.putDefaultValues(relativeStrategyProperties);\n+    Mockito.doNothing().when(quarantineManager).updateQuarantineState(any(PartitionState.class), any(PartitionState.class),\n+        anyLong());\n+\n+    _stateUpdater = new StateUpdater(relativeStrategyProperties, quarantineManager, _executorService,\n+        partitionLoadBalancerStateMap, Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void testInitializePartition()\n+  {\n+    setup(new D2RelativeStrategyProperties(), new ConcurrentHashMap<>());\n+\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    // Verify before initialization the partition does not exist\n+    assertTrue(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).isEmpty());\n+\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, DEFAULT_CLUSTER_GENERATION_ID);\n+\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(_stateUpdater.getPointsMap(DEFAULT_PARTITION_ID).get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterGenerationIdChange()\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .build();\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(2,\n+        Arrays.asList(20, 20), Arrays.asList(10, 10), Arrays.asList(200L, 500L), Arrays.asList(100L, 200L), Arrays.asList(0, 0));\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+    // Cluster generation id changed from 0 to 1\n+    _stateUpdater.updateState(new HashSet<>(trackerClients), DEFAULT_PARTITION_ID, 1);\n+\n+    Mockito.verify(_executorService).execute(any(Runnable.class));\n+  }\n+\n+  @Test\n+  public void testUpdateOnePartition()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0), Arrays.asList(TrackerClientState.HealthState.HEALTHY,\n+            TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify one host's health score dropped to 80\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), 80);\n+  }\n+\n+  @Test\n+  public void testUpdateMultiplePartitions()\n+  {\n+    /**\n+     * There are 2 partitions, and 4 tracker clients in total.\n+     * Partition 0 contains tracker client 1,2,3\n+     * Partition 1 contains tracker client 3,4\n+     * TrackerClient 3 will be unhealthy in partition 0, but not in partition 1\n+     */\n+    List<TrackerClient> trackerClients1 = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 300L, 1000L),\n+        Arrays.asList(100L, 200L, 500L), Arrays.asList(0, 0, 0));\n+    List<TrackerClient> trackerClients2 = TrackerClientMockHelper.mockTrackerClients(1,\n+        Arrays.asList(20), Arrays.asList(10), Arrays.asList(1000L),\n+        Arrays.asList(600L), Arrays.asList(0));\n+    trackerClients2.add(trackerClients1.get(2));\n+\n+    PartitionState state1 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients1, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+    PartitionState state2 = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients2, Arrays.asList(1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(0, state1);\n+    partitionLoadBalancerStateMap.put(1, state2);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    URI overlapUri = trackerClients1.get(2).getUri();\n+\n+    // Verify the host has 80 points in partition 0, 100 points in partition 1\n+    assertEquals(partitionLoadBalancerStateMap.get(0).getPointsMap().get(overlapUri).intValue(), 80);\n+    assertEquals(partitionLoadBalancerStateMap.get(1).getPointsMap().get(overlapUri).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test\n+  public void testClusterUrisChange()\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(10, 10, 10), Arrays.asList(200L, 220L, 1000L),\n+        Arrays.asList(100L, 110L, 500L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties(), partitionLoadBalancerStateMap);\n+\n+    // New tracker clients set only contains 2 out of 3 tracker clients from the old state\n+    Set<TrackerClient> newTrackerClientSet = new HashSet<>();\n+    newTrackerClientSet.add(trackerClients.get(0));\n+    newTrackerClientSet.add(trackerClients.get(1));\n+    _stateUpdater.updateStateForPartition(newTrackerClientSet, DEFAULT_PARTITION_ID, state, 1L);\n+\n+    // Verify there are only 2 URIs in the points map\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    assertEquals(pointsMap.size(), 2);\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test(dataProvider = \"trackerClients\")\n+  public void testHealthScoreDropByLatency(List<TrackerClient> trackerClients, double highLatencyFactor,\n+      double highErrorRate, boolean expectToDropHealthScore)\n+  {\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(30, 30, 30), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties()\n+            .setRelativeLatencyHighThresholdFactor(highLatencyFactor).setHighErrorRate(highErrorRate),\n+        partitionLoadBalancerStateMap);\n+    _stateUpdater.updateState();\n+\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+    if (!expectToDropHealthScore)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else\n+    {\n+      // Experiment 1 dropped because of latency, experiment 2 dropped because of outstanding latency\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 80);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    }\n+  }\n+\n+  @DataProvider(name = \"trackerClients\")\n+  Object[][] getTrackerClients()\n+  {\n+    List<Long> defaultLatencyList = Arrays.asList(100L, 100L, 100L);\n+    List<Long> defaultOutstandingLatencyList = Arrays.asList(20L, 20L, 20L);\n+    List<Integer> defaultCallCountList = Arrays.asList(20, 20, 20);\n+    List<Integer> defaultOutstandingCountList = Arrays.asList(10, 10, 10);\n+    List<Integer> defaultErrorCountList = Arrays.asList(0, 0, 0);\n+    double defaultHighLatencyFactor = 1.2;\n+    double defaultHighErrorRate = 0.2;\n+    int numTrackerClients = 3;\n+    return new Object[][]\n+        {\n+            // Test with different latency and outstanding latencies\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(200L, 220L, 200L), Arrays.asList(100L, 110L, 100L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 120L, 115L), Arrays.asList(20L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(100L, 120L, 115L), Arrays.asList(1000L, 10L, 15L), defaultErrorCountList), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,defaultCallCountList, defaultOutstandingCountList,\n+                Arrays.asList(1000L, 500L, 600L), Arrays.asList(900L, 700L, 800L), defaultErrorCountList), 1.5, defaultHighErrorRate, false},\n+\n+            // Test with different error count and error rates\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, false},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(10, 10, 15)), defaultHighLatencyFactor, 0.09, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, defaultHighErrorRate, true},\n+            {TrackerClientMockHelper.mockTrackerClients(numTrackerClients,Arrays.asList(100, 200, 200), Arrays.asList(0, 0, 0),\n+                defaultLatencyList, defaultOutstandingLatencyList, Arrays.asList(21, 10, 15)), defaultHighLatencyFactor, 0.3, false}\n+        };\n+  }\n+\n+  @Test\n+  public void testSmallCallCount()\n+  {\n+    int minCallCount = 10;\n+    // One client has high latency but small call count\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(5, 20, 20), Arrays.asList(0, 0, 0), Arrays.asList(1000L, 300L, 300L),\n+        Arrays.asList(100L, 200L, 200L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(1.0, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(5, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE, minCallCount)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties().setMinCallCount(minCallCount),\n+        partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    // Verify the host with high latency still has 100 points\n+    assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+    assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+  }\n+\n+  @Test(dataProvider = \"slowStartThreshold\")\n+  public void testHealthScoreRecover(double currentHealthScore, double slowStartThreshold)\n+  {\n+    List<TrackerClient> trackerClients = TrackerClientMockHelper.mockTrackerClients(3,\n+        Arrays.asList(20, 20, 20), Arrays.asList(0, 0, 0), Arrays.asList(300L, 300L, 300L),\n+        Arrays.asList(200L, 200L, 200L), Arrays.asList(0, 0, 0));\n+\n+    PartitionState state = new PartitionStateDataBuilder(new DistributionNonDiscreteRingFactory<>())\n+        .setClusterGenerationId(DEFAULT_CLUSTER_GENERATION_ID)\n+        .setTrackerClientStateMap(trackerClients, Arrays.asList(currentHealthScore, 1.0, 1.0),\n+            Arrays.asList(TrackerClientState.HealthState.UNHEALTHY, TrackerClientState.HealthState.HEALTHY, TrackerClientState.HealthState.HEALTHY),\n+            Arrays.asList(20, 20, 20), RelativeLoadBalancerStrategyFactory.DEFAULT_INITIAL_HEALTH_SCORE,\n+            RelativeLoadBalancerStrategyFactory.DEFAULT_MIN_CALL_COUNT)\n+        .build();\n+\n+    ConcurrentMap<Integer, PartitionState> partitionLoadBalancerStateMap = new ConcurrentHashMap<>();\n+    partitionLoadBalancerStateMap.put(DEFAULT_PARTITION_ID, state);\n+    setup(new D2RelativeStrategyProperties().setSlowStartThreshold(slowStartThreshold),\n+        partitionLoadBalancerStateMap);\n+\n+    _stateUpdater.updateState();\n+    Map<URI, Integer> pointsMap = _stateUpdater.getPointsMap(DEFAULT_PARTITION_ID);\n+\n+    if (slowStartThreshold == RelativeLoadBalancerStrategyFactory.DEFAULT_SLOW_START_THRESHOLD)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 5);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else if (currentHealthScore == 0.0)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 1);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else if (currentHealthScore == 0.1)\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 20);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    } else\n+    {\n+      assertEquals(pointsMap.get(trackerClients.get(0).getUri()).intValue(), 30);\n+      assertEquals(pointsMap.get(trackerClients.get(1).getUri()).intValue(), HEALTHY_POINTS);\n+      assertEquals(pointsMap.get(trackerClients.get(2).getUri()).intValue(), HEALTHY_POINTS);\n+    }\n+  }\n+\n+  @DataProvider(name = \"slowStartThreshold\")\n+  Object[][] getSlowStartThreshold()\n+  {\n+    return new Object[][]\n+        {\n+            {0.0, 0.0},\n+            {0.0, 0.2},\n+            {0.1, 0.2},\n+            {0.25, 0.2}\n+        };\n+  }\n+}", "originalCommit": "485f8e81c90adbcfc6b9249a379f7814f3f99fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "675cd6c14188f699b77b40985463e50fd9db4bb1", "url": "https://github.com/linkedin/rest.li/commit/675cd6c14188f699b77b40985463e50fd9db4bb1", "message": "Fixed unit tests", "committedDate": "2020-07-01T08:04:53Z", "type": "commit"}, {"oid": "1d415acb6667e27eab4f0096fb1b5919667c57b9", "url": "https://github.com/linkedin/rest.li/commit/1d415acb6667e27eab4f0096fb1b5919667c57b9", "message": "Error message update in unit test", "committedDate": "2020-07-01T08:16:33Z", "type": "commit"}]}