{"pr_number": 183, "pr_title": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "pr_createdAt": "2020-02-21T08:14:52Z", "pr_url": "https://github.com/linkedin/rest.li/pull/183", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NTk3Nw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382485977", "bodyText": "Technically, this isn't true. Inline types are not necessarily referenced by simple name (e.g. referencing an inline type with an overridden namespace). The point is that they can't be imported.\nTo be completely accurate, this set is just \"a set of simple type names which shouldn't be imported in this document\", because (1) importing types with the same simple name as an inline type is prohibited and will cause a parser error, and (2) being able to reference something in the current namespace by simple name is prioritized (thus anytime an intra-namespace reference is present, that simple name should be off-limits for importing).", "author": "evanw555", "createdAt": "2020-02-21T09:44:00Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -733,13 +734,17 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   private Map<String, Name> computeImports(DataSchema schema, String rootNamespace)\n   {\n     Set<Name> encounteredTypes = new HashSet<>();\n-    Set<String> inlinedTypeNames = new HashSet<>();\n-    gatherTypes(schema, true, encounteredTypes, inlinedTypeNames);\n+    // Collects the set of simple names of types that can use simple reference because\n+    // 1. They are defined inline or", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MjUxOQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382682519", "bodyText": "My comment was describing the same, made it clear now..", "author": "karthikbalasub", "createdAt": "2020-02-21T16:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NzA1Mw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382487053", "bodyText": "As my other comment mentions above, I'd rephrase this as \"add to the set of non-importable simple names\" (or something along those lines).", "author": "evanw555", "createdAt": "2020-02-21T09:46:06Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -749,25 +754,29 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   }\n \n   /**\n-   * Gather all types (both referenced and inlined) found in this schema and in all its descendents.\n+   * Gather all types (both referenced and inlined) and names of types that should use simple reference from this schema\n+   * and in all its descendents.\n    * @param schema schema to traverse.\n    * @param isDeclaredInline true if the schema should be treated as an inline declaration, false if it should be\n    *                         considered a by-name reference.\n    * @param encounteredTypes cumulative set of all encountered types in this schema (and its descendents).\n-   * @param inlinedTypeNames cumulative set of simple names of all inlined types in this schema (and its descendents).\n+   * @param typeNamesWithSimpleReference cumulative set of simple names of all types in this schema (and its\n+   *                                    descendents) that can use simple reference.\n+   * @param currentNamespace namespace of the current scope.\n    */\n   private void gatherTypes(DataSchema schema, boolean isDeclaredInline, Set<Name> encounteredTypes,\n-      Set<String> inlinedTypeNames)\n+      Set<String> typeNamesWithSimpleReference, String currentNamespace)\n   {\n     // If named type, add to the set of encountered types\n     if (schema instanceof NamedDataSchema)\n     {\n       NamedDataSchema namedSchema = (NamedDataSchema) schema;\n       encounteredTypes.add(new Name(namedSchema.getFullName()));\n-      // If declared inline, add to the set of inlined types\n-      if (isDeclaredInline)\n+      // If declared inline or of the namespace matches the current namespace, add to the set of types with simple\n+      // reference.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5MTAxMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382691013", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NzA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTIwMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382489203", "bodyText": "nit: identifier -> simple name", "author": "evanw555", "createdAt": "2020-02-21T09:50:38Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace\n+    if (_importsByLocalName.containsKey(schema.getName()) &&\n+        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace()))\n     {\n+      // Write only identifier if there is an import matching the schema.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NTc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382685799", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTUyMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382489523", "bodyText": "nit: Write only simple name for schemas in the current namespace only if there are no corresponding imports", "author": "evanw555", "createdAt": "2020-02-21T09:51:13Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace\n+    if (_importsByLocalName.containsKey(schema.getName()) &&\n+        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace()))\n     {\n+      // Write only identifier if there is an import matching the schema.\n+      _builder.writeIdentifier(schema.getName());\n+    }\n+    else if (_namespace.equals(schema.getNamespace()) && !_importsByLocalName.containsKey(schema.getName()))\n+    {\n+      // Write only identifier for schemas in the current namespace only if there are no imports with the same simple", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NjYxMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382686613", "bodyText": "fixed.\ncorresponding imports -> conflicting imports", "author": "karthikbalasub", "createdAt": "2020-02-21T16:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MDEyOQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382490129", "bodyText": "The javadoc for this method is now incorrect. Tbh you can probably just remove the detail and say it writes simple name or FQN depending on the current namespace and present imports.", "author": "evanw555", "createdAt": "2020-02-21T09:52:29Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NzM3NA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382687374", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MDEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5NDM0MA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382494340", "bodyText": "I'd say Importing the type wouldn't force some intra-namespace reference to become fully-qualified.", "author": "evanw555", "createdAt": "2020-02-21T10:01:13Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -719,6 +719,7 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n    * (1) The type is outside the root namespace of the document.\n    * (2) The type is declared outside the document (i.e. not inlined in this document).\n    * (3) The type's name does not conflict with name of an Inlined type.\n+   * (4) The type's name does not conflict with another type that can use simple reference.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4OTA4Mw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382689083", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5NDM0MA=="}], "type": "inlineReview"}, {"oid": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "url": "https://github.com/linkedin/rest.li/commit/ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "message": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "committedDate": "2020-02-21T16:55:48Z", "type": "commit"}, {"oid": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "url": "https://github.com/linkedin/rest.li/commit/ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "message": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "committedDate": "2020-02-21T16:55:48Z", "type": "forcePushed"}, {"oid": "27869c9d66a4e6c93c0534b8e3c82d569ce91329", "url": "https://github.com/linkedin/rest.li/commit/27869c9d66a4e6c93c0534b8e3c82d569ce91329", "message": "Fix a typo", "committedDate": "2020-02-21T23:14:58Z", "type": "commit"}, {"oid": "3ee790ea6db314b7baf23801bbf05a590cb7615e", "url": "https://github.com/linkedin/rest.li/commit/3ee790ea6db314b7baf23801bbf05a590cb7615e", "message": "Rename record name in test.", "committedDate": "2020-02-21T23:53:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTgwNw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382875807", "bodyText": "You should also name this to nonImportableTypeNames to be consistent.", "author": "evanw555", "createdAt": "2020-02-22T01:57:41Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -733,13 +735,18 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   private Map<String, Name> computeImports(DataSchema schema, String rootNamespace)\n   {\n     Set<Name> encounteredTypes = new HashSet<>();\n-    Set<String> inlinedTypeNames = new HashSet<>();\n-    gatherTypes(schema, true, encounteredTypes, inlinedTypeNames);\n+    // Collects the set of simple names of types that can cause conflicts with imports because\n+    // 1. They are defined inline or\n+    // 2. They are in the same namespace as their surrounding context (including namespace overrides) and are\n+    //    preferred use simple reference\n+    Set<String> typeNamesWithSimpleReference = new HashSet<>();", "originalCommit": "3ee790ea6db314b7baf23801bbf05a590cb7615e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a03ea42606adc6d24b7b38cb23936595feccaec", "url": "https://github.com/linkedin/rest.li/commit/6a03ea42606adc6d24b7b38cb23936595feccaec", "message": "Address Evan's comments", "committedDate": "2020-02-22T02:15:31Z", "type": "commit"}]}