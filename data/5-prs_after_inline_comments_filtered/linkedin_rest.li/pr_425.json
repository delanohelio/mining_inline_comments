{"pr_number": 425, "pr_title": "Add checkPegasusSchemaSnapshotTask", "pr_createdAt": "2020-09-24T03:43:29Z", "pr_url": "https://github.com/linkedin/rest.li/pull/425", "timeline": [{"oid": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "url": "https://github.com/linkedin/rest.li/commit/849f5a16a92eb014628d6e9085f5293301e2a3aa", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-24T15:34:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494751719", "bodyText": "Is it worth to also add CompatibilityLevel.OFF and CompatibilityLevel.IGNORE?", "author": "BrianPin", "createdAt": "2020-09-25T05:14:58Z", "path": "restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityInfo;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestPegasusSchemaSnapshotCompatibilityChecker\n+{\n+  private final String FS = File.separator;\n+  private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n+\n+  @Test\n+  public void testCompatiblePegasusSchemaSnapshot()\n+  {\n+    PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzQxMA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373410", "bodyText": "OFF should not do the compatibility check\nAdd an assertion in incompatibleTest for IGNORE.", "author": "nickibi", "createdAt": "2020-09-26T01:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzNjEyMg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496636122", "bodyText": "here, CompatibilityLevel.OFF should also not parse the schemas. can we add assert on method calls?", "author": "aman1309", "createdAt": "2020-09-29T11:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzOTU3MA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496839570", "bodyText": "based on the way we trigger the checkPegasuSchemaSnapshotTask, the PegasusSchemaSnapshotCompatibilityChecker will not even be triggered if CompatibilityLevel.OFF.\nWe could add some check in PegasusSchemaSnapshotCompatibilityChecker if CompatibilityLevel.OFF do nothing. But that's redundant check, since we do the check even before executing the task.\nTherefore adding CompatibilityLevel.OFF test in TestPegasusSchemaSnapshotCompatibilityChecker is not applicable.", "author": "nickibi", "createdAt": "2020-09-29T15:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MjQ1OQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494752459", "bodyText": "I think it might be better to abstract test input out from the test logic.\nOne example is the \"BirthInfo\"", "author": "BrianPin", "createdAt": "2020-09-25T05:17:58Z", "path": "restli-tools/src/test/java/com/linkedin/restli/tools/snapshot/check/TestPegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityInfo;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestPegasusSchemaSnapshotCompatibilityChecker\n+{\n+  private final String FS = File.separator;\n+  private String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  private String snapshotDir = testDir + FS + \"pegasusSchemaSnapshot\";\n+\n+  @Test\n+  public void testCompatiblePegasusSchemaSnapshot()\n+  {\n+    PegasusSchemaSnapshotCompatibilityChecker checker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    checker.checkPegasusSchemaCompatibility(snapshotDir + FS + \"BirthInfo.pdl\", snapshotDir + FS + \"compatibleSchemaSnapshot/BirthInfo.pdl\",\n+        CompatibilityLevel.EQUIVALENT, CompatibilityOptions.Mode.DATA);\n+    CompatibilityInfoMap infoMap = checker.getInfoMap();\n+    Assert.assertTrue(infoMap.isModelCompatible(CompatibilityLevel.EQUIVALENT));\n+  }\n+\n+  @Test\n+  public void testIncompatiblePegasusSchemaSnapshot()", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzIxNQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373215", "bodyText": "Used DataProvider instead", "author": "nickibi", "createdAt": "2020-09-26T01:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzQxOA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494753418", "bodyText": "How about just final String compatableLevel", "author": "BrianPin", "createdAt": "2020-09-25T05:21:24Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzE0Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373147", "bodyText": "Fixed", "author": "nickibi", "createdAt": "2020-09-26T01:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDI1NA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494754254", "bodyText": "Would it be cleaner if the action checkPegasusSchemaCompatibility return the InfoMap directly?\nI mean : not use the check to have another call to get the info.\nThe reason being, if we not return info map directly, they are sort of internal state in the checker, that means you will need to get the info map before you can use the check to check again.", "author": "BrianPin", "createdAt": "2020-09-25T05:24:38Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      compatLevelValue = cl.getOptionValue(\"cl\");\n+    }\n+    else\n+    {\n+      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    try\n+    {\n+      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityLevel\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String compatModeValue;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      compatModeValue = cl.getOptionValue(\"cm\");\n+    }\n+    else\n+    {\n+      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n+    }\n+    CompatibilityOptions.Mode compatMode = null;\n+    try\n+    {\n+      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityOption Mode\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzExNQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373115", "bodyText": "Updated based on the suggestion", "author": "nickibi", "createdAt": "2020-09-26T01:48:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NDI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTY4NQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r494755685", "bodyText": "We can try to use StringJoiner to replace StringBuilder, that will make this code a bit cleaner because we don't have to add delimiter every time when a element is appended.\nYou can have it this way\nStringJoiner joiner = new StringJoiner(\"|\", \"<\", \">\");\nStream.of(CompatibilityOptions.Mode.values()).forEach(elem -> joiner.add(elem));\nreturn joiner.toString();", "author": "BrianPin", "createdAt": "2020-09-25T05:29:41Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    final String compatLevelValue;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      compatLevelValue = cl.getOptionValue(\"cl\");\n+    }\n+    else\n+    {\n+      compatLevelValue = CompatibilityLevel.DEFAULT.name();\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    try\n+    {\n+      compatLevel = CompatibilityLevel.valueOf(compatLevelValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityLevel\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String compatModeValue;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      compatModeValue = cl.getOptionValue(\"cm\");\n+    }\n+    else\n+    {\n+      compatModeValue = CompatibilityOptions.Mode.SCHEMA.name();\n+    }\n+    CompatibilityOptions.Mode compatMode = null;\n+    try\n+    {\n+      compatMode = CompatibilityOptions.Mode.valueOf(compatModeValue.toUpperCase());\n+    }\n+    catch (IllegalArgumentException e)\n+    {\n+      _logger.error(\"Invalid compatibilityOption Mode\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker.getInfoMap().createSummary();\n+\n+    if (compatLevel != CompatibilityLevel.OFF && summary.length() > 0)\n+    {\n+      _logger.info(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      _logger.info(new CompatibilityReport(compatibilityChecker.getInfoMap(), compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker.getInfoMap().isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  public CompatibilityInfoMap getInfoMap()\n+  {\n+    return _infoMap;\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing idl file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   */\n+  public void checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    final StringBuilder options = new StringBuilder(\"<\");\n+    for (CompatibilityLevel compatLevel : CompatibilityLevel.values())\n+    {\n+      options.append(compatLevel.name().toLowerCase()).append(\"|\");\n+    }\n+    options.replace(options.length() - 1, options.length(), \">\");\n+\n+    return options.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    final StringBuilder options = new StringBuilder(\"<\");", "originalCommit": "849f5a16a92eb014628d6e9085f5293301e2a3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM3MzA0OA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495373048", "bodyText": "Updated based on the suggestion", "author": "nickibi", "createdAt": "2020-09-26T01:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1NTY4NQ=="}], "type": "inlineReview"}, {"oid": "65a379ceaed8dde2e093cc2997848e715b99c139", "url": "https://github.com/linkedin/rest.li/commit/65a379ceaed8dde2e093cc2997848e715b99c139", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-26T01:31:11Z", "type": "forcePushed"}, {"oid": "c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "url": "https://github.com/linkedin/rest.li/commit/c39cd375d947a7f098acc730cfba3b4eb67e5fbf", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-26T04:07:23Z", "type": "forcePushed"}, {"oid": "678478fea424515a1a53489198c7036c9262d441", "url": "https://github.com/linkedin/rest.li/commit/678478fea424515a1a53489198c7036c9262d441", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-27T23:43:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNzk1MQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495637951", "bodyText": "Please add a one line comment on what each of these constants are used for.", "author": "karthikbalasub", "createdAt": "2020-09-28T00:21:51Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -538,6 +541,9 @@\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI1MzgzNA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496253834", "bodyText": "Added comments", "author": "nickibi", "createdAt": "2020-09-28T21:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYzNzk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDM1NA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640354", "bodyText": "Is this java process expecting the list of files to compare as the input? If so, please add to the help message.", "author": "karthikbalasub", "createdAt": "2020-09-28T00:41:12Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NTc0NQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496245745", "bodyText": "Updated to use directory as input instead of list of files.\nUpdated the help message accordingly.", "author": "nickibi", "createdAt": "2020-09-28T21:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDY3Mw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640673", "bodyText": "Why should we print the summary twice if \"report\" is enabled?\nIs printing to stdout the best option? Can we write this to a file instead?", "author": "karthikbalasub", "createdAt": "2020-09-28T00:43:41Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY4MjIzMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495682233", "bodyText": "Umm, printing similar contents of reports is unnecessary. Summary should be good enough for report here.\nI used stdout to leverage the existed \"CompatibilityLogChecker\" class to generate report.\nIn CheckPegasusSnapshotTask, we write the report into a summary file. Writing into a file here seems like redundant.\nMaybe we could remove \"report\" in the cmd line app?", "author": "nickibi", "createdAt": "2020-09-28T04:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NDQ4MQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496264481", "bodyText": "Discussed offline.\nWrite the report into a file.\nIn CheckPegasusSchemaSnapshotTask, use CompatibilityLogChecker to check the report file for the compatibility info.", "author": "nickibi", "createdAt": "2020-09-28T22:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDkwMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495640901", "bodyText": "Is this the best way to take inputs for this checker? Can we just take the root directory and iterate over the files?\nThe reason I'm asking is that for PDL files, the number of files is going to be large and would exceed the cmd line limit.", "author": "karthikbalasub", "createdAt": "2020-09-28T00:45:16Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcwNTYxMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495705611", "bodyText": "That's a good point, I will update to use the root directory instead.", "author": "nickibi", "createdAt": "2020-09-28T06:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2MzgwNA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496263804", "bodyText": "Updated", "author": "nickibi", "createdAt": "2020-09-28T22:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTAzNA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495641034", "bodyText": "nit: previousSchema or prevSchema", "author": "karthikbalasub", "createdAt": "2020-09-28T00:46:13Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI1NzY2Mg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496257662", "bodyText": "Following we need to parse pdl file to DataSchema, for the DataSchema I called it prevSchema. So I used \"prevSchemaFile\" to distinguish those two objects.\nI could remove this local variable, just pass 'new File(prevPegasusSchemaPath)' into the parseSchema method to get DataSchema.", "author": "nickibi", "createdAt": "2020-09-28T21:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTk0NA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495641944", "bodyText": "I don't think this is the correct impact. We just have to these files as added. Similar to how the ChangedFileReportTask works.\nAlso, add this only after current schema is parsed correctly?", "author": "karthikbalasub", "createdAt": "2020-09-28T00:51:51Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2MzYwMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496263601", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-09-28T22:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MjMzMA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495642330", "bodyText": "Again, this is just a backwards incompatible change. It can break any client using this schema at build time, not just old readers.", "author": "karthikbalasub", "createdAt": "2020-09-28T00:54:25Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2MzY2MQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496263661", "bodyText": "Updated.", "author": "nickibi", "createdAt": "2020-09-28T22:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MjMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MzgyMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495643821", "bodyText": "It seems odd that you need to create a resolver for each file. Do you want to process the same schema multiple times if it is referenced by other schemas? Consider this scenario:\nPrev:\nA.pdl:\nrecord A {\nb: B\n}\nB.pdl:\nrecord B {\nf1: int\nf2: float\n}\nCurrent:\nA.pdl:\nrecord A {\nb: B\n}\nB.pdl:\nrecord B {\nf1: int\n// f2 deleted\n}\nNow will the error be reported once for B.pdl or twice, for both A.pdl and B.pdl?\nI know we report the error multiple times for resource compatibility checking, but do you think that is the best options for schema checker also?", "author": "karthikbalasub", "createdAt": "2020-09-28T01:05:03Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.restli.internal.tools.RestLiToolsUtils;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static String _resolverPath;\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withLongOpt(\"report\")\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length < 2 || cliArgs.length %2 != 0)\n+    {\n+      _logger.error(\"Invalid arguments\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode\");\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    try\n+    {\n+      _resolverPath = RestLiToolsUtils.getResolverPathFromSystemProperty();\n+    }\n+    catch (IOException e)\n+    {\n+      _logger.error(\"Cannot read resolver path: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < cliArgs.length; i += 2)\n+    {\n+      String prevSnapshot = cliArgs[i-1];\n+      String currentSnapshot = cliArgs[i];\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatLevel, compatMode);\n+    }\n+\n+    String summary = compatibilityChecker._infoMap.createSummary();\n+\n+    if (summary.length() > 0)\n+    {\n+      System.out.println(summary);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      System.out.println(new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport());\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatibilityLevel compatibility level\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityLevel compatibilityLevel, CompatibilityOptions.Mode compatMode)\n+  {\n+    _infoMap.isCompatible(compatibilityLevel);\n+\n+    File preSchemaFile = new File(prevPegasusSchemaPath);\n+    File currSchemaFile = new File(currentPegasusSchemaPath);\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(preSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.OLD_READER_IGNORES_DATA,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(currSchemaFile);\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAKS_OLD_READER,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n+    PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+    parser.parse(new FileInputStream(schemaFile));", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY4NDg4Mg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495684882", "bodyText": "Umm, I think based on the way we generated snapshot pdl we have to parse each file.\nAll the referenced schemas are constructed as inline records in the snapshot.\nFor example:\nsnapshot: A.pdl will be look like following\nrecord A {\nb: record B {\nf1: int\nf2: float\n}\n}\nI don't think we could avoid it.\nActually, since we do not need resolver path here. I could use DefaultDataSchemaResolver instead. I will the code.", "author": "nickibi", "createdAt": "2020-09-28T04:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0MzgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTI0MA==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495645240", "bodyText": "Not used anywhere?", "author": "karthikbalasub", "createdAt": "2020-09-28T01:13:52Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/compatibility/CompatibilityInfoMap.java", "diffHunk": "@@ -166,6 +166,21 @@ public String createSummary()\n     return summaryMessage.toString();\n   }\n \n+  public String createPegasusSchemaSummary()", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3NzMxOQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495677319", "bodyText": "It is supposed to use to create summary report. When I edited code, we accidentally removed the usage.\nUpdated.", "author": "nickibi", "createdAt": "2020-09-28T03:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NjAwNg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496246006", "bodyText": "No more usage, deleted.", "author": "nickibi", "createdAt": "2020-09-28T21:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTYxMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495645613", "bodyText": "unused?", "author": "karthikbalasub", "createdAt": "2020-09-28T01:15:53Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -1,32 +1,176 @@\n /*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.linkedin.pegasus.gradle.tasks;\n \n+import com.linkedin.pegasus.gradle.IOUtil;\n+import com.linkedin.pegasus.gradle.PathingJarUtil;\n+import com.linkedin.pegasus.gradle.PegasusPlugin;\n+import com.linkedin.pegasus.gradle.SharedFileUtils;\n+import com.linkedin.pegasus.gradle.internal.CompatibilityLogChecker;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Classpath;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputDirectory;\n+import org.gradle.api.tasks.PathSensitive;\n+import org.gradle.api.tasks.PathSensitivity;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n import org.gradle.api.tasks.TaskAction;\n \n \n @CacheableTask\n public class CheckPegasusSnapshotTask extends DefaultTask\n {\n+  private File _currentSnapshotDirectory;\n+  private File _previousSnapshotDirectory;\n+  private String _compatibilityLevel;\n+  private FileCollection _codegenClasspath;\n+  private String _compatibilityMode;\n+  private FileCollection _handlerJarPath;\n+  private boolean _isExtensionSchema = false;\n+  private File _summaryTarget = new File(getProject().getBuildDir(), \"reports/checkPegasusSchema/summary.txt\");\n+\n   @TaskAction\n   public void checkPegasusSnapshot()\n   {\n-    // TODO: implement CheckPegasusSnapshotTask\n+    getLogger().info(\"Checking pegasus schema compatibility ...\");\n+    List<String> argFiles = new ArrayList<>();\n+    argFiles.addAll(SharedFileUtils.findMatchingFiles(PegasusPlugin.PDL_FILE_SUFFIX,\n+        getProject().fileTree(_currentSnapshotDirectory), getProject().fileTree(_previousSnapshotDirectory), false));\n+    if (argFiles.isEmpty())\n+    {\n+      return;\n+    }\n+\n+    FileCollection pathedCodegenClasspath;\n+    try\n+    {\n+      pathedCodegenClasspath = PathingJarUtil.generatePathingJar(getProject(), getName(),\n+          _codegenClasspath, false);\n+    }\n+    catch (IOException e)\n+    {\n+      throw new GradleException(\"Error occurred generating pathing JAR.\", e);\n+    }\n+\n+    CompatibilityLogChecker logChecker = new CompatibilityLogChecker();\n+    getProject().javaexec(javaExecSpec ->\n+    {\n+      javaExecSpec.setMain(\"com.linkedin.restli.tools.snapshot.check.PegasusSchemaSnapshotCompatibilityChecker\");\n+      javaExecSpec.setClasspath(pathedCodegenClasspath);\n+      javaExecSpec.args(\"--compatLevel\", _compatibilityLevel);\n+      javaExecSpec.args(\"--compatMode\", _compatibilityMode);\n+      javaExecSpec.args(\"--report\");\n+      javaExecSpec.args(argFiles);\n+      javaExecSpec.setStandardOutput(logChecker);\n+    });\n+\n+    IOUtil.writeText(_summaryTarget, logChecker.getWholeText());\n+\n+    if (!logChecker.isModelCompatible())\n+    {\n+      throw new GradleException(\"See output for \" + getPath() + \". Summary written to \"\n+          + _summaryTarget.getAbsolutePath());\n+    }\n+  }\n+\n+  @InputDirectory\n+  @SkipWhenEmpty\n+  @PathSensitive(PathSensitivity.RELATIVE)\n+  public File getCurrentSnapshotDirectory()\n+  {\n+    return _currentSnapshotDirectory;\n   }\n \n+  public void setCurrentSnapshotDirectory(File currentSnapshotDirectory)\n+  {\n+    _currentSnapshotDirectory = currentSnapshotDirectory;\n+  }\n+\n+  @InputDirectory\n+  @SkipWhenEmpty\n+  @PathSensitive(PathSensitivity.RELATIVE)\n+  public File getPreviousSnapshotDirectory()\n+  {\n+    return _previousSnapshotDirectory;\n+  }\n+\n+  public void setPreviousSnapshotDirectory(File previousSnapshotDirectory)\n+  {\n+    _previousSnapshotDirectory = previousSnapshotDirectory;\n+  }\n+\n+  @Input\n+  public String getCompatibilityLevel()\n+  {\n+    return _compatibilityLevel;\n+  }\n+\n+  public void setCompatibilityLevel(String compatibilityLevel)\n+  {\n+    _compatibilityLevel = compatibilityLevel;\n+  }\n+\n+  @Input\n+  public String getCompatibilityMode()\n+  {\n+    return _compatibilityMode;\n+  }\n+\n+  public void setCompatibilityMode(String compatibilityMode)\n+  {\n+    _compatibilityMode = compatibilityMode;\n+  }\n+\n+  @Classpath\n+  public FileCollection getCodegenClasspath()\n+  {\n+    return _codegenClasspath;\n+  }\n+\n+  public void setCodegenClasspath(FileCollection codegenClasspath)\n+  {\n+    _codegenClasspath = codegenClasspath;\n+  }\n+\n+  @Input\n+  public boolean isExtensionSchema()\n+  {\n+    return _isExtensionSchema;\n+  }\n+\n+  public void setExtensionSchema(boolean isExtensionSchema)\n+  {\n+    _isExtensionSchema = isExtensionSchema;\n+  }\n+\n+  @Classpath\n+  public FileCollection getHandlerJarPath()\n+  {\n+    return _handlerJarPath;", "originalCommit": "678478fea424515a1a53489198c7036c9262d441", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY3NzUzMg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r495677532", "bodyText": "It will be used to in the following PR. I created it as for a place holder.", "author": "nickibi", "createdAt": "2020-09-28T03:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY0NTYxMw=="}], "type": "inlineReview"}, {"oid": "18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "url": "https://github.com/linkedin/rest.li/commit/18610609ada1a7dd8e98bcb0c7c159fb02d9a326", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-28T22:07:18Z", "type": "forcePushed"}, {"oid": "e8cff132df27dc0936309023946b483d09cf9112", "url": "https://github.com/linkedin/rest.li/commit/e8cff132df27dc0936309023946b483d09cf9112", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-28T22:16:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNjY1Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496606657", "bodyText": "Suggestion: would be good to refactor this and move these config constants to FileCompatibilityType(String configName) Enum", "author": "aman1309", "createdAt": "2020-09-29T10:22:10Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -538,6 +539,12 @@\n   public static final String SNAPSHOT_FILE_SUFFIX = \".snapshot.json\";\n   public static final String SNAPSHOT_COMPAT_REQUIREMENT = \"rest.model.compatibility\";\n   public static final String IDL_COMPAT_REQUIREMENT = \"rest.idl.compatibility\";\n+  // Pegasus extension schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n+  public static final String PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusExtensionSchema.compatibility\";\n+  // Pegasus schema compatibility level configuration, which is used to define the {@link CompatibilityLevel}.\n+  public static final String PEGASUS_SCHEMA_SNAPSHOT_REQUIREMENT = \"pegasusPlugin.pegasusSchema.compatibility\";\n+  // CompatibilityOptions Mode configuration, which is used to define the {@link CompatibilityOptions#Mode} in the compatibility checker.\n+  private static final String PEGASUS_COMPATIBILITY_MODE = \"pegasusPlugin.pegasusSchemaCompatibilityCheckMode\";", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwNjU0Ng==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496806546", "bodyText": "All those configurations are optional to provide different configurations. I don't think adding them into a enum is the right solution here.\nI just reconsidered the usage of PEGASUS_EXTENSION_SCHEMA_SNAPSHOT_REQUIREMENT. The extension schema is not going to be consumed by rest.li end user. It will be consumed by GQL, backward incompatible change should not be allowed. Therefore, removed this configuration.", "author": "nickibi", "createdAt": "2020-09-29T15:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYwNjY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYyODk2Ng==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496628966", "bodyText": "since we might use pdl for idl's in 3.0 or for any other future usecase, recommend using 'FileCompatibilityType' instead of boolean flag.", "author": "aman1309", "createdAt": "2020-09-29T11:03:26Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/CheckPegasusSnapshotTask.java", "diffHunk": "@@ -1,32 +1,176 @@\n /*\n-   Copyright (c) 2020 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n package com.linkedin.pegasus.gradle.tasks;\n \n+\n+import com.linkedin.pegasus.gradle.PathingJarUtil;\n+import com.linkedin.pegasus.gradle.internal.CompatibilityLogChecker;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Classpath;\n+import org.gradle.api.tasks.Input;\n+import org.gradle.api.tasks.InputDirectory;\n+import org.gradle.api.tasks.PathSensitive;\n+import org.gradle.api.tasks.PathSensitivity;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n import org.gradle.api.tasks.TaskAction;\n \n \n @CacheableTask\n public class CheckPegasusSnapshotTask extends DefaultTask\n {\n+  private File _currentSnapshotDirectory;\n+  private File _previousSnapshotDirectory;\n+  private String _compatibilityLevel;\n+  private FileCollection _codegenClasspath;\n+  private String _compatibilityMode;\n+  private FileCollection _handlerJarPath;\n+  private boolean _isExtensionSchema = false;", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMzEzMQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496803131", "bodyText": "I don't think using Enum instead of a boolean is appropriate here. No matter how many use cases of pdl in the future, it is unrelated to the usage of this boolean flag here. isExtensionSchema boolean not only is used to detect input but also is used for annotation check in the following PR.", "author": "nickibi", "createdAt": "2020-09-29T15:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYyODk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzMDMxMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496630313", "bodyText": "can we unit test for gradle tasks?", "author": "aman1309", "createdAt": "2020-09-29T11:05:54Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -1449,23 +1460,43 @@ protected void configurePegasusSchemaSnapshotGeneration(Project project, SourceS\n   {\n     File schemaDir = isExtensionSchema? project.file(getExtensionSchemaPath(project, sourceSet))\n         : project.file(getDataSchemaPath(project, sourceSet));\n+\n     Path publishablePegasusSchemaSnapshotDir = project.getBuildDir().toPath().resolve(sourceSet.getName() +\n             (isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT));\n \n     Task generatePegasusSchemaSnapshot = generatePegasusSchemaSnapshot(project, sourceSet,\n         isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT, schemaDir,\n         publishablePegasusSchemaSnapshotDir.toFile(), isExtensionSchema);\n \n+    File pegasusSchemaSnapshotDir = project.file(isExtensionSchema ? getPegasusExtensionSchemaSnapshotPath(project, sourceSet)\n+        : getPegasusSchemaSnapshotPath(project, sourceSet));\n+    pegasusSchemaSnapshotDir.mkdirs();\n+\n     Task checkSchemaSnapshot = project.getTasks().create(sourceSet.getTaskName(\"check\",\n         isExtensionSchema ? PEGASUS_EXTENSION_SCHEMA_SNAPSHOT: PEGASUS_SCHEMA_SNAPSHOT),\n         CheckPegasusSnapshotTask.class, task ->\n         {\n           task.dependsOn(generatePegasusSchemaSnapshot);\n-          // TODO: update CheckPegasusSnapshotTask\n-        });\n+          task.setCurrentSnapshotDirectory(publishablePegasusSchemaSnapshotDir.toFile());\n+          task.setPreviousSnapshotDirectory(pegasusSchemaSnapshotDir);\n+          task.setCodegenClasspath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION)\n+              .plus(project.getConfigurations().getByName(PEGASUS_PLUGIN_CONFIGURATION))\n+              .plus(project.getConfigurations().getByName(JavaPlatformPlugin.RUNTIME_CONFIGURATION_NAME)));\n+          task.setCompatibilityLevel(isExtensionSchema ?\n+              PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_EXTENSION_SCHEMA_SNAPSHOT)\n+              :PropertyUtil.findCompatLevel(project, FileCompatibilityType.PEGASUS_SCHEMA_SNAPSHOT));\n+          task.setCompatibilityMode(isExtensionSchema ? COMPATIBILITY_OPTIONS_MODE_DATA :\n+              PropertyUtil.findCompatMode(project, PEGASUS_COMPATIBILITY_MODE));\n+          task.setExtensionSchema(isExtensionSchema);\n+          task.setHandlerJarPath(project.getConfigurations() .getByName(SCHEMA_ANNOTATION_HANDLER_CONFIGURATION));\n \n-    File pegasusSchemaSnapshotDir = new File(isExtensionSchema ? getPegasusExtensionSchemaSnapshotPath(project, sourceSet)\n-        : getPegasusSchemaSnapshotPath(project, sourceSet));\n+          task.onlyIf(t ->", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYzMTQwMw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496631403", "bodyText": "lets print option value and exception trace also.\nSame for other places.", "author": "aman1309", "createdAt": "2020-09-29T11:07:56Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Prints a report at the end of the execution that can be parsed for reporting to other tools\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel\");", "originalCommit": "e8cff132df27dc0936309023946b483d09cf9112", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "02a5f62be184d2095e9036247e3532f365edeb34", "url": "https://github.com/linkedin/rest.li/commit/02a5f62be184d2095e9036247e3532f365edeb34", "message": "Add checkPegasusSchemaSnapshotTask", "committedDate": "2020-09-29T15:57:44Z", "type": "forcePushed"}, {"oid": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "url": "https://github.com/linkedin/rest.li/commit/7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-29T16:15:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNjE1Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496916157", "bodyText": "the Key should include the path or atleast the package (namespace)? what if there are two schemas with the same name in a module?\nAlso add a unit test for this case", "author": "karthikbalasub", "createdAt": "2020-09-29T17:30:19Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n+    {\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n+  {\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      newSchemaCreated = true;\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()\n+  {\n+    final HelpFormatter formatter = new HelpFormatter();\n+    formatter.printHelp(120,\n+        PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n+        _options,\n+        \"\",\n+        true);\n+  }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))\n+      {\n+        filePairs.add(prevFilesMap.get(filename));\n+        filePairs.add(absolutePath);\n+        prevFilesMap.remove(filename);\n+      }\n+      else\n+      {\n+        filePairs.add(\"\");\n+        filePairs.add(absolutePath);\n+      }\n+    });\n+\n+    prevFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      filePairs.add(absolutePath);\n+      filePairs.add(\"\");\n+    });\n+\n+    return filePairs;\n+  }\n+\n+  /**\n+   * Create a map for all the files under snapshot directory.\n+   * The key is the file name, the value is the absolutePath of the file\n+   * @param snapshotFileDir\n+   * @return filesMap Map<String, String>\n+   */\n+  private static Map<String, String> createMapFromFiles(String snapshotFileDir)\n+  {\n+    try (Stream<Path> paths = Files.walk(Paths.get(snapshotFileDir)))\n+    {\n+      return paths\n+          .filter(path -> path.toString().endsWith(PDL))\n+          .map(path -> path.toFile())\n+          .collect(Collectors.toMap(File::getName, File:: getAbsolutePath, (first, second) -> first));", "originalCommit": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3NTA2Mg==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496975062", "bodyText": "We use FQN as pdl snapshot file name, which includes the namespace.\nI will add unit tests.", "author": "nickibi", "createdAt": "2020-09-29T19:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNjE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzA1Nw==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496927057", "bodyText": "should be prevFilesMap\nIs there a unit test to handle this case?", "author": "karthikbalasub", "createdAt": "2020-09-29T17:48:09Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/snapshot/check/PegasusSchemaSnapshotCompatibilityChecker.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.linkedin.restli.tools.snapshot.check;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.compatibility.CompatibilityChecker;\n+import com.linkedin.data.schema.compatibility.CompatibilityMessage;\n+import com.linkedin.data.schema.compatibility.CompatibilityOptions;\n+import com.linkedin.data.schema.compatibility.CompatibilityResult;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.DefaultDataSchemaResolver;\n+import com.linkedin.restli.tools.compatibility.CompatibilityInfoMap;\n+import com.linkedin.restli.tools.compatibility.CompatibilityReport;\n+import com.linkedin.restli.tools.idlcheck.CompatibilityLevel;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * Check Compatibility between pairs of Pegasus Schema Snapshots (.pdl files).\n+ *\n+ * @author Yingjie Bi\n+ */\n+public class PegasusSchemaSnapshotCompatibilityChecker\n+{\n+\n+  private static final Options _options = new Options();\n+  private static final Logger _logger = LoggerFactory.getLogger(\n+      PegasusSchemaSnapshotCompatibilityChecker.class);\n+  private final CompatibilityInfoMap _infoMap = new CompatibilityInfoMap();\n+  private static final String PDL = \".pdl\";\n+\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_level\")\n+        .withLongOpt(\"compatLevel\")\n+        .hasArg()\n+        .withDescription(\"Compatibility level \" + listCompatLevelOptions())\n+        .create(\"cl\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibilityOption_mode\")\n+        .withLongOpt(\"compatMode\")\n+        .hasArg()\n+        .withDescription(\"CompatibilityOption Mode \" + listCompatModeOptions())\n+        .create(\"cm\"));\n+    _options.addOption(OptionBuilder.withArgName(\"compatibility_report\")\n+        .withLongOpt(\"report\")\n+        .hasArg()\n+        .withDescription(\"Write the compatibility report into the provided file at the end of the execution.\")\n+        .create(\"report\"));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    final CommandLineParser parser = new GnuParser();\n+    CommandLine cl = parser.parse(_options, args);\n+\n+    if (cl.hasOption('h'))\n+    {\n+      help();\n+      System.exit(0);\n+    }\n+\n+    String[] cliArgs = cl.getArgs();\n+\n+    if (cliArgs.length != 2)\n+    {\n+      _logger.error(\"Invalid arguments!\");\n+      help();\n+      System.exit(1);\n+    }\n+\n+    String prevSnapshotDir = cliArgs[0];\n+    String currSnapshotDir = cliArgs[1];\n+\n+    List<String> prevSnapshotAndCurrSnapshotPairs = getMatchingPrevAndCurrSnapshotPairs(prevSnapshotDir, currSnapshotDir);\n+\n+    CompatibilityLevel compatLevel = null;\n+    if (cl.hasOption(\"cl\"))\n+    {\n+      try\n+      {\n+        compatLevel = CompatibilityLevel.valueOf(cl.getOptionValue(\"cl\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityLevel: \" + cl.getOptionValue(\"cl\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatLevel = CompatibilityLevel.DEFAULT;\n+    }\n+\n+    CompatibilityOptions.Mode compatMode = null;\n+    if (cl.hasOption(\"cm\"))\n+    {\n+      try\n+      {\n+        compatMode = CompatibilityOptions.Mode.valueOf(cl.getOptionValue(\"cm\").toUpperCase());\n+      }\n+      catch (IllegalArgumentException e)\n+      {\n+        _logger.error(\"Invalid compatibilityOption Mode: \" + cl.getOptionValue(\"cm\") + e.getMessage());\n+        help();\n+        System.exit(1);\n+      }\n+    }\n+    else\n+    {\n+      compatMode = CompatibilityOptions.Mode.SCHEMA;\n+    }\n+\n+    PegasusSchemaSnapshotCompatibilityChecker compatibilityChecker = new PegasusSchemaSnapshotCompatibilityChecker();\n+    for (int i = 1; i < prevSnapshotAndCurrSnapshotPairs.size(); i += 2)\n+    {\n+      String prevSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i-1);\n+      String currentSnapshot = prevSnapshotAndCurrSnapshotPairs.get(i);\n+      compatibilityChecker.checkPegasusSchemaCompatibility(prevSnapshot, currentSnapshot, compatMode);\n+    }\n+\n+    if (cl.hasOption(\"report\"))\n+    {\n+      File reportFile = new File(cl.getOptionValue(\"report\"));\n+      String compatibilityReport = new CompatibilityReport(compatibilityChecker._infoMap, compatLevel).createReport();\n+      Files.write(reportFile.toPath(), compatibilityReport.getBytes(StandardCharsets.UTF_8));\n+      System.exit(0);\n+    }\n+\n+    System.exit(compatibilityChecker._infoMap.isModelCompatible(compatLevel) ? 0 : 1);\n+  }\n+\n+  /**\n+   * Check backwards compatibility between a pegasusSchemaSnapshot (.pdl) and a pegasusSchemaSnapshot (.pdl) file.\n+   *\n+   * @param prevPegasusSchemaPath previously existing snapshot file\n+   * @param currentPegasusSchemaPath current snapshot file\n+   * @param compatMode compatibilityOptions mode which defines the compatibility check mode.\n+   * @return CompatibilityInfoMap which contains information whether the given two files are compatible or not.\n+   */\n+  public CompatibilityInfoMap checkPegasusSchemaCompatibility(String prevPegasusSchemaPath, String currentPegasusSchemaPath,\n+      CompatibilityOptions.Mode compatMode)\n+  {\n+    boolean newSchemaCreated = false;\n+    boolean preSchemaRemoved = false;\n+\n+    DataSchema preSchema = null;\n+    try\n+    {\n+      preSchema = parseSchema(new File(prevPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      newSchemaCreated = true;\n+    }\n+\n+    DataSchema currSchema = null;\n+    try\n+    {\n+      currSchema = parseSchema(new File(currentPegasusSchemaPath));\n+    }\n+    catch(FileNotFoundException e)\n+    {\n+      preSchemaRemoved = true;\n+    }\n+\n+    if (newSchemaCreated && !preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.NEW_SCHEMA_ADDED,\n+          \"New schema %s is created.\", currentPegasusSchemaPath);\n+    }\n+    if (!newSchemaCreated && preSchemaRemoved)\n+    {\n+      constructCompatibilityMessage(CompatibilityMessage.Impact.BREAK_OLD_CLIENTS,\n+          \"Schema %s is removed.\", prevPegasusSchemaPath);\n+    }\n+\n+    if (preSchema == null || currSchema == null)\n+    {\n+      return _infoMap;\n+    }\n+\n+    CompatibilityOptions compatibilityOptions = new CompatibilityOptions().setMode(compatMode).setAllowPromotions(true);\n+    CompatibilityResult result = CompatibilityChecker.checkCompatibility(preSchema, currSchema, compatibilityOptions);\n+\n+    if (!result.getMessages().isEmpty())\n+    {\n+      result.getMessages().forEach(message -> _infoMap.addModelInfo(message));\n+    }\n+\n+    return _infoMap;\n+  }\n+\n+  private void constructCompatibilityMessage(CompatibilityMessage.Impact impact, String format, Object... args)\n+  {\n+    CompatibilityMessage message = new CompatibilityMessage(new Object[]{}, impact, format, args);\n+    _infoMap.addModelInfo(message);\n+  }\n+\n+  private DataSchema parseSchema(File schemaFile) throws FileNotFoundException\n+  {\n+    PdlSchemaParser parser = new PdlSchemaParser(new DefaultDataSchemaResolver());\n+    parser.parse(new FileInputStream(schemaFile));\n+    if (parser.hasError())\n+    {\n+      throw new RuntimeException(parser.errorMessage() + \" Error while parsing file: \" + schemaFile.toString());\n+    }\n+\n+    List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+    if (topLevelDataSchemas.size() != 1)\n+    {\n+      throw new RuntimeException(\"Could not parse schema : \" + schemaFile.getAbsolutePath() + \" The size of top level schemas is not 1.\");\n+    }\n+    DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+    if (!(topLevelDataSchema instanceof NamedDataSchema))\n+    {\n+      throw new RuntimeException(\"Invalid schema : \" + schemaFile.getAbsolutePath() + \", the schema is not a named schema.\");\n+    }\n+    return topLevelDataSchema;\n+  }\n+\n+  private static String listCompatLevelOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityLevel.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static String listCompatModeOptions()\n+  {\n+    StringJoiner stringJoiner = new StringJoiner(\"|\", \"<\", \">\");\n+    Stream.of(CompatibilityOptions.Mode.values()).forEach(e -> stringJoiner.add(e.name()));\n+    return stringJoiner.toString();\n+  }\n+\n+  private static void help()\n+  {\n+    final HelpFormatter formatter = new HelpFormatter();\n+    formatter.printHelp(120,\n+        PegasusSchemaSnapshotCompatibilityChecker.class.getSimpleName(),\n+        \"[compatibility_level], [compatibilityOption_mode], [report], [prevSnapshotDir], [currSnapshotDir]\",\n+        _options,\n+        \"\",\n+        true);\n+  }\n+\n+  /**\n+   * Generate a file pair list, the same snapshot names of prevSnapshot and currSnapshot will be grouped together.\n+   *\n+   * @param prevSnapshotDir\n+   * @param currSnapshotDir\n+   * @return filePairList List<String>\n+   */\n+  private static List<String> getMatchingPrevAndCurrSnapshotPairs(String prevSnapshotDir, String currSnapshotDir)\n+  {\n+    Map<String, String> prevFilesMap = createMapFromFiles(prevSnapshotDir);\n+    Map<String, String> currFilesMap = createMapFromFiles(currSnapshotDir);\n+    List<String> filePairs = new ArrayList<>();\n+\n+    currFilesMap.forEach((filename, absolutePath) ->\n+    {\n+      if (currFilesMap.containsKey(filename))", "originalCommit": "7f338873ec5fa3064fd53ce5a8a3da420a93c83e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2NDQ5OQ==", "url": "https://github.com/linkedin/rest.li/pull/425#discussion_r496964499", "bodyText": "Oops, it should be prevFilesMap.\nI would make this method as package private for adding unit test.", "author": "nickibi", "createdAt": "2020-09-29T18:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNzA1Nw=="}], "type": "inlineReview"}, {"oid": "03c0e0e7db8db22d16618c58e117bafbbfa111b8", "url": "https://github.com/linkedin/rest.li/commit/03c0e0e7db8db22d16618c58e117bafbbfa111b8", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-29T23:38:34Z", "type": "forcePushed"}, {"oid": "64e32c96a570d57853c8759bd7647904d05f8157", "url": "https://github.com/linkedin/rest.li/commit/64e32c96a570d57853c8759bd7647904d05f8157", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T00:03:18Z", "type": "forcePushed"}, {"oid": "205b990c053a124cce887f07cf7916434a805221", "url": "https://github.com/linkedin/rest.li/commit/205b990c053a124cce887f07cf7916434a805221", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:09:38Z", "type": "forcePushed"}, {"oid": "107af4472c44c1da1e2c6fe53f46519b7cec81f1", "url": "https://github.com/linkedin/rest.li/commit/107af4472c44c1da1e2c6fe53f46519b7cec81f1", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:18:15Z", "type": "forcePushed"}, {"oid": "dc6d58cf211e56744382ca4e759f7ccb65401dc1", "url": "https://github.com/linkedin/rest.li/commit/dc6d58cf211e56744382ca4e759f7ccb65401dc1", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:20:52Z", "type": "commit"}, {"oid": "dc6d58cf211e56744382ca4e759f7ccb65401dc1", "url": "https://github.com/linkedin/rest.li/commit/dc6d58cf211e56744382ca4e759f7ccb65401dc1", "message": "Add `checkPegasusSchemaSnapshot` task.\n   - The task will be used to check any pegasus schema compatible and incompatible changes.\n   - The pegasus schema may or may not be part of a rest.li resource.\n   - The task will be triggered at build time, if user provides gradle property: \"pegasusPlugin.enablePegasusSchemaCompatibilityCheck=true\".", "committedDate": "2020-09-30T15:20:52Z", "type": "forcePushed"}]}