{"pr_number": 235, "pr_title": "Add extensionSchema validation task", "pr_createdAt": "2020-03-26T04:45:34Z", "pr_url": "https://github.com/linkedin/rest.li/pull/235", "timeline": [{"oid": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "url": "https://github.com/linkedin/rest.li/commit/f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "message": "Add extension schema validation tasks\nUpdate Pegesus plugin", "committedDate": "2020-03-26T04:46:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyODM1Ng==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398328356", "bodyText": "add some debug?", "author": "junchuanwang", "createdAt": "2020-03-26T05:39:50Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -913,6 +921,41 @@ protected void configureGeneratedSourcesAndJavadoc(Project project)\n     }\n   }\n \n+  protected void configureExtensionSchemaValidation(Project project, SourceSet sourceSet)\n+  {\n+    // extension schema  directory\n+    File extensionSchemaDir = project.file(getExtensionSchemaPath(project, sourceSet));\n+\n+    if (SharedFileUtils.getSuffixedFiles(project, extensionSchemaDir, PDL_FILE_SUFFIX).isEmpty())\n+    {\n+      return;", "originalCommit": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc3OTE3Nw==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398779177", "bodyText": "This task should be run during build time by default. If there is no extension schema, it will not run. Do you think adding debug info here will confuse people if they don't use ER.", "author": "nickibi", "createdAt": "2020-03-26T17:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyODM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDMxNw==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398330317", "bodyText": "Where is this used? I didn't see", "author": "junchuanwang", "createdAt": "2020-03-26T05:47:14Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -721,6 +722,11 @@ public void apply(Project project)\n     // and validate.\n     Configuration schemaAnnotationHandler = configurations.maybeCreate(\"schemaAnnotationHandler\");\n \n+    // configuration for parsing and validating extension schemas during build time.\n+    //\n+    // publish extension schemas into extension schema Jar once the validation passes.\n+    Configuration extensionSchema = configurations.maybeCreate(\"extensionSchema\");", "originalCommit": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc3OTUwNA==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398779504", "bodyText": "It is used in line 956.", "author": "nickibi", "createdAt": "2020-03-26T18:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDYzMQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398330631", "bodyText": "Rename this to end with \"cmdLineApp\" to follow convention.", "author": "junchuanwang", "createdAt": "2020-03-26T05:48:10Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidation.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.data;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ExtensionSchemaValidation", "originalCommit": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc4MTE0NA==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398781144", "bodyText": "Follow what convention? All the classes under com/linkedin/restli/tools/data are not end with \"cmdLineApp\".", "author": "nickibi", "createdAt": "2020-03-26T18:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkxNjE1OQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r399916159", "bodyText": "I believe that is not correct due to historical reasons. We should from now on call all newly created file with \"cmdLineApp\" because they can be used as command line app:\n    getProject().javaexec(javaExecSpec -> {\n       javaExecSpec.setMain(\"com.linkedin.restli.tools.data.ExtensionSchemaValidation\");\n       javaExecSpec.setClasspath(_pathedClasspath);\n       javaExecSpec.args(resolverPathStr);\n       javaExecSpec.args(_inputDir.getAbsolutePath());\n     });", "author": "junchuanwang", "createdAt": "2020-03-30T04:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2ODM0Nw==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r400468347", "bodyText": "Updated the class name to \"ExtensionSchemaValidationCmdLineApp\"", "author": "nickibi", "createdAt": "2020-03-30T20:19:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDgyOA==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398330828", "bodyText": "nits: Wrong arguments", "author": "junchuanwang", "createdAt": "2020-03-26T05:48:47Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidation.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.data;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ExtensionSchemaValidation\n+{\n+  private static final Logger _logger = LoggerFactory.getLogger(ExtensionSchemaValidation.class);\n+  private static final Options _options = new Options();\n+  private static final String _pdl = \"pdl\";\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    try {\n+      final CommandLineParser parser = new GnuParser();\n+      CommandLine cl = parser.parse(_options, args);\n+\n+      if (cl.hasOption('h'))\n+      {\n+        help();\n+        System.exit(0);\n+      }\n+\n+      String[] cliArgs = cl.getArgs();\n+      if (cliArgs.length != 2)\n+      {\n+        _logger.error(\"Wrong argument given\");", "originalCommit": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NDc3MQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398894771", "bodyText": "nit: Invalid arguments", "author": "evanw555", "createdAt": "2020-03-26T21:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQwNjUzMg==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r399406532", "bodyText": "Fixed the log.", "author": "nickibi", "createdAt": "2020-03-27T16:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMTI1OQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398331259", "bodyText": "Should give the reason", "author": "junchuanwang", "createdAt": "2020-03-26T05:50:27Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidation.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.data;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ExtensionSchemaValidation\n+{\n+  private static final Logger _logger = LoggerFactory.getLogger(ExtensionSchemaValidation.class);\n+  private static final Options _options = new Options();\n+  private static final String _pdl = \"pdl\";\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    try {\n+      final CommandLineParser parser = new GnuParser();\n+      CommandLine cl = parser.parse(_options, args);\n+\n+      if (cl.hasOption('h'))\n+      {\n+        help();\n+        System.exit(0);\n+      }\n+\n+      String[] cliArgs = cl.getArgs();\n+      if (cliArgs.length != 2)\n+      {\n+        _logger.error(\"Wrong argument given\");\n+        help();\n+        System.exit(1);\n+      }\n+      int i = 0;\n+      String resolverPath = cliArgs[i++];\n+      String inputPath = cliArgs[i];\n+\n+      File inputDir = new File(inputPath);\n+\n+      if (!inputDir.exists() || !inputDir.canRead()) {\n+        _logger.error(\"Input directory does not exist or cannot be read: \" + inputDir.getAbsolutePath());\n+        System.exit(1);\n+      }\n+\n+      parseAndValidateExtensionSchemas(resolverPath, inputDir);\n+    }\n+    catch (ParseException e)\n+    {\n+      _logger.error(\"Invalid arguments: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+  }\n+\n+  private static void parseAndValidateExtensionSchemas(String resolverPath, File inputDir) throws IOException\n+  {\n+    // Parse each extension schema and validate it\n+    Iterator<File> iterator = FileUtils.iterateFiles(inputDir, new String[]{_pdl}, true);\n+    while(iterator.hasNext())\n+    {\n+      File inputFile = iterator.next();\n+      DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverPath);\n+      PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+      parser.parse(new FileInputStream(inputFile));\n+      if (parser.hasError())\n+      {\n+        _logger.error(parser.errorMessage());\n+        System.exit(1);\n+      }\n+\n+      List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+      if (topLevelDataSchemas == null || topLevelDataSchemas.isEmpty() || topLevelDataSchemas.size() > 1)\n+      {\n+        _logger.error(\"Could not parse extension schema : \" + inputFile.getAbsolutePath());\n+        System.exit(1);\n+      }\n+      DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+      if (!(topLevelDataSchema instanceof NamedDataSchema))\n+      {\n+        _logger.error(\"Invalid extension schema : \" + inputFile.getAbsolutePath());", "originalCommit": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQwNjEyMw==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r399406123", "bodyText": "Updated the log.", "author": "nickibi", "createdAt": "2020-03-27T16:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMTQ2Nw==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398331467", "bodyText": "\"dot\" needs to be at the beginning of the line", "author": "junchuanwang", "createdAt": "2020-03-26T05:51:19Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidation.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.data;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ExtensionSchemaValidation\n+{\n+  private static final Logger _logger = LoggerFactory.getLogger(ExtensionSchemaValidation.class);\n+  private static final Options _options = new Options();\n+  private static final String _pdl = \"pdl\";\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    try {\n+      final CommandLineParser parser = new GnuParser();\n+      CommandLine cl = parser.parse(_options, args);\n+\n+      if (cl.hasOption('h'))\n+      {\n+        help();\n+        System.exit(0);\n+      }\n+\n+      String[] cliArgs = cl.getArgs();\n+      if (cliArgs.length != 2)\n+      {\n+        _logger.error(\"Wrong argument given\");\n+        help();\n+        System.exit(1);\n+      }\n+      int i = 0;\n+      String resolverPath = cliArgs[i++];\n+      String inputPath = cliArgs[i];\n+\n+      File inputDir = new File(inputPath);\n+\n+      if (!inputDir.exists() || !inputDir.canRead()) {\n+        _logger.error(\"Input directory does not exist or cannot be read: \" + inputDir.getAbsolutePath());\n+        System.exit(1);\n+      }\n+\n+      parseAndValidateExtensionSchemas(resolverPath, inputDir);\n+    }\n+    catch (ParseException e)\n+    {\n+      _logger.error(\"Invalid arguments: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+  }\n+\n+  private static void parseAndValidateExtensionSchemas(String resolverPath, File inputDir) throws IOException\n+  {\n+    // Parse each extension schema and validate it\n+    Iterator<File> iterator = FileUtils.iterateFiles(inputDir, new String[]{_pdl}, true);\n+    while(iterator.hasNext())\n+    {\n+      File inputFile = iterator.next();\n+      DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverPath);\n+      PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+      parser.parse(new FileInputStream(inputFile));\n+      if (parser.hasError())\n+      {\n+        _logger.error(parser.errorMessage());\n+        System.exit(1);\n+      }\n+\n+      List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+      if (topLevelDataSchemas == null || topLevelDataSchemas.isEmpty() || topLevelDataSchemas.size() > 1)\n+      {\n+        _logger.error(\"Could not parse extension schema : \" + inputFile.getAbsolutePath());\n+        System.exit(1);\n+      }\n+      DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+      if (!(topLevelDataSchema instanceof NamedDataSchema))\n+      {\n+        _logger.error(\"Invalid extension schema : \" + inputFile.getAbsolutePath());\n+        System.exit(1);\n+      }\n+      if (!((NamedDataSchema) topLevelDataSchema).getFullName().endsWith(\"Extensions\"))\n+      {\n+        _logger.error(\"Invalid extension schema name : [{}]. The name of the extension schema must be <baseSchemaName> + 'Extensions'\", ((NamedDataSchema) topLevelDataSchema).getFullName());\n+        System.exit(1);\n+      }\n+\n+      List<NamedDataSchema> includes = ((RecordDataSchema)topLevelDataSchema).getInclude();\n+      // TODO: Check includes schemas can only be the resource schemas\n+\n+      List<RecordDataSchema.Field> extensionSchemaFields = ((RecordDataSchema)topLevelDataSchema).getFields().\n+          stream().", "originalCommit": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMTY5OA==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r398331698", "bodyText": "uncessary parenthesis, also can be add to last line, no need to split", "author": "junchuanwang", "createdAt": "2020-03-26T05:52:08Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidation.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.data;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaResolver;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.grammar.PdlSchemaParser;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.GnuParser;\n+import org.apache.commons.cli.HelpFormatter;\n+import org.apache.commons.cli.OptionBuilder;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.io.FileUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ExtensionSchemaValidation\n+{\n+  private static final Logger _logger = LoggerFactory.getLogger(ExtensionSchemaValidation.class);\n+  private static final Options _options = new Options();\n+  private static final String _pdl = \"pdl\";\n+\n+  static\n+  {\n+    _options.addOption(OptionBuilder.withLongOpt(\"help\")\n+        .withDescription(\"Print help\")\n+        .create('h'));\n+  }\n+\n+  public static void main(String[] args) throws Exception\n+  {\n+    try {\n+      final CommandLineParser parser = new GnuParser();\n+      CommandLine cl = parser.parse(_options, args);\n+\n+      if (cl.hasOption('h'))\n+      {\n+        help();\n+        System.exit(0);\n+      }\n+\n+      String[] cliArgs = cl.getArgs();\n+      if (cliArgs.length != 2)\n+      {\n+        _logger.error(\"Wrong argument given\");\n+        help();\n+        System.exit(1);\n+      }\n+      int i = 0;\n+      String resolverPath = cliArgs[i++];\n+      String inputPath = cliArgs[i];\n+\n+      File inputDir = new File(inputPath);\n+\n+      if (!inputDir.exists() || !inputDir.canRead()) {\n+        _logger.error(\"Input directory does not exist or cannot be read: \" + inputDir.getAbsolutePath());\n+        System.exit(1);\n+      }\n+\n+      parseAndValidateExtensionSchemas(resolverPath, inputDir);\n+    }\n+    catch (ParseException e)\n+    {\n+      _logger.error(\"Invalid arguments: \" + e.getMessage());\n+      System.exit(1);\n+    }\n+  }\n+\n+  private static void parseAndValidateExtensionSchemas(String resolverPath, File inputDir) throws IOException\n+  {\n+    // Parse each extension schema and validate it\n+    Iterator<File> iterator = FileUtils.iterateFiles(inputDir, new String[]{_pdl}, true);\n+    while(iterator.hasNext())\n+    {\n+      File inputFile = iterator.next();\n+      DataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(resolverPath);\n+      PdlSchemaParser parser = new PdlSchemaParser(resolver);\n+      parser.parse(new FileInputStream(inputFile));\n+      if (parser.hasError())\n+      {\n+        _logger.error(parser.errorMessage());\n+        System.exit(1);\n+      }\n+\n+      List<DataSchema> topLevelDataSchemas = parser.topLevelDataSchemas();\n+      if (topLevelDataSchemas == null || topLevelDataSchemas.isEmpty() || topLevelDataSchemas.size() > 1)\n+      {\n+        _logger.error(\"Could not parse extension schema : \" + inputFile.getAbsolutePath());\n+        System.exit(1);\n+      }\n+      DataSchema topLevelDataSchema = topLevelDataSchemas.get(0);\n+      if (!(topLevelDataSchema instanceof NamedDataSchema))\n+      {\n+        _logger.error(\"Invalid extension schema : \" + inputFile.getAbsolutePath());\n+        System.exit(1);\n+      }\n+      if (!((NamedDataSchema) topLevelDataSchema).getFullName().endsWith(\"Extensions\"))\n+      {\n+        _logger.error(\"Invalid extension schema name : [{}]. The name of the extension schema must be <baseSchemaName> + 'Extensions'\", ((NamedDataSchema) topLevelDataSchema).getFullName());\n+        System.exit(1);\n+      }\n+\n+      List<NamedDataSchema> includes = ((RecordDataSchema)topLevelDataSchema).getInclude();\n+      // TODO: Check includes schemas can only be the resource schemas\n+\n+      List<RecordDataSchema.Field> extensionSchemaFields = ((RecordDataSchema)topLevelDataSchema).getFields().\n+          stream().\n+          filter(\n+              f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))", "originalCommit": "f0209d8176af3a4ea0e1b88e3bc32ce4c7596df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQwNzQ0MQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r399407441", "bodyText": "Can you please explain \"unnecessary parenthesis\"? I don't see any.", "author": "nickibi", "createdAt": "2020-03-27T16:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMTY5OA=="}], "type": "inlineReview"}, {"oid": "9a3e8f3731ea3a6eadac85d0f042fc23d80d6fa7", "url": "https://github.com/linkedin/rest.li/commit/9a3e8f3731ea3a6eadac85d0f042fc23d80d6fa7", "message": "Add extensionSchema validation task\n - this PR is doing basic schema validation, the field annoation validation will be done in a following PR.", "committedDate": "2020-03-30T20:44:57Z", "type": "commit"}, {"oid": "2bd9d7eb96cd6e68219858013ed727fa14368945", "url": "https://github.com/linkedin/rest.li/commit/2bd9d7eb96cd6e68219858013ed727fa14368945", "message": "Add extension schema validation tasks\nUpdate Pegesus plugin", "committedDate": "2020-03-30T20:44:57Z", "type": "commit"}, {"oid": "dd4c860468f4e0345df13211c23e450d9c7b5355", "url": "https://github.com/linkedin/rest.li/commit/dd4c860468f4e0345df13211c23e450d9c7b5355", "message": "Address code review feedback", "committedDate": "2020-03-30T20:44:57Z", "type": "commit"}, {"oid": "c836db9a3bb5d046bfeae6464b96bdd7e8d3b3f0", "url": "https://github.com/linkedin/rest.li/commit/c836db9a3bb5d046bfeae6464b96bdd7e8d3b3f0", "message": "Update ExtensionSchemaValidation class name to ExtensionSchemaValidationCmdLineApp", "committedDate": "2020-03-30T20:44:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNjExMQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r400606111", "bodyText": "I'd rename this to configureExtensionSchemaValidationAndPublishTasks as this is not just validating (also publishing jars)", "author": "karthikbalasub", "createdAt": "2020-03-31T02:29:57Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/PegasusPlugin.java", "diffHunk": "@@ -913,6 +921,41 @@ protected void configureGeneratedSourcesAndJavadoc(Project project)\n     }\n   }\n \n+  protected void configureExtensionSchemaValidation(Project project, SourceSet sourceSet)", "originalCommit": "f25ff7e26e5fd7c0037fcd21bc4448d4a48c139e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyMzM0MQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r400623341", "bodyText": "Renamed this to configureExtensionSchemaValidationAndPublishTasks", "author": "nickibi", "createdAt": "2020-03-31T03:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNjExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNzQ5OQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r400607499", "bodyText": "li-pegasus (in opensource)", "author": "karthikbalasub", "createdAt": "2020-03-31T02:35:34Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/tasks/ValidateExtensionSchemaTask.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.pegasus.gradle.tasks;\n+\n+import com.linkedin.pegasus.gradle.PathingJarUtil;\n+import com.linkedin.pegasus.gradle.PegasusPlugin;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.gradle.api.DefaultTask;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.file.FileTree;\n+import org.gradle.api.tasks.CacheableTask;\n+import org.gradle.api.tasks.Classpath;\n+import org.gradle.api.tasks.InputDirectory;\n+import org.gradle.api.tasks.PathSensitive;\n+import org.gradle.api.tasks.PathSensitivity;\n+import org.gradle.api.tasks.SkipWhenEmpty;\n+import org.gradle.api.tasks.TaskAction;\n+\n+import static com.linkedin.pegasus.gradle.SharedFileUtils.*;\n+\n+/**\n+ * Validate extension schemas.\n+ *\n+ * To use this plugin, add these three lines to your build.gradle:\n+ * <pre>\n+ * apply plugin: 'li-pegasus2'", "originalCommit": "f25ff7e26e5fd7c0037fcd21bc4448d4a48c139e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYxNDQzOQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r400614439", "bodyText": "Do you mean I should remove this part?", "author": "nickibi", "createdAt": "2020-03-31T03:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNzQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYyMzE3NQ==", "url": "https://github.com/linkedin/rest.li/pull/235#discussion_r400623175", "bodyText": "Updated the doc to use \"li-pegasus\" instead.", "author": "nickibi", "createdAt": "2020-03-31T03:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNzQ5OQ=="}], "type": "inlineReview"}, {"oid": "a516efd98aca8832b106a19f96dd293aab584803", "url": "https://github.com/linkedin/rest.li/commit/a516efd98aca8832b106a19f96dd293aab584803", "message": "Add extensionSchema validation task\n - this PR is doing basic schema validation, the field annoation validation will be done in a following PR.", "committedDate": "2020-03-31T03:47:53Z", "type": "commit"}, {"oid": "5dcf4db120f7d2660732a68462ea9dd54b8fc2c3", "url": "https://github.com/linkedin/rest.li/commit/5dcf4db120f7d2660732a68462ea9dd54b8fc2c3", "message": "Add extension schema validation tasks\nUpdate Pegesus plugin", "committedDate": "2020-03-31T03:49:17Z", "type": "commit"}, {"oid": "d993fd0cde4feeef376122e8342050d44fe93a35", "url": "https://github.com/linkedin/rest.li/commit/d993fd0cde4feeef376122e8342050d44fe93a35", "message": "Address code review feedback", "committedDate": "2020-03-31T03:49:20Z", "type": "commit"}, {"oid": "949f9c490b0350a145812fb2cc9ad5a3eb0c2859", "url": "https://github.com/linkedin/rest.li/commit/949f9c490b0350a145812fb2cc9ad5a3eb0c2859", "message": "Update ExtensionSchemaValidation class name to ExtensionSchemaValidationCmdLineApp", "committedDate": "2020-03-31T03:49:20Z", "type": "commit"}, {"oid": "949f9c490b0350a145812fb2cc9ad5a3eb0c2859", "url": "https://github.com/linkedin/rest.li/commit/949f9c490b0350a145812fb2cc9ad5a3eb0c2859", "message": "Update ExtensionSchemaValidation class name to ExtensionSchemaValidationCmdLineApp", "committedDate": "2020-03-31T03:49:20Z", "type": "forcePushed"}]}