{"pr_number": 448, "pr_title": "Improve translate schema task performance.", "pr_createdAt": "2020-10-15T11:08:55Z", "pr_url": "https://github.com/linkedin/rest.li/pull/448", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTI0OA==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505461248", "bodyText": "can we print schema location (or path) with the error?", "author": "aman1309", "createdAt": "2020-10-15T11:17:58Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        // Skip source files not matching the format specified.\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)\n+      {\n+        NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+        String schemaFullname = namedDataSchema.getFullName();\n+        LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, location.getSourceFile().getAbsolutePath());\n+        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(namedDataSchema, location.getSourceFile(), encode(schema)));\n+      }\n+      else\n+      {\n+        LOGGER.error(\"Parsed a non-named schema as top-level schema.\");", "originalCommit": "41cbc914e380964b7a537015624da4c2e5e9b6d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Njc2Mg==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505466762", "bodyText": "I believe that was handled during source parsing", "author": "junchuanwang", "createdAt": "2020-10-15T11:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2ODM3Mg==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505768372", "bodyText": "Yeah, this is just to keep the logic complete. The internal logic only adds Named schemas to parse result. Sadly, changing that API touched too many places, so I didn't include it here.\nAdded the location to the log anyways.", "author": "karthikbalasub", "createdAt": "2020-10-15T18:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2MTI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Njk5Ng==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505466996", "bodyText": "Is this error covered after this change?", "author": "junchuanwang", "createdAt": "2020-10-15T11:28:53Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -345,46 +346,6 @@ private void writeTranslatedSchemasToDirectory(\n     }\n   }\n \n-  private static NamedDataSchema checkForErrorsAndGetTopLevelSchema(\n-      File file, String schemaFullname, PegasusSchemaParser parser, StringBuilder errorMessages)\n-  {\n-    StringBuilder errorMessageBuilder = parser.errorMessageBuilder();\n-    if (errorMessageBuilder.length() > 0)\n-    {\n-      errorMessages.append(\"Failed to parse schema: \")\n-          .append(file.getAbsolutePath())\n-          .append(\"\\nfullname: \")\n-          .append(schemaFullname)\n-          .append(\"\\nerrors: \")\n-          .append(errorMessageBuilder.toString())\n-          .append(\"\\n\");\n-      return null;\n-    }\n-    List<DataSchema> topLevelSchemas = parser.topLevelDataSchemas();\n-    if (topLevelSchemas.size() != 1)\n-    {\n-      errorMessages.append(\"Expected one top level schema for: \")\n-          .append(file.getAbsolutePath())\n-          .append(\" but got \")\n-          .append(topLevelSchemas.size())\n-          .append(\" schemas.\")\n-          .append(\"\\n\");\n-      return  null;\n-    }\n-    DataSchema sourceSchema = topLevelSchemas.get(0);\n-    if (!(sourceSchema instanceof NamedDataSchema) ||\n-        !((NamedDataSchema) sourceSchema).getFullName().equals(schemaFullname))\n-    {\n-      errorMessages.append(\"Parsed top-level schema does not match the schema file name. File: \")", "originalCommit": "41cbc914e380964b7a537015624da4c2e5e9b6d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2NTEyOA==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505765128", "bodyText": "Yes, done here: https://github.com/linkedin/rest.li/blob/master/generator/src/main/java/com/linkedin/pegasus/generator/FileFormatDataSchemaParser.java#L177", "author": "karthikbalasub", "createdAt": "2020-10-15T18:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQ2Njk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0NzY3Nw==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505647677", "bodyText": "nit: space after for", "author": "nickibi", "createdAt": "2020-10-15T15:43:40Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())", "originalCommit": "41cbc914e380964b7a537015624da4c2e5e9b6d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwNjExMg==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505706112", "bodyText": "Dont we have style check automatically?", "author": "BrianPin", "createdAt": "2020-10-15T17:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0NzY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2NzY3NA==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505767674", "bodyText": "no automated style checks in pegasus", "author": "karthikbalasub", "createdAt": "2020-10-15T18:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0NzY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505668296", "bodyText": "Parsing schemas in this way, we may not get expected result.\nDataSchemaParser.ParseResult (parsedSources) also contains embedded name schemas which are unnecessary to be top level schemas.", "author": "nickibi", "createdAt": "2020-10-15T16:12:44Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        // Skip source files not matching the format specified.\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)", "originalCommit": "41cbc914e380964b7a537015624da4c2e5e9b6d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2MTA3OA==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505761078", "bodyText": "+1, please consider the side effect of generated non-top level files", "author": "BrianPin", "createdAt": "2020-10-15T18:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2NjE1Mg==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505766152", "bodyText": "ParseResult will not contain nested schemas. See relevant logic here:\n\n  \n    \n      rest.li/generator/src/main/java/com/linkedin/pegasus/generator/FileFormatDataSchemaParser.java\n    \n    \n         Line 259\n      in\n      74121d5\n    \n    \n    \n    \n\n        \n          \n           return parser.topLevelDataSchemas(); \n        \n    \n  \n\n\nIt only adds top-level schemas to the parse result.", "author": "karthikbalasub", "createdAt": "2020-10-15T18:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc3ODIzNg==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505778236", "bodyText": "Look at here: \n  \n    \n      rest.li/generator/src/main/java/com/linkedin/pegasus/generator/FileFormatDataSchemaParser.java\n    \n    \n         Line 139\n      in\n      894952a\n    \n    \n    \n    \n\n        \n          \n           result.getSchemaAndLocations().put(schema, entry.getValue()); \n        \n    \n  \n\n.", "author": "nickibi", "createdAt": "2020-10-15T19:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwNDA2Nw==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505904067", "bodyText": "I think ybi means in the end of the parsing process, there will still be more non-top level schemas", "author": "BrianPin", "createdAt": "2020-10-15T22:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyODIwMw==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r510528203", "bodyText": "Good catch. Infact the schema translator tests were failing because of that!\nFixed the logic now to check for top level schemas and also ignore schemas loaded from resolver path (not in source dir).", "author": "karthikbalasub", "createdAt": "2020-10-23T00:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNDA3OQ==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r510534079", "bodyText": "In the isTopLevelSchema method, we have already checked whether schema is NamedDataSchema, do we still need to do the same check here?", "author": "nickibi", "createdAt": "2020-10-23T00:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNTMzMw==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r510535333", "bodyText": "removed the check, it was redundant.", "author": "karthikbalasub", "createdAt": "2020-10-23T00:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY2ODI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5OTk1NQ==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505899955", "bodyText": "Is it worth to just skip the error and keep looping?", "author": "BrianPin", "createdAt": "2020-10-15T22:28:46Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,32 +209,31 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for(Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        // Skip source files not matching the format specified.\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)\n+      {\n+        NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+        String schemaFullname = namedDataSchema.getFullName();\n+        LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, location.getSourceFile().getAbsolutePath());\n+        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(namedDataSchema, location.getSourceFile(), encode(schema)));\n+      }\n+      else\n+      {\n+        LOGGER.error(\"Parsed a non-named schema as top-level schema.\");\n+        System.exit(1);", "originalCommit": "41cbc914e380964b7a537015624da4c2e5e9b6d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwMTQ5OQ==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r505901499", "bodyText": "No, it is a translator. It should have 1 to 1 translation. If there is a non-named schema as a top level schema, it means something wrong. We should throw exception not skip it.", "author": "nickibi", "createdAt": "2020-10-15T22:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5OTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyODQ4Mw==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r510528483", "bodyText": "This check is mainly a failsafe. The DataSchemaParse::parseSources logic already checks for this and includes errors for all schemas, so this would never be hit.", "author": "karthikbalasub", "createdAt": "2020-10-23T00:14:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5OTk1NQ=="}], "type": "inlineReview"}, {"oid": "30d9a5afed3971be1dec2b8f42cc28a0787e19fe", "url": "https://github.com/linkedin/rest.li/commit/30d9a5afed3971be1dec2b8f42cc28a0787e19fe", "message": "Address review comments", "committedDate": "2020-10-23T00:10:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUzNDA5MQ==", "url": "https://github.com/linkedin/rest.li/pull/448#discussion_r510534091", "bodyText": "nit: remove extra line", "author": "nickibi", "createdAt": "2020-10-23T00:38:02Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/SchemaFormatTranslator.java", "diffHunk": "@@ -207,36 +206,67 @@ private void translateFiles() throws IOException, InterruptedException\n   private Map<String, SchemaInfo> getTopLevelSchemaToTranslatedSchemaMap() throws IOException\n   {\n     Map<String, SchemaInfo> topLevelTranslatedSchemas = new HashMap<>();\n+    DataSchemaParser dataSchemaParser = new DataSchemaParser(_resolverPath);\n+    DataSchemaParser.ParseResult parsedSources = dataSchemaParser.parseSources(\n+        new String[]{_sourceDir.getAbsolutePath()});\n \n-    Iterator<File> iter = FileUtils.iterateFiles(_sourceDir, new String[]{_sourceFormat}, true);\n-    StringBuilder errorMessages = new StringBuilder();\n-    while(iter.hasNext())\n+    for (Map.Entry<DataSchema, DataSchemaLocation> entry : parsedSources.getSchemaAndLocations().entrySet())\n     {\n-      File sourceFile = iter.next();\n-      String relativePath = _sourceDir.toURI().relativize(sourceFile.toURI()).getPath();\n-      String relativeMinusExt = trimFileExtension(relativePath);\n-      String schemaFullname = relativeMinusExt.replace(File.separatorChar, '.');\n-\n-      // When translating files 1:1, a new resolver and parser are required for each file translated\n-      // so that a single top level output schema is matched to each input file.\n-      MultiFormatDataSchemaResolver resolver = MultiFormatDataSchemaResolver.withBuiltinFormats(_resolverPath);\n-      PegasusSchemaParser parser = AbstractSchemaParser.parserForFileExtension(_sourceFormat, resolver);\n-      parser.parse(new FileInputStream(sourceFile));\n-      LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, sourceFile.getAbsolutePath());\n-      NamedDataSchema schema = checkForErrorsAndGetTopLevelSchema(sourceFile, schemaFullname, parser, errorMessages);\n-      if (schema != null)\n+      DataSchema schema = entry.getKey();\n+      DataSchemaLocation location = entry.getValue();\n+      // DataSchemaParse::parseSources returns all schemas from the source dir and the schemas referenced by it.\n+      // For translation we need to skip the following schemas:\n+      //   - From source files not matching the source format specified.\n+      //   - Schemas not loaded from the source dir provided as input.\n+      //   - Nested schemas.\n+      if (!location.getSourceFile().getAbsolutePath().endsWith(_sourceFormat) ||\n+          !location.toString().startsWith(_sourceDir.getAbsolutePath()) ||\n+          !isTopLevelSchema(schema, location))\n       {\n-        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(schema, sourceFile, encode(schema)));\n+        continue;\n+      }\n+      if (schema instanceof NamedDataSchema)\n+      {\n+        NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+        String schemaFullname = namedDataSchema.getFullName();\n+        LOGGER.debug(\"Loaded source schema: {}, from location: {}\", schemaFullname, location.getSourceFile().getAbsolutePath());\n+        topLevelTranslatedSchemas.put(schemaFullname, new SchemaInfo(namedDataSchema, location.getSourceFile(), encode(schema)));\n+      }\n+      else\n+      {\n+        LOGGER.error(\"Parsed a non-named schema as top-level schema. Location: {}\", location.getSourceFile().getAbsolutePath());\n+        System.exit(1);\n       }\n     }\n-    if (errorMessages.length() > 0)\n+    return topLevelTranslatedSchemas;\n+  }\n+\n+  /**\n+   * Returns true if the schema name matches the file name of the location, indicating the schema is a top-level\n+   * schema.\n+   */\n+  private boolean isTopLevelSchema(DataSchema schema, DataSchemaLocation location)\n+  {\n+    if (!(schema instanceof NamedDataSchema))\n     {\n-      LOGGER.error(errorMessages.toString());\n-      System.exit(1);\n+      // Top-level schemas should be named.\n+      return false;\n     }\n-    return topLevelTranslatedSchemas;\n+    NamedDataSchema namedDataSchema = (NamedDataSchema) schema;\n+    String namespace = namedDataSchema.getNamespace();\n+    String path = location.toString();\n+    if (!FileUtil.removeFileExtension(path.substring(path.lastIndexOf(File.separator) + 1)).equalsIgnoreCase(namedDataSchema.getName()))\n+    {\n+      // Schema name didn't match.\n+      return false;\n+    }\n+\n+    final String parent = path.substring(0, path.lastIndexOf(File.separator));\n+    // Finally check if namespace matches.\n+    return parent.endsWith(namespace.replace('.', File.separatorChar));\n   }\n \n+", "originalCommit": "30d9a5afed3971be1dec2b8f42cc28a0787e19fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5cb65762092773d8e8694ba1feb613a98a2fd3ab", "url": "https://github.com/linkedin/rest.li/commit/5cb65762092773d8e8694ba1feb613a98a2fd3ab", "message": "Release 29.7.13", "committedDate": "2020-10-23T00:43:33Z", "type": "forcePushed"}, {"oid": "7db1afbd4bd64aaa95db9619b45f3e8dc083c712", "url": "https://github.com/linkedin/rest.li/commit/7db1afbd4bd64aaa95db9619b45f3e8dc083c712", "message": "Improve translate schema task performance by parsing all source files\ntogether. This avoids loading the schemas multiple times.", "committedDate": "2020-10-23T01:32:11Z", "type": "commit"}, {"oid": "4f16cb05993e4dffe8a89db07d3fb38bf18f3c52", "url": "https://github.com/linkedin/rest.li/commit/4f16cb05993e4dffe8a89db07d3fb38bf18f3c52", "message": "Address review comments", "committedDate": "2020-10-23T01:32:11Z", "type": "commit"}, {"oid": "0b5035c98115c7b9cf5182b42d45bdd321c64b17", "url": "https://github.com/linkedin/rest.li/commit/0b5035c98115c7b9cf5182b42d45bdd321c64b17", "message": "Address review comments", "committedDate": "2020-10-23T01:32:11Z", "type": "commit"}, {"oid": "159119379b06313a49a96ff5ac60e4310babcb12", "url": "https://github.com/linkedin/rest.li/commit/159119379b06313a49a96ff5ac60e4310babcb12", "message": "Release 29.7.14", "committedDate": "2020-10-23T01:32:43Z", "type": "commit"}, {"oid": "159119379b06313a49a96ff5ac60e4310babcb12", "url": "https://github.com/linkedin/rest.li/commit/159119379b06313a49a96ff5ac60e4310babcb12", "message": "Release 29.7.14", "committedDate": "2020-10-23T01:32:43Z", "type": "forcePushed"}]}