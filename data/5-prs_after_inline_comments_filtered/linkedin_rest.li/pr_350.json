{"pr_number": 350, "pr_title": "Improve performance of uri mask encoding and decoding", "pr_createdAt": "2020-07-17T09:45:19Z", "pr_url": "https://github.com/linkedin/rest.li/pull/350", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDI1OQ==", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457724259", "bodyText": "although i like this coding style, but it seems it is not consistent with rest of the code.", "author": "BrianPin", "createdAt": "2020-07-20T22:20:27Z", "path": "data-transform/src/main/java/com/linkedin/data/transform/filter/MaskComposition.java", "diffHunk": "@@ -90,6 +90,11 @@ public void interpret(InterpreterContext instrCtx)\n                          instrCtx);\n           }\n         }\n+        // This can happen if the mask is for an array field and the merged start/count resulted in default values.\n+        // Setting the wildcard mask to represent all items are included.\n+        if (data.isEmpty()) {", "originalCommit": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDM1NA==", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457724354", "bodyText": "I mean the left bracket should be in a new line", "author": "BrianPin", "createdAt": "2020-07-20T22:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkzNDIxOQ==", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457934219", "bodyText": "Fixed.", "author": "karthikbalasub", "createdAt": "2020-07-21T08:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzcyNDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczNzk3OQ==", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457737979", "bodyText": "This is more like a question, nextToken is set when we see a comma ',',  and this while loop is condition to enter when the nextToken is set to -1. Do we design to process only the token before comma ','?\nIf the token list looks like \"token1, token2\"  then it seems this token2 is not going to be processed or I missed the fact that the use case will not happen.", "author": "BrianPin", "createdAt": "2020-07-20T22:57:44Z", "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "diffHunk": "@@ -115,137 +110,162 @@ else if (entry.getValue()\n    * @param toparse StringBuilder containing a string representation of an encoded MaskTree\n    * @return a MaskTree\n    * @throws IllegalMaskException if syntax in the input is malformed\n+   * @deprecated use {@link #decodeMaskUriFormat(String)} instead.\n    */\n+  @Deprecated\n   public static MaskTree decodeMaskUriFormat(StringBuilder toparse) throws IllegalMaskException\n   {\n-    ParseState state = ParseState.PARSE_FIELDS;\n+    return decodeMaskUriFormat(toparse.toString());\n+  }\n \n+  /**\n+   * Return a {@link MaskTree} that is deserialized from the input projection mask string used in URI parameter. The\n+   * input projection string must have been URL decoded if the projection was part of a request URI.\n+   *\n+   * @param toparse String representing an encoded MaskTree\n+   * @return a MaskTree\n+   * @throws IllegalMaskException if syntax in the input is malformed\n+   */\n+  public static MaskTree decodeMaskUriFormat(String toparse) throws IllegalMaskException\n+  {\n+    ParseState state = ParseState.PARSE_FIELDS;\n+    int index = 0;\n     DataMap result = new DataMap();\n-    Deque<DataMap> stack = new ArrayDeque<DataMap>();\n+    Deque<DataMap> stack = new ArrayDeque<>();\n     stack.addLast(result);\n+    StringBuilder field = new StringBuilder();\n \n-    while (toparse.length() > 0)\n+    while (index < toparse.length())\n     {\n       switch (state)\n       {\n       case TRAVERSE:\n-        if (toparse.indexOf(\",\") != 0)\n+        if (toparse.charAt(index) != ',')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while traversing\");\n+              + toparse.substring(index) + \"' while traversing\");\n         }\n-        toparse.delete(0, 1);\n+        index++;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case DESCEND:\n-        if (toparse.indexOf(\":(\") != 0)\n+        if (toparse.charAt(index) != ':' || toparse.charAt(index + 1) != '(')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while descending\");\n+              + toparse.substring(index) + \"' while descending\");\n         }\n-        toparse.delete(0, 2);\n+        index += 2;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case PARSE_FIELDS:\n-\n-        Integer maskValue = null;\n-        if (toparse.charAt(0) == '-')\n+        Integer maskValue;\n+        if (toparse.charAt(index) == '-')\n         {\n           maskValue = MaskOperation.NEGATIVE_MASK_OP.getRepresentation();\n-          toparse.delete(0, 1);\n+          index++;\n         }\n         else\n         {\n           maskValue = MaskOperation.POSITIVE_MASK_OP.getRepresentation();\n         }\n \n         int nextToken = -1;\n-        StringBuilder field = new StringBuilder();\n-        for (int ii = 0; ii < toparse.length(); ++ii)\n+        field.setLength(0);\n+        int fieldIndex = index;\n+        for (; fieldIndex < toparse.length(); ++fieldIndex)\n         {\n-          char c = toparse.charAt(ii);\n+          char c = toparse.charAt(fieldIndex);\n           switch (c)\n           {\n           case ',':\n             state = ParseState.TRAVERSE;\n-            nextToken = ii;\n+            nextToken = fieldIndex;\n             break;\n           case ':':\n-            if (field.length() > 0 && (FilterConstants.START.equals(field.toString()) || FilterConstants.COUNT.equals(field.toString())))\n+            if ((fieldIndex + 1) >= toparse.length())\n+            {\n+              throw new IllegalMaskException(\"Malformed mask syntax: unexpected end of buffer after ':'\");\n+            }\n+            if ((field.length() == FilterConstants.START.length() && field.indexOf(FilterConstants.START) == 0)\n+                || (field.length() == FilterConstants.COUNT.length() && field.indexOf(FilterConstants.COUNT) == 0))\n             {\n-              if (!Character.isDigit(toparse.charAt(ii + 1)))\n+              if (!Character.isDigit(toparse.charAt(fieldIndex + 1)))\n               {\n                 throw new IllegalMaskException(\"Malformed mask syntax: unexpected range value\");\n               }\n \n-              ii++;\n+              fieldIndex++;\n \n               // Aggressively consume the numerical value for the range parameter as this is a special case.\n-              StringBuilder rangeValue = new StringBuilder();\n-              while (ii < toparse.length())\n+              int rangeValue = 0;\n+              while (fieldIndex < toparse.length() && nextToken == -1)", "originalCommit": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MTA3Mg==", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457941072", "bodyText": "This code block handles the start and count params in the projection.\nFor example: $*:(c),$start:2,$count:4\nWe are parsing for digits after we see the field name as \"$start\" or \"$count\" (see lines 189-190).\nSo we move to the next token if we see \",\" or \")\" (valid), parse the number if we see digit (valid) and anything else is invalid.", "author": "karthikbalasub", "createdAt": "2020-07-21T08:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczNzk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MTI1Nw==", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457941257", "bodyText": "This code block handles the start and count params in the projection.\nFor example: $*:(c),$start:2,$count:4\nWe are parsing for digits after we see the field name as \"$start\" or \"$count\" (see lines 189-190).\nSo we move to the next token if we see \",\" or \")\" (break the loop), parse the number if we see digit (valid) and anything else is invalid.", "author": "karthikbalasub", "createdAt": "2020-07-21T08:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzczNzk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc0NTA3MQ==", "url": "https://github.com/linkedin/rest.li/pull/350#discussion_r457745071", "bodyText": "check for index out of bounds", "author": "logancarmody", "createdAt": "2020-07-20T23:19:35Z", "path": "restli-common/src/main/java/com/linkedin/restli/internal/common/URIMaskUtil.java", "diffHunk": "@@ -115,137 +110,162 @@ else if (entry.getValue()\n    * @param toparse StringBuilder containing a string representation of an encoded MaskTree\n    * @return a MaskTree\n    * @throws IllegalMaskException if syntax in the input is malformed\n+   * @deprecated use {@link #decodeMaskUriFormat(String)} instead.\n    */\n+  @Deprecated\n   public static MaskTree decodeMaskUriFormat(StringBuilder toparse) throws IllegalMaskException\n   {\n-    ParseState state = ParseState.PARSE_FIELDS;\n+    return decodeMaskUriFormat(toparse.toString());\n+  }\n \n+  /**\n+   * Return a {@link MaskTree} that is deserialized from the input projection mask string used in URI parameter. The\n+   * input projection string must have been URL decoded if the projection was part of a request URI.\n+   *\n+   * @param toparse String representing an encoded MaskTree\n+   * @return a MaskTree\n+   * @throws IllegalMaskException if syntax in the input is malformed\n+   */\n+  public static MaskTree decodeMaskUriFormat(String toparse) throws IllegalMaskException\n+  {\n+    ParseState state = ParseState.PARSE_FIELDS;\n+    int index = 0;\n     DataMap result = new DataMap();\n-    Deque<DataMap> stack = new ArrayDeque<DataMap>();\n+    Deque<DataMap> stack = new ArrayDeque<>();\n     stack.addLast(result);\n+    StringBuilder field = new StringBuilder();\n \n-    while (toparse.length() > 0)\n+    while (index < toparse.length())\n     {\n       switch (state)\n       {\n       case TRAVERSE:\n-        if (toparse.indexOf(\",\") != 0)\n+        if (toparse.charAt(index) != ',')\n         {\n           throw new IllegalStateException(\"Internal Error parsing mask: unexpected parse buffer '\"\n-              + toparse + \"' while traversing\");\n+              + toparse.substring(index) + \"' while traversing\");\n         }\n-        toparse.delete(0, 1);\n+        index++;\n         state = ParseState.PARSE_FIELDS;\n         break;\n       case DESCEND:\n-        if (toparse.indexOf(\":(\") != 0)\n+        if (toparse.charAt(index) != ':' || toparse.charAt(index + 1) != '(')", "originalCommit": "0a9ca318ef601df83a2d4a5db83fb5ac6641879e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eeb97800d5ff09e20782e46fc7a2771e32cf88b9", "url": "https://github.com/linkedin/rest.li/commit/eeb97800d5ff09e20782e46fc7a2771e32cf88b9", "message": "Improve performance of uri mask encoding and decoding\n\nFixes the following issues:\nEncoding:\n - Projection parameters were first encoded using default logic and then\n   overwritten using the encoded value from URIMask encoding. Avoiding\nthe unnecessary double encoding for projection parameters.\n - During mask creation, we iterate through the entire datamap to\n   cleanup empty masks. Since {'a': 1 } and { 'a' : { '$*': 1} } are\nfunctionally equivalent, we can avoid the extra iteration by setting $*:\n1. This might increase the URI size, but the chance of someone using\narray start/count with default values for both is going to be very low,\nso doing this optimization makes sense.\n - During encoding a string is created for each sub datamap and then\n   appended to the parent string builder. This is avoided by passing in\nthe string builder to encode into.\nDecoding:\n - The decoding logic was poorly designed. It was deleting characters from\nthe front of string builder. This is avoided by checking chars from the\nstring builder.", "committedDate": "2020-07-22T06:01:33Z", "type": "commit"}, {"oid": "490cdf26324e3dac74887cbd6dc18236812f83b4", "url": "https://github.com/linkedin/rest.li/commit/490cdf26324e3dac74887cbd6dc18236812f83b4", "message": "Address review comments.", "committedDate": "2020-07-22T06:01:34Z", "type": "commit"}, {"oid": "29f289f1c806282980bedc06fdccc772b0ffaac0", "url": "https://github.com/linkedin/rest.li/commit/29f289f1c806282980bedc06fdccc772b0ffaac0", "message": "Update version and changelog.", "committedDate": "2020-07-22T06:03:01Z", "type": "commit"}, {"oid": "29f289f1c806282980bedc06fdccc772b0ffaac0", "url": "https://github.com/linkedin/rest.li/commit/29f289f1c806282980bedc06fdccc772b0ffaac0", "message": "Update version and changelog.", "committedDate": "2020-07-22T06:03:01Z", "type": "forcePushed"}]}