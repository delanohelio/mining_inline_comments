{"pr_number": 339, "pr_title": "Add PathSpecSet: a set of PathSpecSet with support for full projection", "pr_createdAt": "2020-06-23T15:58:44Z", "pr_url": "https://github.com/linkedin/rest.li/pull/339", "timeline": [{"oid": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "url": "https://github.com/linkedin/rest.li/commit/5c96e81dbe52a18bfae0084f36d3346de45e11ca", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set.", "committedDate": "2020-09-02T18:05:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTc3Mg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485099772", "bodyText": "braces on new line?", "author": "BrianPin", "createdAt": "2020-09-08T17:58:30Z", "path": "data-transform/src/main/java/com/linkedin/data/transform/filter/request/MaskCreator.java", "diffHunk": "@@ -57,6 +57,23 @@ public static MaskTree createPositiveMask(Collection<PathSpec> paths)\n     return createMaskTree(paths, MaskOperation.POSITIVE_MASK_OP);\n   }\n \n+  /**\n+   * Create a positive mask for the given set.\n+   *\n+   * @param pathSpecSet the set that should be in the mask\n+   * @return a {@link MaskTree}\n+   */\n+  public static MaskTree createPositiveMask(PathSpecSet pathSpecSet)\n+  {\n+    if (pathSpecSet.isFullProjection()) {", "originalCommit": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5OTM5NQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485199395", "bodyText": "Is there a code style I can refer to?", "author": "GuiForget", "createdAt": "2020-09-08T21:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzMzc2Mw==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485233763", "bodyText": "Good q. I think it has been left braces on next line ever since restli first version.\nAlthough I don't think there is strict rules regarding coding style, (for example, the line width)\nI just don't want to see in the future there will be many places where mixed type is happening inside the repo", "author": "BrianPin", "createdAt": "2020-09-08T22:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMDIzMg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r486710232", "bodyText": "Yeah, AFAIK the Rest.li code style isn't documented formally. It's just based on convention", "author": "evanw555", "createdAt": "2020-09-11T00:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTk4MQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485099981", "bodyText": "braces on new line?", "author": "BrianPin", "createdAt": "2020-09-08T17:58:53Z", "path": "data-transform/src/test/java/com/linkedin/data/transform/filter/TestMaskCreation.java", "diffHunk": "@@ -370,4 +372,34 @@ public void testComposingNegativeMaskWithPositiveSubmasks() throws IOException\n     mask.addOperation(new PathSpec(\"a\"), MaskOperation.NEGATIVE_MASK_OP);\n     Assert.assertEquals(mask.toString(), \"{a=0}\");\n   }\n+\n+  @Test(dataProvider = \"pathSpecSetProvider\")\n+  public void testPositiveMaskWithPathSpecSet(PathSpecSet input, MaskTree expected) {", "originalCommit": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTcyMQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r486709721", "bodyText": "+1. This is the convention in Rest.li", "author": "evanw555", "createdAt": "2020-09-11T00:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5OTk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcyNzczOQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485727739", "bodyText": "Might as well add copy-right file headers?", "author": "BrianPin", "createdAt": "2020-09-09T16:02:54Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;", "originalCommit": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTU4Mg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r486709582", "bodyText": "+1. Add copyright comment at the top of all new source files. See existing files for reference.", "author": "evanw555", "createdAt": "2020-09-11T00:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcyNzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1NDAxMA==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485854010", "bodyText": "remove the _ prefix (not the convention followed in this project)", "author": "karthikbalasub", "createdAt": "2020-09-09T19:17:38Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet {\n+  private final static PathSpecSet _EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet _FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);", "originalCommit": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1OTU5Nw==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485859597", "bodyText": "initialize size to parent path size + child path size", "author": "karthikbalasub", "createdAt": "2020-09-09T19:27:06Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet {\n+  private final static PathSpecSet _EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet _FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;\n+\n+  private PathSpecSet(Builder builder) {\n+    this(new HashSet<>(builder._pathSpecs), builder._fullProjection);\n+  }\n+\n+  private PathSpecSet(Set<PathSpec> pathSpecs, boolean fullProjection) {\n+    _pathSpecs = Collections.unmodifiableSet(pathSpecs);\n+    _fullProjection = fullProjection;\n+  }\n+\n+  /**\n+   * Create a new path spec set by copying the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(Collection<PathSpec> pathSpecs) {\n+    if (pathSpecs.isEmpty()) {\n+      return empty();\n+    } else {\n+      return new PathSpecSet(new HashSet<>(pathSpecs), false);\n+    }\n+  }\n+\n+  /**\n+   * Create a new path spec set from the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(PathSpec... pathSpecs) {\n+    return of(Arrays.asList(pathSpecs));\n+  }\n+\n+  /**\n+   * @return mutable builder to incrementally construct a {@link PathSpecSet}\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents an empty projection (no fields requested)\n+   */\n+  public static PathSpecSet empty() {\n+    return _EMPTY;\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents the user wants all fields (all fields requested)\n+   */\n+  public static PathSpecSet fullProjection() {\n+    return _FULL_PROJECTION;\n+  }\n+\n+  /**\n+   * @return null if a {@link #fullProjection()}, else wise a new {@link PathSpec} array for the projection. Intended to\n+   *         be used passed into rest.li builder's {@code fields} method.\n+   */\n+  public PathSpec[] toArray() {\n+    if (_fullProjection) {\n+      return null;\n+    }\n+    return _pathSpecs.toArray(new PathSpec[0]);\n+  }\n+\n+  /**\n+   * Creates a new mutable builder using this path spec set as a starting state\n+   *\n+   * @return a mutable builder\n+   */\n+  public Builder toBuilder() {\n+    return newBuilder().add(this);\n+  }\n+\n+  /**\n+   * @return underlying {@link PathSpec}s represented by this path spec set. Note that if this is a\n+   *         {@link #fullProjection()} this will be an empty set even though all fields are desired.\n+   */\n+  public Set<PathSpec> getPathSpecs() {\n+    return _pathSpecs;\n+  }\n+\n+  /**\n+   * @return if this is an {@link #empty()} path spec set (no fields requested)\n+   */\n+  public boolean isEmpty() {\n+    return _pathSpecs.isEmpty() && !_fullProjection;\n+  }\n+\n+  /**\n+   * @return if this is a path spec set representing the intent to retrieve all fields\n+   */\n+  public boolean isFullProjection() {\n+    return _fullProjection;\n+  }\n+\n+  /**\n+   * Return true if the {@link PathSpecSet} contains the input {@link PathSpec}.\n+   *\n+   * A {@link PathSpec} is always in a {@link PathSpecSet} if {@link PathSpecSet#isFullProjection()}.\n+   *\n+   * A {@link PathSpec} is in a {@link PathSpecSet} if {@link PathSpecSet#getPathSpecs()} contains the {@link PathSpec} or\n+   * any parent {@link PathSpec}.\n+   *\n+   * {@code\n+   * PathSpecSet.fullProjection().contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a().b()); // true\n+   * }\n+   *\n+   * @param pathSpec the input {@link PathSpec} to look for in the {@link PathSpecSet}\n+   * @return true if the input {@link PathSpec} is in this {@link PathSpecSet}\n+   */\n+  public boolean contains(PathSpec pathSpec) {\n+    if (_fullProjection) {\n+      return true;\n+    }\n+\n+    return IntStream.range(0, pathSpec.getPathComponents().size() + 1)\n+        .mapToObj(i -> new PathSpec(pathSpec.getPathComponents().subList(0, i).toArray(new String[0])))\n+        .anyMatch(_pathSpecs::contains);\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where the contained {@link PathSpec}s are scoped to the input parent\n+   * {@link PathSpec}.\n+   *\n+   * For example, suppose you have these models:\n+   * <pre>\n+   * {\n+   *   \"type\": \"Foo\",\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"bar\"\n+   *     },\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"baz\"\n+   *     }\n+   *   ]\n+   * }\n+   *\n+   * {\n+   *   \"type\": \"Zing\"\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"Foo\",\n+   *       \"name\": \"foo\"\n+   *     }\n+   *   ]\n+   * }\n+   * </pre>\n+   *\n+   * If you want to only fetch the \"bar\" field from a \"Zing\" record you might make a {@link PathSpecSet} like this:\n+   * {@code PathSpecSet.of(Zing.fields().foo().bar()}.\n+   *\n+   * However, suppose you already have a {@link PathSpecSet} from the perspective of \"Foo\" but need a\n+   * {@link PathSpecSet} for your \"Zing\" downstream.  This method make this easy:\n+   * {@code\n+   *   PathSpecSet fooPathSpecSet = PathSpecSet.of(Foo.fields().bar());\n+   *   PathSpecSet zingPathSpecSet = fooPathSpecSet.copyWithScope(Zing.fields().foo());\n+   *\n+   *   zingPathSpecSet.equals(PathSpecSet.of(Zing.fields().foo().bar()); // true\n+   * }\n+   *\n+   * If you scope an empty {@link PathSpecSet} it remains empty.\n+   *\n+   * @param parent the parent {@link PathSpec} to use when scoping the contained {@link PathSpec}s\n+   * @return a new {@link PathSpecSet} that is scoped to the new parent\n+   */\n+  public PathSpecSet copyWithScope(PathSpec parent) {\n+    if (this.isFullProjection()) {\n+      return PathSpecSet.of(parent);\n+    }\n+\n+    if (this.isEmpty()) {\n+      return PathSpecSet.empty();\n+    }\n+\n+    Builder builder = newBuilder();\n+\n+    this.getPathSpecs().stream()\n+        .map(childPathSpec -> {\n+          ArrayList<String> list = new ArrayList<>();", "originalCommit": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MTgzNA==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r485861834", "bodyText": "This should check for the prefix or any parent of the perfix, right?", "author": "karthikbalasub", "createdAt": "2020-09-09T19:30:06Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,377 @@\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet {\n+  private final static PathSpecSet _EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet _FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;\n+\n+  private PathSpecSet(Builder builder) {\n+    this(new HashSet<>(builder._pathSpecs), builder._fullProjection);\n+  }\n+\n+  private PathSpecSet(Set<PathSpec> pathSpecs, boolean fullProjection) {\n+    _pathSpecs = Collections.unmodifiableSet(pathSpecs);\n+    _fullProjection = fullProjection;\n+  }\n+\n+  /**\n+   * Create a new path spec set by copying the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(Collection<PathSpec> pathSpecs) {\n+    if (pathSpecs.isEmpty()) {\n+      return empty();\n+    } else {\n+      return new PathSpecSet(new HashSet<>(pathSpecs), false);\n+    }\n+  }\n+\n+  /**\n+   * Create a new path spec set from the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(PathSpec... pathSpecs) {\n+    return of(Arrays.asList(pathSpecs));\n+  }\n+\n+  /**\n+   * @return mutable builder to incrementally construct a {@link PathSpecSet}\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents an empty projection (no fields requested)\n+   */\n+  public static PathSpecSet empty() {\n+    return _EMPTY;\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents the user wants all fields (all fields requested)\n+   */\n+  public static PathSpecSet fullProjection() {\n+    return _FULL_PROJECTION;\n+  }\n+\n+  /**\n+   * @return null if a {@link #fullProjection()}, else wise a new {@link PathSpec} array for the projection. Intended to\n+   *         be used passed into rest.li builder's {@code fields} method.\n+   */\n+  public PathSpec[] toArray() {\n+    if (_fullProjection) {\n+      return null;\n+    }\n+    return _pathSpecs.toArray(new PathSpec[0]);\n+  }\n+\n+  /**\n+   * Creates a new mutable builder using this path spec set as a starting state\n+   *\n+   * @return a mutable builder\n+   */\n+  public Builder toBuilder() {\n+    return newBuilder().add(this);\n+  }\n+\n+  /**\n+   * @return underlying {@link PathSpec}s represented by this path spec set. Note that if this is a\n+   *         {@link #fullProjection()} this will be an empty set even though all fields are desired.\n+   */\n+  public Set<PathSpec> getPathSpecs() {\n+    return _pathSpecs;\n+  }\n+\n+  /**\n+   * @return if this is an {@link #empty()} path spec set (no fields requested)\n+   */\n+  public boolean isEmpty() {\n+    return _pathSpecs.isEmpty() && !_fullProjection;\n+  }\n+\n+  /**\n+   * @return if this is a path spec set representing the intent to retrieve all fields\n+   */\n+  public boolean isFullProjection() {\n+    return _fullProjection;\n+  }\n+\n+  /**\n+   * Return true if the {@link PathSpecSet} contains the input {@link PathSpec}.\n+   *\n+   * A {@link PathSpec} is always in a {@link PathSpecSet} if {@link PathSpecSet#isFullProjection()}.\n+   *\n+   * A {@link PathSpec} is in a {@link PathSpecSet} if {@link PathSpecSet#getPathSpecs()} contains the {@link PathSpec} or\n+   * any parent {@link PathSpec}.\n+   *\n+   * {@code\n+   * PathSpecSet.fullProjection().contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a().b()); // true\n+   * }\n+   *\n+   * @param pathSpec the input {@link PathSpec} to look for in the {@link PathSpecSet}\n+   * @return true if the input {@link PathSpec} is in this {@link PathSpecSet}\n+   */\n+  public boolean contains(PathSpec pathSpec) {\n+    if (_fullProjection) {\n+      return true;\n+    }\n+\n+    return IntStream.range(0, pathSpec.getPathComponents().size() + 1)\n+        .mapToObj(i -> new PathSpec(pathSpec.getPathComponents().subList(0, i).toArray(new String[0])))\n+        .anyMatch(_pathSpecs::contains);\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where the contained {@link PathSpec}s are scoped to the input parent\n+   * {@link PathSpec}.\n+   *\n+   * For example, suppose you have these models:\n+   * <pre>\n+   * {\n+   *   \"type\": \"Foo\",\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"bar\"\n+   *     },\n+   *     {\n+   *       \"type\": \"int\",\n+   *       \"name\": \"baz\"\n+   *     }\n+   *   ]\n+   * }\n+   *\n+   * {\n+   *   \"type\": \"Zing\"\n+   *   \"fields\": [\n+   *     {\n+   *       \"type\": \"Foo\",\n+   *       \"name\": \"foo\"\n+   *     }\n+   *   ]\n+   * }\n+   * </pre>\n+   *\n+   * If you want to only fetch the \"bar\" field from a \"Zing\" record you might make a {@link PathSpecSet} like this:\n+   * {@code PathSpecSet.of(Zing.fields().foo().bar()}.\n+   *\n+   * However, suppose you already have a {@link PathSpecSet} from the perspective of \"Foo\" but need a\n+   * {@link PathSpecSet} for your \"Zing\" downstream.  This method make this easy:\n+   * {@code\n+   *   PathSpecSet fooPathSpecSet = PathSpecSet.of(Foo.fields().bar());\n+   *   PathSpecSet zingPathSpecSet = fooPathSpecSet.copyWithScope(Zing.fields().foo());\n+   *\n+   *   zingPathSpecSet.equals(PathSpecSet.of(Zing.fields().foo().bar()); // true\n+   * }\n+   *\n+   * If you scope an empty {@link PathSpecSet} it remains empty.\n+   *\n+   * @param parent the parent {@link PathSpec} to use when scoping the contained {@link PathSpec}s\n+   * @return a new {@link PathSpecSet} that is scoped to the new parent\n+   */\n+  public PathSpecSet copyWithScope(PathSpec parent) {\n+    if (this.isFullProjection()) {\n+      return PathSpecSet.of(parent);\n+    }\n+\n+    if (this.isEmpty()) {\n+      return PathSpecSet.empty();\n+    }\n+\n+    Builder builder = newBuilder();\n+\n+    this.getPathSpecs().stream()\n+        .map(childPathSpec -> {\n+          ArrayList<String> list = new ArrayList<>();\n+          list.addAll(parent.getPathComponents());\n+          list.addAll(childPathSpec.getPathComponents());\n+          return list;\n+        })\n+        .map(PathSpec::new)\n+        .forEach(builder::add);\n+\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where only {@link PathSpec}s that are prefixed with the input {@link PathSpec} are retained.\n+   *\n+   * Additionally, the prefix is removed for the retained {@link PathSpec}s.\n+   *\n+   * Here are some examples showing the functionality:\n+   *\n+   * {@code\n+   *   // This PathSpecSet is empty because no PathSpecs originally contained start with \"abc\"\n+   *   PathSpecSet emptyPathSpecSet = PathSpecSet.of(Foo.fields().bar().baz()).copyAndRemovePrefix(Foo.fields().abc());\n+   *\n+   *   // This PathSpecSet is full because it contains the entire prefix PathSpec\n+   *   PathSpecSet fullPathSpecSet = PathSpecSet.of(Foo.fields().bar()).copyAndRemovePrefix(Foo.fields().bar())\n+   *\n+   *   // The following \"equals\" evaluates to true\n+   *   PathSpecSet prefixRemovedPathSpecSet = PathSpecSet.of(Foo.fields().bar().baz(), Foo.fields().bar().abc()).copyAndRemovePrefix(Foo.fields().bar());\n+   *   prefixRemovedPathSpecSet.equals(PathSpecSet.of(new PathSpec(\"baz\"), new PathSpec(\"abc\")));\n+   * }\n+   *\n+   * @param prefix the {@link PathSpec} prefix to use when retaining {@link PathSpec}s.\n+   * @return a {@link PathSpecSet} with elements starting with the input {@link PathSpec} prefix\n+   */\n+  public PathSpecSet copyAndRemovePrefix(PathSpec prefix) {\n+    if (isFullProjection() || isEmpty()) {\n+      // full or empty projections stay the same\n+      return this;\n+    }\n+\n+    // if we contain the exact prefix PathSpec, it should be a full projection\n+    if (getPathSpecs().contains(prefix)) {", "originalCommit": "5c96e81dbe52a18bfae0084f36d3346de45e11ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3MTYzMA==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r505871630", "bodyText": "yes you are correct. I'll modify accordingly", "author": "GuiForget", "createdAt": "2020-10-15T21:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2MTgzNA=="}], "type": "inlineReview"}, {"oid": "2784abab006e8f2c2c90925e51cb37131fa8bac6", "url": "https://github.com/linkedin/rest.li/commit/2784abab006e8f2c2c90925e51cb37131fa8bac6", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set.", "committedDate": "2020-10-16T22:00:15Z", "type": "forcePushed"}, {"oid": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "url": "https://github.com/linkedin/rest.li/commit/2c810667d15d73cfc38840fb82fc27a5c2caaf41", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set.", "committedDate": "2020-11-03T20:23:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MTU1Mw==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533041553", "bodyText": "nit: write records in PDL, not PDSC", "author": "evanw555", "createdAt": "2020-12-01T02:59:22Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet\n+{\n+  private final static PathSpecSet EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;\n+\n+  private PathSpecSet(Builder builder)\n+  {\n+    this(new HashSet<>(builder._pathSpecs), builder._fullProjection);\n+  }\n+\n+  private PathSpecSet(Set<PathSpec> pathSpecs, boolean fullProjection)\n+  {\n+    _pathSpecs = Collections.unmodifiableSet(pathSpecs);\n+    _fullProjection = fullProjection;\n+  }\n+\n+  /**\n+   * Create a new path spec set by copying the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(Collection<PathSpec> pathSpecs)\n+  {\n+    if (pathSpecs.isEmpty())\n+    {\n+      return empty();\n+    }\n+    else\n+    {\n+      return new PathSpecSet(new HashSet<>(pathSpecs), false);\n+    }\n+  }\n+\n+  /**\n+   * Create a new path spec set from the input {@code pathSpecs}.\n+   *\n+   * @param pathSpecs input path specs\n+   * @return immutable path spec set\n+   */\n+  public static PathSpecSet of(PathSpec... pathSpecs)\n+  {\n+    return of(Arrays.asList(pathSpecs));\n+  }\n+\n+  /**\n+   * @return mutable builder to incrementally construct a {@link PathSpecSet}\n+   */\n+  public static Builder newBuilder()\n+  {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents an empty projection (no fields requested)\n+   */\n+  public static PathSpecSet empty()\n+  {\n+    return EMPTY;\n+  }\n+\n+  /**\n+   * @return immutable path spec set that represents the user wants all fields (all fields requested)\n+   */\n+  public static PathSpecSet fullProjection()\n+  {\n+    return FULL_PROJECTION;\n+  }\n+\n+  /**\n+   * @return null if a {@link #fullProjection()}, else wise a new {@link PathSpec} array for the projection. Intended to\n+   *         be used passed into rest.li builder's {@code fields} method.\n+   */\n+  public PathSpec[] toArray()\n+  {\n+    if (_fullProjection)\n+    {\n+      return null;\n+    }\n+    return _pathSpecs.toArray(new PathSpec[0]);\n+  }\n+\n+  /**\n+   * Creates a new mutable builder using this path spec set as a starting state\n+   *\n+   * @return a mutable builder\n+   */\n+  public Builder toBuilder()\n+  {\n+    return newBuilder().add(this);\n+  }\n+\n+  /**\n+   * @return underlying {@link PathSpec}s represented by this path spec set. Note that if this is a\n+   *         {@link #fullProjection()} this will be an empty set even though all fields are desired.\n+   */\n+  public Set<PathSpec> getPathSpecs()\n+  {\n+    return _pathSpecs;\n+  }\n+\n+  /**\n+   * @return if this is an {@link #empty()} path spec set (no fields requested)\n+   */\n+  public boolean isEmpty()\n+  {\n+    return _pathSpecs.isEmpty() && !_fullProjection;\n+  }\n+\n+  /**\n+   * @return if this is a path spec set representing the intent to retrieve all fields\n+   */\n+  public boolean isFullProjection()\n+  {\n+    return _fullProjection;\n+  }\n+\n+  /**\n+   * Return true if the {@link PathSpecSet} contains the input {@link PathSpec}.\n+   *\n+   * A {@link PathSpec} is always in a {@link PathSpecSet} if {@link PathSpecSet#isFullProjection()}.\n+   *\n+   * A {@link PathSpec} is in a {@link PathSpecSet} if {@link PathSpecSet#getPathSpecs()} contains the {@link PathSpec} or\n+   * any parent {@link PathSpec}.\n+   *\n+   * {@code\n+   * PathSpecSet.fullProjection().contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a()); // true\n+   * PathSpecSet.of(SomeRecord.fields().a()).contains(SomeRecord.fields().a().b()); // true\n+   * }\n+   *\n+   * @param pathSpec the input {@link PathSpec} to look for in the {@link PathSpecSet}\n+   * @return true if the input {@link PathSpec} is in this {@link PathSpecSet}\n+   */\n+  public boolean contains(PathSpec pathSpec)\n+  {\n+    if (_fullProjection)\n+    {\n+      return true;\n+    }\n+\n+    return IntStream.range(0, pathSpec.getPathComponents().size() + 1)\n+        .mapToObj(i -> new PathSpec(pathSpec.getPathComponents().subList(0, i).toArray(new String[0])))\n+        .anyMatch(_pathSpecs::contains);\n+  }\n+\n+  /**\n+   * Return a copy of this {@link PathSpecSet} where the contained {@link PathSpec}s are scoped to the input parent\n+   * {@link PathSpec}.\n+   *\n+   * For example, suppose you have these models:\n+   * <pre>\n+   * {\n+   *   \"type\": \"Foo\",", "originalCommit": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODE2OQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068169", "bodyText": "For all javadocs in this class, I'd suggest providing examples using the serialized pathspec syntax (e.g. /foo/bar, /foo) for clarity, especially in more complicated examples (e.g. copy with scope, remove prefix)", "author": "evanw555", "createdAt": "2020-12-01T04:38:15Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**", "originalCommit": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4MjI3NQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r541782275", "bodyText": "I edited the javadoc, let me know if this is what you had in mind", "author": "GuiForget", "createdAt": "2020-12-12T21:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODE2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNzYyNg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r552937626", "bodyText": "Adding /foo directly into code segments may be confusing, as it's not proper Java syntax. However, I still think it's more clear to users. I originally meant adding this in addition to the code examples, like set of {/a} contains /a or something like that.", "author": "evanw555", "createdAt": "2021-01-06T20:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODIxMg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068212", "bodyText": "Should say 2020", "author": "evanw555", "createdAt": "2020-12-01T04:38:23Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.", "originalCommit": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODQzNQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068435", "bodyText": "typo: explicitly", "author": "evanw555", "createdAt": "2020-12-01T04:39:14Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),", "originalCommit": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4MjMwMg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r541782302", "bodyText": "I can't find the typo", "author": "GuiForget", "createdAt": "2020-12-12T21:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2ODg1MA==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533068850", "bodyText": "nit: capitalize as \"Rest.li\"", "author": "evanw555", "createdAt": "2020-12-01T04:40:29Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),", "originalCommit": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r533069668", "bodyText": "I'm skeptical about using the terminology \"full projection\", as PathSpecs are not inherently tied to Rest.li projections (that's just one application). However, one could make the argument that the term \"projection\" is a generic term and isn't implying that it's used for Rest.li projections. What do you think?\nI'm also curious to know how a \"full projection\" PathSpecSet is used. Do you have an example of one use case?", "author": "evanw555", "createdAt": "2020-12-01T04:43:58Z", "path": "data/src/main/java/com/linkedin/data/schema/PathSpecSet.java", "diffHunk": "@@ -0,0 +1,440 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.schema;\n+\n+import com.linkedin.data.template.RecordTemplate;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+\n+\n+/**\n+ * Represents an immutable set of {@link PathSpec}s.\n+ *\n+ * <p>Path spec set is a convenient wrapper for a collection of {@link PathSpec}. A few advantages of using this class\n+ * over manually passing around {@code Set<PathSpec>} is:\n+ *\n+ * <ul>\n+ *   <li>guaranteed immutable representation</li>\n+ *   <li>\n+ *     explicitly supports \"full projection\" which translates into fetch everything (default for rest.li resources),\n+ *     as well as \"empty\" which translates into fetch no fields\n+ *   </li>\n+ *   <li>mutable builder for incrementally assembling an immutable {@link PathSpecSet}</li>\n+ *   <li>built-in utility to mask a {@link RecordTemplate} with the stored path specs</li>\n+ * </ul>\n+ *\n+ * @author Joseph Florencio\n+ */\n+final public class PathSpecSet\n+{\n+  private final static PathSpecSet EMPTY = new PathSpecSet(Collections.emptySet(), false);\n+  private final static PathSpecSet FULL_PROJECTION = new PathSpecSet(Collections.emptySet(), true);\n+\n+  private final Set<PathSpec> _pathSpecs;\n+  private final boolean _fullProjection;", "originalCommit": "2c810667d15d73cfc38840fb82fc27a5c2caaf41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ3MzgwNQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r534473805", "bodyText": "maybe we can change to name \"universal\". Otherwise the \"full\" return a empty set and NULL in toArray seems unnatural to me as well", "author": "junchuanwang", "createdAt": "2020-12-02T20:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc3OTQxNA==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r541779414", "bodyText": "In Rest.li world, when you have a PathSpecSet you may have logic that is skipped if the projection doesn't include a specific field:\nif (pathSpecSet.contains(MyRecord.fields().subrecord()) {\n    // do a bunch of stuff that is costly but unnecessary if the field subrecord isn't requested\n}\n\nAnd then given the ResourceContext, you can easily build a PathSpecSet with PathSpecSet.of(resourceContext.getProjectionMask()).\nWhen no projection is specified, the ProjectionMask is null and you want to make sure that contains(PathSpec) returns true for any PathSpec and that's the meaning of a fullProjection.", "author": "GuiForget", "createdAt": "2020-12-12T20:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4MDE0OQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r541780149", "bodyText": "For the toArray() returning null, this is consistent with the behavior of the method fields(PathSpec[]) in the Rest.li builders.", "author": "GuiForget", "createdAt": "2020-12-12T21:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTc4MTg2Mg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r541781862", "bodyText": "I'm used to full projection so it is difficult for me to come up with an alternative. I'm not sure universal as an adjective works but I could see universe or universeSet as suitable. Here are some alternatives that I found in a thesaurus dictionary:\n\nglobalSet\nallInclusiveSet\nblanketSet", "author": "GuiForget", "createdAt": "2020-12-12T21:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkzNDc4MQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r542934781", "bodyText": "When no projection is specified, the ProjectionMask is null and you want to make sure that contains(PathSpec) returns true for any PathSpec and that's the meaning of a fullProjection.\n\nIn this specific use case it makes sense, but this object is simply a set of path specs. An empty path spec set articulates to a full projection when it's used in the specific application of projection, but path specs aren't only for projections. What does an empty path spec set mean when it's being used for indexing values from a complex data object, or matching ReadOnly/CreateOnly predicates? I don't necessarily think that an empty path spec set contains everything for all use cases.", "author": "evanw555", "createdAt": "2020-12-15T00:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjQ0NjAxNg==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r552446016", "bodyText": "thanks for the explanation, I will vote for \"allInclusiveSet\".", "author": "junchuanwang", "createdAt": "2021-01-06T08:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkzNDkzOQ==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r552934939", "bodyText": "Synced up with @GuiForget about this offline. He clarified that an empty set is not necessarily the same as an \"all inclusive\" or \"full projection\" set, which must be created explicitly as such.\nAs for naming, I say we avoid using the terminology \"full projection\", and instead use something that implies inclusivity. allInclusive/isAllInclusive works for me. complete may also be good, but I'm not sure if that has a different technical definition when it comes to sets.", "author": "evanw555", "createdAt": "2021-01-06T20:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjM1ODIxMA==", "url": "https://github.com/linkedin/rest.li/pull/339#discussion_r572358210", "bodyText": "I renamed fullProjection to allInclusive and propagated the changes throughout the classes and unit tests", "author": "GuiForget", "createdAt": "2021-02-08T20:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA2OTY2OA=="}], "type": "inlineReview"}, {"oid": "6cc0dd2594300283d740d6baeb249a5c5d420d4a", "url": "https://github.com/linkedin/rest.li/commit/6cc0dd2594300283d740d6baeb249a5c5d420d4a", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set.", "committedDate": "2020-12-12T21:15:54Z", "type": "forcePushed"}, {"oid": "f01b84828e3ab6423be107a45b9839bb89edeccc", "url": "https://github.com/linkedin/rest.li/commit/f01b84828e3ab6423be107a45b9839bb89edeccc", "message": "Rename fullProjection -> allInclusive", "committedDate": "2021-02-08T19:53:34Z", "type": "forcePushed"}, {"oid": "45e706af8e947978e2372cd38ecfd62c31b8a34e", "url": "https://github.com/linkedin/rest.li/commit/45e706af8e947978e2372cd38ecfd62c31b8a34e", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set.", "committedDate": "2021-02-09T21:32:55Z", "type": "commit"}, {"oid": "45e706af8e947978e2372cd38ecfd62c31b8a34e", "url": "https://github.com/linkedin/rest.li/commit/45e706af8e947978e2372cd38ecfd62c31b8a34e", "message": "Add PathSpecSet: a set of PathSpecSet with support for full projection\n\nThe PathSpecSet provides functionalities to more easily build or edit a set of PathSpec. In addition, it offers the support for a full projection so that methods like \"contains\" always return true making it easier for the client code to write logic with the set.", "committedDate": "2021-02-09T21:32:55Z", "type": "forcePushed"}]}