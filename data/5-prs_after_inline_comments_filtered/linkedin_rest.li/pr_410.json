{"pr_number": 410, "pr_title": "Loosen validation for array-descendant patch fields", "pr_createdAt": "2020-09-08T18:33:07Z", "pr_url": "https://github.com/linkedin/rest.li/pull/410", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI2Mw==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r485926263", "bodyText": "I totally agree the naming needs to be enhanced. There are just too many validators IMO.\nI was always curious about this naming convention. Before we named validators like \"DataSchemaAnnotationValidator\" or \"DataValidator\", now later a few new validators are now with a \"RestLi\"prefix, does that carry special meaning?", "author": "junchuanwang", "createdAt": "2020-09-09T21:15:23Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -274,9 +278,14 @@ else if (annotationName.equals(CreateOnly.class.getAnnotation(RestSpecAnnotation\n     _validatorClassMap = Collections.unmodifiableMap(validatorClassMap);\n   }\n \n-  private class DataValidator extends DataSchemaAnnotationValidator\n+  /**\n+   * Validates input data and patches using a given resource's {@link ReadOnly} and {@link CreateOnly} annotations.\n+   * Since it's an extension of {@link DataSchemaAnnotationValidator}, it also validates the data using whatever custom\n+   * validators are defined in the schema.\n+   */\n+  private class RestLiAnnotationDataValidator extends DataSchemaAnnotationValidator", "originalCommit": "08b47f8ce3bb1607899d0d6bbc0130b80b164668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk1MjkwOQ==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r485952909", "bodyText": "Good question. My reasoning is:\n\nThe \"RestLi\" prefix implies that the context is the Rest.li request/response validation, not just plain Pegasus data.\n\"Annotation\" because the validator triggers the custom schema validators as well as the \"Rest.li annotations\" (see next bullet point).\nTogether, \"RestLiAnnotation\" implies that the validator uses \"Rest.li annotations\" (i.e. ReadOnly/CreateOnly). These are annotations that are specific to the Rest.li REST framework, not just the Pegasus data layer.\n\nNaming is often very confusing or ambiguous in Rest.li, so I'm trying to make it more clear.", "author": "evanw555", "createdAt": "2020-09-09T22:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEyMDQyMA==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486120420", "bodyText": "(1) Maybe out of scope but I think \"DataSchemaAnnotationValidator\" is itself ambiguous, which made RestLiAnnotationDataValidator ambiguous. Do you see room to improve?  I think it is still a \"DataValidator\", and instantiated from \"schemaProperty\", so IMO it should be something like \"SchemaCustomDataValidator\"\n(2) For \"RestLiAnnotationDataValidator\" according to what you said, I recommend \"RestLiResourceAnnotationSchemaCustomDataValidator\".", "author": "junchuanwang", "createdAt": "2020-09-10T07:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1OTMzMg==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486659332", "bodyText": "I agree 100%, I was also confused by this. The DataSchemaAnnotationValidator is itself a data validator, not a schema validator (or a schema annotation validator). It doesn't sound smooth, but the most accurate name would be CustomValidatorDataValidator or SchemaValidatorDataValidator (the usage of \"validator\" for two different things is annoying). The name could be improved, however since this class is public changing the name has compatibility concerns. We can change it, but it's a little too much for this change IMO.\nThat suggested name is a mouthful, how about ResourceAnnotationDataValidator or RestLiResourceAnnotationDataValidator? If we get around to changing the name of the other class, we can change this one too to be consistent with the other (it's private so changing it again is no big deal).", "author": "evanw555", "createdAt": "2020-09-10T22:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2NjYxNQ==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486666615", "bodyText": "For (2) RestLiResourceAnnotationDataValidator sounds good enough, can we use that?\nFor (1), yes, I know. Also don't know if we can really change that one day (since it is Public), lol", "author": "junchuanwang", "createdAt": "2020-09-10T22:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3MzE0Mw==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486673143", "bodyText": "Yeah, I'll update the PR to use that.\n\nyes, I know. Also don't know if we can really change that one day (since it is Public)\n\nActually, I think we can maintain some compatibility by renaming the class, then preserving the old class as a deprecated subclass. Eventually, we would delete the old class.", "author": "evanw555", "createdAt": "2020-09-10T22:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI5MA==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r485926290", "bodyText": "Did you use this for debug? Not recommend to add it here.", "author": "junchuanwang", "createdAt": "2020-09-09T21:15:26Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -286,15 +295,38 @@ public void validate(ValidatorContext context)\n     {\n       super.validate(context);\n       DataElement element = context.dataElement();\n-      if (_readOnlyRestrictedPredicate.evaluate(element))\n+      System.out.println(\"Validate: \" + element);", "originalCommit": "08b47f8ce3bb1607899d0d6bbc0130b80b164668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk1MTEwMg==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r485951102", "bodyText": "Good catch, lol", "author": "evanw555", "createdAt": "2020-09-09T22:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjk4OA==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r485926988", "bodyText": "why not\nif (!grantArrayDescendantException(element)) {\n  // Original logic\n}", "author": "junchuanwang", "createdAt": "2020-09-09T21:16:59Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/validation/RestLiDataValidator.java", "diffHunk": "@@ -286,15 +295,38 @@ public void validate(ValidatorContext context)\n     {\n       super.validate(context);\n       DataElement element = context.dataElement();\n-      if (_readOnlyRestrictedPredicate.evaluate(element))\n+      System.out.println(\"Validate: \" + element);\n+      if (_readOnlyRestrictedPredicate.evaluate(element) && !grantArrayDescendantException(element))", "originalCommit": "08b47f8ce3bb1607899d0d6bbc0130b80b164668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk1MTAxNw==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r485951017", "bodyText": "Since this method traverses the data tree, it can potentially have performance issues. If we did it your way, it would be invoked for each element in the tree. Since my way is only invoked when the predicate is matched, this means the method will only be invoked for ReadOnly/CreateOnly elements that are mistakenly included (or those which are included as part of an array).", "author": "evanw555", "createdAt": "2020-09-09T22:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA1ODM2MA==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486058360", "bodyText": "Is this println by design or by choice? Logging maybe better?", "author": "karthikrg", "createdAt": "2020-09-10T04:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1NjE5NA==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486656194", "bodyText": "@karthikrg It was just an accident, I added this during testing to see the the order in which elements in the tree are validated. Given that this is invoked once for each element in a JSON object, I think it would flood the logs.", "author": "evanw555", "createdAt": "2020-09-10T21:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNjk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MzExNw==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486093117", "bodyText": "What does the dollar sign $ represent in this string-formed request?", "author": "BrianPin", "createdAt": "2020-09-10T06:24:35Z", "path": "restli-int-test/src/test/java/com/linkedin/restli/examples/TestRestLiValidation.java", "diffHunk": "@@ -557,12 +555,18 @@ public void testPartialUpdateFailure(RestClient restClient, Object builder, Stri\n             \"{\\\"patch\\\": {\\\"validationDemoNext\\\": {\\\"$set\\\": {\\\"stringA\\\": \\\"some value\\\"}}}}\",\n             // A field (MapWithTyperefs/key1) containing a CreateOnly field (MapWithTyperefs/key1/id) has to be partially set\n             \"{\\\"patch\\\": {\\\"MapWithTyperefs\\\": {\\\"key1\\\": {\\\"$set\\\": {\\\"message\\\": \\\"some message\\\", \\\"tone\\\": \\\"SINCERE\\\"}}}}}\",\n-            // Okay to set a field containing a ReadOnly field by omitting the ReadOnly field\n+            // Okay to set a field containing a ReadOnly field if the ReadOnly field is omitted\n             \"{\\\"patch\\\": {\\\"$set\\\": {\\\"ArrayWithInlineRecord\\\": [{\\\"bar2\\\": \\\"missing bar1\\\"}]}}}\",\n+            \"{\\\"patch\\\": {\\\"$set\\\": {\\\"UnionFieldWithInlineRecord\\\": {\\\"com.linkedin.restli.examples.greetings.api.myRecord\\\": {}}}}}\",\n+            \"{\\\"patch\\\": {\\\"$set\\\": {\\\"validationDemoNext\\\": {\\\"stringA\\\": \\\"no stringB\\\"}}}}\",\n             // Okay to delete a field containing a ReadOnly field\n             \"{\\\"patch\\\": {\\\"$delete\\\": [\\\"ArrayWithInlineRecord\\\"]}}\",\n             // Okay to delete a field containing a CreateOnly field\n-            \"{\\\"patch\\\": {\\\"MapWithTyperefs\\\": {\\\"$delete\\\": [\\\"key1\\\"]}}}\"\n+            \"{\\\"patch\\\": {\\\"MapWithTyperefs\\\": {\\\"$delete\\\": [\\\"key1\\\"]}}}\",\n+            // Okay to set a ReadOnly field if it's the descendant of an array\n+            \"{\\\"patch\\\": {\\\"$set\\\": {\\\"ArrayWithInlineRecord\\\": [{\\\"bar1\\\": \\\"setting ReadOnly field\\\", \\\"bar2\\\": \\\"foo\\\"}]}}}\",", "originalCommit": "7f74241211bd5b14ed6fceacc20312d2212083a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY1NTY1OQ==", "url": "https://github.com/linkedin/rest.li/pull/410#discussion_r486655659", "bodyText": "This is the request body of the PARTIAL_UPDATE request. See here for some details of the exact protocol: https://linkedin.github.io/rest.li/spec/protocol#partial-update", "author": "evanw555", "createdAt": "2020-09-10T21:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA5MzExNw=="}], "type": "inlineReview"}, {"oid": "e24826cd050208dea1c0de530098a26042686ac5", "url": "https://github.com/linkedin/rest.li/commit/e24826cd050208dea1c0de530098a26042686ac5", "message": "Loosen validation for array-descendant patch fields\n\nThis change allows a PARTIAL_UPDATE or BATCH_PARTIAL_UPDATE request to\nset a ReadOnly/CreateOnly field if that field is the descendant of an\narray. This is needed because there's no real way to \"patch\" individual\narray elements in Rest.li, so array patching actually sets the entire\narray. Thus, users need a way to \"patch\" an array while maintaining the\nexisting values of ReadOnly/CreateOnly fields.", "committedDate": "2020-09-10T23:07:39Z", "type": "commit"}, {"oid": "e24826cd050208dea1c0de530098a26042686ac5", "url": "https://github.com/linkedin/rest.li/commit/e24826cd050208dea1c0de530098a26042686ac5", "message": "Loosen validation for array-descendant patch fields\n\nThis change allows a PARTIAL_UPDATE or BATCH_PARTIAL_UPDATE request to\nset a ReadOnly/CreateOnly field if that field is the descendant of an\narray. This is needed because there's no real way to \"patch\" individual\narray elements in Rest.li, so array patching actually sets the entire\narray. Thus, users need a way to \"patch\" an array while maintaining the\nexisting values of ReadOnly/CreateOnly fields.", "committedDate": "2020-09-10T23:07:39Z", "type": "forcePushed"}]}