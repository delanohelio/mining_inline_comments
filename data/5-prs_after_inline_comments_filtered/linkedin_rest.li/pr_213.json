{"pr_number": 213, "pr_title": "darkcluster - basic framework for sending dark cluster requests", "pr_createdAt": "2020-03-07T00:26:28Z", "pr_url": "https://github.com/linkedin/rest.li/pull/213", "timeline": [{"oid": "5986457ec43663db628bf2884de262e341f98e6f", "url": "https://github.com/linkedin/rest.li/commit/5986457ec43663db628bf2884de262e341f98e6f", "message": "darkcluster - basic framework for sending dark cluster requests", "committedDate": "2020-03-07T00:31:55Z", "type": "forcePushed"}, {"oid": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "url": "https://github.com/linkedin/rest.li/commit/bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "message": "refactored dark cluster. Just has basic structure, minimal tests so far.", "committedDate": "2020-03-12T22:26:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNDAyOA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393234028", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-03-16T18:35:02Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * DarkClusterDispatcher is responsible for sending the request to the dark cluster. This is where custom dispatching operations can\n+ * be done before the request is sent off, such as adding tracking information to the requestContext, company specific logic, etc.\n+ */\n+public interface DarkClusterDispatcher\n+{\n+  void sendRequest(final RestRequest originalRequest, final RestRequest darkRequest,", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTI0Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365242", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T22:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNDAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNDU1Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393234553", "bodyText": "Prefer handleRequest since the manager does a bunch of other things too.", "author": "zhang-chris", "createdAt": "2020-03-16T18:35:55Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterManager.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * The role of the DarkClusterDispatcher is to determine if the request is safe to send, rewrite the request, find the right sending strategy,\n+ * and send it to the dark clusters via the strategy.\n+ */\n+public interface DarkClusterManager\n+{\n+  String HEADER_METHOD_OVERRIDE = \"X-HTTP-Method-Override\";\n+\n+  /**\n+   * Send the request to the dark cluster. sendDarkRequest should ensure that the original request and requestContext are not modified.\n+   *\n+   * @param oldRequest real request\n+   * @param oldRequestContext requestContext\n+   * @return true if request is sent at least once.\n+   */\n+  boolean sendDarkRequest(final RestRequest oldRequest, final RequestContext oldRequestContext);", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTMyOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365329", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T22:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNDU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNTIxMw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393235213", "bodyText": "Javadoc to describe to describe how the header will be used could be helpful.", "author": "zhang-chris", "createdAt": "2020-03-16T18:37:14Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterManager.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * The role of the DarkClusterDispatcher is to determine if the request is safe to send, rewrite the request, find the right sending strategy,\n+ * and send it to the dark clusters via the strategy.\n+ */\n+public interface DarkClusterManager\n+{\n+  String HEADER_METHOD_OVERRIDE = \"X-HTTP-Method-Override\";", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTM4MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365381", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T22:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNTIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5MzU2Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396893563", "bodyText": "Wait sorry, actually can we just make the static variable in QueryTunnelUtil public instead and use that?", "author": "zhang-chris", "createdAt": "2020-03-24T04:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNTIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNTc3Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400425772", "bodyText": "Also the javadoc doesn't describe how it is intended to be used.", "author": "zhang-chris", "createdAt": "2020-03-30T19:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNTIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNjIyNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393236226", "bodyText": "Mention that the requestContext should be duplicated/dark too.", "author": "zhang-chris", "createdAt": "2020-03-16T18:39:04Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * DarkClusterStrategy controls if a request should be duplicated to the dark canary clusters, and how, if any, traffic shaping should take place.\n+ */\n+public interface DarkClusterStrategy\n+{\n+  /**\n+   * Send request to dark canary according to strategy. This may include not sending the request, or sending it multiple times.\n+   * @param originalRequest incoming request\n+   * @param darkRequest dark request to send\n+   * @param requestContext requestContext for the request", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTUzMQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365531", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T22:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNjIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNjQ4Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393236483", "bodyText": "Does handled successfully just mean without error? Or that at least one request was sent.", "author": "zhang-chris", "createdAt": "2020-03-16T18:39:35Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * DarkClusterStrategy controls if a request should be duplicated to the dark canary clusters, and how, if any, traffic shaping should take place.\n+ */\n+public interface DarkClusterStrategy\n+{\n+  /**\n+   * Send request to dark canary according to strategy. This may include not sending the request, or sending it multiple times.\n+   * @param originalRequest incoming request\n+   * @param darkRequest dark request to send\n+   * @param requestContext requestContext for the request\n+   * @return  true if handled successfully else false", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTY5OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365699", "bodyText": "one request was sent. done.", "author": "davidhoa", "createdAt": "2020-03-19T22:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNjQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNzQwOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393237409", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-03-16T18:41:19Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+\n+/**\n+ * The DarkClusterStrategyFactory is responsible for creating and maintaining the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected. This hides the lifecycle and maintenance of DarkClusterStrategies from users.\n+ */\n+public interface DarkClusterStrategyFactory\n+{\n+  DarkClusterStrategy getOrCreate(String darkClusterName, DarkClusterConfig darkClusterConfig);", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTc0NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365745", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T22:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5NDM4MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396894381", "bodyText": "Thanks,\nI'd take this line out since it's an implementation detail \", because retrieving\n\nit requires iterating through the source cluster's darkClusters, not the dark cluster's darkClusters map.\"", "author": "zhang-chris", "createdAt": "2020-03-24T04:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyODg0MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397428840", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-24T20:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIzNzQwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5NjYzMw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393296633", "bodyText": "Just NoOpDarkClusterManager is fine. Same for the rest of the no-op impls.", "author": "zhang-chris", "createdAt": "2020-03-16T20:39:42Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/NoOpDarkClusterManagerImpl.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * Dummy implementation of DarkClusterDispatcher for NoOp cases like unrelated tests and unsupported cases.\n+ */\n+public class NoOpDarkClusterManagerImpl implements DarkClusterManager", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTc5Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365796", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T22:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5NjYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTU4OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393329588", "bodyText": "Can you check with all javadocs and replace class references with a link? for example, {@link DarkClusterManager}", "author": "zhang-chris", "createdAt": "2020-03-16T21:50:43Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/filter/DarkClusterFilter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.filter;\n+\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.impl.ResponseImpl;\n+import com.linkedin.r2.filter.NextFilter;\n+import com.linkedin.r2.filter.message.rest.RestFilter;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterFilter can be added to the Restli filter chain on either the server or client side, to tee off requests to a\n+ * dark cluster. It delegates to the DarkClusterManager for sending the dark request and verifying the dark response", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTg5OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365898", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T23:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMDg4NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393330885", "bodyText": "prefer ORIGINAL_REQUEST_KEY for clarity.", "author": "zhang-chris", "createdAt": "2020-03-16T21:53:48Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/filter/DarkClusterFilter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.filter;\n+\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.impl.ResponseImpl;\n+import com.linkedin.r2.filter.NextFilter;\n+import com.linkedin.r2.filter.message.rest.RestFilter;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterFilter can be added to the Restli filter chain on either the server or client side, to tee off requests to a\n+ * dark cluster. It delegates to the DarkClusterManager for sending the dark request and verifying the dark response\n+ * against the original response, if that is configured.\n+ *\n+ * Future enhancements might be to make it a Stream Filter as well.\n+ */\n+public class DarkClusterFilter implements RestFilter\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterFilter.class);\n+  private static final String ORIGINAL_REQUEST = DarkClusterFilter.class.getName() + \"_originalRequest\";", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTkzMw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365933", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T23:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMDg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMjY0Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393332643", "bodyText": "This should be done in the manager instead.", "author": "zhang-chris", "createdAt": "2020-03-16T21:57:57Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/filter/DarkClusterFilter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.filter;\n+\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.impl.ResponseImpl;\n+import com.linkedin.r2.filter.NextFilter;\n+import com.linkedin.r2.filter.message.rest.RestFilter;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterFilter can be added to the Restli filter chain on either the server or client side, to tee off requests to a\n+ * dark cluster. It delegates to the DarkClusterManager for sending the dark request and verifying the dark response\n+ * against the original response, if that is configured.\n+ *\n+ * Future enhancements might be to make it a Stream Filter as well.\n+ */\n+public class DarkClusterFilter implements RestFilter\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterFilter.class);\n+  private static final String ORIGINAL_REQUEST = DarkClusterFilter.class.getName() + \"_originalRequest\";\n+\n+  private final DarkClusterManager _darkClusterManager;\n+  private final DarkClusterVerifier _darkClusterVerifier;\n+  private final ExecutorService _executorService;\n+\n+  public DarkClusterFilter(@Nonnull DarkClusterManager darkClusterManager, @Nonnull DarkClusterVerifier darkClusterVerifier,\n+                           @Nonnull ExecutorService executorService)\n+  {\n+    _darkClusterManager = darkClusterManager;\n+    _darkClusterVerifier = darkClusterVerifier;\n+    _executorService = executorService;\n+  }\n+\n+  @Override\n+  public void onRestRequest(RestRequest req, RequestContext requestContext, Map<String, String> wireAttrs,\n+                            NextFilter<RestRequest, RestResponse> nextFilter)\n+  {\n+    // use a copy of request & request context to make sure what we do in dispatcher won't affect the processing\n+    // of the original request\n+    RestRequest reqCopy = req.builder().build();\n+    RequestContext newRequestContext = new RequestContext(requestContext);", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2NTk2NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395365965", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-19T23:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMjY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMjk3Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393332976", "bodyText": "is this comment necessary?", "author": "zhang-chris", "createdAt": "2020-03-16T21:58:43Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/filter/DarkClusterFilter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.filter;\n+\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.impl.ResponseImpl;\n+import com.linkedin.r2.filter.NextFilter;\n+import com.linkedin.r2.filter.message.rest.RestFilter;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterFilter can be added to the Restli filter chain on either the server or client side, to tee off requests to a\n+ * dark cluster. It delegates to the DarkClusterManager for sending the dark request and verifying the dark response\n+ * against the original response, if that is configured.\n+ *\n+ * Future enhancements might be to make it a Stream Filter as well.\n+ */\n+public class DarkClusterFilter implements RestFilter\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterFilter.class);\n+  private static final String ORIGINAL_REQUEST = DarkClusterFilter.class.getName() + \"_originalRequest\";\n+\n+  private final DarkClusterManager _darkClusterManager;\n+  private final DarkClusterVerifier _darkClusterVerifier;\n+  private final ExecutorService _executorService;\n+\n+  public DarkClusterFilter(@Nonnull DarkClusterManager darkClusterManager, @Nonnull DarkClusterVerifier darkClusterVerifier,\n+                           @Nonnull ExecutorService executorService)\n+  {\n+    _darkClusterManager = darkClusterManager;\n+    _darkClusterVerifier = darkClusterVerifier;\n+    _executorService = executorService;\n+  }\n+\n+  @Override\n+  public void onRestRequest(RestRequest req, RequestContext requestContext, Map<String, String> wireAttrs,\n+                            NextFilter<RestRequest, RestResponse> nextFilter)\n+  {\n+    // use a copy of request & request context to make sure what we do in dispatcher won't affect the processing\n+    // of the original request\n+    RestRequest reqCopy = req.builder().build();\n+    RequestContext newRequestContext = new RequestContext(requestContext);\n+\n+    boolean verifyResponse = _darkClusterManager.sendDarkRequest(reqCopy, newRequestContext);\n+\n+    if (verifyResponse)\n+    {\n+      requestContext.putLocalAttr(ORIGINAL_REQUEST, req);\n+    }\n+\n+    nextFilter.onRequest(req, requestContext, wireAttrs);\n+  }\n+\n+  @Override\n+  public void onRestResponse(RestResponse res, RequestContext requestContext, Map<String, String> wireAttrs,\n+                             NextFilter<RestRequest, RestResponse> nextFilter)\n+  {\n+    Object request = requestContext.getLocalAttr(ORIGINAL_REQUEST);\n+    if (request instanceof RestRequest)\n+    {\n+      //this method does not throw exceptions", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMzE3OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393333179", "bodyText": "Can combine the two if statements into 1 line.", "author": "zhang-chris", "createdAt": "2020-03-16T21:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMjk3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NDc5MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395384790", "bodyText": "I changed to use the verifierManager. got rid of the comment.", "author": "davidhoa", "createdAt": "2020-03-20T00:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMjk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNTMxOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393335319", "bodyText": "Check out RequestContextUtil#getObjectWithKey and RequestContextUtil#getServerRequestFinalizerManager. Can we do a similar thing here? I'm not sure how the dependencies will work out since RequestContextUtil is in r2-core module.", "author": "zhang-chris", "createdAt": "2020-03-16T22:04:48Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/filter/DarkClusterFilter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.filter;\n+\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.impl.ResponseImpl;\n+import com.linkedin.r2.filter.NextFilter;\n+import com.linkedin.r2.filter.message.rest.RestFilter;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterFilter can be added to the Restli filter chain on either the server or client side, to tee off requests to a\n+ * dark cluster. It delegates to the DarkClusterManager for sending the dark request and verifying the dark response\n+ * against the original response, if that is configured.\n+ *\n+ * Future enhancements might be to make it a Stream Filter as well.\n+ */\n+public class DarkClusterFilter implements RestFilter\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterFilter.class);\n+  private static final String ORIGINAL_REQUEST = DarkClusterFilter.class.getName() + \"_originalRequest\";\n+\n+  private final DarkClusterManager _darkClusterManager;\n+  private final DarkClusterVerifier _darkClusterVerifier;\n+  private final ExecutorService _executorService;\n+\n+  public DarkClusterFilter(@Nonnull DarkClusterManager darkClusterManager, @Nonnull DarkClusterVerifier darkClusterVerifier,\n+                           @Nonnull ExecutorService executorService)\n+  {\n+    _darkClusterManager = darkClusterManager;\n+    _darkClusterVerifier = darkClusterVerifier;\n+    _executorService = executorService;\n+  }\n+\n+  @Override\n+  public void onRestRequest(RestRequest req, RequestContext requestContext, Map<String, String> wireAttrs,\n+                            NextFilter<RestRequest, RestResponse> nextFilter)\n+  {\n+    // use a copy of request & request context to make sure what we do in dispatcher won't affect the processing\n+    // of the original request\n+    RestRequest reqCopy = req.builder().build();\n+    RequestContext newRequestContext = new RequestContext(requestContext);\n+\n+    boolean verifyResponse = _darkClusterManager.sendDarkRequest(reqCopy, newRequestContext);\n+\n+    if (verifyResponse)\n+    {\n+      requestContext.putLocalAttr(ORIGINAL_REQUEST, req);\n+    }\n+\n+    nextFilter.onRequest(req, requestContext, wireAttrs);\n+  }\n+\n+  @Override\n+  public void onRestResponse(RestResponse res, RequestContext requestContext, Map<String, String> wireAttrs,\n+                             NextFilter<RestRequest, RestResponse> nextFilter)\n+  {\n+    Object request = requestContext.getLocalAttr(ORIGINAL_REQUEST);", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NDY4OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395384689", "bodyText": "I think it's possible, but I don't think it'll save anything, because then I'll have to check for null. so I won't do this.", "author": "davidhoa", "createdAt": "2020-03-20T00:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNTMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNzIwOA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393337208", "bodyText": "I'm still not a fan of all callers of Verifier needing to first check if enabled. Can we instead wrap Verifier in a VerifierManager which does the check instead? Anyone currently calling Verifier will instead call VerifierManager.", "author": "zhang-chris", "createdAt": "2020-03-16T22:10:02Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/BaseDarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.r2.filter.R2Constants;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * The BaseDarkClusterDispatcher handles the basic operations of dispatching a dark request. It takes in a custom dispatcher, handles errors,\n+ * gathers metrics, and calls the verifier if needed.\n+ *\n+ * Note that it is the custom dispatcher's job to send the request on a different executor if that's desired. The verifier is always executed on\n+ * a separate executor, and that is handled by this class.\n+ */\n+public class BaseDarkClusterDispatcher\n+{\n+  private final String _darkClusterName;\n+  private final DarkClusterDispatcher _dispatcher;\n+  private final Notifier _notifier;\n+  private final DarkClusterVerifier _verifier;\n+  private final ExecutorService _dispatcherExecutor;\n+\n+  // Fields keeping track of statistics\n+  private final AtomicInteger _requestCount = new AtomicInteger(0);\n+  private final AtomicInteger _successCount = new AtomicInteger(0);\n+  private final AtomicInteger _exceptionCount = new AtomicInteger(0);\n+  private final ConcurrentHashMap<String, AtomicInteger> _exceptionCountMap = new ConcurrentHashMap<String, AtomicInteger>();\n+\n+  public BaseDarkClusterDispatcher(@Nonnull String darkClusterName, @Nonnull final DarkClusterDispatcher dispatcher, @Nonnull final Notifier notifier,\n+                                   @Nonnull final DarkClusterVerifier verifier, @Nonnull final ExecutorService dispatcherExecutor)\n+  {\n+    _darkClusterName = darkClusterName;\n+    _dispatcher = dispatcher;\n+    _notifier = notifier;\n+    _verifier = verifier;\n+    _dispatcherExecutor = dispatcherExecutor;\n+  }\n+\n+  void sendRequest(RestRequest originalRequest, RestRequest darkRequest, RequestContext requestContext, int numRequestDuplicates)\n+  {\n+    // Result of request is discarded unless _verifier is not null\n+    Callback<RestResponse> callback = new Callback<RestResponse>()\n+    {\n+      @Override\n+      public void onSuccess(RestResponse result)\n+      {\n+        _successCount.incrementAndGet();\n+        if (_verifier.isEnabled())", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNzQzOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393337439", "bodyText": "We can also hide the executor within the VerifierManager, which is a bit cleaner.", "author": "zhang-chris", "createdAt": "2020-03-16T22:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNzIwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NjQ1OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395386458", "bodyText": "done, added a VerifierManager, which does the check and hides the executor.", "author": "davidhoa", "createdAt": "2020-03-20T00:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzNzIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0Mzk1Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393343952", "bodyText": "Thoughts on separating out metrics into a DarkClusterDispatcher decorator?", "author": "zhang-chris", "createdAt": "2020-03-16T22:27:32Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/BaseDarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.r2.filter.R2Constants;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * The BaseDarkClusterDispatcher handles the basic operations of dispatching a dark request. It takes in a custom dispatcher, handles errors,\n+ * gathers metrics, and calls the verifier if needed.\n+ *\n+ * Note that it is the custom dispatcher's job to send the request on a different executor if that's desired. The verifier is always executed on\n+ * a separate executor, and that is handled by this class.\n+ */\n+public class BaseDarkClusterDispatcher\n+{\n+  private final String _darkClusterName;\n+  private final DarkClusterDispatcher _dispatcher;\n+  private final Notifier _notifier;\n+  private final DarkClusterVerifier _verifier;\n+  private final ExecutorService _dispatcherExecutor;\n+\n+  // Fields keeping track of statistics\n+  private final AtomicInteger _requestCount = new AtomicInteger(0);\n+  private final AtomicInteger _successCount = new AtomicInteger(0);\n+  private final AtomicInteger _exceptionCount = new AtomicInteger(0);\n+  private final ConcurrentHashMap<String, AtomicInteger> _exceptionCountMap = new ConcurrentHashMap<String, AtomicInteger>();", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NjM1MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395386350", "bodyText": "yes, that appears possibly through a DarkClusterDispatcher decorator by wrapping the callback. This is here for open source, so will keep.", "author": "davidhoa", "createdAt": "2020-03-20T00:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0Mzk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0NTkxNQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393345915", "bodyText": "final", "author": "zhang-chris", "createdAt": "2020-03-16T22:30:51Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterManagerImpl.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.d2.balancer.util.D2URIRewriter;\n+import com.linkedin.d2.balancer.util.URIRewriter;\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.restli.common.HttpMethod;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterManagerImpl verifies that the request to copy is safe to send, rewrites the request, and hands it off the to strategy to send.\n+ */\n+public class DarkClusterManagerImpl implements DarkClusterManager\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterManagerImpl.class);\n+\n+  private final Pattern _whiteListRegEx;\n+  private final Pattern _blackListRegEx;\n+  private final Notifier _notifier;\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private String _clusterName;", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NjU2MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395386560", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-20T00:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0NTkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTAzMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393351030", "bodyText": "This is probably old code, but can you add javadoc describing what is considered a safe request?", "author": "zhang-chris", "createdAt": "2020-03-16T22:45:24Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterManagerImpl.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.d2.balancer.util.D2URIRewriter;\n+import com.linkedin.d2.balancer.util.URIRewriter;\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.restli.common.HttpMethod;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterManagerImpl verifies that the request to copy is safe to send, rewrites the request, and hands it off the to strategy to send.\n+ */\n+public class DarkClusterManagerImpl implements DarkClusterManager\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterManagerImpl.class);\n+\n+  private final Pattern _whiteListRegEx;\n+  private final Pattern _blackListRegEx;\n+  private final Notifier _notifier;\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private String _clusterName;\n+  private final DarkClusterStrategyFactory _darkClusterStrategyFactory;\n+  private Map<String, AtomicReference<URIRewriter>> _uriRewriterMap;\n+\n+  public DarkClusterManagerImpl(@Nonnull String clusterName, @Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                @Nonnull DarkClusterStrategyFactory strategyFactory, String whiteListRegEx,\n+                                String blackListRegEx, @Nonnull Notifier notifier)\n+  {\n+    _whiteListRegEx = whiteListRegEx == null ? null : Pattern.compile(whiteListRegEx);\n+    _blackListRegEx = blackListRegEx == null ? null : Pattern.compile(blackListRegEx);\n+    _notifier = notifier;\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _clusterName = clusterName;\n+    _darkClusterStrategyFactory = strategyFactory;\n+    _uriRewriterMap = new HashMap<>();\n+  }\n+\n+  @Override\n+  public boolean sendDarkRequest(RestRequest request, RequestContext requestContext)\n+  {\n+    // the request is already immutable, and a new requestContext will be created in BaseDarkClusterDispatcher.\n+    // We don't need to copy them here, but doing it just for safety.\n+    RequestContext newRequestContext = new RequestContext(requestContext);\n+    String uri = request.getURI().toString();\n+    boolean darkRequestSent = false;\n+    try\n+    {\n+      final boolean whiteListed = _whiteListRegEx != null && _whiteListRegEx.matcher(uri).matches();\n+      final boolean blackedListed = _blackListRegEx != null && _blackListRegEx.matcher(uri).matches();\n+      if ((isSafe(request) || whiteListed) && !blackedListed)\n+      {\n+\n+        DarkClusterConfigMap configMap = _clusterInfoProvider.getDarkClusterConfigMap(_clusterName);\n+        for (Map.Entry<String, DarkClusterConfig> darkClusterConfigEntry : configMap.entrySet())\n+        {\n+          String darkClusterName = darkClusterConfigEntry.getKey();\n+          DarkClusterConfig darkClusterConfig = darkClusterConfigEntry.getValue();\n+\n+          RestRequest newD2Request = rewriteRequest(request, darkClusterName);\n+          // now find the strategy appropriate for each dark cluster\n+          DarkClusterStrategy strategy = _darkClusterStrategyFactory.getOrCreate(darkClusterName, darkClusterConfig);\n+          darkRequestSent = strategy.handleRequest(newD2Request, request, newRequestContext);\n+        }\n+\n+      }\n+    }\n+    catch (Throwable e)\n+    {\n+      _notifier.notify(() -> new RuntimeException(\"DarkCanaryDispatcherFilter failed to send request: \" + uri, e));\n+    }\n+    return darkRequestSent;\n+  }\n+\n+  private boolean isSafe(RestRequest req)", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NjU4Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395386586", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-20T00:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MjcyNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393352726", "bodyText": "computeIfAbsent is apparently not as performant as it could be in java 7. Could be worth manually checking if present first since we potentially do this on every request.", "author": "zhang-chris", "createdAt": "2020-03-16T22:50:52Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterManagerImpl.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.d2.balancer.util.D2URIRewriter;\n+import com.linkedin.d2.balancer.util.URIRewriter;\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.restli.common.HttpMethod;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterManagerImpl verifies that the request to copy is safe to send, rewrites the request, and hands it off the to strategy to send.\n+ */\n+public class DarkClusterManagerImpl implements DarkClusterManager\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterManagerImpl.class);\n+\n+  private final Pattern _whiteListRegEx;\n+  private final Pattern _blackListRegEx;\n+  private final Notifier _notifier;\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private String _clusterName;\n+  private final DarkClusterStrategyFactory _darkClusterStrategyFactory;\n+  private Map<String, AtomicReference<URIRewriter>> _uriRewriterMap;\n+\n+  public DarkClusterManagerImpl(@Nonnull String clusterName, @Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                @Nonnull DarkClusterStrategyFactory strategyFactory, String whiteListRegEx,\n+                                String blackListRegEx, @Nonnull Notifier notifier)\n+  {\n+    _whiteListRegEx = whiteListRegEx == null ? null : Pattern.compile(whiteListRegEx);\n+    _blackListRegEx = blackListRegEx == null ? null : Pattern.compile(blackListRegEx);\n+    _notifier = notifier;\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _clusterName = clusterName;\n+    _darkClusterStrategyFactory = strategyFactory;\n+    _uriRewriterMap = new HashMap<>();\n+  }\n+\n+  @Override\n+  public boolean sendDarkRequest(RestRequest request, RequestContext requestContext)\n+  {\n+    // the request is already immutable, and a new requestContext will be created in BaseDarkClusterDispatcher.\n+    // We don't need to copy them here, but doing it just for safety.\n+    RequestContext newRequestContext = new RequestContext(requestContext);\n+    String uri = request.getURI().toString();\n+    boolean darkRequestSent = false;\n+    try\n+    {\n+      final boolean whiteListed = _whiteListRegEx != null && _whiteListRegEx.matcher(uri).matches();\n+      final boolean blackedListed = _blackListRegEx != null && _blackListRegEx.matcher(uri).matches();\n+      if ((isSafe(request) || whiteListed) && !blackedListed)\n+      {\n+\n+        DarkClusterConfigMap configMap = _clusterInfoProvider.getDarkClusterConfigMap(_clusterName);\n+        for (Map.Entry<String, DarkClusterConfig> darkClusterConfigEntry : configMap.entrySet())\n+        {\n+          String darkClusterName = darkClusterConfigEntry.getKey();\n+          DarkClusterConfig darkClusterConfig = darkClusterConfigEntry.getValue();\n+\n+          RestRequest newD2Request = rewriteRequest(request, darkClusterName);\n+          // now find the strategy appropriate for each dark cluster\n+          DarkClusterStrategy strategy = _darkClusterStrategyFactory.getOrCreate(darkClusterName, darkClusterConfig);\n+          darkRequestSent = strategy.handleRequest(newD2Request, request, newRequestContext);\n+        }\n+\n+      }\n+    }\n+    catch (Throwable e)\n+    {\n+      _notifier.notify(() -> new RuntimeException(\"DarkCanaryDispatcherFilter failed to send request: \" + uri, e));\n+    }\n+    return darkRequestSent;\n+  }\n+\n+  private boolean isSafe(RestRequest req)\n+  {\n+    try\n+    {\n+      Map<String, String> headers = req.getHeaders();\n+      HttpMethod method;\n+      if (headers != null && headers.containsKey(HEADER_METHOD_OVERRIDE))\n+      {\n+        // This request method was converted from another method. (see com.linkedin.r2.message.rest.QueryTunnelUtil.java)\n+        method = HttpMethod.valueOf(headers.get(HEADER_METHOD_OVERRIDE));\n+      }\n+      else\n+      {\n+        method = HttpMethod.valueOf(req.getMethod());\n+      }\n+      return method.isSafe();\n+    }\n+    catch (Exception e)\n+    {\n+      _log.error(\"Invalid HttpMethod: {}\" + req.getMethod());\n+      return false;\n+    }\n+  }\n+\n+  /**\n+   * RewriteRequest takes the original request and creates a new one with the dark service name.\n+   * The original request URI is actually of the form \"/<restli-resource>/rest-of-path\" because it is being\n+   * processed in the r2 filter chain.\n+   * @param originalRequest\n+   * @return\n+   */\n+  private RestRequest rewriteRequest(RestRequest originalRequest, String darkServiceName)\n+  {\n+    _uriRewriterMap.computeIfAbsent(darkServiceName, k -> {", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NjYxNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395386614", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-20T00:12:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1Mzk4Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393353982", "bodyText": "I'm not sure what the standard for @nonnull is in pegasus but imo using package level annotation to apply nonnull to everything automatically and only specifying @nullable instead is a lot cleaner than having all these annotations everywhere. The assumption is nullable happens a lot less frequently than nonnull.\nFor example : https://jarvis.corp.linkedin.com/codesearch/result/?path=bulkhead%2Fclient%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fbulkhead%2Fclient&reponame=bulkhead%2Fbulkhead&name=package-info.java", "author": "zhang-chris", "createdAt": "2020-03-16T22:54:56Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategyImpl;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected. The complexity of listening for event changes is hidden by ClusterInfoProvider, so a simple\n+ * time and change based mechanism is used here to periodically refresh the list.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _clusterName;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final ExecutorService _executorService;\n+  private final Random _random;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull ClusterInfoProvider clusterInfoProvider, @Nonnull String clusterName,", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NzE5Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395387196", "bodyText": "I reduced many of the constructors to have fewer arguments. Doesn't look too bad to me. It's also a good reminder for anyone not using an IDE that reminds of redundant code.", "author": "davidhoa", "createdAt": "2020-03-20T00:14:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1Mzk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MDAxMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393370010", "bodyText": "private final", "author": "zhang-chris", "createdAt": "2020-03-16T23:41:24Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategyImpl;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected. The complexity of listening for event changes is hidden by ClusterInfoProvider, so a simple\n+ * time and change based mechanism is used here to periodically refresh the list.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _clusterName;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NjY0Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395386647", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-20T00:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MDAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MDM4NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393370384", "bodyText": "we can #put instead", "author": "zhang-chris", "createdAt": "2020-03-16T23:42:55Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategyImpl;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected. The complexity of listening for event changes is hidden by ClusterInfoProvider, so a simple\n+ * time and change based mechanism is used here to periodically refresh the list.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _clusterName;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final ExecutorService _executorService;\n+  private final Random _random;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull ClusterInfoProvider clusterInfoProvider, @Nonnull String clusterName,\n+                                        @Nonnull BaseDarkClusterDispatcher baseDarkClusterDispatcher, @Nonnull Notifier notifier,\n+                                        @Nonnull ExecutorService executorService, @Nonnull Random random)\n+  {\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _clusterName = clusterName;\n+    _baseDarkClusterDispatcher = baseDarkClusterDispatcher;\n+    _notifier = notifier;\n+    _darkStrategyMap = new HashMap<>();\n+    _executorService = executorService;\n+    _random = random;\n+  }\n+\n+  public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull DarkClusterConfig darkClusterConfig)\n+  {\n+    if (!_darkStrategyMap.containsKey(darkClusterName))\n+    {\n+      _darkStrategyMap.putIfAbsent(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName, darkClusterConfig)));", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NzQxNw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395387417", "bodyText": "there still can be multiple callers racing to enter this, putIfAbsent avoids multiple puts on the same darkClusterName.", "author": "davidhoa", "createdAt": "2020-03-20T00:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MjM2Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r393372362", "bodyText": "Time based updates seems not ideal vs event driven. It looks like the reason you need this is because we don't know when ClusterLoadBalancerSubscriber receives new updates. Not sure what the best way to handle this is.\nI'm thinking either\n\nPush a lot of the dark canary stuff down to D2 layer and add a map of DarkCanaryStrategy to SimpleLoadBalancerState.\nAdd a hook to SimpleLoadBalancerState so we can listen to any cluster updates.\n\nThoughts?", "author": "zhang-chris", "createdAt": "2020-03-16T23:50:08Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategyImpl;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected. The complexity of listening for event changes is hidden by ClusterInfoProvider, so a simple\n+ * time and change based mechanism is used here to periodically refresh the list.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _clusterName;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final ExecutorService _executorService;\n+  private final Random _random;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull ClusterInfoProvider clusterInfoProvider, @Nonnull String clusterName,\n+                                        @Nonnull BaseDarkClusterDispatcher baseDarkClusterDispatcher, @Nonnull Notifier notifier,\n+                                        @Nonnull ExecutorService executorService, @Nonnull Random random)\n+  {\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _clusterName = clusterName;\n+    _baseDarkClusterDispatcher = baseDarkClusterDispatcher;\n+    _notifier = notifier;\n+    _darkStrategyMap = new HashMap<>();\n+    _executorService = executorService;\n+    _random = random;\n+  }\n+\n+  public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull DarkClusterConfig darkClusterConfig)\n+  {\n+    if (!_darkStrategyMap.containsKey(darkClusterName))\n+    {\n+      _darkStrategyMap.putIfAbsent(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName, darkClusterConfig)));\n+    }\n+    if (strategyNeedsRefresh(darkClusterName, darkClusterConfig))\n+    {\n+      kickoffRefresh(darkClusterName, darkClusterConfig);\n+    }\n+\n+    return _darkStrategyMap.get(darkClusterName).get();\n+  }\n+\n+  private boolean strategyNeedsRefresh(String darkClusterName, DarkClusterConfig darkClusterConfig)", "originalCommit": "bc6fbf0ed6ce62aece5d47d806a06a4005028a1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM4NzY4OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r395387688", "bodyText": "as discussed, added an API to get notifications on Cluster updates, and using it in the StrategyFactory.", "author": "davidhoa", "createdAt": "2020-03-20T00:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MjM2Mg=="}], "type": "inlineReview"}, {"oid": "5d2cd4086cfe8b0adc4eabbfe64e8cd4db9efd43", "url": "https://github.com/linkedin/rest.li/commit/5d2cd4086cfe8b0adc4eabbfe64e8cd4db9efd43", "message": "refactor based on comments, added VerifierManager, javadocs, renames.", "committedDate": "2020-03-20T00:46:13Z", "type": "forcePushed"}, {"oid": "1f4d96101fee40a96c83595bfa38acac62c4f76d", "url": "https://github.com/linkedin/rest.li/commit/1f4d96101fee40a96c83595bfa38acac62c4f76d", "message": "refactor based on comments, added VerifierManager, javadocs, renames.", "committedDate": "2020-03-20T05:14:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjQyMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396886420", "bodyText": "copyright", "author": "zhang-chris", "createdAt": "2020-03-24T03:42:25Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/LoadBalancerClusterListener.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.linkedin.d2.balancer;", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NDA0OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397354048", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-24T17:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4OTYzOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396889639", "bodyText": "Can simplify to 2 lines:\nDarkClusterConfigMap darkClusterConfigMap = clusterProperties != null ? clusterProperties.getDarkClusters() : new DarkClusterConfigMap();\nclulsterCountFutureCallback.onSuccess(darkClusterConfigMap);\nalso rename clusterCountFutureCallback -> darkClusterConfigMapFutureCallback;", "author": "zhang-chris", "createdAt": "2020-03-24T03:56:30Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancer.java", "diffHunk": "@@ -902,6 +902,42 @@ public int getClusterCount(String clusterName, String scheme, int partitionId) t\n     }\n   }\n \n+  @Override\n+  public DarkClusterConfigMap getDarkClusterConfigMap(String clusterName) throws ServiceUnavailableException\n+  {\n+    FutureCallback<DarkClusterConfigMap> clusterCountFutureCallback = new FutureCallback<>();\n+\n+    _state.listenToCluster(clusterName, (type, name) ->\n+    {\n+      ClusterProperties clusterProperties = _state.getClusterProperties(clusterName).getProperty();\n+      if (clusterProperties != null)\n+      {\n+        clusterCountFutureCallback.onSuccess(clusterProperties.getDarkClusters());\n+      }\n+      else\n+      {\n+        // there won't be a DarkClusterConfigMap if there is no such cluster. Return empty structure in this case.\n+        clusterCountFutureCallback.onSuccess(new DarkClusterConfigMap());\n+      }", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM1NDE2OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397354168", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-24T17:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4OTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5Mzk0Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396893947", "bodyText": "Prefer originalRequest, originalRequestContext instead. Can we use that everywhere? thanks", "author": "zhang-chris", "createdAt": "2020-03-24T04:16:36Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterManager.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * The role of the DarkClusterDispatcher is to determine if the request is safe to send, rewrite the request, find the right sending strategy,\n+ * and send it to the dark clusters via the strategy.\n+ */\n+public interface DarkClusterManager\n+{\n+  /**\n+   * This header key indicates that the request method was converted from another method, such as GET to POST\n+   */\n+  String HEADER_METHOD_OVERRIDE = \"X-HTTP-Method-Override\";\n+\n+  /**\n+   * Send the request to the dark cluster. sendDarkRequest should ensure that the original request and requestContext are not modified.\n+   *\n+   * @param oldRequest real request\n+   * @param oldRequestContext requestContext\n+   * @return true if request is sent at least once.\n+   */\n+  boolean handleDarkRequest(final RestRequest oldRequest, final RequestContext oldRequestContext);", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyODczNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397428736", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-24T20:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5Mzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5NTc2OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396895769", "bodyText": "update since this is no longer true", "author": "zhang-chris", "createdAt": "2020-03-24T04:25:21Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/BaseDarkClusterDispatcherImpl.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.r2.filter.R2Constants;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * The BaseDarkClusterDispatcher handles the basic operations of dispatching a dark request. It takes in a custom dispatcher, handles errors,\n+ * gathers metrics, and calls the verifier if needed.\n+ *\n+ * Note that it is the custom dispatcher's job to send the request on a different executor if that's desired. The verifier is always executed on\n+ * a separate executor, and that is handled by this class.", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyOTAxOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397429019", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-24T20:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5NTc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMTEzMg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396901132", "bodyText": "Is this true? Aren't we listening to cluster updates and not dark cluster? updatedClusterName is the _sourceClusterName in this case.", "author": "zhang-chris", "createdAt": "2020-03-24T04:51:29Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                        @Nonnull String clusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _sourceClusterName = clusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new LoadBalancerClusterListener()\n+    {\n+      @Override\n+      public void onClusterAdded(String updatedClusterName)\n+      {\n+        if (_darkStrategyMap.containsKey(updatedClusterName))\n+        {\n+          // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n+          // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n+          // to recreate the dark cluster strategies, such as the multiplier.", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5OTA0NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397499044", "bodyText": "I added clarifying comments to the code. We actually will be listening to both source cluster (because we call ClusterInfoProvider.getDarkClusters() on the source cluster, which calls listenToCluster) and the dark clusters, because we send requests through the d2 client, which also calls listenToCluster. (we also might be calling getClusterCount as well on both source and target cluster). So while it's possible to update strategies when either the source cluster or dark cluster changes, it's most precise doing it only when we receive onClusterAdded for darkClusters, because we know for sure then that the dark cluster znode changed, rather than some unrelated source cluster change (or a different dark cluster change).", "author": "davidhoa", "createdAt": "2020-03-24T22:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMTEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyMjYzNQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r398122635", "bodyText": "I see, thanks for clarifying.", "author": "zhang-chris", "createdAt": "2020-03-25T19:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMTEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0NTUzNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r398145534", "bodyText": "closing comment.", "author": "davidhoa", "createdAt": "2020-03-25T20:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMTEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNTM4NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396915385", "bodyText": "Prefer not inlining within the constructor and extract out as private class.", "author": "zhang-chris", "createdAt": "2020-03-24T05:51:22Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                        @Nonnull String clusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _sourceClusterName = clusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new LoadBalancerClusterListener()", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyOTg2NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397429864", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-24T20:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNTM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNTk5Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396915996", "bodyText": "copyright", "author": "zhang-chris", "createdAt": "2020-03-24T05:53:39Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterVerifierManagerImpl.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.linkedin.darkcluster.impl;", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5OTA4OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397499089", "bodyText": "done", "author": "davidhoa", "createdAt": "2020-03-24T22:25:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNzg0Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396917847", "bodyText": "no need for impl", "author": "zhang-chris", "createdAt": "2020-03-24T06:00:33Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/RelativeTrafficDarkCanaryStrategyImpl.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Random;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * RelativeTrafficDarkCanaryStrategyImpl figures out how many dark requests to send. It uses the {@link ClusterInfoProvider} to determine the number of\n+ * instances in both the source and target cluster, and uses that to calculate the number of request to send in order to make the level of traffic\n+ * proportional to itself on any instance in the dark cluster (accounting for multiplier), assuming all hosts in the source cluster send traffic.\n+ */\n+public class RelativeTrafficDarkCanaryStrategyImpl implements DarkClusterStrategy", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxOTA4Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396919086", "bodyText": "DarkCanary -> DarkCluster\nI forget if we discussed this naming before. Why not just keep as ConstantMultiplierDarkClusterStrategy?", "author": "zhang-chris", "createdAt": "2020-03-24T06:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNzg0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5OTI1OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397499258", "bodyText": "done, renamed to ConstantMultiplierDarkClusterStrategy.", "author": "davidhoa", "createdAt": "2020-03-24T22:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNzg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxOTQyMQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r396919421", "bodyText": "should remove darkRequestSent and return #sendRequest", "author": "zhang-chris", "createdAt": "2020-03-24T06:06:09Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/RelativeTrafficDarkCanaryStrategyImpl.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Random;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * RelativeTrafficDarkCanaryStrategyImpl figures out how many dark requests to send. It uses the {@link ClusterInfoProvider} to determine the number of\n+ * instances in both the source and target cluster, and uses that to calculate the number of request to send in order to make the level of traffic\n+ * proportional to itself on any instance in the dark cluster (accounting for multiplier), assuming all hosts in the source cluster send traffic.\n+ */\n+public class RelativeTrafficDarkCanaryStrategyImpl implements DarkClusterStrategy\n+{\n+  private final String _originalClusterName;\n+  private final String _darkClusterName;\n+  private final Float _multiplier;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Random _random;\n+\n+  public RelativeTrafficDarkCanaryStrategyImpl(@Nonnull String originalClusterName, @Nonnull String darkClusterName, @Nonnull Float multiplier,\n+                                               @Nonnull BaseDarkClusterDispatcher baseDarkClusterDispatcher,\n+                                               @Nonnull Notifier notifier, @Nonnull Random random)\n+  {\n+    _originalClusterName = originalClusterName;\n+    _darkClusterName = darkClusterName;\n+    _multiplier = multiplier;\n+    _baseDarkClusterDispatcher = baseDarkClusterDispatcher;\n+    _notifier = notifier;\n+    _random = random;\n+  }\n+\n+  @Override\n+  public boolean handleRequest(RestRequest originalRequest,RestRequest darkRequest, RequestContext requestContext)\n+  {\n+    boolean darkRequestSent = false;\n+    int numRequestDuplicates = getNumDuplicateRequests(_darkClusterName, _originalClusterName, _multiplier, _random.nextFloat());\n+\n+    _baseDarkClusterDispatcher.sendRequest(originalRequest, darkRequest, requestContext, numRequestDuplicates);", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ5OTM3Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r397499373", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-03-24T22:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxOTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyMzg0Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r398123847", "bodyText": "It doesn't look like the for loop at 65 is necessary. You can use #containsKey instead.", "author": "zhang-chris", "createdAt": "2020-03-25T19:45:15Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                        @Nonnull String clusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _sourceClusterName = clusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new LoadBalancerClusterListener()\n+    {\n+      @Override\n+      public void onClusterAdded(String updatedClusterName)\n+      {\n+        if (_darkStrategyMap.containsKey(updatedClusterName))\n+        {\n+          // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n+          // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n+          // to recreate the dark cluster strategies, such as the multiplier.\n+          try\n+          {\n+            DarkClusterConfigMap darkConfigMap = _clusterInfoProvider.getDarkClusterConfigMap(_sourceClusterName);\n+            for (Map.Entry<String, DarkClusterConfig> entry : darkConfigMap.entrySet())", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE0NTY5OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r398145699", "bodyText": "ah yes, done.", "author": "davidhoa", "createdAt": "2020-03-25T20:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyMzg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNDA5Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r398124093", "bodyText": "Should account for if cluster removed is the source cluster.", "author": "zhang-chris", "createdAt": "2020-03-25T19:45:40Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                        @Nonnull String clusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _sourceClusterName = clusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new LoadBalancerClusterListener()\n+    {\n+      @Override\n+      public void onClusterAdded(String updatedClusterName)\n+      {\n+        if (_darkStrategyMap.containsKey(updatedClusterName))\n+        {\n+          // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n+          // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n+          // to recreate the dark cluster strategies, such as the multiplier.\n+          try\n+          {\n+            DarkClusterConfigMap darkConfigMap = _clusterInfoProvider.getDarkClusterConfigMap(_sourceClusterName);\n+            for (Map.Entry<String, DarkClusterConfig> entry : darkConfigMap.entrySet())\n+            {\n+              String darkClusterName = entry.getKey();\n+              // just update the cluster that's changed.\n+              if (darkClusterName.equals(updatedClusterName))\n+              {\n+                _darkStrategyMap.put(entry.getKey(), new AtomicReference<>(createStrategy(clusterName, entry.getValue())));\n+              }\n+            }\n+\n+          }\n+          catch (ServiceUnavailableException e)\n+          {\n+            _notifier.notify(() -> new RuntimeException(\"unable to refresh DarkClusterConfigMap for source cluster: \" + _sourceClusterName));\n+          }\n+        }\n+      }\n+\n+      @Override\n+      public void onClusterRemoved(String clusterName)\n+      {\n+        _darkStrategyMap.remove(clusterName);", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE1MTc3MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r398151771", "bodyText": "This should never happen, just like we don't allow clusters to be deleted if there are services in the cluster. In that case, all services need to be removed from the cluster first. Similarly, all dark services and dark clusters need to be removed as well before the source cluster is removed. This code here can't enforce that, the place that enforces that is whatever writes the d2-config. So I won't change anything here.", "author": "davidhoa", "createdAt": "2020-03-25T20:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNDA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ1MzYyNw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r399453627", "bodyText": "I agree it should not be happening. But I think it would be good to account for it anyway rather than assuming D2 config writer handles it properly since it is an entirely different component. Up to you.", "author": "zhang-chris", "createdAt": "2020-03-27T18:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNDA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNTgzMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r403435830", "bodyText": "there's nothing that can be done here; if I wanted to find the darkClusters that corresponded to the sourceCluster cluster that was being removed, I can't unless I made a duplicate copy outside of the SOT; that would make a big mess to keep in sync. So there's nothing that can be done here for that case, which should never happen. Nor can I even issue a warning, since I wouldn't even know about any dark clusters that correspond to it (only get the clustername, not the property being removed).", "author": "davidhoa", "createdAt": "2020-04-04T07:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNDA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMTM1OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400421359", "bodyText": "{ on new line", "author": "zhang-chris", "createdAt": "2020-03-30T18:56:56Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerTest.java", "diffHunk": "@@ -158,6 +161,32 @@ public void doOneTimeTearDown() throws IOException\n     }\n   }\n \n+  private SimpleLoadBalancer setupLoadBalancer(LoadBalancerState state, MockStore<ServiceProperties> serviceRegistry,\n+      MockStore<ClusterProperties> clusterRegistry, MockStore<UriProperties> uriRegistry)\n+      throws ExecutionException, InterruptedException {", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4MDIzMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404480230", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T01:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMTQ0MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400421441", "bodyText": "same here", "author": "zhang-chris", "createdAt": "2020-03-30T18:57:06Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerTest.java", "diffHunk": "@@ -158,6 +161,32 @@ public void doOneTimeTearDown() throws IOException\n     }\n   }\n \n+  private SimpleLoadBalancer setupLoadBalancer(LoadBalancerState state, MockStore<ServiceProperties> serviceRegistry,\n+      MockStore<ClusterProperties> clusterRegistry, MockStore<UriProperties> uriRegistry)\n+      throws ExecutionException, InterruptedException {\n+    Map<String, LoadBalancerStrategyFactory<? extends LoadBalancerStrategy>> loadBalancerStrategyFactories =\n+        new HashMap<>();\n+    Map<String, TransportClientFactory> clientFactories = new HashMap<>();\n+    LoadBalancerState loadBalancerState = state;\n+\n+    loadBalancerStrategyFactories.put(\"degrader\", new DegraderLoadBalancerStrategyFactoryV3());\n+    clientFactories.put(PropertyKeys.HTTP_SCHEME, new DoNothingClientFactory());\n+    clientFactories.put(PropertyKeys.HTTPS_SCHEME, new DoNothingClientFactory());\n+\n+    if (loadBalancerState == null) {", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4Nzg0MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404487841", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T01:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMzIzNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400423234", "bodyText": "javadoc", "author": "zhang-chris", "createdAt": "2020-03-30T19:00:04Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/BaseDarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * BaseDarkClusterDispatcher handles the basic operations of dispatching a dark request, such as sending the request\n+ * multiple times, handling errors, gathering metrics, and calling the verifier if needed on the dark response. Because\n+ * metrics need to be separated out, BaseDarkClusterDispatcher maps 1:1 with a dark cluster, and given that new dark clusters can be\n+ * added at runtime, BaseDarkClusterDispatcher will be instantiated dynamically.\n+ *\n+ * This interface handles multiple requests to be dispatched, whereas {@link DarkClusterDispatcher} is one level down and handles just one request.\n+ * Both levels are provided as interfaces to allow flexibility in user provided implementations. {@link DarkClusterDispatcher} can also be a singleton,\n+ * whereas BaseDarkClusterDispatcher is meant to be one per dark cluster, for separation of metrics.\n+ *\n+ * The lifecycle of a BaseDarkClusterDispatcher is from the time of the first request sent to that dark cluster until jvm shutdown, or strategy\n+ * change. As such, the {@link DarkClusterStrategyFactory} will control instantiations of the BaseDarkClusterDispatcher, one per dark cluster, which is\n+ * the same as the lifecycle of {@link DarkClusterStrategy}.\n+ */\n+public interface BaseDarkClusterDispatcher\n+{\n+  boolean sendRequest(RestRequest originalRequest, RestRequest darkRequest, RequestContext requestContext, int numRequestDuplicates);", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNjQxNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404526414", "bodyText": "done. also decided that the requestContext really should be originalRequestContext (though the filter will copy it for safety). DarkClusterDispatcher will also take the originalRequestContext, and it will be the implementation of DarkClusterDispatcher that will create the darkRequestContext for the dark requests. This makes sense because you need to have a separate requestContext anyway for each dark request, so making the copying done at the lowest layer makes sense.", "author": "davidhoa", "createdAt": "2020-04-07T04:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMzIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1MTQ4Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405051487", "bodyText": "ok sounds good", "author": "zhang-chris", "createdAt": "2020-04-07T19:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMzY2OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400423669", "bodyText": "does not match parameter name \"originalRequest\". Should users pass in a copy or not?", "author": "zhang-chris", "createdAt": "2020-03-30T19:00:50Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * DarkClusterDispatcher is responsible for sending the request to the dark cluster. This is where custom dispatching operations can\n+ * be done before the request is sent off, such as adding tracking information to the requestContext, company specific logic, etc.\n+ */\n+public interface DarkClusterDispatcher\n+{\n+  /**\n+   * Sends the request to the dark cluster.\n+   *\n+   * @param originalRequest a copy of the original request", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNjY2OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404526668", "bodyText": "I fixed this. As mentioned in the comments on BaseDarkClusterDispatcher, I'm actually changing this to be the originalRequestContext (though our filter will copy for safety's sake).", "author": "davidhoa", "createdAt": "2020-04-07T04:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNDA0MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400424041", "bodyText": "I think renaming to darkRequestContext would be clearer. Here and everywhere else.", "author": "zhang-chris", "createdAt": "2020-03-30T19:01:30Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * DarkClusterDispatcher is responsible for sending the request to the dark cluster. This is where custom dispatching operations can\n+ * be done before the request is sent off, such as adding tracking information to the requestContext, company specific logic, etc.\n+ */\n+public interface DarkClusterDispatcher\n+{\n+  /**\n+   * Sends the request to the dark cluster.\n+   *\n+   * @param originalRequest a copy of the original request\n+   * @param darkRequest the request that should be sent\n+   * @param requestContext the requestContext corresponding to the darkRequest", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNjkxNw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404526917", "bodyText": "renamed to originalRequestContext.", "author": "davidhoa", "createdAt": "2020-04-07T04:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNDA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNDYyOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400424629", "bodyText": "The final's are used pretty inconsistently. We should either use them everywhere or not at all. I think it's fine to just leave out.", "author": "zhang-chris", "createdAt": "2020-03-30T19:02:31Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * DarkClusterDispatcher is responsible for sending the request to the dark cluster. This is where custom dispatching operations can\n+ * be done before the request is sent off, such as adding tracking information to the requestContext, company specific logic, etc.\n+ */\n+public interface DarkClusterDispatcher\n+{\n+  /**\n+   * Sends the request to the dark cluster.\n+   *\n+   * @param originalRequest a copy of the original request\n+   * @param darkRequest the request that should be sent\n+   * @param requestContext the requestContext corresponding to the darkRequest\n+   * @param callback the callback to invoke on receiving the dark response\n+   * @return true if request was sent, false otherwise\n+   */\n+  boolean sendRequest(final RestRequest originalRequest, final RestRequest darkRequest,", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNjk1NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404526954", "bodyText": "removed.", "author": "davidhoa", "createdAt": "2020-04-07T04:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNjEyNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400426124", "bodyText": "Be consistent with naming. I prefer \"originalRequest(Context)\" instead of \"oldRequest(Context)\".", "author": "zhang-chris", "createdAt": "2020-03-30T19:05:12Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterManager.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * The role of the DarkClusterDispatcher is to determine if the request is safe to send, rewrite the request, find the right sending strategy,\n+ * and send it to the dark clusters via the strategy.\n+ */\n+public interface DarkClusterManager\n+{\n+  /**\n+   * This header key indicates that the request method was converted from another method, such as GET to POST\n+   */\n+  String HEADER_METHOD_OVERRIDE = \"X-HTTP-Method-Override\";\n+\n+  /**\n+   * Send the request to the dark cluster. sendDarkRequest should ensure that the original request and requestContext are not modified.\n+   *\n+   * @param oldRequest real request\n+   * @param oldRequestContext requestContext\n+   * @return true if request is sent at least once.\n+   */\n+  boolean handleDarkRequest(final RestRequest oldRequest, final RequestContext oldRequestContext);", "originalCommit": "30f219986401e5797b73ded9d5fcf62d064a34a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAyMDk4Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405020983", "bodyText": "I think you were looking at an old diff.", "author": "davidhoa", "createdAt": "2020-04-07T18:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNjEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzODU1Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400438553", "bodyText": "It would be more correct to separate add and remove counts and verify on those.\nprivate Map<String, AtomicInteger> clusterAddedCounters = new HashMap<>();\nprivate Map<String, AtomicInteger> clusterRemovedCounters = new HashMap<>();\nDo we expect concurrency to be an issue or can we use HashMap instead?", "author": "zhang-chris", "createdAt": "2020-03-30T19:24:53Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerStateTest.java", "diffHunk": "@@ -1610,6 +1617,166 @@ public void testUpdatePartitionDataMap()\n \n   }\n \n+  @Test\n+  public void testRegisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    // then update the cluster\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected 2 calls\");\n+  }\n+\n+  @Test\n+  public void testUnregisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _state.unregisterClusterListener(clusterListener);\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call, same as before\");\n+  }\n+\n+  @Test\n+  public void testOnRemoveCluster()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _clusterRegistry.remove(CLUSTER1_CLUSTER_NAME);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected count of 2\");\n+  }\n+\n+  @Test\n+  public void testRegisterClusterListenerDuplicates()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    _state.registerClusterListener(clusterListener);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+  }\n+\n+  @Test\n+  public void testRegisterMultipleClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener1 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    TestClusterListener clusterListener2 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+    assertEquals(clusterListener2.getCount(CLUSTER2_CLUSTER_NAME), 2, \"expected 2 call\");\n+  }\n+\n+  @Test\n+  public void testShutdownWithClusterListener() throws URISyntaxException,\n+                                                       InterruptedException\n+  {\n+    reset();\n+    TestClusterListener clusterListener1 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    TestClusterListener clusterListener2 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected 0 call\");\n+    assertEquals(clusterListener1.getCount(CLUSTER2_CLUSTER_NAME), 0, \"expected 0 call\");\n+    TestShutdownCallback callback = new TestShutdownCallback();\n+\n+    _state.shutdown(callback);\n+\n+    if (!callback.await(10, TimeUnit.SECONDS))\n+    {\n+      fail(\"unable to shut down state\");\n+    }\n+\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+    assertEquals(clusterListener1.getCount(CLUSTER2_CLUSTER_NAME), 1, \"expected 1 call\");\n+  }\n+\n+  public static class TestClusterListener implements LoadBalancerClusterListener\n+  {\n+    // Store if notified on both add and remove\n+    private Map<String, AtomicInteger> notificationCounter = new ConcurrentHashMap<>();", "originalCommit": "ebb7a7db7a4b51085558f5d4471e3b0f4b593e6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4NTYxMg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404485612", "bodyText": "done. I don't expect concurrency to be an issue for these tests. making the counters separate complicates the code, but doable.", "author": "davidhoa", "createdAt": "2020-04-07T01:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzODU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1MjI2Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405052267", "bodyText": "I think it's necessary complexity since add/remove are 2 separate behaviors.", "author": "zhang-chris", "createdAt": "2020-04-07T19:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzODU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzOTc1NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r400439754", "bodyText": "It would be nice if the messages were a bit more descriptive with reasons why we expect a certain number of count. for example, \"Expected 1 call since duplicates are not allowed.\" makes the test that much easier to understand.", "author": "zhang-chris", "createdAt": "2020-03-30T19:26:57Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerStateTest.java", "diffHunk": "@@ -1610,6 +1617,166 @@ public void testUpdatePartitionDataMap()\n \n   }\n \n+  @Test\n+  public void testRegisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    // then update the cluster\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected 2 calls\");\n+  }\n+\n+  @Test\n+  public void testUnregisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _state.unregisterClusterListener(clusterListener);\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call, same as before\");\n+  }\n+\n+  @Test\n+  public void testOnRemoveCluster()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _clusterRegistry.remove(CLUSTER1_CLUSTER_NAME);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected count of 2\");\n+  }\n+\n+  @Test\n+  public void testRegisterClusterListenerDuplicates()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    _state.registerClusterListener(clusterListener);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");", "originalCommit": "ebb7a7db7a4b51085558f5d4471e3b0f4b593e6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4MzAzNw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404483037", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T01:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzOTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzMDMzOA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404330338", "bodyText": "I couldnt understand why this and ZKPeer is changed, can you explain?", "author": "zhang-chris", "createdAt": "2020-04-06T19:19:48Z", "path": "d2-int-test/src/test/java/com/linkedin/d2/quorum/ZKQuorum.java", "diffHunk": "@@ -82,10 +82,7 @@ private void createNewPeerData(int id)\n     int electionPort = ZKTestUtil.getRandomPort() + 1001;\n     ZKPeer zkpeer = new ZKPeer(id, ZKTestUtil.createTempDir(\"zkdata\"+id), ZKTestUtil.createTempDir(\"zklog\"+id), HOST, clientPort, quorumPort, electionPort);\n     _peers.put(id, zkpeer);\n-    _peersView.put(Long.valueOf(id), new QuorumServer(id,\n-                                                     new InetSocketAddress(HOST, quorumPort),\n-                                                     new InetSocketAddress(HOST, electionPort),\n-                                                     LearnerType.PARTICIPANT));\n+    _peersView.put(Long.valueOf(id), new QuorumServer(id, HOST, quorumPort, electionPort, LearnerType.PARTICIPANT));", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4MTM1OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404481359", "bodyText": "these weren't my changes ... these appear to be Nizar's changes. Not sure why they appear as my diffs.", "author": "davidhoa", "createdAt": "2020-04-07T01:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzMDMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1MjYwNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405052606", "bodyText": "interesting.. makes sense now", "author": "zhang-chris", "createdAt": "2020-04-07T19:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzMDMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzNTA1Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404335056", "bodyText": "add spacing for readability", "author": "zhang-chris", "createdAt": "2020-04-06T19:28:33Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerStateTest.java", "diffHunk": "@@ -1610,6 +1616,166 @@ public void testUpdatePartitionDataMap()\n \n   }\n \n+  @Test\n+  public void testRegisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    // then update the cluster\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected 2 calls\");\n+  }\n+\n+  @Test\n+  public void testUnregisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _state.unregisterClusterListener(clusterListener);\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call, same as before\");\n+  }\n+\n+  @Test\n+  public void testOnRemoveCluster()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _clusterRegistry.remove(CLUSTER1_CLUSTER_NAME);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected count of 2\");\n+  }\n+\n+  @Test\n+  public void testRegisterClusterListenerDuplicates()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    _state.registerClusterListener(clusterListener);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+  }\n+\n+  @Test\n+  public void testRegisterMultipleClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener1 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    TestClusterListener clusterListener2 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+    assertEquals(clusterListener2.getCount(CLUSTER2_CLUSTER_NAME), 2, \"expected 2 call\");", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4MzIxOA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404483218", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T01:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzNTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzNjM4Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404336383", "bodyText": "I'm okay with failing with NPE in this case instead of silently returning 0 since this is for tests and would indicate something is very wrong. No need to check if clusterName is null.", "author": "zhang-chris", "createdAt": "2020-04-06T19:30:51Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerStateTest.java", "diffHunk": "@@ -1610,6 +1616,166 @@ public void testUpdatePartitionDataMap()\n \n   }\n \n+  @Test\n+  public void testRegisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    // then update the cluster\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected 2 calls\");\n+  }\n+\n+  @Test\n+  public void testUnregisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _state.unregisterClusterListener(clusterListener);\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call, same as before\");\n+  }\n+\n+  @Test\n+  public void testOnRemoveCluster()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _clusterRegistry.remove(CLUSTER1_CLUSTER_NAME);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected count of 2\");\n+  }\n+\n+  @Test\n+  public void testRegisterClusterListenerDuplicates()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    _state.registerClusterListener(clusterListener);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+  }\n+\n+  @Test\n+  public void testRegisterMultipleClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener1 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    TestClusterListener clusterListener2 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+    assertEquals(clusterListener2.getCount(CLUSTER2_CLUSTER_NAME), 2, \"expected 2 call\");\n+  }\n+\n+  @Test\n+  public void testShutdownWithClusterListener() throws URISyntaxException,\n+                                                       InterruptedException\n+  {\n+    reset();\n+    TestClusterListener clusterListener1 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    TestClusterListener clusterListener2 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected 0 call\");\n+    assertEquals(clusterListener1.getCount(CLUSTER2_CLUSTER_NAME), 0, \"expected 0 call\");\n+    TestShutdownCallback callback = new TestShutdownCallback();\n+\n+    _state.shutdown(callback);\n+\n+    if (!callback.await(10, TimeUnit.SECONDS))\n+    {\n+      fail(\"unable to shut down state\");\n+    }\n+\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+    assertEquals(clusterListener1.getCount(CLUSTER2_CLUSTER_NAME), 1, \"expected 1 call\");\n+  }\n+\n+  public static class TestClusterListener implements LoadBalancerClusterListener\n+  {\n+    // Store if notified on both add and remove\n+    private Map<String, AtomicInteger> notificationCounter = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void onClusterAdded(String clusterName)\n+    {\n+      incrementCount(clusterName);\n+    }\n+\n+    @Override\n+    public void onClusterRemoved(String clusterName)\n+    {\n+      incrementCount(clusterName);\n+    }\n+\n+    public int getCount(String clusterName)\n+    {\n+      if (clusterName != null)", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4NjkzMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404486930", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T01:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzNjM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM0MTU0OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404341548", "bodyText": "This method can be simplified.\nAtomicInteger counter = notificationCounters.computeIfAbsent(clusterName, (clusterName) -> new AtomicInteger());\ncounter.incrementAndGet();", "author": "zhang-chris", "createdAt": "2020-04-06T19:40:12Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerStateTest.java", "diffHunk": "@@ -1610,6 +1616,166 @@ public void testUpdatePartitionDataMap()\n \n   }\n \n+  @Test\n+  public void testRegisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    // then update the cluster\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected 2 calls\");\n+  }\n+\n+  @Test\n+  public void testUnregisterClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _state.unregisterClusterListener(clusterListener);\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call, same as before\");\n+  }\n+\n+  @Test\n+  public void testOnRemoveCluster()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+    _clusterRegistry.remove(CLUSTER1_CLUSTER_NAME);\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 2, \"expected count of 2\");\n+  }\n+\n+  @Test\n+  public void testRegisterClusterListenerDuplicates()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    _state.registerClusterListener(clusterListener);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+\n+  }\n+\n+  @Test\n+  public void testRegisterMultipleClusterListener()\n+  {\n+    reset();\n+\n+    TestClusterListener clusterListener1 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    TestClusterListener clusterListener2 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+    assertEquals(clusterListener2.getCount(CLUSTER2_CLUSTER_NAME), 2, \"expected 2 call\");\n+  }\n+\n+  @Test\n+  public void testShutdownWithClusterListener() throws URISyntaxException,\n+                                                       InterruptedException\n+  {\n+    reset();\n+    TestClusterListener clusterListener1 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    TestClusterListener clusterListener2 = new TestClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 0, \"expected 0 call\");\n+    assertEquals(clusterListener1.getCount(CLUSTER2_CLUSTER_NAME), 0, \"expected 0 call\");\n+    TestShutdownCallback callback = new TestShutdownCallback();\n+\n+    _state.shutdown(callback);\n+\n+    if (!callback.await(10, TimeUnit.SECONDS))\n+    {\n+      fail(\"unable to shut down state\");\n+    }\n+\n+    assertEquals(clusterListener1.getCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call\");\n+    assertEquals(clusterListener1.getCount(CLUSTER2_CLUSTER_NAME), 1, \"expected 1 call\");\n+  }\n+\n+  public static class TestClusterListener implements LoadBalancerClusterListener\n+  {\n+    // Store if notified on both add and remove\n+    private Map<String, AtomicInteger> notificationCounter = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void onClusterAdded(String clusterName)\n+    {\n+      incrementCount(clusterName);\n+    }\n+\n+    @Override\n+    public void onClusterRemoved(String clusterName)\n+    {\n+      incrementCount(clusterName);\n+    }\n+\n+    public int getCount(String clusterName)\n+    {\n+      if (clusterName != null)\n+      {\n+        return notificationCounter.getOrDefault(clusterName, new AtomicInteger(0)).intValue();\n+      }\n+      return 0;\n+    }\n+\n+    private void incrementCount(String clusterName)\n+    {\n+      AtomicInteger count = notificationCounter.get(clusterName);\n+      if (count == null)\n+      {\n+        count = new AtomicInteger();\n+        AtomicInteger curCount = notificationCounter.putIfAbsent(clusterName, count);\n+        if (curCount != null)\n+        {\n+          count = curCount;\n+        }\n+      }\n+      count.incrementAndGet();\n+    }", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4Nzc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404487785", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T01:43:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM0MTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM0NDQ1Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404344452", "bodyText": "Can we extract out and resuse the TestClusterListener impl used in SimpleLoadBalancerStateTest?", "author": "zhang-chris", "createdAt": "2020-04-06T19:45:48Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerTest.java", "diffHunk": "@@ -185,57 +216,186 @@ public void testClusterInfoProvider(int numHttp, int numHttps, int expectedNumHt\n       int partitionIdForAdd, int partitionIdForCheck)\n       throws InterruptedException, ExecutionException, ServiceUnavailableException\n   {\n-    Map<String, LoadBalancerStrategyFactory<? extends LoadBalancerStrategy>> loadBalancerStrategyFactories =\n-        new HashMap<>();\n-    Map<String, TransportClientFactory> clientFactories = new HashMap<>();\n-\n     MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n     MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n     MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n \n-    loadBalancerStrategyFactories.put(\"degrader\", new DegraderLoadBalancerStrategyFactoryV3());\n-    clientFactories.put(PropertyKeys.HTTP_SCHEME, new DoNothingClientFactory());\n-    clientFactories.put(PropertyKeys.HTTPS_SCHEME, new DoNothingClientFactory());\n-\n-    SimpleLoadBalancerState state =\n-        new SimpleLoadBalancerState(new SynchronousExecutorService(),\n-            uriRegistry,\n-            clusterRegistry,\n-            serviceRegistry,\n-            clientFactories,\n-            loadBalancerStrategyFactories);\n-\n-    SimpleLoadBalancer loadBalancer =\n-        new SimpleLoadBalancer(state, 5, TimeUnit.SECONDS, _d2Executor);\n-\n-    FutureCallback<None> balancerCallback = new FutureCallback<None>();\n-    loadBalancer.start(balancerCallback);\n-    balancerCallback.get();\n+    populateUriRegistry(numHttp, numHttps, partitionIdForAdd, uriRegistry);\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME));\n \n-    URI uri1 = URI.create(\"http://test.qa1.com:1234\");\n-    URI uri2 = URI.create(\"http://test.qa2.com:2345\");\n-    URI uri3 = URI.create(\"http://test.qa3.com:6789\");\n+    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTP_SCHEME, partitionIdForCheck), expectedNumHttp,\n+        \"Http cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttp);\n+    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTPS_SCHEME, partitionIdForCheck), expectedNumHttps,\n+        \"Https cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttps);\n+  }\n \n+  private void populateUriRegistry(int numHttp, int numHttps, int partitionIdForAdd, MockStore<UriProperties> uriRegistry)\n+  {\n     Map<Integer, PartitionData> partitionData = new HashMap<>(1);\n     partitionData.put(partitionIdForAdd, new PartitionData(1d));\n     Map<URI, Map<Integer, PartitionData>> uriData = new HashMap<URI, Map<Integer, PartitionData>>(numHttp);\n     Set<String> schemeSet = new HashSet<>();\n     schemeSet.add(PropertyKeys.HTTP_SCHEME);\n     schemeSet.add(PropertyKeys.HTTPS_SCHEME);\n-    for (String scheme : schemeSet) {\n+    for (String scheme : schemeSet)\n+    {\n       for (int i = 0; i < (scheme.equals(PropertyKeys.HTTP_SCHEME) ? numHttp : numHttps); i++) {\n         uriData.put(URI.create(scheme + \"://test.qa\" + i + \".com:1234\"), partitionData);\n       }\n     }\n+    uriRegistry.put(CLUSTER1_NAME, new UriProperties(CLUSTER1_NAME, uriData));\n+  }\n+  @Test\n+  public void testClusterInfoProviderGetDarkClusters()\n+      throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    int numHttp = 3;\n+    int numHttps = 4;\n+    int partitionIdForAdd = 0;\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n \n-    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME));\n+    DarkClusterConfig darkClusterConfig = new DarkClusterConfig().setMultiplier(1.0f);\n+    DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap();\n+    darkClusterConfigMap.put(DARK_CLUSTER1_NAME, darkClusterConfig);\n \n-    uriRegistry.put(CLUSTER1_NAME, new UriProperties(CLUSTER1_NAME, uriData));\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+        Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(), darkClusterConfigMap));\n \n-    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTP_SCHEME, partitionIdForCheck), expectedNumHttp,\n-        \"Http cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttp);\n-    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTPS_SCHEME, partitionIdForCheck), expectedNumHttps,\n-        \"Https cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttps);\n+    populateUriRegistry(numHttp, numHttps, partitionIdForAdd, uriRegistry);\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(CLUSTER1_NAME);\n+    Assert.assertEquals(returnedDarkClusterConfigMap, darkClusterConfigMap, \"dark cluster configs should be equal\");\n+    Assert.assertEquals(returnedDarkClusterConfigMap.get(DARK_CLUSTER1_NAME).getMultiplier(), 1.0f, \"multiplier should match\");\n+  }\n+\n+  @Test\n+  public void testClusterInfoProviderGetDarkClustersNoUris()\n+      throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+\n+    DarkClusterConfig darkClusterConfig = new DarkClusterConfig().setMultiplier(1.0f);\n+    DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap();\n+    darkClusterConfigMap.put(DARK_CLUSTER1_NAME, darkClusterConfig);\n+\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+        Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(), darkClusterConfigMap));\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(CLUSTER1_NAME);\n+    Assert.assertEquals(returnedDarkClusterConfigMap, darkClusterConfigMap, \"dark cluster configs should be equal\");\n+    Assert.assertEquals(returnedDarkClusterConfigMap.get(DARK_CLUSTER1_NAME).getMultiplier(), 1.0f, \"multiplier should match\");\n+  }\n+\n+  @Test\n+  public void testClusterInfoProviderGetDarkClustersNoCluster()\n+    throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(NONEXISTENT_CLUSTER);\n+    Assert.assertEquals(returnedDarkClusterConfigMap.size(), 0, \"expected empty map\");\n+  }\n+\n+  @Test\n+  /**\n+   * The Register cluster Listener code is already tested in SimpleLoadBalancerStateTest, this is here for testing the\n+   * SimpleLoadBalancer API exposing this.\n+   */\n+  public void testClusterInfoProviderRegisterClusterListener()\n+    throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+    FutureCallback<None> balancerCallback = new FutureCallback<None>();\n+    loadBalancer.start(balancerCallback);\n+    balancerCallback.get();\n+    TestClusterListener testClusterListener = new TestClusterListener();\n+    loadBalancer.registerClusterListener(testClusterListener);\n+    loadBalancer.listenToCluster(CLUSTER1_NAME, false, new LoadBalancerState.NullStateListenerCallback());\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+                                                             Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(),\n+                                                             new DarkClusterConfigMap()));\n+    Assert.assertEquals(testClusterListener.addCount, 1, \"expected add count of 1\");\n+    Assert.assertEquals(testClusterListener.removeCount, 0, \"expected remove count of 0\");\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    PropertyEventShutdownCallback callback = () -> latch.countDown();\n+    loadBalancer.shutdown(callback);\n+    if (!latch.await(60, TimeUnit.SECONDS))\n+    {\n+      fail(\"unable to shutdown state\");\n+    }\n+    Assert.assertEquals(testClusterListener.addCount, 1, \"expected add count of 1\");\n+    Assert.assertEquals(testClusterListener.removeCount, 1, \"expected remove count of 1\");\n+\n+    // now unregister, and we don't expect the counts to change.\n+    loadBalancer.unregisterClusterListener(testClusterListener);\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+                                                             Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(),\n+                                                             new DarkClusterConfigMap()));\n+    Assert.assertEquals(testClusterListener.addCount, 1, \"expected add count of 1\");\n+    Assert.assertEquals(testClusterListener.removeCount, 0, \"expected remove count of 0\");\n+\n+  }\n+\n+  @Test\n+  public void testClusterInfoProviderUnregisterClusterListener()\n+    throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+    FutureCallback<None> balancerCallback = new FutureCallback<None>();\n+    loadBalancer.start(balancerCallback);\n+    balancerCallback.get();\n+    TestClusterListener testClusterListener = new TestClusterListener();\n+    loadBalancer.registerClusterListener(testClusterListener);\n+    loadBalancer.listenToCluster(CLUSTER1_NAME, false, new LoadBalancerState.NullStateListenerCallback());\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+                                                             Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(),\n+                                                             new DarkClusterConfigMap()));\n+    Assert.assertEquals(testClusterListener.addCount, 1, \"expected add count of 1\");\n+    Assert.assertEquals(testClusterListener.removeCount, 0, \"expected remove count of 0\");\n+\n+    // now unregister, and we don't expect the counts to change.\n+    loadBalancer.unregisterClusterListener(testClusterListener);\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+                                                             Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(),\n+                                                             new DarkClusterConfigMap()));\n+    Assert.assertEquals(testClusterListener.addCount, 1, \"expected add count of 1\");\n+    Assert.assertEquals(testClusterListener.removeCount, 0, \"expected remove count of 0\");\n+\n+  }\n+\n+  private static class TestClusterListener implements LoadBalancerClusterListener", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxODMyNQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404518325", "bodyText": "thanks for catching. I had written these at different times and didn't realize I had already done this.", "author": "davidhoa", "createdAt": "2020-04-07T03:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM0NDQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM0ODk3NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404348974", "bodyText": "please place before @test annotation", "author": "zhang-chris", "createdAt": "2020-04-06T19:54:05Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerTest.java", "diffHunk": "@@ -185,57 +216,186 @@ public void testClusterInfoProvider(int numHttp, int numHttps, int expectedNumHt\n       int partitionIdForAdd, int partitionIdForCheck)\n       throws InterruptedException, ExecutionException, ServiceUnavailableException\n   {\n-    Map<String, LoadBalancerStrategyFactory<? extends LoadBalancerStrategy>> loadBalancerStrategyFactories =\n-        new HashMap<>();\n-    Map<String, TransportClientFactory> clientFactories = new HashMap<>();\n-\n     MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n     MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n     MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n \n-    loadBalancerStrategyFactories.put(\"degrader\", new DegraderLoadBalancerStrategyFactoryV3());\n-    clientFactories.put(PropertyKeys.HTTP_SCHEME, new DoNothingClientFactory());\n-    clientFactories.put(PropertyKeys.HTTPS_SCHEME, new DoNothingClientFactory());\n-\n-    SimpleLoadBalancerState state =\n-        new SimpleLoadBalancerState(new SynchronousExecutorService(),\n-            uriRegistry,\n-            clusterRegistry,\n-            serviceRegistry,\n-            clientFactories,\n-            loadBalancerStrategyFactories);\n-\n-    SimpleLoadBalancer loadBalancer =\n-        new SimpleLoadBalancer(state, 5, TimeUnit.SECONDS, _d2Executor);\n-\n-    FutureCallback<None> balancerCallback = new FutureCallback<None>();\n-    loadBalancer.start(balancerCallback);\n-    balancerCallback.get();\n+    populateUriRegistry(numHttp, numHttps, partitionIdForAdd, uriRegistry);\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME));\n \n-    URI uri1 = URI.create(\"http://test.qa1.com:1234\");\n-    URI uri2 = URI.create(\"http://test.qa2.com:2345\");\n-    URI uri3 = URI.create(\"http://test.qa3.com:6789\");\n+    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTP_SCHEME, partitionIdForCheck), expectedNumHttp,\n+        \"Http cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttp);\n+    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTPS_SCHEME, partitionIdForCheck), expectedNumHttps,\n+        \"Https cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttps);\n+  }\n \n+  private void populateUriRegistry(int numHttp, int numHttps, int partitionIdForAdd, MockStore<UriProperties> uriRegistry)\n+  {\n     Map<Integer, PartitionData> partitionData = new HashMap<>(1);\n     partitionData.put(partitionIdForAdd, new PartitionData(1d));\n     Map<URI, Map<Integer, PartitionData>> uriData = new HashMap<URI, Map<Integer, PartitionData>>(numHttp);\n     Set<String> schemeSet = new HashSet<>();\n     schemeSet.add(PropertyKeys.HTTP_SCHEME);\n     schemeSet.add(PropertyKeys.HTTPS_SCHEME);\n-    for (String scheme : schemeSet) {\n+    for (String scheme : schemeSet)\n+    {\n       for (int i = 0; i < (scheme.equals(PropertyKeys.HTTP_SCHEME) ? numHttp : numHttps); i++) {\n         uriData.put(URI.create(scheme + \"://test.qa\" + i + \".com:1234\"), partitionData);\n       }\n     }\n+    uriRegistry.put(CLUSTER1_NAME, new UriProperties(CLUSTER1_NAME, uriData));\n+  }\n+  @Test\n+  public void testClusterInfoProviderGetDarkClusters()\n+      throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    int numHttp = 3;\n+    int numHttps = 4;\n+    int partitionIdForAdd = 0;\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n \n-    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME));\n+    DarkClusterConfig darkClusterConfig = new DarkClusterConfig().setMultiplier(1.0f);\n+    DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap();\n+    darkClusterConfigMap.put(DARK_CLUSTER1_NAME, darkClusterConfig);\n \n-    uriRegistry.put(CLUSTER1_NAME, new UriProperties(CLUSTER1_NAME, uriData));\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+        Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(), darkClusterConfigMap));\n \n-    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTP_SCHEME, partitionIdForCheck), expectedNumHttp,\n-        \"Http cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttp);\n-    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTPS_SCHEME, partitionIdForCheck), expectedNumHttps,\n-        \"Https cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttps);\n+    populateUriRegistry(numHttp, numHttps, partitionIdForAdd, uriRegistry);\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(CLUSTER1_NAME);\n+    Assert.assertEquals(returnedDarkClusterConfigMap, darkClusterConfigMap, \"dark cluster configs should be equal\");\n+    Assert.assertEquals(returnedDarkClusterConfigMap.get(DARK_CLUSTER1_NAME).getMultiplier(), 1.0f, \"multiplier should match\");\n+  }\n+\n+  @Test\n+  public void testClusterInfoProviderGetDarkClustersNoUris()\n+      throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+\n+    DarkClusterConfig darkClusterConfig = new DarkClusterConfig().setMultiplier(1.0f);\n+    DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap();\n+    darkClusterConfigMap.put(DARK_CLUSTER1_NAME, darkClusterConfig);\n+\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+        Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(), darkClusterConfigMap));\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(CLUSTER1_NAME);\n+    Assert.assertEquals(returnedDarkClusterConfigMap, darkClusterConfigMap, \"dark cluster configs should be equal\");\n+    Assert.assertEquals(returnedDarkClusterConfigMap.get(DARK_CLUSTER1_NAME).getMultiplier(), 1.0f, \"multiplier should match\");\n+  }\n+\n+  @Test\n+  public void testClusterInfoProviderGetDarkClustersNoCluster()\n+    throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(NONEXISTENT_CLUSTER);\n+    Assert.assertEquals(returnedDarkClusterConfigMap.size(), 0, \"expected empty map\");\n+  }\n+\n+  @Test\n+  /**\n+   * The Register cluster Listener code is already tested in SimpleLoadBalancerStateTest, this is here for testing the\n+   * SimpleLoadBalancer API exposing this.\n+   */", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ4ODIzNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404488234", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T01:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM0ODk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NTAyNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404355026", "bodyText": "For constant multiplier strategy why isn't it just a straight multiple? Do we even need to take into account number of hosts in the cluster?", "author": "zhang-chris", "createdAt": "2020-04-06T20:05:16Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/ConstantMultiplierDarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Random;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * ConstantMultiplierDarkClusterStrategy figures out how many dark requests to send. It uses the {@link ClusterInfoProvider} to determine the number of\n+ * instances in both the source and target cluster, and uses that to calculate the number of request to send in order to make the level of traffic\n+ * proportional to itself on any instance in the dark cluster (accounting for multiplier), assuming all hosts in the source cluster send traffic.\n+ */\n+public class ConstantMultiplierDarkClusterStrategy implements DarkClusterStrategy\n+{\n+  private final String _originalClusterName;\n+  private final String _darkClusterName;\n+  private final Float _multiplier;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Random _random;\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public ConstantMultiplierDarkClusterStrategy(@Nonnull String originalClusterName, @Nonnull String darkClusterName, @Nonnull Float multiplier,\n+                                               @Nonnull BaseDarkClusterDispatcher baseDarkClusterDispatcher,\n+                                               @Nonnull Notifier notifier,\n+                                               @Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                               @Nonnull Random random)\n+  {\n+    _originalClusterName = originalClusterName;\n+    _darkClusterName = darkClusterName;\n+    _multiplier = multiplier;\n+    _baseDarkClusterDispatcher = baseDarkClusterDispatcher;\n+    _notifier = notifier;\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _random = random;\n+  }\n+\n+  @Override\n+  public boolean handleRequest(RestRequest originalRequest, RestRequest darkRequest, RequestContext requestContext)\n+  {\n+    int numRequestDuplicates = getNumDuplicateRequests(_random.nextFloat());\n+    return _baseDarkClusterDispatcher.sendRequest(originalRequest, darkRequest, requestContext, numRequestDuplicates);\n+  }\n+\n+  /**\n+   * The formula to keep traffic proportional to the sending cluster is\n+   * Avg#DarkRequests = ((# instances in dark cluster) * multiplier) / (# instances in source cluster)", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyNzUxMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404527510", "bodyText": "the objective of this strategy is to keep the traffic on the dark cluster instance relative to the source cluster instance. So you need to take into account both source and target # of hosts. As we talked about, I should renamed this back to RelativeTrafficMultiplierStrategy. Does that make sense?", "author": "davidhoa", "createdAt": "2020-04-07T04:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1NTYwOA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405055608", "bodyText": "Yep - sorry forgot to remove this comment after we discussed. Let me think about naming. Not a huge fan of RelativeTraffic either since it's still not obvious that traffic is kept proportional for individual hosts.", "author": "zhang-chris", "createdAt": "2020-04-07T19:23:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NTAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NzY0MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404357640", "bodyText": "Can we remove this comment?", "author": "zhang-chris", "createdAt": "2020-04-06T20:10:18Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ * start() must be called in order to register the ClusterListener.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  // ClusterInfoProvider isn't available until the D2 client is started, so it can't be\n+  // populated during construction time.\n+  private final Facilities _facilities;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull Facilities facilities,\n+                                        @Nonnull String sourceClusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _facilities = facilities;\n+    _sourceClusterName = sourceClusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new DarkClusterListener();\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    _facilities.getClusterInfoProvider().registerClusterListener(_clusterListener);\n+  }\n+\n+  @Override\n+  public void shutdown()\n+  {\n+    _facilities.getClusterInfoProvider().unregisterClusterListener(_clusterListener);\n+  }\n+\n+\n+\n+  @Override\n+  public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull DarkClusterConfig darkClusterConfig)\n+  {\n+    if (!_darkStrategyMap.containsKey(darkClusterName))\n+    {\n+      _darkStrategyMap.putIfAbsent(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName, darkClusterConfig)));\n+    }\n+    // it's theoretically possible for the Listener to remove the entry after the containsKey but before we retrieve it. Rather\n+    // than adding synchronization between accessors of _darkStrategyMap, we will make each put or get resilient\n+    //return _darkStrategyMap.get(darkClusterName).get();", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzMDI3NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404530275", "bodyText": "I removed the  commented out return statement.", "author": "davidhoa", "createdAt": "2020-04-07T04:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NzY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1ODIwMw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404358203", "bodyText": "This should be under a functional API instead otherwise every time we call this method we are creating a new AtomicReference and NoOpDarkClusterStrategy.", "author": "zhang-chris", "createdAt": "2020-04-06T20:11:25Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ * start() must be called in order to register the ClusterListener.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  // ClusterInfoProvider isn't available until the D2 client is started, so it can't be\n+  // populated during construction time.\n+  private final Facilities _facilities;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull Facilities facilities,\n+                                        @Nonnull String sourceClusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _facilities = facilities;\n+    _sourceClusterName = sourceClusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new DarkClusterListener();\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    _facilities.getClusterInfoProvider().registerClusterListener(_clusterListener);\n+  }\n+\n+  @Override\n+  public void shutdown()\n+  {\n+    _facilities.getClusterInfoProvider().unregisterClusterListener(_clusterListener);\n+  }\n+\n+\n+\n+  @Override\n+  public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull DarkClusterConfig darkClusterConfig)\n+  {\n+    if (!_darkStrategyMap.containsKey(darkClusterName))\n+    {\n+      _darkStrategyMap.putIfAbsent(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName, darkClusterConfig)));\n+    }\n+    // it's theoretically possible for the Listener to remove the entry after the containsKey but before we retrieve it. Rather\n+    // than adding synchronization between accessors of _darkStrategyMap, we will make each put or get resilient\n+    //return _darkStrategyMap.get(darkClusterName).get();\n+    return _darkStrategyMap.getOrDefault(darkClusterName, new AtomicReference<DarkClusterStrategy>(new NoOpDarkClusterStrategy())).get();", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2Mzg5Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404363892", "bodyText": "or rather we should just\nprivate static final NO_OP_DARK_CLUSTER_STRATEGY = ...;\nreturn _darkStrategyMap.getOrDefault(darkClusterName, NO_OP_DARK_CLUSTER_STRATEGY);", "author": "zhang-chris", "createdAt": "2020-04-06T20:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1ODIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzMTQyNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404531424", "bodyText": "great idea, thanks for the catch.", "author": "davidhoa", "createdAt": "2020-04-07T04:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1ODIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NDIxMQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404364211", "bodyText": "Is AtomicReference necessary?", "author": "zhang-chris", "createdAt": "2020-04-06T20:22:26Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ * start() must be called in order to register the ClusterListener.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  // ClusterInfoProvider isn't available until the D2 client is started, so it can't be\n+  // populated during construction time.\n+  private final Facilities _facilities;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUyOTgzMw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404529833", "bodyText": "yes, it is, because otherwise the map needs to be volatile, and that's slower. We use this pattern elsewhere in pegasus as well.", "author": "davidhoa", "createdAt": "2020-04-07T04:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NDIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA1OTYxNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405059614", "bodyText": "Still not clear to me why we need atomic reference. Let's discuss.", "author": "zhang-chris", "createdAt": "2020-04-07T19:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NDIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDczNQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r406420735", "bodyText": "Will remove the AtomicReference, the concurrency aspect is addressed by the ConcurrentHashMap, and we will make a note that the DarkClusterStrategy needs to be threadsafe.", "author": "davidhoa", "createdAt": "2020-04-09T19:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NDIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2OTMyMw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404369323", "bodyText": "I forget if I already left a comment about this so I might be repeating myself but can we still account for this in code? In theory we should never worry about source cluster removed but that's controlled by a completely independent component. We can handle it and/or log a warning.", "author": "zhang-chris", "createdAt": "2020-04-06T20:31:22Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ * start() must be called in order to register the ClusterListener.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  // ClusterInfoProvider isn't available until the D2 client is started, so it can't be\n+  // populated during construction time.\n+  private final Facilities _facilities;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull Facilities facilities,\n+                                        @Nonnull String sourceClusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _facilities = facilities;\n+    _sourceClusterName = sourceClusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new DarkClusterListener();\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    _facilities.getClusterInfoProvider().registerClusterListener(_clusterListener);\n+  }\n+\n+  @Override\n+  public void shutdown()\n+  {\n+    _facilities.getClusterInfoProvider().unregisterClusterListener(_clusterListener);\n+  }\n+\n+\n+\n+  @Override\n+  public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull DarkClusterConfig darkClusterConfig)\n+  {\n+    if (!_darkStrategyMap.containsKey(darkClusterName))\n+    {\n+      _darkStrategyMap.putIfAbsent(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName, darkClusterConfig)));\n+    }\n+    // it's theoretically possible for the Listener to remove the entry after the containsKey but before we retrieve it. Rather\n+    // than adding synchronization between accessors of _darkStrategyMap, we will make each put or get resilient\n+    //return _darkStrategyMap.get(darkClusterName).get();\n+    return _darkStrategyMap.getOrDefault(darkClusterName, new AtomicReference<DarkClusterStrategy>(new NoOpDarkClusterStrategy())).get();\n+  }\n+\n+  /**\n+   * In the future, additional strategies can be added, and the logic here can choose the appropriate one based on the config values.\n+   */\n+  private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n+  {\n+    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    {\n+      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n+                                                                                              _notifier, _verifierManager);\n+      return new ConstantMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                       baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n+    }\n+    else\n+    {\n+      return new NoOpDarkClusterStrategy();\n+    }\n+  }\n+\n+  /**\n+   * DarkClusterListener will only take action on dark clusters that exist in the strategy map.\n+   */\n+  private class DarkClusterListener implements LoadBalancerClusterListener\n+  {\n+\n+    @Override\n+    public void onClusterAdded(String updatedClusterName)\n+    {\n+      // We will be listening to both the source cluster because we needed the DarkClusterConfig\n+      // from the source cluster, and that called listenToCluster.\n+      // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n+      // to the dark clusters, and will be listening on the dark cluster znodes.\n+      // It is more precise to update on just dark cluster updates, because listening on the\n+      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n+      // we know for sure we need to update that dark cluster.\n+      if (_darkStrategyMap.containsKey(updatedClusterName))\n+      {\n+        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n+        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n+        // to recreate the dark cluster strategies, such as the multiplier.\n+        String darkClusterName = updatedClusterName;\n+        try\n+        {\n+          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+          if (darkConfigMap.containsKey(darkClusterName))\n+          {\n+            // just update the dark cluster that changed\n+            _darkStrategyMap.put(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName,\n+                                                                                          darkConfigMap.get(darkClusterName))));\n+          }\n+        }\n+        catch (ServiceUnavailableException e)\n+        {\n+          _notifier.notify(() -> new RuntimeException(\"PEGA_0019 unable to refresh DarkClusterConfigMap for source cluster: \"\n+                                                        + _sourceClusterName + \", darkClusterName: \" + darkClusterName));\n+        }\n+      }\n+    }\n+\n+    /**\n+     * The only thing we can do on onClusterRemoved is to remove the cluster that got triggered. Theoretically we should never see the source\n+     * cluster being removed if we still have strategies for it's dark clusters. If there is any case where the source cluster", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzMjU4NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404532584", "bodyText": "you already did mention it. But no, we cannot handle it. There is nothing we can do. Even given a source cluster, we don't know what the dark clusters that were corresponding to it (there's no properties associated with the event on remove), nor should we attempt to keep track of it because that involves maintaining a separate source-of-truth that can get out of sync with the original, and cause unexpected problems.  There's nothing to even indicate it's a source cluster, it could just be another random cluster.", "author": "davidhoa", "createdAt": "2020-04-07T04:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2OTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2OTg0OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404369849", "bodyText": "DefaultDarkClusterDispatcherImpl -> DefaultDarkClusterDispatcher\nno need for impl", "author": "zhang-chris", "createdAt": "2020-04-06T20:32:23Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DefaultDarkClusterDispatcherImpl.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+import com.linkedin.r2.transport.common.Client;\n+\n+/**\n+ * Default implementation of DarkClusterDispatcher\n+ * requests should probably be offloaded to an executor.\n+ */\n+public class DefaultDarkClusterDispatcherImpl implements DarkClusterDispatcher", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzMjg1MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404532850", "bodyText": "ok, while I prefer the impl for consistency, I'll change it.", "author": "davidhoa", "createdAt": "2020-04-07T04:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2OTg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NDI2MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404374260", "bodyText": "can we remove?", "author": "zhang-chris", "createdAt": "2020-04-06T20:40:16Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestConstantMultiplierDarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.impl.BaseDarkClusterDispatcherImpl;\n+import com.linkedin.darkcluster.impl.ConstantMultiplierDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class TestConstantMultiplierDarkClusterStrategy\n+{\n+  private static final String SOURCE_CLUSTER_NAME = \"FooCluster\";\n+  private static final String DARK_CLUSTER_NAME = \"fooCluster-dark\";\n+  private static final int SEED = 2;\n+  private static final float ERR_PCT = 0.30f; // 5%\n+\n+  @DataProvider\n+  public Object[][] multiplierKeys()\n+  {\n+    return new Object[][] {\n+      // numIterations, multiplier, numSourceInstances, numDarkInstances\n+      {0, 0f, 10, 10},\n+      {0, 1f, 10, 10},\n+      {1000, 0.1f, 10, 10},\n+      {1000, 0.25f, 10, 10},\n+      {1000, 0.5f, 10, 10},\n+      {1000, 1f, 10, 10},\n+      {1000, 1.5f, 10, 10},\n+      {100, 2f, 10, 10},\n+      // now test typical case of multiplier ~1 with different instance sizes\n+      {1000, 1f, 10, 1},\n+      {1000, 0.9f, 10, 1},\n+      {1000, 1.2f, 10, 1},\n+      {1000, 1f, 10, 2},\n+      {1000, 1f, 40, 3},\n+      {1000, 2f, 10, 1},\n+      {1000, 2.5f, 10, 1},\n+      {1000, 4f, 10, 1}\n+    };\n+  }\n+\n+  // disabled til ConstantMultiplierDarkClusterStrategy is fully implemented.", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzMzQ3Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404533476", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T04:51:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NDI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NTUzOA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404375538", "bodyText": "We should also be testing the filter behavior, even if it's simple. With the current test we only verify that request/response can pass through the filter without exception.", "author": "zhang-chris", "createdAt": "2020-04-06T20:42:44Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterFilter.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerTestState;\n+import com.linkedin.d2.balancer.simple.SimpleLoadBalancer;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterVerifier;\n+import com.linkedin.darkcluster.filter.DarkClusterFilter;\n+import com.linkedin.darkcluster.impl.DarkClusterManagerImpl;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DarkClusterVerifierManagerImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.filter.NextFilter;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+import com.linkedin.r2.message.rest.RestResponse;\n+import com.linkedin.r2.message.rest.RestResponseBuilder;\n+\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterFilter", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0NzAxNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404547016", "bodyText": "added a test for testing if requests get sent.", "author": "davidhoa", "createdAt": "2020-04-07T05:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc4MjY2Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405782666", "bodyText": "Sorry I was unclear. Since this is a unit test we shouldn't be testing that the request gets sent. That's layers down. Tests should be just verifying that request was passed to both the managers when we expect. I notice you don't use Mocks much, that would make testing this a lot easier, as well as remove a lot of the setup code needed.", "author": "zhang-chris", "createdAt": "2020-04-08T20:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3NTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjA5MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404386091", "bodyText": "My concern with this test is that we're verifying based on MockClient and RequestAuthorityMap, both of which are implementation details that DarkClusterManager doesn't care about. Can we instead just mock DarkClusterStrategyFactory and verify that it is being called correctly based on black/whitelists and with the right Request url? Instead of going an extra layer down into the factory impl.", "author": "zhang-chris", "createdAt": "2020-04-06T21:02:16Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterManager.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.impl.DarkClusterManagerImpl;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import static com.linkedin.darkcluster.TestDarkClusterStrategyFactory.DARK_CLUSTER_NAME;\n+import static com.linkedin.darkcluster.TestDarkClusterStrategyFactory.SEED;\n+import static com.linkedin.darkcluster.TestDarkClusterStrategyFactory.SOURCE_CLUSTER_NAME;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterManager\n+{\n+  private static final String METHOD_SAFE = \"GET\";\n+  private static final String METHOD_UNSAFE = \"POST\";\n+\n+  @DataProvider\n+  public Object[][] provideKeys()\n+  {\n+    return new Object[][] {\n+      // whitelist, blacklist, httpMethod, expected white count, expected black count\n+      {null, null, METHOD_SAFE, 1, 1},\n+      {null, null, METHOD_UNSAFE, 0, 0},\n+      {\".*white.*\", null, METHOD_SAFE, 1, 1},\n+      {\".*white.*\", null, METHOD_UNSAFE, 1, 0},\n+      {\".*white.*\", \".*black.*\", METHOD_SAFE, 1, 0},\n+      {\".*white.*\", \".*black.*\", METHOD_UNSAFE, 1, 0},\n+      {null, \".*black.*\", METHOD_SAFE, 1, 0},\n+      {null, \".*black.*\", METHOD_UNSAFE, 0, 0}\n+    };\n+  }\n+\n+  @Test(dataProvider = \"provideKeys\")\n+  public void testBasic(String whitelist, String blacklist, String httpMethod, int expectedWhiteCount, int expectedBlackCount)", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1NjYwMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404556600", "bodyText": "ok, done. I think it achieves the same thing.", "author": "davidhoa", "createdAt": "2020-04-07T06:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxNDM0Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404414346", "bodyText": "Can we extract out all setup into a @BeforeMethod setup method? That way the individual tests are more readable and slim.", "author": "zhang-chris", "createdAt": "2020-04-06T21:59:38Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.ConstantMultiplierDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import static org.testng.Assert.fail;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterStrategyFactory\n+{\n+  static final String SOURCE_CLUSTER_NAME = \"FooCluster\";\n+  static final String DARK_CLUSTER_NAME = \"FooCluster-dark\";\n+  static final int SEED = 2;\n+\n+  @Test\n+  public void testCreateStrategiesWithNoDarkClusters()\n+  {\n+    ClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1OTUyMQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404559521", "bodyText": "ah yes, I should have caught that. done.", "author": "davidhoa", "createdAt": "2020-04-07T06:16:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxNDM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MjcxMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404442710", "bodyText": "Let's separate out behaviors into different tests. Line 93 is one test, and this is another.", "author": "zhang-chris", "createdAt": "2020-04-06T23:11:39Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.ConstantMultiplierDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import static org.testng.Assert.fail;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterStrategyFactory\n+{\n+  static final String SOURCE_CLUSTER_NAME = \"FooCluster\";\n+  static final String DARK_CLUSTER_NAME = \"FooCluster-dark\";\n+  static final int SEED = 2;\n+\n+  @Test\n+  public void testCreateStrategiesWithNoDarkClusters()\n+  {\n+    ClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory = new DarkClusterStrategyFactoryImpl(facilities,\n+                                                                                    SOURCE_CLUSTER_NAME,\n+                                                                                    darkClusterDispatcher,\n+                                                                                    new DoNothingNotifier(),\n+                                                                                    new Random(SEED),\n+                                                                                    new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, new DarkClusterConfig());\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    boolean requestSent = strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    Assert.assertTrue(strategy instanceof NoOpDarkClusterStrategy);\n+    Assert.assertFalse(requestSent, \"default empty strategy should not send request\");\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesWithDarkClusters()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // update Strategy, simulating a refresh.\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig2);\n+    clusterInfoProvider.triggerClusterRefresh(SOURCE_CLUSTER_NAME);\n+    // Nothing should have been changed, since we should be ignoring source cluster changes.\n+    DarkClusterStrategy strategy2 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy2 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy2).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // now trigger a refresh on the dark cluster. Note that darkClusterConfig1 is ignored since there should already be an entry for this\n+    // dark cluster, and we should get the strategy associated with darkClusterConfig2 back.\n+    clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2ODcwNw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404568707", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T06:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0MjcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NDUyMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404444520", "bodyText": "Throughout the tests in this PR we are assuming that\nDarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n.setMultiplier(0.1f);\nis considered a ConstantMultiplierDarkClusterStrategy.\nInstead of implicitly assuming, we should instead encapsulate it in a helper method to clarify intent and keep it future proof.\npublic class DarkClusterTestUtil\n{\npublic static DarkClusterConfig createConstantMultiplierConfig(float multiplier)\n}", "author": "zhang-chris", "createdAt": "2020-04-06T23:16:42Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.ConstantMultiplierDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import static org.testng.Assert.fail;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterStrategyFactory\n+{\n+  static final String SOURCE_CLUSTER_NAME = \"FooCluster\";\n+  static final String DARK_CLUSTER_NAME = \"FooCluster-dark\";\n+  static final int SEED = 2;\n+\n+  @Test\n+  public void testCreateStrategiesWithNoDarkClusters()\n+  {\n+    ClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory = new DarkClusterStrategyFactoryImpl(facilities,\n+                                                                                    SOURCE_CLUSTER_NAME,\n+                                                                                    darkClusterDispatcher,\n+                                                                                    new DoNothingNotifier(),\n+                                                                                    new Random(SEED),\n+                                                                                    new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, new DarkClusterConfig());\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    boolean requestSent = strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    Assert.assertTrue(strategy instanceof NoOpDarkClusterStrategy);\n+    Assert.assertFalse(requestSent, \"default empty strategy should not send request\");\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesWithDarkClusters()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU2NDk4OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404564988", "bodyText": "great idea. done.", "author": "davidhoa", "createdAt": "2020-04-07T06:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NDUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NTM0OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404445349", "bodyText": "prefer notifyListenersClusterAdded and notifyListenersClusterRemoved for clarity.", "author": "zhang-chris", "createdAt": "2020-04-06T23:19:06Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/MockClusterInfoProvider.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+\n+public class MockClusterInfoProvider implements ClusterInfoProvider\n+{\n+  Map<String, DarkClusterConfigMap> lookupMap = new HashMap<>();\n+  List<LoadBalancerClusterListener> clusterListeners = new ArrayList<>();\n+  Map<String, Integer> clusterHttpsCount = new HashMap<>();\n+\n+  @Override\n+  public int getClusterCount(String clusterName, String scheme, int partitionId)\n+    throws ServiceUnavailableException\n+  {\n+    return 0;\n+  }\n+\n+  @Override\n+  public int getHttpsClusterCount(String clusterName)\n+    throws ServiceUnavailableException\n+  {\n+    return clusterHttpsCount.getOrDefault(clusterName, 1);\n+  }\n+\n+  @Override\n+  public DarkClusterConfigMap getDarkClusterConfigMap(String clusterName)\n+    throws ServiceUnavailableException\n+  {\n+    return lookupMap.get(clusterName);\n+  }\n+\n+  @Override\n+  public void registerClusterListener(LoadBalancerClusterListener clusterListener)\n+  {\n+    clusterListeners.add(clusterListener);\n+  }\n+\n+  @Override\n+  public void unregisterClusterListener(LoadBalancerClusterListener clusterListener)\n+  {\n+    clusterListeners.remove(clusterListener);\n+  }\n+\n+  /**\n+   * add the ability to add a dark cluster to a source cluster's darkClusterConfigMap\n+   */\n+  void addDarkClusterConfig(String sourceClusterName, String darkClusterName, DarkClusterConfig darkClusterConfig)\n+  {\n+    DarkClusterConfigMap darkClusterConfigMap = (lookupMap.containsKey(sourceClusterName)) ? lookupMap.get(sourceClusterName) :\n+      new DarkClusterConfigMap();\n+\n+    darkClusterConfigMap.put(darkClusterName, darkClusterConfig);\n+    lookupMap.put(sourceClusterName, darkClusterConfigMap);\n+  }\n+\n+  void triggerClusterRefresh(String clusterName)", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzMzMxOQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404533319", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T04:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NjI4MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404446280", "bodyText": "unnecessary, can remove.", "author": "zhang-chris", "createdAt": "2020-04-06T23:21:54Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.ConstantMultiplierDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import static org.testng.Assert.fail;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterStrategyFactory\n+{\n+  static final String SOURCE_CLUSTER_NAME = \"FooCluster\";\n+  static final String DARK_CLUSTER_NAME = \"FooCluster-dark\";\n+  static final int SEED = 2;\n+\n+  @Test\n+  public void testCreateStrategiesWithNoDarkClusters()\n+  {\n+    ClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory = new DarkClusterStrategyFactoryImpl(facilities,\n+                                                                                    SOURCE_CLUSTER_NAME,\n+                                                                                    darkClusterDispatcher,\n+                                                                                    new DoNothingNotifier(),\n+                                                                                    new Random(SEED),\n+                                                                                    new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, new DarkClusterConfig());\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    boolean requestSent = strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    Assert.assertTrue(strategy instanceof NoOpDarkClusterStrategy);\n+    Assert.assertFalse(requestSent, \"default empty strategy should not send request\");\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesWithDarkClusters()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // update Strategy, simulating a refresh.\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig2);\n+    clusterInfoProvider.triggerClusterRefresh(SOURCE_CLUSTER_NAME);\n+    // Nothing should have been changed, since we should be ignoring source cluster changes.\n+    DarkClusterStrategy strategy2 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy2 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy2).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // now trigger a refresh on the dark cluster. Note that darkClusterConfig1 is ignored since there should already be an entry for this\n+    // dark cluster, and we should get the strategy associated with darkClusterConfig2 back.\n+    clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);\n+    DarkClusterStrategy strategy3 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy3 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy3).getMultiplier(), 0.1f, \"expected 0.1f multiplier\");\n+\n+    // if someone has a handle to old strategies, those should still be usable.\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    strategy2.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesAfterStoppingListener()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    strategyFactory.shutdown();\n+\n+    // now trigger a refresh on the dark cluster. Note that darkClusterConfig1 is ignored since there should already be an entry for this\n+    // dark cluster, and we should get the strategy associated with darkClusterConfig2 back.\n+    clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);\n+    // Nothing should have been changed, since we should be ignoring source cluster changes.\n+    DarkClusterStrategy strategy2 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy2 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy2).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+  }\n+\n+  @Test\n+  public void testStrategyRaceCondition()\n+  {\n+    int noopStrategyCount = 0;\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig().setMultiplier(0.5f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy) strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // this was registered after DarkClusterStrategyFactoryImpl registered it's clusterListener.\n+    clusterInfoProvider.registerClusterListener(new DeletingClusterListener(clusterInfoProvider));\n+\n+    ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+    final CountDownLatch latch = new CountDownLatch(1);\n+\n+    try\n+    {\n+      scheduledExecutorService.scheduleAtFixedRate(() -> {\n+        clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);\n+        latch.countDown();\n+      }, 0, 1, TimeUnit.MILLISECONDS);\n+\n+      if (!latch.await(30, TimeUnit.SECONDS))\n+      {\n+        fail(\"unable to execute task on executor\");\n+      }\n+\n+      for (int i = 0; i< 100000; i++)\n+      {\n+        strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+        // verified that this will catch race conditions, saw it happen 9/100k times.\n+        Assert.assertNotNull(strategy, \"null at iteration: \" + i);\n+        if (strategy instanceof NoOpDarkClusterStrategy)\n+        {\n+          noopStrategyCount++;\n+        }\n+      }\n+      System.out.println(\"noopStrategyCount: \" + noopStrategyCount);\n+    }\n+    catch (InterruptedException ie)\n+    {\n+      fail(\"got interrupted exception\", ie);\n+    }\n+    finally\n+    {\n+      scheduledExecutorService.shutdown();\n+    }\n+\n+\n+  }\n+\n+  private static class DeletingClusterListener implements LoadBalancerClusterListener\n+  {\n+    // handle to MockClusterInfoProvider so it can call triggerCluster actions.", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3Mzk3MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404573971", "bodyText": "As explained in another comment, adding another task will not work, I tried it out and it doesn't reproduce the race problem because adding another task is not fast enough to cause inconsistent results in getOrCreate().", "author": "davidhoa", "createdAt": "2020-04-07T06:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NjI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzU5Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404447592", "bodyText": "Instead of wrapping triggerClusterRemove in DeletingClusterListener can we just decouple refresh and remove by scheduling two separate tasks in the executor?\nOne task for triggerClusterRefresh (what we already have)\nOne task for triggerClusterRemove\nthat way we don't need to further complicate with using this listener.", "author": "zhang-chris", "createdAt": "2020-04-06T23:25:40Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.ConstantMultiplierDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import static org.testng.Assert.fail;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterStrategyFactory\n+{\n+  static final String SOURCE_CLUSTER_NAME = \"FooCluster\";\n+  static final String DARK_CLUSTER_NAME = \"FooCluster-dark\";\n+  static final int SEED = 2;\n+\n+  @Test\n+  public void testCreateStrategiesWithNoDarkClusters()\n+  {\n+    ClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory = new DarkClusterStrategyFactoryImpl(facilities,\n+                                                                                    SOURCE_CLUSTER_NAME,\n+                                                                                    darkClusterDispatcher,\n+                                                                                    new DoNothingNotifier(),\n+                                                                                    new Random(SEED),\n+                                                                                    new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, new DarkClusterConfig());\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    boolean requestSent = strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    Assert.assertTrue(strategy instanceof NoOpDarkClusterStrategy);\n+    Assert.assertFalse(requestSent, \"default empty strategy should not send request\");\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesWithDarkClusters()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // update Strategy, simulating a refresh.\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig2);\n+    clusterInfoProvider.triggerClusterRefresh(SOURCE_CLUSTER_NAME);\n+    // Nothing should have been changed, since we should be ignoring source cluster changes.\n+    DarkClusterStrategy strategy2 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy2 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy2).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // now trigger a refresh on the dark cluster. Note that darkClusterConfig1 is ignored since there should already be an entry for this\n+    // dark cluster, and we should get the strategy associated with darkClusterConfig2 back.\n+    clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);\n+    DarkClusterStrategy strategy3 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy3 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy3).getMultiplier(), 0.1f, \"expected 0.1f multiplier\");\n+\n+    // if someone has a handle to old strategies, those should still be usable.\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    strategy2.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesAfterStoppingListener()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    strategyFactory.shutdown();\n+\n+    // now trigger a refresh on the dark cluster. Note that darkClusterConfig1 is ignored since there should already be an entry for this\n+    // dark cluster, and we should get the strategy associated with darkClusterConfig2 back.\n+    clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);\n+    // Nothing should have been changed, since we should be ignoring source cluster changes.\n+    DarkClusterStrategy strategy2 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy2 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy2).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+  }\n+\n+  @Test\n+  public void testStrategyRaceCondition()\n+  {\n+    int noopStrategyCount = 0;\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig().setMultiplier(0.5f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy) strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // this was registered after DarkClusterStrategyFactoryImpl registered it's clusterListener.\n+    clusterInfoProvider.registerClusterListener(new DeletingClusterListener(clusterInfoProvider));", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3MTk1NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404571955", "bodyText": "No, that won't reproduce the race condition because it's not fast enough, adding another task to the executor is slower than what it takes to go through getOrCreate(). So I'm going to leave the test as is and still use the DeletingClusterListener.", "author": "davidhoa", "createdAt": "2020-04-07T06:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0NzU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODE3Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404448177", "bodyText": "Is this latch necessary? I haven't seen this similar pattern of protecting against failed executor task in our codebase. Wondering if this is a valid concern and if we can just remove.", "author": "zhang-chris", "createdAt": "2020-04-06T23:27:27Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.ConstantMultiplierDarkClusterStrategy;\n+import com.linkedin.darkcluster.impl.DarkClusterStrategyFactoryImpl;\n+import com.linkedin.darkcluster.impl.DefaultDarkClusterDispatcherImpl;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+\n+import static org.testng.Assert.fail;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterStrategyFactory\n+{\n+  static final String SOURCE_CLUSTER_NAME = \"FooCluster\";\n+  static final String DARK_CLUSTER_NAME = \"FooCluster-dark\";\n+  static final int SEED = 2;\n+\n+  @Test\n+  public void testCreateStrategiesWithNoDarkClusters()\n+  {\n+    ClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory = new DarkClusterStrategyFactoryImpl(facilities,\n+                                                                                    SOURCE_CLUSTER_NAME,\n+                                                                                    darkClusterDispatcher,\n+                                                                                    new DoNothingNotifier(),\n+                                                                                    new Random(SEED),\n+                                                                                    new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, new DarkClusterConfig());\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    boolean requestSent = strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    Assert.assertTrue(strategy instanceof NoOpDarkClusterStrategy);\n+    Assert.assertFalse(requestSent, \"default empty strategy should not send request\");\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesWithDarkClusters()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // update Strategy, simulating a refresh.\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig2);\n+    clusterInfoProvider.triggerClusterRefresh(SOURCE_CLUSTER_NAME);\n+    // Nothing should have been changed, since we should be ignoring source cluster changes.\n+    DarkClusterStrategy strategy2 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy2 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy2).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // now trigger a refresh on the dark cluster. Note that darkClusterConfig1 is ignored since there should already be an entry for this\n+    // dark cluster, and we should get the strategy associated with darkClusterConfig2 back.\n+    clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);\n+    DarkClusterStrategy strategy3 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy3 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy3).getMultiplier(), 0.1f, \"expected 0.1f multiplier\");\n+\n+    // if someone has a handle to old strategies, those should still be usable.\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    strategy.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+    strategy2.handleRequest(dummyRestRequest, dummyRestRequest, new RequestContext());\n+  }\n+\n+  @Test\n+  public void testChangingStrategiesAfterStoppingListener()\n+  {\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig()\n+      .setMultiplier(0.5f);\n+    DarkClusterConfig darkClusterConfig2 = new DarkClusterConfig()\n+      .setMultiplier(0.1f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    strategyFactory.shutdown();\n+\n+    // now trigger a refresh on the dark cluster. Note that darkClusterConfig1 is ignored since there should already be an entry for this\n+    // dark cluster, and we should get the strategy associated with darkClusterConfig2 back.\n+    clusterInfoProvider.triggerClusterRefresh(DARK_CLUSTER_NAME);\n+    // Nothing should have been changed, since we should be ignoring source cluster changes.\n+    DarkClusterStrategy strategy2 = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy2 instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy)strategy2).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+  }\n+\n+  @Test\n+  public void testStrategyRaceCondition()\n+  {\n+    int noopStrategyCount = 0;\n+    MockClusterInfoProvider clusterInfoProvider = new MockClusterInfoProvider();\n+    Facilities facilities = new MockFacilities(clusterInfoProvider);\n+    DarkClusterDispatcher darkClusterDispatcher = new DefaultDarkClusterDispatcherImpl(new MockClient(false));\n+    DarkClusterStrategyFactory strategyFactory =\n+      new DarkClusterStrategyFactoryImpl(facilities, SOURCE_CLUSTER_NAME, darkClusterDispatcher, new DoNothingNotifier(), new Random(SEED),\n+                                         new CountingVerifierManager());\n+    strategyFactory.start();\n+    DarkClusterConfig darkClusterConfig1 = new DarkClusterConfig().setMultiplier(0.5f);\n+    clusterInfoProvider.addDarkClusterConfig(SOURCE_CLUSTER_NAME, DARK_CLUSTER_NAME, darkClusterConfig1);\n+    DarkClusterStrategy strategy = strategyFactory.getOrCreate(DARK_CLUSTER_NAME, darkClusterConfig1);\n+    Assert.assertTrue(strategy instanceof ConstantMultiplierDarkClusterStrategy);\n+    Assert.assertEquals(((ConstantMultiplierDarkClusterStrategy) strategy).getMultiplier(), 0.5f, \"expected 0.5f multiplier\");\n+\n+    // this was registered after DarkClusterStrategyFactoryImpl registered it's clusterListener.\n+    clusterInfoProvider.registerClusterListener(new DeletingClusterListener(clusterInfoProvider));\n+\n+    ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();\n+    final CountDownLatch latch = new CountDownLatch(1);", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3MzI4MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404573281", "bodyText": "the latch is necessary so that  the code that follows definitely executes after. It's not primarily for protecting against failed executors. You can think of it as a better alternative than a sleep, because once the latch counts down we know we've done the pre-requisite async task.", "author": "davidhoa", "createdAt": "2020-04-07T06:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4MDc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405080799", "bodyText": "makes sense", "author": "zhang-chris", "createdAt": "2020-04-07T20:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODc0MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404448740", "bodyText": "copyright", "author": "zhang-chris", "createdAt": "2020-04-06T23:29:12Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterUrlRewrite.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.linkedin.darkcluster;", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU3NDI1Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404574257", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T06:51:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ0ODc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2NjM1Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404466356", "bodyText": "extract out to private method and reduce duplicate code.", "author": "zhang-chris", "createdAt": "2020-04-07T00:25:47Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterVerifierManager.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster;\n+\n+import java.net.URI;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.impl.DarkClusterVerifierManagerImpl;\n+import com.linkedin.darkcluster.impl.SafeDarkClusterVerifier;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestRequestBuilder;\n+import com.linkedin.r2.message.rest.RestResponse;\n+import com.linkedin.r2.message.rest.RestResponseBuilder;\n+\n+import static org.testng.Assert.fail;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestDarkClusterVerifierManager\n+{\n+  private static final String DARK_CLUSTER1_NAME = \"darkCluster1\";\n+\n+  @Test\n+  void testVerifierEnabled()\n+    throws InterruptedException\n+  {\n+    TestVerifier verifier = new TestVerifier(true);\n+    ExecutorService executorService = Executors.newSingleThreadExecutor();\n+    DarkClusterVerifierManager verifierManager = new DarkClusterVerifierManagerImpl(verifier, executorService);\n+    RestRequest dummyRestRequest = new RestRequestBuilder(URI.create(\"foo\")).build();\n+    RestResponse res = new RestResponseBuilder().build();\n+    verifierManager.onDarkResponse(dummyRestRequest, res, DARK_CLUSTER1_NAME);\n+    verifierManager.onDarkResponse(dummyRestRequest, res, DARK_CLUSTER1_NAME);\n+    verifierManager.onResponse(dummyRestRequest, res);\n+\n+    // because it takes some time execute the previous three tasks on the executor, add a 4th one\n+    // that can signal we are done, given the executor is single threaded and will process them in order.\n+    final CountDownLatch latch = new CountDownLatch(1);", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4MDA4NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404580085", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-07T07:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2NjM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2NzIwNA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r404467204", "bodyText": "Is there a test written for this?", "author": "zhang-chris", "createdAt": "2020-04-07T00:28:40Z", "path": "data/src/main/java/com/linkedin/data/DataMapBuilder.java", "diffHunk": "@@ -68,7 +68,9 @@ public DataMap convertToDataMap()\n   public void setInUse(boolean v) { _inUse = v; }\n \n   private int optimumCapacityFromSize() {\n-    return getOptimumHashMapCapacityFromSize(_dataMapContents.size());\n+    // Pass in size / 2 since we calculate size based on num pairs\n+    // Should be a clean division since we add to the list in pairs\n+    return getOptimumHashMapCapacityFromSize(_dataMapContents.size() / 2);", "originalCommit": "de1f911fba5afa098ccc8b6bbe41a79b39664629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNTEyNw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405005127", "bodyText": "not my stuff, somehow it got included. I fixed this in the latest diff.", "author": "davidhoa", "createdAt": "2020-04-07T17:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2NzIwNA=="}], "type": "inlineReview"}, {"oid": "e04659102be0551813e1175bdb9510ea0f791c37", "url": "https://github.com/linkedin/rest.li/commit/e04659102be0551813e1175bdb9510ea0f791c37", "message": "updated with code review comments.", "committedDate": "2020-04-07T17:51:02Z", "type": "forcePushed"}, {"oid": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "url": "https://github.com/linkedin/rest.li/commit/b57c7bef45b98b2bee956bbc9555a3d56da5b513", "message": "updated with code review comments.", "committedDate": "2020-04-07T18:53:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNjk4MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405726980", "bodyText": "no need to extract this out to private method if it's only being used here. same for onClusterRemoved", "author": "zhang-chris", "createdAt": "2020-04-08T18:26:52Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/MockClusterListener.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.simple;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+\n+public class MockClusterListener implements LoadBalancerClusterListener\n+{\n+  // Store if notified\n+  private Map<String, AtomicInteger> clusterAddedCounter = new HashMap<>();\n+  private Map<String, AtomicInteger> clusterRemovedCounter = new HashMap<>();\n+\n+  @Override\n+  public void onClusterAdded(String clusterName)\n+  {\n+    incrementClusterAddedCount(clusterName);", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyMTY3MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405821670", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNjk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNzMzNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405727336", "bodyText": "technically these should be under functional api too, but not a big deal because this is for tests.", "author": "zhang-chris", "createdAt": "2020-04-08T18:27:28Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/MockClusterListener.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.d2.balancer.simple;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+\n+public class MockClusterListener implements LoadBalancerClusterListener\n+{\n+  // Store if notified\n+  private Map<String, AtomicInteger> clusterAddedCounter = new HashMap<>();\n+  private Map<String, AtomicInteger> clusterRemovedCounter = new HashMap<>();\n+\n+  @Override\n+  public void onClusterAdded(String clusterName)\n+  {\n+    incrementClusterAddedCount(clusterName);\n+  }\n+\n+  @Override\n+  public void onClusterRemoved(String clusterName)\n+  {\n+    incrementClusterRemovedCount(clusterName);\n+  }\n+\n+  public int getClusterAddedCount(String clusterName)\n+  {\n+    return clusterAddedCounter.getOrDefault(clusterName, new AtomicInteger(0)).intValue();", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyMTc1Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405821756", "bodyText": "keeping as is.", "author": "davidhoa", "createdAt": "2020-04-08T21:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcyNzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczMjU2Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405732566", "bodyText": "We should also assert\nassertEquals(clusterListener1.getClusterAddedCount(CLUSTER2_CLUSTER_NAME), 2);\nassertEquals(clusterListener2.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1);", "author": "zhang-chris", "createdAt": "2020-04-08T18:36:06Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerStateTest.java", "diffHunk": "@@ -1610,6 +1613,129 @@ public void testUpdatePartitionDataMap()\n \n   }\n \n+  @Test\n+  public void testRegisterClusterListener()\n+  {\n+    reset();\n+\n+    MockClusterListener clusterListener = new MockClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count since no action has been triggered\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call after clusterRegistry put\");\n+\n+    // then update the cluster\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 2, \"expected 2 calls after additional clusterRegistry put\");\n+  }\n+\n+  @Test\n+  public void testUnregisterClusterListener()\n+  {\n+    reset();\n+\n+    MockClusterListener clusterListener = new MockClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call after put\");\n+\n+    _state.unregisterClusterListener(clusterListener);\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call, since we shouldn't have seen the latest put\");\n+  }\n+\n+  @Test\n+  public void testOnRemoveCluster()\n+  {\n+    reset();\n+\n+    MockClusterListener clusterListener = new MockClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 0, \"expected zero count\");\n+\n+    // first add a cluster\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call after put\");\n+    assertEquals(clusterListener.getClusterRemovedCount(CLUSTER1_CLUSTER_NAME), 0, \"expected nothing yet\");\n+\n+    _clusterRegistry.remove(CLUSTER1_CLUSTER_NAME);\n+    assertEquals(clusterListener.getClusterRemovedCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 after remove\");\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1, \"Nothing more should have been added to the added count\");\n+  }\n+\n+  @Test\n+  public void testRegisterClusterListenerDuplicates()\n+  {\n+    reset();\n+\n+    MockClusterListener clusterListener = new MockClusterListener();\n+    _state.registerClusterListener(clusterListener);\n+    _state.registerClusterListener(clusterListener);\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    assertEquals(clusterListener.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call since duplicates are not allowed\");\n+\n+  }\n+\n+  @Test\n+  public void testRegisterMultipleClusterListener()\n+  {\n+    reset();\n+\n+    MockClusterListener clusterListener1 = new MockClusterListener();\n+    _state.registerClusterListener(clusterListener1);\n+    MockClusterListener clusterListener2 = new MockClusterListener();\n+    _state.registerClusterListener(clusterListener2);\n+\n+    _state.listenToCluster(CLUSTER1_CLUSTER_NAME, new NullStateListenerCallback());\n+    _state.listenToCluster(CLUSTER2_CLUSTER_NAME, new NullStateListenerCallback());\n+\n+    _clusterRegistry.put(CLUSTER1_CLUSTER_NAME, new ClusterProperties(CLUSTER1_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+    _clusterRegistry.put(CLUSTER2_CLUSTER_NAME, new ClusterProperties(CLUSTER2_CLUSTER_NAME));\n+\n+    assertEquals(clusterListener1.getClusterAddedCount(CLUSTER1_CLUSTER_NAME), 1, \"expected 1 call for cluster1\");\n+    assertEquals(clusterListener2.getClusterAddedCount(CLUSTER2_CLUSTER_NAME), 2, \"expected 2 call for cluster 2\");", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyMTgzMg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405821832", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczMjU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczODIwMQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405738201", "bodyText": "Looks like this is a copy of the test below and this block should be removed.", "author": "zhang-chris", "createdAt": "2020-04-08T18:45:25Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/simple/SimpleLoadBalancerTest.java", "diffHunk": "@@ -185,57 +218,167 @@ public void testClusterInfoProvider(int numHttp, int numHttps, int expectedNumHt\n       int partitionIdForAdd, int partitionIdForCheck)\n       throws InterruptedException, ExecutionException, ServiceUnavailableException\n   {\n-    Map<String, LoadBalancerStrategyFactory<? extends LoadBalancerStrategy>> loadBalancerStrategyFactories =\n-        new HashMap<>();\n-    Map<String, TransportClientFactory> clientFactories = new HashMap<>();\n-\n     MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n     MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n     MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n \n-    loadBalancerStrategyFactories.put(\"degrader\", new DegraderLoadBalancerStrategyFactoryV3());\n-    clientFactories.put(PropertyKeys.HTTP_SCHEME, new DoNothingClientFactory());\n-    clientFactories.put(PropertyKeys.HTTPS_SCHEME, new DoNothingClientFactory());\n-\n-    SimpleLoadBalancerState state =\n-        new SimpleLoadBalancerState(new SynchronousExecutorService(),\n-            uriRegistry,\n-            clusterRegistry,\n-            serviceRegistry,\n-            clientFactories,\n-            loadBalancerStrategyFactories);\n-\n-    SimpleLoadBalancer loadBalancer =\n-        new SimpleLoadBalancer(state, 5, TimeUnit.SECONDS, _d2Executor);\n-\n-    FutureCallback<None> balancerCallback = new FutureCallback<None>();\n-    loadBalancer.start(balancerCallback);\n-    balancerCallback.get();\n+    populateUriRegistry(numHttp, numHttps, partitionIdForAdd, uriRegistry);\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME));\n \n-    URI uri1 = URI.create(\"http://test.qa1.com:1234\");\n-    URI uri2 = URI.create(\"http://test.qa2.com:2345\");\n-    URI uri3 = URI.create(\"http://test.qa3.com:6789\");\n+    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTP_SCHEME, partitionIdForCheck), expectedNumHttp,\n+        \"Http cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttp);\n+    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTPS_SCHEME, partitionIdForCheck), expectedNumHttps,\n+        \"Https cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttps);\n+  }\n \n+  private void populateUriRegistry(int numHttp, int numHttps, int partitionIdForAdd, MockStore<UriProperties> uriRegistry)\n+  {\n     Map<Integer, PartitionData> partitionData = new HashMap<>(1);\n     partitionData.put(partitionIdForAdd, new PartitionData(1d));\n     Map<URI, Map<Integer, PartitionData>> uriData = new HashMap<URI, Map<Integer, PartitionData>>(numHttp);\n     Set<String> schemeSet = new HashSet<>();\n     schemeSet.add(PropertyKeys.HTTP_SCHEME);\n     schemeSet.add(PropertyKeys.HTTPS_SCHEME);\n-    for (String scheme : schemeSet) {\n+    for (String scheme : schemeSet)\n+    {\n       for (int i = 0; i < (scheme.equals(PropertyKeys.HTTP_SCHEME) ? numHttp : numHttps); i++) {\n         uriData.put(URI.create(scheme + \"://test.qa\" + i + \".com:1234\"), partitionData);\n       }\n     }\n+    uriRegistry.put(CLUSTER1_NAME, new UriProperties(CLUSTER1_NAME, uriData));\n+  }\n+  @Test\n+  public void testClusterInfoProviderGetDarkClusters()\n+      throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    int numHttp = 3;\n+    int numHttps = 4;\n+    int partitionIdForAdd = 0;\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n \n-    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME));\n+    DarkClusterConfig darkClusterConfig = new DarkClusterConfig().setMultiplier(1.0f);\n+    DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap();\n+    darkClusterConfigMap.put(DARK_CLUSTER1_NAME, darkClusterConfig);\n \n-    uriRegistry.put(CLUSTER1_NAME, new UriProperties(CLUSTER1_NAME, uriData));\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+        Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(), darkClusterConfigMap));\n \n-    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTP_SCHEME, partitionIdForCheck), expectedNumHttp,\n-        \"Http cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttp);\n-    Assert.assertEquals(loadBalancer.getClusterCount(CLUSTER1_NAME, PropertyKeys.HTTPS_SCHEME, partitionIdForCheck), expectedNumHttps,\n-        \"Https cluster count for partitionId: \" + partitionIdForCheck + \" should be: \" + expectedNumHttps);\n+    populateUriRegistry(numHttp, numHttps, partitionIdForAdd, uriRegistry);\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(CLUSTER1_NAME);\n+    Assert.assertEquals(returnedDarkClusterConfigMap, darkClusterConfigMap, \"dark cluster configs should be equal\");\n+    Assert.assertEquals(returnedDarkClusterConfigMap.get(DARK_CLUSTER1_NAME).getMultiplier(), 1.0f, \"multiplier should match\");\n+  }\n+\n+  @Test\n+  public void testClusterInfoProviderGetDarkClustersNoUris()\n+      throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+\n+    DarkClusterConfig darkClusterConfig = new DarkClusterConfig().setMultiplier(1.0f);\n+    DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap();\n+    darkClusterConfigMap.put(DARK_CLUSTER1_NAME, darkClusterConfig);\n+\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+        Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(), darkClusterConfigMap));\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(CLUSTER1_NAME);\n+    Assert.assertEquals(returnedDarkClusterConfigMap, darkClusterConfigMap, \"dark cluster configs should be equal\");\n+    Assert.assertEquals(returnedDarkClusterConfigMap.get(DARK_CLUSTER1_NAME).getMultiplier(), 1.0f, \"multiplier should match\");\n+  }\n+\n+  @Test\n+  public void testClusterInfoProviderGetDarkClustersNoCluster()\n+    throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+\n+    DarkClusterConfigMap returnedDarkClusterConfigMap = loadBalancer.getDarkClusterConfigMap(NONEXISTENT_CLUSTER);\n+    Assert.assertEquals(returnedDarkClusterConfigMap.size(), 0, \"expected empty map\");\n+  }\n+\n+  /**\n+   * The Register cluster Listener code is already tested in SimpleLoadBalancerStateTest, this is here for testing the\n+   * SimpleLoadBalancer API exposing this.\n+   */\n+  @Test\n+  public void testClusterInfoProviderRegisterClusterListener()\n+    throws InterruptedException, ExecutionException, ServiceUnavailableException\n+  {\n+    MockStore<ServiceProperties> serviceRegistry = new MockStore<>();\n+    MockStore<ClusterProperties> clusterRegistry = new MockStore<>();\n+    MockStore<UriProperties> uriRegistry = new MockStore<>();\n+    SimpleLoadBalancer loadBalancer = setupLoadBalancer(null, serviceRegistry, clusterRegistry, uriRegistry);\n+    FutureCallback<None> balancerCallback = new FutureCallback<None>();\n+    loadBalancer.start(balancerCallback);\n+    balancerCallback.get();\n+    MockClusterListener testClusterListener = new MockClusterListener();\n+    loadBalancer.registerClusterListener(testClusterListener);\n+    loadBalancer.listenToCluster(CLUSTER1_NAME, false, new LoadBalancerState.NullStateListenerCallback());\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+                                                             Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(),\n+                                                             new DarkClusterConfigMap()));\n+    Assert.assertEquals(testClusterListener.getClusterAddedCount(CLUSTER1_NAME), 1, \"expected add count of 1\");\n+    Assert.assertEquals(testClusterListener.getClusterRemovedCount(CLUSTER1_NAME), 0, \"expected remove count of 0\");\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    PropertyEventShutdownCallback callback = latch::countDown;\n+    loadBalancer.shutdown(callback);\n+    if (!latch.await(60, TimeUnit.SECONDS))\n+    {\n+      fail(\"unable to shutdown state\");\n+    }\n+    Assert.assertEquals(testClusterListener.getClusterAddedCount(CLUSTER1_NAME), 1, \"expected add count of 1 after shutdown\");\n+    Assert.assertEquals(testClusterListener.getClusterRemovedCount(CLUSTER1_NAME), 1, \"expected remove count of 1 after shutdown\");\n+\n+    // now unregister, and we don't expect the counts to change.\n+    loadBalancer.unregisterClusterListener(testClusterListener);\n+    clusterRegistry.put(CLUSTER1_NAME, new ClusterProperties(CLUSTER1_NAME, Collections.emptyList(), Collections.emptyMap(),\n+                                                             Collections.emptySet(), NullPartitionProperties.getInstance(), Collections.emptyList(),\n+                                                             new DarkClusterConfigMap()));\n+    Assert.assertEquals(testClusterListener.getClusterAddedCount(CLUSTER1_NAME), 1, \"expected add count of 1\");\n+    Assert.assertEquals(testClusterListener.getClusterRemovedCount(CLUSTER1_NAME), 0, \"expected remove count of 0\");", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyMTk0Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405821946", "bodyText": "thanks for catching. removed.", "author": "davidhoa", "createdAt": "2020-04-08T21:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTczODIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MTY3MQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405741671", "bodyText": "This is more implementation detail. I would say something simple, maybe \"Manages dark request verification using {@link DarkClusterVerifier}.\"", "author": "zhang-chris", "createdAt": "2020-04-08T18:51:36Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterVerifierManager.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+/**\n+ * DarkClusterVerifierManager handles checking if the verifier is enabled and doing the verification on a\n+ * separate thread.", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyMjA3OA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405822078", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0NDM3MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405744370", "bodyText": "This would be better placed as javadoc of constructor.\nand maybe rename status to \"requestSent\"?", "author": "zhang-chris", "createdAt": "2020-04-08T18:56:26Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/NoOpDarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.api;\n+\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * Dummy implementation of DarkClusterStrategy. This can be used in tests safely.\n+ */\n+public class NoOpDarkClusterStrategy implements DarkClusterStrategy\n+{\n+  /**\n+   * status is what this class should return on each invocation of handleRequest. Tests\n+   * may want to pretend that a strategy was returned, but if this get's used in production,\n+   * a status of false (request not sent) is more correct.\n+   */", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyMjE2MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405822160", "bodyText": "done to both.", "author": "davidhoa", "createdAt": "2020-04-08T21:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0NDM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0NjI5NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405746294", "bodyText": "Can probably just use the simpleName to cut down on String length", "author": "zhang-chris", "createdAt": "2020-04-08T18:59:39Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/filter/DarkClusterFilter.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.filter;\n+\n+import java.util.Map;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.darkcluster.api.DarkClusterManager;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.r2.filter.NextFilter;\n+import com.linkedin.r2.filter.message.rest.RestFilter;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * DarkClusterFilter can be added to the Restli filter chain on either the server or client side, to tee off requests to a\n+ * dark cluster. It delegates to the {@link DarkClusterManager} for sending the dark request and verifying the dark response\n+ * against the original response, if that is configured.\n+ *\n+ * Future enhancements might be to make it a Stream Filter as well.\n+ */\n+public class DarkClusterFilter implements RestFilter\n+{\n+  private static final Logger _log = LoggerFactory.getLogger(DarkClusterFilter.class);\n+  private static final String ORIGINAL_REQUEST_KEY = DarkClusterFilter.class.getName() + \"_originalRequest\";", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyMjI0Mw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405822243", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0NjI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDIxMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405750210", "bodyText": "Who should be calling start/shutdown and when to make sure ClusterInfoProvider is available? Could be nice to add the info as javadoc\nIf ClusterInfoProvider is not available yet when this is called what happens? Do we need error handling for that?", "author": "zhang-chris", "createdAt": "2020-04-08T19:06:31Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ * start() must be called in order to register the ClusterListener.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private static final AtomicReference<DarkClusterStrategy> NO_OP_DARK_CLUSTER_STRATEGY = new AtomicReference<>(new NoOpDarkClusterStrategy());\n+\n+  // ClusterInfoProvider isn't available until the D2 client is started, so it can't be\n+  // populated during construction time.\n+  private final Facilities _facilities;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull Facilities facilities,\n+                                        @Nonnull String sourceClusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _facilities = facilities;\n+    _sourceClusterName = sourceClusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new DarkClusterListener();\n+  }\n+\n+  @Override", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNDIzNQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405824235", "bodyText": "I added some javadocs that mentions the same mechanism that starts the load balancer like ZKFSLoadBalancer should start this as well. We don't need to have error handling for that, a runtime exception will be thrown and reported back to the user. see checkLoadBalancer() in ZKFSLoadBalancer for what will be thrown.", "author": "davidhoa", "createdAt": "2020-04-08T21:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NjUwNg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405766506", "bodyText": "Instead of hardcoding the criteria for a strategy here, let's do a similar thing that is currently being done with dark canary in container.\nhttps://jarvis.corp.linkedin.com/codesearch/result/?name=DarkCanaryStrategy.java&path=container%2Fpegasus%2Fpegasus-darkcanary-impl%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinkedin%2Fcontainer%2Fdarkcanary%2Fstrategy&reponame=multiproducts%2Fcontainer#51\nWe can define a public static #isMember(DarkClusterConfig) for RelativeTrafficMultiplierDarkClusterStrategy.\nif (RelativeTrafficMultiplierDarkClusterStrategy.isMember(darkClusterConfig)) {}", "author": "zhang-chris", "createdAt": "2020-04-08T19:37:27Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ * start() must be called in order to register the ClusterListener.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private static final AtomicReference<DarkClusterStrategy> NO_OP_DARK_CLUSTER_STRATEGY = new AtomicReference<>(new NoOpDarkClusterStrategy());\n+\n+  // ClusterInfoProvider isn't available until the D2 client is started, so it can't be\n+  // populated during construction time.\n+  private final Facilities _facilities;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull Facilities facilities,\n+                                        @Nonnull String sourceClusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _facilities = facilities;\n+    _sourceClusterName = sourceClusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new DarkClusterListener();\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    _facilities.getClusterInfoProvider().registerClusterListener(_clusterListener);\n+  }\n+\n+  @Override\n+  public void shutdown()\n+  {\n+    _facilities.getClusterInfoProvider().unregisterClusterListener(_clusterListener);\n+  }\n+\n+\n+\n+  @Override\n+  public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull DarkClusterConfig darkClusterConfig)\n+  {\n+    if (!_darkStrategyMap.containsKey(darkClusterName))\n+    {\n+      _darkStrategyMap.putIfAbsent(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName, darkClusterConfig)));\n+    }\n+    // it's theoretically possible for the Listener to remove the entry after the containsKey but before we retrieve it. Rather\n+    // than adding synchronization between accessors of _darkStrategyMap, we will make each put or get resilient\n+    return _darkStrategyMap.getOrDefault(darkClusterName, NO_OP_DARK_CLUSTER_STRATEGY).get();\n+  }\n+\n+  /**\n+   * In the future, additional strategies can be added, and the logic here can choose the appropriate one based on the config values.\n+   */\n+  private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n+  {\n+    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNDk1NA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405824954", "bodyText": "I don't think this is a better pattern, you can have multiple strategies overlapping in what they think they support, and the only thing determining what's chosen is the arbitrary order in which they are checked. With the current mechanism, it is very clear that createStrategy determines what strategy is chosen, and how it is chosen.", "author": "davidhoa", "createdAt": "2020-04-08T21:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NjUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQyMDg4Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r406420886", "bodyText": "We talked offline, and we will have the user explicitly choose the strategy they want in the darkClusterConfigs. That will require additional work, and will be done outside of this PR. For now, keeping it as is, as we can change to the new mechanism when it's ready.", "author": "davidhoa", "createdAt": "2020-04-09T19:14:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NjUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NzQyMA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405767420", "bodyText": "Log a warn since we don't expect a match to not be found.", "author": "zhang-chris", "createdAt": "2020-04-08T19:39:03Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.DarkClusterConfig;\n+import com.linkedin.d2.DarkClusterConfigMap;\n+import com.linkedin.d2.balancer.Facilities;\n+import com.linkedin.d2.balancer.LoadBalancerClusterListener;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.darkcluster.api.DarkClusterStrategyFactory;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.darkcluster.api.NoOpDarkClusterStrategy;\n+\n+/**\n+ * DarkClusterStrategyFactoryImpl creates and maintains the strategies needed for dark clusters. This involves refreshing\n+ * when darkClusterConfig changes are detected, by way of a {@link LoadBalancerClusterListener}\n+ * start() must be called in order to register the ClusterListener.\n+ */\n+public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactory\n+{\n+  private static final AtomicReference<DarkClusterStrategy> NO_OP_DARK_CLUSTER_STRATEGY = new AtomicReference<>(new NoOpDarkClusterStrategy());\n+\n+  // ClusterInfoProvider isn't available until the D2 client is started, so it can't be\n+  // populated during construction time.\n+  private final Facilities _facilities;\n+  private final String _sourceClusterName;\n+  private final DarkClusterDispatcher _darkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Map<String, AtomicReference<DarkClusterStrategy>> _darkStrategyMap;\n+  private final Random _random;\n+  private final LoadBalancerClusterListener _clusterListener;\n+  private final DarkClusterVerifierManager _verifierManager;\n+\n+  public DarkClusterStrategyFactoryImpl(@Nonnull Facilities facilities,\n+                                        @Nonnull String sourceClusterName,\n+                                        @Nonnull DarkClusterDispatcher darkClusterDispatcher,\n+                                        @Nonnull Notifier notifier,\n+                                        @Nonnull Random random,\n+                                        @Nonnull DarkClusterVerifierManager verifierManager)\n+  {\n+    _facilities = facilities;\n+    _sourceClusterName = sourceClusterName;\n+    _notifier = notifier;\n+    _darkStrategyMap = new ConcurrentHashMap<>();\n+    _random = random;\n+    _darkClusterDispatcher = darkClusterDispatcher;\n+    _verifierManager = verifierManager;\n+    _clusterListener = new DarkClusterListener();\n+  }\n+\n+  @Override\n+  public void start()\n+  {\n+    _facilities.getClusterInfoProvider().registerClusterListener(_clusterListener);\n+  }\n+\n+  @Override\n+  public void shutdown()\n+  {\n+    _facilities.getClusterInfoProvider().unregisterClusterListener(_clusterListener);\n+  }\n+\n+\n+\n+  @Override\n+  public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull DarkClusterConfig darkClusterConfig)\n+  {\n+    if (!_darkStrategyMap.containsKey(darkClusterName))\n+    {\n+      _darkStrategyMap.putIfAbsent(darkClusterName, new AtomicReference<>(createStrategy(darkClusterName, darkClusterConfig)));\n+    }\n+    // it's theoretically possible for the Listener to remove the entry after the containsKey but before we retrieve it. Rather\n+    // than adding synchronization between accessors of _darkStrategyMap, we will make each put or get resilient\n+    return _darkStrategyMap.getOrDefault(darkClusterName, NO_OP_DARK_CLUSTER_STRATEGY).get();\n+  }\n+\n+  /**\n+   * In the future, additional strategies can be added, and the logic here can choose the appropriate one based on the config values.\n+   */\n+  private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n+  {\n+    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    {\n+      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n+                                                                                              _notifier, _verifierManager);\n+      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n+    }\n+    else\n+    {\n+      return new NoOpDarkClusterStrategy();", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNjgwNQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405826805", "bodyText": "actually, we do expect this to be returned in some cases. For example, if users have intentionally set their multiplier to zero because they don't want traffic to go to the dark cluster.  This can be a temporary thing, so it is an expected use case. I added a comment.", "author": "davidhoa", "createdAt": "2020-04-08T21:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc2NzQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3MTY3Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405771672", "bodyText": "spacing", "author": "zhang-chris", "createdAt": "2020-04-08T19:47:18Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterVerifierManagerImpl.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.darkcluster.api.DarkClusterVerifier;\n+import com.linkedin.darkcluster.api.DarkClusterVerifierManager;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+\n+public class DarkClusterVerifierManagerImpl implements DarkClusterVerifierManager\n+{\n+  private final DarkClusterVerifier _verifier;\n+  private final ExecutorService _executorService;\n+\n+  public DarkClusterVerifierManagerImpl(@Nonnull DarkClusterVerifier verifier,\n+                                        @Nonnull\n+                                          ExecutorService executorService)", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNjg5OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405826899", "bodyText": "fixed.", "author": "davidhoa", "createdAt": "2020-04-08T21:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3MTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3MzAxMg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405773012", "bodyText": "Can you expand on this? Or is it necessary to mention here? This just gives me more questions, like if request should be offloaded to an executor, why isn't an executor in this class?", "author": "zhang-chris", "createdAt": "2020-04-08T19:49:39Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DefaultDarkClusterDispatcher.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.callback.Callback;\n+import com.linkedin.darkcluster.api.DarkClusterDispatcher;\n+import com.linkedin.r2.filter.R2Constants;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+import com.linkedin.r2.message.rest.RestResponse;\n+import com.linkedin.r2.transport.common.Client;\n+\n+/**\n+ * Default implementation of DarkClusterDispatcher\n+ * requests should probably be offloaded to an executor.", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNzA1Nw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405827057", "bodyText": "I removed this, it isn't necessary to mention.", "author": "davidhoa", "createdAt": "2020-04-08T21:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3MzAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3MzY3Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405773672", "bodyText": "no need to include _random as an argument since it's already an instance variable.", "author": "zhang-chris", "createdAt": "2020-04-08T19:50:47Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/RelativeTrafficMultiplierDarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Random;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * RelativeTrafficMultiplierDarkClusterStrategy figures out how many dark requests to send. It uses the {@link ClusterInfoProvider} to determine\n+ * the number ofinstances in both the source and target cluster, and uses that to calculate the number of request to send in order to make the\n+ * level of traffic proportional to itself on any instance in the dark cluster (accounting for multiplier), assuming all hosts in the source cluster\n+ * send traffic.\n+ */\n+public class RelativeTrafficMultiplierDarkClusterStrategy implements DarkClusterStrategy\n+{\n+  private final String _originalClusterName;\n+  private final String _darkClusterName;\n+  private final Float _multiplier;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Random _random;\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RelativeTrafficMultiplierDarkClusterStrategy(@Nonnull String originalClusterName, @Nonnull String darkClusterName, @Nonnull Float multiplier,\n+                                                      @Nonnull BaseDarkClusterDispatcher baseDarkClusterDispatcher,\n+                                                      @Nonnull Notifier notifier,\n+                                                      @Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                                      @Nonnull Random random)\n+  {\n+    _originalClusterName = originalClusterName;\n+    _darkClusterName = darkClusterName;\n+    _multiplier = multiplier;\n+    _baseDarkClusterDispatcher = baseDarkClusterDispatcher;\n+    _notifier = notifier;\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _random = random;\n+  }\n+\n+  @Override\n+  public boolean handleRequest(RestRequest originalRequest, RestRequest darkRequest, RequestContext requestContext)\n+  {\n+    int numRequestDuplicates = getNumDuplicateRequests(_random.nextFloat());", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNzI0MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405827240", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3MzY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3NDY3Ng==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405774676", "bodyText": "It was a lot clearer to me when you mentioned it a multiplier of 1 would keep the incoming QPS per source host equal to incoming QPS for dark. Can we mention the high level first before going into the math?", "author": "zhang-chris", "createdAt": "2020-04-08T19:52:40Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/RelativeTrafficMultiplierDarkClusterStrategy.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.darkcluster.impl;\n+\n+import java.util.Random;\n+\n+import javax.annotation.Nonnull;\n+\n+import com.linkedin.common.util.Notifier;\n+import com.linkedin.d2.balancer.ServiceUnavailableException;\n+import com.linkedin.d2.balancer.util.ClusterInfoProvider;\n+import com.linkedin.darkcluster.api.BaseDarkClusterDispatcher;\n+import com.linkedin.darkcluster.api.DarkClusterStrategy;\n+import com.linkedin.r2.message.RequestContext;\n+import com.linkedin.r2.message.rest.RestRequest;\n+\n+/**\n+ * RelativeTrafficMultiplierDarkClusterStrategy figures out how many dark requests to send. It uses the {@link ClusterInfoProvider} to determine\n+ * the number ofinstances in both the source and target cluster, and uses that to calculate the number of request to send in order to make the\n+ * level of traffic proportional to itself on any instance in the dark cluster (accounting for multiplier), assuming all hosts in the source cluster\n+ * send traffic.\n+ */\n+public class RelativeTrafficMultiplierDarkClusterStrategy implements DarkClusterStrategy\n+{\n+  private final String _originalClusterName;\n+  private final String _darkClusterName;\n+  private final Float _multiplier;\n+  private final BaseDarkClusterDispatcher _baseDarkClusterDispatcher;\n+  private final Notifier _notifier;\n+  private final Random _random;\n+  private final ClusterInfoProvider _clusterInfoProvider;\n+\n+  public RelativeTrafficMultiplierDarkClusterStrategy(@Nonnull String originalClusterName, @Nonnull String darkClusterName, @Nonnull Float multiplier,\n+                                                      @Nonnull BaseDarkClusterDispatcher baseDarkClusterDispatcher,\n+                                                      @Nonnull Notifier notifier,\n+                                                      @Nonnull ClusterInfoProvider clusterInfoProvider,\n+                                                      @Nonnull Random random)\n+  {\n+    _originalClusterName = originalClusterName;\n+    _darkClusterName = darkClusterName;\n+    _multiplier = multiplier;\n+    _baseDarkClusterDispatcher = baseDarkClusterDispatcher;\n+    _notifier = notifier;\n+    _clusterInfoProvider = clusterInfoProvider;\n+    _random = random;\n+  }\n+\n+  @Override\n+  public boolean handleRequest(RestRequest originalRequest, RestRequest darkRequest, RequestContext requestContext)\n+  {\n+    int numRequestDuplicates = getNumDuplicateRequests(_random.nextFloat());\n+    return _baseDarkClusterDispatcher.sendRequest(originalRequest, darkRequest, requestContext, numRequestDuplicates);\n+  }\n+\n+  /**\n+   * The formula to keep traffic proportional to the sending cluster is\n+   * Avg#DarkRequests = ((# instances in dark cluster) * multiplier) / (# instances in source cluster)", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNzM2OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405827369", "bodyText": "done, I mentioned the high level on the class javadoc, as well as here.", "author": "davidhoa", "createdAt": "2020-04-08T21:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3NDY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3NTExNw==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405775117", "bodyText": "copyright", "author": "zhang-chris", "createdAt": "2020-04-08T19:53:28Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/DarkClusterTestUtil.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.linkedin.darkcluster;", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNzQ5MA==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405827490", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3NTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3NjA4OQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405776089", "bodyText": "Add javadoc, \"Contains helper methods to create valid {@link DarkClusterConfig}s for different {@link DarkClusterStrategy}s.\"", "author": "zhang-chris", "createdAt": "2020-04-08T19:55:08Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/DarkClusterTestUtil.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.linkedin.darkcluster;\n+\n+import com.linkedin.d2.DarkClusterConfig;\n+\n+public class DarkClusterTestUtil", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNzY0Mg==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405827642", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3NjA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3ODAwNQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405778005", "bodyText": "copyright", "author": "zhang-chris", "createdAt": "2020-04-08T19:58:40Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/MockFacilities.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package com.linkedin.darkcluster;", "originalCommit": "b57c7bef45b98b2bee956bbc9555a3d56da5b513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgyNzc0NQ==", "url": "https://github.com/linkedin/rest.li/pull/213#discussion_r405827745", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-08T21:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc3ODAwNQ=="}], "type": "inlineReview"}, {"oid": "6e6c6d59b1bdf4e614832651c4b3e11cfa095491", "url": "https://github.com/linkedin/rest.li/commit/6e6c6d59b1bdf4e614832651c4b3e11cfa095491", "message": "darkcluster - basic framework for sending dark cluster requests", "committedDate": "2020-04-10T19:18:57Z", "type": "commit"}, {"oid": "e947a7f1c1deed6d30a5ae8ac857d573b9bf468c", "url": "https://github.com/linkedin/rest.li/commit/e947a7f1c1deed6d30a5ae8ac857d573b9bf468c", "message": "refactored dark cluster. Just has basic structure, minimal tests so far.", "committedDate": "2020-04-10T19:18:57Z", "type": "commit"}, {"oid": "b9bdefb372cea8e461f02c243d637c0ccb1d3b2a", "url": "https://github.com/linkedin/rest.li/commit/b9bdefb372cea8e461f02c243d637c0ccb1d3b2a", "message": "refactor based on comments, added VerifierManager, javadocs, renames.", "committedDate": "2020-04-10T19:18:57Z", "type": "commit"}, {"oid": "69b66e4041e3a0cecef1963ef74e066401058931", "url": "https://github.com/linkedin/rest.li/commit/69b66e4041e3a0cecef1963ef74e066401058931", "message": "Change HashMap to ConcurrentHashMap", "committedDate": "2020-04-10T19:18:57Z", "type": "commit"}, {"oid": "3ee01700335df4157bccf96884a5566c60bca19e", "url": "https://github.com/linkedin/rest.li/commit/3ee01700335df4157bccf96884a5566c60bca19e", "message": "code review comments, additional testcases up to DarkClusterStrategyFactoryImpl. More to come.", "committedDate": "2020-04-10T19:18:58Z", "type": "commit"}, {"oid": "0f5d98547d7cc7740ba90955126e047b5f19b501", "url": "https://github.com/linkedin/rest.li/commit/0f5d98547d7cc7740ba90955126e047b5f19b501", "message": "additional tests, fixed some bugs.", "committedDate": "2020-04-10T19:18:58Z", "type": "commit"}, {"oid": "a904ceb19f3b1038c7b21f3e0854cdee9914e7a3", "url": "https://github.com/linkedin/rest.li/commit/a904ceb19f3b1038c7b21f3e0854cdee9914e7a3", "message": "additional cleanup, testcases.", "committedDate": "2020-04-10T19:18:58Z", "type": "commit"}, {"oid": "a0490250a1aedcc229b7c6f586af56eaad2795cb", "url": "https://github.com/linkedin/rest.li/commit/a0490250a1aedcc229b7c6f586af56eaad2795cb", "message": "misc cleanup, implement ConstantDarkClusterMultiplierStrategy", "committedDate": "2020-04-10T19:18:58Z", "type": "commit"}, {"oid": "fd2963d43eef1ba27ea932682fa8d4bad67df2f2", "url": "https://github.com/linkedin/rest.li/commit/fd2963d43eef1ba27ea932682fa8d4bad67df2f2", "message": "additional changes: expose shutdown on ClusterInfoProvider, use Facilities instead of ClusterInfoProvider", "committedDate": "2020-04-10T19:18:58Z", "type": "commit"}, {"oid": "388bad030ecbc730db1f467b0d3915eee79d7bee", "url": "https://github.com/linkedin/rest.li/commit/388bad030ecbc730db1f467b0d3915eee79d7bee", "message": "Bump ZK Client from 3.4.6 to 3.4.13 (#229)", "committedDate": "2020-04-10T19:18:58Z", "type": "commit"}, {"oid": "96a3b6e797585c73bd56ada883e9b50bce48f1a4", "url": "https://github.com/linkedin/rest.li/commit/96a3b6e797585c73bd56ada883e9b50bce48f1a4", "message": "updated with code review comments.", "committedDate": "2020-04-10T19:18:58Z", "type": "commit"}, {"oid": "0a4a6c18ba194f0bbc36645cab01071ffbde9f10", "url": "https://github.com/linkedin/rest.li/commit/0a4a6c18ba194f0bbc36645cab01071ffbde9f10", "message": "address additional comments.", "committedDate": "2020-04-10T19:19:27Z", "type": "commit"}, {"oid": "18544b78da03a92174e40315cdba6df7a4d3b6b9", "url": "https://github.com/linkedin/rest.li/commit/18544b78da03a92174e40315cdba6df7a4d3b6b9", "message": "clarification on Strategies", "committedDate": "2020-04-10T19:19:33Z", "type": "commit"}, {"oid": "5eb6ada18fbe428b052fcd6c12c8385fc3ac028c", "url": "https://github.com/linkedin/rest.li/commit/5eb6ada18fbe428b052fcd6c12c8385fc3ac028c", "message": "Remove AtomicReference from DarkClusterStrategyFactoryImpl, add javadoc note on DarkClusterStrategy", "committedDate": "2020-04-10T19:19:33Z", "type": "commit"}, {"oid": "5eb6ada18fbe428b052fcd6c12c8385fc3ac028c", "url": "https://github.com/linkedin/rest.li/commit/5eb6ada18fbe428b052fcd6c12c8385fc3ac028c", "message": "Remove AtomicReference from DarkClusterStrategyFactoryImpl, add javadoc note on DarkClusterStrategy", "committedDate": "2020-04-10T19:19:33Z", "type": "forcePushed"}]}