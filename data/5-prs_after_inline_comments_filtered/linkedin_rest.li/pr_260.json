{"pr_number": 260, "pr_title": "Protobuf parsing performance improvements.", "pr_createdAt": "2020-04-14T00:36:46Z", "pr_url": "https://github.com/linkedin/rest.li/pull/260", "timeline": [{"oid": "273fda171140cd684dd9b12b0916a007621cebf5", "url": "https://github.com/linkedin/rest.li/commit/273fda171140cd684dd9b12b0916a007621cebf5", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one.", "committedDate": "2020-04-15T04:53:30Z", "type": "forcePushed"}, {"oid": "5a9222c89bfbcea160a5405ec2c48c7aa4dff319", "url": "https://github.com/linkedin/rest.li/commit/5a9222c89bfbcea160a5405ec2c48c7aa4dff319", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one.", "committedDate": "2020-04-15T05:06:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MDQ0Mw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408570443", "bodyText": "In the old path, we have size <= getCurrentRemaining(), why we don't need to include = here?", "author": "mchen07", "createdAt": "2020-04-15T04:14:49Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1309,33 +1309,67 @@ private ByteArrayProtoReader(ByteArrayVector byteArrays)\n     }\n \n     @Override\n-    public String readString() throws IOException\n-    {\n+    public String readASCIIString() throws IOException {\n       final int size = readInt32();\n-      final byte[] bytes;\n-      final int oldOffset = _localOffset;\n-      final int tempOffset;\n-\n-      if (size < 0)\n+      if (size > 0)\n+      {\n+        // If we can read from the current chunk, read directly.\n+        if (size < getCurrentRemaining())", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwNzQxMg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408607412", "bodyText": "Accidental bug. Should be <=", "author": "karthikrg", "createdAt": "2020-04-15T06:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1NjMzNQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408956335", "bodyText": "How come our current testcases didn't guard this? Maybe add a test for such bug.", "author": "mchen07", "createdAt": "2020-04-15T16:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MDQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MDc3NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408570775", "bodyText": "Similar puzzle of excluding = above", "author": "mchen07", "createdAt": "2020-04-15T04:16:08Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1309,33 +1309,67 @@ private ByteArrayProtoReader(ByteArrayVector byteArrays)\n     }\n \n     @Override\n-    public String readString() throws IOException\n-    {\n+    public String readASCIIString() throws IOException {\n       final int size = readInt32();\n-      final byte[] bytes;\n-      final int oldOffset = _localOffset;\n-      final int tempOffset;\n-\n-      if (size < 0)\n+      if (size > 0)\n+      {\n+        // If we can read from the current chunk, read directly.\n+        if (size < getCurrentRemaining())\n+        {\n+          String value = Utf8Utils.decodeASCII(_currentSegment.getArray(), _localOffset, size, _textBuffer);\n+          _localOffset += size;\n+          return value;\n+        }\n+        else\n+        {\n+          ByteStringLongDecoderState state = new ByteStringLongDecoderState(_byteArrays, _currentIndex, _localOffset);\n+          String value = Utf8Utils.decodeLongASCII(state, size, _textBuffer);\n+          _currentIndex = state.getCurrentIndex();\n+          _currentSegment = _byteArrays.get(_currentIndex);\n+          _localOffset = state.getPosition();\n+          return value;\n+        }\n+      }\n+      else if (size == 0)\n+      {\n+        return \"\";\n+      }\n+      else\n       {\n         throw new IOException(\"Read negative size: \" + size + \". Invalid string\");\n       }\n-      else if (size <= getCurrentRemaining())\n+    }\n+\n+    @Override\n+    public String readString() throws IOException\n+    {\n+      final int size = readInt32();\n+      if (size > 0)\n       {\n-        // Fast path:  We already have the bytes in a contiguous buffer, so just copy directly from it.\n-        bytes = _currentSegment.getArray();\n-        _localOffset = oldOffset + size;\n-        tempOffset = oldOffset;\n-        return Utf8Utils.decode(bytes, tempOffset, size);\n+        // If we can read from the current chunk, read directly.\n+        if (size < getCurrentRemaining())", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwNzQ2Nw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408607467", "bodyText": "Same as above", "author": "karthikrg", "createdAt": "2020-04-15T06:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MDc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MDk4NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408570985", "bodyText": "This comment should move into if to match with the right branch.", "author": "mchen07", "createdAt": "2020-04-15T04:17:07Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1309,33 +1309,67 @@ private ByteArrayProtoReader(ByteArrayVector byteArrays)\n     }\n \n     @Override\n-    public String readString() throws IOException\n-    {\n+    public String readASCIIString() throws IOException {\n       final int size = readInt32();\n-      final byte[] bytes;\n-      final int oldOffset = _localOffset;\n-      final int tempOffset;\n-\n-      if (size < 0)\n+      if (size > 0)\n+      {\n+        // If we can read from the current chunk, read directly.\n+        if (size < getCurrentRemaining())\n+        {\n+          String value = Utf8Utils.decodeASCII(_currentSegment.getArray(), _localOffset, size, _textBuffer);\n+          _localOffset += size;\n+          return value;\n+        }\n+        else\n+        {\n+          ByteStringLongDecoderState state = new ByteStringLongDecoderState(_byteArrays, _currentIndex, _localOffset);\n+          String value = Utf8Utils.decodeLongASCII(state, size, _textBuffer);\n+          _currentIndex = state.getCurrentIndex();\n+          _currentSegment = _byteArrays.get(_currentIndex);\n+          _localOffset = state.getPosition();\n+          return value;\n+        }\n+      }\n+      else if (size == 0)\n+      {\n+        return \"\";\n+      }\n+      else\n       {\n         throw new IOException(\"Read negative size: \" + size + \". Invalid string\");\n       }\n-      else if (size <= getCurrentRemaining())\n+    }\n+\n+    @Override\n+    public String readString() throws IOException\n+    {\n+      final int size = readInt32();\n+      if (size > 0)\n       {\n-        // Fast path:  We already have the bytes in a contiguous buffer, so just copy directly from it.\n-        bytes = _currentSegment.getArray();\n-        _localOffset = oldOffset + size;\n-        tempOffset = oldOffset;\n-        return Utf8Utils.decode(bytes, tempOffset, size);\n+        // If we can read from the current chunk, read directly.", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MTA5NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408571095", "bodyText": "Move comment inside if branch", "author": "mchen07", "createdAt": "2020-04-15T04:17:38Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1309,33 +1309,67 @@ private ByteArrayProtoReader(ByteArrayVector byteArrays)\n     }\n \n     @Override\n-    public String readString() throws IOException\n-    {\n+    public String readASCIIString() throws IOException {\n       final int size = readInt32();\n-      final byte[] bytes;\n-      final int oldOffset = _localOffset;\n-      final int tempOffset;\n-\n-      if (size < 0)\n+      if (size > 0)\n+      {\n+        // If we can read from the current chunk, read directly.", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MTE5Ng==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408571196", "bodyText": "Javadoc on this class for easier maintenance.", "author": "mchen07", "createdAt": "2020-04-15T04:18:02Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1584,4 +1618,42 @@ private int getCurrentRemaining()\n       return _currentSegment.getOffset() + _currentSegment.getLength() - _localOffset;\n     }\n   }\n+\n+  private static class ByteStringLongDecoderState extends Utf8Utils.LongDecoderState", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MzEyOQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408573129", "bodyText": "This part of code seems repeating two places. Is the _position here 0?", "author": "mchen07", "createdAt": "2020-04-15T04:26:04Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1584,4 +1618,42 @@ private int getCurrentRemaining()\n       return _currentSegment.getOffset() + _currentSegment.getLength() - _localOffset;\n     }\n   }\n+\n+  private static class ByteStringLongDecoderState extends Utf8Utils.LongDecoderState\n+  {\n+    private final ByteArrayVector _byteArrays;\n+\n+    private int _currentIndex;\n+\n+    ByteStringLongDecoderState(ByteArrayVector byteArrays, int currentIndex, int localOffset)\n+    {\n+      _byteArrays =  byteArrays;\n+      _currentIndex = currentIndex;\n+\n+      ByteArray array = byteArrays.get(currentIndex);\n+      _buffer = array.getArray();\n+      _offset = array.getOffset();\n+      _position = localOffset;\n+      _bufferSize = array.getLength();\n+    }\n+\n+    @Override\n+    public void readNextChunk() throws IOException\n+    {\n+      if (++_currentIndex >= _byteArrays.getArraySize())\n+      {\n+        throw new EOFException();\n+      }\n+\n+      ByteArray array = _byteArrays.get(_currentIndex);\n+      _buffer = array.getArray();\n+      _offset = array.getOffset();\n+      _position = array.getOffset();\n+      _bufferSize = array.getLength();", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwOTcwNw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408609707", "bodyText": "No. Position is the offset in the byte array of the given segment. Resolved the repetition.", "author": "karthikrg", "createdAt": "2020-04-15T06:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3MzEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3Mzc1Ng==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408573756", "bodyText": "localOffset is a bit confusing with ByteArray.offset.\nSo currentIndex is index to the array of ByteArray, and localOffset is the index to current ByteArray.  Why do we need both _position and _offset in your LongDecoderState?", "author": "mchen07", "createdAt": "2020-04-15T04:28:40Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1584,4 +1618,42 @@ private int getCurrentRemaining()\n       return _currentSegment.getOffset() + _currentSegment.getLength() - _localOffset;\n     }\n   }\n+\n+  private static class ByteStringLongDecoderState extends Utf8Utils.LongDecoderState\n+  {\n+    private final ByteArrayVector _byteArrays;\n+\n+    private int _currentIndex;\n+\n+    ByteStringLongDecoderState(ByteArrayVector byteArrays, int currentIndex, int localOffset)", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMDgzMg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408610832", "bodyText": "currentIndex is index to the array of ByteArray\nYes\n\n\nlocalOffset is the index to current ByteArray\nYes, this is the current position in the byte array\n\nByteArray.offset represents the offset of the underlying byte[] of the ByteArray. This is needed to know when the byte array ends, since we operate only on raw byte[] in Utf8Utils.", "author": "karthikrg", "createdAt": "2020-04-15T06:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3Mzc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NzA1MQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408657051", "bodyText": "I might be better to rename localOffset -> currentArrayOffset\nJavadoc on this constructor can also help.", "author": "karthikbalasub", "createdAt": "2020-04-15T08:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3Mzc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk0ODg0MQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408948841", "bodyText": "+1 on this renaming.", "author": "mchen07", "createdAt": "2020-04-15T15:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3Mzc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1MDcyOQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408950729", "bodyText": "But sorry, I still didn't quite get the difference btw current ByteArray.offset and this localOffset. This localOffset is also index to the underlying byte[] of  current ByteArray, no?", "author": "mchen07", "createdAt": "2020-04-15T15:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3Mzc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI2Nzg5OA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409267898", "bodyText": "offset is the offset of the underlying byte[] when creating the ByteArray. Let us say its is 4.\nlocalOffset represents current position in the byte[]. Let us say it is 8.", "author": "karthikrg", "createdAt": "2020-04-16T04:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3Mzc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3NDAwMg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408574002", "bodyText": "This renaming makes sense.", "author": "mchen07", "createdAt": "2020-04-15T04:29:26Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -450,7 +450,7 @@ public ProtoReader asProtoReader()\n       return ProtoReader.newInstance(byteArray.getArray(), byteArray.getOffset(), byteArray.getLength());\n     }\n \n-    return new ByteArrayProtoReader(_byteArrays);\n+    return new ByteStringProtoReader(_byteArrays);", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3NDk3OA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408574978", "bodyText": "s/A/An", "author": "mchen07", "createdAt": "2020-04-15T04:33:19Z", "path": "data/src/main/java/com/linkedin/data/codec/symbol/EmptySymbolTable.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.codec.symbol;\n+\n+/**\n+ * A empty symbol table meant for avoiding branching checks in parsers/generators when no symbol table is used.", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMDk3Ng==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408610976", "bodyText": "Aye aye grammar nazi ;)", "author": "karthikrg", "createdAt": "2020-04-15T06:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3NDk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3NzMyMw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408577323", "bodyText": "so this is directly copied from Google, right? I didn't read it carefully. How come your first version does not use this file? Is this used anywhere? I can see that your ByteStringProtoReader is inspired by this.", "author": "mchen07", "createdAt": "2020-04-15T04:43:16Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/ByteArrayReader.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+// Protocol Buffers - Google's data interchange format\n+// Copyright 2008 Google Inc.  All rights reserved.\n+// https://developers.google.com/protocol-buffers/\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+\n+package com.linkedin.data.protobuf;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+\n+/**\n+ * A {@link ProtoReader} implementation that uses a backing array as the input.\n+ */\n+final class ByteArrayReader extends ProtoReader", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMTMzNA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408611334", "bodyText": "This class used to be inside ProtoReader. I extracted it out into a separate package private class for better readability.\nThis code is copied from Google, but heavily modified, mostly around String parsing for performance, which is why I have retained both LI and Google copyright", "author": "karthikrg", "createdAt": "2020-04-15T06:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3NzMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3ODA0Ng==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408578046", "bodyText": "Curious why we only brought in these two ProtoReader class now?", "author": "mchen07", "createdAt": "2020-04-15T04:46:17Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/InputStreamReader.java", "diffHunk": "@@ -0,0 +1,655 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+// Protocol Buffers - Google's data interchange format\n+// Copyright 2008 Google Inc.  All rights reserved.\n+// https://developers.google.com/protocol-buffers/\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+package com.linkedin.data.protobuf;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+/**\n+ * Implementation of {@link ProtoReader} that uses an {@link InputStream} as the data source.\n+ */\n+final class InputStreamReader extends ProtoReader", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMTUzNA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408611534", "bodyText": "See above comment. This is not new, just refactored into separate package private class for better readability.", "author": "karthikrg", "createdAt": "2020-04-15T06:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3ODA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3ODQzNQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408578435", "bodyText": "Why do we copy those classes not depends on them? How do we handle out-of-sync issues?", "author": "mchen07", "createdAt": "2020-04-15T04:47:54Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/ProtoReader.java", "diffHunk": "@@ -49,47 +49,48 @@\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n \n /**\n  * Utility class for reading Protocol Buffers encoded binary data.\n  */\n public abstract class ProtoReader", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMjE1MA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408612150", "bodyText": "We copied because:\n\nWe want to modify them to work with our loose binding using symbol tables, as opposed to protobuf vanilla impl that depends on build time schemas and generated code.\nString parsing enhancements that improve string parsing performance beyond vanilla protobuf.", "author": "karthikrg", "createdAt": "2020-04-15T06:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3ODQzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1MzIyNQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408953225", "bodyText": "Ok. How do you plan to get any future bug fix from Google? Hope that there are not many bugfix, otherwise it is a pain, that is how we deal with that URL jersey parser before in pegasus.", "author": "mchen07", "createdAt": "2020-04-15T15:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3ODQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3ODYzMA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408578630", "bodyText": "Are these changes because of Google update or we have our own custom copy now?", "author": "mchen07", "createdAt": "2020-04-15T04:48:38Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/ProtoReader.java", "diffHunk": "@@ -49,47 +49,48 @@\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n \n /**\n  * Utility class for reading Protocol Buffers encoded binary data.\n  */\n public abstract class ProtoReader\n {\n-  private static final int DEFAULT_BUFFER_SIZE = 4096;\n-  private static final int DEFAULT_SIZE_LIMIT = Integer.MAX_VALUE;\n+  static final int DEFAULT_BYTE_BUFFER_SIZE = 4096;\n+  static final int DEFAULT_TEXT_BUFFER_SIZE = 1024;\n+  static final int DEFAULT_SIZE_LIMIT = Integer.MAX_VALUE;\n \n   /**\n-   * Create a new CodedInputStream wrapping the given InputStream.\n+   * Create a new ProtoReader wrapping the given InputStream.", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMjMyMg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408612322", "bodyText": "We have our own custom copy.", "author": "karthikrg", "createdAt": "2020-04-15T06:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3ODYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3OTUwNA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408579504", "bodyText": "Maybe define a constant Function<Integer, Byte]  (for example, ASCII_ONLY_ORDINAL_GENERATOR) for readability.", "author": "mchen07", "createdAt": "2020-04-15T04:52:21Z", "path": "data/src/main/java/com/linkedin/data/codec/ProtobufDataCodec.java", "diffHunk": "@@ -365,15 +377,16 @@ public void doubleValue(double value) throws IOException\n     public void stringValue(String value) throws IOException\n     {\n       int symbolId;\n-      if (_symbolTable != null && (symbolId = _symbolTable.getSymbolId(value)) != SymbolTable.UNKNOWN_SYMBOL_ID)\n+      if ((symbolId = _symbolTable.getSymbolId(value)) != SymbolTable.UNKNOWN_SYMBOL_ID)\n       {\n         _protoWriter.writeByte(STRING_REFERENCE_ORDINAL);\n         _protoWriter.writeUInt32(symbolId);\n       }\n       else\n       {\n-        _protoWriter.writeByte(STRING_LITERAL_ORDINAL);\n-        _protoWriter.writeString(value);\n+        // If the byte length is the same as the string length, then this is an ASCII-only string.\n+        _protoWriter.writeString(value, byteLength ->", "originalCommit": "042d7d0e2e1861fa68b9d0631934a4e8c16fef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMjg2Ng==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408612866", "bodyText": "Then I have to make it a bifunction since I cannot use the string inline. Prefer to keep it this way for that reason. The comment anyways clearly indicates what the function is doing.", "author": "karthikrg", "createdAt": "2020-04-15T06:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU3OTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MTEwNw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408581107", "bodyText": "Curious why you are not directly returning _buffer here?", "author": "mchen07", "createdAt": "2020-04-15T04:58:28Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/TextBuffer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+\n+package com.linkedin.data.protobuf;\n+\n+/**\n+ * A container for holding text data in the form of a char[] to minimize allocations when parsing strings.\n+ */\n+final class TextBuffer\n+{\n+  private char[] _buffer;\n+\n+  /**\n+   * Constructor\n+   *\n+   * @param intialSize  The initial size of the buffer instantiated from the pool.\n+   */\n+  public TextBuffer(int intialSize)\n+  {\n+    _buffer = new char[intialSize];\n+  }\n+\n+  /**\n+   * Get a buffer of the given size from this instance. If the underlying instance size greater than or equal\n+   * to the requested size, the underlying buffer is returned as is. Else, the existing buffer is recycled, and\n+   * a new buffer of at least the given size is retrieved from the underlying pool.\n+   */\n+  public char[] getBuf(int size)\n+  {\n+    if (_buffer == null)\n+    {\n+      throw new IllegalStateException(\"Buffer already in use or closed.\");\n+    }\n+\n+    if (_buffer.length >= size)\n+    {\n+      char[] buffer = _buffer;\n+      _buffer = null;\n+      return buffer;", "originalCommit": "273fda171140cd684dd9b12b0916a007621cebf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMzIxNg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408613216", "bodyText": "I want to nil the _buffer (ivar) to make sure that no one ends up using the underlying buffer concurrently in case of bugs with the code. Such races may result in String corruption.", "author": "karthikrg", "createdAt": "2020-04-15T06:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MTEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk1NDU2Mg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408954562", "bodyText": "is ivar objective-c concept? lol", "author": "mchen07", "createdAt": "2020-04-15T15:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MTMzMw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408581333", "bodyText": "I didn't see an underlying pool is maintained here?", "author": "mchen07", "createdAt": "2020-04-15T04:59:06Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/TextBuffer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+\n+package com.linkedin.data.protobuf;\n+\n+/**\n+ * A container for holding text data in the form of a char[] to minimize allocations when parsing strings.\n+ */\n+final class TextBuffer\n+{\n+  private char[] _buffer;\n+\n+  /**\n+   * Constructor\n+   *\n+   * @param intialSize  The initial size of the buffer instantiated from the pool.\n+   */\n+  public TextBuffer(int intialSize)\n+  {\n+    _buffer = new char[intialSize];\n+  }\n+\n+  /**\n+   * Get a buffer of the given size from this instance. If the underlying instance size greater than or equal\n+   * to the requested size, the underlying buffer is returned as is. Else, the existing buffer is recycled, and\n+   * a new buffer of at least the given size is retrieved from the underlying pool.", "originalCommit": "273fda171140cd684dd9b12b0916a007621cebf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMzY2MA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408613660", "bodyText": "Fixed the doc.", "author": "karthikrg", "createdAt": "2020-04-15T06:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MTMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MTcxMQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408581711", "bodyText": "It is better to have some unit test for this class heavily used here", "author": "mchen07", "createdAt": "2020-04-15T05:00:35Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/TextBuffer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+\n+package com.linkedin.data.protobuf;\n+\n+/**\n+ * A container for holding text data in the form of a char[] to minimize allocations when parsing strings.\n+ */\n+final class TextBuffer", "originalCommit": "273fda171140cd684dd9b12b0916a007621cebf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxMzkwNA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408613904", "bodyText": "This class is implictly tested by Protobuf reader classes since it is used in reading strings. Same for Utf8Utils class.", "author": "karthikrg", "createdAt": "2020-04-15T06:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MTcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MjQxOQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408582419", "bodyText": "elaborate a bit on long here.", "author": "mchen07", "createdAt": "2020-04-15T05:03:29Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/Utf8Utils.java", "diffHunk": "@@ -274,191 +274,316 @@ private static int encodedLengthGeneral(CharSequence sequence, int start)\n   }\n \n   /**\n-   * Decodes the given UTF-8 encoded byte array slice into a {@link String}.\n-   *\n-   * @throws IllegalArgumentException if the input is not valid UTF-8.\n+   * Decodes the given ASCII encoded byte array slice into a {@link String}.\n    */\n-  public static String decode(byte[] bytes, int index, int size)\n+  public static String decodeASCII(byte[] bytes, int index, int size, TextBuffer textBuffer)\n   {\n-    // Bitwise OR combines the sign bits so any negative value fails the check.\n-    if ((index | size | bytes.length - index - size) < 0)\n-    {\n-      throw new ArrayIndexOutOfBoundsException(\n-          String.format(\"buffer length=%d, index=%d, size=%d\", bytes.length, index, size));\n-    }\n-\n     int offset = index;\n     final int limit = offset + size;\n \n-    // The longest possible resulting String is the same as the number of input bytes, when it is\n-    // all ASCII. For other cases, this over-allocates and we will truncate in the end.\n-    char[] resultArr = new char[size];\n-    int resultPos = 0;\n+    // Reuse buffers to avoid thrashing due to transient allocs.\n+    char[] resultArr = null;\n+    try\n+    {\n+      resultArr = textBuffer.getBuf(size);\n+      int resultPos = 0;\n+      while (offset < limit) {\n+        resultArr[resultPos++] = (char) bytes[offset++];\n+      }\n+      return new String(resultArr, 0, size);\n+    }\n+    finally\n+    {\n+      textBuffer.returnBuf(resultArr);\n+    }\n+  }\n \n-    while (offset < limit)\n+  /**\n+   * Decodes a long ASCII encoded byte source into a {@link String}.", "originalCommit": "273fda171140cd684dd9b12b0916a007621cebf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxNTA3NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408615075", "bodyText": "Done", "author": "karthikrg", "createdAt": "2020-04-15T06:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4MjQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4NTM1NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408585355", "bodyText": "javadoc", "author": "mchen07", "createdAt": "2020-04-15T05:14:30Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/Utf8Utils.java", "diffHunk": "@@ -274,191 +274,316 @@ private static int encodedLengthGeneral(CharSequence sequence, int start)\n   }\n \n   /**\n-   * Decodes the given UTF-8 encoded byte array slice into a {@link String}.\n-   *\n-   * @throws IllegalArgumentException if the input is not valid UTF-8.\n+   * Decodes the given ASCII encoded byte array slice into a {@link String}.\n    */\n-  public static String decode(byte[] bytes, int index, int size)\n+  public static String decodeASCII(byte[] bytes, int index, int size, TextBuffer textBuffer)\n   {\n-    // Bitwise OR combines the sign bits so any negative value fails the check.\n-    if ((index | size | bytes.length - index - size) < 0)\n-    {\n-      throw new ArrayIndexOutOfBoundsException(\n-          String.format(\"buffer length=%d, index=%d, size=%d\", bytes.length, index, size));\n-    }\n-\n     int offset = index;\n     final int limit = offset + size;\n \n-    // The longest possible resulting String is the same as the number of input bytes, when it is\n-    // all ASCII. For other cases, this over-allocates and we will truncate in the end.\n-    char[] resultArr = new char[size];\n-    int resultPos = 0;\n+    // Reuse buffers to avoid thrashing due to transient allocs.\n+    char[] resultArr = null;\n+    try\n+    {\n+      resultArr = textBuffer.getBuf(size);\n+      int resultPos = 0;\n+      while (offset < limit) {\n+        resultArr[resultPos++] = (char) bytes[offset++];\n+      }\n+      return new String(resultArr, 0, size);\n+    }\n+    finally\n+    {\n+      textBuffer.returnBuf(resultArr);\n+    }\n+  }\n \n-    while (offset < limit)\n+  /**\n+   * Decodes a long ASCII encoded byte source into a {@link String}.\n+   */\n+  public static String decodeLongASCII(LongDecoderState state, int size, TextBuffer textBuffer) throws IOException\n+  {\n+    // Reuse buffers to avoid thrashing due to transient allocs.\n+    char[] resultArr = null;\n+    try\n     {\n-      byte byte1 = bytes[offset++];\n-      int value = byte1 & 0xff;\n-      switch (UTF8_LOOKUP_TABLE[value])\n+      resultArr = textBuffer.getBuf(size);\n+      int resultPos = 0;\n+\n+      byte[] buffer = state._buffer;\n+      int position = state._position;\n+      int limit = state._offset + state._bufferSize;\n+\n+      while (resultPos < size)\n       {\n-        case 0:\n-          DecodeUtil.handleOneByte(byte1, resultArr, resultPos++);\n-          break;\n-        case 2:\n-          DecodeUtil.handleTwoBytes(byte1, bytes[offset++], resultArr, resultPos++);\n-          break;\n-        case 3:\n-          DecodeUtil.handleThreeBytes(byte1, bytes[offset++], bytes[offset++], resultArr, resultPos++);\n-          break;\n-        case 4:\n-          DecodeUtil.handleFourBytes(byte1, bytes[offset++], bytes[offset++], bytes[offset++], resultArr, resultPos++);\n-          // 4-byte case requires two chars.\n-          resultPos++;\n-          break;\n-        default:\n-          throw INVALID_UTF8_EXCEPTION;\n+        if (position >= limit)\n+        {\n+          state.readNextChunk();\n+          buffer = state._buffer;\n+          position = state._position;\n+          limit = state._offset + state._bufferSize;\n+        }\n+\n+        while (position < limit && resultPos < size)\n+        {\n+          resultArr[resultPos++] = (char) buffer[position++];\n+        }\n       }\n+\n+      state._position = position;\n+      return new String(resultArr, 0, resultPos);\n+    }\n+    finally\n+    {\n+      textBuffer.returnBuf(resultArr);\n     }\n+  }\n \n-    return new String(resultArr, 0, resultPos);\n+  /**\n+   * Decodes the given UTF-8 encoded byte array slice into a {@link String}.\n+   *\n+   * @throws IllegalArgumentException if the input is not valid UTF-8.\n+   *\n+   * @deprecated Use {@link #decode(byte[], int, int, TextBuffer)} instead, re-using the same TextBuffer between\n+   * invocations, as much as possible.\n+   */\n+  @Deprecated\n+  public static String decode(byte[] bytes, int index, int size)\n+  {\n+    return decode(bytes, index, size, new TextBuffer(ProtoReader.DEFAULT_TEXT_BUFFER_SIZE));\n   }\n \n   /**\n-   * Decodes the given UTF-8 encoded section with the given size using the given {@link ProtoReader} into a\n-   * {@link String}.\n+   * Decodes the given UTF-8 encoded byte array slice into a {@link String}.\n    *\n    * @throws IllegalArgumentException if the input is not valid UTF-8.\n    */\n-  public static String decode(ProtoReader protoReader, int size) throws IOException\n+  public static String decode(byte[] bytes, int index, int size, TextBuffer textBuffer)\n   {\n+    int offset = index;\n+    final int limit = offset + size;\n+\n     // The longest possible resulting String is the same as the number of input bytes, when it is\n-    // all ASCII. For other cases, this over-allocates and we will truncate in the end.\n-    char[] resultArr = new char[size];\n-    int resultPos = 0;\n+    // all ASCII. For other cases, this over-allocates and we will truncate in the end. Use a pooled\n+    // buffer here to avoid thrashing due to transient allocs.\n+    char[] resultArr = null;\n \n-    while (size > 0)\n+    try\n     {\n-      byte byte1 = protoReader.readRawByte();\n-      int value = byte1 & 0xff;\n-      switch (UTF8_LOOKUP_TABLE[value])\n+      resultArr = textBuffer.getBuf(size);\n+      int resultPos = 0;\n+\n+      while (offset < limit)\n       {\n-        case 0:\n-          DecodeUtil.handleOneByte(byte1, resultArr, resultPos++);\n-          size--;\n-          break;\n-        case 2:\n-          DecodeUtil.handleTwoBytes(byte1, protoReader.readRawByte(), resultArr, resultPos++);\n-          size -= 2;\n-          break;\n-        case 3:\n-          DecodeUtil.handleThreeBytes(byte1, protoReader.readRawByte(), protoReader.readRawByte(), resultArr, resultPos++);\n-          size -= 3;\n-          break;\n-        case 4:\n-          DecodeUtil.handleFourBytes(byte1, protoReader.readRawByte(), protoReader.readRawByte(), protoReader.readRawByte(), resultArr, resultPos++);\n-          // 4-byte case requires two chars.\n-          resultPos++;\n-          size -= 4;\n-          break;\n-        default:\n-          throw INVALID_UTF8_EXCEPTION;\n+        int i = bytes[offset++] & 0xff;\n+        switch (UTF8_LOOKUP_TABLE[i])\n+        {\n+          case 0:\n+            // ASCII. Nothing to do, since byte is same as char.\n+            break;\n+          case 2:\n+            // 2 byte unicode\n+            i = ((i & 0x1F) << 6) | (bytes[offset++] & 0x3F);\n+            break;\n+          case 3:\n+            // 3 byte unicode\n+            i = ((i & 0x0F) << 12) | ((bytes[offset++] & 0x3F) << 6) | (bytes[offset++] & 0x3F);\n+            break;\n+          case 4:\n+            // 4 byte unicode\n+            i = ((i & 0x07) << 18) | ((bytes[offset++] & 0x3F) << 12) | ((bytes[offset++] & 0x3F) << 6) | (bytes[offset++] & 0x3F);\n+            // Split the codepoint\n+            i -= 0x10000;\n+            resultArr[resultPos++] = (char) (0xD800 | (i >> 10));\n+            i = 0xDC00 | (i & 0x3FF);\n+            break;\n+          default:\n+            throw new IllegalArgumentException(\"Invalid UTF-8. UTF-8 character cannot be \" + UTF8_LOOKUP_TABLE[i] + \"bytes\");\n+        }\n+        resultArr[resultPos++] = (char) i;\n       }\n-    }\n \n-    return new String(resultArr, 0, resultPos);\n+      return new String(resultArr, 0, resultPos);\n+    }\n+    catch (ArrayIndexOutOfBoundsException e)\n+    {\n+      throw new IllegalArgumentException(\"Invalid UTF-8. Unterminated multi-byte sequence\", e);\n+    }\n+    finally\n+    {\n+      textBuffer.returnBuf(resultArr);\n+    }\n   }\n \n   /**\n-   * Utility methods for decoding bytes into {@link String}. Callers are responsible for extracting\n-   * bytes (possibly using Unsafe methods), and checking remaining bytes.\n+   * Decodes the given long UTF-8 encoded byte source into a {@link String}.\n+   *\n+   * <p>The loops in the multi-byte sections are intentionally hand unrolled here for performance reasons.</p>\n+   *\n+   * @throws IllegalArgumentException if the input is not valid UTF-8.\n    */\n-  private static class DecodeUtil\n+  public static String decodeLong(LongDecoderState state, int size, TextBuffer textBuffer) throws IOException\n   {\n-    private static void handleOneByte(byte byte1, char[] resultArr, int resultPos)\n-    {\n-      resultArr[resultPos] = (char) byte1;\n-    }\n+    // The longest possible resulting String is the same as the number of input bytes, when it is\n+    // all ASCII. For other cases, this over-allocates and we will truncate in the end. Use a pooled\n+    // buffer here to avoid thrashing due to transient allocs.\n+    char[] resultArr = null;\n \n-    private static void handleTwoBytes(byte byte1, byte byte2, char[] resultArr, int resultPos)\n+    try\n     {\n-      // Simultaneously checks for illegal trailing-byte in leading position (<= '11000000') and\n-      // overlong 2-byte, '11000001'.\n-      if (byte1 < (byte) 0xC2 || isNotTrailingByte(byte2))\n-      {\n-        throw INVALID_UTF8_EXCEPTION;\n-      }\n+      resultArr = textBuffer.getBuf(size);\n+      int resultPos = 0;\n \n-      resultArr[resultPos] = (char) (((byte1 & 0x1F) << 6) | trailingByteValue(byte2));\n-    }\n+      byte[] buffer = state._buffer;\n+      int position = state._position;\n+      int limit = state._offset + state._bufferSize;\n+      int totalBytesRead = 0;\n \n-    private static void handleThreeBytes(byte byte1, byte byte2, byte byte3, char[] resultArr, int resultPos)\n-    {\n-      if (isNotTrailingByte(byte2)\n-          // overlong? 5 most significant bits must not all be zero\n-          || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)\n-          // check for illegal surrogate codepoints\n-          || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)\n-          || isNotTrailingByte(byte3))\n+      while (totalBytesRead < size)\n       {\n-        throw INVALID_UTF8_EXCEPTION;\n+        if (position >= limit)\n+        {\n+          state.readNextChunk();\n+          buffer = state._buffer;\n+          position = state._position;\n+          limit = state._offset + state._bufferSize;\n+        }\n+\n+        int i = buffer[position++] & 0xff;\n+        switch (UTF8_LOOKUP_TABLE[i])\n+        {\n+          case 0:\n+            // ASCII. Nothing to do, since byte is same as char.\n+            totalBytesRead++;\n+            break;\n+          case 2:\n+            // 2 byte unicode\n+            if (position >= limit)\n+            {\n+              state.readNextChunk();\n+              buffer = state._buffer;\n+              position = state._position;\n+              limit = state._offset + state._bufferSize;\n+            }\n+            i = ((i & 0x1F) << 6) | (buffer[position++] & 0x3F);\n+            totalBytesRead += 2;\n+            break;\n+          case 3:\n+            // 3 byte unicode\n+            if (position < limit -1)\n+            {\n+              i = ((i & 0x0F) << 12) | ((buffer[position++] & 0x3F) << 6) | (buffer[position++] & 0x3F);\n+            }\n+            else\n+            {\n+              byte byte2, byte3;\n+              if (position >= limit)\n+              {\n+                state.readNextChunk();\n+                buffer = state._buffer;\n+                position = state._position;\n+                limit = state._offset + state._bufferSize;\n+              }\n+              byte2 = buffer[position++];\n+\n+              if (position >= limit)\n+              {\n+                state.readNextChunk();\n+                buffer = state._buffer;\n+                position = state._position;\n+                limit = state._offset + state._bufferSize;\n+              }\n+              byte3 = buffer[position++];\n+              i = ((i & 0x0F) << 12) | ((byte2 & 0x3F) << 6) | (byte3 & 0x3F);\n+            }\n+            totalBytesRead += 3;\n+            break;\n+          case 4:\n+            // 4 byte unicode\n+            if (position < limit - 2)\n+            {\n+              i = ((i & 0x07) << 18) | ((buffer[position++] & 0x3F) << 12) | ((buffer[position++] & 0x3F) << 6) | (buffer[position++] & 0x3F);\n+            }\n+            else\n+            {\n+              byte byte2, byte3, byte4;\n+              if (position >= limit)\n+              {\n+                state.readNextChunk();\n+                buffer = state._buffer;\n+                position = state._position;\n+                limit = state._offset + state._bufferSize;\n+              }\n+              byte2 = buffer[position++];\n+\n+              if (position >= limit)\n+              {\n+                state.readNextChunk();\n+                buffer = state._buffer;\n+                position = state._position;\n+                limit = state._offset + state._bufferSize;\n+              }\n+              byte3 = buffer[position++];\n+\n+              if (position >= limit)\n+              {\n+                state.readNextChunk();\n+                buffer = state._buffer;\n+                position = state._position;\n+                limit = state._offset + state._bufferSize;\n+              }\n+              byte4 = buffer[position++];\n+\n+              i = ((i & 0x07) << 18) | ((byte2 & 0x3F) << 12) | ((byte3 & 0x3F) << 6) | (byte4 & 0x3F);\n+            }\n+            // Split the codepoint\n+            i -= 0x10000;\n+            resultArr[resultPos++] = (char) (0xD800 | (i >> 10));\n+            i = 0xDC00 | (i & 0x3FF);\n+            totalBytesRead += 4;\n+            break;\n+          default:\n+            throw new IllegalArgumentException(\"Invalid UTF-8. UTF-8 character cannot be \" + UTF8_LOOKUP_TABLE[i] + \"bytes\");\n+        }\n+        resultArr[resultPos++] = (char) i;\n       }\n \n-      resultArr[resultPos] =\n-          (char)\n-              (((byte1 & 0x0F) << 12) | (trailingByteValue(byte2) << 6) | trailingByteValue(byte3));\n+      state._position = position;\n+      return new String(resultArr, 0, resultPos);\n     }\n-\n-    private static void handleFourBytes(byte byte1, byte byte2, byte byte3, byte byte4, char[] resultArr, int resultPos)\n+    finally\n     {\n-      if (isNotTrailingByte(byte2)\n-          // Check that 1 <= plane <= 16.  Tricky optimized form of:\n-          //   valid 4-byte leading byte?\n-          // if (byte1 > (byte) 0xF4 ||\n-          //   overlong? 4 most significant bits must not all be zero\n-          //     byte1 == (byte) 0xF0 && byte2 < (byte) 0x90 ||\n-          //   codepoint larger than the highest code point (U+10FFFF)?\n-          //     byte1 == (byte) 0xF4 && byte2 > (byte) 0x8F)\n-          || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0\n-          || isNotTrailingByte(byte3)\n-          || isNotTrailingByte(byte4))\n-      {\n-        throw INVALID_UTF8_EXCEPTION;\n-      }\n-\n-      int codepoint =\n-          ((byte1 & 0x07) << 18)\n-              | (trailingByteValue(byte2) << 12)\n-              | (trailingByteValue(byte3) << 6)\n-              | trailingByteValue(byte4);\n-      resultArr[resultPos] = DecodeUtil.highSurrogate(codepoint);\n-      resultArr[resultPos + 1] = DecodeUtil.lowSurrogate(codepoint);\n+      textBuffer.returnBuf(resultArr);\n     }\n+  }\n+\n+  public static abstract class LongDecoderState", "originalCommit": "5a9222c89bfbcea160a5405ec2c48c7aa4dff319", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxNTUyNg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408615526", "bodyText": "Done", "author": "karthikrg", "createdAt": "2020-04-15T06:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4NTM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4NTU0Mg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408585542", "bodyText": "comment here a new content type due to backward incompatible for existing ProtoReader.", "author": "mchen07", "createdAt": "2020-04-15T05:15:15Z", "path": "restli-client/src/test/java/com/linkedin/restli/client/RestClientTest.java", "diffHunk": "@@ -176,6 +176,7 @@ private TimeoutOption(Long l, TimeUnit timeUnit)\n     LICOR_TEXT(ContentType.LICOR_TEXT),\n     LICOR_BINARY(ContentType.LICOR_BINARY),\n     PROTOBUF(ContentType.PROTOBUF),\n+    LI_PROTOBUF(ContentType.LI_PROTOBUF),", "originalCommit": "5a9222c89bfbcea160a5405ec2c48c7aa4dff319", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxNTcxOA==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408615718", "bodyText": "Rather than add a comment here, I added it in ContentType.", "author": "karthikrg", "createdAt": "2020-04-15T06:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4NTU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2NjE2MQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408966161", "bodyText": "Then adding a comment there saying why we have two: PROTOBUF_DATA_CODEC and LI_PROTOBUF_DATA_CODEC. and difference btw the two.", "author": "mchen07", "createdAt": "2020-04-15T16:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODU4NTU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMzY2NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408603665", "bodyText": "nit: can directly use buffer(byte) instead of writeByte", "author": "aman1309", "createdAt": "2020-04-15T06:15:33Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/ProtoWriter.java", "diffHunk": "@@ -301,18 +320,30 @@ public void writeString(String value) throws IOException\n \n       if (minLengthVarIntSize == maxLengthVarIntSize)\n       {\n-        _position = oldPosition + minLengthVarIntSize;\n+        _position = oldPosition + leadingOrdinalLength + minLengthVarIntSize;\n         int newPosition = Utf8Utils.encode(value, _buffer, _position, _limit - _position);\n         // Since this class is stateful and tracks the position, we rewind and store the state,\n         // prepend the length, then reset it back to the end of the string.\n         _position = oldPosition;\n-        int length = newPosition - oldPosition - minLengthVarIntSize;\n+        int length = newPosition - oldPosition - leadingOrdinalLength - minLengthVarIntSize;\n+\n+        if (leadingOrdinalGenerator != null)\n+        {\n+          writeByte(leadingOrdinalGenerator.apply(length));", "originalCommit": "5a9222c89bfbcea160a5405ec2c48c7aa4dff319", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwNTk2NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408605965", "bodyText": "curious why ASCII ordinal has to be 20?", "author": "aman1309", "createdAt": "2020-04-15T06:22:03Z", "path": "data/src/main/java/com/linkedin/data/codec/ProtobufDataCodec.java", "diffHunk": "@@ -57,29 +56,27 @@\n   private static final byte RAW_BYTES_ORDINAL = 10;\n   private static final byte NULL_ORDINAL = 11;\n \n-  private static final Map<Class<?>, Byte> ORDINAL_MAP = new HashMap<>();\n-  static {\n-    ORDINAL_MAP.put(DataMap.class, MAP_ORDINAL);\n-    ORDINAL_MAP.put(DataList.class, LIST_ORDINAL);\n-    ORDINAL_MAP.put(String.class, STRING_LITERAL_ORDINAL);\n-    ORDINAL_MAP.put(Integer.class, INTEGER_ORDINAL);\n-    ORDINAL_MAP.put(Long.class, LONG_ORDINAL);\n-    ORDINAL_MAP.put(Float.class, FLOAT_ORDINAL);\n-    ORDINAL_MAP.put(Double.class,DOUBLE_ORDINAL);\n-    ORDINAL_MAP.put(Boolean.class, BOOLEAN_FALSE_ORDINAL);\n-    ORDINAL_MAP.put(ByteString.class, RAW_BYTES_ORDINAL);\n-  }\n+  // 12-19 is reserved for custom ordinals to be used by codec extenders.\n+  private static final byte ASCII_STRING_LITERAL_ORDINAL = 20;", "originalCommit": "5a9222c89bfbcea160a5405ec2c48c7aa4dff319", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxNzY1Mg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408617652", "bodyText": "We reserved 12-19 for custom ordinals to be used by codec extenders. Protobuf codec for example is extended within LI and used in dedupe mode for frontends at LinkedIn.", "author": "karthikrg", "createdAt": "2020-04-15T06:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwNTk2NQ=="}], "type": "inlineReview"}, {"oid": "7a78f064b0581387a310987107c0a9914748df09", "url": "https://github.com/linkedin/rest.li/commit/7a78f064b0581387a310987107c0a9914748df09", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-15T06:54:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1NTU4Mg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408655582", "bodyText": "nit: I'd rename this as updateState()", "author": "karthikbalasub", "createdAt": "2020-04-15T08:04:24Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1584,4 +1618,48 @@ private int getCurrentRemaining()\n       return _currentSegment.getOffset() + _currentSegment.getLength() - _localOffset;\n     }\n   }\n+\n+  /**\n+   * Maintains the current state of the decoder when parsing a {@link String} across\n+   * multiple {@link ByteArray} instances.\n+   */\n+  private static class ByteStringLongDecoderState extends Utf8Utils.LongDecoderState\n+  {\n+    private final ByteArrayVector _byteArrays;\n+\n+    private int _currentIndex;\n+\n+    ByteStringLongDecoderState(ByteArrayVector byteArrays, int currentIndex, int localOffset)\n+    {\n+      _byteArrays =  byteArrays;\n+      _currentIndex = currentIndex;\n+      initialize();\n+      _position = localOffset;\n+    }\n+\n+    @Override\n+    public void readNextChunk() throws IOException\n+    {\n+      if (++_currentIndex >= _byteArrays.getArraySize())\n+      {\n+        throw new EOFException();\n+      }\n+\n+      initialize();\n+    }\n+\n+    int getCurrentIndex()\n+    {\n+      return _currentIndex;\n+    }\n+\n+    private void initialize()", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODI2MQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408658261", "bodyText": "Do you think the 8 ordinals are sufficient for custom extensions? Should we add more room?", "author": "karthikbalasub", "createdAt": "2020-04-15T08:09:19Z", "path": "data/src/main/java/com/linkedin/data/codec/ProtobufDataCodec.java", "diffHunk": "@@ -57,29 +56,27 @@\n   private static final byte RAW_BYTES_ORDINAL = 10;\n   private static final byte NULL_ORDINAL = 11;\n \n-  private static final Map<Class<?>, Byte> ORDINAL_MAP = new HashMap<>();\n-  static {\n-    ORDINAL_MAP.put(DataMap.class, MAP_ORDINAL);\n-    ORDINAL_MAP.put(DataList.class, LIST_ORDINAL);\n-    ORDINAL_MAP.put(String.class, STRING_LITERAL_ORDINAL);\n-    ORDINAL_MAP.put(Integer.class, INTEGER_ORDINAL);\n-    ORDINAL_MAP.put(Long.class, LONG_ORDINAL);\n-    ORDINAL_MAP.put(Float.class, FLOAT_ORDINAL);\n-    ORDINAL_MAP.put(Double.class,DOUBLE_ORDINAL);\n-    ORDINAL_MAP.put(Boolean.class, BOOLEAN_FALSE_ORDINAL);\n-    ORDINAL_MAP.put(ByteString.class, RAW_BYTES_ORDINAL);\n-  }\n+  // 12-19 is reserved for custom ordinals to be used by codec extenders.", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyNjgyOQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409126829", "bodyText": "Should be fine. I can update the comment to also say that 30-127 is also reserved for custom ordinals. This way we can have room for expansion as well as clear boundaries on what we consider as private expansion space for the root codec.", "author": "karthikrg", "createdAt": "2020-04-15T20:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4MjA0NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408682045", "bodyText": "This is no longer true?", "author": "karthikbalasub", "createdAt": "2020-04-15T08:49:12Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/InputStreamReader.java", "diffHunk": "@@ -0,0 +1,655 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+// Protocol Buffers - Google's data interchange format\n+// Copyright 2008 Google Inc.  All rights reserved.\n+// https://developers.google.com/protocol-buffers/\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+package com.linkedin.data.protobuf;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+/**\n+ * Implementation of {@link ProtoReader} that uses an {@link InputStream} as the data source.\n+ */\n+final class InputStreamReader extends ProtoReader\n+{\n+  private final InputStream _input;\n+  private final byte[] _buffer;\n+\n+  /**\n+   * Represents how many bytes are currently filled in the _buffer\n+   */\n+  private int _bufferSize;\n+\n+  private int _bufferSizeAfterLimit;\n+  private int _pos;\n+\n+  /**\n+   * The total number of bytes read before the current _buffer. The total bytes read up to the\n+   * current position can be computed as {@code _totalBytesRetired + _pos}. This value may be\n+   * negative if reading started in the middle of the current _buffer (e.g. if the constructor that\n+   * takes a byte array and an offset was used).", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyODIxMw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409128213", "bodyText": "You are right. I updated the comment.", "author": "karthikrg", "createdAt": "2020-04-15T20:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4MjA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Nzg4Nw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408687887", "bodyText": "typo: initialSize", "author": "karthikbalasub", "createdAt": "2020-04-15T08:58:50Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/TextBuffer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+\n+package com.linkedin.data.protobuf;\n+\n+/**\n+ * A container for holding text data in the form of a char[] to minimize allocations when parsing strings.\n+ */\n+final class TextBuffer\n+{\n+  private char[] _buffer;\n+\n+  /**\n+   * Constructor\n+   *\n+   * @param intialSize  The initial size of the buffer instantiated from the pool.\n+   */\n+  public TextBuffer(int intialSize)", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNDE5Mg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408704192", "bodyText": "Consider moving limit inside the state. _offset and _bufferSize are not need outside of calculating limit.", "author": "karthikbalasub", "createdAt": "2020-04-15T09:25:58Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/Utf8Utils.java", "diffHunk": "@@ -274,191 +274,320 @@ private static int encodedLengthGeneral(CharSequence sequence, int start)\n   }\n \n   /**\n-   * Decodes the given UTF-8 encoded byte array slice into a {@link String}.\n-   *\n-   * @throws IllegalArgumentException if the input is not valid UTF-8.\n+   * Decodes the given ASCII encoded byte array slice into a {@link String}.\n    */\n-  public static String decode(byte[] bytes, int index, int size)\n+  public static String decodeASCII(byte[] bytes, int index, int size, TextBuffer textBuffer)\n   {\n-    // Bitwise OR combines the sign bits so any negative value fails the check.\n-    if ((index | size | bytes.length - index - size) < 0)\n-    {\n-      throw new ArrayIndexOutOfBoundsException(\n-          String.format(\"buffer length=%d, index=%d, size=%d\", bytes.length, index, size));\n-    }\n-\n     int offset = index;\n     final int limit = offset + size;\n \n-    // The longest possible resulting String is the same as the number of input bytes, when it is\n-    // all ASCII. For other cases, this over-allocates and we will truncate in the end.\n-    char[] resultArr = new char[size];\n-    int resultPos = 0;\n+    // Reuse buffers to avoid thrashing due to transient allocs.\n+    char[] resultArr = null;\n+    try\n+    {\n+      resultArr = textBuffer.getBuf(size);\n+      int resultPos = 0;\n+      while (offset < limit) {\n+        resultArr[resultPos++] = (char) bytes[offset++];\n+      }\n+      return new String(resultArr, 0, size);\n+    }\n+    finally\n+    {\n+      textBuffer.returnBuf(resultArr);\n+    }\n+  }\n \n-    while (offset < limit)\n+  /**\n+   * Decodes a long ASCII encoded byte source that spans multiple byte array chunks into a {@link String}.\n+   */\n+  public static String decodeLongASCII(LongDecoderState state, int size, TextBuffer textBuffer) throws IOException\n+  {\n+    // Reuse buffers to avoid thrashing due to transient allocs.\n+    char[] resultArr = null;\n+    try\n     {\n-      byte byte1 = bytes[offset++];\n-      int value = byte1 & 0xff;\n-      switch (UTF8_LOOKUP_TABLE[value])\n+      resultArr = textBuffer.getBuf(size);\n+      int resultPos = 0;\n+\n+      byte[] buffer = state._buffer;\n+      int position = state._position;\n+      int limit = state._offset + state._bufferSize;", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEzMTI3Ng==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409131276", "bodyText": "I prefer keeping it this way. This way we will have more flexibility in the future when dealing with incremental chunked data sources (if we need to like chrysaor does today).", "author": "karthikrg", "createdAt": "2020-04-15T21:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcwNDE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MTEzNw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408961137", "bodyText": "Is this the same or similar code as that one in ByteArrayReader? Is it possible to share some code.", "author": "mchen07", "createdAt": "2020-04-15T16:07:44Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/InputStreamReader.java", "diffHunk": "@@ -0,0 +1,655 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+// Protocol Buffers - Google's data interchange format\n+// Copyright 2008 Google Inc.  All rights reserved.\n+// https://developers.google.com/protocol-buffers/\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions are\n+// met:\n+//\n+//     * Redistributions of source code must retain the above copyright\n+// notice, this list of conditions and the following disclaimer.\n+//     * Redistributions in binary form must reproduce the above\n+// copyright notice, this list of conditions and the following disclaimer\n+// in the documentation and/or other materials provided with the\n+// distribution.\n+//     * Neither the name of Google Inc. nor the names of its\n+// contributors may be used to endorse or promote products derived from\n+// this software without specific prior written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+package com.linkedin.data.protobuf;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+/**\n+ * Implementation of {@link ProtoReader} that uses an {@link InputStream} as the data source.\n+ */\n+final class InputStreamReader extends ProtoReader\n+{\n+  private final InputStream _input;\n+  private final byte[] _buffer;\n+\n+  /**\n+   * Represents how many bytes are currently filled in the _buffer\n+   */\n+  private int _bufferSize;\n+\n+  private int _bufferSizeAfterLimit;\n+  private int _pos;\n+\n+  /**\n+   * The total number of bytes read before the current _buffer. The total bytes read up to the\n+   * current position can be computed as {@code _totalBytesRetired + _pos}. This value may be\n+   * negative if reading started in the middle of the current _buffer (e.g. if the constructor that\n+   * takes a byte array and an offset was used).\n+   */\n+  private int _totalBytesRetired;\n+\n+  /**\n+   * The absolute position of the end of the current message.\n+   */\n+  private int _currentLimit = Integer.MAX_VALUE;\n+\n+  InputStreamReader(final InputStream input, int bufferSize)\n+  {\n+    _input = input;\n+    _buffer = new byte[bufferSize];\n+    _bufferSize = 0;\n+    _pos = 0;\n+    _totalBytesRetired = 0;\n+  }\n+\n+  @Override\n+  public String readASCIIString() throws IOException {\n+    final int size = readInt32();\n+    if (size > 0)\n+    {\n+      // If we can fit into a buffer, read directly off the buffer,\n+      if (size < _bufferSize)\n+      {\n+        // Slow path: We can fit into a buffer, but there aren't enough bytes available in the current buffer.\n+        // Refill!\n+        if (size > (_bufferSize - _pos))\n+        {\n+          refillBuffer(size);\n+        }\n+\n+        String value = Utf8Utils.decodeASCII(_buffer, _pos, size, _textBuffer);\n+        _pos += size;\n+        return value;\n+      }\n+      else\n+      {\n+        Utf8Utils.LongDecoderState state = new InputStreamLongDecoderState(_buffer, _pos, _bufferSize, _input);\n+        String value = Utf8Utils.decodeLongASCII(state, size, _textBuffer);\n+        _pos = state.getPosition();\n+        _bufferSize = state.getBufferSize();\n+        return value;\n+      }\n+    }\n+    else if (size == 0)\n+    {\n+      return \"\";\n+    }\n+    else\n+    {\n+      throw new IOException(\"Read negative size: \" + size + \". Invalid string\");\n+    }\n+  }\n+\n+  @Override\n+  public String readString() throws IOException\n+  {\n+    final int size = readInt32();\n+    if (size > 0)\n+    {\n+      // If we can fit into a buffer, read directly off the buffer,\n+      if (size < _bufferSize)\n+      {\n+        // Slow path: We can fit into a buffer, but there aren't enough bytes available in the current buffer.\n+        // Refill!\n+        if (size > (_bufferSize - _pos))\n+        {\n+          refillBuffer(size);\n+        }\n+\n+        String value = Utf8Utils.decode(_buffer, _pos, size, _textBuffer);\n+        _pos += size;\n+        return value;\n+      }\n+      else\n+      {\n+        Utf8Utils.LongDecoderState state = new InputStreamLongDecoderState(_buffer, _pos, _bufferSize, _input);\n+        String value = Utf8Utils.decodeLong(state, size, _textBuffer);\n+        _pos = state.getPosition();\n+        _bufferSize = state.getBufferSize();\n+        return value;\n+      }\n+    }\n+    else if (size == 0)\n+    {\n+      return \"\";\n+    }\n+    else\n+    {\n+      throw new IOException(\"Read negative size: \" + size + \". Invalid string\");\n+    }\n+  }\n+\n+  @Override\n+  public byte[] readByteArray() throws IOException\n+  {\n+    final int size = readInt32();\n+    if (size <= (_bufferSize - _pos) && size > 0)\n+    {\n+      // Fast path: We already have the bytes in a contiguous _buffer, so\n+      // just copy directly from it.\n+      final byte[] result = Arrays.copyOfRange(_buffer, _pos, _pos + size);\n+      _pos += size;\n+      return result;\n+    }\n+    else\n+    {\n+      // Slow path: Build a byte array first then copy it.\n+      return readRawBytesSlowPath(size);\n+    }\n+  }\n+\n+  @Override\n+  public int readInt32() throws IOException\n+  {\n+    // See implementation notes for readInt64\n+    fastpath:\n+    {\n+      int tempPos = _pos;\n+\n+      if (_bufferSize == tempPos)\n+      {\n+        break fastpath;\n+      }\n+\n+      final byte[] buffer = this._buffer;\n+      int x;\n+      if ((x = buffer[tempPos++]) >= 0)\n+      {\n+        _pos = tempPos;\n+        return x;\n+      }\n+      else if (_bufferSize - tempPos < 9)\n+      {\n+        break fastpath;\n+      }\n+      else if ((x ^= (buffer[tempPos++] << 7)) < 0)\n+      {\n+        x ^= (~0 << 7);\n+      }\n+      else if ((x ^= (buffer[tempPos++] << 14)) >= 0)\n+      {\n+        x ^= (~0 << 7) ^ (~0 << 14);\n+      }\n+      else if ((x ^= (buffer[tempPos++] << 21)) < 0)\n+      {\n+        x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21);\n+      }\n+      else\n+      {\n+        int y = buffer[tempPos++];\n+        x ^= y << 28;\n+        x ^= (~0 << 7) ^ (~0 << 14) ^ (~0 << 21) ^ (~0 << 28);\n+        if (y < 0\n+            && buffer[tempPos++] < 0\n+            && buffer[tempPos++] < 0\n+            && buffer[tempPos++] < 0\n+            && buffer[tempPos++] < 0\n+            && buffer[tempPos++] < 0)\n+        {\n+          break fastpath; // Will throw malformedVarint()\n+        }\n+      }\n+      _pos = tempPos;\n+      return x;\n+    }\n+    return (int) readRawVarint64SlowPath();\n+  }\n+\n+  @Override\n+  public long readInt64() throws IOException", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEzMjU3Mg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409132572", "bodyText": "Looks similar but there are subtle differences in between the method in several places. Choose to keep it separate for better clarity/readability, especially given that this method will hardly ever change.\nGoogle's protobuf implementation does the same FWIW", "author": "karthikrg", "createdAt": "2020-04-15T21:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2MTEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2Njk1Mg==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408966952", "bodyText": "See my earlier comments. Add comments to explain the difference between two.", "author": "mchen07", "createdAt": "2020-04-15T16:16:22Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/ContentType.java", "diffHunk": "@@ -55,6 +55,7 @@\n   private static final JacksonLICORStreamDataCodec\n       LICOR_BINARY_STREAM_DATA_CODEC = new JacksonLICORStreamDataCodec(R2Constants.DEFAULT_DATA_CHUNK_SIZE, true);\n   private static final ProtobufDataCodec PROTOBUF_DATA_CODEC = new ProtobufDataCodec();\n+  private static final ProtobufDataCodec LI_PROTOBUF_DATA_CODEC = new ProtobufDataCodec(null, true);", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2ODQ3Nw==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r408968477", "bodyText": "Nit: For open source, LI in the name or header has too much trace on the contributing company, why do we need to use LI in the header name, can we name it based on functionality?", "author": "mchen07", "createdAt": "2020-04-15T16:18:47Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/ContentType.java", "diffHunk": "@@ -55,6 +55,7 @@\n   private static final JacksonLICORStreamDataCodec\n       LICOR_BINARY_STREAM_DATA_CODEC = new JacksonLICORStreamDataCodec(R2Constants.DEFAULT_DATA_CHUNK_SIZE, true);\n   private static final ProtobufDataCodec PROTOBUF_DATA_CODEC = new ProtobufDataCodec();\n+  private static final ProtobufDataCodec LI_PROTOBUF_DATA_CODEC = new ProtobufDataCodec(null, true);", "originalCommit": "7a78f064b0581387a310987107c0a9914748df09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEzMjg5NQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409132895", "bodyText": "I agree with removing LI. I am just gonna call it protobuf v2.", "author": "karthikrg", "createdAt": "2020-04-15T21:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2ODQ3Nw=="}], "type": "inlineReview"}, {"oid": "3bf467bc0e0c19dc88c28df5b226d6f0977f6d78", "url": "https://github.com/linkedin/rest.li/commit/3bf467bc0e0c19dc88c28df5b226d6f0977f6d78", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-15T23:24:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTIxMzc0MQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409213741", "bodyText": "buffer() here too", "author": "aman1309", "createdAt": "2020-04-16T00:39:25Z", "path": "li-protobuf/src/main/java/com/linkedin/data/protobuf/ProtoWriter.java", "diffHunk": "@@ -301,18 +320,30 @@ public void writeString(String value) throws IOException\n \n       if (minLengthVarIntSize == maxLengthVarIntSize)\n       {\n-        _position = oldPosition + minLengthVarIntSize;\n+        _position = oldPosition + leadingOrdinalLength + minLengthVarIntSize;\n         int newPosition = Utf8Utils.encode(value, _buffer, _position, _limit - _position);\n         // Since this class is stateful and tracks the position, we rewind and store the state,\n         // prepend the length, then reset it back to the end of the string.\n         _position = oldPosition;\n-        int length = newPosition - oldPosition - minLengthVarIntSize;\n+        int length = newPosition - oldPosition - leadingOrdinalLength - minLengthVarIntSize;\n+\n+        if (leadingOrdinalGenerator != null)\n+        {\n+          buffer(leadingOrdinalGenerator.apply(length));\n+        }\n+\n         bufferUInt32(length);\n         _position = newPosition;\n       }\n       else\n       {\n         int length = Utf8Utils.encodedLength(value);\n+\n+        if (leadingOrdinalGenerator != null)\n+        {\n+          writeByte(leadingOrdinalGenerator.apply(length));", "originalCommit": "3bf467bc0e0c19dc88c28df5b226d6f0977f6d78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c49c6e878f2c0a40d1eab2f5895ee87631ab8c3", "url": "https://github.com/linkedin/rest.li/commit/7c49c6e878f2c0a40d1eab2f5895ee87631ab8c3", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-16T00:40:27Z", "type": "forcePushed"}, {"oid": "fae9b5fbb0a87c9a4598ab416c3456baab61c798", "url": "https://github.com/linkedin/rest.li/commit/fae9b5fbb0a87c9a4598ab416c3456baab61c798", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-16T02:44:30Z", "type": "forcePushed"}, {"oid": "aba32b06c7f435de7d1b4963ede5f51739e8033e", "url": "https://github.com/linkedin/rest.li/commit/aba32b06c7f435de7d1b4963ede5f51739e8033e", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-16T04:13:55Z", "type": "forcePushed"}, {"oid": "f5a1e0a006af05b1bdc8933fc41f812d8146e88f", "url": "https://github.com/linkedin/rest.li/commit/f5a1e0a006af05b1bdc8933fc41f812d8146e88f", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-16T04:24:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI3MzExMQ==", "url": "https://github.com/linkedin/rest.li/pull/260#discussion_r409273111", "bodyText": "This also needs to rename to currentArrayOffset.", "author": "mchen07", "createdAt": "2020-04-16T04:23:15Z", "path": "data/src/main/java/com/linkedin/data/ByteString.java", "diffHunk": "@@ -1560,28 +1596,72 @@ private long readRawVarint64SlowPath() throws IOException\n       int length = getCurrentRemaining();\n       if (length > 0)\n       {\n-        System.arraycopy(_currentSegment.getArray(), _localOffset, bytes, offset, length);\n+        System.arraycopy(_currentSegment.getArray(), _currentArrayOffset, bytes, offset, length);\n         size -= length;\n         offset += length;\n-        _localOffset += length;\n+        _currentArrayOffset += length;\n       }\n \n       while (size > 0)\n       {\n         readNextBuffer();\n         length = Math.min(size, _currentSegment.getLength());\n-        System.arraycopy(_currentSegment.getArray(), _localOffset, bytes, offset, length);\n+        System.arraycopy(_currentSegment.getArray(), _currentArrayOffset, bytes, offset, length);\n         size -= length;\n         offset += length;\n-        _localOffset += length;\n+        _currentArrayOffset += length;\n       }\n \n       return bytes;\n     }\n \n     private int getCurrentRemaining()\n     {\n-      return _currentSegment.getOffset() + _currentSegment.getLength() - _localOffset;\n+      return _currentSegment.getOffset() + _currentSegment.getLength() - _currentArrayOffset;\n+    }\n+  }\n+\n+  /**\n+   * Maintains the current state of the decoder when parsing a {@link String} across\n+   * multiple {@link ByteArray} instances.\n+   */\n+  private static class ByteStringLongDecoderState extends Utf8Utils.LongDecoderState\n+  {\n+    private final ByteArrayVector _byteArrays;\n+\n+    private int _currentIndex;\n+\n+    ByteStringLongDecoderState(ByteArrayVector byteArrays, int currentIndex, int localOffset)", "originalCommit": "aba32b06c7f435de7d1b4963ede5f51739e8033e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "886f12949b27abee22bc692aecc1705c6a953b47", "url": "https://github.com/linkedin/rest.li/commit/886f12949b27abee22bc692aecc1705c6a953b47", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-16T05:42:31Z", "type": "forcePushed"}, {"oid": "b67dde474ce181b9f0d880f420b822161773421e", "url": "https://github.com/linkedin/rest.li/commit/b67dde474ce181b9f0d880f420b822161773421e", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-17T00:11:40Z", "type": "commit"}, {"oid": "b67dde474ce181b9f0d880f420b822161773421e", "url": "https://github.com/linkedin/rest.li/commit/b67dde474ce181b9f0d880f420b822161773421e", "message": "Protobuf parsing performance improvements.\nIntroduce support for ASCII only strings. Since this is a backward incompatible change, introduce a new content type for it, and deprecate the old one. By encoding ASCII only strings with a separate ordinal, we give a hint to decoders to use a faster path for decoding ASCII only strings in which bytes directly map to chars, and there are no multi-byte chars.", "committedDate": "2020-04-17T00:11:40Z", "type": "forcePushed"}]}