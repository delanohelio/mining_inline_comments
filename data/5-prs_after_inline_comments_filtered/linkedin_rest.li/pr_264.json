{"pr_number": 264, "pr_title": "DarkCluster schema changes: adding multiplierStrategyList and transportClientProperties", "pr_createdAt": "2020-04-21T06:19:26Z", "pr_url": "https://github.com/linkedin/rest.li/pull/264", "timeline": [{"oid": "9ef5448a157b528ba7f1be3fa0b2cdf217ab5e54", "url": "https://github.com/linkedin/rest.li/commit/9ef5448a157b528ba7f1be3fa0b2cdf217ab5e54", "message": "rebase and incorporate pdsc->pdl migration", "committedDate": "2020-04-21T22:24:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412633715", "bodyText": "Can we keep this old behavior of using Jackson to serialize everything and selectively replace each transport properties with output of TransportClientPropertiesConverter?", "author": "zhang-chris", "createdAt": "2020-04-22T03:02:49Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);", "originalCommit": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3NDAzNw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412674037", "bodyText": "that seems pretty hacky. Doing what I did (use the Map<String, Object>) is more consistent with what the code was doing for other stuff, anyway. The only reason I was trying to use the pegasus object for both in-mem and for zookeeper storage was because I didn't see the need to have two formats; with the inclusion of transportClientProperties I do need the separate format. Regarding your proposal, that would require retraversing the DarkClusterConfigMap and accessing the dataMap directly to hardcode some mappings, and wouldn't take into account further changes in the TransportClientPropertiesConverter. So I don't think that's a better option. Doing the Map<String, Object> way may be more code, but it's pretty understandable and in line with the rest of the Converter classes.", "author": "davidhoa", "createdAt": "2020-04-22T05:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MzMwMQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r413373301", "bodyText": "ok", "author": "zhang-chris", "createdAt": "2020-04-22T22:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYzMzcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412642252", "bodyText": "this will never be reached because of previous \"darkClusterConfig.getMultiplier() > 0\"", "author": "zhang-chris", "createdAt": "2020-04-22T03:30:24Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)", "originalCommit": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MzY2NQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412643665", "bodyText": "I think it would be a lot cleaner if we had the implementations themselves handle these edge cases rather than manually returning NoOpDarkClusterStrategy. In this case always return new RelativeTrafficMultiplierDarkClusterStrategy but since the multiplier is <= 0 then no requests will be sent out.", "author": "zhang-chris", "createdAt": "2020-04-22T03:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3NjExOQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412676119", "bodyText": "yeah, sorry about that. I'll fix that code. The reasons I did not want to have the implementations handle it was because then every handleRequest invocation has to do an if check, rather than only when a strategy has to be created. The tradeoff of putting it in createStrategy seems to be worth not doing that if statement in the hot path.", "author": "davidhoa", "createdAt": "2020-04-22T05:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjY0Mg==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412642642", "bodyText": "This else statement return breaks the use of strategy list since it will never iterate past the first element. but also made a previous comment on not using a list.", "author": "zhang-chris", "createdAt": "2020-04-22T03:31:32Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else", "originalCommit": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3Njc3MQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412676771", "bodyText": "doing this will still use the strategylist, because if constant qps isn't available, it will go into the else if and not the else:\nif (RELATIVE_TRAFFIC) {\n}\nelse if (CONSTANT_QPS) {\n}\nelse {\n}", "author": "davidhoa", "createdAt": "2020-04-22T05:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0MjY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0NjMzMQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412646331", "bodyText": "Prefer using switch/case for clarity.", "author": "zhang-chris", "createdAt": "2020-04-22T03:43:21Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +112,38 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n-    {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      MultiplierStrategyTypeArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.multiplierStrategyType multiplierStrategyType : strategyList)\n+      {\n+        if (RELATIVE_TRAFFIC.equals(multiplierStrategyType) && darkClusterConfig.getMultiplier() > 0)\n+        {\n+          if (darkClusterConfig.getMultiplier() <= 0)\n+          {\n+            // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+            // temporarily set the traffic to zero; don't log anything.\n+            return new NoOpDarkClusterStrategy();\n+          }\n+          BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+            new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+          return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                  baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                  _random);\n+        }\n+        else if (CONSTANT_QPS.equals(multiplierStrategyType))\n+        {\n+          // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+        }\n+        else\n+        {\n+          // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n+          return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.\n+    return new NoOpDarkClusterStrategy();\n   }", "originalCommit": "c34b0fd615dd6fe4fbe7d64c09aa013871ebeb01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY3NzAxMw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r412677013", "bodyText": "sure.", "author": "davidhoa", "createdAt": "2020-04-22T05:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjY0NjMzMQ=="}], "type": "inlineReview"}, {"oid": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "url": "https://github.com/linkedin/rest.li/commit/65ab2577596c9527dc65e2eb9ebf1db000ec613a", "message": "additional comment changes", "committedDate": "2020-04-23T20:44:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414119984", "bodyText": "make the naming uniform - I think these are fine:\nDEFAULT_MULTIPLIER\nDEFAULT_DISPATCHER....", "author": "zhang-chris", "createdAt": "2020-04-23T20:59:23Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -39,6 +46,9 @@\n   private static final JacksonDataCodec CODEC = new JacksonDataCodec();\n   private static final ValidationOptions VALIDATION_OPTIONS =\n       new ValidationOptions(RequiredMode.FIXUP_ABSENT_WITH_DEFAULT, CoercionMode.STRING_TO_PRIMITIVE);\n+  private static final float DARK_CLUSTER_MULTIPLIER_DEFAULT = 0;\n+  private static final int DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE = Integer.MAX_VALUE;\n+  private static final int DARK_CLUSTER_DISPATCHER_TARGET_RATE = 0;", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MjU5Ng==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414152596", "bodyText": "Can we use the static variables defined in ClusterProperties? Or move those variables to a more appropriate class?", "author": "zhang-chris", "createdAt": "2020-04-23T21:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2Njc4MA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414166780", "bodyText": "ah, forgot I had those. I'll use the ones defined in ClusterProperties.", "author": "davidhoa", "createdAt": "2020-04-23T22:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExOTk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMDc1MA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414120750", "bodyText": "instead of a comment here can we add a description to the javadoc of converter method in TransportClientPropertiesConverter?", "author": "zhang-chris", "createdAt": "2020-04-23T21:00:49Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2OTAwNg==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414169006", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-23T22:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTE0Mw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414139143", "bodyText": "not necessary here, let's remove", "author": "zhang-chris", "createdAt": "2020-04-23T21:33:20Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3MTU0MQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414171541", "bodyText": "since we put it in the pdl, yes, we can remove this.", "author": "davidhoa", "createdAt": "2020-04-23T22:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTgyOQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414139829", "bodyText": "can remove here too. I don't think converter needs to do anything special to be resilient since it's just a string anyway.", "author": "zhang-chris", "createdAt": "2020-04-23T21:34:45Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }\n+\n+      // the multiplier strategy list is a list instead of a single value because rolling out a new strategy\n+      // can be decoupled from upgrading a service if you use a list that has a prioritized list with new\n+      // strategies and old (existing) strategies.\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST))\n+      {\n+        DataList dataList = new DataList();\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> strategyList = (List<String>)props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST);\n+        dataList.addAll(strategyList);\n+\n+        // note that unknown strategyTypes can be added here. This can happen for new strategies as they are rolling\n+        // out, or for bad strategy types. The converter and client code should be resilient to these.", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3Mjk4Mw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414172983", "bodyText": "I had this comment because another way would have been to convert each entry in the strategy list to a DarkClusterStrategyName enum, and then create the array. But instead, I chose to go the dataList way that takes the List untouched, so that the unknown strategy is preserved, and the client can return $Unknown instead. But I agree that the comment is not needed anymore, since this is implied by the comments in the pdl.", "author": "davidhoa", "createdAt": "2020-04-23T22:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEzOTgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MDc2MQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414140761", "bodyText": "Is this necessary? Can we remove? no one is using this config yet anyway", "author": "zhang-chris", "createdAt": "2020-04-23T21:36:26Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +59,115 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundMaxRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE, darkClusterConfig.getDispatcherOutboundMaxRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDispatcherOutboundTargetRate())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE, darkClusterConfig.getDispatcherOutboundTargetRate().toString());\n+        }\n+\n+        if (darkClusterConfig.hasMultiplierStrategyList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getMultiplierStrategyList();\n+          List<String> strategyList = new ArrayList<>();\n+          for (DarkClusterStrategyName type : myArray)\n+          {\n+            strategyList.add(type.toString());\n+          }\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST, strategyList);\n+        }\n+\n+        if (darkClusterConfig.hasTransportClientProperties())\n+        {\n+          // transportClientProperties needs special serialization, as the keys that are written to zookeeper are not\n+          // the same as the field names.\n+          prop.put(PropertyKeys.DARK_CLUSTER_TRANSPORT_CLIENT_PROPERTIES,\n+                   TransportClientPropertiesConverter.toProperties(darkClusterConfig.getTransportClientProperties()));\n+        }\n+        darkProps.put(darkClusterName, prop);\n       }\n+      return darkProps;\n     }\n   }\n \n   public static DarkClusterConfigMap toConfig(Map<String, Object> properties)\n   {\n-    try\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    for (Map.Entry<String, Object> entry : properties.entrySet())\n     {\n-      if (properties == null)\n+      String darkClusterName = entry.getKey();\n+      DarkClusterConfig darkClusterConfig = new DarkClusterConfig();\n+      @SuppressWarnings(\"unchecked\")\n+      Map<String, Object> props = (Map<String, Object>) entry.getValue();\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_MULTIPLIER))\n+      {\n+        darkClusterConfig.setMultiplier(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_MULTIPLIER), Float.class));\n+      }\n+      else\n       {\n-        return new DarkClusterConfigMap();\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setMultiplier(DARK_CLUSTER_MULTIPLIER_DEFAULT);\n       }\n-      String json = JacksonUtil.getObjectMapper().writeValueAsString(properties);\n-      DarkClusterConfigMap darkClusterConfigMap = new DarkClusterConfigMap(CODEC.stringToMap(json));\n-      //fixes are applied in place\n-      ValidateDataAgainstSchema.validate(darkClusterConfigMap, VALIDATION_OPTIONS);\n \n-      return darkClusterConfigMap;\n-    }\n-    catch (IOException e)\n-    {\n-      throw new RuntimeException(e);\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundMaxRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_MAX_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundMaxRate(DARK_CLUSTER_DISPATCHER_OUTBOUND_MAX_RATE);\n+      }\n+\n+      if (props.containsKey(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE))\n+      {\n+        darkClusterConfig.setDispatcherOutboundTargetRate(PropertyUtil.coerce(props.get(PropertyKeys.DARK_CLUSTER_OUTBOUND_TARGET_RATE), Integer.class));\n+      }\n+      else\n+      {\n+        // to maintain backwards compatibility with previously ser/de, set the default on deserialization\n+        darkClusterConfig.setDispatcherOutboundTargetRate(DARK_CLUSTER_DISPATCHER_TARGET_RATE);\n+      }", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MTQ2OA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414141468", "bodyText": "Can you include a class-level javadoc explaining how everything here is what is stored in zk, etc to prevent running into this issue again?", "author": "zhang-chris", "createdAt": "2020-04-23T21:37:51Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -38,7 +41,7 @@\n   private final Set<URI> _bannedUris;\n   @Deprecated\n   private final List<String>          _prioritizedSchemes;\n-  private final DarkClusterConfigMap _darkClusters;\n+  private final Map<String, Object> _darkClusters;\n   private final boolean              _delegated;\n \n   public ClusterProperties(String clusterName)", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3NzIxMQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414177211", "bodyText": "will do.", "author": "davidhoa", "createdAt": "2020-04-23T22:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MTQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0Njc2Mg==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414146762", "bodyText": "I thought I left a comment about this but I don't see it, weird. Anyway can we keep this constructor and do a conversion from  DarkClusterConfigMap to Map<String, Object> instead?", "author": "zhang-chris", "createdAt": "2020-04-23T21:48:08Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/ClusterProperties.java", "diffHunk": "@@ -95,9 +102,17 @@ public ClusterProperties(String clusterName,\n       DarkClusterConfigMap darkClusters)\n   {\n     this(clusterName, prioritizedSchemes, properties, bannedUris, partitionProperties, sslSessionValidationStrings,\n-        darkClusters, false);\n+        (Map<String, Object>)null, false);\n   }\n \n+  /**\n+   * @deprecated Use the constructor that uses a Map instead of DarkClusterConfigMap. Using this object is not flexible enough to hold\n+   * transportClientProperties, because {@link com.linkedin.d2.balancer.config.TransportClientPropertiesConverter} uses different\n+   * keys in it's serialization than how Jackson would serialize D2TransportClientProperties. That is problematic since ClusterProperties\n+   * already should have had all necessary conversions done, but in this case the pegasus objects don't have a mechanism to allow the conversions.\n+   * The solution is to use a Map<String, Object> to pass in the darkClusters.\n+   */\n+  @Deprecated", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NTg2Ng==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414185866", "bodyText": "I don't think this is a good idea. It'd be confusing since the getter that jackson would use to serialize would have a Map<String, Object> but the constructor would have something different.", "author": "davidhoa", "createdAt": "2020-04-23T23:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0Njc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0ODY1Mw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414148653", "bodyText": "update name", "author": "zhang-chris", "createdAt": "2020-04-23T21:51:50Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/properties/PropertyKeys.java", "diffHunk": "@@ -179,6 +179,8 @@\n   public static final String DARK_CLUSTER_MULTIPLIER = \"multiplier\";\n   public static final String DARK_CLUSTER_OUTBOUND_TARGET_RATE = \"dispatcherOutboundTargetRate\";\n   public static final String DARK_CLUSTER_OUTBOUND_MAX_RATE = \"dispatcherOutboundMaxRate\";\n+  public static final String DARK_CLUSTER_MULTIPLIER_STRATEGY_LIST = \"multiplierStrategyList\";", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MTg2MQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414181861", "bodyText": "updated to DARK_CLUSTER_STRATEGY_LIST = \"darkClusterStrategyList\"", "author": "davidhoa", "createdAt": "2020-04-23T23:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0ODY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDQ0Nw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414150447", "bodyText": "update name", "author": "zhang-chris", "createdAt": "2020-04-23T21:55:23Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MjIxMA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414182210", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-23T23:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDYzNQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414150635", "bodyText": "use public static variable", "author": "zhang-chris", "createdAt": "2020-04-23T21:55:46Z", "path": "d2/src/test/java/com/linkedin/d2/balancer/config/DarkClustersConverterTest.java", "diffHunk": "@@ -111,11 +129,69 @@ public void testEntriesInClusterConfig()\n     expectedConfigMap.put(DARK_CLUSTER_KEY, expectedConfig);\n     DarkClusterConfigMap resultConfigMap = DarkClustersConverter.toConfig(DarkClustersConverter.toProperties(configMap));\n     Assert.assertEquals(resultConfigMap, expectedConfigMap);\n-    // random entries in the map are carried over because of the pass thru nature of dataMaps.\n-    Assert.assertTrue(resultConfigMap.get(DARK_CLUSTER_KEY).data().containsKey(\"blahblah\"));\n     // verify values are converted properly.\n-    Assert.assertEquals(resultConfigMap.get(DARK_CLUSTER_KEY).getMultiplier(),0.0f, \"unexpected multiplier\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n-    Assert.assertEquals((int)resultConfigMap.get(DARK_CLUSTER_KEY).getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    DarkClusterConfig darkClusterConfig = resultConfigMap.get(DARK_CLUSTER_KEY);\n+    Assert.assertEquals(darkClusterConfig.getMultiplier(),0.0f, \"unexpected multiplier\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundTargetRate(), 454, \"unexpected target rate\");\n+    Assert.assertEquals((int)darkClusterConfig.getDispatcherOutboundMaxRate(), 1234566, \"unexpected maxRate\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().size(), 1, \"there should be one strategy\");\n+    Assert.assertEquals(darkClusterConfig.getMultiplierStrategyList().get(0), DarkClusterStrategyName.RELATIVE_TRAFFIC,\n+                        \"expected RELATIVE_TRAFFIC strategy\");\n+    Assert.assertTrue(darkClusterConfig.hasTransportClientProperties());\n+    D2TransportClientProperties returnedTransportClientProperties = darkClusterConfig.getTransportClientProperties();\n+    Assert.assertNotNull(returnedTransportClientProperties);\n+    Assert.assertTrue(returnedTransportClientProperties.hasRequestTimeout());\n+    Assert.assertEquals(Objects.requireNonNull(returnedTransportClientProperties.getRequestTimeout()).longValue(),\n+                        1000, \"expected 1000 request Timeout\");\n+\n+  }\n+\n+  @Test\n+  public void testMultipleStrategies()\n+  {\n+    DarkClusterConfigMap configMap = new DarkClusterConfigMap();\n+    DarkClusterStrategyNameArray multiplierStrategyTypeArray = new DarkClusterStrategyNameArray();\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.RELATIVE_TRAFFIC);\n+    multiplierStrategyTypeArray.add(DarkClusterStrategyName.CONSTANT_QPS);\n+    DarkClusterConfig config = new DarkClusterConfig()\n+      .setMultiplierStrategyList(multiplierStrategyTypeArray);\n+\n+    configMap.put(DARK_CLUSTER_KEY, config);\n+\n+    // these are defaults that will be set if the fields are missing.\n+    config.setMultiplier(0.0f);\n+    config.setDispatcherOutboundTargetRate(0);\n+    config.setDispatcherOutboundMaxRate(Integer.MAX_VALUE);", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MzA1NA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414183054", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-23T23:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MDYzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDc1NA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414154754", "bodyText": "I'm still a fan of exposing an API in DarkClusterStrategy#isValidConfig that the factory can just call into for each strategy type :)\nThat way everything is self-contained in each impl and the factory doesn't need to know these details.", "author": "zhang-chris", "createdAt": "2020-04-23T22:04:17Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NTM4NA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414185384", "bodyText": "sure, I can do this. that gives us the best of both; the factory doesn't need to know these details, and we can optimize for the common codepath at the expense of just one additional call when we create the strategy (instead of at each getOrCreateStrategy)", "author": "davidhoa", "createdAt": "2020-04-23T23:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc4MzQ3Ng==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414783476", "bodyText": "ended up declaring a static method in the RelativeTrafficMultiplierDarkClusterStrategy, because you can't have a static method in the interface that you can override in the impl.", "author": "davidhoa", "createdAt": "2020-04-24T18:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDgyMA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414154820", "bodyText": "update name", "author": "zhang-chris", "createdAt": "2020-04-23T22:04:24Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4MzQ0NA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414183444", "bodyText": "changed to darkClusterStrategyName", "author": "davidhoa", "createdAt": "2020-04-23T23:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NDgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTI3MQ==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414155271", "bodyText": "not necessary since we return no op strategy at end anyway.", "author": "zhang-chris", "createdAt": "2020-04-23T22:05:20Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NDMzNw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414184337", "bodyText": "ok.", "author": "davidhoa", "createdAt": "2020-04-23T23:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTMyOA==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414155328", "bodyText": "can remove comment", "author": "zhang-chris", "createdAt": "2020-04-23T22:05:27Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -109,18 +109,35 @@ public DarkClusterStrategy getOrCreate(@Nonnull String darkClusterName, @Nonnull\n    */\n   private DarkClusterStrategy createStrategy(String darkClusterName, DarkClusterConfig darkClusterConfig)\n   {\n-    if (darkClusterConfig.hasMultiplier() && darkClusterConfig.getMultiplier() > 0)\n+    if (darkClusterConfig.hasMultiplierStrategyList())\n     {\n-      BaseDarkClusterDispatcher baseDarkClusterDispatcher = new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher,\n-                                                                                              _notifier, _verifierManager);\n-      return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n-                                                              baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(), _random);\n-    }\n-    else\n-    {\n-      // Falling into this clause means that the user does not want traffic to be sent to the dark cluster, temporary or otherwise.\n-      return new NoOpDarkClusterStrategy();\n+      DarkClusterStrategyNameArray strategyList = darkClusterConfig.getMultiplierStrategyList();\n+      for (com.linkedin.d2.DarkClusterStrategyName multiplierStrategyType : strategyList)\n+      {\n+        switch(multiplierStrategyType)\n+        {\n+          case RELATIVE_TRAFFIC:\n+            if (darkClusterConfig.getMultiplier() <= 0)\n+            {\n+              // it is a valid case to set RELATIVE_TRAFFIC but set the multiplier to zero to\n+              // temporarily set the traffic to zero; don't log anything.\n+              return new NoOpDarkClusterStrategy();\n+            }\n+            BaseDarkClusterDispatcher baseDarkClusterDispatcher =\n+              new BaseDarkClusterDispatcherImpl(darkClusterName, _darkClusterDispatcher, _notifier, _verifierManager);\n+            return new RelativeTrafficMultiplierDarkClusterStrategy(_sourceClusterName, darkClusterName, darkClusterConfig.getMultiplier(),\n+                                                                    baseDarkClusterDispatcher, _notifier, _facilities.getClusterInfoProvider(),\n+                                                                    _random);\n+          case CONSTANT_QPS:\n+            // the constant qps strategy is not yet implemented, continue to the next strategy if it exists\n+            break;\n+          default:\n+            return new NoOpDarkClusterStrategy();\n+        }\n+      }\n     }\n+    // Reaching here means that the user has not specified a strategy. return the NoOp Strategy.", "originalCommit": "65ab2577596c9527dc65e2eb9ebf1db000ec613a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE4NDI0Mw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r414184243", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-04-23T23:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NTMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgzMzE1Nw==", "url": "https://github.com/linkedin/rest.li/pull/264#discussion_r416833157", "bodyText": "-> strategyNameArray", "author": "zhang-chris", "createdAt": "2020-04-28T18:30:07Z", "path": "d2/src/main/java/com/linkedin/d2/balancer/config/DarkClustersConverter.java", "diffHunk": "@@ -49,36 +50,78 @@\n     }\n     else\n     {\n-      try\n-      {\n-        String json = CODEC.mapToString(config.data());\n-        return JacksonUtil.getObjectMapper().readValue(json, Map.class);\n-      }\n-      catch (IOException e)\n+      Map<String, Object> darkProps = new HashMap<>();\n+      for (Map.Entry<String,DarkClusterConfig> entry : config.entrySet())\n       {\n-        throw new RuntimeException(e);\n+        String darkClusterName = entry.getKey();\n+        DarkClusterConfig darkClusterConfig = entry.getValue();\n+        Map<String, Object> prop = new HashMap<>();\n+        if (darkClusterConfig.hasMultiplier())\n+        {\n+          prop.put(PropertyKeys.DARK_CLUSTER_MULTIPLIER, darkClusterConfig.getMultiplier().toString());\n+        }\n+\n+        if (darkClusterConfig.hasDarkClusterStrategyPrioritizedList())\n+        {\n+          DarkClusterStrategyNameArray myArray = darkClusterConfig.getDarkClusterStrategyPrioritizedList();", "originalCommit": "8c658f260aa0e998def24eb171a69d906bb05382", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f03534c676b6ef8ddd2ab77191461c10061cf3e7", "url": "https://github.com/linkedin/rest.li/commit/f03534c676b6ef8ddd2ab77191461c10061cf3e7", "message": "DarkCluster schema changes to add multiplierStrategyList and transportClientProperties", "committedDate": "2020-04-28T21:09:30Z", "type": "commit"}, {"oid": "fe10402c5f9432af01d11242d53e0c1da8ef0581", "url": "https://github.com/linkedin/rest.li/commit/fe10402c5f9432af01d11242d53e0c1da8ef0581", "message": "rebase and incorporate pdsc->pdl migration", "committedDate": "2020-04-28T21:09:30Z", "type": "commit"}, {"oid": "6c87196224f9d5adf926c2f08cab689ebc59a92c", "url": "https://github.com/linkedin/rest.li/commit/6c87196224f9d5adf926c2f08cab689ebc59a92c", "message": "add multiplierStrategy unit tests.", "committedDate": "2020-04-28T21:09:30Z", "type": "commit"}, {"oid": "8564f6244ae8e56b753b451138f935d21f09516b", "url": "https://github.com/linkedin/rest.li/commit/8564f6244ae8e56b753b451138f935d21f09516b", "message": "address Chris' review comments.", "committedDate": "2020-04-28T21:09:30Z", "type": "commit"}, {"oid": "ba59835537ee2f0a0e14986ea207ecf4a9a74fdb", "url": "https://github.com/linkedin/rest.li/commit/ba59835537ee2f0a0e14986ea207ecf4a9a74fdb", "message": "additional comment changes", "committedDate": "2020-04-28T21:09:30Z", "type": "commit"}, {"oid": "a8b6d7ad9d607241803249f7b29ee3ad5ebef44f", "url": "https://github.com/linkedin/rest.li/commit/a8b6d7ad9d607241803249f7b29ee3ad5ebef44f", "message": "renames", "committedDate": "2020-04-28T21:09:30Z", "type": "commit"}, {"oid": "efd65b511aa66ab276371de33c386b285a1c5327", "url": "https://github.com/linkedin/rest.li/commit/efd65b511aa66ab276371de33c386b285a1c5327", "message": "clean up code.", "committedDate": "2020-04-28T21:09:30Z", "type": "commit"}, {"oid": "b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "url": "https://github.com/linkedin/rest.li/commit/b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "message": "minor naming change", "committedDate": "2020-04-28T21:09:31Z", "type": "commit"}, {"oid": "b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "url": "https://github.com/linkedin/rest.li/commit/b7ed20299115804e0e0ebc9df0bbc592b1fa7a50", "message": "minor naming change", "committedDate": "2020-04-28T21:09:31Z", "type": "forcePushed"}]}