{"pr_number": 335, "pr_title": "Supply default values in restli response if the return data does not have it", "pr_createdAt": "2020-06-20T01:53:41Z", "pr_url": "https://github.com/linkedin/rest.li/pull/335", "timeline": [{"oid": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "url": "https://github.com/linkedin/rest.li/commit/29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-06-22T17:32:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyOTk3NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443829974", "bodyText": "combine these 2 conditions in one statement", "author": "aman1309", "createdAt": "2020-06-22T21:13:58Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,20 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNTQ3OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444415479", "bodyText": "Since I added the else section, it seems to me it is ok to keep it separate?", "author": "BrianPin", "createdAt": "2020-06-23T18:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyOTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443831615", "bodyText": "can you add integration test for this to test based on query param", "author": "aman1309", "createdAt": "2020-06-22T21:17:22Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzNzQ0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444437444", "bodyText": "+1, you can probably just add extra test cases to existing integration tests", "author": "evanw555", "createdAt": "2020-06-23T18:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTExNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447111117", "bodyText": "Integration test is added", "author": "BrianPin", "createdAt": "2020-06-29T16:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMjkzNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443832935", "bodyText": "$sendDefaults, doc was updated to add $ as prefix to not conflict with other fields.\nAlso, can you move it to as constant instead of hard coding here", "author": "aman1309", "createdAt": "2020-06-22T21:20:16Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +117,19 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(\"sendDefaults\") &&", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTI3MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447111270", "bodyText": "this is updated", "author": "BrianPin", "createdAt": "2020-06-29T16:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMjkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443833719", "bodyText": "move this inside if statement if we have fill defaults", "author": "aman1309", "createdAt": "2020-06-22T21:21:55Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +117,19 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MjYzMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444442632", "bodyText": "+1, logic is only necessary when needed", "author": "evanw555", "createdAt": "2020-06-23T19:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUzOTU5Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444539592", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-06-23T22:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNDI5OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443834299", "bodyText": "as discussed update this logic to fill nested defaults if field value is not null", "author": "aman1309", "createdAt": "2020-06-22T21:23:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,20 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)\n+        {\n+          dataMap.put(field.getName(), field.getDefault());", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bb55c5b526dcc244bcbb2463b41d5de338188168", "url": "https://github.com/linkedin/rest.li/commit/bb55c5b526dcc244bcbb2463b41d5de338188168", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-06-22T23:13:34Z", "type": "forcePushed"}, {"oid": "89a6060586011c826a2609468bd2c969f6aa3f35", "url": "https://github.com/linkedin/rest.li/commit/89a6060586011c826a2609468bd2c969f6aa3f35", "message": "Address Aman's comment about recursive resolve default values for record and fix the query key for this feature", "committedDate": "2020-06-23T18:10:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MTMwNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444441305", "bodyText": "I'd suggest renaming this to something like fillInDefaultValues, since get... seems to imply it's a side effect-less get accessor. Also add a javadoc since it's a public method (alternatively consider reducing to private/p-private)", "author": "evanw555", "createdAt": "2020-06-23T18:59:17Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +86,30 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUzNTEyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444535123", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-06-23T22:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MTMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzU0Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444443543", "bodyText": "Consider moving this logic to the ResourceContext interface. This is what I did for ResourceContext#isReturnEntityRequested rather than directly looking at the parameters.", "author": "evanw555", "createdAt": "2020-06-23T19:03:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +123,20 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzM3Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444543372", "bodyText": "Yeah that makes the code consistent, thanks", "author": "BrianPin", "createdAt": "2020-06-23T22:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzY3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444443678", "bodyText": "nit: add newline", "author": "evanw555", "createdAt": "2020-06-23T19:03:36Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444444622", "bodyText": "What's the purpose of this change?", "author": "evanw555", "createdAt": "2020-06-23T19:05:25Z", "path": "restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java", "diffHunk": "@@ -1210,7 +1210,7 @@ public FixedTemplatePlaceholder(Object object, FixedDataSchema schema)\n \n   private static ResourceModel buildPlaceholderResourceModel(ResourceSchema resourceSchema)\n   {\n-    return new ResourceModel(RecordTemplatePlaceholder.class,", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTU2MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444481561", "bodyText": "This is good question, so when I do gradle test, this test class failed because it uses the RecordTemplatePlaceholder and it is not a real template,  on the other hand, in my newly added code, i need to have a fully function resource model instance.\nroutingResult.getResourceMethod().getResourceModel().getValueClass();\n\nIf we keep using the RecordTemplatePlaceholder, we will get an exception.\nThe ResourceModel takes an RecordTemplate as the input, the change from  RecordTemplatePlaceholder  to use resourceSchema seems to be a perfect fit. It is needed to say, I don't know why the original code uses the RecordTemplatePlaceholder rather than the real resourceSchema", "author": "BrianPin", "createdAt": "2020-06-23T20:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTgxMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r445169812", "bodyText": "I don't think this is a good idea. Using a random record type like ResourceSchema is misleading and made me believe that this logic is inherently related to resource schemas. I'd suggest you do one of two things:\n\nBe explicit about using a dummy record by using something like EmptyRecord.\nFix the issue in RecordTemplatePlaceholder, this is an easy fix, since you can just define the schema as new RecordDataSchema(new Name(RecordTemplatePlaceholder.class.getCanonicalName()), RecordDataSchema.RecordType.RECORD).", "author": "evanw555", "createdAt": "2020-06-24T21:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ5ODEyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447498123", "bodyText": "I removed the change, it looks like I no longer need this change anymore. Will notice your suggestion next time when same situation happen", "author": "BrianPin", "createdAt": "2020-06-30T08:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0Njk1Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444446956", "bodyText": "Move to com.linkedin.restli.internal.server.response to be aligned with the location of ResponseUtils", "author": "evanw555", "createdAt": "2020-06-23T19:09:22Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0ODA5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444448097", "bodyText": "Consider renaming this to just be TestResponseUtils to be aligned with the class it's testing.", "author": "evanw555", "createdAt": "2020-06-23T19:11:32Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0ODMzNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444448337", "bodyText": "Consider renaming this to TestGetAbsentFieldsDefaultValues to be aligned with the method it's testing. If you rename that method, rename this test accordingly.", "author": "evanw555", "createdAt": "2020-06-23T19:12:03Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    DataList recordBField1 = new DataList(1);\n+    recordBField1.add(-1);\n+\n+    DataMap recordBField2 = new DataMap();\n+    DataList recordBField2DefaultValues = new DataList(2);\n+    recordBField2DefaultValues.add(\"defaultValue1\");\n+    recordBField2DefaultValues.add(\"defaultValue2\");\n+    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+    DataMap personalRecordD = new DataMap();\n+    personalRecordD.put(\"field3\", 0L);\n+    personalRecordD.put(\"field4\", \"default\");\n+\n+    return new Object[][]{\n+        {\n+            \"RecordA.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .put(\"field3\", 0L)\n+                .put(\"field4\", \"default\")\n+                .build())\n+        },\n+        {\n+            \"RecordB.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", recordBField1)\n+                .put(\"field2\", recordBField2)\n+                .build())\n+        },\n+        {\n+            \"RecordC.pdl\",\n+            new DataMap(),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"name\", \"default+\")\n+                .put(\"personalRecordD\", personalRecordD)\n+                .build()),\n+        }\n+    };\n+  }\n+\n+  @Test(dataProvider = \"default_serialization\")\n+  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444542146", "bodyText": "test this for typerefs", "author": "aman1309", "createdAt": "2020-06-23T22:24:58Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +86,30 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)\n+        {\n+          dataMap.put(field.getName(), field.getDefault());\n+        }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxODkyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444618923", "bodyText": "Got an exception:\njava.lang.ClassCastException: com.linkedin.data.schema.TyperefDataSchema cannot be cast to com.linkedin.data.schema.RecordDataSchema", "author": "BrianPin", "createdAt": "2020-06-24T03:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMTc0OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447131748", "bodyText": "yeah, you might want to use dereferenced schema for typerefs", "author": "aman1309", "createdAt": "2020-06-29T17:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMDAyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447510023", "bodyText": "Resolved this, Aman!", "author": "BrianPin", "createdAt": "2020-06-30T08:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}], "type": "inlineReview"}, {"oid": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "url": "https://github.com/linkedin/rest.li/commit/49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "message": "Address comment: integration test and recursive resolve and typeref test", "committedDate": "2020-06-25T23:26:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NzE0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r446047144", "bodyText": "You need to handle the else part for this.", "author": "karthikbalasub", "createdAt": "2020-06-26T08:35:49Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,51 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        if (!dataMap.containsKey(field.getName()))", "originalCommit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1Mzc0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r446053744", "bodyText": "This is not needed. You need to traverse the nested schemas only if the value is present at the top-level.\nConsider this:\nrecord Foo {\n  f1: int = 5\n  f2: optional int\n }\n\nrecord Bar {\n   b1: Foo = { f2: 10 }\n   b2: optional Foo\n   b3: Foo\n}\n\n\nSo the scenarios are (top-level is Bar):\n1.\n{\n  b1: {\n    f1: 1\n  },\n  b2: {}\n}\n\n\nOutput with defaults filled in should be:\n{\n  b1: {\n    f1: 1\n  },\n   b2: {\n    f1: 5,     // Filled using default value in Foo\n  }\n}\n\n\nb3 is not present in the input data and so shouldn't be filled in.\n\n\n\n{\n  b3: {\n    f2: 1\n  }\n}\n\n\nOutput with defaults filled in should be:\n{\n b1: {.         // Filled because of default value in Bar\n   f1: 5,        // Filled using default value in Foo\n    f2: 10     // Filled using default value in Bar\n  },\n  b3: {\n    f1: 5,     // Filled using default value in Foo\n    f2: 1\n  }\n}\n\n\nBasically, fill in the defaults for fields only if the record is present or record is filled in using a default. Do not create a record only because a nested field specifies default value.", "author": "karthikbalasub", "createdAt": "2020-06-26T08:48:56Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,51 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        if (!dataMap.containsKey(field.getName()))\n+        {\n+          if (field.getDefault() != null)\n+          {\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n+          }", "originalCommit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NTI1MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447875251", "bodyText": "I think this is addressed, had put exact same cases in test", "author": "BrianPin", "createdAt": "2020-06-30T17:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1Mzc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMDg1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447530854", "bodyText": "If you change this to a create with return entity, then you can controll the data being returned (by sending it for create) and thus can test multiple scenarios", "author": "karthikbalasub", "createdAt": "2020-06-30T09:06:38Z", "path": "restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.linkedin.restli.examples.greetings.server.defaults;\n+\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.server.annotations.RestLiCollection;\n+import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n+\n+\n+@RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n+public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long, HighLevelRecordWithDefault>\n+{\n+  @Override\n+  public HighLevelRecordWithDefault get(Long keyId)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NDg1NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447874855", "bodyText": "ok", "author": "BrianPin", "createdAt": "2020-06-30T17:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMDg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTUyMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447531522", "bodyText": "Complete the doc, I think it would be useful to provide the pseudo code you had in the doc.", "author": "karthikbalasub", "createdAt": "2020-06-30T09:07:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTgzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447531831", "bodyText": "Why do you need to copy?", "author": "karthikbalasub", "createdAt": "2020-06-30T09:08:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NDQ2MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447874460", "bodyText": "It is for return, If I don't return a DataMap, then for non existing field that has a default value, I will need to pass in a DataMap for putting data.", "author": "BrianPin", "createdAt": "2020-06-30T17:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzY3MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447533670", "bodyText": "redundant as the containsKey check above ensures the value wouldn't be null", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:01Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDIzOA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447870238", "bodyText": "yes", "author": "BrianPin", "createdAt": "2020-06-30T17:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzg4OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447533889", "bodyText": "redundant as you are updating the field value inplace", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:20Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2OTM2NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447869365", "bodyText": "Just to be sure I get you correctly, I don't get why this is redundant, because as for now it is not in place yet.", "author": "BrianPin", "createdAt": "2020-06-30T17:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDE4Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447534182", "bodyText": "Non reachable code block", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:47Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDEwOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447870109", "bodyText": "agree, will make fix", "author": "BrianPin", "createdAt": "2020-06-30T17:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447535229", "bodyText": "Why duplicate the logic for checking Record/Typeref again? Why not just make a recursive call for each field?", "author": "karthikbalasub", "createdAt": "2020-06-30T09:13:27Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2NTk2Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447865962", "bodyText": "good suggestion -> For each field, make a recursive call for its field schema and data, to make code shorter", "author": "BrianPin", "createdAt": "2020-06-30T17:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MzA5OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r449273098", "bodyText": "I found here it is needed to differentiate the case but I do changed the code for the redundant logic of checking assigned field. but for this part about \"record field and typeref field logic redundancy\" I feel I can not change it because there are some logic necessary, let me know!", "author": "BrianPin", "createdAt": "2020-07-02T21:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTUyNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454615524", "bodyText": "I think you can simplify the logic by reversing the checks.\nFirst check and compute the field value:\nif( dataDefaultFilled.containsKey())\n   Object fieldData = // get data from datamap\nelse if field has default\n  fieldData = // get field default.\nelse\n  // continue (nothing to do).\n\nThen compute the default for the field by calling recursively:\nif fieldData instaceOf DataMap || instance of DataList\n  fieldData = fillInDefaults(fieldData, fieldSchema)\n\ndataDefaultFilled.put(fieldName, fieldData)", "author": "karthikbalasub", "createdAt": "2020-07-14T20:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzOTU4NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447539585", "bodyText": "I'm don't think this would work for batch, finder or action methods. Can you add test coverage for these?\nCheck the restli validator on response method to understand different response structures. I feel it might be easier to add the fill default logic in ResponseBuilders", "author": "karthikbalasub", "createdAt": "2020-06-30T09:20:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -98,6 +189,15 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.isDefaultValueFillInRequested())\n+      {\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          dataMap = fillInDefaultValues(dataSchema, dataMap);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2MzIyOA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447863228", "bodyText": "I saw there is a RestLiValidationFilter which implements Filter interface, it has a onResponse function,\nalso there are multiple **ResponseBuilders where they all share same interface RestLiResponseBuilder\nI don't know how to fit the fill-default in there yet, will dig deeper.", "author": "BrianPin", "createdAt": "2020-06-30T17:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzOTU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MDMxNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447940317", "bodyText": "I'd suggest renaming this to be consistent with the terminology used elsewhere in this PR. String FILL_DEFAULTS_PARAM = \"$fillDefaults\"; or String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\"", "author": "evanw555", "createdAt": "2020-06-30T19:52:13Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java", "diffHunk": "@@ -77,6 +77,7 @@\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MTk5Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447941992", "bodyText": "This is a mouthful. I'd suggest renaming to isFillDefaultsRequested or isFillInDefaultsRequested", "author": "evanw555", "createdAt": "2020-06-30T19:55:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java", "diffHunk": "@@ -220,4 +220,15 @@\n    * @return whether the request specifies that the resource should return an entity\n    */\n   boolean isReturnEntityRequested();\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * This is to determine whether the service will fill in default values when the returned value record has some missing\n+   * field. In case:\n+   * 1. the client is requesting that the default value to be returned. Reads the appropriate\n+   * query parameter to determine this information, defaults to false if the query parameter isn't present.\n+   * 2. the server is configured to return default value for every request-response pair\n+   * @return true if the service need to fill in default value when the field of the return value record is absent\n+   */\n+  boolean isDefaultValueFillInRequested();", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "url": "https://github.com/linkedin/rest.li/commit/bc7fb8498fbed875417ca1926bb6bdc3560c144d", "message": "address Karthiks comment about right place to fill in default, also review the logic of filling defaults", "committedDate": "2020-07-02T21:13:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMTYwNg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454521606", "bodyText": "Suggest changing the param to $fillInDefaults to be consistent", "author": "karthikbalasub", "createdAt": "2020-07-14T17:27:16Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java", "diffHunk": "@@ -77,6 +77,7 @@\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0Mzg5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r457143897", "bodyText": "Yeah, will also need to change design doc", "author": "BrianPin", "createdAt": "2020-07-20T07:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MDQwNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454580405", "bodyText": "nit: remove the extra comma", "author": "karthikbalasub", "createdAt": "2020-07-14T19:07:00Z", "path": "restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.ActionRequest;\n+import com.linkedin.restli.client.BatchFindRequest;\n+import com.linkedin.restli.client.BatchGetEntityRequest;\n+import com.linkedin.restli.client.FindRequest;\n+import com.linkedin.restli.client.GetAllRequest;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.response.BatchKVResponse;\n+import com.linkedin.restli.common.BatchFinderCriteriaResult;\n+import com.linkedin.restli.common.EntityResponse;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  private DataMap expectedTestData;\n+\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init(Collections.emptyList());\n+    expectedTestData = new DataMap();\n+    expectedTestData.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MTE1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454581154", "bodyText": "I suggest you test both scenarios: with fillInDefaults flag and without it.\nYou don't have to do it for all methods, just doing that for GET should be enough. For other methods, test only with fillInDefaults flag.", "author": "karthikbalasub", "createdAt": "2020-07-14T19:08:13Z", "path": "restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.ActionRequest;\n+import com.linkedin.restli.client.BatchFindRequest;\n+import com.linkedin.restli.client.BatchGetEntityRequest;\n+import com.linkedin.restli.client.FindRequest;\n+import com.linkedin.restli.client.GetAllRequest;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.response.BatchKVResponse;\n+import com.linkedin.restli.common.BatchFinderCriteriaResult;\n+import com.linkedin.restli.common.EntityResponse;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  private DataMap expectedTestData;\n+\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init(Collections.emptyList());\n+    expectedTestData = new DataMap();\n+    expectedTestData.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MzYzMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454583633", "bodyText": "remove", "author": "karthikbalasub", "createdAt": "2020-07-14T19:12:49Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5OTY3Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454599677", "bodyText": "Change to a log message (debug/info)", "author": "karthikbalasub", "createdAt": "2020-07-14T19:42:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNDUyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454604525", "bodyText": "This section should be refactored to avoid duplication with the else block", "author": "karthikbalasub", "createdAt": "2020-07-14T19:51:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNTU2NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454605564", "bodyText": "Avoid duplication", "author": "karthikbalasub", "createdAt": "2020-07-14T19:53:12Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java", "diffHunk": "@@ -153,9 +154,22 @@ else if (result.getErrors().containsKey(criteria))\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n-      response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(),\n-                                                         resourceContext.getProjectionMode(),\n-                                                         resourceContext.getProjectionMask())));\n+      if (resourceContext.isFillInDefaultsRequested())\n+      {\n+        DataMap elementData = elements.get(j).data();\n+        RecordDataSchema schema = elements.get(j).schema();\n+        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elementData);\n+        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault,\n+            resourceContext.getProjectionMode(),\n+            resourceContext.getProjectionMask())));", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjgyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454606825", "bodyText": "When you fail to create the value instance, you should return 500 error, not fall back to value without default.", "author": "karthikbalasub", "createdAt": "2020-07-14T19:55:28Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwOTkzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454609931", "bodyText": "Initialize with size computed using DataMapBuilder::getOptimumHashMapCapacityFromSize", "author": "karthikbalasub", "createdAt": "2020-07-14T20:01:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +92,95 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454615927", "bodyText": "You would also need a method to handle DataLists. What if you have a field which is an array of records?", "author": "karthikbalasub", "createdAt": "2020-07-14T20:12:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +92,95 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MDk0NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r456960945", "bodyText": "For fields of array, in the code I assume the following case:\nCase 1 When the schema provide default\ntestFieldArray: array[MidLevelRecordWithDefault] = [{\"intWithDefault\": 0, \"intWithoutDefault\": 0}]\n\nCase 2 When schema does not have default\nIn case 1, I will just use the default provided.\nIn case 2, there will be no defaults filled in.\nI think this is an important case to discuss.\nI think whats the correct way might be: for a field that is an array, if there is no default provided restli provides no value with this field (This statement matches the example I pasted in design doc)\nIf there is default for an array field, I will just use the default.\nI think now the question is, is it just default provided on the schema or the element record all other default values?\nLet me know if this is wrong", "author": "BrianPin", "createdAt": "2020-07-19T22:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMzgyNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458003827", "bodyText": "You should follow the same behavior as complex fields.\n\nif field is not null, fill it with defaults from item's schema recursively.\nif field is null and schema provides default, use the default and fill it with defaults from the item's schema recursively.\nif field is null and not default provided, do nothin.", "author": "karthikbalasub", "createdAt": "2020-07-21T10:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw=="}], "type": "inlineReview"}, {"oid": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "url": "https://github.com/linkedin/rest.li/commit/c18cfcc93ec7698ccead9e1a483956c8160fff02", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-07-20T07:59:08Z", "type": "forcePushed"}, {"oid": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "url": "https://github.com/linkedin/rest.li/commit/20edab3a4a167ffb434e6127da064e312c9dc4e0", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-07-20T17:41:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMTU3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458001578", "bodyText": "Add javadoc", "author": "karthikbalasub", "createdAt": "2020-07-21T10:38:52Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java", "diffHunk": "@@ -552,4 +555,14 @@ public void setValidateResourceKeys(boolean validateResourceKeys)\n     setMethodConfig(\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n+\n+  public boolean shouldFillInDefaultValues()", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMTYyNg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458001626", "bodyText": "Add javadoc", "author": "karthikbalasub", "createdAt": "2020-07-21T10:38:57Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java", "diffHunk": "@@ -552,4 +555,14 @@ public void setValidateResourceKeys(boolean validateResourceKeys)\n     setMethodConfig(\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n+\n+  public boolean shouldFillInDefaultValues()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMjcyMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458002720", "bodyText": "For each case, add a short comment on what it is testing.\nOr even better, include a string in the test data with the context and use that string when tests fail.", "author": "karthikbalasub", "createdAt": "2020-07-21T10:40:59Z", "path": "restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.internal.server.response;\n+\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.util.DataMapUtils;\n+import java.io.File;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestResponseUtils\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    // case 1", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwNTE3Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458005173", "bodyText": "Can you explain when this is needed? I feel this should just return null here.", "author": "karthikbalasub", "createdAt": "2020-07-21T10:46:08Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled;\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e81643c891572982585ede78eb7b5cd20c8aafa", "url": "https://github.com/linkedin/rest.li/commit/9e81643c891572982585ede78eb7b5cd20c8aafa", "message": "Address comment for clarity", "committedDate": "2020-07-22T17:20:51Z", "type": "forcePushed"}, {"oid": "68c81b337a69f7cec5dc68f19a09041ca0785647", "url": "https://github.com/linkedin/rest.li/commit/68c81b337a69f7cec5dc68f19a09041ca0785647", "message": "add union method and re-org test cases", "committedDate": "2020-07-23T23:40:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTc0Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461201742", "bodyText": "move this as javadoc for the method", "author": "aman1309", "createdAt": "2020-07-27T22:16:05Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java", "diffHunk": "@@ -626,6 +630,23 @@ public boolean isReturnEntityRequested()\n     return ArgumentUtils.parseReturnEntityParameter(returnEntityValue);\n   }\n \n+  @Override\n+  public boolean isFillInDefaultsRequested()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  @Override\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)\n+  {\n+    // if a server has a configuration to set the flag to true, it will be set\n+    // through this method, and if the request itself already has the flag set to true\n+    // we will keep the flag remain true even the server config is not set.\n+    // That is => either server config or client request param will be able to\n+    // request fill in default values", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNTU0Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461815543", "bodyText": "done", "author": "BrianPin", "createdAt": "2020-07-28T19:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNTY5MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461205690", "bodyText": "did you look at any other possible position where this can be inserted instead of response builders? and if not how did we ensure all cases are(will remain) covered where the response is being sent out", "author": "aman1309", "createdAt": "2020-07-27T22:26:18Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java", "diffHunk": "@@ -153,8 +154,13 @@ private D buildRestLiResponseData(final Request request,\n         throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n             \"Unexpected null encountered. Null element inside of a List returned by the resource method: \" + routingResult.getResourceMethod());\n       }\n+      DataMap rawData = entry.data();\n+      if (resourceContext.isFillInDefaultsRequested())\n+      {\n+        rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n+      }", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0OTI3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461849278", "bodyText": "The way I find the response builder is by looking up all classes that implements the interface RestLiResponseBuilder so there are only 10 classes, I only need to implement this default filling feature in classes : ActionResponseBuilder BatchFinderResponseBuilder BatchGetResponseBuilder GetResponseBuilder and CollectionResponseBuilder, it covers: Action, Get, GetAll, BatchGet, Finder, BatchFinder methods\nThere are other classes that implements this inferface RestLiResponseBuilder I think they don't need to have this:\nBatchCreateResponseBuilder\nBatchResponseBuilder for  BATCH_UPDATE, BATCH_PARTIAL_UPDATE\nCreateResponseBuilder\nEmptyResponseBuilder\nPartialUpdateResponseBuilder\nLet me know if I miss anything", "author": "BrianPin", "createdAt": "2020-07-28T20:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNjEyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461206125", "bodyText": "switch case?", "author": "aman1309", "createdAt": "2020-07-27T22:27:28Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjQwMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r467322400", "bodyText": "Done", "author": "BrianPin", "createdAt": "2020-08-07T23:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNjEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwOTA1Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461209057", "bodyText": "this condition seems common and can be moved out of data schema switch construct", "author": "aman1309", "createdAt": "2020-07-27T22:35:17Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDUxMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461210512", "bodyText": "fillInDefaultOnXYZ.. can be combined into fillInDefaultValues with switch case. why do we need separate methods for each? and separate switch case constructs?", "author": "aman1309", "createdAt": "2020-07-27T22:39:10Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NDAzMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463554033", "bodyText": "+1, it seems there is a lot of duplication.\nYou'd just need one fillDefaultOnData which takes dataSchema and an Object, does the branching based on schema type.\nIn all other methods, you just have to get the nested schema (eg, field, item or value schema) and call this method again.", "author": "karthikbalasub", "createdAt": "2020-07-31T11:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461212137", "bodyText": "if you are filling in default datamap you shouldn't need to recursively call for record again as all default would be there from schema", "author": "aman1309", "createdAt": "2020-07-27T22:43:37Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzU5Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461233596", "bodyText": "Well, according to Karthik's example, even there is a default for a record, we still need to figure out other field to see if there is a default. Let me know if we need a sync with Karthik", "author": "BrianPin", "createdAt": "2020-07-27T23:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNDc0OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461234749", "bodyText": "oh yeah no need thanks", "author": "aman1309", "createdAt": "2020-07-27T23:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461213493", "bodyText": "this would increase the memory consumption unnecessarily can you optimize for this. why do you need this? you're anyway traversing for list of schema fields. can we not update and return the original datamap?", "author": "aman1309", "createdAt": "2020-07-27T22:47:14Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzAwOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461233009", "bodyText": "Do you mean update and return?", "author": "BrianPin", "createdAt": "2020-07-27T23:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNTI5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461235297", "bodyText": "yup or just update will also be fine", "author": "aman1309", "createdAt": "2020-07-27T23:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzMjMxNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r462032314", "bodyText": "I tried just update without creating new dataMap, in some cases it will return exception because the dataMap is read only.\nI think in this regard we can not just assume we can update the dataMap, we have only one way to make the fill.\nThe exception is like the following:, it is caused by an internal field in DataMap _readOnly, which in the function we can not change it.\nGradle suite > Gradle test > com.linkedin.restli.internal.server.response.TestResponseUtils > testGetAbsentFieldsDefaultValues[4](case5.json) FAILED\n    java.lang.AssertionError: Test failed with exception:\n    java.lang.UnsupportedOperationException: Cannot mutate a read-only map\n        at org.testng.Assert.fail(Assert.java:96)\n        at com.linkedin.restli.internal.server.response.TestResponseUtils.testGetAbsentFieldsDefaultValues(TestResponseUtils.java:84)", "author": "BrianPin", "createdAt": "2020-07-29T04:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNTMzNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463705334", "bodyText": "Ah! you may use DataComplex.clone() for shallow copy instead of manual deep copy.", "author": "aman1309", "createdAt": "2020-07-31T16:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NjExMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463556113", "bodyText": "This is an interesting way to provide inputs. One suggestion here is to name the files in a meaningful way.\neg, basic_case.json, array_map.json", "author": "karthikbalasub", "createdAt": "2020-07-31T11:27:01Z", "path": "restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.internal.server.response;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.util.DataMapUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.util.Collections;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestResponseUtils\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    return new Object[][]{\n+        {\"case1.json\"},\n+        {\"case2.json\"},\n+        {\"case3.json\"},\n+        {\"case4.json\"},\n+        {\"case5.json\"},\n+        {\"case6.json\"},\n+        {\"case7.json\"},\n+        {\"case8.json\"},", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9827904cb299eb93d624530e2435a0e023944999", "url": "https://github.com/linkedin/rest.li/commit/9827904cb299eb93d624530e2435a0e023944999", "message": "Address logic simplification comment and case renaming comment", "committedDate": "2020-08-07T20:44:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NTQ2NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468095464", "bodyText": "initialize size", "author": "karthikbalasub", "createdAt": "2020-08-10T18:25:50Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026799", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-08-12T06:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzgxMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097810", "bodyText": "We should use CheckedUtil::*withoutChecking methods.\nBy default DataMap and DataList check for cycles when a new object is added. However, since we are controling the logic and are not creating cycles, we can skip those checks for performance.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:19Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjc1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026754", "bodyText": "Sure", "author": "BrianPin", "createdAt": "2020-08-12T06:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzg2Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097862", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzkzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097931", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:33Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjY4OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026689", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzk4OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097988", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjY1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026654", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODEyMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468098120", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:57Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    if (dataWithDefault.size() == 1)\n+    {\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        dataWithDefault.put(memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjYyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026623", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTAwMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468099003", "bodyText": "This will check all the entries again.. so better option is to create an empty dataMap and put items inside the loop without checking\n(Similar to how you are handling lists)", "author": "karthikbalasub", "createdAt": "2020-08-10T18:32:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjU5MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026590", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468099785", "bodyText": "Do not initialize the default map with original data. Update it as you iterate the data to fill defaults, use putWithoutchecking", "author": "karthikbalasub", "createdAt": "2020-08-10T18:34:12Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjQ5Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026493", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDc3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468100778", "bodyText": "You don't need this method. Just make fillInDataDefault public and use that.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:36:06Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    if (dataWithDefault.size() == 1)\n+    {\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        dataWithDefault.put(memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjM3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026378", "bodyText": "Method consolidated", "author": "BrianPin", "createdAt": "2020-08-12T06:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDc3OA=="}], "type": "inlineReview"}, {"oid": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "url": "https://github.com/linkedin/rest.li/commit/fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "message": "address performance related comment", "committedDate": "2020-08-12T06:00:04Z", "type": "forcePushed"}, {"oid": "9dd9423bea7d526770ed897fd0be455f4de070cf", "url": "https://github.com/linkedin/rest.li/commit/9dd9423bea7d526770ed897fd0be455f4de070cf", "message": "address performance related comment", "committedDate": "2020-08-12T06:15:00Z", "type": "forcePushed"}, {"oid": "bbc6a802bd24b4fcb42c11eea1dd6f82a652b9dd", "url": "https://github.com/linkedin/rest.li/commit/bbc6a802bd24b4fcb42c11eea1dd6f82a652b9dd", "message": "Update change log", "committedDate": "2020-08-17T16:45:40Z", "type": "forcePushed"}, {"oid": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "url": "https://github.com/linkedin/rest.li/commit/a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "message": "Use dataMap clone instead of putWithoutChecking to reduce performance impact", "committedDate": "2020-08-18T06:29:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5Njc5MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r472396791", "bodyText": "add javadoc here", "author": "aman1309", "createdAt": "2020-08-18T18:26:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,93 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)", "originalCommit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NzQ4Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r472397483", "bodyText": "change scope to private. not required to be exposed outside. same for other methods", "author": "aman1309", "createdAt": "2020-08-18T18:27:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,93 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    try\n+    {\n+      switch (schema.getType())\n+      {\n+        case RECORD:\n+          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case TYPEREF:\n+          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+        case MAP:\n+          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case UNION:\n+          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case ARRAY:\n+          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+        default:\n+          return dataWithoutDefault;\n+      }\n+    }\n+    catch (CloneNotSupportedException ex)\n+    {\n+      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException", "originalCommit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "url": "https://github.com/linkedin/rest.li/commit/409ed62fb17a48648aa502cedf9973ea7b76bb46", "message": "address comment on method scope", "committedDate": "2020-08-21T07:53:44Z", "type": "forcePushed"}, {"oid": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "url": "https://github.com/linkedin/rest.li/commit/307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "url": "https://github.com/linkedin/rest.li/commit/b73b3e314542d4801b66365db7e3367b3fc8fbb1", "message": "Address Aman's comment about recursive resolve default values for record and fix the query key for this feature", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "url": "https://github.com/linkedin/rest.li/commit/9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "message": "Address comment: integration test and recursive resolve and typeref test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "c68a4a87545db83506676ee251b9631b5c18b917", "url": "https://github.com/linkedin/rest.li/commit/c68a4a87545db83506676ee251b9631b5c18b917", "message": "Fix integration test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "4bd6141324db1856d9abee232d5b74cb99ff7365", "url": "https://github.com/linkedin/rest.li/commit/4bd6141324db1856d9abee232d5b74cb99ff7365", "message": "Address Karthiks comment about design", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "8f8eed14e7352cf0964a7881964cf4bfcbdbe88e", "url": "https://github.com/linkedin/rest.li/commit/8f8eed14e7352cf0964a7881964cf4bfcbdbe88e", "message": "fix test failure in TestResourceSchemaCollection", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "3dcb85552f3653b177932480593368e1aa1a835a", "url": "https://github.com/linkedin/rest.li/commit/3dcb85552f3653b177932480593368e1aa1a835a", "message": "address Evan's comment regarding placeholder class in test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "url": "https://github.com/linkedin/rest.li/commit/bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "message": "address Karthiks comment about right place to fill in default, also review the logic of filling defaults", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "url": "https://github.com/linkedin/rest.li/commit/3e82f796f7b91e25261d42a3479f2cfbfc2be202", "message": "address Evan naming comments", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "4047975c79b41cf1457725b38e511ef8e4bfc405", "url": "https://github.com/linkedin/rest.li/commit/4047975c79b41cf1457725b38e511ef8e4bfc405", "message": "Add function mock to address test regressions caused by the new method of resource context", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "url": "https://github.com/linkedin/rest.li/commit/15b992d6f281f0b4dde00e80f157a253d892b1d5", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "url": "https://github.com/linkedin/rest.li/commit/a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "message": "Add server config logic in code", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "b555a312099de17a5117f0cd2e5f048d494830d0", "url": "https://github.com/linkedin/rest.li/commit/b555a312099de17a5117f0cd2e5f048d494830d0", "message": "Address comment for clarity", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "793f6419fdfe8446341a5df1782dc58bff3a6e30", "url": "https://github.com/linkedin/rest.li/commit/793f6419fdfe8446341a5df1782dc58bff3a6e30", "message": "add union method and re-org test cases", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "58e8ea8272b72fc5d4084422122e9be77ebcfa86", "url": "https://github.com/linkedin/rest.li/commit/58e8ea8272b72fc5d4084422122e9be77ebcfa86", "message": "address Aman javadoc comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "ecd3ddcfdc82367b38f81384e25aede4b06a5171", "url": "https://github.com/linkedin/rest.li/commit/ecd3ddcfdc82367b38f81384e25aede4b06a5171", "message": "update changelog.md", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "8f39f3c1023fd79c185e53636c412e3d30947827", "url": "https://github.com/linkedin/rest.li/commit/8f39f3c1023fd79c185e53636c412e3d30947827", "message": "Fix typo", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "08362edd6ff6eadc2ca3c2c41a7bbff24aca00b4", "url": "https://github.com/linkedin/rest.li/commit/08362edd6ff6eadc2ca3c2c41a7bbff24aca00b4", "message": "Address logic simplification comment and case renaming comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "436bab3e63d7c17615c4feccb732259825cc08b5", "url": "https://github.com/linkedin/rest.li/commit/436bab3e63d7c17615c4feccb732259825cc08b5", "message": "address performance related comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "2ead1d477885929de308e25a636119f9fe069b13", "url": "https://github.com/linkedin/rest.li/commit/2ead1d477885929de308e25a636119f9fe069b13", "message": "Update change log", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "9572e80c471f843034f97a31b79ed3bf8c335b22", "url": "https://github.com/linkedin/rest.li/commit/9572e80c471f843034f97a31b79ed3bf8c335b22", "message": "Fix version string", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "e0d533df508a3a213cf4b1909c9100e751792a60", "url": "https://github.com/linkedin/rest.li/commit/e0d533df508a3a213cf4b1909c9100e751792a60", "message": "Use dataMap clone instead of putWithoutChecking to reduce performance impact", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "c2fb120145b0af84c49c14771a7aaf137955bc97", "url": "https://github.com/linkedin/rest.li/commit/c2fb120145b0af84c49c14771a7aaf137955bc97", "message": "address comment on method scope", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "566703eb6c3bfde63d344ce8f2b149e22b0ff1e1", "url": "https://github.com/linkedin/rest.li/commit/566703eb6c3bfde63d344ce8f2b149e22b0ff1e1", "message": "Advance version in change log", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "883b9665a463ea86ff0571d6944024f832977cd8", "url": "https://github.com/linkedin/rest.li/commit/883b9665a463ea86ff0571d6944024f832977cd8", "message": "Update change log", "committedDate": "2020-08-24T07:46:04Z", "type": "commit"}, {"oid": "883b9665a463ea86ff0571d6944024f832977cd8", "url": "https://github.com/linkedin/rest.li/commit/883b9665a463ea86ff0571d6944024f832977cd8", "message": "Update change log", "committedDate": "2020-08-24T07:46:04Z", "type": "forcePushed"}, {"oid": "6c33c62d0ba896a583459a000e1fd088042bb016", "url": "https://github.com/linkedin/rest.li/commit/6c33c62d0ba896a583459a000e1fd088042bb016", "message": "Fix merge error on changelog", "committedDate": "2020-08-24T15:46:11Z", "type": "commit"}]}