{"pr_number": 412, "pr_title": "Cancel request by timeout", "pr_createdAt": "2020-07-31T13:19:42Z", "pr_url": "https://github.com/artipie/artipie/pull/412", "timeline": [{"oid": "17808b9dc1ba80a6c1d9ad9cdc6400218525daa9", "url": "https://github.com/artipie/artipie/commit/17808b9dc1ba80a6c1d9ad9cdc6400218525daa9", "message": "#409 - cancel request by timeout", "committedDate": "2020-07-31T13:16:38Z", "type": "commit"}, {"oid": "6c4ba209f954e2a290086c81549694aba44ca655", "url": "https://github.com/artipie/artipie/commit/6c4ba209f954e2a290086c81549694aba44ca655", "message": "#409 - wrap all slices with timeout slice", "committedDate": "2020-07-31T13:18:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NjY0OQ==", "url": "https://github.com/artipie/artipie/pull/412#discussion_r464266649", "bodyText": "@g4s8 future should complete only after this.origin.accept has been completed, please move future.complete invocation to .thenRun()", "author": "olegmoz", "createdAt": "2020-08-03T08:27:21Z", "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http;\n+\n+import com.artipie.asto.Content;\n+import com.artipie.http.rs.RsStatus;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Slice which cancel requests on timeout.\n+ * <p>\n+ * If response is not sent in fixed time-span,\n+ * this slice will respond with {@code 503} status code.\n+ * </p>\n+ * @since 0.10\n+ */\n+public final class TimeoutSlice implements Slice {\n+\n+    /**\n+     * Origin slice.\n+     */\n+    private final Slice origin;\n+\n+    /**\n+     * Timeout duration.\n+     */\n+    private final Duration duration;\n+\n+    /**\n+     * Executor service.\n+     */\n+    private final ScheduledExecutorService exec;\n+\n+    /**\n+     * Wrpap {@link Slice} implementation.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration) {\n+        this(\n+            origin,\n+            duration,\n+            Executors.newSingleThreadScheduledExecutor(\n+                run -> new Thread(run, TimeoutSlice.class.getSimpleName())\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Wrpap {@link Slice} implementation with specified scheduler.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     * @param exec Scheduler\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration,\n+        final ScheduledExecutorService exec) {\n+        this.origin = origin;\n+        this.duration = duration;\n+        this.exec = exec;\n+    }\n+\n+    @Override\n+    public Response response(final String line, final Iterable<Map.Entry<String, String>> headers,\n+        final Publisher<ByteBuffer> body) {\n+        return new TimeoutResponse(\n+            this.origin.response(line, headers, body), this.duration, this.exec\n+        );\n+    }\n+\n+    /**\n+     * Response with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutResponse implements Response {\n+\n+        /**\n+         * Origin response.\n+         */\n+        private final Response origin;\n+\n+        /**\n+         * Timeout duration.\n+         */\n+        private final Duration duration;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin response\n+         * @param duration Timeout duration\n+         * @param exec Executor service\n+         */\n+        TimeoutResponse(final Response origin, final Duration duration,\n+            final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.duration = duration;\n+            this.exec = exec;\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> send(final Connection connection) {\n+            final TimeoutConnection tcon = new TimeoutConnection(connection, this.exec);\n+            return CompletableFuture.anyOf(\n+                this.origin.send(tcon).toCompletableFuture(),\n+                tcon.timeout(this.duration)\n+            ).thenApply(ignore -> null);\n+        }\n+    }\n+\n+    /**\n+     * Connection with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutConnection implements Connection {\n+\n+        /**\n+         * Origin connection.\n+         */\n+        private final Connection origin;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Completed flag.\n+         */\n+        private final AtomicBoolean completed;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin connection\n+         * @param exec Scheduler\n+         */\n+        TimeoutConnection(final Connection origin, final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.exec = exec;\n+            this.completed = new AtomicBoolean();\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> accept(final RsStatus status, final Headers headers,\n+            final Publisher<ByteBuffer> body) {\n+            final CompletionStage<Void> res;\n+            if (this.completed.compareAndSet(false, true)) {\n+                res = this.origin.accept(status, headers, body);\n+            } else {\n+                res = CompletableFuture.completedFuture(null);\n+            }\n+            return res;\n+        }\n+\n+        /**\n+         * Start timeout task.\n+         * @param duration Timeout duration\n+         * @return Task future\n+         */\n+        CompletableFuture<?> timeout(final Duration duration) {\n+            final CompletableFuture<?> future = new CompletableFuture<>();\n+            this.exec.schedule(\n+                () -> {\n+                    if (this.completed.compareAndSet(false, true)) {\n+                        this.origin.accept(\n+                            RsStatus.UNAVAILABLE, Headers.EMPTY,\n+                            new Content.From(\n+                                \"Request cancelled by timeout\".getBytes(StandardCharsets.UTF_8)\n+                            )\n+                        );\n+                        future.complete(null);", "originalCommit": "6c4ba209f954e2a290086c81549694aba44ca655", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NzIxNw==", "url": "https://github.com/artipie/artipie/pull/412#discussion_r464267217", "bodyText": "@g4s8 I'd suggest to use milliseconds here as it is default precision in Java libraries", "author": "olegmoz", "createdAt": "2020-08-03T08:28:32Z", "path": "src/main/java/com/artipie/http/TimeoutSlice.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * The MIT License (MIT)\n+ *\n+ * Copyright (c) 2020 artipie.com\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http;\n+\n+import com.artipie.asto.Content;\n+import com.artipie.http.rs.RsStatus;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Slice which cancel requests on timeout.\n+ * <p>\n+ * If response is not sent in fixed time-span,\n+ * this slice will respond with {@code 503} status code.\n+ * </p>\n+ * @since 0.10\n+ */\n+public final class TimeoutSlice implements Slice {\n+\n+    /**\n+     * Origin slice.\n+     */\n+    private final Slice origin;\n+\n+    /**\n+     * Timeout duration.\n+     */\n+    private final Duration duration;\n+\n+    /**\n+     * Executor service.\n+     */\n+    private final ScheduledExecutorService exec;\n+\n+    /**\n+     * Wrpap {@link Slice} implementation.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration) {\n+        this(\n+            origin,\n+            duration,\n+            Executors.newSingleThreadScheduledExecutor(\n+                run -> new Thread(run, TimeoutSlice.class.getSimpleName())\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Wrpap {@link Slice} implementation with specified scheduler.\n+     * @param origin Origin slice\n+     * @param duration Timeout duration\n+     * @param exec Scheduler\n+     */\n+    public TimeoutSlice(final Slice origin, final Duration duration,\n+        final ScheduledExecutorService exec) {\n+        this.origin = origin;\n+        this.duration = duration;\n+        this.exec = exec;\n+    }\n+\n+    @Override\n+    public Response response(final String line, final Iterable<Map.Entry<String, String>> headers,\n+        final Publisher<ByteBuffer> body) {\n+        return new TimeoutResponse(\n+            this.origin.response(line, headers, body), this.duration, this.exec\n+        );\n+    }\n+\n+    /**\n+     * Response with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutResponse implements Response {\n+\n+        /**\n+         * Origin response.\n+         */\n+        private final Response origin;\n+\n+        /**\n+         * Timeout duration.\n+         */\n+        private final Duration duration;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin response\n+         * @param duration Timeout duration\n+         * @param exec Executor service\n+         */\n+        TimeoutResponse(final Response origin, final Duration duration,\n+            final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.duration = duration;\n+            this.exec = exec;\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> send(final Connection connection) {\n+            final TimeoutConnection tcon = new TimeoutConnection(connection, this.exec);\n+            return CompletableFuture.anyOf(\n+                this.origin.send(tcon).toCompletableFuture(),\n+                tcon.timeout(this.duration)\n+            ).thenApply(ignore -> null);\n+        }\n+    }\n+\n+    /**\n+     * Connection with timeout support.\n+     * @since 0.10\n+     */\n+    private static final class TimeoutConnection implements Connection {\n+\n+        /**\n+         * Origin connection.\n+         */\n+        private final Connection origin;\n+\n+        /**\n+         * Scheduler.\n+         */\n+        private final ScheduledExecutorService exec;\n+\n+        /**\n+         * Completed flag.\n+         */\n+        private final AtomicBoolean completed;\n+\n+        /**\n+         * Ctor.\n+         * @param origin Origin connection\n+         * @param exec Scheduler\n+         */\n+        TimeoutConnection(final Connection origin, final ScheduledExecutorService exec) {\n+            this.origin = origin;\n+            this.exec = exec;\n+            this.completed = new AtomicBoolean();\n+        }\n+\n+        @Override\n+        public CompletionStage<Void> accept(final RsStatus status, final Headers headers,\n+            final Publisher<ByteBuffer> body) {\n+            final CompletionStage<Void> res;\n+            if (this.completed.compareAndSet(false, true)) {\n+                res = this.origin.accept(status, headers, body);\n+            } else {\n+                res = CompletableFuture.completedFuture(null);\n+            }\n+            return res;\n+        }\n+\n+        /**\n+         * Start timeout task.\n+         * @param duration Timeout duration\n+         * @return Task future\n+         */\n+        CompletableFuture<?> timeout(final Duration duration) {\n+            final CompletableFuture<?> future = new CompletableFuture<>();\n+            this.exec.schedule(\n+                () -> {\n+                    if (this.completed.compareAndSet(false, true)) {\n+                        this.origin.accept(\n+                            RsStatus.UNAVAILABLE, Headers.EMPTY,\n+                            new Content.From(\n+                                \"Request cancelled by timeout\".getBytes(StandardCharsets.UTF_8)\n+                            )\n+                        );\n+                        future.complete(null);\n+                    }\n+                },\n+                duration.getSeconds(), TimeUnit.SECONDS", "originalCommit": "6c4ba209f954e2a290086c81549694aba44ca655", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "79a58b6ead915bbbdee277a7bb757a0d94a8303f", "url": "https://github.com/artipie/artipie/commit/79a58b6ead915bbbdee277a7bb757a0d94a8303f", "message": "#409 - (cr) using millis", "committedDate": "2020-08-04T12:55:35Z", "type": "commit"}, {"oid": "d1b1a7ed03937a3c3e6cac3621d5ffd02d027f2c", "url": "https://github.com/artipie/artipie/commit/d1b1a7ed03937a3c3e6cac3621d5ffd02d027f2c", "message": "Merge branch 'master' into 409", "committedDate": "2020-08-04T12:55:50Z", "type": "commit"}, {"oid": "baa6e3915f75df26820fdcd8b4c9e1420be31283", "url": "https://github.com/artipie/artipie/commit/baa6e3915f75df26820fdcd8b4c9e1420be31283", "message": "Merge branch 'master' into 409", "committedDate": "2020-08-04T13:11:55Z", "type": "commit"}, {"oid": "a7c8c194e4c269c7792700ebb14254d2064d36fc", "url": "https://github.com/artipie/artipie/commit/a7c8c194e4c269c7792700ebb14254d2064d36fc", "message": "Merge branch 'master' into 409", "committedDate": "2020-08-05T13:12:59Z", "type": "commit"}]}