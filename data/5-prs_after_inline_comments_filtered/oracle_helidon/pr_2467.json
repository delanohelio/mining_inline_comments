{"pr_number": 2467, "pr_title": "Micronaut integration", "pr_createdAt": "2020-10-19T15:02:01Z", "pr_url": "https://github.com/oracle/helidon/pull/2467", "timeline": [{"oid": "1033461366e5b9149967a61eb19b14ed8d696847", "url": "https://github.com/oracle/helidon/commit/1033461366e5b9149967a61eb19b14ed8d696847", "message": "Rebase and pom version fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-10-20T09:21:37Z", "type": "forcePushed"}, {"oid": "3bc55e1d8f5145f6fcf97679fe56bfafb64e6593", "url": "https://github.com/oracle/helidon/commit/3bc55e1d8f5145f6fcf97679fe56bfafb64e6593", "message": "Rebase and pom version fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-10-20T09:39:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4NDA5Mw==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510084093", "bodyText": "Does this need to take into account parameterized types?", "author": "graemerocher", "createdAt": "2020-10-22T11:25:53Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/CdiExecutableMethod.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.enterprise.inject.spi.Annotated;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedParameter;\n+\n+import io.micronaut.context.AbstractExecutableMethod;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.DefaultArgument;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.annotation.DefaultAnnotationMetadata;\n+\n+// Executable method used to invoke Micronaut interceptor when we need to merge CDI and Micronaut\n+// annotation metadata, or when we do not have Micronaut annotation metadata\n+@SuppressWarnings(\"rawtypes\")\n+final class CdiExecutableMethod extends AbstractExecutableMethod {\n+    private final AnnotationMetadata annotationMetadata;\n+\n+    private CdiExecutableMethod(AnnotationMetadata methodAnnotationMetadata,\n+                                Class<?> declaringType,\n+                                String methodName,\n+                                Argument<?> genericReturnType,\n+                                Argument... arguments) {\n+        super(declaringType, methodName, genericReturnType, arguments);\n+        this.annotationMetadata = methodAnnotationMetadata;\n+    }\n+\n+    /**\n+     * Create from CDI method and Micronaut executable method.\n+     * Merges together annotations from both worlds.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @param micronautMethod Micronaut executable method\n+     * @return a new combined executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod, ExecutableMethod<?, ?> micronautMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod, micronautMethod.getAnnotationMetadata()),\n+                      arguments(cdiMethod.getParameters(), micronautMethod.getArguments()));\n+    }\n+\n+    /**\n+     * Create from CDI method.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @return Micronaut executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod),\n+                      arguments(cdiMethod.getParameters()));\n+    }\n+\n+    private static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod,\n+                                                 AnnotationMetadata annotationMetadata,\n+                                                 Argument... arguments) {\n+        Class<?> declaringType = cdiMethod.getDeclaringType().getJavaClass();\n+        Argument<?> returnType = Argument.of(cdiMethod.getJavaMember().getReturnType());\n+\n+        return new CdiExecutableMethod(annotationMetadata,\n+                                       declaringType,\n+                                       cdiMethod.getJavaMember().getName(),\n+                                       returnType,\n+                                       arguments);\n+    }\n+\n+    @Override\n+    protected AnnotationMetadata resolveAnnotationMetadata() {\n+        return annotationMetadata;\n+    }\n+\n+    @Override\n+    protected Object invokeInternal(Object instance, Object[] arguments) {\n+        throw new MicronautCdiException(\"invokeInternal should not be called in interceptor\");\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters, Argument[] miParameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter, miParameters[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static Argument<?> toArgument(AnnotatedParameter<?> parameter, Argument argument) {\n+        Parameter javaParameter = parameter.getJavaParameter();\n+        return new DefaultArgument(javaParameter.getType(),\n+                                   javaParameter.getName(),\n+                                   annotationMetadata(parameter, argument.getAnnotationMetadata()));", "originalCommit": "e306d7bd3114abf57856621d196869c60c8f357b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4ODkzNg==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510088936", "bodyText": "I think you can probably create the io.micronaut.context.Qualifier[] in the same loop with Qualifiers.byAnnotation(annotationMetadata, qualifiers.get(i))", "author": "graemerocher", "createdAt": "2020-10-22T11:34:55Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private final List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        synthesized[i] = annotationMetadata.synthesize(qualifiers.get(i));", "originalCommit": "e306d7bd3114abf57856621d196869c60c8f357b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MDEwOQ==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510090109", "bodyText": "Minor, but this would preform better with parallelStream() and then collect() then adding all the beans to beanDefinitions", "author": "graemerocher", "createdAt": "2020-10-22T11:37:04Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private final List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        synthesized[i] = annotationMetadata.synthesize(qualifiers.get(i));\n+                    }\n+\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        if (synthesized[i] != null) {\n+                            mq[i] = Qualifiers.byAnnotation(synthesized[i]);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        list.stream()", "originalCommit": "e306d7bd3114abf57856621d196869c60c8f357b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MjQxNw==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510092417", "bodyText": "Would probably try cache all of this lookup logic in getInterceptionMetadata otherwise it probably adds quite some overhead to invocation", "author": "graemerocher", "createdAt": "2020-10-22T11:41:25Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautInterceptor.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.core.annotation.Internal;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * A CDI interceptor that invokes all Micronaut interceptors.\n+ * DO NOT USE DIRECTLY. Usage is computed by this CDI extension.\n+ */\n+// interceptor binding is defined in code of extension, not on annotation\n+@MicronautIntercepted\n+@Interceptor\n+@Priority(Interceptor.Priority.LIBRARY_BEFORE)\n+@Internal\n+public class MicronautInterceptor {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautInterceptor.class.getName());\n+\n+    private final ApplicationContext context;\n+    private final MicronautCdiExtension extension;\n+\n+    @Inject\n+    MicronautInterceptor(ApplicationContext context, MicronautCdiExtension extension) {\n+        this.context = context;\n+        this.extension = extension;\n+    }\n+\n+    /**\n+     * Interceptor method that call Micronaut interceptors for a CDI bean.\n+     *\n+     * @param cdiCtx invocation context\n+     * @return response of the method\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @AroundInvoke\n+    public Object invoke(InvocationContext cdiCtx) {\n+\n+        Method javaMethod = cdiCtx.getMethod();\n+        MethodInterceptorMetadata meta = extension.getInterceptionMetadata(javaMethod);\n+\n+        Set<Class<? extends MethodInterceptor<?, ?>>> interceptorClasses = meta.interceptors();\n+        Set<MethodInterceptor<?, ?>> interceptors = new TreeSet<>(Comparator.comparingInt(MethodInterceptor::getOrder));\n+\n+        for (Class<? extends MethodInterceptor> aClass : interceptorClasses) {\n+            interceptors.add(context.findBean(aClass)\n+                                     .orElseThrow(() -> new MicronautCdiException(\"Cannot create bean class for interceptor \"\n+                                                                                          + aClass.getName())));\n+        }\n+\n+        ExecutableMethod<?, ?> executableMethod = meta.executableMethod();\n+        Iterator<MethodInterceptor<?, ?>> remaining = interceptors.iterator();", "originalCommit": "e306d7bd3114abf57856621d196869c60c8f357b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIxMDU1Nw==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510210557", "bodyText": "I do not think so - I need to lookup the interceptor instance for each invocation, as it may not be a Singleton. In case it is Prototype, a new instance is needed.\nEverything else is cached in MethodInterceptorMetadata", "author": "tomas-langer", "createdAt": "2020-10-22T14:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MjQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MzA0NA==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510093044", "bodyText": "In Micronaut core we construct the attributes and mutable arguments lazily since they may not be used which reduces overhead", "author": "graemerocher", "createdAt": "2020-10-22T11:42:33Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautMethodInvocationContext.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.Interceptor;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.convert.value.MutableConvertibleMultiValuesMap;\n+import io.micronaut.core.convert.value.MutableConvertibleValues;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.ArgumentValue;\n+import io.micronaut.core.type.MutableArgumentValue;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * Invocation context for Micronaut interceptors.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+class MicronautMethodInvocationContext implements MethodInvocationContext {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautMethodInvocationContext.class.getName());\n+\n+    private final InvocationContext cdiContext;\n+    private final ExecutableMethod executableMethod;\n+    private final Set<MethodInterceptor<?, ?>> allInterceptors;\n+    private final MutableConvertibleValues attributes;\n+    private final Map<String, MutableArgumentValue<?>> mutableArguments;\n+\n+    private Iterator<MethodInterceptor<?, ?>> remaining;\n+\n+    private MicronautMethodInvocationContext(InvocationContext cdiContext,\n+                                             ExecutableMethod executableMethod,\n+                                             Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                             Iterator<MethodInterceptor<?, ?>> remaining) {\n+        this.cdiContext = cdiContext;\n+        this.executableMethod = executableMethod;\n+        this.allInterceptors = allInterceptors;\n+        this.remaining = remaining;\n+\n+        this.attributes = new MutableConvertibleMultiValuesMap();\n+        this.mutableArguments = new LinkedHashMap<>();\n+        Object[] parameters = cdiContext.getParameters();\n+        Argument[] argumentNames = executableMethod.getArguments();\n+\n+        for (int i = 0; i < argumentNames.length; i++) {\n+            Argument argument = argumentNames[i];\n+            Object parameterValue = parameters[i];\n+            mutableArguments.put(argument.getName(),\n+                                 new MutableArgument<Object>(argument, parameterValue));\n+        }", "originalCommit": "e306d7bd3114abf57856621d196869c60c8f357b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5NDQzOQ==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510094439", "bodyText": "Again in Micronaut core we tend to have an implementation whereby MutableArgumentValue.setValue(..) will set the value into the Object[] to avoid this copying", "author": "graemerocher", "createdAt": "2020-10-22T11:44:59Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautMethodInvocationContext.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.Interceptor;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.convert.value.MutableConvertibleMultiValuesMap;\n+import io.micronaut.core.convert.value.MutableConvertibleValues;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.ArgumentValue;\n+import io.micronaut.core.type.MutableArgumentValue;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * Invocation context for Micronaut interceptors.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+class MicronautMethodInvocationContext implements MethodInvocationContext {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautMethodInvocationContext.class.getName());\n+\n+    private final InvocationContext cdiContext;\n+    private final ExecutableMethod executableMethod;\n+    private final Set<MethodInterceptor<?, ?>> allInterceptors;\n+    private final MutableConvertibleValues attributes;\n+    private final Map<String, MutableArgumentValue<?>> mutableArguments;\n+\n+    private Iterator<MethodInterceptor<?, ?>> remaining;\n+\n+    private MicronautMethodInvocationContext(InvocationContext cdiContext,\n+                                             ExecutableMethod executableMethod,\n+                                             Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                             Iterator<MethodInterceptor<?, ?>> remaining) {\n+        this.cdiContext = cdiContext;\n+        this.executableMethod = executableMethod;\n+        this.allInterceptors = allInterceptors;\n+        this.remaining = remaining;\n+\n+        this.attributes = new MutableConvertibleMultiValuesMap();\n+        this.mutableArguments = new LinkedHashMap<>();\n+        Object[] parameters = cdiContext.getParameters();\n+        Argument[] argumentNames = executableMethod.getArguments();\n+\n+        for (int i = 0; i < argumentNames.length; i++) {\n+            Argument argument = argumentNames[i];\n+            Object parameterValue = parameters[i];\n+            mutableArguments.put(argument.getName(),\n+                                 new MutableArgument<Object>(argument, parameterValue));\n+        }\n+    }\n+\n+    static MethodInvocationContext create(InvocationContext cdiCtx,\n+                                          ExecutableMethod<?, ?> executableMethod,\n+                                          Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                          Iterator<MethodInterceptor<?, ?>> remaining) {\n+        return new MicronautMethodInvocationContext(cdiCtx,\n+                                                    executableMethod,\n+                                                    allInterceptors,\n+                                                    remaining);\n+    }\n+\n+    @Override\n+    public ExecutableMethod getExecutableMethod() {\n+        return executableMethod;\n+    }\n+\n+    @Override\n+    public Map<String, MutableArgumentValue<?>> getParameters() {\n+        return mutableArguments;\n+    }\n+\n+    @Override\n+    public Object getTarget() {\n+        return cdiContext.getTarget();\n+    }\n+\n+    @Override\n+    public Object proceed() throws RuntimeException {\n+        if (remaining.hasNext()) {\n+            MethodInterceptor<?, ?> next = remaining.next();\n+            LOGGER.finest(() -> \"Micronaut interceptor: \" + next.getClass().getName());\n+            return next.intercept(this);\n+        }\n+        try {\n+            Object[] arguments = mutableArguments.values()\n+                    .stream()\n+                    .map(ArgumentValue::getValue)\n+                    .toArray(Object[]::new);", "originalCommit": "e306d7bd3114abf57856621d196869c60c8f357b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "02a423c18cee7eca3c800f596998d36b31ccdaf4", "url": "https://github.com/oracle/helidon/commit/02a423c18cee7eca3c800f596998d36b31ccdaf4", "message": "Review fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-09T15:54:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MDQxOA==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r523050418", "bodyText": ".flatMap(Arrays::stream) may save few instructions", "author": "danielkec", "createdAt": "2020-11-13T16:10:40Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        List<MicronautBean> beans = list.parallelStream()\n+                .filter(ServiceDefinition::isPresent)\n+                .map(ServiceDefinition::load)\n+                .filter(BeanDefinitionReference::isPresent)\n+                .map(ref -> {\n+                    Class<?> beanType = ref.getBeanType();\n+\n+                    String className = ref.getBeanType().getName();\n+                    if (className.endsWith(\"$Intercepted\")) {\n+                        // either superclass is the one we want, or first implemented interface\n+                        if (Object.class.equals(beanType.getSuperclass())) {\n+                            Class<?>[] interfaces = beanType.getInterfaces();\n+                            if (interfaces.length > 0) {\n+                                beanType = interfaces[0];\n+                            }\n+                        } else {\n+                            beanType = beanType.getSuperclass();\n+                        }\n+                    }\n+\n+                    return new MicronautBean(beanType, ref);\n+                })\n+                .collect(Collectors.toList());\n+\n+        // using my own collection, so the field is final\n+        beanDefinitions.addAll(beans);\n+\n+        for (MicronautBean defRef : beanDefinitions) {\n+            mBeanToDefRef.computeIfAbsent(defRef.beanType(), it -> new LinkedList<>())\n+                    .add(defRef);\n+        }\n+\n+        unprocessedBeans.putAll(mBeanToDefRef);\n+    }\n+\n+    /**\n+     * Find Micronaut interceptor annotations and locate interceptor classes to be used.\n+     *\n+     * @param interceptors set of interceptors to add new interceptors to\n+     * @param annotations set of annotations on the processed element\n+     */\n+    private void addMicronautInterceptors(Set<Class<?>> interceptors, Set<Annotation> annotations) {\n+        annotations.stream()\n+                .map(Annotation::annotationType)\n+                .filter(type -> type.getAnnotation(Around.class) != null)\n+                .map(type -> type.getAnnotation(Type.class))\n+                .map(Type::value)\n+                .map(Set::of)\n+                .flatMap(Set::stream)", "originalCommit": "02a423c18cee7eca3c800f596998d36b31ccdaf4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MTIxNQ==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r523051215", "bodyText": "or .flatMap(Stream::of) \ud83d\ude42", "author": "danielkec", "createdAt": "2020-11-13T16:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk4NjI3Mg==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526986272", "bodyText": "argumentNames[0].getName() seems weird, var name arguments would sound better", "author": "danielkec", "createdAt": "2020-11-19T15:40:24Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautMethodInvocationContext.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.interceptor.InvocationContext;\n+\n+import io.helidon.common.LazyValue;\n+\n+import io.micronaut.aop.Interceptor;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.convert.value.MutableConvertibleMultiValuesMap;\n+import io.micronaut.core.convert.value.MutableConvertibleValues;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.ArgumentValue;\n+import io.micronaut.core.type.MutableArgumentValue;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * Invocation context for Micronaut interceptors.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+class MicronautMethodInvocationContext implements MethodInvocationContext {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautMethodInvocationContext.class.getName());\n+\n+    private final InvocationContext cdiContext;\n+    private final ExecutableMethod executableMethod;\n+    private final Set<MethodInterceptor<?, ?>> allInterceptors;\n+    private final LazyValue<MutableConvertibleMultiValuesMap> attributes;\n+    private final LazyValue<Map<String, MutableArgumentValue<?>>> mutableArguments;\n+\n+    private Iterator<MethodInterceptor<?, ?>> remaining;\n+\n+    private MicronautMethodInvocationContext(InvocationContext cdiContext,\n+                                             ExecutableMethod executableMethod,\n+                                             Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                             Iterator<MethodInterceptor<?, ?>> remaining) {\n+        this.cdiContext = cdiContext;\n+        this.executableMethod = executableMethod;\n+        this.allInterceptors = allInterceptors;\n+        this.remaining = remaining;\n+\n+        this.attributes = LazyValue.create(MutableConvertibleMultiValuesMap::new);\n+        this.mutableArguments = LazyValue.create(() -> {\n+            Map<String, MutableArgumentValue<?>> args = new LinkedHashMap<>();\n+            Object[] parameters = cdiContext.getParameters();\n+            Argument[] argumentNames = executableMethod.getArguments();", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5MjEyMA==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526992120", "bodyText": "Is it possible that no interceptor classes are found and NPE is thrown?", "author": "danielkec", "createdAt": "2020-11-19T15:47:44Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautInterceptor.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.core.annotation.Internal;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * A CDI interceptor that invokes all Micronaut interceptors.\n+ * DO NOT USE DIRECTLY. Usage is computed by this CDI extension.\n+ */\n+// interceptor binding is defined in code of extension, not on annotation\n+@MicronautIntercepted\n+@Interceptor\n+@Priority(Interceptor.Priority.LIBRARY_BEFORE)\n+@Internal\n+public class MicronautInterceptor {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautInterceptor.class.getName());\n+\n+    private final ApplicationContext context;\n+    private final MicronautCdiExtension extension;\n+\n+    @Inject\n+    MicronautInterceptor(ApplicationContext context, MicronautCdiExtension extension) {\n+        this.context = context;\n+        this.extension = extension;\n+    }\n+\n+    /**\n+     * Interceptor method that call Micronaut interceptors for a CDI bean.\n+     *\n+     * @param cdiCtx invocation context\n+     * @return response of the method\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @AroundInvoke\n+    public Object invoke(InvocationContext cdiCtx) {\n+\n+        Method javaMethod = cdiCtx.getMethod();\n+        MethodInterceptorMetadata meta = extension.getInterceptionMetadata(javaMethod);\n+\n+        Set<Class<? extends MethodInterceptor<?, ?>>> interceptorClasses = meta.interceptors();\n+        Set<MethodInterceptor<?, ?>> interceptors = new TreeSet<>(Comparator.comparingInt(MethodInterceptor::getOrder));\n+\n+        for (Class<? extends MethodInterceptor> aClass : interceptorClasses) {\n+            // we need to find the bean for each invocation, as this may be a prototype bean\n+            interceptors.add(context.findBean(aClass)\n+                                     .orElseThrow(() -> new MicronautCdiException(\"Cannot create bean class for interceptor \"\n+                                                                                          + aClass.getName())));\n+        }\n+\n+        ExecutableMethod<?, ?> executableMethod = meta.executableMethod();\n+        Iterator<MethodInterceptor<?, ?>> remaining = interceptors.iterator();\n+        io.micronaut.aop.MethodInvocationContext context = MicronautMethodInvocationContext\n+                .create(cdiCtx, executableMethod, interceptors, remaining);\n+\n+        MethodInterceptor<?, ?> next = remaining.next();", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY2MTE5NQ==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527661195", "bodyText": "As we are in an invocation of the MicronautInterceptor, there was at least one interceptor found that triggered this class to be added to the interceptors of CDI. So no, this should not happen, there is always at least one interceptor.", "author": "tomas-langer", "createdAt": "2020-11-20T12:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5MjEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5NDk0Nw==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526994947", "bodyText": "Not needed anymore? \ud83d\udc7b", "author": "danielkec", "createdAt": "2020-11-19T15:51:17Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        List<MicronautBean> beans = list.parallelStream()\n+                .filter(ServiceDefinition::isPresent)\n+                .map(ServiceDefinition::load)\n+                .filter(BeanDefinitionReference::isPresent)\n+                .map(ref -> {\n+                    Class<?> beanType = ref.getBeanType();\n+\n+                    String className = ref.getBeanType().getName();\n+                    if (className.endsWith(\"$Intercepted\")) {\n+                        // either superclass is the one we want, or first implemented interface\n+                        if (Object.class.equals(beanType.getSuperclass())) {\n+                            Class<?>[] interfaces = beanType.getInterfaces();\n+                            if (interfaces.length > 0) {\n+                                beanType = interfaces[0];\n+                            }\n+                        } else {\n+                            beanType = beanType.getSuperclass();\n+                        }\n+                    }\n+\n+                    return new MicronautBean(beanType, ref);\n+                })\n+                .collect(Collectors.toList());\n+\n+        // using my own collection, so the field is final\n+        beanDefinitions.addAll(beans);\n+\n+        for (MicronautBean defRef : beanDefinitions) {\n+            mBeanToDefRef.computeIfAbsent(defRef.beanType(), it -> new LinkedList<>())\n+                    .add(defRef);\n+        }\n+\n+        unprocessedBeans.putAll(mBeanToDefRef);\n+    }\n+\n+    /**\n+     * Find Micronaut interceptor annotations and locate interceptor classes to be used.\n+     *\n+     * @param interceptors set of interceptors to add new interceptors to\n+     * @param annotations set of annotations on the processed element\n+     */\n+    private void addMicronautInterceptors(Set<Class<?>> interceptors, Set<Annotation> annotations) {\n+        annotations.stream()\n+                .map(Annotation::annotationType)\n+                .filter(type -> type.getAnnotation(Around.class) != null)\n+                .map(type -> type.getAnnotation(Type.class))\n+                .map(Type::value)\n+                .map(Set::of)\n+                .flatMap(Set::stream)\n+                .forEach(interceptors::add);\n+    }\n+\n+    private void findMicronautInterceptors(Set<Class<?>> classInterceptors,\n+                                           Map<Method, Set<Class<?>>> allMethodInterceptors,\n+                                           BeanDefinitionReference<?> miBean) {\n+        // find all annotations with Around stereotype and find its Type annotation to add interceptors\n+        miBean.getAnnotationMetadata()\n+                .getAnnotationTypesByStereotype(Around.class)\n+                .stream()\n+                .map(it -> it.getAnnotation(Type.class))\n+                .filter(Objects::nonNull)\n+                .map(Type::value)\n+                .flatMap(Stream::of)\n+                .forEach(classInterceptors::add);\n+\n+        BeanDefinition<?> beanDef = miBean.load();\n+\n+        Collection<? extends ExecutableMethod<?, ?>> executableMethods = beanDef.getExecutableMethods();\n+        for (ExecutableMethod<?, ?> executableMethod : executableMethods) {\n+            Set<Class<?>> methodInterceptors = new HashSet<>();\n+\n+            executableMethod\n+                    .getAnnotationTypesByStereotype(Around.class)\n+                    .stream()\n+                    .map(it -> it.getAnnotation(Type.class))\n+                    .filter(Objects::nonNull)\n+                    .map(Type::value)\n+                    .flatMap(Stream::of)\n+                    .forEach(methodInterceptors::add);\n+\n+            this.executableMethodCache.putIfAbsent(executableMethod.getTargetMethod(), executableMethod);\n+\n+            allMethodInterceptors.computeIfAbsent(executableMethod.getTargetMethod(), it -> new HashSet<>())\n+                    .addAll(methodInterceptors);\n+        }\n+    }\n+\n+    private BeanDefinitionReference<?> findMicronautBeanDefinition(List<MicronautBean> mBeans) {\n+        for (MicronautBean mBean : mBeans) {\n+            BeanDefinitionReference<?> ref = mBean.definitionRef();\n+            //            if (ref instanceof AdvisedBeanType) {\n+            //                continue;\n+            //            }", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1MjAwOA==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527152008", "bodyText": "Actually not yet available in the current Micronaut release", "author": "tomas-langer", "createdAt": "2020-11-19T19:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5NDk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5OTgxOA==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526999818", "bodyText": "Could be little prettier\nfindMicronautBeanDefinition(miBeans)\n    .ifPresent(miBean -> findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean))", "author": "danielkec", "createdAt": "2020-11-19T15:57:13Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzY2MjEyNA==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527662124", "bodyText": "Your code is not doing the same thing as my code.", "author": "tomas-langer", "createdAt": "2020-11-20T12:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5OTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwOTkxMA==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527009910", "bodyText": "Code duplication alert with line 362-368", "author": "danielkec", "createdAt": "2020-11-19T16:10:07Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        List<MicronautBean> beans = list.parallelStream()\n+                .filter(ServiceDefinition::isPresent)\n+                .map(ServiceDefinition::load)\n+                .filter(BeanDefinitionReference::isPresent)\n+                .map(ref -> {\n+                    Class<?> beanType = ref.getBeanType();\n+\n+                    String className = ref.getBeanType().getName();\n+                    if (className.endsWith(\"$Intercepted\")) {\n+                        // either superclass is the one we want, or first implemented interface\n+                        if (Object.class.equals(beanType.getSuperclass())) {\n+                            Class<?>[] interfaces = beanType.getInterfaces();\n+                            if (interfaces.length > 0) {\n+                                beanType = interfaces[0];\n+                            }\n+                        } else {\n+                            beanType = beanType.getSuperclass();\n+                        }\n+                    }\n+\n+                    return new MicronautBean(beanType, ref);\n+                })\n+                .collect(Collectors.toList());\n+\n+        // using my own collection, so the field is final\n+        beanDefinitions.addAll(beans);\n+\n+        for (MicronautBean defRef : beanDefinitions) {\n+            mBeanToDefRef.computeIfAbsent(defRef.beanType(), it -> new LinkedList<>())\n+                    .add(defRef);\n+        }\n+\n+        unprocessedBeans.putAll(mBeanToDefRef);\n+    }\n+\n+    /**\n+     * Find Micronaut interceptor annotations and locate interceptor classes to be used.\n+     *\n+     * @param interceptors set of interceptors to add new interceptors to\n+     * @param annotations set of annotations on the processed element\n+     */\n+    private void addMicronautInterceptors(Set<Class<?>> interceptors, Set<Annotation> annotations) {\n+        annotations.stream()\n+                .map(Annotation::annotationType)\n+                .filter(type -> type.getAnnotation(Around.class) != null)\n+                .map(type -> type.getAnnotation(Type.class))\n+                .map(Type::value)\n+                .map(Set::of)\n+                .flatMap(Set::stream)\n+                .forEach(interceptors::add);\n+    }\n+\n+    private void findMicronautInterceptors(Set<Class<?>> classInterceptors,\n+                                           Map<Method, Set<Class<?>>> allMethodInterceptors,\n+                                           BeanDefinitionReference<?> miBean) {\n+        // find all annotations with Around stereotype and find its Type annotation to add interceptors\n+        miBean.getAnnotationMetadata()\n+                .getAnnotationTypesByStereotype(Around.class)\n+                .stream()\n+                .map(it -> it.getAnnotation(Type.class))\n+                .filter(Objects::nonNull)\n+                .map(Type::value)\n+                .flatMap(Stream::of)\n+                .forEach(classInterceptors::add);\n+\n+        BeanDefinition<?> beanDef = miBean.load();\n+\n+        Collection<? extends ExecutableMethod<?, ?>> executableMethods = beanDef.getExecutableMethods();\n+        for (ExecutableMethod<?, ?> executableMethod : executableMethods) {\n+            Set<Class<?>> methodInterceptors = new HashSet<>();\n+\n+            executableMethod\n+                    .getAnnotationTypesByStereotype(Around.class)\n+                    .stream()\n+                    .map(it -> it.getAnnotation(Type.class))\n+                    .filter(Objects::nonNull)\n+                    .map(Type::value)\n+                    .flatMap(Stream::of)\n+                    .forEach(methodInterceptors::add);", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxODcxMg==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527018712", "bodyText": "Bean id prefix used 4 times would deserve a constant", "author": "danielkec", "createdAt": "2020-11-19T16:21:56Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMzE1Nw==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527023157", "bodyText": "adn", "author": "danielkec", "createdAt": "2020-11-19T16:27:46Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3Nzg5NQ==", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527077895", "bodyText": "teh", "author": "danielkec", "createdAt": "2020-11-19T17:43:04Z", "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/CdiExecutableMethod.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.enterprise.inject.spi.Annotated;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedParameter;\n+\n+import io.micronaut.context.AbstractExecutableMethod;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.DefaultArgument;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.annotation.DefaultAnnotationMetadata;\n+\n+// Executable method used to invoke Micronaut interceptor when we need to merge CDI and Micronaut\n+// annotation metadata, or when we do not have Micronaut annotation metadata\n+@SuppressWarnings(\"rawtypes\")\n+final class CdiExecutableMethod extends AbstractExecutableMethod {\n+    private final AnnotationMetadata annotationMetadata;\n+\n+    private CdiExecutableMethod(AnnotationMetadata methodAnnotationMetadata,\n+                                Class<?> declaringType,\n+                                String methodName,\n+                                Argument<?> genericReturnType,\n+                                Argument... arguments) {\n+        super(declaringType, methodName, genericReturnType, arguments);\n+        this.annotationMetadata = methodAnnotationMetadata;\n+    }\n+\n+    /**\n+     * Create from CDI method and Micronaut executable method.\n+     * Merges together annotations from both worlds.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @param micronautMethod Micronaut executable method\n+     * @return a new combined executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod, ExecutableMethod<?, ?> micronautMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod, micronautMethod.getAnnotationMetadata()),\n+                      arguments(cdiMethod.getParameters(), micronautMethod.getArguments()));\n+    }\n+\n+    /**\n+     * Create from CDI method.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @return Micronaut executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod),\n+                      arguments(cdiMethod.getParameters()));\n+    }\n+\n+    private static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod,\n+                                                 AnnotationMetadata annotationMetadata,\n+                                                 Argument... arguments) {\n+        Class<?> declaringType = cdiMethod.getDeclaringType().getJavaClass();\n+        Argument<?> returnType = Argument.of(cdiMethod.getJavaMember().getReturnType());\n+\n+        return new CdiExecutableMethod(annotationMetadata,\n+                                       declaringType,\n+                                       cdiMethod.getJavaMember().getName(),\n+                                       returnType,\n+                                       arguments);\n+    }\n+\n+    @Override\n+    protected AnnotationMetadata resolveAnnotationMetadata() {\n+        return annotationMetadata;\n+    }\n+\n+    @Override\n+    protected Object invokeInternal(Object instance, Object[] arguments) {\n+        throw new MicronautCdiException(\"invokeInternal should not be called in interceptor\");\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters, Argument[] miParameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter, miParameters[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static Argument<?> toArgument(AnnotatedParameter<?> parameter, Argument argument) {\n+        Parameter javaParameter = parameter.getJavaParameter();\n+        return new DefaultArgument(javaParameter.getParameterizedType(),\n+                                   javaParameter.getName(),\n+                                   annotationMetadata(parameter, argument.getAnnotationMetadata()));\n+    }\n+\n+    private static Argument<?> toArgument(AnnotatedParameter<?> parameter) {\n+        Parameter javaParameter = parameter.getJavaParameter();\n+        return new DefaultArgument(javaParameter.getType(),\n+                                   javaParameter.getName(),\n+                                   annotationMetadata(parameter));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static AnnotationMetadata annotationMetadata(Annotated annotated, AnnotationMetadata miAnnotated) {\n+        Map<Class<? extends Annotation>, Annotation> annotations = new HashMap<>();\n+        Set<String> miAnnotationNames = miAnnotated.getAnnotationNames();\n+        // add micronaut annotations\n+        for (String miAnnotationName : miAnnotationNames) {\n+            try {\n+                Annotation annotation = miAnnotated.synthesize((Class<? extends Annotation>) Class.forName(miAnnotationName));\n+                annotations.put(annotation.annotationType(), annotation);\n+            } catch (Throwable ignored) {\n+                // this annotation is not on the classpath, we can ignore it\n+            }\n+        }\n+\n+        // then overwrite with CDI annotations (more significant for us)\n+        annotated.getAnnotations()\n+                .forEach(it -> annotations.put(it.annotationType(), it));\n+\n+        return annotationMetadata(annotations);\n+    }\n+\n+    private static AnnotationMetadata annotationMetadata(Annotated annotated) {\n+        Map<Class<? extends Annotation>, Annotation> annotations = new HashMap<>();\n+        annotated.getAnnotations()\n+                .forEach(it -> annotations.put(it.annotationType(), it));\n+\n+        return annotationMetadata(annotations);\n+    }\n+\n+    private static AnnotationMetadata annotationMetadata(Map<Class<? extends Annotation>, Annotation> annotations) {\n+        Map<Class<? extends Annotation>, Annotation> stereotypes = new HashMap<>();\n+        Map<String, Set<String>> byStereotype = new HashMap<>();\n+        Map<String, Map<CharSequence, Object>> miAnnotations = new HashMap<>();\n+\n+        processAnnotations(annotations,\n+                           miAnnotations,\n+                           stereotypes,\n+                           byStereotype);\n+\n+        Map<String, Map<CharSequence, Object>> miStereotypes = new HashMap<>();\n+        for (var entry : stereotypes.entrySet()) {\n+            miStereotypes.put(entry.getKey().getName(), annotationValues(entry.getValue()));\n+        }\n+\n+        Map<String, List<String>> byStereotypeWithList = new HashMap<>();\n+        byStereotype\n+                .forEach((stereotype, set) -> byStereotypeWithList.put(stereotype, new ArrayList<>(set)));\n+\n+        return new DefaultAnnotationMetadata(miAnnotations,\n+                                             miStereotypes,\n+                                             miStereotypes,\n+                                             miAnnotations,\n+                                             byStereotypeWithList);\n+    }\n+\n+    private static void processAnnotations(Map<Class<? extends Annotation>, Annotation> declaredAnnotations,\n+                                           Map<String, Map<CharSequence, Object>> miAnnotations,\n+                                           Map<Class<? extends Annotation>, Annotation> stereotypeMap,\n+                                           Map<String, Set<String>> annotationsByStereotype) {\n+        for (var entry : declaredAnnotations.entrySet()) {\n+            if (stereotypeMap.containsKey(Repeatable.class)) {\n+                // I need to ignore this (used only when there is just one repetition)\n+                // this gets processed as part of teh Repeatable container", "originalCommit": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "260a855b0045b7df255a10facb3fcfecac78bb77", "url": "https://github.com/oracle/helidon/commit/260a855b0045b7df255a10facb3fcfecac78bb77", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:00Z", "type": "commit"}, {"oid": "9d7465cc5c662bee734ba3c461bd8a81029980fe", "url": "https://github.com/oracle/helidon/commit/9d7465cc5c662bee734ba3c461bd8a81029980fe", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:00Z", "type": "commit"}, {"oid": "3d39f339a398d8c9c22b658cd34e9bfa5a42cb30", "url": "https://github.com/oracle/helidon/commit/3d39f339a398d8c9c22b658cd34e9bfa5a42cb30", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:00Z", "type": "commit"}, {"oid": "14e2888f23f0577066934c0b0e1d120ea2a05e53", "url": "https://github.com/oracle/helidon/commit/14e2888f23f0577066934c0b0e1d120ea2a05e53", "message": "Using snapshot for fixed feature\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:00Z", "type": "commit"}, {"oid": "3a41570984973b4463db92bd1af9a49d6ae55081", "url": "https://github.com/oracle/helidon/commit/3a41570984973b4463db92bd1af9a49d6ae55081", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "b9e1e99765177c6aac742c238d102130f821893f", "url": "https://github.com/oracle/helidon/commit/b9e1e99765177c6aac742c238d102130f821893f", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "43bfcf2e6bf134c8f07369621dd6bcfe3cc5cbd4", "url": "https://github.com/oracle/helidon/commit/43bfcf2e6bf134c8f07369621dd6bcfe3cc5cbd4", "message": "Squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "5a1e21ec7f0d41632de1670e7bb60715d047eac7", "url": "https://github.com/oracle/helidon/commit/5a1e21ec7f0d41632de1670e7bb60715d047eac7", "message": "Micronaut integration, with Micronaut Data support.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "a22ac3e81abc1d3882d428b33416aea9779d02f0", "url": "https://github.com/oracle/helidon/commit/a22ac3e81abc1d3882d428b33416aea9779d02f0", "message": "Checkstyle fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "5fa440f3fa68d1241db235adb2985ad33f42c98e", "url": "https://github.com/oracle/helidon/commit/5fa440f3fa68d1241db235adb2985ad33f42c98e", "message": "Rebase and pom version fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "8ec2689fbd2db9cf880b54f1b15e380bd031ea40", "url": "https://github.com/oracle/helidon/commit/8ec2689fbd2db9cf880b54f1b15e380bd031ea40", "message": "- module info\n- native image support\n- test for example\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "f64311997abeb0257103dceb02963c3f7f3db21e", "url": "https://github.com/oracle/helidon/commit/f64311997abeb0257103dceb02963c3f7f3db21e", "message": "Fix javadoc issue.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "77594cb1cfc14322b1868e967a95bf57105ec3bc", "url": "https://github.com/oracle/helidon/commit/77594cb1cfc14322b1868e967a95bf57105ec3bc", "message": "Using the correct Micronaut scope for Dependent.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "36f650a9f402514e72719c0b2691ef0581d50d10", "url": "https://github.com/oracle/helidon/commit/36f650a9f402514e72719c0b2691ef0581d50d10", "message": "Support for parameterized types\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "a2422b68d4bb523c5b5ae4da6ef6527fbe28d223", "url": "https://github.com/oracle/helidon/commit/a2422b68d4bb523c5b5ae4da6ef6527fbe28d223", "message": "Review fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "ef91e01b1d3a7fd860b7c98f9302f2ff9a592af1", "url": "https://github.com/oracle/helidon/commit/ef91e01b1d3a7fd860b7c98f9302f2ff9a592af1", "message": "Review comment fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T12:46:01Z", "type": "commit"}, {"oid": "f40e241615e95da81bade0e22da7252362b2f12e", "url": "https://github.com/oracle/helidon/commit/f40e241615e95da81bade0e22da7252362b2f12e", "message": "Upgrade to latest Micronaut release.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T13:59:35Z", "type": "commit"}, {"oid": "f40e241615e95da81bade0e22da7252362b2f12e", "url": "https://github.com/oracle/helidon/commit/f40e241615e95da81bade0e22da7252362b2f12e", "message": "Upgrade to latest Micronaut release.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-20T13:59:35Z", "type": "forcePushed"}, {"oid": "4ecda43ea559eba0c59685c575f990abd1bd7b71", "url": "https://github.com/oracle/helidon/commit/4ecda43ea559eba0c59685c575f990abd1bd7b71", "message": "Merge branch 'master' into 2386-micronaut-integration", "committedDate": "2020-11-25T11:18:11Z", "type": "commit"}]}