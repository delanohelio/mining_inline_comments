{"pr_number": 1787, "pr_title": "Multipart", "pr_createdAt": "2020-05-14T02:56:44Z", "pr_url": "https://github.com/oracle/helidon/pull/1787", "timeline": [{"oid": "e321495aed549792c76b976d592c5db900ede458", "url": "https://github.com/oracle/helidon/commit/e321495aed549792c76b976d592c5db900ede458", "message": "Multipart (#2)\n\nInitial implementation of multipart media support.", "committedDate": "2020-05-13T00:24:57Z", "type": "commit"}, {"oid": "c354d736e5c76ed6284f5d957edc36ab96e7e5f8", "url": "https://github.com/oracle/helidon/commit/c354d736e5c76ed6284f5d957edc36ab96e7e5f8", "message": "Update multipart example", "committedDate": "2020-05-13T02:24:39Z", "type": "commit"}, {"oid": "aaf944b6e13e15c4b6349ac619e9958856bc0486", "url": "https://github.com/oracle/helidon/commit/aaf944b6e13e15c4b6349ac619e9958856bc0486", "message": "update BodyPartTest to get rid of UncompletablePublisher", "committedDate": "2020-05-13T02:25:10Z", "type": "commit"}, {"oid": "6ef0f9771abcf28337e9e764cef389a9c1ec9e03", "url": "https://github.com/oracle/helidon/commit/6ef0f9771abcf28337e9e764cef389a9c1ec9e03", "message": "fix signature of MutliPart.fields", "committedDate": "2020-05-13T02:29:22Z", "type": "commit"}, {"oid": "ee33bb2719bdab8457543820fc8bb122cdf3e7d3", "url": "https://github.com/oracle/helidon/commit/ee33bb2719bdab8457543820fc8bb122cdf3e7d3", "message": "fix imports in MultiPartEncoderTest", "committedDate": "2020-05-13T02:29:37Z", "type": "commit"}, {"oid": "7c2902ecfdfe7cae3612fcc4b8be01c975695e62", "url": "https://github.com/oracle/helidon/commit/7c2902ecfdfe7cae3612fcc4b8be01c975695e62", "message": "fix buffering", "committedDate": "2020-05-14T02:39:49Z", "type": "commit"}, {"oid": "07bc03937780992459c7238ec40298c47371a1d5", "url": "https://github.com/oracle/helidon/commit/07bc03937780992459c7238ec40298c47371a1d5", "message": "Update multipart example to be a mini file upload webapp", "committedDate": "2020-05-14T02:50:52Z", "type": "commit"}, {"oid": "dbcbb81891f3b926ce45717adf8be21439b37535", "url": "https://github.com/oracle/helidon/commit/dbcbb81891f3b926ce45717adf8be21439b37535", "message": "fix checkstyle", "committedDate": "2020-05-14T03:16:15Z", "type": "commit"}, {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "url": "https://github.com/oracle/helidon/commit/1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "message": "fix checkstyle", "committedDate": "2020-05-14T05:22:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NzY1Mg==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425057652", "bodyText": "We have nice tooling for that, no need to misuse OriginThreadPublisher here\nMultiPartDecoder_not_extending_OTPub.patch.txt", "author": "danielkec", "createdAt": "2020-05-14T11:13:02Z", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartDecoder.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyReadableContent;\n+import io.helidon.media.common.MessageBodyReaderContext;\n+\n+/**\n+ * Reactive processor that decodes HTTP payload as a stream of {@link BodyPart}.\n+ * This processor is a single use publisher that supports a single subscriber,\n+ * it is not resumable.\n+ */\n+public final class MultiPartDecoder implements Processor<DataChunk, ReadableBodyPart> {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    /**\n+     * Indicate that the chunks subscription is complete.\n+     */\n+    private boolean complete;\n+\n+    /**\n+     * The upstream subscription.\n+     */\n+    private Subscription chunksSubscription;\n+\n+    /**\n+     * The builder for the current {@link BodyPart}.\n+     */\n+    private ReadableBodyPart.Builder bodyPartBuilder;\n+\n+    /**\n+     * The builder for the current {@link ReadableBodyPartHeaders}.\n+     */\n+    private ReadableBodyPartHeaders.Builder bodyPartHeaderBuilder;\n+\n+    /**\n+     * The publisher for the current part.\n+     */\n+    private BodyPartContentPublisher contentPublisher;\n+\n+    /**\n+     * The parent chunk for the published body part chunks.\n+     */\n+    private BodyPartChunk.Parent chunkParent;\n+\n+    /**\n+     * The MIME parser.\n+     */\n+    private final MIMEParser parser;\n+\n+    /**\n+     * The parser event processor.\n+     */\n+    private final ParserEventProcessor parserEventProcessor;\n+\n+    /**\n+     * The bodyParts processed during each {@code onNext}.\n+     */\n+    private final Queue<ReadableBodyPart> bodyParts;\n+\n+    /**\n+     * The reader context.\n+     */\n+    private final MessageBodyReaderContext context;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final BodyPartPublisher downstream;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param boundary mime message boundary\n+     * @param context reader context\n+     */\n+    private MultiPartDecoder(String boundary, MessageBodyReaderContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        parserEventProcessor = new ParserEventProcessor();\n+        parser = new MIMEParser(boundary, parserEventProcessor);\n+        downstream = new BodyPartPublisher();", "originalCommit": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1NzAzMQ==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425257031", "bodyText": "I wrote most of this code prior to all of the new Multi stuff ; which is why it is using OTP. I'll take a look at your patch.", "author": "romain-grecourt", "createdAt": "2020-05-14T16:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMTUzNg==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r426111536", "bodyText": "Looking at your diff, there seems to be a part that's missing. Let's schedule something next week to go over your suggestions.", "author": "romain-grecourt", "createdAt": "2020-05-16T03:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NzY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDA1OA==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425060058", "bodyText": "We definitely need Multi.just(...).via(Flow.Processor).subscribe(Flow.Subscriber) like MPRS have", "author": "danielkec", "createdAt": "2020-05-14T11:17:31Z", "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testNoClosingBoundary(){\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Type: text/xml; charset=UTF-8\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"<foo>bar</foo>\\n\").getBytes();\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, null);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getClass(), is(equalTo(MIMEParser.ParsingException.class)));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"No closing MIME boundary\")));\n+    }\n+\n+    @Test\n+    public void testCanceledPartSubscription() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                part.content().subscribe(new Subscriber<DataChunk>() {\n+                    Subscription subscription;\n+\n+                    @Override\n+                    public void onSubscribe(Subscription subscription) {\n+                        this.subscription = subscription;\n+                        subscription.request(Long.MAX_VALUE);\n+                    }\n+\n+                    @Override\n+                    public void onNext(DataChunk item) {\n+                        latch.countDown();\n+                        subscription.cancel();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable throwable) {\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                    }\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"This is the 2nd body.\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testPartContentSubscriberThrottling() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(3);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 2) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            }\n+            part.content().subscribe(new Subscriber<DataChunk>() {\n+\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    subscription.request(1);\n+                }\n+\n+                @Override\n+                public void onNext(DataChunk item) {\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                }\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatchNegative(latch, \"the 2nd part should not be processed\");\n+        assertThat(latch.getCount(), is(equalTo(1L)));\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testUpstreamError() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        new Publisher<DataChunk>(){\n+            @Override\n+            public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+                subscriber.onError(new IllegalStateException(\"oops\"));\n+            }\n+        }.subscribe(decoder);\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, null);\n+        decoder.subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"oops\")));\n+    }\n+\n+    @Test\n+    public void testSubcribingMoreThanOnce() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(\"foo\".getBytes()).subscribe(decoder);\n+        try {\n+            chunksPublisher(\"bar\".getBytes()).subscribe(decoder);\n+            fail(\"exception should be thrown\");\n+        } catch(IllegalStateException ex) {\n+            assertThat(ex.getMessage(), is(equalTo(\"Input subscription already set\")));\n+        }\n+    }\n+\n+    /**\n+     * Types of test subscribers.\n+     */\n+    enum SUBSCRIBER_TYPE {\n+        INFINITE,\n+        ONE_BY_ONE,\n+        CANCEL_AFTER_ONE,\n+    }\n+\n+    /**\n+     * A part test subscriber.\n+     */\n+    static class BodyPartSubscriber implements Subscriber<BodyPart>{\n+\n+        private final SUBSCRIBER_TYPE subscriberType;\n+        private final Consumer<BodyPart> consumer;\n+        private Subscription subcription;\n+        private Throwable error;\n+        private boolean complete;\n+\n+        BodyPartSubscriber(SUBSCRIBER_TYPE subscriberType, Consumer<BodyPart> consumer) {\n+            this.subscriberType = subscriberType;\n+            this.consumer = consumer;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subcription = subscription;\n+            if (subscriberType == SUBSCRIBER_TYPE.INFINITE) {\n+                subscription.request(Long.MAX_VALUE);\n+            } else {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(BodyPart item) {\n+            if (consumer == null){\n+                return;\n+            }\n+            consumer.accept(item);\n+            if (subscriberType == SUBSCRIBER_TYPE.ONE_BY_ONE) {\n+                subcription.request(1);\n+            } else if (subscriberType == SUBSCRIBER_TYPE.CANCEL_AFTER_ONE) {\n+                subcription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable ex) {\n+            error = ex;\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            complete = true;\n+        }\n+    }\n+\n+    /**\n+     * Create the parts publisher for the specified boundary and request\n+     * chunks.\n+     * @param boundary multipart boundary string\n+     * @param chunks request chunks\n+     * @return publisher of body parts\n+     */\n+    static Publisher<? extends BodyPart> partsPublisher(String boundary, byte[]... chunks) {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(boundary, MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(chunks).subscribe(decoder);", "originalCommit": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2ODAyMQ==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425268021", "bodyText": "Yes, this would simplify using processors.", "author": "romain-grecourt", "createdAt": "2020-05-14T16:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MTkwMg==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425061902", "bodyText": "Its not required by spec, is there business reason for this check?", "author": "danielkec", "createdAt": "2020-05-14T11:21:05Z", "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));", "originalCommit": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2NzIxMg==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425267212", "bodyText": "Probably not, I wasn't looking at making these spec compliant at the time. Thanks for pointing this out, I will remove these.", "author": "romain-grecourt", "createdAt": "2020-05-14T16:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MTkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMDgzNg==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r426110836", "bodyText": "This test is doing a cancel after receiving the first item ; the assertions tests none of onError() and onComplete() were called.\nDo you mean that it is legal for a subscriber to received either of these signals after the subscription has been canceled ?\nThe code that implements onError and onComplete checks for canceled subscription, that's the only reason for these 2 assertions.", "author": "romain-grecourt", "createdAt": "2020-05-16T02:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzNzQyNg==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425137426", "bodyText": "Decoder looks basically as a flatmap, I may be wrong but it should be possible to leave all the queuing in decoder to flatMap operator and simplify it considerably, so if this works:\n        Multi.from(chunksPublisher(chunk1))\n                .flatMap(chunk -> {\n                    var decoder = MultiPartDecoder.create(boundary, MEDIA_CONTEXT.readerContext());\n                    Single.just(chunk).subscribe(decoder);\n                    return decoder;\n                }).subscribe(testSubscriber);\nSomething like this should be possible:\n        var parser = new MIMEParser(boundary){\n            List<ReadableBodyPart> parse(DataChunk chunk){\n                ...\n            }\n        };\n        Multi.from(chunksPublisher(chunk1))\n                .flatMapIterable(parser::parse)\n                }).subscribe(testSubscriber);", "author": "danielkec", "createdAt": "2020-05-14T13:30:26Z", "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);", "originalCommit": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwMTc3Mw==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425201773", "bodyText": "Sorry I got Decoder/Encoder vertigo, I meant Encoder, to look like re-implemented flatmap:\n    private static String encodeParts(String boundary, WriteableBodyPart... parts) throws Exception {\n        Multi<DataChunk> pub = Multi.just(parts)\n                .flatMap(part -> {\n                    var enc = MultiPartEncoder.create(boundary, MEDIA_CONTEXT.writerContext());\n                    Single.just(part).subscribe(enc);\n                    return enc;\n                });\n        return ContentReaders.readString(pub, StandardCharsets.UTF_8).get(10, TimeUnit.SECONDS);\n    }", "author": "danielkec", "createdAt": "2020-05-14T14:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzNzQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMDM0NA==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425220344", "bodyText": "required_spec213_blackbox_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull\nrequired_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal", "author": "danielkec", "createdAt": "2020-05-14T15:20:19Z", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyWriterContext;\n+\n+/**\n+ * Reactive processor that encodes a stream of {@link BodyPart} into an HTTP\n+ * payload. This processor is a single use publisher that supports a single\n+ * subscriber, it is not resumable.\n+ */\n+public final class MultiPartEncoder implements Processor<WriteableBodyPart, DataChunk> {\n+\n+    private Subscription partsSubscription;\n+    private BodyPartContentSubscriber contentSubscriber;\n+\n+    /**\n+     * The writer context.\n+     */\n+    private final MessageBodyWriterContext context;\n+\n+    /**\n+     * The boundary used for the generated multi-part message.\n+     */\n+    private final String boundary;\n+\n+    /**\n+     * Complete flag.\n+     */\n+    private volatile boolean complete;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final MultiPartChunksPublisher downstream;\n+\n+    /**\n+     * Create a new multipart encoder.\n+     * @param boundary boundary string\n+     * @param context writer context\n+     */\n+    private MultiPartEncoder(String boundary, MessageBodyWriterContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        this.boundary = boundary;\n+        this.downstream = new MultiPartChunksPublisher();\n+        this.complete = false;\n+    }\n+\n+    /**\n+     * Create a new encoder instance.\n+     * @param boundary multipart boundary delimiter\n+     * @param context writer context\n+     * @return MultiPartEncoder\n+     */\n+    public static MultiPartEncoder create(String boundary, MessageBodyWriterContext context) {\n+        return new MultiPartEncoder(boundary, context);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+        downstream.subscribe(subscriber);\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        if (partsSubscription != null) {\n+            throw new IllegalStateException(\"Input subscription already set\");\n+        }\n+        partsSubscription = subscription;\n+    }", "originalCommit": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzMjEwOA==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425232108", "bodyText": "required_spec213_blackbox_onError_mustThrowNullPointerExceptionWhenParametersAreNull", "author": "danielkec", "createdAt": "2020-05-14T15:35:28Z", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyWriterContext;\n+\n+/**\n+ * Reactive processor that encodes a stream of {@link BodyPart} into an HTTP\n+ * payload. This processor is a single use publisher that supports a single\n+ * subscriber, it is not resumable.\n+ */\n+public final class MultiPartEncoder implements Processor<WriteableBodyPart, DataChunk> {\n+\n+    private Subscription partsSubscription;\n+    private BodyPartContentSubscriber contentSubscriber;\n+\n+    /**\n+     * The writer context.\n+     */\n+    private final MessageBodyWriterContext context;\n+\n+    /**\n+     * The boundary used for the generated multi-part message.\n+     */\n+    private final String boundary;\n+\n+    /**\n+     * Complete flag.\n+     */\n+    private volatile boolean complete;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final MultiPartChunksPublisher downstream;\n+\n+    /**\n+     * Create a new multipart encoder.\n+     * @param boundary boundary string\n+     * @param context writer context\n+     */\n+    private MultiPartEncoder(String boundary, MessageBodyWriterContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        this.boundary = boundary;\n+        this.downstream = new MultiPartChunksPublisher();\n+        this.complete = false;\n+    }\n+\n+    /**\n+     * Create a new encoder instance.\n+     * @param boundary multipart boundary delimiter\n+     * @param context writer context\n+     * @return MultiPartEncoder\n+     */\n+    public static MultiPartEncoder create(String boundary, MessageBodyWriterContext context) {\n+        return new MultiPartEncoder(boundary, context);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+        downstream.subscribe(subscriber);\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        if (partsSubscription != null) {\n+            throw new IllegalStateException(\"Input subscription already set\");\n+        }\n+        partsSubscription = subscription;\n+    }\n+\n+    @Override\n+    public void onNext(WriteableBodyPart bodyPart) {\n+        Map<String, List<String>> headers = bodyPart.headers().toMap();\n+        StringBuilder sb = new StringBuilder();\n+\n+        // start boundary\n+        sb.append(\"--\").append(boundary).append(\"\\r\\n\");\n+\n+        // headers lines\n+        for (Map.Entry<String, List<String>> headerEntry : headers.entrySet()) {\n+\n+            String headerName = headerEntry.getKey();\n+            for (String headerValue : headerEntry.getValue()) {\n+                sb.append(headerName)\n+                        .append(\":\")\n+                        .append(headerValue)\n+                        .append(\"\\r\\n\");\n+            }\n+        }\n+\n+        // end of headers empty line\n+        sb.append(\"\\r\\n\");\n+        downstream.submit(sb.toString());\n+        contentSubscriber = new BodyPartContentSubscriber();\n+        bodyPart.content()\n+                .toPublisher(context)\n+                .subscribe(contentSubscriber);\n+    }\n+\n+    @Override\n+    public void onError(Throwable error) {\n+        downstream.error(error);\n+    }", "originalCommit": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MjI5Mg==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425962292", "bodyText": "Can you please rename to MimeParser? We adopt this in our APIs - even for cases when the original abbreviation is all capitals (such as MpConfig).", "author": "tomas-langer", "createdAt": "2020-05-15T18:00:01Z", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MIMEParser.java", "diffHunk": "@@ -0,0 +1,953 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Parser for multipart MIME message.\n+ */\n+final class MIMEParser {", "originalCommit": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzNjQ2Ng==", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r428436466", "bodyText": "Fixed.", "author": "romain-grecourt", "createdAt": "2020-05-21T04:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MjI5Mg=="}], "type": "inlineReview"}, {"oid": "7f1d0a55ce1269619a3beb64906530266c9a7911", "url": "https://github.com/oracle/helidon/commit/7f1d0a55ce1269619a3beb64906530266c9a7911", "message": "Polish FileService, remove silly wrap methods\nRework body part release\nOptimize VirtualBuffer.getByte(int), use arrays instead of LinkedList\n\nrename MIMEParser to MimeParser\n\nuse SubscriptionHelper\n\nfix use of Optional\n\nreset all fields in VirtualBuffer.clear\n\nFix unit tests", "committedDate": "2020-05-16T03:21:59Z", "type": "commit"}, {"oid": "f1e9607e9c521b59861059ab576389dbeaef41ec", "url": "https://github.com/oracle/helidon/commit/f1e9607e9c521b59861059ab576389dbeaef41ec", "message": "fix checkstyle errors", "committedDate": "2020-05-16T03:38:21Z", "type": "commit"}, {"oid": "4471a5fc8b2943cd737f2cd0abcf38175069d906", "url": "https://github.com/oracle/helidon/commit/4471a5fc8b2943cd737f2cd0abcf38175069d906", "message": "Rename MIMEParserTest to MimeParserTest", "committedDate": "2020-05-16T04:04:17Z", "type": "commit"}, {"oid": "293612c040551111d5f95d94694791fef9f7c32f", "url": "https://github.com/oracle/helidon/commit/293612c040551111d5f95d94694791fef9f7c32f", "message": "Merge remote-tracking branch 'origin/master' into multipart", "committedDate": "2020-05-18T18:25:42Z", "type": "commit"}, {"oid": "5dedfc9df13f1f51e9b13d8ece7d3f53903e956b", "url": "https://github.com/oracle/helidon/commit/5dedfc9df13f1f51e9b13d8ece7d3f53903e956b", "message": "Encoder with emitter (#3)\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-19T00:07:24Z", "type": "commit"}, {"oid": "6bc1b4f8f4b50321eca5075e034576a7f376964f", "url": "https://github.com/oracle/helidon/commit/6bc1b4f8f4b50321eca5075e034576a7f376964f", "message": "Update multipart reactive code to get rid of OriginThreadPublisher and use EmittingPublisher instead.", "committedDate": "2020-05-19T18:58:26Z", "type": "commit"}, {"oid": "d77b9f54cbde461935a0093071b284c6a84c9671", "url": "https://github.com/oracle/helidon/commit/d77b9f54cbde461935a0093071b284c6a84c9671", "message": "BufferedEmittingPublisher as replacement for OriginThreadPublisher\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-19T19:30:04Z", "type": "commit"}, {"oid": "6ea60c7a0b2e11e949e89ccd9bae51b57f3e7be1", "url": "https://github.com/oracle/helidon/commit/6ea60c7a0b2e11e949e89ccd9bae51b57f3e7be1", "message": "Merge branch 'multipart' of github.com:romain-grecourt/helidon into multipart", "committedDate": "2020-05-20T02:00:28Z", "type": "commit"}, {"oid": "881fff3382e410ef80a3ad5a689ff811244f93dd", "url": "https://github.com/oracle/helidon/commit/881fff3382e410ef80a3ad5a689ff811244f93dd", "message": "fix checkstyle and update style", "committedDate": "2020-05-20T02:15:33Z", "type": "commit"}, {"oid": "8876724810d8ed78679eb431b62027917d53a161", "url": "https://github.com/oracle/helidon/commit/8876724810d8ed78679eb431b62027917d53a161", "message": "add newline at the end of file", "committedDate": "2020-05-20T02:33:15Z", "type": "commit"}, {"oid": "bed4825c9bc61839264064a76cfb626b21b913ce", "url": "https://github.com/oracle/helidon/commit/bed4825c9bc61839264064a76cfb626b21b913ce", "message": "Cleanup\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T09:45:24Z", "type": "commit"}, {"oid": "49c2177dc8d367276dbe0d21e9c99b4e597a1567", "url": "https://github.com/oracle/helidon/commit/49c2177dc8d367276dbe0d21e9c99b4e597a1567", "message": "Align with OTP use-cases\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T11:21:33Z", "type": "commit"}, {"oid": "035083a9d295ed912535270ef5a925089cb409cb", "url": "https://github.com/oracle/helidon/commit/035083a9d295ed912535270ef5a925089cb409cb", "message": "Switch webclient to new OTP replacement\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T11:27:53Z", "type": "commit"}, {"oid": "a298a01fbef2b850852b86e218c6785c67207814", "url": "https://github.com/oracle/helidon/commit/a298a01fbef2b850852b86e218c6785c67207814", "message": "Noop emit for webclient workaround\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T12:28:31Z", "type": "commit"}, {"oid": "aac0d2c443b422e152d1c6daf609c9e0dff5d75a", "url": "https://github.com/oracle/helidon/commit/aac0d2c443b422e152d1c6daf609c9e0dff5d75a", "message": "Javadoc fix\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T12:30:13Z", "type": "commit"}, {"oid": "30fcc8ee232c709756c51753fd415329a9247c15", "url": "https://github.com/oracle/helidon/commit/30fcc8ee232c709756c51753fd415329a9247c15", "message": "Noop emit for webclient workaround\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T12:30:27Z", "type": "commit"}, {"oid": "f5f17a18dbff54de25ab2d7d4de562832f469920", "url": "https://github.com/oracle/helidon/commit/f5f17a18dbff54de25ab2d7d4de562832f469920", "message": "Javadoc fix\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T12:58:23Z", "type": "commit"}, {"oid": "34260917e90928a05ade689f0d69fa96943aebea", "url": "https://github.com/oracle/helidon/commit/34260917e90928a05ade689f0d69fa96943aebea", "message": "Switch webserver to new OTP replacement\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T15:07:10Z", "type": "commit"}, {"oid": "8bf8560559e98633de583722b6a6407557973201", "url": "https://github.com/oracle/helidon/commit/8bf8560559e98633de583722b6a6407557973201", "message": "OTP in webserver Jersey test fix\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T18:33:40Z", "type": "commit"}, {"oid": "183fe7387df9f7ca30927661400adf1a0ceb903a", "url": "https://github.com/oracle/helidon/commit/183fe7387df9f7ca30927661400adf1a0ceb903a", "message": "Performance boost for unbounded use-cases\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-20T20:44:51Z", "type": "commit"}, {"oid": "e247007dc69dae440398437f2db0373da9041b1d", "url": "https://github.com/oracle/helidon/commit/e247007dc69dae440398437f2db0373da9041b1d", "message": "TCK passing for both encoder and decoder", "committedDate": "2020-05-21T00:14:54Z", "type": "commit"}, {"oid": "e1c8643472a621247688e148f9dda9e6ceec7a12", "url": "https://github.com/oracle/helidon/commit/e1c8643472a621247688e148f9dda9e6ceec7a12", "message": "update example to compile after the refactoring from io.helidon.media.multipart.common to io.helidon.media.multipart", "committedDate": "2020-05-21T00:25:52Z", "type": "commit"}, {"oid": "cef832fdd7ce7f3ee4582fcf70c612b9184e5b75", "url": "https://github.com/oracle/helidon/commit/cef832fdd7ce7f3ee4582fcf70c612b9184e5b75", "message": "Merge remote-tracking branch 'danielkec/emitter' into multipart", "committedDate": "2020-05-21T00:29:54Z", "type": "commit"}, {"oid": "21469fd10947a7fbffed0d898794df1445c161ec", "url": "https://github.com/oracle/helidon/commit/21469fd10947a7fbffed0d898794df1445c161ec", "message": "rebase multipart on top of the buffered emitter", "committedDate": "2020-05-21T03:38:05Z", "type": "commit"}, {"oid": "7543139d2aba4cebac344647578979f20824b722", "url": "https://github.com/oracle/helidon/commit/7543139d2aba4cebac344647578979f20824b722", "message": "update javadocs", "committedDate": "2020-05-21T04:07:24Z", "type": "commit"}, {"oid": "1029093bf21acf318aaeaab8f9844749e7176829", "url": "https://github.com/oracle/helidon/commit/1029093bf21acf318aaeaab8f9844749e7176829", "message": "remove javadoc", "committedDate": "2020-05-21T04:14:52Z", "type": "commit"}, {"oid": "6ff433b3f18c4a4917df6b82b25235a7d27a31cd", "url": "https://github.com/oracle/helidon/commit/6ff433b3f18c4a4917df6b82b25235a7d27a31cd", "message": "fix checkstyle", "committedDate": "2020-05-21T04:18:11Z", "type": "commit"}, {"oid": "f8a33c5070d95746804b215c457cf256ae526335", "url": "https://github.com/oracle/helidon/commit/f8a33c5070d95746804b215c457cf256ae526335", "message": "fix EmittingPublisherTest", "committedDate": "2020-05-21T06:56:27Z", "type": "commit"}, {"oid": "a1f2f2991c57ec107e7d1e8280d7577f0daa4c70", "url": "https://github.com/oracle/helidon/commit/a1f2f2991c57ec107e7d1e8280d7577f0daa4c70", "message": "Another performance boost\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-21T08:34:32Z", "type": "commit"}, {"oid": "9eeab8c2d43739e4f1eef97feb5ff83fe4f8187d", "url": "https://github.com/oracle/helidon/commit/9eeab8c2d43739e4f1eef97feb5ff83fe4f8187d", "message": "Cleanup and review issues\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-21T15:11:11Z", "type": "commit"}, {"oid": "ea9da46dceef61a25bd55e31fd13d41a6cff6cbe", "url": "https://github.com/oracle/helidon/commit/ea9da46dceef61a25bd55e31fd13d41a6cff6cbe", "message": "Kafka connector with new emitter\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-21T16:28:17Z", "type": "commit"}, {"oid": "6251d7781d79a73a48e2ba14e9b1ac0ba1ae7d01", "url": "https://github.com/oracle/helidon/commit/6251d7781d79a73a48e2ba14e9b1ac0ba1ae7d01", "message": "Merge remote-tracking branch 'danielkec/emitter' into multipart", "committedDate": "2020-05-21T18:22:11Z", "type": "commit"}, {"oid": "a7d538f285eee454f55f303414da01e3df4e2f4d", "url": "https://github.com/oracle/helidon/commit/a7d538f285eee454f55f303414da01e3df4e2f4d", "message": "Remove MessageBodyWriteableContent and fallback variants of MessageBodyWriterContext.marshall\nReplace MessageBodyWriteableContent with WriteableBodyPartContent that does support a writer context (i.e registerWriter methods)\nSimplified WriteableBodyPart.Builder by implementing 3 variants of WriteableBodyPartContent for the 3 types of data sources (raw publisher, entity, entity stream)", "committedDate": "2020-05-21T21:30:38Z", "type": "commit"}, {"oid": "54e30229f2fb8066064dd036da847bb260715de2", "url": "https://github.com/oracle/helidon/commit/54e30229f2fb8066064dd036da847bb260715de2", "message": "fix checkstyle errors", "committedDate": "2020-05-21T22:37:00Z", "type": "commit"}, {"oid": "e10feda18f20354801c8ba71e45a8fc4eac01971", "url": "https://github.com/oracle/helidon/commit/e10feda18f20354801c8ba71e45a8fc4eac01971", "message": "fix leftover usage of marshallStream with fallback", "committedDate": "2020-05-21T23:22:31Z", "type": "commit"}, {"oid": "e2238bf0c3c7b50037855334b14aae462e59a223", "url": "https://github.com/oracle/helidon/commit/e2238bf0c3c7b50037855334b14aae462e59a223", "message": "Merge remote-tracking branch 'origin/master' into multipart", "committedDate": "2020-05-22T23:44:02Z", "type": "commit"}, {"oid": "119c508fd84172a5449ec8fec12112e17947a7f2", "url": "https://github.com/oracle/helidon/commit/119c508fd84172a5449ec8fec12112e17947a7f2", "message": "comment-out onCancel for now", "committedDate": "2020-05-23T00:32:23Z", "type": "commit"}]}