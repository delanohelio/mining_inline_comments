{"pr_number": 1770, "pr_title": "Multi from InputStream", "pr_createdAt": "2020-05-12T11:49:29Z", "pr_url": "https://github.com/oracle/helidon/pull/1770", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NDE3Nw==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r423674177", "bodyText": "Not sure if publisher should be responsible for closing the inputstream but variant with onCancel is kind of ugly because of the checked exception\nMulti.from(is, 5)\n.onCancel(()->{\n  try{\n    is.close();\n    ...\n})...", "author": "danielkec", "createdAt": "2020-05-12T11:55:28Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/MultiFromInputStream.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class MultiFromInputStream implements Multi<ByteBuffer> {\n+\n+    private final InputStream inputStream;\n+    private final int bufferSize;\n+\n+    MultiFromInputStream(InputStream inputStream, int bufferSize) {\n+        this.inputStream = inputStream;\n+        this.bufferSize = bufferSize;\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super ByteBuffer> subscriber) {\n+        Objects.requireNonNull(subscriber, \"subscriber is null\");\n+        try {\n+            inputStream.available();\n+        } catch (IOException e) {\n+            subscriber.onSubscribe(EmptySubscription.INSTANCE);\n+            subscriber.onError(e);\n+            return;\n+        }\n+        InputStreamSubscription subscription = new InputStreamSubscription(subscriber, inputStream, bufferSize);\n+        subscriber.onSubscribe(subscription);\n+    }\n+\n+    static final class InputStreamSubscription extends AtomicLong implements Flow.Subscription {\n+\n+        private final Flow.Subscriber<? super ByteBuffer> downstream;\n+\n+        private InputStream inputStream;\n+        private final int bufferSize;\n+\n+        private volatile int canceled;\n+\n+        static final int NORMAL_CANCEL = 1;\n+        static final int BAD_REQUEST = 2;\n+\n+        InputStreamSubscription(Flow.Subscriber<? super ByteBuffer> downstream, InputStream inputStream, final int bufferSize) {\n+            this.downstream = downstream;\n+            this.inputStream = inputStream;\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0L) {\n+                canceled = BAD_REQUEST;\n+                n = 1; // for cleanup\n+            }\n+\n+            if (SubscriptionHelper.addRequest(this, n) != 0L) {\n+                return;\n+            }\n+\n+            long emitted = 0L;\n+            Flow.Subscriber<? super ByteBuffer> downstream = this.downstream;\n+\n+            for (;;) {\n+                while (emitted != n) {\n+                    int isCanceled = canceled;\n+                    if (isCanceled != 0) {\n+                        var toClose = inputStream;\n+                        inputStream = null;\n+                        if (isCanceled == BAD_REQUEST) {\n+                            downstream.onError(new IllegalArgumentException(\n+                                    \"Rule \u00a73.9 violated: non-positive request amount is forbidden\"));\n+                        } else if (isCanceled == NORMAL_CANCEL) {\n+                            try {\n+                                toClose.close();\n+                            } catch (IOException e) {\n+                                // Rule \u00a71.8 says eventually\n+                                downstream.onError(e);\n+                            }\n+                        }", "originalCommit": "d5bce14fd0eb91da42458c1bea145a02bc3f7abf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwODU0MQ==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r426308541", "bodyText": "removed", "author": "danielkec", "createdAt": "2020-05-17T21:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NDE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNjMyMA==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r423906320", "bodyText": "AFAIK this method should not be blocking. If you block here, you block the subscriber trying to request data.\nIt feels the only way to implement this correctly is to use an executor service.\nI think the existing implementations are not correct.", "author": "tomas-langer", "createdAt": "2020-05-12T17:24:38Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/MultiFromInputStream.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class MultiFromInputStream implements Multi<ByteBuffer> {\n+\n+    private final InputStream inputStream;\n+    private final int bufferSize;\n+\n+    MultiFromInputStream(InputStream inputStream, int bufferSize) {\n+        this.inputStream = inputStream;\n+        this.bufferSize = bufferSize;\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super ByteBuffer> subscriber) {\n+        Objects.requireNonNull(subscriber, \"subscriber is null\");\n+        try {\n+            inputStream.available();\n+        } catch (IOException e) {\n+            subscriber.onSubscribe(EmptySubscription.INSTANCE);\n+            subscriber.onError(e);\n+            return;\n+        }\n+        InputStreamSubscription subscription = new InputStreamSubscription(subscriber, inputStream, bufferSize);\n+        subscriber.onSubscribe(subscription);\n+    }\n+\n+    static final class InputStreamSubscription extends AtomicLong implements Flow.Subscription {\n+\n+        private final Flow.Subscriber<? super ByteBuffer> downstream;\n+\n+        private InputStream inputStream;\n+        private final int bufferSize;\n+\n+        private volatile int canceled;\n+\n+        static final int NORMAL_CANCEL = 1;\n+        static final int BAD_REQUEST = 2;\n+\n+        InputStreamSubscription(Flow.Subscriber<? super ByteBuffer> downstream, InputStream inputStream, final int bufferSize) {\n+            this.downstream = downstream;\n+            this.inputStream = inputStream;\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0L) {\n+                canceled = BAD_REQUEST;\n+                n = 1; // for cleanup\n+            }\n+\n+            if (SubscriptionHelper.addRequest(this, n) != 0L) {\n+                return;\n+            }\n+\n+            long emitted = 0L;\n+            Flow.Subscriber<? super ByteBuffer> downstream = this.downstream;\n+\n+            for (;;) {\n+                while (emitted != n) {\n+                    int isCanceled = canceled;\n+                    if (isCanceled != 0) {\n+                        var toClose = inputStream;\n+                        inputStream = null;\n+                        if (isCanceled == BAD_REQUEST) {\n+                            downstream.onError(new IllegalArgumentException(\n+                                    \"Rule \u00a73.9 violated: non-positive request amount is forbidden\"));\n+                        } else if (isCanceled == NORMAL_CANCEL) {\n+                            try {\n+                                toClose.close();\n+                            } catch (IOException e) {\n+                                // Rule \u00a71.8 says eventually\n+                                downstream.onError(e);\n+                            }\n+                        }\n+                        return;\n+                    }\n+\n+                    ByteBuffer value;\n+\n+                    try {\n+                        value = ByteBuffer.wrap(inputStream.readNBytes(bufferSize));", "originalCommit": "d5bce14fd0eb91da42458c1bea145a02bc3f7abf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NDA5OA==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r424254098", "bodyText": "Depends if you can trust InputStream to not block, then it would be excusable I guess, after all every method out of our control can block", "author": "danielkec", "createdAt": "2020-05-13T08:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNjMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzY1Mg==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r424257652", "bodyText": "@tomas-langer Added both variants so user can keep performance up in case he can trust InputStream to not block(for example ByteArrayInputStream) or utilize his own ExecutorService in case blocking of read operations is expected.", "author": "danielkec", "createdAt": "2020-05-13T08:19:58Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/Multi.java", "diffHunk": "@@ -178,6 +181,43 @@\n         return new MultiFromStream<>(stream);\n     }\n \n+    /**\n+     * Create a {@link Multi} instance that publishes {@link ByteBuffer}s from the given {@link InputStream}.\n+     * <p>\n+     * If {@link InputStream} can be trusted not to block on read operations, use faster\n+     * {@link Multi#from(java.io.InputStream, int)}.\n+     * <p>\n+     * The operator calls {@link InputStream#close()} when the cancel signal is intercepted.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @param buffSize size of the chunks to be sent to downstream in the form of {@link ByteBuffer}\n+     * @param executor executor to use for waiting at {@link InputStream}'s blocking reads\n+     * @return Multi\n+     * @throws NullPointerException if {@code stream} is {@code null}\n+     */\n+    static Multi<ByteBuffer> from(InputStream inputStream, int buffSize, ExecutorService executor) {\n+        Objects.requireNonNull(inputStream, \"stream is null\");\n+        return new MultiFromInputStream(inputStream, buffSize, executor);\n+    }", "originalCommit": "2fd65c15f26a07a87abc03b0075ada654a8ba21f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzMjU4OA==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r424332588", "bodyText": "Our internal rules do not allow null parameters - please check the executor is not null in this case", "author": "tomas-langer", "createdAt": "2020-05-13T10:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NTI4MA==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r424375280", "bodyText": "fixed", "author": "danielkec", "createdAt": "2020-05-13T11:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNDkwNw==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r424334907", "bodyText": "This approach is\n\nerror prone\nhard to read\n\nplease either use two implementation classes, or use an executor service that executes in thread.", "author": "tomas-langer", "createdAt": "2020-05-13T10:27:43Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/MultiFromInputStream.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+class MultiFromInputStream implements Multi<ByteBuffer> {\n+\n+    private final InputStream inputStream;\n+    private final int bufferSize;\n+    private final ExecutorService executorService;\n+\n+    MultiFromInputStream(InputStream inputStream, int bufferSize, ExecutorService executorService) {\n+        this.inputStream = inputStream;\n+        this.bufferSize = bufferSize;\n+        this.executorService = executorService;\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super ByteBuffer> subscriber) {\n+        Objects.requireNonNull(subscriber, \"subscriber is null\");\n+        try {\n+            inputStream.available();\n+        } catch (IOException e) {\n+            subscriber.onSubscribe(EmptySubscription.INSTANCE);\n+            subscriber.onError(e);\n+            return;\n+        }\n+        InputStreamSubscription subscription = new InputStreamSubscription(subscriber, inputStream, bufferSize, executorService);\n+        subscriber.onSubscribe(subscription);\n+    }\n+\n+    static final class InputStreamSubscription extends AtomicLong implements Flow.Subscription {\n+\n+        private final ExecutorService executorService;\n+        private final LinkedBlockingQueue<Runnable> submitQueue = new LinkedBlockingQueue<>();\n+        private final Flow.Subscriber<? super ByteBuffer> downstream;\n+        private final int bufferSize;\n+        private InputStream inputStream;\n+\n+        private final AtomicBoolean draining = new AtomicBoolean(false);\n+\n+        private volatile int canceled;\n+\n+        static final int NORMAL_CANCEL = 1;\n+        static final int BAD_REQUEST = 2;\n+\n+        InputStreamSubscription(Flow.Subscriber<? super ByteBuffer> downstream,\n+                                InputStream inputStream,\n+                                final int bufferSize,\n+                                ExecutorService executorService) {\n+            this.downstream = downstream;\n+            this.inputStream = inputStream;\n+            this.bufferSize = bufferSize;\n+            this.executorService = executorService;\n+        }\n+\n+\n+        private void trySubmit(long n) {\n+            long emitted = 0L;\n+            Flow.Subscriber<? super ByteBuffer> downstream = this.downstream;\n+\n+            for (;;) {\n+                while (emitted != n) {\n+                    int isCanceled = canceled;\n+                    if (isCanceled != 0) {\n+                        var toClose = inputStream;\n+                        inputStream = null;\n+                        if (isCanceled == BAD_REQUEST) {\n+                            downstream.onError(new IllegalArgumentException(\n+                                    \"Rule \u00a73.9 violated: non-positive request amount is forbidden\"));\n+                        } else if (isCanceled == NORMAL_CANCEL) {\n+                            try {\n+                                toClose.close();\n+                            } catch (IOException e) {\n+                                // Rule \u00a71.8 says eventually\n+                                downstream.onError(e);\n+                            }\n+                        }\n+                        return;\n+                    }\n+\n+                    ByteBuffer value;\n+\n+                    try {\n+                        value = ByteBuffer.wrap(inputStream.readNBytes(bufferSize));\n+                    } catch (Throwable ex) {\n+                        inputStream = null;\n+                        canceled = NORMAL_CANCEL;\n+                        downstream.onError(ex);\n+                        return;\n+                    }\n+\n+                    if (value.limit() == 0) {\n+                        inputStream = null;\n+                        downstream.onComplete();\n+                        return;\n+                    }\n+\n+                    downstream.onNext(value);\n+\n+                    if (canceled != 0) {\n+                        continue;\n+                    }\n+\n+                    emitted++;\n+                }\n+\n+                n = get();\n+                if (n == emitted) {\n+                    n = SubscriptionHelper.produced(this, emitted);\n+                    if (n == 0L) {\n+                        return;\n+                    }\n+                    emitted = 0L;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0L) {\n+                canceled = BAD_REQUEST;\n+                n = 1; // for cleanup\n+            }\n+\n+            if (SubscriptionHelper.addRequest(this, n) != 0L) {\n+                return;\n+            }\n+\n+            if (executorService == null) {", "originalCommit": "2fd65c15f26a07a87abc03b0075ada654a8ba21f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM3NTY4Ng==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r424375686", "bodyText": "fixed", "author": "danielkec", "createdAt": "2020-05-13T11:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMzNDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5Mzc5OQ==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r425893799", "bodyText": "The buffSize in both methods seems a bit of an overhead.\nI think the static method from should only accept InputStream (and ExecutorService for blocking variant).\nIf you want to have the buffSize, a builder may be the right way to go, using some reasonable default for buffer size otherwise.", "author": "tomas-langer", "createdAt": "2020-05-15T15:52:40Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/Multi.java", "diffHunk": "@@ -178,6 +181,44 @@\n         return new MultiFromStream<>(stream);\n     }\n \n+    /**\n+     * Create a {@link Multi} instance that publishes {@link ByteBuffer}s from the given {@link InputStream}.\n+     * <p>\n+     * If {@link InputStream} can be trusted not to block on read operations, use faster\n+     * {@link Multi#from(java.io.InputStream, int)}.\n+     * <p>\n+     * The operator calls {@link InputStream#close()} when the cancel signal is intercepted.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @param buffSize size of the chunks to be sent to downstream in the form of {@link ByteBuffer}\n+     * @param executor executor to use for waiting at {@link InputStream}'s blocking reads\n+     * @return Multi\n+     * @throws NullPointerException if {@code stream} is {@code null}\n+     */\n+    static Multi<ByteBuffer> from(InputStream inputStream, int buffSize, ExecutorService executor) {\n+        Objects.requireNonNull(inputStream, \"stream is null\");\n+        Objects.requireNonNull(executor, \"executor is null\");\n+        return new MultiFromBlockingInputStream(inputStream, buffSize, executor);\n+    }\n+\n+    /**\n+     * Create a {@link Multi} instance that publishes {@link ByteBuffer}s from the given {@link InputStream}.\n+     * <p>\n+     * {@link InputStream} is trusted not to block on read operations, in case it can't be assured use\n+     * {@link Multi#from(java.io.InputStream, int, java.util.concurrent.ExecutorService)}.\n+     * <p>\n+     * The operator calls {@link InputStream#close()} when the cancel signal is intercepted.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @param buffSize    size of the chunks to be sent to downstream in the form of {@link ByteBuffer}\n+     * @return Multi\n+     * @throws NullPointerException if {@code stream} is {@code null}\n+     */\n+    static Multi<ByteBuffer> from(InputStream inputStream, int buffSize) {", "originalCommit": "993c8eb34bf551e58e47d10f0fc7af8ac09cd14b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMwMzMyNA==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r426303324", "bodyText": "We can do something like this:\n        String s = Multi.from(is, executorService)\n                .withByteBufferSize(4)\n                .map(StandardCharsets.UTF_8::decode)\n                ....", "author": "danielkec", "createdAt": "2020-05-17T20:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5Mzc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNjY5OA==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r429426698", "bodyText": "Helidon builder pattern:\n\nA static factory method builder that creates a new builder instance\nBuilder has only setters in Helidon style (e.g. no verb)\nThere is a clear transition from builder to built instance\n\nSo your example:\nMulti.builder(is, executorService)\n   .bufferSize(1024)\n   .build()\n   .map...\nI think it is enough you are breaking the rule for static factory methods, which should always be called create and not from", "author": "tomas-langer", "createdAt": "2020-05-22T19:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5Mzc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg4NjIxMA==", "url": "https://github.com/oracle/helidon/pull/1770#discussion_r431886210", "bodyText": "IoMulti.builder(is)\n                .executor(Executors.newSingleThreadExecutor())\n                .byteBufferSize(BUFFER_SIZE)\n                .build();", "author": "danielkec", "createdAt": "2020-05-28T14:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5Mzc5OQ=="}], "type": "inlineReview"}, {"oid": "4d7a2aab7afa41b9322fbfaf860a166036058410", "url": "https://github.com/oracle/helidon/commit/4d7a2aab7afa41b9322fbfaf860a166036058410", "message": "Multi from InputStream", "committedDate": "2020-05-28T12:40:03Z", "type": "commit"}, {"oid": "864d7bb5d72f573f67d2729a60688f555b100f31", "url": "https://github.com/oracle/helidon/commit/864d7bb5d72f573f67d2729a60688f555b100f31", "message": "Switch to MultiFromInputStream\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-28T13:42:45Z", "type": "commit"}, {"oid": "3664001010f75837fd8d224425326766d7b03b25", "url": "https://github.com/oracle/helidon/commit/3664001010f75837fd8d224425326766d7b03b25", "message": "Move MultiFromInputStream to IoMulti builder\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-28T14:33:04Z", "type": "commit"}, {"oid": "3664001010f75837fd8d224425326766d7b03b25", "url": "https://github.com/oracle/helidon/commit/3664001010f75837fd8d224425326766d7b03b25", "message": "Move MultiFromInputStream to IoMulti builder\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-05-28T14:33:04Z", "type": "forcePushed"}]}