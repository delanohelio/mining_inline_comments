{"pr_number": 1458, "pr_title": "Remove dependency on Jackson via SmallRye -2.x", "pr_createdAt": "2020-03-02T16:43:12Z", "pr_url": "https://github.com/oracle/helidon/pull/1458", "timeline": [{"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "url": "https://github.com/oracle/helidon/commit/c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "message": "Remove transitive dep. on jackson from SmallRye OpenAPI implementation", "committedDate": "2020-02-28T06:22:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNDU0MA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386624540", "bodyText": "Just a quick check to make sure you have to do this, and/or it's the right thing to do.  It struck me as surprising (as a layman reviewer) that the Property superclass wouldn't default to this value.", "author": "ljnelson", "createdAt": "2020-03-02T20:13:28Z", "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:\n+                    valueNode.setType(List.class);\n+                    return true;\n+\n+                case anchor:\n+                    break;\n+\n+                case mapping:\n+                    valueNode.setType(Map.class);\n+                    return true;\n+\n+                case scalar:\n+                    break;\n+\n+                default:\n+\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isExtension(String name) {\n+        return name.startsWith(EXTENSION_PROPERTY_PREFIX);\n+    }\n+\n+    /**\n+     * Specific type description for {@code Schema}.\n+     * <p>\n+     *     The {@code Schema} node allows the {@code additionalProperties} subnode to be either\n+     *     {@code Boolean} or another {@code Schema}. This type description provides a customized\n+     *     property description for {@code additionalProperties} that infers which variant a\n+     *     specific node in the document actually uses and then processes it accordingly.\n+     * </p>\n+     */\n+    static class SchemaTypeDescription extends ExpandedTypeDescription {\n+\n+        private static final PropertyDescriptor ADDL_PROPS_PROP_DESCRIPTOR = preparePropertyDescriptor();\n+\n+        private static final Property ADDL_PROPS_PROPERTY =\n+                new MethodProperty(ADDL_PROPS_PROP_DESCRIPTOR) {\n+\n+                    @Override\n+                    public void set(Object object, Object value) throws Exception {\n+                        Schema s = Schema.class.cast(object);\n+                        if (value instanceof Schema) {\n+                            s.setAdditionalPropertiesSchema((Schema) value);\n+                        } else {\n+                            s.setAdditionalPropertiesBoolean((Boolean) value);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public Object get(Object object) {\n+                        Schema s = Schema.class.cast(object);\n+                        Boolean b = s.getAdditionalPropertiesBoolean();\n+                        return b != null ? b : s.getAdditionalPropertiesSchema();\n+                    }\n+                };\n+\n+        private static PropertyDescriptor preparePropertyDescriptor() {\n+            try {\n+                return new PropertyDescriptor(\"additionalProperties\",\n+                        Schema.class.getMethod(\"getAdditionalPropertiesSchema\"),\n+                        Schema.class.getMethod(\"setAdditionalPropertiesSchema\", Schema.class));\n+            } catch (IntrospectionException | NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private SchemaTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+            super(clazz, impl);\n+        }\n+\n+        @Override\n+        public Property getProperty(String name) {\n+            return name.equals(\"additionalProperties\") ? ADDL_PROPS_PROPERTY : super.getProperty(name);\n+        }\n+    }\n+\n+    /**\n+     * Property description for an extension subnode.\n+     */\n+    static class ExtensionProperty extends Property {\n+\n+        ExtensionProperty(String name) {\n+            super(name, Object.class);\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return new Class[0];", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDI0NQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824245", "bodyText": "In fact, this is correct. We know that the ExtensionProperty class will be used only for OpenAPI extensions, and we know those properties will have no type arguments, so this method can safely always return an empty array. I will insert a comment to this effect and will also change the method so it does not create a new array upon each invocation.", "author": "tjquinno", "createdAt": "2020-03-04T17:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNDU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNDcxMg==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386624712", "bodyText": "Consider making static", "author": "ljnelson", "createdAt": "2020-03-02T20:13:48Z", "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:\n+                    valueNode.setType(List.class);\n+                    return true;\n+\n+                case anchor:\n+                    break;\n+\n+                case mapping:\n+                    valueNode.setType(Map.class);\n+                    return true;\n+\n+                case scalar:\n+                    break;\n+\n+                default:\n+\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isExtension(String name) {\n+        return name.startsWith(EXTENSION_PROPERTY_PREFIX);\n+    }\n+\n+    /**\n+     * Specific type description for {@code Schema}.\n+     * <p>\n+     *     The {@code Schema} node allows the {@code additionalProperties} subnode to be either\n+     *     {@code Boolean} or another {@code Schema}. This type description provides a customized\n+     *     property description for {@code additionalProperties} that infers which variant a\n+     *     specific node in the document actually uses and then processes it accordingly.\n+     * </p>\n+     */\n+    static class SchemaTypeDescription extends ExpandedTypeDescription {\n+\n+        private static final PropertyDescriptor ADDL_PROPS_PROP_DESCRIPTOR = preparePropertyDescriptor();\n+\n+        private static final Property ADDL_PROPS_PROPERTY =\n+                new MethodProperty(ADDL_PROPS_PROP_DESCRIPTOR) {\n+\n+                    @Override\n+                    public void set(Object object, Object value) throws Exception {\n+                        Schema s = Schema.class.cast(object);\n+                        if (value instanceof Schema) {\n+                            s.setAdditionalPropertiesSchema((Schema) value);\n+                        } else {\n+                            s.setAdditionalPropertiesBoolean((Boolean) value);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public Object get(Object object) {\n+                        Schema s = Schema.class.cast(object);\n+                        Boolean b = s.getAdditionalPropertiesBoolean();\n+                        return b != null ? b : s.getAdditionalPropertiesSchema();\n+                    }\n+                };\n+\n+        private static PropertyDescriptor preparePropertyDescriptor() {\n+            try {\n+                return new PropertyDescriptor(\"additionalProperties\",\n+                        Schema.class.getMethod(\"getAdditionalPropertiesSchema\"),\n+                        Schema.class.getMethod(\"setAdditionalPropertiesSchema\", Schema.class));\n+            } catch (IntrospectionException | NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private SchemaTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+            super(clazz, impl);\n+        }\n+\n+        @Override\n+        public Property getProperty(String name) {\n+            return name.equals(\"additionalProperties\") ? ADDL_PROPS_PROPERTY : super.getProperty(name);\n+        }\n+    }\n+\n+    /**\n+     * Property description for an extension subnode.\n+     */\n+    static class ExtensionProperty extends Property {\n+\n+        ExtensionProperty(String name) {\n+            super(name, Object.class);\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return new Class[0];\n+        }\n+\n+        @Override\n+        public void set(Object object, Object value) throws Exception {\n+            asExt(object).addExtension(getName(), value);\n+        }\n+\n+        @Override\n+        public Object get(Object object) {\n+            return asExt(object).getExtensions().get(getName());\n+        }\n+\n+        @Override\n+        public List<Annotation> getAnnotations() {\n+            return null;\n+        }\n+\n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n+            return null;\n+        }\n+\n+        private Extensible<?> asExt(Object object) {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDM0NQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824345", "bodyText": "As written it invokes the instance method getName for the error message.", "author": "tjquinno", "createdAt": "2020-03-04T17:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2Njc2OQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387866769", "bodyText": "\ud83e\udd26\u200d\u2642 Got it.", "author": "ljnelson", "createdAt": "2020-03-04T18:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNDcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjAwMw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386626003", "bodyText": "These case values surprised me; where are they coming from?  Obviously everything compiles so it's fine but maybe a quick one-liner comment somewhere explaining their provenance.", "author": "ljnelson", "createdAt": "2020-03-02T20:16:30Z", "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDM3NA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824374", "bodyText": "Comment added.", "author": "tjquinno", "createdAt": "2020-03-04T17:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjQyMQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386626421", "bodyText": "OK to return null, or should it be Collections.emptyList()?  Don't know the innards of SnakeYAML to know whether one is different from the other.  Obviously avoiding any object allocations is good if possible.", "author": "ljnelson", "createdAt": "2020-03-02T20:17:26Z", "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:\n+                    valueNode.setType(List.class);\n+                    return true;\n+\n+                case anchor:\n+                    break;\n+\n+                case mapping:\n+                    valueNode.setType(Map.class);\n+                    return true;\n+\n+                case scalar:\n+                    break;\n+\n+                default:\n+\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isExtension(String name) {\n+        return name.startsWith(EXTENSION_PROPERTY_PREFIX);\n+    }\n+\n+    /**\n+     * Specific type description for {@code Schema}.\n+     * <p>\n+     *     The {@code Schema} node allows the {@code additionalProperties} subnode to be either\n+     *     {@code Boolean} or another {@code Schema}. This type description provides a customized\n+     *     property description for {@code additionalProperties} that infers which variant a\n+     *     specific node in the document actually uses and then processes it accordingly.\n+     * </p>\n+     */\n+    static class SchemaTypeDescription extends ExpandedTypeDescription {\n+\n+        private static final PropertyDescriptor ADDL_PROPS_PROP_DESCRIPTOR = preparePropertyDescriptor();\n+\n+        private static final Property ADDL_PROPS_PROPERTY =\n+                new MethodProperty(ADDL_PROPS_PROP_DESCRIPTOR) {\n+\n+                    @Override\n+                    public void set(Object object, Object value) throws Exception {\n+                        Schema s = Schema.class.cast(object);\n+                        if (value instanceof Schema) {\n+                            s.setAdditionalPropertiesSchema((Schema) value);\n+                        } else {\n+                            s.setAdditionalPropertiesBoolean((Boolean) value);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public Object get(Object object) {\n+                        Schema s = Schema.class.cast(object);\n+                        Boolean b = s.getAdditionalPropertiesBoolean();\n+                        return b != null ? b : s.getAdditionalPropertiesSchema();\n+                    }\n+                };\n+\n+        private static PropertyDescriptor preparePropertyDescriptor() {\n+            try {\n+                return new PropertyDescriptor(\"additionalProperties\",\n+                        Schema.class.getMethod(\"getAdditionalPropertiesSchema\"),\n+                        Schema.class.getMethod(\"setAdditionalPropertiesSchema\", Schema.class));\n+            } catch (IntrospectionException | NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private SchemaTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+            super(clazz, impl);\n+        }\n+\n+        @Override\n+        public Property getProperty(String name) {\n+            return name.equals(\"additionalProperties\") ? ADDL_PROPS_PROPERTY : super.getProperty(name);\n+        }\n+    }\n+\n+    /**\n+     * Property description for an extension subnode.\n+     */\n+    static class ExtensionProperty extends Property {\n+\n+        ExtensionProperty(String name) {\n+            super(name, Object.class);\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return new Class[0];\n+        }\n+\n+        @Override\n+        public void set(Object object, Object value) throws Exception {\n+            asExt(object).addExtension(getName(), value);\n+        }\n+\n+        @Override\n+        public Object get(Object object) {\n+            return asExt(object).getExtensions().get(getName());\n+        }\n+\n+        @Override\n+        public List<Annotation> getAnnotations() {\n+            return null;", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDQxNQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824415", "bodyText": "Fixed.", "author": "tjquinno", "createdAt": "2020-03-04T17:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjY0OQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386626649", "bodyText": "Layman reviewer note: surprised me to see Impl as a prefix; was expecting a suffix here.  This is true even when I read your class comment.  I'm not sure what would be a better name.  Maybe DelegatingTypeDescription?", "author": "ljnelson", "createdAt": "2020-03-02T20:17:57Z", "path": "openapi/src/main/java/io/helidon/openapi/ImplTypeDescription.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.util.Set;\n+\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.Tag;\n+\n+/**\n+ * Version of {@code TypeDescription} used for implementation classes (rather than the corresponding interfaces) which delegate\n+ * most method invocations to the {@code TypeDescription} for the related interface.\n+ */\n+class ImplTypeDescription extends TypeDescription {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDUzNg==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824536", "bodyText": "I think an Impl suffix might be problematic because this class is a TypeDescription for implementation classes (from SmallRye) rather than for interfaces (from MP OpenAPI). Plus TypeDescription is itself a class, so I'm not sure about the expectation of seeing an \"implementation\" of another class.\nThe apparent clarity of DelegatingTypeDescription might actually be a little misleading, because, although it delegates every method to delegate.something, the getType method_does not_ delegate to delegate.getType() but to delegate.impl(). This is what makes this an ImplTypeDescription.\nI will make this more explicit in the class comments.", "author": "tjquinno", "createdAt": "2020-03-04T17:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNzMyNg==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386627326", "bodyText": "Could this be final?", "author": "ljnelson", "createdAt": "2020-03-02T20:19:23Z", "path": "openapi/src/main/java/io/helidon/openapi/OpenAPIParser.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+\n+/**\n+ * Abstraction for SnakeYAML parsing of JSON and YAML.\n+ */\n+class OpenAPIParser {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDU5OQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824599", "bodyText": "Yes. Changed.", "author": "tjquinno", "createdAt": "2020-03-04T17:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNzMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNzg3Ng==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386627876", "bodyText": "Do we know if the Reader is closed?  I assume Yaml does in fact consume the whole thing and closes it afterwards (a pet peeve of mine, but I digress).  A quick comment noting this would be good here.", "author": "ljnelson", "createdAt": "2020-03-02T20:20:34Z", "path": "openapi/src/main/java/io/helidon/openapi/OpenAPIParser.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+\n+/**\n+ * Abstraction for SnakeYAML parsing of JSON and YAML.\n+ */\n+class OpenAPIParser {\n+\n+    private OpenAPIParser() {\n+    }\n+\n+    static OpenAPI parse(Map<Class<?>, ExpandedTypeDescription> types, InputStream inputStream,\n+            OpenAPISupport.OpenAPIMediaType openAPIMediaType) {\n+        Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);\n+        return parse(types, reader, openAPIMediaType);\n+    }\n+\n+    static OpenAPI parse(Map<Class<?>, ExpandedTypeDescription> types, Reader reader,\n+            OpenAPISupport.OpenAPIMediaType openAPIMediaType) {\n+        TypeDescription openAPITD = types.get(OpenAPI.class);\n+        Constructor topConstructor = new CustomConstructor(openAPITD);\n+\n+        types.values()\n+                .forEach(topConstructor::addTypeDescription);\n+\n+        Yaml yaml = new Yaml(topConstructor);\n+        OpenAPI result = yaml.loadAs(reader, OpenAPI.class);", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDY0Mw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824643", "bodyText": "Yaml does not in fact close the Reader. Because the Reader is passed as an argument, I've changed the call sites to close their readers.", "author": "tjquinno", "createdAt": "2020-03-04T17:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNzg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyODM1Nw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386628357", "bodyText": "Nit: consider \"Specialized SnakeYAML Constructor\"", "author": "ljnelson", "createdAt": "2020-03-02T20:21:34Z", "path": "openapi/src/main/java/io/helidon/openapi/CustomConstructor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.PathItem;\n+import org.eclipse.microprofile.openapi.models.Paths;\n+import org.eclipse.microprofile.openapi.models.callbacks.Callback;\n+import org.eclipse.microprofile.openapi.models.media.Content;\n+import org.eclipse.microprofile.openapi.models.media.MediaType;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponse;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponses;\n+import org.eclipse.microprofile.openapi.models.security.Scopes;\n+import org.eclipse.microprofile.openapi.models.security.SecurityRequirement;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariable;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariables;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.SequenceNode;\n+\n+/**\n+ * Specialized constructor for modifying {@code Node} objects for OpenAPI types that extend {@code Map} to adjust the type of", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDY4Nw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824687", "bodyText": "Fixed", "author": "tjquinno", "createdAt": "2020-03-04T17:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyODM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyODkyNQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386628925", "bodyText": "Reading along, perhaps you effectively answer this later, perhaps not: can this be final?", "author": "ljnelson", "createdAt": "2020-03-02T20:22:41Z", "path": "openapi/src/main/java/io/helidon/openapi/CustomConstructor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.PathItem;\n+import org.eclipse.microprofile.openapi.models.Paths;\n+import org.eclipse.microprofile.openapi.models.callbacks.Callback;\n+import org.eclipse.microprofile.openapi.models.media.Content;\n+import org.eclipse.microprofile.openapi.models.media.MediaType;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponse;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponses;\n+import org.eclipse.microprofile.openapi.models.security.Scopes;\n+import org.eclipse.microprofile.openapi.models.security.SecurityRequirement;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariable;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariables;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.SequenceNode;\n+\n+/**\n+ * Specialized constructor for modifying {@code Node} objects for OpenAPI types that extend {@code Map} to adjust the type of\n+ * the child nodes of such nodes.\n+ * <p>\n+ * Several MicroProfile OpenAPI interfaces extend {@code Map}. For example, {@code Paths} extends {@code Map\n+ * <String, PathItem>} and {@code SecurityRequirement} extends {@code Map<String, List<String>>}. When SnakeYAML builds the node\n+ * corresponding to one of these types, it correctly creates each child node as a {@code MappingNode} but it assigns those\n+ * child nodes a type of {@code Object} instead of the mapped type -- {@code PathItem} in the example above.\n+ * </p>\n+ * <p>\n+ * This class customizes the preparation of the node tree in these situations by setting the types for the child nodes explicitly\n+ * to the corresponding child type. In OpenAPI 1.1.2 there are two situations, depending on whether the mapped-to type is a\n+ * {@code List} or not.\n+ * </p>\n+ * <p>\n+ * The MicroProfile OpenAPI 2.0 versions of the interfaces no longer use this construct of an interface extending {@code Map}, so\n+ * ideally we can remove this workaround when we adopt 2.0.\n+ * </p>\n+ */\n+class CustomConstructor extends Constructor {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDc1MA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824750", "bodyText": "Yes. Changed.", "author": "tjquinno", "createdAt": "2020-03-04T17:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyODkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyOTM3NQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386629375", "bodyText": "Can this be final?", "author": "ljnelson", "createdAt": "2020-03-02T20:23:37Z", "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDgxNg==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824816", "bodyText": "This one cannot be final; the inner SchemaTypeDescription class extends it. But that one can be final; I changed that.", "author": "tjquinno", "createdAt": "2020-03-04T17:37:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyOTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDMzOA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386630338", "bodyText": "Consider wrapping this in Collections.unmodifiableMap().", "author": "ljnelson", "createdAt": "2020-03-02T20:25:42Z", "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -116,6 +149,88 @@ public void configureEndpoint(Routing.Rules rules) {\n                 .get(webContext, this::prepareResponse);\n     }\n \n+    static synchronized SnakeYAMLParserHelper<ExpandedTypeDescription> helper() {\n+        if (helper == null) {\n+            helper = SnakeYAMLParserHelper.create(ExpandedTypeDescription::create);\n+            adjustTypeDescriptions(helper.types());\n+        }\n+        return helper;\n+    }\n+\n+    static Map<Class<?>, ExpandedTypeDescription> buildImplsToTypes(SnakeYAMLParserHelper<ExpandedTypeDescription> helper) {\n+        return helper.entrySet().stream()", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDg2Nw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824867", "bodyText": "Done", "author": "tjquinno", "createdAt": "2020-03-04T17:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDczMg==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386630732", "bodyText": "Just a note to say I appreciate the comments!!", "author": "ljnelson", "createdAt": "2020-03-02T20:26:26Z", "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -116,6 +149,88 @@ public void configureEndpoint(Routing.Rules rules) {\n                 .get(webContext, this::prepareResponse);\n     }\n \n+    static synchronized SnakeYAMLParserHelper<ExpandedTypeDescription> helper() {\n+        if (helper == null) {\n+            helper = SnakeYAMLParserHelper.create(ExpandedTypeDescription::create);\n+            adjustTypeDescriptions(helper.types());\n+        }\n+        return helper;\n+    }\n+\n+    static Map<Class<?>, ExpandedTypeDescription> buildImplsToTypes(SnakeYAMLParserHelper<ExpandedTypeDescription> helper) {\n+        return helper.entrySet().stream()\n+                .map(Map.Entry::getValue)\n+                .collect(Collectors.toMap(ExpandedTypeDescription::impl, Function.identity()));\n+    }\n+\n+    private static void adjustTypeDescriptions(Map<Class<?>, ExpandedTypeDescription> types) {\n+        /*\n+         * We need to adjust the {@code TypeDescription} objects set up by the generated {@code SnakeYAMLParserHelper} class\n+         * because there are some OpenAPI-specific issues that the general-purpose helper generator cannot know about.\n+         */\n+\n+        /*\n+         * In the OpenAPI document, HTTP methods are expressed in lower-case. But the associated Java methods on the PathItem\n+         * class use the HTTP method names in upper-case. So for each HTTP method, \"add\" a property to PathItem's type\n+         * description using the lower-case name but upper-case Java methods and exclude the upper-case property that\n+         * SnakeYAML's automatic analysis of the class already created.\n+         */\n+        ExpandedTypeDescription pathItemTD = types.get(PathItem.class);\n+        for (PathItem.HttpMethod m : PathItem.HttpMethod.values()) {\n+            pathItemTD.substituteProperty(m.name().toLowerCase(), Operation.class, getter(m), setter(m));\n+            pathItemTD.addExcludes(m.name());\n+        }\n+\n+        /*\n+         * An OpenAPI document can contain a property named \"enum\" for Schema and ServerVariable, but the related Java methods\n+         * use \"enumeration\".\n+         */\n+        Set.<Class<?>>of(Schema.class, ServerVariable.class).forEach(c -> {\n+            ExpandedTypeDescription tdWithEnumeration = types.get(c);\n+            tdWithEnumeration.substituteProperty(\"enum\", List.class, \"getEnumeration\", \"setEnumeration\");\n+            tdWithEnumeration.addPropertyParameters(\"enum\", String.class);\n+            tdWithEnumeration.addExcludes(\"enumeration\");\n+        });\n+\n+        /*\n+         * SnakeYAML derives properties only from methods declared directly by each OpenAPI interface, not from methods defined\n+         *  on other interfaces which the original one extends. Those we have to handle explicitly.\n+         */", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDg5Nw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824897", "bodyText": "Aim to please!", "author": "tjquinno", "createdAt": "2020-03-04T17:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjE1MA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386632150", "bodyText": "Whoops", "author": "ljnelson", "createdAt": "2020-03-02T20:29:04Z", "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -132,8 +247,10 @@ private OpenAPI prepareModel(OpenApiConfig config, IndexView indexView, OpenApiS\n                 OpenApiDocument.INSTANCE.reset();\n                 OpenApiDocument.INSTANCE.config(config);\n                 OpenApiDocument.INSTANCE.modelFromReader(OpenApiProcessor.modelFromReader(config, getContextClassLoader()));\n-                OpenApiDocument.INSTANCE.modelFromStaticFile(OpenApiProcessor.modelFromStaticFile(staticFile));\n-                if (isAnnotationProcessingEnabled(config)) {\n+                if (staticFile != null) {\n+                    OpenApiDocument.INSTANCE.modelFromStaticFile(OpenAPIParser.parse(helper().types(), staticFile.getContent(),\n+                            OpenAPIMediaType.byFormat(staticFile.getFormat())));\n+                }if (isAnnotationProcessingEnabled(config)) {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNDkzMw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387824933", "bodyText": "Fixed", "author": "tjquinno", "createdAt": "2020-03-04T17:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjUwMw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386632503", "bodyText": "The old version would let RuntimeExceptions be thrown here; not sure if you intended to catch them as well.", "author": "ljnelson", "createdAt": "2020-03-02T20:29:48Z", "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -182,7 +305,7 @@ private void prepareResponse(ServerRequest req, ServerResponse resp) {\n             resp.status(Http.Status.OK_200);\n             resp.headers().add(Http.Header.CONTENT_TYPE, resultMediaType.toString());\n             resp.send(openAPIDocument);\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTAwNw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825007", "bodyText": "The intent of the change is to catch any Exception (and convert it into a 500 response with a brief explanation sent back to the client).", "author": "tjquinno", "createdAt": "2020-03-04T17:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjkyMQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386632921", "bodyText": "Maybe equalsIgnoreCase()?", "author": "ljnelson", "createdAt": "2020-03-02T20:30:45Z", "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -252,6 +375,92 @@ private MediaType chooseResponseMediaType(ServerRequest req) {\n         return resultMediaType;\n     }\n \n+    /**\n+     * Extension we want SmallRye's OpenAPI implementation to use for parsing the JSON content in Extension annotations.\n+     */\n+    private static class HelidonAnnotationScannerExtension implements AnnotationScannerExtension {\n+\n+        @Override\n+        public Object parseExtension(String key, String value) {\n+\n+            // Inspired by SmallRye's JsonUtil#parseValue method.\n+            if (value == null) {\n+                return null;\n+            }\n+\n+            value = value.trim();\n+\n+            if (\"true\".equals(value) || \"false\".equals(value)) {", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTA0OQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825049", "bodyText": "I pretty much lifted this method from the corresponding SmallRye one, but I think your suggestion is a good one. Done.", "author": "tjquinno", "createdAt": "2020-03-04T17:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMzkwMA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386633900", "bodyText": "Hazy old memories of making sure that SnakeYAML's SafeConstructor or something is in play; I'll try to dig for more details.", "author": "ljnelson", "createdAt": "2020-03-02T20:32:52Z", "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTA5NA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825094", "bodyText": "IIRC that's if you want to restrict the document-to-object mapping to objects that come with Java (i.e., not your own). (see https://bitbucket.org/asomov/snakeyaml/wiki/Documentation and search for SafeConstructor)", "author": "tjquinno", "createdAt": "2020-03-04T17:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMzkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDQwMw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386634403", "bodyText": "Maybe put in a finally block?", "author": "ljnelson", "createdAt": "2020-03-02T20:33:55Z", "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTEzNQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825135", "bodyText": "Clearing representedObjects is an awkward but effective way to prevent SnakeYAML from using anchors and links in the output document (this is the least bad way, currently, BTW) because Jackson - which is used in the MP OpenAPI TCK - does not process those correctly. If some method invoked here throws an exception then all bets are off and we don't really care about the contents of representedObjects any more. I've added a comment explaining this.", "author": "tjquinno", "createdAt": "2020-03-04T17:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDg5Ng==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386634896", "bodyText": "Been a while since I've seen this operator.  Won't this always assign false to reject?  {Heads off to JLS page}", "author": "ljnelson", "createdAt": "2020-03-02T20:34:59Z", "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private void processExtensions(MappingNode node, Object javaBean) {\n+            if (!Extensible.class.isAssignableFrom(javaBean.getClass())) {\n+                return;\n+            }\n+\n+            List<NodeTuple> tuples = new ArrayList<>(node.getValue());\n+\n+            if (tuples.isEmpty()) {\n+                return;\n+            }\n+            List<NodeTuple> updatedTuples = new ArrayList<>();\n+\n+            tuples.forEach(tuple -> {\n+                Node keyNode = tuple.getKeyNode();\n+                if (keyNode.getTag().equals(Tag.STR)) {\n+                    String key = ((ScalarNode) keyNode).getValue();\n+                    if (key.equals(EXTENSIONS)) {\n+                        Node valueNode = tuple.getValueNode();\n+                        if (valueNode.getNodeId().equals(NodeId.mapping)) {\n+                            MappingNode extensions = MappingNode.class.cast(valueNode);\n+                            updatedTuples.addAll(extensions.getValue());\n+                        }\n+                    } else {\n+                        updatedTuples.add(tuple);\n+                    }\n+                } else {\n+                    updatedTuples.add(tuple);\n+                }\n+            });\n+            node.setValue(updatedTuples);\n+        }\n+\n+        /**\n+         * Some SmallRye implementation classes have properties not supported by the implemented interface, so ignore those or\n+         * the serialized YAML will contain SmallRye-only properties.\n+         *\n+         * @param javaBean the bean being serialized\n+         * @param property the property being serialized\n+         * @return true if the property should be processes; false otherwise\n+         */\n+        private boolean okToProcess(Object javaBean, Property property) {\n+            boolean reject = false;\n+            reject |= Parameter.class.isAssignableFrom(javaBean.getClass()) && property.getName().equals(\"hidden\");", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNzM2NQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386637365", "bodyText": "Oh, never mind.", "author": "ljnelson", "createdAt": "2020-03-02T20:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTE3OQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825179", "bodyText": "I'm adding a comment in the code explaining. If, over time, we have to add more cases to ignore then we can just add a new line similar to the existing reject |= ... one for each case to be skipped without perturbing the other lines in the method.", "author": "tjquinno", "createdAt": "2020-03-04T17:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTIxOA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386635218", "bodyText": "Nit: why reverse the order?", "author": "ljnelson", "createdAt": "2020-03-02T20:35:38Z", "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private void processExtensions(MappingNode node, Object javaBean) {\n+            if (!Extensible.class.isAssignableFrom(javaBean.getClass())) {\n+                return;\n+            }\n+\n+            List<NodeTuple> tuples = new ArrayList<>(node.getValue());\n+\n+            if (tuples.isEmpty()) {\n+                return;\n+            }\n+            List<NodeTuple> updatedTuples = new ArrayList<>();\n+\n+            tuples.forEach(tuple -> {\n+                Node keyNode = tuple.getKeyNode();\n+                if (keyNode.getTag().equals(Tag.STR)) {\n+                    String key = ((ScalarNode) keyNode).getValue();\n+                    if (key.equals(EXTENSIONS)) {\n+                        Node valueNode = tuple.getValueNode();\n+                        if (valueNode.getNodeId().equals(NodeId.mapping)) {\n+                            MappingNode extensions = MappingNode.class.cast(valueNode);\n+                            updatedTuples.addAll(extensions.getValue());\n+                        }\n+                    } else {\n+                        updatedTuples.add(tuple);\n+                    }\n+                } else {\n+                    updatedTuples.add(tuple);\n+                }\n+            });\n+            node.setValue(updatedTuples);\n+        }\n+\n+        /**\n+         * Some SmallRye implementation classes have properties not supported by the implemented interface, so ignore those or\n+         * the serialized YAML will contain SmallRye-only properties.\n+         *\n+         * @param javaBean the bean being serialized\n+         * @param property the property being serialized\n+         * @return true if the property should be processes; false otherwise\n+         */\n+        private boolean okToProcess(Object javaBean, Property property) {\n+            boolean reject = false;\n+            reject |= Parameter.class.isAssignableFrom(javaBean.getClass()) && property.getName().equals(\"hidden\");\n+            return !reject;\n+        }\n+    }\n+\n+    /**\n+     * Suppress the tag output for SmallRye implementation classes so the resulting document can be read into any MP OpenAPI\n+     * implementation, not just SmallRye's.\n+     */\n+    static class TagSuppressingWriter extends PrintWriter {\n+\n+        private static final Pattern SMALLRYE_IMPL_TAG_PATTERN =\n+                Pattern.compile(\"!!\" + Pattern.quote(OpenAPIImpl.class.getPackage().getName()) + \".+$\");\n+\n+        TagSuppressingWriter(Writer out) {\n+            super(out);\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            int effLen = detag(CharBuffer.wrap(cbuf), off, len);\n+            if (effLen > 0) {\n+                super.write(cbuf, off, effLen);\n+            }\n+        }\n+\n+        @Override\n+        public void write(String s, int off, int len) {\n+            int effLen = detag(s, off, len);\n+            if (effLen > 0) {\n+                super.write(s, off, effLen);\n+            }\n+        }\n+\n+        private int detag(CharSequence cs, int off, int len) {\n+            int result = len;\n+            Matcher m = SMALLRYE_IMPL_TAG_PATTERN.matcher(cs.subSequence(off, off + len));\n+            if (m.matches()) {\n+                result = len - (m.end() - m.start());\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    private static class DelegatingProperty extends Property {\n+\n+        private final Property delegate;\n+\n+        private DelegatingProperty(Property delegate, String name) {\n+            super(name, delegate.getType());", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTIyNg==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825226", "bodyText": "No longer an issue. See below.", "author": "tjquinno", "createdAt": "2020-03-04T17:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTUzMw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386635533", "bodyText": "Surprise: was expecting delegate.  Don't know if that's on purpose or not.", "author": "ljnelson", "createdAt": "2020-03-02T20:36:14Z", "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private void processExtensions(MappingNode node, Object javaBean) {\n+            if (!Extensible.class.isAssignableFrom(javaBean.getClass())) {\n+                return;\n+            }\n+\n+            List<NodeTuple> tuples = new ArrayList<>(node.getValue());\n+\n+            if (tuples.isEmpty()) {\n+                return;\n+            }\n+            List<NodeTuple> updatedTuples = new ArrayList<>();\n+\n+            tuples.forEach(tuple -> {\n+                Node keyNode = tuple.getKeyNode();\n+                if (keyNode.getTag().equals(Tag.STR)) {\n+                    String key = ((ScalarNode) keyNode).getValue();\n+                    if (key.equals(EXTENSIONS)) {\n+                        Node valueNode = tuple.getValueNode();\n+                        if (valueNode.getNodeId().equals(NodeId.mapping)) {\n+                            MappingNode extensions = MappingNode.class.cast(valueNode);\n+                            updatedTuples.addAll(extensions.getValue());\n+                        }\n+                    } else {\n+                        updatedTuples.add(tuple);\n+                    }\n+                } else {\n+                    updatedTuples.add(tuple);\n+                }\n+            });\n+            node.setValue(updatedTuples);\n+        }\n+\n+        /**\n+         * Some SmallRye implementation classes have properties not supported by the implemented interface, so ignore those or\n+         * the serialized YAML will contain SmallRye-only properties.\n+         *\n+         * @param javaBean the bean being serialized\n+         * @param property the property being serialized\n+         * @return true if the property should be processes; false otherwise\n+         */\n+        private boolean okToProcess(Object javaBean, Property property) {\n+            boolean reject = false;\n+            reject |= Parameter.class.isAssignableFrom(javaBean.getClass()) && property.getName().equals(\"hidden\");\n+            return !reject;\n+        }\n+    }\n+\n+    /**\n+     * Suppress the tag output for SmallRye implementation classes so the resulting document can be read into any MP OpenAPI\n+     * implementation, not just SmallRye's.\n+     */\n+    static class TagSuppressingWriter extends PrintWriter {\n+\n+        private static final Pattern SMALLRYE_IMPL_TAG_PATTERN =\n+                Pattern.compile(\"!!\" + Pattern.quote(OpenAPIImpl.class.getPackage().getName()) + \".+$\");\n+\n+        TagSuppressingWriter(Writer out) {\n+            super(out);\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            int effLen = detag(CharBuffer.wrap(cbuf), off, len);\n+            if (effLen > 0) {\n+                super.write(cbuf, off, effLen);\n+            }\n+        }\n+\n+        @Override\n+        public void write(String s, int off, int len) {\n+            int effLen = detag(s, off, len);\n+            if (effLen > 0) {\n+                super.write(s, off, effLen);\n+            }\n+        }\n+\n+        private int detag(CharSequence cs, int off, int len) {\n+            int result = len;\n+            Matcher m = SMALLRYE_IMPL_TAG_PATTERN.matcher(cs.subSequence(off, off + len));\n+            if (m.matches()) {\n+                result = len - (m.end() - m.start());\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    private static class DelegatingProperty extends Property {\n+\n+        private final Property delegate;\n+\n+        private DelegatingProperty(Property delegate, String name) {\n+            super(name, delegate.getType());\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public Class<?> getType() {\n+            return delegate.getType();\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return delegate.getActualTypeArguments();\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return super.getName();", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTI1MQ==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825251", "bodyText": "The whole DelegatingProperty class (and the logic that instantiated it) was a holdover from an earlier approach that's no longer used. Removed.", "author": "tjquinno", "createdAt": "2020-03-04T17:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTc2NA==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386635764", "bodyText": "Nit: java.beans, yes?", "author": "ljnelson", "createdAt": "2020-03-02T20:36:42Z", "path": "openapi/src/main/java/module-info.java", "diffHunk": "@@ -27,6 +27,9 @@\n     requires jandex;\n \n     requires smallrye.open.api;\n+    requires java.json;\n+    requires java.desktop; // for java.bean package", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTI5Nw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825297", "bodyText": "Fixed", "author": "tjquinno", "createdAt": "2020-03-04T17:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNjIwMw==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386636203", "bodyText": "Nit: any kind of close operation that needs to be performed here?", "author": "ljnelson", "createdAt": "2020-03-02T20:37:40Z", "path": "openapi/src/test/java/io/helidon/openapi/TestUtil.java", "diffHunk": "@@ -221,6 +222,12 @@ public static JsonStructure jsonFromResponse(HttpURLConnection cnx) throws IOExc\n         return result;\n     }\n \n+    static JsonStructure jsonFromReader(Reader reader) {\n+        JsonReader jsonReader = JSON_READER_FACTORY.createReader(reader);\n+        JsonStructure result = jsonReader.read();", "originalCommit": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyNTM0Ng==", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r387825346", "bodyText": "Yes. Done.", "author": "tjquinno", "createdAt": "2020-03-04T17:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNjIwMw=="}], "type": "inlineReview"}, {"oid": "29c648df31bcbfdbd917d384347a7a6e82a69ee1", "url": "https://github.com/oracle/helidon/commit/29c648df31bcbfdbd917d384347a7a6e82a69ee1", "message": "Respond to review comments", "committedDate": "2020-03-03T11:34:30Z", "type": "commit"}, {"oid": "e9b79e8db3a05f860502508a6ceb2fc5aa32a832", "url": "https://github.com/oracle/helidon/commit/e9b79e8db3a05f860502508a6ceb2fc5aa32a832", "message": "Review comment adjustments", "committedDate": "2020-03-04T15:53:30Z", "type": "commit"}, {"oid": "7b4cab195a1969dd959bcecf854f7a99e8c8ea30", "url": "https://github.com/oracle/helidon/commit/7b4cab195a1969dd959bcecf854f7a99e8c8ea30", "message": "A few other changes inspired by review comments", "committedDate": "2020-03-04T17:33:09Z", "type": "commit"}, {"oid": "c93cdee40e726932cbc5ea4529e270de198b9a3a", "url": "https://github.com/oracle/helidon/commit/c93cdee40e726932cbc5ea4529e270de198b9a3a", "message": "Trivial change to trigger pipeline", "committedDate": "2020-03-04T21:39:03Z", "type": "commit"}, {"oid": "5798e0268a92d83df654872fa22c0b9a142d6de4", "url": "https://github.com/oracle/helidon/commit/5798e0268a92d83df654872fa22c0b9a142d6de4", "message": "Concurrent changes", "committedDate": "2020-03-08T23:48:03Z", "type": "commit"}, {"oid": "445993b7d5c5d5dd23baa0688d9b2ef81b6ff713", "url": "https://github.com/oracle/helidon/commit/445993b7d5c5d5dd23baa0688d9b2ef81b6ff713", "message": "Exclude JSON-B via jakarta (as well as existing exclusion)", "committedDate": "2020-03-08T23:49:47Z", "type": "commit"}, {"oid": "88ce4740885f00d2b67e838cc0ab00d98f893a4a", "url": "https://github.com/oracle/helidon/commit/88ce4740885f00d2b67e838cc0ab00d98f893a4a", "message": "Fix missing quote marks around numeric key in example openapi yaml file", "committedDate": "2020-03-09T04:42:09Z", "type": "commit"}, {"oid": "f12d92359ecc018537a04ad3d78ddaa9b533ebb2", "url": "https://github.com/oracle/helidon/commit/f12d92359ecc018537a04ad3d78ddaa9b533ebb2", "message": "Fix copyright error", "committedDate": "2020-03-09T04:49:11Z", "type": "commit"}, {"oid": "4b8f8ecdd6f1a836e9fa0c6b4a21191566d0562c", "url": "https://github.com/oracle/helidon/commit/4b8f8ecdd6f1a836e9fa0c6b4a21191566d0562c", "message": "Old exclusion no longer needed; just the one for jakarta.json.bind-api now", "committedDate": "2020-03-09T12:35:21Z", "type": "commit"}, {"oid": "ed54720e28666124efeab0c718000b25b91b2d87", "url": "https://github.com/oracle/helidon/commit/ed54720e28666124efeab0c718000b25b91b2d87", "message": "Concurrent changes", "committedDate": "2020-03-09T14:48:59Z", "type": "commit"}]}