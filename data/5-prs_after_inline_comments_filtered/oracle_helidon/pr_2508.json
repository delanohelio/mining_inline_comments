{"pr_number": 2508, "pr_title": "Concat array enhancement", "pr_createdAt": "2020-11-08T12:35:20Z", "pr_url": "https://github.com/oracle/helidon/pull/2508", "timeline": [{"oid": "edff27426ca6a155c5f07fd5b71460ddfb1ec228", "url": "https://github.com/oracle/helidon/commit/edff27426ca6a155c5f07fd5b71460ddfb1ec228", "message": "Concat array enhancement\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-11-24T08:21:30Z", "type": "forcePushed"}, {"oid": "edff27426ca6a155c5f07fd5b71460ddfb1ec228", "url": "https://github.com/oracle/helidon/commit/edff27426ca6a155c5f07fd5b71460ddfb1ec228", "message": "Concat array enhancement\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2020-11-24T08:21:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4MTEyNw==", "url": "https://github.com/oracle/helidon/pull/2508#discussion_r529581127", "bodyText": "Two things need doing:\nlong oldProduced = produced; on the line before change of REQUESTED, then use oldProduced to the end of this method.\nThis addresses the case raised by @akarnok - concurrent request results in concurrent onNext, which updates produced.\nand\nREQUESTED.setVolatile(this, p0) to replace setOpaque - opaque doesn't guarantee ordering with other stores.", "author": "olotenko", "createdAt": "2020-11-24T14:21:35Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/MultiConcatArray.java", "diffHunk": "@@ -35,31 +36,89 @@\n     public void subscribe(Flow.Subscriber<? super T> subscriber) {\n         ConcatArraySubscriber<T> parent = new ConcatArraySubscriber<>(subscriber, sources);\n         subscriber.onSubscribe(parent);\n-        parent.nextSource();\n+        parent.nextSource(parent.produced);\n     }\n \n-    static final class ConcatArraySubscriber<T> extends SubscriptionArbiter\n-    implements Flow.Subscriber<T> {\n+    protected static final class ConcatArraySubscriber<T>\n+    implements Flow.Subscriber<T>, Flow.Subscription {\n \n         private final Flow.Subscriber<? super T> downstream;\n \n         private final Flow.Publisher<T>[] sources;\n \n-        private final AtomicInteger wip;\n+        private Flow.Subscription subscription;\n \n         private int index;\n \n-        private long produced;\n+        private long produced = INIT;\n+\n+        private volatile long requested = SEE_OTHER;\n+        private volatile long pending = INIT;\n+        private volatile Thread lastThreadCompleting;\n+        private boolean redo;\n+\n+        static final long BAD = Long.MIN_VALUE;\n+        static final long CANCEL = Long.MIN_VALUE + 1;\n+        static final long SEE_OTHER = Long.MIN_VALUE + 2;\n+        static final long INIT = Long.MIN_VALUE + 3;\n+\n+        static final VarHandle REQUESTED;\n+        static final VarHandle PENDING;\n+        static final VarHandle LASTTHREADCOMPLETING;\n+\n+        static {\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+                REQUESTED = lookup.findVarHandle(ConcatArraySubscriber.class, \"requested\", long.class);\n+                PENDING = lookup.findVarHandle(ConcatArraySubscriber.class, \"pending\", long.class);\n+                LASTTHREADCOMPLETING = lookup\n+                        .findVarHandle(ConcatArraySubscriber.class, \"lastThreadCompleting\", Thread.class);\n+            } catch (Exception e) {\n+                throw new Error(\"Expected lookup to succeed\", e);\n+            }\n+        }\n \n         ConcatArraySubscriber(Flow.Subscriber<? super T> downstream, Flow.Publisher<T>[] sources) {\n             this.downstream = downstream;\n             this.sources = sources;\n-            this.wip = new AtomicInteger();\n         }\n \n         @Override\n         public void onSubscribe(Flow.Subscription subscription) {\n-            super.setSubscription(subscription);\n+            long p0 = pending;\n+            if (p0 == CANCEL) {\n+               subscription.cancel();\n+               return;\n+            }\n+\n+            produced++; // assert: matching request(1) has been done by nextSource()\n+            this.subscription = subscription;\n+            // assert: requested == SEE_OTHER\n+            REQUESTED.setOpaque(this, p0); // assert: p0 is guaranteed to be a value of requested never seen before", "originalCommit": "edff27426ca6a155c5f07fd5b71460ddfb1ec228", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67f59cbce720744bf1057da1e9c734ae26e9a4d1", "url": "https://github.com/oracle/helidon/commit/67f59cbce720744bf1057da1e9c734ae26e9a4d1", "message": "Assumes some Publishers are not fully conformant and may issue onNext/onComplete concurrently with onSubscribe in response to concurrent request().\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2021-01-06T17:18:51Z", "type": "commit"}, {"oid": "4b36aeacac8d97355b89b67016cfae4ced655846", "url": "https://github.com/oracle/helidon/commit/4b36aeacac8d97355b89b67016cfae4ced655846", "message": "Copyright\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>", "committedDate": "2021-01-06T20:17:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzMzODQ5NA==", "url": "https://github.com/oracle/helidon/pull/2508#discussion_r553338494", "bodyText": "Reading this again, strictly speaking this fence is not needed, because we have stronger fences between the stores targeted by this fence. But no need to change the code as the cost of this fence on the target platforms is zero.", "author": "olotenko", "createdAt": "2021-01-07T13:51:25Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/MultiConcatArray.java", "diffHunk": "@@ -70,38 +141,215 @@ public void onNext(T item) {\n \n         @Override\n         public void onError(Throwable throwable) {\n+            REQUESTED.setOpaque(this, CANCEL);\n             downstream.onError(throwable);\n         }\n \n         @Override\n         public void onComplete() {\n-            long produced = this.produced;\n-            if (produced != 0L) {\n-                this.produced = 0L;\n-                super.produced(produced);\n+            Thread current = Thread.currentThread();\n+            if (LASTTHREADCOMPLETING.getOpaque(this) == current) {\n+                redo = true;\n+                return;\n+            }\n+\n+            LASTTHREADCOMPLETING.setOpaque(this, current);\n+            VarHandle.storeStoreFence();", "originalCommit": "4b36aeacac8d97355b89b67016cfae4ced655846", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}