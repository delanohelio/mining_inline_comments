{"pr_number": 2591, "pr_title": "Support for HTTP pipelining", "pr_createdAt": "2020-12-09T16:08:10Z", "pr_url": "https://github.com/oracle/helidon/pull/2591", "timeline": [{"oid": "26946571b2330925ea55a8d684c8267ad797a618", "url": "https://github.com/oracle/helidon/commit/26946571b2330925ea55a8d684c8267ad797a618", "message": "Initial support for HTTP pipelining with test.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-07T19:38:27Z", "type": "commit"}, {"oid": "9099b7d776366c8189daec7f31a0982ab0b43dd7", "url": "https://github.com/oracle/helidon/commit/9099b7d776366c8189daec7f31a0982ab0b43dd7", "message": "Some minor fixes and removal of unused thread variable.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-07T20:57:33Z", "type": "commit"}, {"oid": "223e7b3a3d9e2a7f4d768c28acf7758caca9b42a", "url": "https://github.com/oracle/helidon/commit/223e7b3a3d9e2a7f4d768c28acf7758caca9b42a", "message": "New pipelining test that uses HTTP/2 and OkHttp client.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-08T21:01:31Z", "type": "commit"}, {"oid": "329eef2a5f798e674d9228cc63b080dca89b6720", "url": "https://github.com/oracle/helidon/commit/329eef2a5f798e674d9228cc63b080dca89b6720", "message": "Some minor changes and comments.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-09T15:57:01Z", "type": "commit"}, {"oid": "45963f04d7432f5a76ffd445b305c188df67396a", "url": "https://github.com/oracle/helidon/commit/45963f04d7432f5a76ffd445b305c188df67396a", "message": "Removed unused static.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-09T16:10:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzODkwMw==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539538903", "bodyText": "Readability nit: prev should probably be something like previousRequestFuture to \"look like\", e.g., responseFuture, headersFuture, etc.", "author": "ljnelson", "createdAt": "2020-12-09T18:19:12Z", "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -79,27 +78,28 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n+    private CompletableFuture<?> prev;\n \n     /**\n      * @param ctx the channel handler context\n      * @param request the request\n      * @param requestContentConsumed whether the request content is consumed\n-     * @param thread the outbound event loop thread which will be used to write the response\n+     * @param prev Future that represents previous request completion for HTTP pipelining\n      * @param requestId the correlation ID that is added to the log statements\n      */\n     BareResponseImpl(ChannelHandlerContext ctx,\n                      HttpRequest request,\n                      BooleanSupplier requestContentConsumed,\n-                     Thread thread,\n+                     CompletableFuture<?> prev,", "originalCommit": "45963f04d7432f5a76ffd445b305c188df67396a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MDIyNw==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539550227", "bodyText": "Good point", "author": "spericas", "createdAt": "2020-12-09T18:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzODkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MTc0MA==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539541740", "bodyText": "await(10, TimeUnit.SECONDS)", "author": "danielkec", "createdAt": "2020-12-09T18:23:13Z", "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver;\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.Http;\n+import io.helidon.webserver.utils.SocketHttpClient;\n+\n+import okhttp3.Call;\n+import okhttp3.Callback;\n+import okhttp3.Interceptor;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Protocol;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+\n+/**\n+ * Test support for HTTP 1.1 pipelining.\n+ */\n+public class HttpPipelineTest {\n+    private static final Logger LOGGER = Logger.getLogger(HttpPipelineTest.class.getName());\n+\n+    private static WebServer webServer;\n+    private static AtomicInteger counter = new AtomicInteger(0);\n+    private static ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(1);\n+    private static OkHttpClient client;\n+\n+    private static class LoggingInterceptor implements Interceptor {\n+        @Override\n+        public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException {\n+            Request request = chain.request();\n+\n+            long t1 = System.nanoTime();\n+            System.out.println(String.format(\"Sending request %s on %s%n%s\",\n+                    request.url(), chain.connection(), request.headers()));\n+\n+            Response response = chain.proceed(request);\n+\n+            long t2 = System.nanoTime();\n+            System.out.println(String.format(\"Received response for %s in %.1fms%nProtocol is %s%n%s\",\n+                    response.request().url(), (t2 - t1) / 1e6d, response.protocol(), response.headers()));\n+\n+            return response;\n+        }\n+    }\n+\n+    @BeforeAll\n+    public static void startServer() throws Exception {\n+        startServer(0);\n+    }\n+\n+    @AfterAll\n+    public static void close() throws Exception {\n+        if (webServer != null) {\n+            webServer.shutdown()\n+                    .toCompletableFuture()\n+                    .get(10, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private static void startServer(int port) throws Exception {\n+        webServer = WebServer.builder()\n+                .experimental(ExperimentalConfiguration.builder().http2(\n+                        Http2Configuration.builder().enable(true).build()).build())\n+                .port(port)\n+                .routing(Routing.builder()\n+                        .put(\"/\", (req, res) -> {\n+                            counter.set(0);\n+                            res.send();\n+                        })\n+                        .get(\"/\", (req, res) -> {\n+                            int n = counter.getAndIncrement();\n+                            int delay = (n % 2 == 0) ? 1000 : 0;    // alternate delay 1 second and no delay\n+                            executor.schedule(() -> res.status(Http.Status.OK_200).send(\"Response \" + n + \"\\n\"),\n+                                    delay, TimeUnit.MILLISECONDS);\n+                        })\n+                        .build())\n+                .build()\n+                .start()\n+                .toCompletableFuture()\n+                .get(10, TimeUnit.SECONDS);", "originalCommit": "45963f04d7432f5a76ffd445b305c188df67396a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MDg1MA==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539550850", "bodyText": "Copy/paste, yes too long.", "author": "spericas", "createdAt": "2020-12-09T18:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0NDg4Mw==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539544883", "bodyText": "Will be the assertion error thrown on correct thread?", "author": "danielkec", "createdAt": "2020-12-09T18:27:44Z", "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver;\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.Http;\n+import io.helidon.webserver.utils.SocketHttpClient;\n+\n+import okhttp3.Call;\n+import okhttp3.Callback;\n+import okhttp3.Interceptor;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Protocol;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+\n+/**\n+ * Test support for HTTP 1.1 pipelining.\n+ */\n+public class HttpPipelineTest {\n+    private static final Logger LOGGER = Logger.getLogger(HttpPipelineTest.class.getName());\n+\n+    private static WebServer webServer;\n+    private static AtomicInteger counter = new AtomicInteger(0);\n+    private static ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(1);\n+    private static OkHttpClient client;\n+\n+    private static class LoggingInterceptor implements Interceptor {\n+        @Override\n+        public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException {\n+            Request request = chain.request();\n+\n+            long t1 = System.nanoTime();\n+            System.out.println(String.format(\"Sending request %s on %s%n%s\",\n+                    request.url(), chain.connection(), request.headers()));\n+\n+            Response response = chain.proceed(request);\n+\n+            long t2 = System.nanoTime();\n+            System.out.println(String.format(\"Received response for %s in %.1fms%nProtocol is %s%n%s\",\n+                    response.request().url(), (t2 - t1) / 1e6d, response.protocol(), response.headers()));\n+\n+            return response;\n+        }\n+    }\n+\n+    @BeforeAll\n+    public static void startServer() throws Exception {\n+        startServer(0);\n+    }\n+\n+    @AfterAll\n+    public static void close() throws Exception {\n+        if (webServer != null) {\n+            webServer.shutdown()\n+                    .toCompletableFuture()\n+                    .get(10, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private static void startServer(int port) throws Exception {\n+        webServer = WebServer.builder()\n+                .experimental(ExperimentalConfiguration.builder().http2(\n+                        Http2Configuration.builder().enable(true).build()).build())\n+                .port(port)\n+                .routing(Routing.builder()\n+                        .put(\"/\", (req, res) -> {\n+                            counter.set(0);\n+                            res.send();\n+                        })\n+                        .get(\"/\", (req, res) -> {\n+                            int n = counter.getAndIncrement();\n+                            int delay = (n % 2 == 0) ? 1000 : 0;    // alternate delay 1 second and no delay\n+                            executor.schedule(() -> res.status(Http.Status.OK_200).send(\"Response \" + n + \"\\n\"),\n+                                    delay, TimeUnit.MILLISECONDS);\n+                        })\n+                        .build())\n+                .build()\n+                .start()\n+                .toCompletableFuture()\n+                .get(10, TimeUnit.SECONDS);\n+\n+        OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder()\n+                .addNetworkInterceptor(new LoggingInterceptor())\n+                .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE));\n+        client = clientBuilder.build();\n+\n+        LOGGER.info(\"Started server at: https://localhost:\" + webServer.port());\n+    }\n+\n+    /**\n+     * Pipelines request_0 and request_1 and makes sure responses are returned in the\n+     * correct order. Note that the server will delay the response for request_0 to\n+     * make sure they are properly synchronized.\n+     *\n+     * @throws Exception If there are connection problems.\n+     */\n+    @Test\n+    public void testPipelining() throws Exception {\n+        try (SocketHttpClient s = new SocketHttpClient(webServer)) {\n+            s.request(Http.Method.PUT, \"/\");        // reset server\n+            s.request(Http.Method.GET, \"/\");        // request_0\n+            s.request(Http.Method.GET, \"/\");        // request_1\n+            String put = s.receive();\n+            assertThat(put, notNullValue());\n+            String get0 = s.receive();\n+            assertThat(get0, containsString(\"Response 0\"));\n+            String get1 = s.receive();\n+            assertThat(get1, containsString(\"Response 1\"));\n+        }\n+    }\n+\n+    /**\n+     * Same as previous test but using HTTP/2 and OkHttp as async client.\n+     */\n+    @Test\n+    public void testPipeliningHttp2() throws Exception {\n+        MediaType mt = MediaType.get(\"text/plain\");\n+        URL url = new URL(\"http://localhost:\" + webServer.port() + \"/\");\n+        Request put = new Request.Builder().url(url).put(RequestBody.create(mt, \"\")).build();\n+        client.newCall(put).execute();\n+\n+        Request get = new Request.Builder().url(url).build();\n+        CompletableFuture<?> cf0 = new CompletableFuture<>();\n+        CompletableFuture<?> cf1 = new CompletableFuture<>();\n+\n+        client.newCall(get).enqueue(new Callback() {\n+            @Override\n+            public void onFailure(Call call, IOException e) {\n+                cf0.completeExceptionally(e);\n+            }\n+\n+            @Override\n+            public void onResponse(Call call, Response r0) throws IOException {\n+                LOGGER.info(\"Received r0\");\n+                if (cf1.isDone()) {\n+                    LOGGER.info(\"Expected r0 before r1\");\n+                    cf0.completeExceptionally(new RuntimeException(\"Expected r0 before r1\"));\n+                } else {\n+                    assertThat(r0.body().string(), containsString(\"Response 0\"));", "originalCommit": "45963f04d7432f5a76ffd445b305c188df67396a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MTY0Mg==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539551642", "bodyText": "No, will fix this.", "author": "spericas", "createdAt": "2020-12-09T18:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0NDg4Mw=="}], "type": "inlineReview"}, {"oid": "47de1a64f25fa7f1c60a30c513f5c6af35042705", "url": "https://github.com/oracle/helidon/commit/47de1a64f25fa7f1c60a30c513f5c6af35042705", "message": "A few minor fixes: variable renames, removal of artifact version in pom, etc.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-09T18:44:06Z", "type": "commit"}, {"oid": "c3e33bab7b1bfbaf7eeef509008314663713fa3a", "url": "https://github.com/oracle/helidon/commit/c3e33bab7b1bfbaf7eeef509008314663713fa3a", "message": "Shorten variable name.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-09T18:46:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539560712", "bodyText": "I am unsure of the threading implications of who can modify this field, but I see it being modified in several places.  Does it need to be volatile?", "author": "ljnelson", "createdAt": "2020-12-09T18:50:46Z", "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -78,19 +78,19 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n-    private CompletableFuture<?> previousRequestFuture;\n+    private CompletableFuture<?> prevRequestFuture;", "originalCommit": "c3e33bab7b1bfbaf7eeef509008314663713fa3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2OTQ4Mw==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539569483", "bodyText": "Reading and writing this variable as a volatile as we do in onNext is odd and typically flagged as a problem (non-atomic update). Method onNext cannot be called in parallel, but it can be called sequentially in different threads. Perhaps this should be an AtomicReference instead.", "author": "spericas", "createdAt": "2020-12-09T19:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MTMyNA==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539571324", "bodyText": "\u2026although AtomicReference is really just volatile memory semantics on steroids, right?  Up to you; just saw it being assigned in various places and wanted to double-check.", "author": "ljnelson", "createdAt": "2020-12-09T19:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1OTYwNQ==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539659605", "bodyText": "onNext/onComplete from which these are invoked are totally ordered. The inter-thread semantics are ensured by the Publisher that calls these.\nOn the other hand, if you have a non-compliant Publisher that may issue onNext concurrently, the chaining logic is going to be broken even if prev is volatile.", "author": "olotenko", "createdAt": "2020-12-09T21:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg=="}], "type": "inlineReview"}, {"oid": "7bcb7b9b7b2ea7e9de585483e9acebf0266b1c41", "url": "https://github.com/oracle/helidon/commit/7bcb7b9b7b2ea7e9de585483e9acebf0266b1c41", "message": "Use volatile for prevRequestFuture field.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-09T19:26:00Z", "type": "commit"}, {"oid": "364b368e62057b72972d4304748b197dd400ac04", "url": "https://github.com/oracle/helidon/commit/364b368e62057b72972d4304748b197dd400ac04", "message": "One more variable rename.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-09T19:29:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MTE1MQ==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539661151", "bodyText": "Since we are into renaming, I'd like to make sure the meaning is documented to be not only previous request, but really any chunk.\n(N.B.: onNext may push several content chunks for the same request, so prev would reference the future for those chunks)", "author": "olotenko", "createdAt": "2020-12-09T21:28:33Z", "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -78,19 +78,19 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n-    private CompletableFuture<?> prev;\n+    private CompletableFuture<?> previousRequestFuture;", "originalCommit": "47de1a64f25fa7f1c60a30c513f5c6af35042705", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba7d4347fca194a54307b3f34bcf3badbec882de", "url": "https://github.com/oracle/helidon/commit/ba7d4347fca194a54307b3f34bcf3badbec882de", "message": "Cleanup use of volatile keyword in BareResponseImpl. Renamed variable.\n\nSigned-off-by: Santiago Pericasgeertsen <santiago.pericasgeertsen@oracle.com>", "committedDate": "2020-12-10T16:29:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NzQ4Nw==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r540467487", "bodyText": "Why declare local var?", "author": "danielkec", "createdAt": "2020-12-10T20:16:22Z", "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "diffHunk": "@@ -144,7 +156,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n             // Queue, context and publisher creation\n             ReferenceHoldingQueue<DataChunk> queue = new ReferenceHoldingQueue<>();\n             queues.add(queue);\n-            requestContext = new RequestContext(new HttpRequestScopedPublisher(ctx, queue), request);\n+            RequestContext requestContext = new RequestContext(new HttpRequestScopedPublisher(ctx, queue), request);\n+            this.requestContext = requestContext;\n+", "originalCommit": "ba7d4347fca194a54307b3f34bcf3badbec882de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MjMzMA==", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r540472330", "bodyText": "aha makes sense", "author": "danielkec", "createdAt": "2020-12-10T20:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NzQ4Nw=="}], "type": "inlineReview"}]}