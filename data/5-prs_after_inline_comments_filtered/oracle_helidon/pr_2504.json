{"pr_number": 2504, "pr_title": "Graph QL", "pr_createdAt": "2020-11-05T05:57:26Z", "pr_url": "https://github.com/oracle/helidon/pull/2504", "timeline": [{"oid": "ffe562a111c5a2587097b588986755bff99437b2", "url": "https://github.com/oracle/helidon/commit/ffe562a111c5a2587097b588986755bff99437b2", "message": "futher updates", "committedDate": "2020-11-05T03:44:30Z", "type": "commit"}, {"oid": "f10d39038a8b59a6d0aafbe99c9617b9fafbd823", "url": "https://github.com/oracle/helidon/commit/f10d39038a8b59a6d0aafbe99c9617b9fafbd823", "message": "Progress on adding Builders", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "20299faa67f7bf1046f442ce4b0e52aab8614d79", "url": "https://github.com/oracle/helidon/commit/20299faa67f7bf1046f442ce4b0e52aab8614d79", "message": "further work on builders", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "1dd371d87309653ee94edc0e927b642039b43140", "url": "https://github.com/oracle/helidon/commit/1dd371d87309653ee94edc0e927b642039b43140", "message": "formatting", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "0562b0c52d0e751332206d7b9c648aa742078930", "url": "https://github.com/oracle/helidon/commit/0562b0c52d0e751332206d7b9c648aa742078930", "message": "Remove redudant code", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "c1f42d8cfd9024b2b059ba2db6b5d0168457029b", "url": "https://github.com/oracle/helidon/commit/c1f42d8cfd9024b2b059ba2db6b5d0168457029b", "message": "Upgrade to microprofile-graphql official 1.0.3 release!", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "3e6cf15b0b1fd4b82502ce145640692e8d942e7a", "url": "https://github.com/oracle/helidon/commit/3e6cf15b0b1fd4b82502ce145640692e8d942e7a", "message": "Add builders and fix checkstyle", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "a83efef61eb9b9cb4504f49542591e35876f48ea", "url": "https://github.com/oracle/helidon/commit/a83efef61eb9b9cb4504f49542591e35876f48ea", "message": "code cleanup", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "a12c42365a248c9c69bcfba37143b916f93ff79d", "url": "https://github.com/oracle/helidon/commit/a12c42365a248c9c69bcfba37143b916f93ff79d", "message": "Add message about [][]", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "d0737c098d292d1b27a398433ef4dd2586449b52", "url": "https://github.com/oracle/helidon/commit/d0737c098d292d1b27a398433ef4dd2586449b52", "message": "Doco an config", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "d0220be4e656757ed944c6e6b62d335cee9b42ae", "url": "https://github.com/oracle/helidon/commit/d0220be4e656757ed944c6e6b62d335cee9b42ae", "message": "Minor cleanup", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "df319f7fc71fb9345f87ec5341509994455c50b9", "url": "https://github.com/oracle/helidon/commit/df319f7fc71fb9345f87ec5341509994455c50b9", "message": "Add examples", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "ee4cc1bcbadf9c366380d37162cc31aa4ba5b53e", "url": "https://github.com/oracle/helidon/commit/ee4cc1bcbadf9c366380d37162cc31aa4ba5b53e", "message": "further example updates", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "21508d780cbf74773c5f27c1bb0ae63faade5cf7", "url": "https://github.com/oracle/helidon/commit/21508d780cbf74773c5f27c1bb0ae63faade5cf7", "message": "Move example under microprofile", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "6751556bcd621ff558e6ab367f6fcb9ea1580067", "url": "https://github.com/oracle/helidon/commit/6751556bcd621ff558e6ab367f6fcb9ea1580067", "message": "Minor", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "af5a52578fb7a84baf9913e0babb3d8963224983", "url": "https://github.com/oracle/helidon/commit/af5a52578fb7a84baf9913e0babb3d8963224983", "message": "add graphql example under mp", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "80ce0bbae6c688ff62b52e1106306be324f89f7d", "url": "https://github.com/oracle/helidon/commit/80ce0bbae6c688ff62b52e1106306be324f89f7d", "message": "update to graphql example", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "59225b9bb60e50deebfbc1e306f69cbd1b0d309a", "url": "https://github.com/oracle/helidon/commit/59225b9bb60e50deebfbc1e306f69cbd1b0d309a", "message": "update to graphql example", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "ac0e48447eea6572e240dc60069544f4e491b2a9", "url": "https://github.com/oracle/helidon/commit/ac0e48447eea6572e240dc60069544f4e491b2a9", "message": "update to graphql example", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "0f173d03cfa294770fdb8b8acd164c15165ff4e6", "url": "https://github.com/oracle/helidon/commit/0f173d03cfa294770fdb8b8acd164c15165ff4e6", "message": "update to graphql example", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "4abb628255add6ea9337dde460f722ab1d422d7f", "url": "https://github.com/oracle/helidon/commit/4abb628255add6ea9337dde460f722ab1d422d7f", "message": "cleanup", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "657a6cc2255ccd44d203effbf554779beb0816f8", "url": "https://github.com/oracle/helidon/commit/657a6cc2255ccd44d203effbf554779beb0816f8", "message": "Review fixes", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "bedba313a9988254ac131736cd8a606d346a3378", "url": "https://github.com/oracle/helidon/commit/bedba313a9988254ac131736cd8a606d346a3378", "message": "Code updates", "committedDate": "2020-11-05T03:44:31Z", "type": "commit"}, {"oid": "31c20a46366f51a3dfa30bc438ce6d7139fe880d", "url": "https://github.com/oracle/helidon/commit/31c20a46366f51a3dfa30bc438ce6d7139fe880d", "message": "further updates", "committedDate": "2020-11-05T04:07:44Z", "type": "commit"}, {"oid": "56d6eb1617aece4e3801ae77728a7def6f81f746", "url": "https://github.com/oracle/helidon/commit/56d6eb1617aece4e3801ae77728a7def6f81f746", "message": "minor", "committedDate": "2020-11-05T05:55:29Z", "type": "commit"}, {"oid": "69f4e85935a6f55791935ae5da60c77347cce8aa", "url": "https://github.com/oracle/helidon/commit/69f4e85935a6f55791935ae5da60c77347cce8aa", "message": "fix copyright", "committedDate": "2020-11-05T06:14:37Z", "type": "commit"}, {"oid": "d0d4c2c0bb8eaf4bfcc92eeae0cee00a76429279", "url": "https://github.com/oracle/helidon/commit/d0d4c2c0bb8eaf4bfcc92eeae0cee00a76429279", "message": "Using web server.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-06T15:14:12Z", "type": "commit"}, {"oid": "8bcb580983888db6d638f81c98e8b51fa90dc885", "url": "https://github.com/oracle/helidon/commit/8bcb580983888db6d638f81c98e8b51fa90dc885", "message": "No beans.xml\nUsing request scope to execute\nHonoring vetoed beans\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-06T16:03:23Z", "type": "commit"}, {"oid": "56468bea464b6187631c9e124acd795666218a22", "url": "https://github.com/oracle/helidon/commit/56468bea464b6187631c9e124acd795666218a22", "message": "GraphQL SE.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-07T01:08:15Z", "type": "commit"}, {"oid": "4c4f0ba4ad3e1f3709b343b6f7c5a1660f0f7f8e", "url": "https://github.com/oracle/helidon/commit/4c4f0ba4ad3e1f3709b343b6f7c5a1660f0f7f8e", "message": "Native image support.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-07T01:27:37Z", "type": "commit"}, {"oid": "8e2c89e749acdec81cfe14c34012a7a38917db4f", "url": "https://github.com/oracle/helidon/commit/8e2c89e749acdec81cfe14c34012a7a38917db4f", "message": "Javadoc fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-07T12:10:00Z", "type": "commit"}, {"oid": "e89bf0e7270ae61d699389f95c7203f7e7a2dca5", "url": "https://github.com/oracle/helidon/commit/e89bf0e7270ae61d699389f95c7203f7e7a2dca5", "message": "TCK fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-09T12:08:43Z", "type": "commit"}, {"oid": "464ef2c9d0798ce94e7f63439fb7344f844357a3", "url": "https://github.com/oracle/helidon/commit/464ef2c9d0798ce94e7f63439fb7344f844357a3", "message": "TCK fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-09T12:58:38Z", "type": "commit"}, {"oid": "bf256e2dea66f65529af0a0051a03e1387fac954", "url": "https://github.com/oracle/helidon/commit/bf256e2dea66f65529af0a0051a03e1387fac954", "message": "Documentation update.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-09T12:58:46Z", "type": "commit"}, {"oid": "2b205814d1751d8eb38ea3d1a1bd1f8a2ce1f9bf", "url": "https://github.com/oracle/helidon/commit/2b205814d1751d8eb38ea3d1a1bd1f8a2ce1f9bf", "message": "Copyright and checkstyle.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-09T13:59:49Z", "type": "commit"}, {"oid": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "url": "https://github.com/oracle/helidon/commit/2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "message": "Minor typo in doc", "committedDate": "2020-11-12T06:06:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyMDY0MQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522220641", "bodyText": "String delim = isFirst.getAndSet(false) ? \"\" : \", \"; But do we need AtomicBoolean at all?", "author": "danielkec", "createdAt": "2020-11-12T16:02:56Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaDirective.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The representation of a GraphQL directive.\n+ */\n+class SchemaDirective implements ElementGenerator {\n+\n+    /**\n+     * The name of the directive.\n+     */\n+    private final String name;\n+\n+    /**\n+     * The list of arguments for the directive.\n+     */\n+    private final List<SchemaArgument> listSchemaArguments;\n+\n+    /**\n+     * The locations the directive applies to.\n+     */\n+    private final Set<String> setLocations;\n+\n+    /**\n+     * Construct a {@link SchemaDirective}.\n+     *\n+     * @param builder the {@link Builder} to construct from\n+     */\n+    private SchemaDirective(Builder builder) {\n+        this.name = builder.name;\n+        this.listSchemaArguments = builder.listSchemaArguments;\n+        this.setLocations = builder.setLocations;\n+    }\n+\n+    /**\n+     * Fluent API builder to create {@link SchemaDirective}.\n+     *\n+     * @return new builder instance\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Return the GraphQL schema representation of the element.\n+     *\n+     * @return the GraphQL schema representation of the element.\n+     */\n+    @Override\n+    public String getSchemaAsString() {\n+        StringBuilder sb = new StringBuilder(\"directive @\" + name());\n+\n+        if (listSchemaArguments.size() > 0) {\n+            sb.append(\"(\");\n+            AtomicBoolean isFirst = new AtomicBoolean(true);\n+            listSchemaArguments.forEach(a -> {\n+                String delim = isFirst.get() ? \"\" : \", \";\n+                isFirst.set(false);", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzNzk2Ng==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522537966", "bodyText": "Isfirst needs to be (effectivly) final as referenced in lambda, so cannot be boolean or Boolean.", "author": "tmiddlet2666", "createdAt": "2020-11-13T00:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyMDY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyNTgzMQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522225831", "bodyText": "single", "author": "danielkec", "createdAt": "2020-11-12T16:09:48Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/JandexUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.Index;\n+import org.jboss.jandex.IndexReader;\n+\n+/**\n+ * Utilities for working with Jandex indexes.\n+ */\n+class JandexUtils {\n+\n+    private static final Logger LOGGER = Logger.getLogger(JandexUtils.class.getName());\n+\n+    /**\n+     * Default Jandex index file.\n+     */\n+    protected static final String DEFAULT_INDEX_FILE = \"META-INF/jandex.idx\";\n+\n+    /**\n+     * Property to override the default index file. (Normally used for functional tests)\n+     */\n+    public static final String PROP_INDEX_FILE = \"io.helidon.microprofile.graphql.indexfile\";\n+\n+    /**\n+     * The {@link Set} of loaded indexes.\n+     */\n+    private Set<Index> setIndexes = new HashSet<>();\n+\n+    /**\n+     * The file used to load the index.\n+     */\n+    private String indexFile;\n+\n+    /**\n+     * Construct an instance of the utilities class..\n+     */\n+    private JandexUtils() {\n+        indexFile = System.getProperty(PROP_INDEX_FILE, DEFAULT_INDEX_FILE);\n+    }\n+\n+    /**\n+     * Create a new {@link JandexUtils}.\n+     * @return a new {@link JandexUtils}\n+     */\n+    public static JandexUtils create() {\n+         return new JandexUtils();\n+    }\n+\n+    /**\n+     * Load all the index files of the given name.\n+     */\n+    public void loadIndexes() {\n+        try {\n+            List<URL> listUrls = findIndexFiles(indexFile);\n+\n+            // loop through each URL and load the index\n+            for (URL url : listUrls) {\n+                try (InputStream input = url.openStream()) {\n+                    setIndexes.add(new IndexReader(input).read());\n+                } catch (Exception e) {\n+                    LOGGER.warning(\"Unable to load default Jandex index file: \" + url\n+                                           + \" : \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException ignore) {\n+            // any Exception coming from getResources() or toURL() is ignored and\n+            // the Map of indexes remain empty\n+        }\n+    }\n+\n+    /**\n+     * Return all the Jandex index files with the given name. If the name is absolute then\n+     * return the singl file.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzMTcwMA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522231700", "bodyText": "anyMatch could save few iterations, what if there is more than one SchemaType with the same name?", "author": "danielkec", "createdAt": "2020-11-12T16:17:22Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/Schema.java", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import graphql.GraphQLException;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.TypeResolver;\n+import graphql.schema.idl.RuntimeWiring;\n+import graphql.schema.idl.SchemaParser;\n+import graphql.schema.idl.TypeDefinitionRegistry;\n+import graphql.schema.idl.TypeRuntimeWiring;\n+\n+import static graphql.schema.idl.RuntimeWiring.newRuntimeWiring;\n+import static graphql.schema.idl.TypeRuntimeWiring.newTypeWiring;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getSafeClass;\n+\n+/**\n+ * The representation of a GraphQL Schema.\n+ */\n+class Schema implements ElementGenerator {\n+\n+    private static final Logger LOGGER = Logger.getLogger(Schema.class.getName());\n+\n+    /**\n+     * Default query name.\n+     */\n+    public static final String QUERY = \"Query\";\n+\n+    /**\n+     * Default mutation name.\n+     */\n+    public static final String MUTATION = \"Mutation\";\n+\n+    /**\n+     * Default subscription name.\n+     */\n+    public static final String SUBSCRIPTION = \"Subscription\";\n+\n+    /**\n+     * The top level query name.\n+     */\n+    private String queryName;\n+\n+    /**\n+     * The top level mutation name.\n+     */\n+    private String mutationName;\n+\n+    /**\n+     * The top level subscription name.\n+     */\n+    private String subscriptionName;\n+\n+    /**\n+     * List of {@link SchemaType}s for this schema. This includes the standard schema types and other types.\n+     */\n+    private final List<SchemaType> listSchemaTypes;\n+\n+    /**\n+     * List of {@link SchemaScalar}s that should be included in the schema.\n+     */\n+    private final List<SchemaScalar> listSchemaScalars;\n+\n+    /**\n+     * List of {@link SchemaDirective}s that should be included in the schema.\n+     */\n+    private final List<SchemaDirective> listSchemaDirectives;\n+\n+    /**\n+     * List of {@link SchemaInputType}s that should be included in the schema.\n+     */\n+    private final List<SchemaInputType> listInputTypes;\n+\n+    /**\n+     * List of {@link SchemaEnum}s that should be included in the schema.\n+     */\n+    private final List<SchemaEnum> listSchemaEnums;\n+\n+    /**\n+     * Construct a {@link Schema}.\n+     *\n+     * @param builder the {@link Builder} to construct from\n+     */\n+    private Schema(Builder builder) {\n+        this.listSchemaTypes = new ArrayList<>();\n+        this.listSchemaScalars = new ArrayList<>();\n+        this.listSchemaDirectives = new ArrayList<>();\n+        this.listInputTypes = new ArrayList<>();\n+        this.listSchemaEnums = new ArrayList<>();\n+        this.queryName = builder.queryName;\n+        this.subscriptionName = builder.subscriptionName;\n+        this.mutationName = builder.mutationName;\n+    }\n+\n+    /**\n+     * Fluent API builder to create {@link Schema}.\n+     *\n+     * @return new builder instance\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Build a new {@link Schema}.\n+     *\n+     * @return a new {@link Schema}\n+     */\n+    public static Schema create() {\n+        return builder().build();\n+    }\n+\n+    /**\n+     * Generates a {@link GraphQLSchema} from the current discovered schema.\n+     *\n+     * @return {@link GraphQLSchema}\n+     */\n+    public GraphQLSchema generateGraphQLSchema() {\n+        SchemaParser schemaParser = new SchemaParser();\n+        TypeDefinitionRegistry typeDefinitionRegistry;\n+\n+        try {\n+            typeDefinitionRegistry = schemaParser.parse(getSchemaAsString());\n+            return new graphql.schema.idl.SchemaGenerator().makeExecutableSchema(typeDefinitionRegistry, getRuntimeWiring());\n+        } catch (Exception e) {\n+            String message = \"Unable to parse the generated schema\";\n+            LOGGER.warning(message + \"\\n\" + getSchemaAsString());\n+            throw new GraphQLException(message, e);\n+        }\n+    }\n+\n+    /**\n+     * Return the GraphQL schema representation of the element.\n+     *\n+     * @return the GraphQL schema representation of the element.\n+     */\n+    @Override\n+    public String getSchemaAsString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        listSchemaDirectives.forEach(d -> sb.append(d.getSchemaAsString()).append('\\n'));\n+        if (listSchemaDirectives.size() > 0) {\n+            sb.append('\\n');\n+        }\n+\n+        sb.append(\"schema \").append(OPEN_CURLY).append(NEWLINE);\n+\n+        // only output \"query\" if we have a query type\n+        if (containsTypeWithName(queryName)) {\n+            sb.append(SPACER).append(\"query: \").append(queryName).append('\\n');\n+        }\n+        if (containsTypeWithName(mutationName)) {\n+            sb.append(SPACER).append(\"mutation: \").append(mutationName).append('\\n');\n+        }\n+        if (containsTypeWithName(subscriptionName)) {\n+            sb.append(SPACER).append(\"subscription: \").append(subscriptionName).append('\\n');\n+        }\n+\n+        sb.append(CLOSE_CURLY).append(NEWLINE).append(NEWLINE);\n+\n+        listSchemaTypes.forEach(t -> sb.append(t.getSchemaAsString()).append(\"\\n\"));\n+\n+        listInputTypes.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaEnums.forEach(e -> sb.append(e.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaScalars.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Return the {@link RuntimeWiring} for the given auto-generated schema.\n+     *\n+     * @return the {@link RuntimeWiring}\n+     */\n+    @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+    public RuntimeWiring getRuntimeWiring() {\n+        RuntimeWiring.Builder builder = newRuntimeWiring();\n+\n+        //  Create the top level Query Runtime Wiring.\n+        SchemaType querySchemaType = getTypeByName(getQueryName());\n+\n+        if (querySchemaType == null) {\n+            throw new GraphQLException(\"No type exists for query of name \" + getQueryName());\n+        }\n+\n+        final TypeRuntimeWiring.Builder typeRuntimeBuilder = newTypeWiring(getQueryName());\n+\n+        // register a type resolver for any interfaces if we have at least one\n+        Set<SchemaType> setInterfaces = getTypes().stream().filter(SchemaType::isInterface).collect(Collectors.toSet());\n+        if (setInterfaces.size() > 0) {\n+            final Map<String, String> mapTypes = new HashMap<>();\n+\n+            getTypes().stream().filter(t -> !t.isInterface()).forEach(t -> mapTypes.put(t.name(), t.valueClassName()));\n+\n+            // generate a TypeResolver for all types that are not interfaces\n+            TypeResolver typeResolver = env -> {\n+                Object o = env.getObject();\n+                for (Map.Entry<String, String> entry : mapTypes.entrySet()) {\n+                    String valueClass = entry.getValue();\n+                    if (valueClass != null) {\n+                        Class<?> typeClass = getSafeClass(entry.getValue());\n+                        if (typeClass != null && typeClass.isAssignableFrom(o.getClass())) {\n+                            return (GraphQLObjectType) env.getSchema().getType(entry.getKey());\n+                        }\n+                    }\n+                }\n+                return null;\n+            };\n+\n+            // add the type resolver to all interfaces and the Query object\n+            setInterfaces.forEach(t -> builder.type(t.name(), tr -> tr.typeResolver(typeResolver)));\n+            builder.type(getQueryName(), tr -> tr.typeResolver(typeResolver));\n+        }\n+\n+        // register the scalars\n+        getScalars().forEach(s -> {\n+            LOGGER.finest(\"Register Scalar: \" + s);\n+            builder.scalar(s.graphQLScalarType());\n+        });\n+\n+        // we should now have the query runtime binding\n+        builder.type(typeRuntimeBuilder);\n+\n+        // search for any types that have field definitions with DataFetchers\n+        getTypes().forEach(t -> {\n+            boolean hasDataFetchers = t.fieldDefinitions().stream().anyMatch(fd -> fd.dataFetcher() != null);\n+            if (hasDataFetchers) {\n+                final TypeRuntimeWiring.Builder runtimeBuilder = newTypeWiring(t.name());\n+                t.fieldDefinitions().stream()\n+                        .filter(fd -> fd.dataFetcher() != null)\n+                        .forEach(fd -> runtimeBuilder.dataFetcher(fd.name(), fd.dataFetcher()));\n+                builder.type(runtimeBuilder);\n+            }\n+        });\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the type name.\n+     *\n+     * @param typeName type name to match\n+     * @return a {@link SchemaType} that matches the type name or null if none found\n+     */\n+    public SchemaType getTypeByName(String typeName) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (schemaType.name().equals(typeName)) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaInputType} that matches the type name.\n+     *\n+     * @param inputTypeName type name to match\n+     * @return a {@link SchemaInputType} that matches the type name or null if none found\n+     */\n+    public SchemaInputType getInputTypeByName(String inputTypeName) {\n+        for (SchemaInputType schemaInputType : listInputTypes) {\n+            if (schemaInputType.name().equals(inputTypeName)) {\n+                return schemaInputType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the given class.\n+     *\n+     * @param clazz the class to find\n+     * @return a {@link SchemaType} that matches the given class or null if none found\n+     */\n+    public SchemaType getTypeByClass(String clazz) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (clazz.equals(schemaType.valueClassName())) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaEnum} that matches the enum name.\n+     *\n+     * @param enumName type name to match\n+     * @return a {@link SchemaEnum} that matches the enum name or null if none found\n+     */\n+    public SchemaEnum getEnumByName(String enumName) {\n+        for (SchemaEnum schemaEnum1 : listSchemaEnums) {\n+            if (schemaEnum1.name().equals(enumName)) {\n+                return schemaEnum1;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided class name.\n+     *\n+     * @param actualClazz the class name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByActualClass(String actualClazz) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.actualClass().equals(actualClazz)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided scalar name.\n+     *\n+     * @param scalarName the scalar name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByName(String scalarName) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.name().equals(scalarName)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaType} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param type type name to search for\n+     * @return true if the type name is contained within the type list\n+     */\n+    public boolean containsTypeWithName(String type) {\n+        return listSchemaTypes.stream().filter(t -> t.name().equals(type)).count() == 1;", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzMjEwNg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522232106", "bodyText": "anyMatch", "author": "danielkec", "createdAt": "2020-11-12T16:17:54Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/Schema.java", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import graphql.GraphQLException;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.TypeResolver;\n+import graphql.schema.idl.RuntimeWiring;\n+import graphql.schema.idl.SchemaParser;\n+import graphql.schema.idl.TypeDefinitionRegistry;\n+import graphql.schema.idl.TypeRuntimeWiring;\n+\n+import static graphql.schema.idl.RuntimeWiring.newRuntimeWiring;\n+import static graphql.schema.idl.TypeRuntimeWiring.newTypeWiring;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getSafeClass;\n+\n+/**\n+ * The representation of a GraphQL Schema.\n+ */\n+class Schema implements ElementGenerator {\n+\n+    private static final Logger LOGGER = Logger.getLogger(Schema.class.getName());\n+\n+    /**\n+     * Default query name.\n+     */\n+    public static final String QUERY = \"Query\";\n+\n+    /**\n+     * Default mutation name.\n+     */\n+    public static final String MUTATION = \"Mutation\";\n+\n+    /**\n+     * Default subscription name.\n+     */\n+    public static final String SUBSCRIPTION = \"Subscription\";\n+\n+    /**\n+     * The top level query name.\n+     */\n+    private String queryName;\n+\n+    /**\n+     * The top level mutation name.\n+     */\n+    private String mutationName;\n+\n+    /**\n+     * The top level subscription name.\n+     */\n+    private String subscriptionName;\n+\n+    /**\n+     * List of {@link SchemaType}s for this schema. This includes the standard schema types and other types.\n+     */\n+    private final List<SchemaType> listSchemaTypes;\n+\n+    /**\n+     * List of {@link SchemaScalar}s that should be included in the schema.\n+     */\n+    private final List<SchemaScalar> listSchemaScalars;\n+\n+    /**\n+     * List of {@link SchemaDirective}s that should be included in the schema.\n+     */\n+    private final List<SchemaDirective> listSchemaDirectives;\n+\n+    /**\n+     * List of {@link SchemaInputType}s that should be included in the schema.\n+     */\n+    private final List<SchemaInputType> listInputTypes;\n+\n+    /**\n+     * List of {@link SchemaEnum}s that should be included in the schema.\n+     */\n+    private final List<SchemaEnum> listSchemaEnums;\n+\n+    /**\n+     * Construct a {@link Schema}.\n+     *\n+     * @param builder the {@link Builder} to construct from\n+     */\n+    private Schema(Builder builder) {\n+        this.listSchemaTypes = new ArrayList<>();\n+        this.listSchemaScalars = new ArrayList<>();\n+        this.listSchemaDirectives = new ArrayList<>();\n+        this.listInputTypes = new ArrayList<>();\n+        this.listSchemaEnums = new ArrayList<>();\n+        this.queryName = builder.queryName;\n+        this.subscriptionName = builder.subscriptionName;\n+        this.mutationName = builder.mutationName;\n+    }\n+\n+    /**\n+     * Fluent API builder to create {@link Schema}.\n+     *\n+     * @return new builder instance\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Build a new {@link Schema}.\n+     *\n+     * @return a new {@link Schema}\n+     */\n+    public static Schema create() {\n+        return builder().build();\n+    }\n+\n+    /**\n+     * Generates a {@link GraphQLSchema} from the current discovered schema.\n+     *\n+     * @return {@link GraphQLSchema}\n+     */\n+    public GraphQLSchema generateGraphQLSchema() {\n+        SchemaParser schemaParser = new SchemaParser();\n+        TypeDefinitionRegistry typeDefinitionRegistry;\n+\n+        try {\n+            typeDefinitionRegistry = schemaParser.parse(getSchemaAsString());\n+            return new graphql.schema.idl.SchemaGenerator().makeExecutableSchema(typeDefinitionRegistry, getRuntimeWiring());\n+        } catch (Exception e) {\n+            String message = \"Unable to parse the generated schema\";\n+            LOGGER.warning(message + \"\\n\" + getSchemaAsString());\n+            throw new GraphQLException(message, e);\n+        }\n+    }\n+\n+    /**\n+     * Return the GraphQL schema representation of the element.\n+     *\n+     * @return the GraphQL schema representation of the element.\n+     */\n+    @Override\n+    public String getSchemaAsString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        listSchemaDirectives.forEach(d -> sb.append(d.getSchemaAsString()).append('\\n'));\n+        if (listSchemaDirectives.size() > 0) {\n+            sb.append('\\n');\n+        }\n+\n+        sb.append(\"schema \").append(OPEN_CURLY).append(NEWLINE);\n+\n+        // only output \"query\" if we have a query type\n+        if (containsTypeWithName(queryName)) {\n+            sb.append(SPACER).append(\"query: \").append(queryName).append('\\n');\n+        }\n+        if (containsTypeWithName(mutationName)) {\n+            sb.append(SPACER).append(\"mutation: \").append(mutationName).append('\\n');\n+        }\n+        if (containsTypeWithName(subscriptionName)) {\n+            sb.append(SPACER).append(\"subscription: \").append(subscriptionName).append('\\n');\n+        }\n+\n+        sb.append(CLOSE_CURLY).append(NEWLINE).append(NEWLINE);\n+\n+        listSchemaTypes.forEach(t -> sb.append(t.getSchemaAsString()).append(\"\\n\"));\n+\n+        listInputTypes.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaEnums.forEach(e -> sb.append(e.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaScalars.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Return the {@link RuntimeWiring} for the given auto-generated schema.\n+     *\n+     * @return the {@link RuntimeWiring}\n+     */\n+    @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+    public RuntimeWiring getRuntimeWiring() {\n+        RuntimeWiring.Builder builder = newRuntimeWiring();\n+\n+        //  Create the top level Query Runtime Wiring.\n+        SchemaType querySchemaType = getTypeByName(getQueryName());\n+\n+        if (querySchemaType == null) {\n+            throw new GraphQLException(\"No type exists for query of name \" + getQueryName());\n+        }\n+\n+        final TypeRuntimeWiring.Builder typeRuntimeBuilder = newTypeWiring(getQueryName());\n+\n+        // register a type resolver for any interfaces if we have at least one\n+        Set<SchemaType> setInterfaces = getTypes().stream().filter(SchemaType::isInterface).collect(Collectors.toSet());\n+        if (setInterfaces.size() > 0) {\n+            final Map<String, String> mapTypes = new HashMap<>();\n+\n+            getTypes().stream().filter(t -> !t.isInterface()).forEach(t -> mapTypes.put(t.name(), t.valueClassName()));\n+\n+            // generate a TypeResolver for all types that are not interfaces\n+            TypeResolver typeResolver = env -> {\n+                Object o = env.getObject();\n+                for (Map.Entry<String, String> entry : mapTypes.entrySet()) {\n+                    String valueClass = entry.getValue();\n+                    if (valueClass != null) {\n+                        Class<?> typeClass = getSafeClass(entry.getValue());\n+                        if (typeClass != null && typeClass.isAssignableFrom(o.getClass())) {\n+                            return (GraphQLObjectType) env.getSchema().getType(entry.getKey());\n+                        }\n+                    }\n+                }\n+                return null;\n+            };\n+\n+            // add the type resolver to all interfaces and the Query object\n+            setInterfaces.forEach(t -> builder.type(t.name(), tr -> tr.typeResolver(typeResolver)));\n+            builder.type(getQueryName(), tr -> tr.typeResolver(typeResolver));\n+        }\n+\n+        // register the scalars\n+        getScalars().forEach(s -> {\n+            LOGGER.finest(\"Register Scalar: \" + s);\n+            builder.scalar(s.graphQLScalarType());\n+        });\n+\n+        // we should now have the query runtime binding\n+        builder.type(typeRuntimeBuilder);\n+\n+        // search for any types that have field definitions with DataFetchers\n+        getTypes().forEach(t -> {\n+            boolean hasDataFetchers = t.fieldDefinitions().stream().anyMatch(fd -> fd.dataFetcher() != null);\n+            if (hasDataFetchers) {\n+                final TypeRuntimeWiring.Builder runtimeBuilder = newTypeWiring(t.name());\n+                t.fieldDefinitions().stream()\n+                        .filter(fd -> fd.dataFetcher() != null)\n+                        .forEach(fd -> runtimeBuilder.dataFetcher(fd.name(), fd.dataFetcher()));\n+                builder.type(runtimeBuilder);\n+            }\n+        });\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the type name.\n+     *\n+     * @param typeName type name to match\n+     * @return a {@link SchemaType} that matches the type name or null if none found\n+     */\n+    public SchemaType getTypeByName(String typeName) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (schemaType.name().equals(typeName)) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaInputType} that matches the type name.\n+     *\n+     * @param inputTypeName type name to match\n+     * @return a {@link SchemaInputType} that matches the type name or null if none found\n+     */\n+    public SchemaInputType getInputTypeByName(String inputTypeName) {\n+        for (SchemaInputType schemaInputType : listInputTypes) {\n+            if (schemaInputType.name().equals(inputTypeName)) {\n+                return schemaInputType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the given class.\n+     *\n+     * @param clazz the class to find\n+     * @return a {@link SchemaType} that matches the given class or null if none found\n+     */\n+    public SchemaType getTypeByClass(String clazz) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (clazz.equals(schemaType.valueClassName())) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaEnum} that matches the enum name.\n+     *\n+     * @param enumName type name to match\n+     * @return a {@link SchemaEnum} that matches the enum name or null if none found\n+     */\n+    public SchemaEnum getEnumByName(String enumName) {\n+        for (SchemaEnum schemaEnum1 : listSchemaEnums) {\n+            if (schemaEnum1.name().equals(enumName)) {\n+                return schemaEnum1;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided class name.\n+     *\n+     * @param actualClazz the class name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByActualClass(String actualClazz) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.actualClass().equals(actualClazz)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided scalar name.\n+     *\n+     * @param scalarName the scalar name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByName(String scalarName) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.name().equals(scalarName)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaType} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param type type name to search for\n+     * @return true if the type name is contained within the type list\n+     */\n+    public boolean containsTypeWithName(String type) {\n+        return listSchemaTypes.stream().filter(t -> t.name().equals(type)).count() == 1;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaInputType} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param type type name to search for\n+     * @return true if the type name is contained within the input type list\n+     */\n+    public boolean containsInputTypeWithName(String type) {\n+        return listInputTypes.stream().filter(t -> t.name().equals(type)).count() == 1;", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzMjI5OA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522232298", "bodyText": "anyMatch", "author": "danielkec", "createdAt": "2020-11-12T16:18:06Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/Schema.java", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import graphql.GraphQLException;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.TypeResolver;\n+import graphql.schema.idl.RuntimeWiring;\n+import graphql.schema.idl.SchemaParser;\n+import graphql.schema.idl.TypeDefinitionRegistry;\n+import graphql.schema.idl.TypeRuntimeWiring;\n+\n+import static graphql.schema.idl.RuntimeWiring.newRuntimeWiring;\n+import static graphql.schema.idl.TypeRuntimeWiring.newTypeWiring;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getSafeClass;\n+\n+/**\n+ * The representation of a GraphQL Schema.\n+ */\n+class Schema implements ElementGenerator {\n+\n+    private static final Logger LOGGER = Logger.getLogger(Schema.class.getName());\n+\n+    /**\n+     * Default query name.\n+     */\n+    public static final String QUERY = \"Query\";\n+\n+    /**\n+     * Default mutation name.\n+     */\n+    public static final String MUTATION = \"Mutation\";\n+\n+    /**\n+     * Default subscription name.\n+     */\n+    public static final String SUBSCRIPTION = \"Subscription\";\n+\n+    /**\n+     * The top level query name.\n+     */\n+    private String queryName;\n+\n+    /**\n+     * The top level mutation name.\n+     */\n+    private String mutationName;\n+\n+    /**\n+     * The top level subscription name.\n+     */\n+    private String subscriptionName;\n+\n+    /**\n+     * List of {@link SchemaType}s for this schema. This includes the standard schema types and other types.\n+     */\n+    private final List<SchemaType> listSchemaTypes;\n+\n+    /**\n+     * List of {@link SchemaScalar}s that should be included in the schema.\n+     */\n+    private final List<SchemaScalar> listSchemaScalars;\n+\n+    /**\n+     * List of {@link SchemaDirective}s that should be included in the schema.\n+     */\n+    private final List<SchemaDirective> listSchemaDirectives;\n+\n+    /**\n+     * List of {@link SchemaInputType}s that should be included in the schema.\n+     */\n+    private final List<SchemaInputType> listInputTypes;\n+\n+    /**\n+     * List of {@link SchemaEnum}s that should be included in the schema.\n+     */\n+    private final List<SchemaEnum> listSchemaEnums;\n+\n+    /**\n+     * Construct a {@link Schema}.\n+     *\n+     * @param builder the {@link Builder} to construct from\n+     */\n+    private Schema(Builder builder) {\n+        this.listSchemaTypes = new ArrayList<>();\n+        this.listSchemaScalars = new ArrayList<>();\n+        this.listSchemaDirectives = new ArrayList<>();\n+        this.listInputTypes = new ArrayList<>();\n+        this.listSchemaEnums = new ArrayList<>();\n+        this.queryName = builder.queryName;\n+        this.subscriptionName = builder.subscriptionName;\n+        this.mutationName = builder.mutationName;\n+    }\n+\n+    /**\n+     * Fluent API builder to create {@link Schema}.\n+     *\n+     * @return new builder instance\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Build a new {@link Schema}.\n+     *\n+     * @return a new {@link Schema}\n+     */\n+    public static Schema create() {\n+        return builder().build();\n+    }\n+\n+    /**\n+     * Generates a {@link GraphQLSchema} from the current discovered schema.\n+     *\n+     * @return {@link GraphQLSchema}\n+     */\n+    public GraphQLSchema generateGraphQLSchema() {\n+        SchemaParser schemaParser = new SchemaParser();\n+        TypeDefinitionRegistry typeDefinitionRegistry;\n+\n+        try {\n+            typeDefinitionRegistry = schemaParser.parse(getSchemaAsString());\n+            return new graphql.schema.idl.SchemaGenerator().makeExecutableSchema(typeDefinitionRegistry, getRuntimeWiring());\n+        } catch (Exception e) {\n+            String message = \"Unable to parse the generated schema\";\n+            LOGGER.warning(message + \"\\n\" + getSchemaAsString());\n+            throw new GraphQLException(message, e);\n+        }\n+    }\n+\n+    /**\n+     * Return the GraphQL schema representation of the element.\n+     *\n+     * @return the GraphQL schema representation of the element.\n+     */\n+    @Override\n+    public String getSchemaAsString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        listSchemaDirectives.forEach(d -> sb.append(d.getSchemaAsString()).append('\\n'));\n+        if (listSchemaDirectives.size() > 0) {\n+            sb.append('\\n');\n+        }\n+\n+        sb.append(\"schema \").append(OPEN_CURLY).append(NEWLINE);\n+\n+        // only output \"query\" if we have a query type\n+        if (containsTypeWithName(queryName)) {\n+            sb.append(SPACER).append(\"query: \").append(queryName).append('\\n');\n+        }\n+        if (containsTypeWithName(mutationName)) {\n+            sb.append(SPACER).append(\"mutation: \").append(mutationName).append('\\n');\n+        }\n+        if (containsTypeWithName(subscriptionName)) {\n+            sb.append(SPACER).append(\"subscription: \").append(subscriptionName).append('\\n');\n+        }\n+\n+        sb.append(CLOSE_CURLY).append(NEWLINE).append(NEWLINE);\n+\n+        listSchemaTypes.forEach(t -> sb.append(t.getSchemaAsString()).append(\"\\n\"));\n+\n+        listInputTypes.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaEnums.forEach(e -> sb.append(e.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaScalars.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Return the {@link RuntimeWiring} for the given auto-generated schema.\n+     *\n+     * @return the {@link RuntimeWiring}\n+     */\n+    @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+    public RuntimeWiring getRuntimeWiring() {\n+        RuntimeWiring.Builder builder = newRuntimeWiring();\n+\n+        //  Create the top level Query Runtime Wiring.\n+        SchemaType querySchemaType = getTypeByName(getQueryName());\n+\n+        if (querySchemaType == null) {\n+            throw new GraphQLException(\"No type exists for query of name \" + getQueryName());\n+        }\n+\n+        final TypeRuntimeWiring.Builder typeRuntimeBuilder = newTypeWiring(getQueryName());\n+\n+        // register a type resolver for any interfaces if we have at least one\n+        Set<SchemaType> setInterfaces = getTypes().stream().filter(SchemaType::isInterface).collect(Collectors.toSet());\n+        if (setInterfaces.size() > 0) {\n+            final Map<String, String> mapTypes = new HashMap<>();\n+\n+            getTypes().stream().filter(t -> !t.isInterface()).forEach(t -> mapTypes.put(t.name(), t.valueClassName()));\n+\n+            // generate a TypeResolver for all types that are not interfaces\n+            TypeResolver typeResolver = env -> {\n+                Object o = env.getObject();\n+                for (Map.Entry<String, String> entry : mapTypes.entrySet()) {\n+                    String valueClass = entry.getValue();\n+                    if (valueClass != null) {\n+                        Class<?> typeClass = getSafeClass(entry.getValue());\n+                        if (typeClass != null && typeClass.isAssignableFrom(o.getClass())) {\n+                            return (GraphQLObjectType) env.getSchema().getType(entry.getKey());\n+                        }\n+                    }\n+                }\n+                return null;\n+            };\n+\n+            // add the type resolver to all interfaces and the Query object\n+            setInterfaces.forEach(t -> builder.type(t.name(), tr -> tr.typeResolver(typeResolver)));\n+            builder.type(getQueryName(), tr -> tr.typeResolver(typeResolver));\n+        }\n+\n+        // register the scalars\n+        getScalars().forEach(s -> {\n+            LOGGER.finest(\"Register Scalar: \" + s);\n+            builder.scalar(s.graphQLScalarType());\n+        });\n+\n+        // we should now have the query runtime binding\n+        builder.type(typeRuntimeBuilder);\n+\n+        // search for any types that have field definitions with DataFetchers\n+        getTypes().forEach(t -> {\n+            boolean hasDataFetchers = t.fieldDefinitions().stream().anyMatch(fd -> fd.dataFetcher() != null);\n+            if (hasDataFetchers) {\n+                final TypeRuntimeWiring.Builder runtimeBuilder = newTypeWiring(t.name());\n+                t.fieldDefinitions().stream()\n+                        .filter(fd -> fd.dataFetcher() != null)\n+                        .forEach(fd -> runtimeBuilder.dataFetcher(fd.name(), fd.dataFetcher()));\n+                builder.type(runtimeBuilder);\n+            }\n+        });\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the type name.\n+     *\n+     * @param typeName type name to match\n+     * @return a {@link SchemaType} that matches the type name or null if none found\n+     */\n+    public SchemaType getTypeByName(String typeName) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (schemaType.name().equals(typeName)) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaInputType} that matches the type name.\n+     *\n+     * @param inputTypeName type name to match\n+     * @return a {@link SchemaInputType} that matches the type name or null if none found\n+     */\n+    public SchemaInputType getInputTypeByName(String inputTypeName) {\n+        for (SchemaInputType schemaInputType : listInputTypes) {\n+            if (schemaInputType.name().equals(inputTypeName)) {\n+                return schemaInputType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the given class.\n+     *\n+     * @param clazz the class to find\n+     * @return a {@link SchemaType} that matches the given class or null if none found\n+     */\n+    public SchemaType getTypeByClass(String clazz) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (clazz.equals(schemaType.valueClassName())) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaEnum} that matches the enum name.\n+     *\n+     * @param enumName type name to match\n+     * @return a {@link SchemaEnum} that matches the enum name or null if none found\n+     */\n+    public SchemaEnum getEnumByName(String enumName) {\n+        for (SchemaEnum schemaEnum1 : listSchemaEnums) {\n+            if (schemaEnum1.name().equals(enumName)) {\n+                return schemaEnum1;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided class name.\n+     *\n+     * @param actualClazz the class name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByActualClass(String actualClazz) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.actualClass().equals(actualClazz)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided scalar name.\n+     *\n+     * @param scalarName the scalar name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByName(String scalarName) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.name().equals(scalarName)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaType} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param type type name to search for\n+     * @return true if the type name is contained within the type list\n+     */\n+    public boolean containsTypeWithName(String type) {\n+        return listSchemaTypes.stream().filter(t -> t.name().equals(type)).count() == 1;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaInputType} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param type type name to search for\n+     * @return true if the type name is contained within the input type list\n+     */\n+    public boolean containsInputTypeWithName(String type) {\n+        return listInputTypes.stream().filter(t -> t.name().equals(type)).count() == 1;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaScalar} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param scalar the scalar name to search for\n+     * @return true if the scalar name is contained within the scalar list\n+     */\n+    public boolean containsScalarWithName(String scalar) {\n+        return listSchemaScalars.stream().filter(s -> s.name().equals(scalar)).count() == 1;", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzMjM5NQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522232395", "bodyText": "anyMatch", "author": "danielkec", "createdAt": "2020-11-12T16:18:11Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/Schema.java", "diffHunk": "@@ -0,0 +1,562 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import graphql.GraphQLException;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.TypeResolver;\n+import graphql.schema.idl.RuntimeWiring;\n+import graphql.schema.idl.SchemaParser;\n+import graphql.schema.idl.TypeDefinitionRegistry;\n+import graphql.schema.idl.TypeRuntimeWiring;\n+\n+import static graphql.schema.idl.RuntimeWiring.newRuntimeWiring;\n+import static graphql.schema.idl.TypeRuntimeWiring.newTypeWiring;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getSafeClass;\n+\n+/**\n+ * The representation of a GraphQL Schema.\n+ */\n+class Schema implements ElementGenerator {\n+\n+    private static final Logger LOGGER = Logger.getLogger(Schema.class.getName());\n+\n+    /**\n+     * Default query name.\n+     */\n+    public static final String QUERY = \"Query\";\n+\n+    /**\n+     * Default mutation name.\n+     */\n+    public static final String MUTATION = \"Mutation\";\n+\n+    /**\n+     * Default subscription name.\n+     */\n+    public static final String SUBSCRIPTION = \"Subscription\";\n+\n+    /**\n+     * The top level query name.\n+     */\n+    private String queryName;\n+\n+    /**\n+     * The top level mutation name.\n+     */\n+    private String mutationName;\n+\n+    /**\n+     * The top level subscription name.\n+     */\n+    private String subscriptionName;\n+\n+    /**\n+     * List of {@link SchemaType}s for this schema. This includes the standard schema types and other types.\n+     */\n+    private final List<SchemaType> listSchemaTypes;\n+\n+    /**\n+     * List of {@link SchemaScalar}s that should be included in the schema.\n+     */\n+    private final List<SchemaScalar> listSchemaScalars;\n+\n+    /**\n+     * List of {@link SchemaDirective}s that should be included in the schema.\n+     */\n+    private final List<SchemaDirective> listSchemaDirectives;\n+\n+    /**\n+     * List of {@link SchemaInputType}s that should be included in the schema.\n+     */\n+    private final List<SchemaInputType> listInputTypes;\n+\n+    /**\n+     * List of {@link SchemaEnum}s that should be included in the schema.\n+     */\n+    private final List<SchemaEnum> listSchemaEnums;\n+\n+    /**\n+     * Construct a {@link Schema}.\n+     *\n+     * @param builder the {@link Builder} to construct from\n+     */\n+    private Schema(Builder builder) {\n+        this.listSchemaTypes = new ArrayList<>();\n+        this.listSchemaScalars = new ArrayList<>();\n+        this.listSchemaDirectives = new ArrayList<>();\n+        this.listInputTypes = new ArrayList<>();\n+        this.listSchemaEnums = new ArrayList<>();\n+        this.queryName = builder.queryName;\n+        this.subscriptionName = builder.subscriptionName;\n+        this.mutationName = builder.mutationName;\n+    }\n+\n+    /**\n+     * Fluent API builder to create {@link Schema}.\n+     *\n+     * @return new builder instance\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Build a new {@link Schema}.\n+     *\n+     * @return a new {@link Schema}\n+     */\n+    public static Schema create() {\n+        return builder().build();\n+    }\n+\n+    /**\n+     * Generates a {@link GraphQLSchema} from the current discovered schema.\n+     *\n+     * @return {@link GraphQLSchema}\n+     */\n+    public GraphQLSchema generateGraphQLSchema() {\n+        SchemaParser schemaParser = new SchemaParser();\n+        TypeDefinitionRegistry typeDefinitionRegistry;\n+\n+        try {\n+            typeDefinitionRegistry = schemaParser.parse(getSchemaAsString());\n+            return new graphql.schema.idl.SchemaGenerator().makeExecutableSchema(typeDefinitionRegistry, getRuntimeWiring());\n+        } catch (Exception e) {\n+            String message = \"Unable to parse the generated schema\";\n+            LOGGER.warning(message + \"\\n\" + getSchemaAsString());\n+            throw new GraphQLException(message, e);\n+        }\n+    }\n+\n+    /**\n+     * Return the GraphQL schema representation of the element.\n+     *\n+     * @return the GraphQL schema representation of the element.\n+     */\n+    @Override\n+    public String getSchemaAsString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        listSchemaDirectives.forEach(d -> sb.append(d.getSchemaAsString()).append('\\n'));\n+        if (listSchemaDirectives.size() > 0) {\n+            sb.append('\\n');\n+        }\n+\n+        sb.append(\"schema \").append(OPEN_CURLY).append(NEWLINE);\n+\n+        // only output \"query\" if we have a query type\n+        if (containsTypeWithName(queryName)) {\n+            sb.append(SPACER).append(\"query: \").append(queryName).append('\\n');\n+        }\n+        if (containsTypeWithName(mutationName)) {\n+            sb.append(SPACER).append(\"mutation: \").append(mutationName).append('\\n');\n+        }\n+        if (containsTypeWithName(subscriptionName)) {\n+            sb.append(SPACER).append(\"subscription: \").append(subscriptionName).append('\\n');\n+        }\n+\n+        sb.append(CLOSE_CURLY).append(NEWLINE).append(NEWLINE);\n+\n+        listSchemaTypes.forEach(t -> sb.append(t.getSchemaAsString()).append(\"\\n\"));\n+\n+        listInputTypes.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaEnums.forEach(e -> sb.append(e.getSchemaAsString()).append('\\n'));\n+\n+        listSchemaScalars.forEach(s -> sb.append(s.getSchemaAsString()).append('\\n'));\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Return the {@link RuntimeWiring} for the given auto-generated schema.\n+     *\n+     * @return the {@link RuntimeWiring}\n+     */\n+    @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+    public RuntimeWiring getRuntimeWiring() {\n+        RuntimeWiring.Builder builder = newRuntimeWiring();\n+\n+        //  Create the top level Query Runtime Wiring.\n+        SchemaType querySchemaType = getTypeByName(getQueryName());\n+\n+        if (querySchemaType == null) {\n+            throw new GraphQLException(\"No type exists for query of name \" + getQueryName());\n+        }\n+\n+        final TypeRuntimeWiring.Builder typeRuntimeBuilder = newTypeWiring(getQueryName());\n+\n+        // register a type resolver for any interfaces if we have at least one\n+        Set<SchemaType> setInterfaces = getTypes().stream().filter(SchemaType::isInterface).collect(Collectors.toSet());\n+        if (setInterfaces.size() > 0) {\n+            final Map<String, String> mapTypes = new HashMap<>();\n+\n+            getTypes().stream().filter(t -> !t.isInterface()).forEach(t -> mapTypes.put(t.name(), t.valueClassName()));\n+\n+            // generate a TypeResolver for all types that are not interfaces\n+            TypeResolver typeResolver = env -> {\n+                Object o = env.getObject();\n+                for (Map.Entry<String, String> entry : mapTypes.entrySet()) {\n+                    String valueClass = entry.getValue();\n+                    if (valueClass != null) {\n+                        Class<?> typeClass = getSafeClass(entry.getValue());\n+                        if (typeClass != null && typeClass.isAssignableFrom(o.getClass())) {\n+                            return (GraphQLObjectType) env.getSchema().getType(entry.getKey());\n+                        }\n+                    }\n+                }\n+                return null;\n+            };\n+\n+            // add the type resolver to all interfaces and the Query object\n+            setInterfaces.forEach(t -> builder.type(t.name(), tr -> tr.typeResolver(typeResolver)));\n+            builder.type(getQueryName(), tr -> tr.typeResolver(typeResolver));\n+        }\n+\n+        // register the scalars\n+        getScalars().forEach(s -> {\n+            LOGGER.finest(\"Register Scalar: \" + s);\n+            builder.scalar(s.graphQLScalarType());\n+        });\n+\n+        // we should now have the query runtime binding\n+        builder.type(typeRuntimeBuilder);\n+\n+        // search for any types that have field definitions with DataFetchers\n+        getTypes().forEach(t -> {\n+            boolean hasDataFetchers = t.fieldDefinitions().stream().anyMatch(fd -> fd.dataFetcher() != null);\n+            if (hasDataFetchers) {\n+                final TypeRuntimeWiring.Builder runtimeBuilder = newTypeWiring(t.name());\n+                t.fieldDefinitions().stream()\n+                        .filter(fd -> fd.dataFetcher() != null)\n+                        .forEach(fd -> runtimeBuilder.dataFetcher(fd.name(), fd.dataFetcher()));\n+                builder.type(runtimeBuilder);\n+            }\n+        });\n+\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the type name.\n+     *\n+     * @param typeName type name to match\n+     * @return a {@link SchemaType} that matches the type name or null if none found\n+     */\n+    public SchemaType getTypeByName(String typeName) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (schemaType.name().equals(typeName)) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaInputType} that matches the type name.\n+     *\n+     * @param inputTypeName type name to match\n+     * @return a {@link SchemaInputType} that matches the type name or null if none found\n+     */\n+    public SchemaInputType getInputTypeByName(String inputTypeName) {\n+        for (SchemaInputType schemaInputType : listInputTypes) {\n+            if (schemaInputType.name().equals(inputTypeName)) {\n+                return schemaInputType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaType} that matches the given class.\n+     *\n+     * @param clazz the class to find\n+     * @return a {@link SchemaType} that matches the given class or null if none found\n+     */\n+    public SchemaType getTypeByClass(String clazz) {\n+        for (SchemaType schemaType : listSchemaTypes) {\n+            if (clazz.equals(schemaType.valueClassName())) {\n+                return schemaType;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaEnum} that matches the enum name.\n+     *\n+     * @param enumName type name to match\n+     * @return a {@link SchemaEnum} that matches the enum name or null if none found\n+     */\n+    public SchemaEnum getEnumByName(String enumName) {\n+        for (SchemaEnum schemaEnum1 : listSchemaEnums) {\n+            if (schemaEnum1.name().equals(enumName)) {\n+                return schemaEnum1;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided class name.\n+     *\n+     * @param actualClazz the class name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByActualClass(String actualClazz) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.actualClass().equals(actualClazz)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return a {@link SchemaScalar} which matches the provided scalar name.\n+     *\n+     * @param scalarName the scalar name to match\n+     * @return {@link SchemaScalar} or null if none found\n+     */\n+    public SchemaScalar getScalarByName(String scalarName) {\n+        for (SchemaScalar schemaScalar : getScalars()) {\n+            if (schemaScalar.name().equals(scalarName)) {\n+                return schemaScalar;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaType} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param type type name to search for\n+     * @return true if the type name is contained within the type list\n+     */\n+    public boolean containsTypeWithName(String type) {\n+        return listSchemaTypes.stream().filter(t -> t.name().equals(type)).count() == 1;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaInputType} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param type type name to search for\n+     * @return true if the type name is contained within the input type list\n+     */\n+    public boolean containsInputTypeWithName(String type) {\n+        return listInputTypes.stream().filter(t -> t.name().equals(type)).count() == 1;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaScalar} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param scalar the scalar name to search for\n+     * @return true if the scalar name is contained within the scalar list\n+     */\n+    public boolean containsScalarWithName(String scalar) {\n+        return listSchemaScalars.stream().filter(s -> s.name().equals(scalar)).count() == 1;\n+    }\n+\n+    /**\n+     * Return true of the {@link SchemaEnum} with the the given name is present for this {@link Schema}.\n+     *\n+     * @param enumName the enum name to search for\n+     * @return true if the enum name is contained within the enum list\n+     */\n+    public boolean containsEnumWithName(String enumName) {\n+        return listSchemaEnums.stream().filter(e -> e.name().equals(enumName)).count() == 1;", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0MzQ3Ng==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522243476", "bodyText": "anyMatch", "author": "danielkec", "createdAt": "2020-11-12T16:32:16Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaGenerator.java", "diffHunk": "@@ -0,0 +1,1780 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.Introspector;\n+import java.beans.MethodDescriptor;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.lang.reflect.ParameterizedType;\n+import java.text.NumberFormat;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.json.bind.annotation.JsonbProperty;\n+\n+import io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DiscoveredMethod;\n+\n+import graphql.schema.DataFetcher;\n+import graphql.schema.DataFetcherFactories;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.PropertyDataFetcher;\n+import org.eclipse.microprofile.graphql.Description;\n+import org.eclipse.microprofile.graphql.GraphQLApi;\n+import org.eclipse.microprofile.graphql.Id;\n+import org.eclipse.microprofile.graphql.Input;\n+import org.eclipse.microprofile.graphql.Interface;\n+import org.eclipse.microprofile.graphql.Mutation;\n+import org.eclipse.microprofile.graphql.Name;\n+import org.eclipse.microprofile.graphql.NonNull;\n+import org.eclipse.microprofile.graphql.Query;\n+import org.eclipse.microprofile.graphql.Source;\n+import org.eclipse.microprofile.graphql.Type;\n+\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_OFFSET_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_ZONED_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.DATE;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.NO_FORMATTING;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.NUMBER;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.formatDate;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.formatNumber;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getCorrectDateFormatter;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getCorrectNumberFormat;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getFormattingAnnotation;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.isJsonbAnnotationPresent;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DiscoveredMethod.MUTATION_TYPE;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DiscoveredMethod.QUERY_TYPE;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_OFFSET_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_ZONED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ID;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.STRING;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.checkScalars;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ensureConfigurationException;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ensureFormat;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ensureValidName;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getAnnotationValue;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getArrayLevels;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getDefaultValueAnnotationValue;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getDescription;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getFieldAnnotations;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getFieldName;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getGraphQLType;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getMethodAnnotations;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getMethodName;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getParameterAnnotations;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getRootArrayClass;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getSafeClass;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getScalar;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getSimpleName;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.getTypeName;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isArrayType;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isDateTimeScalar;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isEnumClass;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isGraphQLType;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isPrimitive;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.shouldIgnoreField;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.shouldIgnoreMethod;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.stripMethodName;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.validateIDClass;\n+\n+/**\n+ * Various utilities for generating {@link Schema}s from classes.\n+ */\n+class SchemaGenerator {\n+\n+    /**\n+     * \"is\" prefix.\n+     */\n+    protected static final String IS = \"is\";\n+\n+    /**\n+     * \"get\" prefix.\n+     */\n+    protected static final String GET = \"get\";\n+\n+    /**\n+     * \"set\" prefix.\n+     */\n+    protected static final String SET = \"set\";\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(SchemaGenerator.class.getName());\n+\n+    /**\n+     * {@link JandexUtils} instance to hold indexes.\n+     */\n+    private JandexUtils jandexUtils;\n+\n+    /**\n+     * Holds the {@link Set} of unresolved types while processing the annotations.\n+     */\n+    private Set<String> setUnresolvedTypes = new HashSet<>();\n+\n+    /**\n+     * Holds the {@link Set} of additional methods that need to be added to types.\n+     */\n+    private Set<DiscoveredMethod> setAdditionalMethods = new HashSet<>();\n+\n+    private final Set<Class<?>> collectedApis = new HashSet<>();\n+\n+    /**\n+     * Construct a {@link SchemaGenerator}.\n+     *\n+     * @param builder the {@link io.helidon.microprofile.graphql.server.SchemaGenerator.Builder} to construct from\n+     */\n+    private SchemaGenerator(Builder builder) {\n+        this.collectedApis.addAll(builder.collectedApis);\n+        jandexUtils = JandexUtils.create();\n+        jandexUtils.loadIndexes();\n+        if (!jandexUtils.hasIndex()) {\n+            String message = \"Unable to find or load jandex index files: \"\n+                    + jandexUtils.getIndexFile() + \".\\nEnsure you are using the \"\n+                    + \"jandex-maven-plugin when you are building your application\";\n+            LOGGER.warning(message);\n+        }\n+    }\n+\n+    /**\n+     * Fluent API builder to create {@link SchemaGenerator}.\n+     *\n+     * @return new builder instance\n+     */\n+    public static Builder builder() {\n+        return new SchemaGenerator.Builder();\n+    }\n+\n+    /**\n+     * Generate a {@link Schema} by scanning all discovered classes using the {@link GraphQlCdiExtension}.\n+     *\n+     * @return a {@link Schema}\n+     * @throws java.lang.IllegalStateException in case the schema cannot be generated\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    public Schema generateSchema() {\n+        int count = collectedApis.size();\n+\n+        LOGGER.info(\"Discovered \" + count + \" annotated GraphQL API class\" + (count != 1 ? \"es\" : \"\"));\n+\n+        try {\n+            return generateSchemaFromClasses(collectedApis);\n+        } catch (IntrospectionException | ClassNotFoundException e) {\n+            throw new IllegalStateException(\"Cannot generate schema\", e);\n+        }\n+    }\n+\n+    /**\n+     * Generate a {@link Schema} from a given array of classes.  The classes are checked to see if they contain any of the\n+     * annotations from the microprofile spec.\n+     *\n+     * @param clazzes array of classes to check\n+     * @return a {@link Schema}\n+     *\n+     * @throws IntrospectionException if any errors with introspection\n+     * @throws ClassNotFoundException if any classes are not found\n+     */\n+    protected Schema generateSchemaFromClasses(Set<Class<?>> clazzes) throws IntrospectionException, ClassNotFoundException {\n+        Schema schema = Schema.create();\n+        setUnresolvedTypes.clear();\n+        setAdditionalMethods.clear();\n+\n+        SchemaType rootQueryType = SchemaType.builder().name(schema.getQueryName()).build();\n+        SchemaType rootMutationType = SchemaType.builder().name(schema.getMutationName()).build();\n+\n+        // process any specific classes with the Input, Type or Interface annotations\n+        for (Class<?> clazz : clazzes) {\n+            // only include interfaces and concrete classes/enums\n+            if (clazz.isInterface() || (!clazz.isInterface() && !Modifier.isAbstract(clazz.getModifiers()))) {\n+                // Discover Enum via annotation\n+                if (clazz.isAnnotationPresent(org.eclipse.microprofile.graphql.Enum.class)) {\n+                    schema.addEnum(generateEnum(clazz));\n+                    continue;\n+                }\n+\n+                // Type, Interface, Input are all treated similarly\n+                Type typeAnnotation = clazz.getAnnotation(Type.class);\n+                Interface interfaceAnnotation = clazz.getAnnotation(Interface.class);\n+                Input inputAnnotation = clazz.getAnnotation(Input.class);\n+\n+                if (typeAnnotation != null && inputAnnotation != null) {\n+                    ensureConfigurationException(LOGGER, \"Class \" + clazz.getName() + \" has been annotated with\"\n+                            + \" both Type and Input\");\n+                }\n+\n+                if (typeAnnotation != null || interfaceAnnotation != null) {\n+                    if (interfaceAnnotation != null && !clazz.isInterface()) {\n+                        ensureConfigurationException(LOGGER, \"Class \" + clazz.getName() + \" has been annotated with\"\n+                                + \" @Interface but is not one\");\n+                    }\n+\n+                    // assuming value for annotation overrides @Name\n+                    String typeName = getTypeName(clazz, true);\n+                    SchemaType type = SchemaType.builder()\n+                            .name(typeName.isBlank() ? clazz.getSimpleName() : typeName)\n+                            .valueClassName(clazz.getName()).build();\n+                    type.isInterface(clazz.isInterface());\n+                    type.description(getDescription(clazz.getAnnotation(Description.class)));\n+\n+                    // add the discovered type\n+                    addTypeToSchema(schema, type);\n+\n+                    if (type.isInterface()) {\n+                        // is an interface so check for any implementors and add them too\n+                        jandexUtils.getKnownImplementors(clazz.getName()).forEach(c -> setUnresolvedTypes.add(c.getName()));\n+                    }\n+                } else if (inputAnnotation != null) {\n+                    String clazzName = clazz.getName();\n+                    String simpleName = clazz.getSimpleName();\n+\n+                    SchemaInputType inputType = generateType(clazzName, true).createInputType(\"\");\n+                    // if the name of the InputType was not changed then append \"Input\"\n+                    if (inputType.name().equals(simpleName)) {\n+                        inputType.name(inputType.name() + \"Input\");\n+                    }\n+\n+                    if (!schema.containsInputTypeWithName(inputType.name())) {\n+                        schema.addInputType(inputType);\n+                        checkInputType(schema, inputType);\n+                    }\n+                }\n+\n+                // obtain top level query API's\n+                if (clazz.isAnnotationPresent(GraphQLApi.class)) {\n+                    processGraphQLApiAnnotations(rootQueryType, rootMutationType, schema, clazz);\n+                }\n+            }\n+        }\n+\n+        schema.addType(rootQueryType);\n+        schema.addType(rootMutationType);\n+\n+        // process unresolved types\n+        processUnresolvedTypes(schema);\n+\n+        // look though all of interface type and see if any of the known types implement\n+        // the interface and if so, add the interface to the type\n+        schema.getTypes().stream().filter(SchemaType::isInterface).forEach(it -> {\n+            schema.getTypes().stream().filter(t -> !t.isInterface() && t.valueClassName() != null).forEach(type -> {\n+                Class<?> interfaceClass = getSafeClass(it.valueClassName());\n+                Class<?> typeClass = getSafeClass(type.valueClassName());\n+                if (interfaceClass != null\n+                        && typeClass != null\n+                        && interfaceClass.isAssignableFrom(typeClass)) {\n+                    type.implementingInterface(it.name());\n+                }\n+            });\n+        });\n+\n+        // process any additional methods required via the @Source annotation\n+        for (DiscoveredMethod dm : setAdditionalMethods) {\n+            // add the discovered method to the type\n+            SchemaType type = schema.getTypeByClass(dm.source());\n+            if (type != null) {\n+                SchemaFieldDefinition fd = newFieldDefinition(dm, null);\n+                // add all arguments which are not source arguments\n+                if (dm.arguments().size() > 0) {\n+                    dm.arguments().stream().filter(a -> !a.isSourceArgument())\n+                            .forEach(fd::addArgument);\n+                }\n+\n+                // check for existing DataFetcher\n+                fd.dataFetcher(DataFetcherUtils.newMethodDataFetcher(\n+                        schema, dm.method().getDeclaringClass(), dm.method(),\n+                        dm.source(), fd.arguments().toArray(new SchemaArgument[0])));\n+                type.addFieldDefinition(fd);\n+\n+                // we are creating this as a type so ignore any Input annotation\n+                String simpleName = getSimpleName(fd.returnType(), true);\n+                String returnType = fd.returnType();\n+                if (!simpleName.equals(returnType)) {\n+                    updateLongTypes(schema, returnType, simpleName);\n+                }\n+            }\n+        }\n+\n+        // process default values for dates\n+        processDefaultDateTimeValues(schema);\n+\n+        // process the @GraphQLApi annotated classes\n+        if (rootQueryType.fieldDefinitions().size() == 0 && rootMutationType.fieldDefinitions().size() == 0) {\n+            LOGGER.warning(\"Unable to find any classes with @GraphQLApi annotation.\"\n+                                   + \"Unable to build schema\");\n+        }\n+\n+        return schema;\n+    }\n+\n+    /**\n+     * Process all {@link SchemaFieldDefinition}s and {@link SchemaArgument}s and update the default values for any scalars.\n+     *\n+     * @param schema {@link Schema} to update\n+     */\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    private void processDefaultDateTimeValues(Schema schema) {\n+        // concatenate both the SchemaType and SchemaInputType\n+        Stream streamInputTypes = schema.getInputTypes().stream().map(it -> (SchemaType) it);\n+        Stream<SchemaType> streamAll = Stream.concat(streamInputTypes, schema.getTypes().stream());\n+        streamAll.forEach(t -> {\n+            t.fieldDefinitions().forEach(fd -> {\n+                String returnType = fd.returnType();\n+                // only check Date/Time/DateTime scalars that are not Queries or don't have data fetchers\n+                // as default formatting has already been dealt with\n+                if (isDateTimeScalar(returnType) && (t.name().equals(Schema.QUERY) || fd.dataFetcher() == null)) {\n+                    String[] existingFormat = fd.format();\n+                    // check if this type is an array type and if so then get the actual original type\n+                    Class<?> clazzOriginalType = fd.originalArrayType() != null\n+                            ? fd.originalArrayType() : fd.originalType();\n+                    String[] newFormat = ensureFormat(returnType, clazzOriginalType.getName(), existingFormat);\n+                    if (!Arrays.equals(newFormat, existingFormat) && newFormat.length == 2) {\n+                        // formats differ so set the new format and DataFetcher\n+                        fd.format(newFormat);\n+                        if (fd.dataFetcher() == null) {\n+                            // create the raw array to pass to the retrieveFormattingDataFetcher method\n+                            DataFetcher dataFetcher = retrieveFormattingDataFetcher(\n+                                    new String[] {DATE, newFormat[0], newFormat[1]},\n+                                    fd.name(), clazzOriginalType.getName());\n+                            fd.dataFetcher(dataFetcher);\n+                        }\n+                        fd.defaultFormatApplied(true);\n+                        SchemaScalar scalar = schema.getScalarByName(fd.returnType());\n+                        GraphQLScalarType newScalarType = null;\n+                        if (fd.returnType().equals(FORMATTED_DATE_SCALAR)) {\n+                            fd.returnType(DATE_SCALAR);\n+                            newScalarType = CUSTOM_DATE_SCALAR;\n+                        } else if (fd.returnType().equals(FORMATTED_TIME_SCALAR)) {\n+                            fd.returnType(TIME_SCALAR);\n+                            newScalarType = CUSTOM_TIME_SCALAR;\n+                        } else if (fd.returnType().equals(FORMATTED_DATETIME_SCALAR)) {\n+                            fd.returnType(DATETIME_SCALAR);\n+                            newScalarType = CUSTOM_DATE_TIME_SCALAR;\n+                        } else if (fd.returnType().equals(FORMATTED_OFFSET_DATETIME_SCALAR)) {\n+                            fd.returnType(FORMATTED_OFFSET_DATETIME_SCALAR);\n+                            newScalarType = CUSTOM_OFFSET_DATE_TIME_SCALAR;\n+                        } else if (fd.returnType().equals(FORMATTED_ZONED_DATETIME_SCALAR)) {\n+                            fd.returnType(FORMATTED_ZONED_DATETIME_SCALAR);\n+                            newScalarType = CUSTOM_ZONED_DATE_TIME_SCALAR;\n+                        }\n+\n+                        // clone the scalar with the new scalar name\n+                        SchemaScalar newScalar = new SchemaScalar(fd.returnType(), scalar.actualClass(),\n+                                                                  newScalarType, scalar.defaultFormat());\n+                        if (!schema.containsScalarWithName(newScalar.name())) {\n+                            schema.addScalar(newScalar);\n+                        }\n+                    }\n+                }\n+\n+                // check the SchemaArguments\n+                fd.arguments().forEach(a -> {\n+                    String argumentType = a.argumentType();\n+                    if (isDateTimeScalar(argumentType)) {\n+                        String[] existingArgFormat = a.format();\n+                        Class<?> clazzOriginalType = a.originalArrayType() != null\n+                                ? a.originalArrayType() : a.originalType();\n+                        String[] newArgFormat = ensureFormat(argumentType, clazzOriginalType.getName(), existingArgFormat);\n+                        if (!Arrays.equals(newArgFormat, existingArgFormat) && newArgFormat.length == 2) {\n+                            a.format(newArgFormat);\n+                        }\n+                    }\n+                });\n+            });\n+        });\n+    }\n+\n+    /**\n+     * Process any unresolved types.\n+     *\n+     * @param schema {@link Schema} to add types to\n+     */\n+    private void processUnresolvedTypes(Schema schema) {\n+        // create any types that are still unresolved. e.g. an Order that contains OrderLine objects\n+        // also ensure if the unresolved type contains another unresolved type then we process it\n+        while (setUnresolvedTypes.size() > 0) {\n+            String returnType = setUnresolvedTypes.iterator().next();\n+\n+            setUnresolvedTypes.remove(returnType);\n+            try {\n+                String simpleName = getSimpleName(returnType, true);\n+\n+                SchemaScalar scalar = getScalar(returnType);\n+                if (scalar != null) {\n+                    if (!schema.containsScalarWithName(scalar.name())) {\n+                        schema.addScalar(scalar);\n+                    }\n+                    // update the return type with the scalar\n+                    updateLongTypes(schema, returnType, scalar.name());\n+                } else if (isEnumClass(returnType)) {\n+                    SchemaEnum newEnum = generateEnum(Class.forName(returnType));\n+                    if (!schema.containsEnumWithName(simpleName)) {\n+                        schema.addEnum(newEnum);\n+                    }\n+                    updateLongTypes(schema, returnType, newEnum.name());\n+                } else {\n+                    // we will either know this type already or need to add it\n+                    boolean fExists = schema.getTypes().stream()\n+                            .filter(t -> t.name().equals(simpleName)).count() > 0;", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxMTM3NQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522211375", "bodyText": "Should the server be shut down at the end of the test?", "author": "tjquinno", "createdAt": "2020-11-12T15:51:18Z", "path": "graphql/server/src/test/java/io/helidon/graphql/server/GraphQlSupportTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.graphql.server;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.helidon.media.jsonb.JsonbSupport;\n+import io.helidon.webclient.WebClient;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.WebServer;\n+\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.StaticDataFetcher;\n+import graphql.schema.idl.RuntimeWiring;\n+import graphql.schema.idl.SchemaGenerator;\n+import graphql.schema.idl.SchemaParser;\n+import graphql.schema.idl.TypeDefinitionRegistry;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+class GraphQlSupportTest {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    void testHelloWorld() {\n+        WebServer server = WebServer.builder()\n+                .routing(Routing.builder()\n+                                 .register(GraphQlSupport.create(buildSchema()))\n+                                 .build())\n+                .build()\n+                .start()", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxMzcxNw==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522213717", "bodyText": "New file. Remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T15:54:15Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/AbstractDescriptiveElement.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNDAxMg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522214012", "bodyText": "New file. Remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T15:54:34Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/CustomScalars.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNjIyMA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522216220", "bodyText": "Casting to String is harmless here, but it surprised me given the method's return type is Object anyway.", "author": "tjquinno", "createdAt": "2020-11-12T15:57:28Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/CustomScalars.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n+\n+import graphql.Scalars;\n+import graphql.language.StringValue;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.Coercing;\n+import graphql.schema.CoercingParseLiteralException;\n+import graphql.schema.CoercingParseValueException;\n+import graphql.schema.CoercingSerializeException;\n+import graphql.schema.GraphQLScalarType;\n+\n+import static graphql.Scalars.GraphQLBigInteger;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_OFFSET_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_ZONED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.TIME_SCALAR;\n+\n+/**\n+ * Custom scalars.\n+ */\n+class CustomScalars {\n+\n+    /**\n+     * Private no-args constructor.\n+     */\n+    private CustomScalars() {\n+    }\n+\n+    /**\n+     * An instance of a custome BigDecimal Scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGDECIMAL_SCALAR = newCustomBigDecimalScalar();\n+\n+    /**\n+     * An instance of a custom Int scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_INT_SCALAR = newCustomGraphQLInt();\n+\n+    /**\n+     * An instance of a custom Float scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_FLOAT_SCALAR = newCustomGraphQLFloat();\n+\n+    /**\n+     * An instance of a custom BigInteger scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGINTEGER_SCALAR = newCustomGraphQLBigInteger();\n+\n+    /**\n+     * An instance of a custom formatted date/time scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(FORMATTED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted time scalar.\n+     */\n+     static final GraphQLScalarType FORMATTED_CUSTOM_TIME_SCALAR = newTimeScalar(FORMATTED_TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted date scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_SCALAR = newDateScalar(FORMATTED_DATE_SCALAR);\n+\n+    /**\n+     * An instance of a custom date/time scalar (with default formatting).\n+     */\n+    static final GraphQLScalarType CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_OFFSET_DATE_TIME_SCALAR =\n+            newOffsetDateTimeScalar(FORMATTED_OFFSET_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_ZONED_DATE_TIME_SCALAR =\n+            newZonedDateTimeScalar(FORMATTED_ZONED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_TIME_SCALAR = newTimeScalar(TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom date scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_DATE_SCALAR = newDateScalar(DATE_SCALAR);\n+\n+    /**\n+     * Return a new custom date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+     static GraphQLScalarType newDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom offset date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newOffsetDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom zoned date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newZonedDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom time scalar\n+     */\n+     static GraphQLScalarType newTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Time;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new TimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom date scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date scalar\n+     */\n+     static GraphQLScalarType newDateScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Date;\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigDecimal scalar.\n+     *\n+     * @return a new custom BigDecimal scalar\n+     */\n+    private static GraphQLScalarType newCustomBigDecimalScalar() {\n+        GraphQLScalarType originalScalar = Scalars.GraphQLBigDecimal;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigDecimal>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Int scalar.\n+     *\n+     * @return a new custom Int scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLInt() {\n+        GraphQLScalarType originalScalar = GraphQLInt;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Integer>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Float scalar.\n+     *\n+     * @return a new custom Float scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLFloat() {\n+        GraphQLScalarType originalScalar = GraphQLFloat;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Double>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigInteger scalar.\n+     *\n+     * @return a new custom BigInteger scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLBigInteger() {\n+        GraphQLScalarType originalScalar = GraphQLBigInteger;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigInteger>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Abstract implementation of {@link Coercing} interface for given classes.\n+     */\n+     abstract static class AbstractDateTimeCoercing implements Coercing {\n+\n+        /**\n+         * {@link Class}es that can be coerced.\n+         */\n+        private final Class<?>[] clazzes;\n+\n+        /**\n+         * Construct a {@link AbstractDateTimeCoercing}.\n+         *\n+         * @param clazzes {@link Class}es to coerce\n+         */\n+         AbstractDateTimeCoercing(Class<?>... clazzes) {\n+            this.clazzes = clazzes;\n+        }\n+\n+        @Override\n+        public Object serialize(Object dataFetcherResult) throws CoercingSerializeException {\n+            return convert(dataFetcherResult);\n+        }\n+\n+        @Override\n+        public Object parseValue(Object input) throws CoercingParseValueException {\n+            return convert(input);\n+        }\n+\n+        @Override\n+        public Object parseLiteral(Object input) throws CoercingParseLiteralException {\n+            return parseStringLiteral(input);\n+        }\n+\n+        /**\n+         * Convert the given input to the type of if a String then leave it be.\n+         *\n+         * @param input input to coerce\n+         * @return the coerced value\n+         * @throws CoercingParseLiteralException if any exceptions converting\n+         */\n+        private Object convert(Object input) throws CoercingParseLiteralException {\n+            if (input instanceof String) {\n+                return (String) input;", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1MzQ3Ng==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r534553476", "bodyText": "fair enough.", "author": "tmiddlet2666", "createdAt": "2020-12-02T23:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIxNjIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNTc0NQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522235745", "bodyText": "Maybe I'm confused, but we want to check if the input argument is an instance of one of the coercible classes, IIUC. If so, I'd expect to see something like i.e. clazz.instanceOf(input). I'm not sure what's in the source does what we want (assuming I understand the intent correctly), but even if it does it seems more complicated than needed.", "author": "tjquinno", "createdAt": "2020-11-12T16:22:22Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/CustomScalars.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n+\n+import graphql.Scalars;\n+import graphql.language.StringValue;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.Coercing;\n+import graphql.schema.CoercingParseLiteralException;\n+import graphql.schema.CoercingParseValueException;\n+import graphql.schema.CoercingSerializeException;\n+import graphql.schema.GraphQLScalarType;\n+\n+import static graphql.Scalars.GraphQLBigInteger;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_OFFSET_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_ZONED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.TIME_SCALAR;\n+\n+/**\n+ * Custom scalars.\n+ */\n+class CustomScalars {\n+\n+    /**\n+     * Private no-args constructor.\n+     */\n+    private CustomScalars() {\n+    }\n+\n+    /**\n+     * An instance of a custome BigDecimal Scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGDECIMAL_SCALAR = newCustomBigDecimalScalar();\n+\n+    /**\n+     * An instance of a custom Int scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_INT_SCALAR = newCustomGraphQLInt();\n+\n+    /**\n+     * An instance of a custom Float scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_FLOAT_SCALAR = newCustomGraphQLFloat();\n+\n+    /**\n+     * An instance of a custom BigInteger scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGINTEGER_SCALAR = newCustomGraphQLBigInteger();\n+\n+    /**\n+     * An instance of a custom formatted date/time scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(FORMATTED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted time scalar.\n+     */\n+     static final GraphQLScalarType FORMATTED_CUSTOM_TIME_SCALAR = newTimeScalar(FORMATTED_TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted date scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_SCALAR = newDateScalar(FORMATTED_DATE_SCALAR);\n+\n+    /**\n+     * An instance of a custom date/time scalar (with default formatting).\n+     */\n+    static final GraphQLScalarType CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_OFFSET_DATE_TIME_SCALAR =\n+            newOffsetDateTimeScalar(FORMATTED_OFFSET_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_ZONED_DATE_TIME_SCALAR =\n+            newZonedDateTimeScalar(FORMATTED_ZONED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_TIME_SCALAR = newTimeScalar(TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom date scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_DATE_SCALAR = newDateScalar(DATE_SCALAR);\n+\n+    /**\n+     * Return a new custom date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+     static GraphQLScalarType newDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom offset date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newOffsetDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom zoned date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newZonedDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom time scalar\n+     */\n+     static GraphQLScalarType newTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Time;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new TimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom date scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date scalar\n+     */\n+     static GraphQLScalarType newDateScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Date;\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigDecimal scalar.\n+     *\n+     * @return a new custom BigDecimal scalar\n+     */\n+    private static GraphQLScalarType newCustomBigDecimalScalar() {\n+        GraphQLScalarType originalScalar = Scalars.GraphQLBigDecimal;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigDecimal>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Int scalar.\n+     *\n+     * @return a new custom Int scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLInt() {\n+        GraphQLScalarType originalScalar = GraphQLInt;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Integer>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Float scalar.\n+     *\n+     * @return a new custom Float scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLFloat() {\n+        GraphQLScalarType originalScalar = GraphQLFloat;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Double>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigInteger scalar.\n+     *\n+     * @return a new custom BigInteger scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLBigInteger() {\n+        GraphQLScalarType originalScalar = GraphQLBigInteger;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigInteger>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Abstract implementation of {@link Coercing} interface for given classes.\n+     */\n+     abstract static class AbstractDateTimeCoercing implements Coercing {\n+\n+        /**\n+         * {@link Class}es that can be coerced.\n+         */\n+        private final Class<?>[] clazzes;\n+\n+        /**\n+         * Construct a {@link AbstractDateTimeCoercing}.\n+         *\n+         * @param clazzes {@link Class}es to coerce\n+         */\n+         AbstractDateTimeCoercing(Class<?>... clazzes) {\n+            this.clazzes = clazzes;\n+        }\n+\n+        @Override\n+        public Object serialize(Object dataFetcherResult) throws CoercingSerializeException {\n+            return convert(dataFetcherResult);\n+        }\n+\n+        @Override\n+        public Object parseValue(Object input) throws CoercingParseValueException {\n+            return convert(input);\n+        }\n+\n+        @Override\n+        public Object parseLiteral(Object input) throws CoercingParseLiteralException {\n+            return parseStringLiteral(input);\n+        }\n+\n+        /**\n+         * Convert the given input to the type of if a String then leave it be.\n+         *\n+         * @param input input to coerce\n+         * @return the coerced value\n+         * @throws CoercingParseLiteralException if any exceptions converting\n+         */\n+        private Object convert(Object input) throws CoercingParseLiteralException {\n+            if (input instanceof String) {\n+                return (String) input;\n+            }\n+\n+            for (Class<?> clazz : clazzes) {\n+                if (input.getClass().isInstance(clazz)) {", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNjY2NQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522236665", "bodyText": "Again, the cast seems unnecessary given that the return type is Object.", "author": "tjquinno", "createdAt": "2020-11-12T16:23:40Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/CustomScalars.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n+\n+import graphql.Scalars;\n+import graphql.language.StringValue;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.Coercing;\n+import graphql.schema.CoercingParseLiteralException;\n+import graphql.schema.CoercingParseValueException;\n+import graphql.schema.CoercingSerializeException;\n+import graphql.schema.GraphQLScalarType;\n+\n+import static graphql.Scalars.GraphQLBigInteger;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_OFFSET_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_ZONED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.TIME_SCALAR;\n+\n+/**\n+ * Custom scalars.\n+ */\n+class CustomScalars {\n+\n+    /**\n+     * Private no-args constructor.\n+     */\n+    private CustomScalars() {\n+    }\n+\n+    /**\n+     * An instance of a custome BigDecimal Scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGDECIMAL_SCALAR = newCustomBigDecimalScalar();\n+\n+    /**\n+     * An instance of a custom Int scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_INT_SCALAR = newCustomGraphQLInt();\n+\n+    /**\n+     * An instance of a custom Float scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_FLOAT_SCALAR = newCustomGraphQLFloat();\n+\n+    /**\n+     * An instance of a custom BigInteger scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGINTEGER_SCALAR = newCustomGraphQLBigInteger();\n+\n+    /**\n+     * An instance of a custom formatted date/time scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(FORMATTED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted time scalar.\n+     */\n+     static final GraphQLScalarType FORMATTED_CUSTOM_TIME_SCALAR = newTimeScalar(FORMATTED_TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted date scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_SCALAR = newDateScalar(FORMATTED_DATE_SCALAR);\n+\n+    /**\n+     * An instance of a custom date/time scalar (with default formatting).\n+     */\n+    static final GraphQLScalarType CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_OFFSET_DATE_TIME_SCALAR =\n+            newOffsetDateTimeScalar(FORMATTED_OFFSET_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_ZONED_DATE_TIME_SCALAR =\n+            newZonedDateTimeScalar(FORMATTED_ZONED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_TIME_SCALAR = newTimeScalar(TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom date scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_DATE_SCALAR = newDateScalar(DATE_SCALAR);\n+\n+    /**\n+     * Return a new custom date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+     static GraphQLScalarType newDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom offset date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newOffsetDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom zoned date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newZonedDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom time scalar\n+     */\n+     static GraphQLScalarType newTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Time;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new TimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom date scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date scalar\n+     */\n+     static GraphQLScalarType newDateScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Date;\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigDecimal scalar.\n+     *\n+     * @return a new custom BigDecimal scalar\n+     */\n+    private static GraphQLScalarType newCustomBigDecimalScalar() {\n+        GraphQLScalarType originalScalar = Scalars.GraphQLBigDecimal;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigDecimal>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Int scalar.\n+     *\n+     * @return a new custom Int scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLInt() {\n+        GraphQLScalarType originalScalar = GraphQLInt;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Integer>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Float scalar.\n+     *\n+     * @return a new custom Float scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLFloat() {\n+        GraphQLScalarType originalScalar = GraphQLFloat;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Double>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigInteger scalar.\n+     *\n+     * @return a new custom BigInteger scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLBigInteger() {\n+        GraphQLScalarType originalScalar = GraphQLBigInteger;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigInteger>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Abstract implementation of {@link Coercing} interface for given classes.\n+     */\n+     abstract static class AbstractDateTimeCoercing implements Coercing {\n+\n+        /**\n+         * {@link Class}es that can be coerced.\n+         */\n+        private final Class<?>[] clazzes;\n+\n+        /**\n+         * Construct a {@link AbstractDateTimeCoercing}.\n+         *\n+         * @param clazzes {@link Class}es to coerce\n+         */\n+         AbstractDateTimeCoercing(Class<?>... clazzes) {\n+            this.clazzes = clazzes;\n+        }\n+\n+        @Override\n+        public Object serialize(Object dataFetcherResult) throws CoercingSerializeException {\n+            return convert(dataFetcherResult);\n+        }\n+\n+        @Override\n+        public Object parseValue(Object input) throws CoercingParseValueException {\n+            return convert(input);\n+        }\n+\n+        @Override\n+        public Object parseLiteral(Object input) throws CoercingParseLiteralException {\n+            return parseStringLiteral(input);\n+        }\n+\n+        /**\n+         * Convert the given input to the type of if a String then leave it be.\n+         *\n+         * @param input input to coerce\n+         * @return the coerced value\n+         * @throws CoercingParseLiteralException if any exceptions converting\n+         */\n+        private Object convert(Object input) throws CoercingParseLiteralException {\n+            if (input instanceof String) {\n+                return (String) input;\n+            }\n+\n+            for (Class<?> clazz : clazzes) {\n+                if (input.getClass().isInstance(clazz)) {\n+                    return clazz.cast(input);", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzNzYyMA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522237620", "bodyText": "Again, why cast here?", "author": "tjquinno", "createdAt": "2020-11-12T16:24:53Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/CustomScalars.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n+\n+import graphql.Scalars;\n+import graphql.language.StringValue;\n+import graphql.scalars.ExtendedScalars;\n+import graphql.schema.Coercing;\n+import graphql.schema.CoercingParseLiteralException;\n+import graphql.schema.CoercingParseValueException;\n+import graphql.schema.CoercingSerializeException;\n+import graphql.schema.GraphQLScalarType;\n+\n+import static graphql.Scalars.GraphQLBigInteger;\n+import static graphql.Scalars.GraphQLFloat;\n+import static graphql.Scalars.GraphQLInt;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_OFFSET_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.FORMATTED_ZONED_DATETIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.TIME_SCALAR;\n+\n+/**\n+ * Custom scalars.\n+ */\n+class CustomScalars {\n+\n+    /**\n+     * Private no-args constructor.\n+     */\n+    private CustomScalars() {\n+    }\n+\n+    /**\n+     * An instance of a custome BigDecimal Scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGDECIMAL_SCALAR = newCustomBigDecimalScalar();\n+\n+    /**\n+     * An instance of a custom Int scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_INT_SCALAR = newCustomGraphQLInt();\n+\n+    /**\n+     * An instance of a custom Float scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_FLOAT_SCALAR = newCustomGraphQLFloat();\n+\n+    /**\n+     * An instance of a custom BigInteger scalar.\n+     */\n+    static final GraphQLScalarType CUSTOM_BIGINTEGER_SCALAR = newCustomGraphQLBigInteger();\n+\n+    /**\n+     * An instance of a custom formatted date/time scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(FORMATTED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted time scalar.\n+     */\n+     static final GraphQLScalarType FORMATTED_CUSTOM_TIME_SCALAR = newTimeScalar(FORMATTED_TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom formatted date scalar.\n+     */\n+    static final GraphQLScalarType FORMATTED_CUSTOM_DATE_SCALAR = newDateScalar(FORMATTED_DATE_SCALAR);\n+\n+    /**\n+     * An instance of a custom date/time scalar (with default formatting).\n+     */\n+    static final GraphQLScalarType CUSTOM_DATE_TIME_SCALAR = newDateTimeScalar(DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_OFFSET_DATE_TIME_SCALAR =\n+            newOffsetDateTimeScalar(FORMATTED_OFFSET_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom offset date/time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_ZONED_DATE_TIME_SCALAR =\n+            newZonedDateTimeScalar(FORMATTED_ZONED_DATETIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom time scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_TIME_SCALAR = newTimeScalar(TIME_SCALAR);\n+\n+    /**\n+     * An instance of a custom date scalar (with default formatting).\n+     */\n+     static final GraphQLScalarType CUSTOM_DATE_SCALAR = newDateScalar(DATE_SCALAR);\n+\n+    /**\n+     * Return a new custom date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+     static GraphQLScalarType newDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom offset date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newOffsetDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom zoned date/time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date/time scalar\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static GraphQLScalarType newZonedDateTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.DateTime;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom time scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom time scalar\n+     */\n+     static GraphQLScalarType newTimeScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Time;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new TimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom date scalar.\n+     *\n+     * @param name the name of the scalar\n+     * @return a new custom date scalar\n+     */\n+     static GraphQLScalarType newDateScalar(String name) {\n+        GraphQLScalarType originalScalar = ExtendedScalars.Date;\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new DateTimeCoercing())\n+                .name(name)\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigDecimal scalar.\n+     *\n+     * @return a new custom BigDecimal scalar\n+     */\n+    private static GraphQLScalarType newCustomBigDecimalScalar() {\n+        GraphQLScalarType originalScalar = Scalars.GraphQLBigDecimal;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigDecimal>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Int scalar.\n+     *\n+     * @return a new custom Int scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLInt() {\n+        GraphQLScalarType originalScalar = GraphQLInt;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Integer>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom Float scalar.\n+     *\n+     * @return a new custom Float scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLFloat() {\n+        GraphQLScalarType originalScalar = GraphQLFloat;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<Double>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Return a new custom BigInteger scalar.\n+     *\n+     * @return a new custom BigInteger scalar\n+     */\n+    private static GraphQLScalarType newCustomGraphQLBigInteger() {\n+        GraphQLScalarType originalScalar = GraphQLBigInteger;\n+\n+        return GraphQLScalarType.newScalar()\n+                .coercing(new NumberCoercing<BigInteger>(originalScalar.getCoercing()))\n+                .name(originalScalar.getName())\n+                .description(\"Custom: \" + originalScalar.getDescription())\n+                .build();\n+    }\n+\n+    /**\n+     * Abstract implementation of {@link Coercing} interface for given classes.\n+     */\n+     abstract static class AbstractDateTimeCoercing implements Coercing {\n+\n+        /**\n+         * {@link Class}es that can be coerced.\n+         */\n+        private final Class<?>[] clazzes;\n+\n+        /**\n+         * Construct a {@link AbstractDateTimeCoercing}.\n+         *\n+         * @param clazzes {@link Class}es to coerce\n+         */\n+         AbstractDateTimeCoercing(Class<?>... clazzes) {\n+            this.clazzes = clazzes;\n+        }\n+\n+        @Override\n+        public Object serialize(Object dataFetcherResult) throws CoercingSerializeException {\n+            return convert(dataFetcherResult);\n+        }\n+\n+        @Override\n+        public Object parseValue(Object input) throws CoercingParseValueException {\n+            return convert(input);\n+        }\n+\n+        @Override\n+        public Object parseLiteral(Object input) throws CoercingParseLiteralException {\n+            return parseStringLiteral(input);\n+        }\n+\n+        /**\n+         * Convert the given input to the type of if a String then leave it be.\n+         *\n+         * @param input input to coerce\n+         * @return the coerced value\n+         * @throws CoercingParseLiteralException if any exceptions converting\n+         */\n+        private Object convert(Object input) throws CoercingParseLiteralException {\n+            if (input instanceof String) {\n+                return (String) input;\n+            }\n+\n+            for (Class<?> clazz : clazzes) {\n+                if (input.getClass().isInstance(clazz)) {\n+                    return clazz.cast(input);\n+                }\n+            }\n+\n+            throw new CoercingParseLiteralException(\"Unable to convert type of \" + input.getClass());\n+        }\n+\n+        /**\n+         * Parse a String literal and return instance of {@link StringValue} or throw an exception.\n+         *\n+         * @param input input to parse\n+         * @throws CoercingParseLiteralException if it is not a {@link StringValue}\n+         */\n+        private String parseStringLiteral(Object input) throws CoercingParseLiteralException {\n+            if (!(input instanceof StringValue)) {\n+                throw new CoercingParseLiteralException(\"Expected AST type 'StringValue' but was '\"\n+                                                                + (\n+                        input == null\n+                                ? \"null\"\n+                                : input.getClass().getSimpleName()) + \"'.\");\n+            }\n+            return ((StringValue) input).getValue();\n+        }\n+    }\n+\n+    /**\n+     * Coercing Implementation for Date/Time.\n+     */\n+     static class DateTimeCoercing extends AbstractDateTimeCoercing {\n+\n+        /**\n+         * Construct a {@link DateTimeCoercing}.\n+         */\n+         DateTimeCoercing() {\n+            super(LocalDateTime.class, OffsetDateTime.class, ZonedDateTime.class);\n+        }\n+    }\n+\n+    /**\n+     * Coercing implementation for Time.\n+     */\n+     static class TimeCoercing extends AbstractDateTimeCoercing {\n+\n+        /**\n+         * Construct a {@link TimeCoercing}.\n+         */\n+         TimeCoercing() {\n+            super(LocalTime.class, OffsetTime.class);\n+        }\n+    }\n+\n+    /**\n+     * Coercing implementation for Date.\n+     */\n+     static class DateCoercing extends AbstractDateTimeCoercing {\n+\n+        /**\n+         * Construct a {@link DateCoercing}.\n+         */\n+         DateCoercing() {\n+            super(LocalDate.class);\n+        }\n+    }\n+\n+    /**\n+     * Coercing implementation for BigDecimal.\n+     */\n+     static class BigDecimalCoercing extends AbstractDateTimeCoercing {\n+\n+        /**\n+         * Construct a {@link DateCoercing}.\n+         */\n+         BigDecimalCoercing() {\n+            super(BigDecimal.class);\n+        }\n+    }\n+\n+    /**\n+     * Number implementation of {@link Coercing} interface for given classes.\n+     * @param <I> defines input type\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+     static class NumberCoercing<I> implements Coercing<I, Object> {\n+\n+        /**\n+         * Original {@link Coercing} to fall back on if neeed.\n+         */\n+        private final Coercing originalCoercing;\n+\n+        /**\n+         * Construct a {@link NumberCoercing} from an original {@link Coercing}.\n+         *\n+         * @param originalCoercing original {@link Coercing}\n+         */\n+         NumberCoercing(Coercing originalCoercing) {\n+            this.originalCoercing = originalCoercing;\n+        }\n+\n+        @Override\n+        public Object serialize(Object dataFetcherResult) throws CoercingSerializeException {\n+            return dataFetcherResult instanceof String\n+                    ? (String) dataFetcherResult", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0MjU5MA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522242590", "bodyText": "I don't know exactly what argument.originalType() can return, but if it could be a subtype of Map then as written this test would let that through -- because Map is not guaranteed to be assignable to a subtype -- but I don't think that's the intent.\nWhat about if (originalType != null && Map.class.isAssignableFrom(originalType))  instead? Then if the originalType is any Map we'd detect it.\nOr maybe I'm missing something.", "author": "tjquinno", "createdAt": "2020-11-12T16:31:11Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/DataFetcherUtils.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.NumberFormat;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.inject.spi.CDI;\n+\n+import io.helidon.graphql.server.ExecutionContext;\n+\n+import graphql.GraphQLException;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.DataFetchingEnvironment;\n+import graphql.schema.PropertyDataFetcher;\n+import graphql.schema.PropertyDataFetcherHelper;\n+\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.formatDate;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.formatNumber;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getCorrectDateFormatter;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getCorrectNumberFormat;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.isFormatEmpty;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ID;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ensureRuntimeException;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isDateTimeClass;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isPrimitiveArray;\n+\n+/**\n+ * Utilities for working with {@link DataFetcher}s.\n+ */\n+class DataFetcherUtils {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(DataFetcherUtils.class.getName());\n+\n+    /**\n+     * Empty format.\n+     */\n+    private static final String[] EMPTY_FORMAT = new String[] {null, null };\n+\n+    /**\n+     * Map message.\n+     */\n+    private static final String MAP_MESSAGE = \"This implementation does not support using a Map \"\n+            + \"as input to a query or mutation\";\n+\n+    /**\n+     * Private constructor for utilities class.\n+     */\n+    private DataFetcherUtils() {\n+    }\n+\n+    /**\n+     * Create a new {@link DataFetcher} for a {@link Class} and {@link Method} to be executed.\n+     *\n+     * @param clazz  {@link Class} to call\n+     * @param method {@link Method} to call\n+     * @param source defines the source for a @Source annotation - may be null\n+     * @param args   optional {@link SchemaArgument}s\n+     * @param schema {@link Schema} that created this {@link DataFetcher}\n+     * @param <V>    value type\n+     * @return a new {@link DataFetcher}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <V> DataFetcher<V> newMethodDataFetcher(Schema schema, Class<?> clazz, Method method,\n+                                                          String source, SchemaArgument... args) {\n+\n+        // this is an application scoped bean\n+        GraphQlBean bean = CDI.current().select(GraphQlBean.class).get();\n+\n+        return environment -> {\n+            ArrayList<Object> listArgumentValues = new ArrayList<>();\n+            // only one @Source annotation should be present and it should be the first argument\n+            if (source != null) {\n+                Class<?> sourceClazz;\n+                try {\n+                    sourceClazz = Class.forName(source);\n+                    listArgumentValues.add(sourceClazz.cast(environment.getSource()));\n+                } catch (ClassNotFoundException e) {\n+                    LOGGER.warning(\"Unable to find source class \" + source);\n+                }\n+            }\n+\n+            if (args.length > 0) {\n+                for (SchemaArgument argument : args) {\n+                    // ensure a Map is not used as an input type\n+                    Class<?> originalType = argument.originalType();\n+                    if (originalType != null && originalType.isAssignableFrom(Map.class)) {", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1OTQ1Mg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r534559452", "bodyText": "my mistake, you are correct.", "author": "tmiddlet2666", "createdAt": "2020-12-02T23:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0MjU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0ODE2MQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522248161", "bodyText": "Is originalType guaranteed to be the interface type (List here, or Set or Collection a couple lines below) and never a sub-interface or an implementation class? If not, then the direct equals comparison will miss ArrayLists or HashSets, for example.\nAlso confusing me about this: I interpret the JavaDoc for the originalType argument to mean that originalType is the type of the elements in the collection, not the type of the collection itself.", "author": "tjquinno", "createdAt": "2020-11-12T16:38:42Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/DataFetcherUtils.java", "diffHunk": "@@ -0,0 +1,596 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.NumberFormat;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.inject.spi.CDI;\n+\n+import io.helidon.graphql.server.ExecutionContext;\n+\n+import graphql.GraphQLException;\n+import graphql.schema.DataFetcher;\n+import graphql.schema.DataFetchingEnvironment;\n+import graphql.schema.PropertyDataFetcher;\n+import graphql.schema.PropertyDataFetcherHelper;\n+\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.formatDate;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.formatNumber;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getCorrectDateFormatter;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getCorrectNumberFormat;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.isFormatEmpty;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ID;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.ensureRuntimeException;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isDateTimeClass;\n+import static io.helidon.microprofile.graphql.server.SchemaGeneratorHelper.isPrimitiveArray;\n+\n+/**\n+ * Utilities for working with {@link DataFetcher}s.\n+ */\n+class DataFetcherUtils {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(DataFetcherUtils.class.getName());\n+\n+    /**\n+     * Empty format.\n+     */\n+    private static final String[] EMPTY_FORMAT = new String[] {null, null };\n+\n+    /**\n+     * Map message.\n+     */\n+    private static final String MAP_MESSAGE = \"This implementation does not support using a Map \"\n+            + \"as input to a query or mutation\";\n+\n+    /**\n+     * Private constructor for utilities class.\n+     */\n+    private DataFetcherUtils() {\n+    }\n+\n+    /**\n+     * Create a new {@link DataFetcher} for a {@link Class} and {@link Method} to be executed.\n+     *\n+     * @param clazz  {@link Class} to call\n+     * @param method {@link Method} to call\n+     * @param source defines the source for a @Source annotation - may be null\n+     * @param args   optional {@link SchemaArgument}s\n+     * @param schema {@link Schema} that created this {@link DataFetcher}\n+     * @param <V>    value type\n+     * @return a new {@link DataFetcher}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <V> DataFetcher<V> newMethodDataFetcher(Schema schema, Class<?> clazz, Method method,\n+                                                          String source, SchemaArgument... args) {\n+\n+        // this is an application scoped bean\n+        GraphQlBean bean = CDI.current().select(GraphQlBean.class).get();\n+\n+        return environment -> {\n+            ArrayList<Object> listArgumentValues = new ArrayList<>();\n+            // only one @Source annotation should be present and it should be the first argument\n+            if (source != null) {\n+                Class<?> sourceClazz;\n+                try {\n+                    sourceClazz = Class.forName(source);\n+                    listArgumentValues.add(sourceClazz.cast(environment.getSource()));\n+                } catch (ClassNotFoundException e) {\n+                    LOGGER.warning(\"Unable to find source class \" + source);\n+                }\n+            }\n+\n+            if (args.length > 0) {\n+                for (SchemaArgument argument : args) {\n+                    // ensure a Map is not used as an input type\n+                    Class<?> originalType = argument.originalType();\n+                    if (originalType != null && originalType.isAssignableFrom(Map.class)) {\n+                        ensureRuntimeException(LOGGER, MAP_MESSAGE);\n+                    }\n+\n+                    if (argument.isArrayReturnType() && argument.arrayLevels() > 1\n+                            && SchemaGeneratorHelper.isPrimitiveArray(argument.originalType())) {\n+                        throw new GraphQlConfigurationException(\"This implementation does not currently support \"\n+                                                              + \"multi-level primitive arrays as arguments. Please use \"\n+                                                              + \"List or Collection of Object equivalent. E.g. \"\n+                                                              + \"In place of method(int [][] value) use \"\n+                                                              + \" method(List<List<Integer>> value)\");\n+                    }\n+\n+                    listArgumentValues.add(generateArgumentValue(schema, argument.argumentType(),\n+                                                                 argument.originalType(),\n+                                                                 argument.originalArrayType(),\n+                                                                 environment.getArgument(argument.argumentName()),\n+                                                                 argument.format()));\n+                }\n+            }\n+\n+            try {\n+                // this is the right place to validate security\n+                return (V)  bean.runGraphQl(clazz, method, listArgumentValues.toArray());\n+            } catch (InvocationTargetException e) {\n+                Throwable targetException = e.getTargetException();\n+                GraphQLException exception = new GraphQLException(e.getTargetException());\n+                if (targetException instanceof org.eclipse.microprofile.graphql.GraphQLException) {\n+                    // if we have partial results we need to return those results and they will\n+                    // get converted correctly to the format required by GraphQL and the ExecutionContext.execute()\n+                    // we ensure this is throw correctly as an error\n+                    ExecutionContext context = environment.getContext();\n+                    context.partialResultsException(exception);\n+                    return (V) ((org.eclipse.microprofile.graphql.GraphQLException) targetException).getPartialResults();\n+                }\n+                throw exception;\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Return a {@link DataFetcher} which converts a {@link Map} to a {@link Collection} of V.\n+     * This assumes that the key for the {@link Map} is contained within the V\n+     *\n+     * @param propertyName name of the property to apply to\n+     * @param <S>          Source of the property\n+     * @param <V>          type of the value\n+     * @return  a {@link DataFetcher}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <S, V> DataFetcher<Collection<V>> newMapValuesDataFetcher(String propertyName) {\n+        return environment -> {\n+            S source = environment.getSource();\n+            if (source == null) {\n+                return null;\n+            }\n+\n+            // retrieve the map and return the collection of V\n+            Map<?, V> map = (Map<?, V>) PropertyDataFetcherHelper\n+                    .getPropertyValue(propertyName, source, environment.getFieldType(), environment);\n+            return map.values();\n+        };\n+    }\n+\n+    /**\n+     * Generate an argument value with the given information. This may be called recursively.\n+     *\n+     * @param schema    {@link Schema} to introspect if needed\n+     * @param argumentType the type of the argument\n+     * @param originalType if this is non null this means the array was a Collection and this is the type in the collection\n+     * @param originalArrayType the original type of the argument as a class\n+     * @param rawValue  raw value of the argument\n+     * @param format argument format\n+     * @return the argument value\n+     * @throws Exception if any errors\n+     */\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\" })\n+    protected static Object generateArgumentValue(Schema schema, String argumentType, Class<?> originalType,\n+                                                  Class<?> originalArrayType,\n+                                                  Object rawValue, String[] format)\n+        throws Exception{\n+        if (rawValue instanceof Map) {\n+            // this means the type is an input type so convert it to the correct class instance\n+            SchemaInputType inputType = schema.getInputTypeByName(argumentType);\n+\n+            // loop through the map and convert each entry\n+            Map<String, Object> map = (Map) rawValue;\n+            Map<String, Object> mapConverted = new HashMap<>();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                // retrieve the Field Definition\n+                String fdName = entry.getKey();\n+                Object value  = entry.getValue();\n+                SchemaFieldDefinition fd = inputType.getFieldDefinitionByName(fdName);\n+\n+                // check to see if the Field Definition return type is an input type\n+                SchemaInputType inputFdInputType = schema.getInputTypeByName(fd.returnType());\n+                if (inputFdInputType != null && value instanceof Map) {\n+                    mapConverted.put(fdName, generateArgumentValue(schema, inputFdInputType.name(),\n+                                                                   Class.forName(inputFdInputType.valueClassName()),\n+                                                                   null,\n+                                                                   value, EMPTY_FORMAT));\n+                } else {\n+                    if (fd.isJsonbFormat() || fd.isJsonbProperty()) {\n+                        // don't deserialize using formatting as Jsonb will do this for us\n+                        mapConverted.put(fdName, value);\n+                    } else {\n+                        // check it is not a Map\n+                        Class<?> originalFdlType = fd.originalType();\n+                        if (originalFdlType != null && originalFdlType.isAssignableFrom(Map.class)) {\n+                            ensureRuntimeException(LOGGER, MAP_MESSAGE);\n+                        }\n+                        // retrieve the data fetcher and check if the property name is different as this should be used\n+                        DataFetcher dataFetcher = fd.dataFetcher();\n+                        if (dataFetcher instanceof PropertyDataFetcher) {\n+                            fdName = ((PropertyDataFetcher) dataFetcher).getPropertyName();\n+                        }\n+                        mapConverted.put(fdName, generateArgumentValue(schema, fd.returnType(), fd.originalType(),\n+                                                                       fd.originalArrayType(), value, fd.format()));\n+                    }\n+                }\n+            }\n+\n+            return JsonUtils.convertFromJson(JsonUtils.convertMapToJson(mapConverted), originalType);\n+\n+        } else if (rawValue instanceof Collection) {\n+            SchemaInputType inputType = schema.getInputTypeByName(argumentType);\n+\n+            Object colResults = null;\n+            boolean isArray = originalType.isArray();\n+            try {\n+                if (originalType.equals(List.class) || isArray) {", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU3NTIxMA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r534575210", "bodyText": "Yes the original type is specifically checked for List Set and Collection and we create the relevant type.\ne.g. for List -> ArrayList(), and Collection or Set we create a TreeSet.\nAny other type will fall through to else. e.g. LinkedList HasSet, etc and then we get the no-args declared constructor and instantiate this, therefore getting our requires class.", "author": "tmiddlet2666", "createdAt": "2020-12-03T00:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0ODE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4NTEyNw==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522285127", "bodyText": "We've just added the class to the set and we add it again if it's an interface?\nIs this really what we want to do here?", "author": "tjquinno", "createdAt": "2020-11-12T17:28:57Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/GraphQlCdiExtension.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.enterprise.inject.spi.BeanManager;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.ProcessManagedBean;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+\n+import io.helidon.graphql.server.GraphQlSupport;\n+import io.helidon.graphql.server.InvocationHandler;\n+import io.helidon.microprofile.server.ServerCdiExtension;\n+import io.helidon.webserver.Routing;\n+\n+import graphql.schema.GraphQLSchema;\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.graphql.ConfigKey;\n+import org.eclipse.microprofile.graphql.GraphQLApi;\n+import org.eclipse.microprofile.graphql.Input;\n+import org.eclipse.microprofile.graphql.Interface;\n+import org.eclipse.microprofile.graphql.Type;\n+\n+import static javax.interceptor.Interceptor.Priority.LIBRARY_BEFORE;\n+\n+/**\n+ * A CDI {@link Extension} to collect the classes that are of interest to Microprofile GraphQL.\n+ */\n+public class GraphQlCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(GraphQlCdiExtension.class.getName());\n+\n+    /**\n+     * The {@link List} of collected API's.\n+     */\n+    private final Set<Class<?>> candidateApis = new HashSet<>();\n+    private final Set<Class<?>> collectedApis = new HashSet<>();\n+\n+    /**\n+     * Collect the classes that have the following Microprofile GraphQL annotations.\n+     *\n+     * @param processAnnotatedType annotation types to process\n+     */\n+    void collectCandidateApis(@Observes @WithAnnotations(GraphQLApi.class) ProcessAnnotatedType<?> processAnnotatedType) {\n+        Class<?> javaClass = processAnnotatedType.getAnnotatedType().getJavaClass();\n+        this.candidateApis.add(javaClass);\n+        if (javaClass.isInterface()) {", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAzMTQ2Nw==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r535031467", "bodyText": "It is a different collection - one is candidateApis the other collectedApis", "author": "tomas-langer", "createdAt": "2020-12-03T09:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4NTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxMDkxMA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r535310910", "bodyText": "My mistake. Different sets, as Tomas pointed out in separate DM.", "author": "tjquinno", "createdAt": "2020-12-03T15:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4NTEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwNzY5Mg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522307692", "bodyText": "I'm not positive, but maybe look into whether observing the Helidon event RuntimeStart instead is what we want to trigger this method.", "author": "tjquinno", "createdAt": "2020-11-12T18:02:17Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/GraphQlCdiExtension.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.AnnotatedType;\n+import javax.enterprise.inject.spi.BeanManager;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.ProcessManagedBean;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+\n+import io.helidon.graphql.server.GraphQlSupport;\n+import io.helidon.graphql.server.InvocationHandler;\n+import io.helidon.microprofile.server.ServerCdiExtension;\n+import io.helidon.webserver.Routing;\n+\n+import graphql.schema.GraphQLSchema;\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.eclipse.microprofile.graphql.ConfigKey;\n+import org.eclipse.microprofile.graphql.GraphQLApi;\n+import org.eclipse.microprofile.graphql.Input;\n+import org.eclipse.microprofile.graphql.Interface;\n+import org.eclipse.microprofile.graphql.Type;\n+\n+import static javax.interceptor.Interceptor.Priority.LIBRARY_BEFORE;\n+\n+/**\n+ * A CDI {@link Extension} to collect the classes that are of interest to Microprofile GraphQL.\n+ */\n+public class GraphQlCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(GraphQlCdiExtension.class.getName());\n+\n+    /**\n+     * The {@link List} of collected API's.\n+     */\n+    private final Set<Class<?>> candidateApis = new HashSet<>();\n+    private final Set<Class<?>> collectedApis = new HashSet<>();\n+\n+    /**\n+     * Collect the classes that have the following Microprofile GraphQL annotations.\n+     *\n+     * @param processAnnotatedType annotation types to process\n+     */\n+    void collectCandidateApis(@Observes @WithAnnotations(GraphQLApi.class) ProcessAnnotatedType<?> processAnnotatedType) {\n+        Class<?> javaClass = processAnnotatedType.getAnnotatedType().getJavaClass();\n+        this.candidateApis.add(javaClass);\n+        if (javaClass.isInterface()) {\n+            collectedApis.add(javaClass);\n+        }\n+    }\n+\n+    void collectApis(@Observes @WithAnnotations({Type.class, Input.class,\n+                                                        Interface.class}) ProcessAnnotatedType<?> processAnnotatedType) {\n+        // these are directly added\n+        this.collectedApis.add(processAnnotatedType.getAnnotatedType().getJavaClass());\n+    }\n+\n+    void collectNonVetoed(@Observes ProcessManagedBean<?> event) {\n+        AnnotatedType<?> type = event.getAnnotatedBeanClass();\n+        Class<?> clazz = type.getJavaClass();\n+\n+        if (candidateApis.remove(clazz)) {\n+            collectedApis.add(clazz);\n+        }\n+    }\n+\n+    void addGraphQlBeans(@Observes BeforeBeanDiscovery event) {\n+        event.addAnnotatedType(GraphQlBean.class, GraphQlBean.class.getName())\n+                .add(ApplicationScoped.Literal.INSTANCE);\n+    }\n+\n+    void clearCandidates(@Observes AfterBeanDiscovery event) {\n+        candidateApis.clear();\n+    }\n+\n+    void registerWithWebServer(@Observes @Priority(LIBRARY_BEFORE + 9) @Initialized(ApplicationScoped.class) Object event,", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAzMDc5NA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r535030794", "bodyText": "I am not sure why? The runtime start is really for native-image specific handling. In this case, we just want to register with webserver routing.\nSo I think the event is OK.\nDo you think this could be an issue?", "author": "tomas-langer", "createdAt": "2020-12-03T09:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwNzY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMxMjQ0MQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r535312441", "bodyText": "I just wanted this to be double-checked, which it has been now. Should be OK.", "author": "tjquinno", "createdAt": "2020-12-03T15:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwNzY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwOTg3Mg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522309872", "bodyText": "Do we need to rely directly on the Jandex index(es)? CDI can answer these same questions, and if Jandex indexes are present Weld's CDI implementation will use them. (Maybe use of Jandex is mandated by GraphQL itself; I have no idea.)", "author": "tjquinno", "createdAt": "2020-11-12T18:05:44Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/JandexUtils.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import org.jboss.jandex.ClassInfo;\n+import org.jboss.jandex.DotName;\n+import org.jboss.jandex.Index;\n+import org.jboss.jandex.IndexReader;\n+\n+/**\n+ * Utilities for working with Jandex indexes.\n+ */\n+class JandexUtils {\n+\n+    private static final Logger LOGGER = Logger.getLogger(JandexUtils.class.getName());\n+\n+    /**\n+     * Default Jandex index file.\n+     */\n+    protected static final String DEFAULT_INDEX_FILE = \"META-INF/jandex.idx\";\n+\n+    /**\n+     * Property to override the default index file. (Normally used for functional tests)\n+     */\n+    public static final String PROP_INDEX_FILE = \"io.helidon.microprofile.graphql.indexfile\";\n+\n+    /**\n+     * The {@link Set} of loaded indexes.\n+     */\n+    private Set<Index> setIndexes = new HashSet<>();\n+\n+    /**\n+     * The file used to load the index.\n+     */\n+    private String indexFile;\n+\n+    /**\n+     * Construct an instance of the utilities class..\n+     */\n+    private JandexUtils() {\n+        indexFile = System.getProperty(PROP_INDEX_FILE, DEFAULT_INDEX_FILE);\n+    }\n+\n+    /**\n+     * Create a new {@link JandexUtils}.\n+     * @return a new {@link JandexUtils}\n+     */\n+    public static JandexUtils create() {\n+         return new JandexUtils();\n+    }\n+\n+    /**\n+     * Load all the index files of the given name.\n+     */\n+    public void loadIndexes() {\n+        try {\n+            List<URL> listUrls = findIndexFiles(indexFile);\n+\n+            // loop through each URL and load the index\n+            for (URL url : listUrls) {\n+                try (InputStream input = url.openStream()) {\n+                    setIndexes.add(new IndexReader(input).read());\n+                } catch (Exception e) {\n+                    LOGGER.warning(\"Unable to load default Jandex index file: \" + url\n+                                           + \" : \" + e.getMessage());\n+                }\n+            }\n+        } catch (IOException ignore) {\n+            // any Exception coming from getResources() or toURL() is ignored and\n+            // the Map of indexes remain empty\n+        }\n+    }\n+\n+    /**\n+     * Return all the Jandex index files with the given name. If the name is absolute then\n+     * return the singl file.\n+     *\n+     * @param indexFileName  index file name\n+     * @return a {@link List} of the index file names\n+     *\n+     * @throws IOException if any error\n+     */\n+    private List<URL> findIndexFiles(String indexFileName) throws IOException {\n+        List<URL> result = new ArrayList<>();\n+        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n+        File file = new File(indexFile);\n+        if (file.isAbsolute()) {\n+            result.add(file.toPath().toUri().toURL());\n+            return result;\n+        }\n+\n+        Enumeration<URL> urls = contextClassLoader.getResources(indexFileName);\n+        while (urls.hasMoreElements()) {\n+            result.add(urls.nextElement());\n+        }\n+\n+        return result;\n+    }\n+\n+\n+    /**\n+     * Return a {@link Collection} of {@link Class}es which are implementors of a given class/interface.\n+     *\n+     * @param clazz           {@link Class} to check for implementors\n+     * @param includeAbstract indicates if abstract classes should be included\n+     * @return a {@link Collection} of {@link Class}es\n+     */\n+    public Collection<Class<?>> getKnownImplementors(String clazz, boolean includeAbstract) {", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1NzI5MA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r534557290", "bodyText": "There is one capability that we need Jandex for and that is to find the annotation in the following situation.\npublic method(List<List<@nonnull String>> param).\nI don't believe CDI can answer this, but please provide and example of how it can if i'm no correct. @tjquinno", "author": "tmiddlet2666", "createdAt": "2020-12-02T23:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwOTg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU1ODQ4Nw==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r534558487", "bodyText": "Actually i mis-read the above comment. Can you provide an example of how CDI can get known implementors?  @tjquinno", "author": "tmiddlet2666", "createdAt": "2020-12-02T23:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwOTg3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQxMzE1NA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r535413154", "bodyText": "After a DM with Laird, it seems that this is not so easy using CDI-only APIs. So it's probably best to keep the code as-is.", "author": "tjquinno", "createdAt": "2020-12-03T16:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwOTg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNjIzOA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522326238", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:32:06Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaArgument.java", "diffHunk": "@@ -0,0 +1,529 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNjU4NA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522326584", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:32:34Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaDirective.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNzE2MQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522327161", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:33:23Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaEnum.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNzY3Nw==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522327677", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:34:13Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaFieldDefinition.java", "diffHunk": "@@ -0,0 +1,635 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyOTIzNA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522329234", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:36:52Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaGenerator.java", "diffHunk": "@@ -0,0 +1,1780 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMzUyMw==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522333523", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:43:54Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaGeneratorHelper.java", "diffHunk": "@@ -0,0 +1,1966 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNjIwNQ==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522336205", "bodyText": "How about PRIMITIVE_ARRAY_MAP.containsValue(clazz)?", "author": "tjquinno", "createdAt": "2020-11-12T18:48:20Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaGeneratorHelper.java", "diffHunk": "@@ -0,0 +1,1966 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedParameterizedType;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+\n+import javax.json.bind.annotation.JsonbProperty;\n+import javax.json.bind.annotation.JsonbTransient;\n+\n+import graphql.scalars.ExtendedScalars;\n+import org.eclipse.microprofile.graphql.DefaultValue;\n+import org.eclipse.microprofile.graphql.Description;\n+import org.eclipse.microprofile.graphql.Enum;\n+import org.eclipse.microprofile.graphql.Id;\n+import org.eclipse.microprofile.graphql.Ignore;\n+import org.eclipse.microprofile.graphql.Input;\n+import org.eclipse.microprofile.graphql.Interface;\n+import org.eclipse.microprofile.graphql.Mutation;\n+import org.eclipse.microprofile.graphql.Name;\n+import org.eclipse.microprofile.graphql.Query;\n+import org.eclipse.microprofile.graphql.Source;\n+import org.eclipse.microprofile.graphql.Type;\n+\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_BIGDECIMAL_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_BIGINTEGER_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_FLOAT_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_INT_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_OFFSET_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_ZONED_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.FORMATTED_CUSTOM_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.FORMATTED_CUSTOM_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.FORMATTED_CUSTOM_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.ElementGenerator.OPEN_SQUARE;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getDefaultDateTimeFormat;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.GET;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.IS;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.SET;\n+\n+/**\n+ * Helper class for {@link SchemaGenerator}.\n+ */\n+final class SchemaGeneratorHelper {\n+\n+    /**\n+     * {@link OffsetTime} class name.\n+     */\n+    protected static final String OFFSET_TIME_CLASS = OffsetTime.class.getName();\n+\n+    /**\n+     * {@link LocalTime} class name.\n+     */\n+    protected static final String LOCAL_TIME_CLASS = LocalTime.class.getName();\n+\n+    /**\n+     * {@link OffsetDateTime} class name.\n+     */\n+    protected static final String OFFSET_DATE_TIME_CLASS = OffsetDateTime.class.getName();\n+\n+    /**\n+     * {@link ZonedDateTime} class name.\n+     */\n+    protected static final String ZONED_DATE_TIME_CLASS = ZonedDateTime.class.getName();\n+\n+    /**\n+     * {@link LocalDateTime} class name.\n+     */\n+    protected static final String LOCAL_DATE_TIME_CLASS = LocalDateTime.class.getName();\n+\n+    /**\n+     * {@link LocalDate} class name.\n+     */\n+    protected static final String LOCAL_DATE_CLASS = LocalDate.class.getName();\n+\n+    /**\n+     * {@link BigDecimal} class name.\n+     */\n+    protected static final String BIG_DECIMAL_CLASS = BigDecimal.class.getName();\n+\n+    /**\n+     * {@link Long} class name.\n+     */\n+    protected static final String LONG_CLASS = Long.class.getName();\n+\n+    /**\n+     * Class name for long primitive.\n+     */\n+    protected static final String LONG_PRIMITIVE_CLASS = long.class.getName();\n+\n+    /**\n+     * {@link Float} class name.\n+     */\n+    protected static final String FLOAT_CLASS = Float.class.getName();\n+\n+    /**\n+     * Class name for float primitive.\n+     */\n+    protected static final String FLOAT_PRIMITIVE_CLASS = float.class.getName();\n+\n+    /**\n+     * {@link Double} class name.\n+     */\n+    protected static final String DOUBLE_CLASS = Double.class.getName();\n+\n+    /**\n+     * Class name for double primitive.\n+     */\n+    protected static final String DOUBLE_PRIMITIVE_CLASS = double.class.getName();\n+\n+    /**\n+     * Class name for {@link BigInteger}.\n+     */\n+    protected static final String BIG_INTEGER_CLASS = BigInteger.class.getName();\n+\n+    /**\n+     * Class name for {@link Integer}.\n+     */\n+    protected static final String INTEGER_CLASS = Integer.class.getName();\n+\n+    /**\n+     * Class name for int.\n+     */\n+    protected static final String INTEGER_PRIMITIVE_CLASS = int.class.getName();\n+\n+    /**\n+     * Class name for {@link Byte}.\n+     */\n+    protected static final String BYTE_CLASS = Byte.class.getName();\n+\n+    /**\n+     * Class name for byte.\n+     */\n+    protected static final String BYTE_PRIMITIVE_CLASS = byte.class.getName();\n+\n+    /**\n+     * Class name for {@link Short}.\n+     */\n+    protected static final String SHORT_CLASS = Short.class.getName();\n+\n+    /**\n+     * Class name for short.\n+     */\n+    protected static final String SHORT_PRIMITIVE_CLASS = short.class.getName();\n+\n+    /**\n+     * Formatted Date scalar.\n+     */\n+    public static final String FORMATTED_DATE_SCALAR = \"FormattedDate\";\n+\n+    /**\n+     * Formatted DateTime scalar.\n+     */\n+    public static final String FORMATTED_DATETIME_SCALAR = \"FormattedDateTime\";\n+\n+    /**\n+     * Formatted DateTime scalar.\n+     */\n+    public static final String FORMATTED_OFFSET_DATETIME_SCALAR = \"FormattedOffsetDateTime\";\n+\n+    /**\n+     * Formatted DateTime scalar.\n+     */\n+    public static final String FORMATTED_ZONED_DATETIME_SCALAR = \"FormattedZonedDateTime\";\n+\n+    /**\n+     * Formatted Time Scalar.\n+     */\n+    public static final String FORMATTED_TIME_SCALAR = \"FormattedTime\";\n+\n+    /**\n+     * Formatted Int.\n+     */\n+\n+    /**\n+     * Date scalar (with default formatting).\n+     */\n+    public static final String DATE_SCALAR = \"Date\";\n+\n+    /**\n+     * DateTime scalar (with default formatting).\n+     */\n+    public static final String DATETIME_SCALAR = \"DateTime\";\n+\n+    /**\n+     * Time Scalar (with default formatting).\n+     */\n+    public static final String TIME_SCALAR = \"Time\";\n+\n+    /**\n+     * Defines a {@link BigDecimal} type.\n+     */\n+    static final String BIG_DECIMAL = \"BigDecimal\";\n+\n+    /**\n+     * Defines a {@link BigInteger} type.\n+     */\n+    static final String BIG_INTEGER = \"BigInteger\";\n+\n+    /**\n+     * Value that indicates that default {@link java.util.Locale}.\n+     */\n+    static final String DEFAULT_LOCALE = \"##default\";\n+\n+    /**\n+     * GraphQL Int.\n+     */\n+    public static final String INT = \"Int\";\n+\n+    /**\n+     * GraphQL Float.\n+     */\n+    public static final String FLOAT = \"Float\";\n+\n+    /**\n+     * GraphQL String.\n+     */\n+    public static final String STRING = \"String\";\n+\n+    /**\n+     * GraphQL ID.\n+     */\n+    public static final String ID = \"ID\";\n+\n+    /**\n+     * GraphQL Boolean.\n+     */\n+    public static final String BOOLEAN = \"Boolean\";\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(SchemaGeneratorHelper.class.getName());\n+\n+    /**\n+     * Indicates empty annotations.\n+     */\n+    private static final Annotation[] EMPTY_ANNOTATIONS = new Annotation[0];\n+\n+    /**\n+     * List of supported scalars keyed by the full class name.\n+     */\n+    static final Map<String, SchemaScalar> SUPPORTED_SCALARS = new HashMap<>() {{\n+        // Object Scalar\n+        put(Object.class.getName(), new SchemaScalar(\"Object\", Object.class.getName(), ExtendedScalars.Object, null));\n+\n+        // Time scalars\n+        put(OffsetTime.class.getName(),\n+            new SchemaScalar(FORMATTED_TIME_SCALAR, OFFSET_TIME_CLASS, FORMATTED_CUSTOM_TIME_SCALAR, \"HH[:mm][:ss]Z\"));\n+        put(LocalTime.class.getName(),\n+            new SchemaScalar(FORMATTED_TIME_SCALAR, LOCAL_TIME_CLASS, FORMATTED_CUSTOM_TIME_SCALAR, \"HH[:mm][:ss]\"));\n+\n+        // DateTime scalars\n+        put(OFFSET_DATE_TIME_CLASS,\n+            new SchemaScalar(FORMATTED_OFFSET_DATETIME_SCALAR, OFFSET_DATE_TIME_CLASS, CUSTOM_OFFSET_DATE_TIME_SCALAR,\n+                             \"yyyy-MM-dd'T'HH[:mm][:ss]Z\"));\n+        put(ZONED_DATE_TIME_CLASS,\n+            new SchemaScalar(FORMATTED_ZONED_DATETIME_SCALAR, ZONED_DATE_TIME_CLASS, CUSTOM_ZONED_DATE_TIME_SCALAR,\n+                             \"yyyy-MM-dd'T'HH[:mm][:ss]Z'['VV']'\"));\n+        put(LOCAL_DATE_TIME_CLASS,\n+            new SchemaScalar(FORMATTED_DATETIME_SCALAR, LOCAL_DATE_TIME_CLASS, FORMATTED_CUSTOM_DATE_TIME_SCALAR,\n+                             \"yyyy-MM-dd'T'HH[:mm][:ss]\"));\n+\n+        // Date scalar\n+        put(LOCAL_DATE_CLASS, new SchemaScalar(FORMATTED_DATE_SCALAR, LOCAL_DATE_CLASS, FORMATTED_CUSTOM_DATE_SCALAR,\n+                                               \"yyyy-MM-dd\"));\n+\n+        // BigDecimal scalars\n+        put(BIG_DECIMAL_CLASS, new SchemaScalar(BIG_DECIMAL, BIG_DECIMAL_CLASS, CUSTOM_BIGDECIMAL_SCALAR, null));\n+\n+        // BigInteger scalars\n+        put(BIG_INTEGER_CLASS, new SchemaScalar(BIG_INTEGER, BIG_INTEGER_CLASS, CUSTOM_BIGINTEGER_SCALAR, null));\n+        put(LONG_PRIMITIVE_CLASS, new SchemaScalar(BIG_INTEGER, LONG_CLASS, CUSTOM_BIGINTEGER_SCALAR, null));\n+        put(LONG_CLASS, new SchemaScalar(BIG_INTEGER, LONG_CLASS, CUSTOM_BIGINTEGER_SCALAR, null));\n+\n+        // Int scalars\n+        put(INTEGER_CLASS, new SchemaScalar(INT, INTEGER_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(INTEGER_PRIMITIVE_CLASS, new SchemaScalar(INT, INTEGER_PRIMITIVE_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(BYTE_CLASS, new SchemaScalar(INT, BYTE_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(BYTE_PRIMITIVE_CLASS, new SchemaScalar(INT, BYTE_PRIMITIVE_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(SHORT_CLASS, new SchemaScalar(INT, SHORT_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(SHORT_PRIMITIVE_CLASS, new SchemaScalar(INT, SHORT_PRIMITIVE_CLASS, CUSTOM_INT_SCALAR, null));\n+\n+        // Float scalars\n+        put(FLOAT_CLASS, new SchemaScalar(FLOAT, FLOAT_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+        put(FLOAT_PRIMITIVE_CLASS, new SchemaScalar(FLOAT, FLOAT_PRIMITIVE_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+        put(DOUBLE_CLASS, new SchemaScalar(FLOAT, DOUBLE_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+        put(DOUBLE_PRIMITIVE_CLASS, new SchemaScalar(FLOAT, DOUBLE_PRIMITIVE_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+    }};\n+\n+    /**\n+     * List of types that should map to a GraphQL Boolean.\n+     */\n+    static final List<String> BOOLEAN_LIST = new ArrayList<>() {{\n+        add(\"boolean\");\n+        add(\"java.lang.Boolean\");\n+    }};\n+\n+    /**\n+     * List of types that should map to a GraphQL String.\n+     */\n+    static final List<String> STRING_LIST = new ArrayList<>() {{\n+        add(\"java.lang.String\");\n+        add(\"java.lang.Character\");\n+        add(\"char\");\n+    }};\n+\n+    /**\n+     * List of array primitive types and their array mapping. See https://docs.oracle.com/javase/6/docs/api/java/lang/Class\n+     * .html#getName%28%29\n+     */\n+    static final Map<String, String> PRIMITIVE_ARRAY_MAP = new HashMap<>() {{\n+        put(\"[Z\", \"boolean\");\n+        put(\"[B\", \"byte\");\n+        put(\"[C\", \"char\");\n+        put(\"[D\", \"double\");\n+        put(\"[F\", \"float\");\n+        put(\"[I\", \"int\");\n+        put(\"[J\", \"long\");\n+        put(\"[S\", \"short\");\n+    }};\n+\n+    /**\n+     * List of all Java primitives.\n+     */\n+    static final List<String> JAVA_PRIMITIVE_TYPES = new ArrayList<>() {{\n+        add(\"byte\");\n+        add(\"short\");\n+        add(\"int\");\n+        add(\"long\");\n+        add(\"float\");\n+        add(\"double\");\n+        add(\"boolean\");\n+        add(\"char\");\n+    }};\n+\n+    /**\n+     * Private no-args constructor.\n+     */\n+    private SchemaGeneratorHelper() {\n+    }\n+\n+    /**\n+     * Return the simple name from a given class as a String. This takes into account any annotations that may be present.\n+     *\n+     * @param className class name\n+     * @return the simple class name\n+     * @throws ClassNotFoundException if invalid class name\n+     */\n+    protected static String getSimpleName(String className)\n+            throws ClassNotFoundException {\n+        return getSimpleName(className, false);\n+    }\n+\n+    /**\n+     * Return true of the {@link Class} is a primitive or array of primitives.\n+     *\n+     * @param clazz {@link Class} to check\n+     * @return true of the {@link Class} is a primitive or array of primitives.\n+     */\n+    protected static boolean isPrimitive(Class<?> clazz) {\n+        return isPrimitive(clazz.getName());\n+    }\n+\n+    /**\n+     * Return true of the class name is a primitive or array of primitives.\n+     *\n+     * @param clazz class name to check\n+     * @return true if the class name is a primitive or array of primitives.\n+     */\n+    protected static boolean isPrimitive(String clazz) {\n+        return JAVA_PRIMITIVE_TYPES.contains(clazz)\n+                || PRIMITIVE_ARRAY_MAP.values().stream().anyMatch(v -> v.contains(clazz));", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNjY1Mg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522336652", "bodyText": "Same comment as above: containsValue(clazz)?", "author": "tjquinno", "createdAt": "2020-11-12T18:49:05Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaGeneratorHelper.java", "diffHunk": "@@ -0,0 +1,1966 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.graphql.server;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.AnnotatedParameterizedType;\n+import java.lang.reflect.AnnotatedType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.logging.Logger;\n+\n+import javax.json.bind.annotation.JsonbProperty;\n+import javax.json.bind.annotation.JsonbTransient;\n+\n+import graphql.scalars.ExtendedScalars;\n+import org.eclipse.microprofile.graphql.DefaultValue;\n+import org.eclipse.microprofile.graphql.Description;\n+import org.eclipse.microprofile.graphql.Enum;\n+import org.eclipse.microprofile.graphql.Id;\n+import org.eclipse.microprofile.graphql.Ignore;\n+import org.eclipse.microprofile.graphql.Input;\n+import org.eclipse.microprofile.graphql.Interface;\n+import org.eclipse.microprofile.graphql.Mutation;\n+import org.eclipse.microprofile.graphql.Name;\n+import org.eclipse.microprofile.graphql.Query;\n+import org.eclipse.microprofile.graphql.Source;\n+import org.eclipse.microprofile.graphql.Type;\n+\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_BIGDECIMAL_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_BIGINTEGER_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_FLOAT_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_INT_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_OFFSET_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.CUSTOM_ZONED_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.FORMATTED_CUSTOM_DATE_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.FORMATTED_CUSTOM_DATE_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.CustomScalars.FORMATTED_CUSTOM_TIME_SCALAR;\n+import static io.helidon.microprofile.graphql.server.ElementGenerator.OPEN_SQUARE;\n+import static io.helidon.microprofile.graphql.server.FormattingHelper.getDefaultDateTimeFormat;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.GET;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.IS;\n+import static io.helidon.microprofile.graphql.server.SchemaGenerator.SET;\n+\n+/**\n+ * Helper class for {@link SchemaGenerator}.\n+ */\n+final class SchemaGeneratorHelper {\n+\n+    /**\n+     * {@link OffsetTime} class name.\n+     */\n+    protected static final String OFFSET_TIME_CLASS = OffsetTime.class.getName();\n+\n+    /**\n+     * {@link LocalTime} class name.\n+     */\n+    protected static final String LOCAL_TIME_CLASS = LocalTime.class.getName();\n+\n+    /**\n+     * {@link OffsetDateTime} class name.\n+     */\n+    protected static final String OFFSET_DATE_TIME_CLASS = OffsetDateTime.class.getName();\n+\n+    /**\n+     * {@link ZonedDateTime} class name.\n+     */\n+    protected static final String ZONED_DATE_TIME_CLASS = ZonedDateTime.class.getName();\n+\n+    /**\n+     * {@link LocalDateTime} class name.\n+     */\n+    protected static final String LOCAL_DATE_TIME_CLASS = LocalDateTime.class.getName();\n+\n+    /**\n+     * {@link LocalDate} class name.\n+     */\n+    protected static final String LOCAL_DATE_CLASS = LocalDate.class.getName();\n+\n+    /**\n+     * {@link BigDecimal} class name.\n+     */\n+    protected static final String BIG_DECIMAL_CLASS = BigDecimal.class.getName();\n+\n+    /**\n+     * {@link Long} class name.\n+     */\n+    protected static final String LONG_CLASS = Long.class.getName();\n+\n+    /**\n+     * Class name for long primitive.\n+     */\n+    protected static final String LONG_PRIMITIVE_CLASS = long.class.getName();\n+\n+    /**\n+     * {@link Float} class name.\n+     */\n+    protected static final String FLOAT_CLASS = Float.class.getName();\n+\n+    /**\n+     * Class name for float primitive.\n+     */\n+    protected static final String FLOAT_PRIMITIVE_CLASS = float.class.getName();\n+\n+    /**\n+     * {@link Double} class name.\n+     */\n+    protected static final String DOUBLE_CLASS = Double.class.getName();\n+\n+    /**\n+     * Class name for double primitive.\n+     */\n+    protected static final String DOUBLE_PRIMITIVE_CLASS = double.class.getName();\n+\n+    /**\n+     * Class name for {@link BigInteger}.\n+     */\n+    protected static final String BIG_INTEGER_CLASS = BigInteger.class.getName();\n+\n+    /**\n+     * Class name for {@link Integer}.\n+     */\n+    protected static final String INTEGER_CLASS = Integer.class.getName();\n+\n+    /**\n+     * Class name for int.\n+     */\n+    protected static final String INTEGER_PRIMITIVE_CLASS = int.class.getName();\n+\n+    /**\n+     * Class name for {@link Byte}.\n+     */\n+    protected static final String BYTE_CLASS = Byte.class.getName();\n+\n+    /**\n+     * Class name for byte.\n+     */\n+    protected static final String BYTE_PRIMITIVE_CLASS = byte.class.getName();\n+\n+    /**\n+     * Class name for {@link Short}.\n+     */\n+    protected static final String SHORT_CLASS = Short.class.getName();\n+\n+    /**\n+     * Class name for short.\n+     */\n+    protected static final String SHORT_PRIMITIVE_CLASS = short.class.getName();\n+\n+    /**\n+     * Formatted Date scalar.\n+     */\n+    public static final String FORMATTED_DATE_SCALAR = \"FormattedDate\";\n+\n+    /**\n+     * Formatted DateTime scalar.\n+     */\n+    public static final String FORMATTED_DATETIME_SCALAR = \"FormattedDateTime\";\n+\n+    /**\n+     * Formatted DateTime scalar.\n+     */\n+    public static final String FORMATTED_OFFSET_DATETIME_SCALAR = \"FormattedOffsetDateTime\";\n+\n+    /**\n+     * Formatted DateTime scalar.\n+     */\n+    public static final String FORMATTED_ZONED_DATETIME_SCALAR = \"FormattedZonedDateTime\";\n+\n+    /**\n+     * Formatted Time Scalar.\n+     */\n+    public static final String FORMATTED_TIME_SCALAR = \"FormattedTime\";\n+\n+    /**\n+     * Formatted Int.\n+     */\n+\n+    /**\n+     * Date scalar (with default formatting).\n+     */\n+    public static final String DATE_SCALAR = \"Date\";\n+\n+    /**\n+     * DateTime scalar (with default formatting).\n+     */\n+    public static final String DATETIME_SCALAR = \"DateTime\";\n+\n+    /**\n+     * Time Scalar (with default formatting).\n+     */\n+    public static final String TIME_SCALAR = \"Time\";\n+\n+    /**\n+     * Defines a {@link BigDecimal} type.\n+     */\n+    static final String BIG_DECIMAL = \"BigDecimal\";\n+\n+    /**\n+     * Defines a {@link BigInteger} type.\n+     */\n+    static final String BIG_INTEGER = \"BigInteger\";\n+\n+    /**\n+     * Value that indicates that default {@link java.util.Locale}.\n+     */\n+    static final String DEFAULT_LOCALE = \"##default\";\n+\n+    /**\n+     * GraphQL Int.\n+     */\n+    public static final String INT = \"Int\";\n+\n+    /**\n+     * GraphQL Float.\n+     */\n+    public static final String FLOAT = \"Float\";\n+\n+    /**\n+     * GraphQL String.\n+     */\n+    public static final String STRING = \"String\";\n+\n+    /**\n+     * GraphQL ID.\n+     */\n+    public static final String ID = \"ID\";\n+\n+    /**\n+     * GraphQL Boolean.\n+     */\n+    public static final String BOOLEAN = \"Boolean\";\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(SchemaGeneratorHelper.class.getName());\n+\n+    /**\n+     * Indicates empty annotations.\n+     */\n+    private static final Annotation[] EMPTY_ANNOTATIONS = new Annotation[0];\n+\n+    /**\n+     * List of supported scalars keyed by the full class name.\n+     */\n+    static final Map<String, SchemaScalar> SUPPORTED_SCALARS = new HashMap<>() {{\n+        // Object Scalar\n+        put(Object.class.getName(), new SchemaScalar(\"Object\", Object.class.getName(), ExtendedScalars.Object, null));\n+\n+        // Time scalars\n+        put(OffsetTime.class.getName(),\n+            new SchemaScalar(FORMATTED_TIME_SCALAR, OFFSET_TIME_CLASS, FORMATTED_CUSTOM_TIME_SCALAR, \"HH[:mm][:ss]Z\"));\n+        put(LocalTime.class.getName(),\n+            new SchemaScalar(FORMATTED_TIME_SCALAR, LOCAL_TIME_CLASS, FORMATTED_CUSTOM_TIME_SCALAR, \"HH[:mm][:ss]\"));\n+\n+        // DateTime scalars\n+        put(OFFSET_DATE_TIME_CLASS,\n+            new SchemaScalar(FORMATTED_OFFSET_DATETIME_SCALAR, OFFSET_DATE_TIME_CLASS, CUSTOM_OFFSET_DATE_TIME_SCALAR,\n+                             \"yyyy-MM-dd'T'HH[:mm][:ss]Z\"));\n+        put(ZONED_DATE_TIME_CLASS,\n+            new SchemaScalar(FORMATTED_ZONED_DATETIME_SCALAR, ZONED_DATE_TIME_CLASS, CUSTOM_ZONED_DATE_TIME_SCALAR,\n+                             \"yyyy-MM-dd'T'HH[:mm][:ss]Z'['VV']'\"));\n+        put(LOCAL_DATE_TIME_CLASS,\n+            new SchemaScalar(FORMATTED_DATETIME_SCALAR, LOCAL_DATE_TIME_CLASS, FORMATTED_CUSTOM_DATE_TIME_SCALAR,\n+                             \"yyyy-MM-dd'T'HH[:mm][:ss]\"));\n+\n+        // Date scalar\n+        put(LOCAL_DATE_CLASS, new SchemaScalar(FORMATTED_DATE_SCALAR, LOCAL_DATE_CLASS, FORMATTED_CUSTOM_DATE_SCALAR,\n+                                               \"yyyy-MM-dd\"));\n+\n+        // BigDecimal scalars\n+        put(BIG_DECIMAL_CLASS, new SchemaScalar(BIG_DECIMAL, BIG_DECIMAL_CLASS, CUSTOM_BIGDECIMAL_SCALAR, null));\n+\n+        // BigInteger scalars\n+        put(BIG_INTEGER_CLASS, new SchemaScalar(BIG_INTEGER, BIG_INTEGER_CLASS, CUSTOM_BIGINTEGER_SCALAR, null));\n+        put(LONG_PRIMITIVE_CLASS, new SchemaScalar(BIG_INTEGER, LONG_CLASS, CUSTOM_BIGINTEGER_SCALAR, null));\n+        put(LONG_CLASS, new SchemaScalar(BIG_INTEGER, LONG_CLASS, CUSTOM_BIGINTEGER_SCALAR, null));\n+\n+        // Int scalars\n+        put(INTEGER_CLASS, new SchemaScalar(INT, INTEGER_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(INTEGER_PRIMITIVE_CLASS, new SchemaScalar(INT, INTEGER_PRIMITIVE_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(BYTE_CLASS, new SchemaScalar(INT, BYTE_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(BYTE_PRIMITIVE_CLASS, new SchemaScalar(INT, BYTE_PRIMITIVE_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(SHORT_CLASS, new SchemaScalar(INT, SHORT_CLASS, CUSTOM_INT_SCALAR, null));\n+        put(SHORT_PRIMITIVE_CLASS, new SchemaScalar(INT, SHORT_PRIMITIVE_CLASS, CUSTOM_INT_SCALAR, null));\n+\n+        // Float scalars\n+        put(FLOAT_CLASS, new SchemaScalar(FLOAT, FLOAT_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+        put(FLOAT_PRIMITIVE_CLASS, new SchemaScalar(FLOAT, FLOAT_PRIMITIVE_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+        put(DOUBLE_CLASS, new SchemaScalar(FLOAT, DOUBLE_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+        put(DOUBLE_PRIMITIVE_CLASS, new SchemaScalar(FLOAT, DOUBLE_PRIMITIVE_CLASS, CUSTOM_FLOAT_SCALAR, null));\n+    }};\n+\n+    /**\n+     * List of types that should map to a GraphQL Boolean.\n+     */\n+    static final List<String> BOOLEAN_LIST = new ArrayList<>() {{\n+        add(\"boolean\");\n+        add(\"java.lang.Boolean\");\n+    }};\n+\n+    /**\n+     * List of types that should map to a GraphQL String.\n+     */\n+    static final List<String> STRING_LIST = new ArrayList<>() {{\n+        add(\"java.lang.String\");\n+        add(\"java.lang.Character\");\n+        add(\"char\");\n+    }};\n+\n+    /**\n+     * List of array primitive types and their array mapping. See https://docs.oracle.com/javase/6/docs/api/java/lang/Class\n+     * .html#getName%28%29\n+     */\n+    static final Map<String, String> PRIMITIVE_ARRAY_MAP = new HashMap<>() {{\n+        put(\"[Z\", \"boolean\");\n+        put(\"[B\", \"byte\");\n+        put(\"[C\", \"char\");\n+        put(\"[D\", \"double\");\n+        put(\"[F\", \"float\");\n+        put(\"[I\", \"int\");\n+        put(\"[J\", \"long\");\n+        put(\"[S\", \"short\");\n+    }};\n+\n+    /**\n+     * List of all Java primitives.\n+     */\n+    static final List<String> JAVA_PRIMITIVE_TYPES = new ArrayList<>() {{\n+        add(\"byte\");\n+        add(\"short\");\n+        add(\"int\");\n+        add(\"long\");\n+        add(\"float\");\n+        add(\"double\");\n+        add(\"boolean\");\n+        add(\"char\");\n+    }};\n+\n+    /**\n+     * Private no-args constructor.\n+     */\n+    private SchemaGeneratorHelper() {\n+    }\n+\n+    /**\n+     * Return the simple name from a given class as a String. This takes into account any annotations that may be present.\n+     *\n+     * @param className class name\n+     * @return the simple class name\n+     * @throws ClassNotFoundException if invalid class name\n+     */\n+    protected static String getSimpleName(String className)\n+            throws ClassNotFoundException {\n+        return getSimpleName(className, false);\n+    }\n+\n+    /**\n+     * Return true of the {@link Class} is a primitive or array of primitives.\n+     *\n+     * @param clazz {@link Class} to check\n+     * @return true of the {@link Class} is a primitive or array of primitives.\n+     */\n+    protected static boolean isPrimitive(Class<?> clazz) {\n+        return isPrimitive(clazz.getName());\n+    }\n+\n+    /**\n+     * Return true of the class name is a primitive or array of primitives.\n+     *\n+     * @param clazz class name to check\n+     * @return true if the class name is a primitive or array of primitives.\n+     */\n+    protected static boolean isPrimitive(String clazz) {\n+        return JAVA_PRIMITIVE_TYPES.contains(clazz)\n+                || PRIMITIVE_ARRAY_MAP.values().stream().anyMatch(v -> v.contains(clazz));\n+    }\n+\n+    /**\n+     * Return true of the class name is an array of primitives.\n+     *\n+     * @param clazz class name to check\n+     * @return true true of the class name is an array of primitives.\n+     */\n+    protected static boolean isPrimitiveArray(String clazz) {\n+        return PRIMITIVE_ARRAY_MAP.values().stream().anyMatch(v -> v.contains(clazz));", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzOTMxNg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522339316", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:53:24Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/SchemaInputType.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MDQyNA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522340424", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:55:10Z", "path": "microprofile/graphql/server/src/main/java/io/helidon/microprofile/graphql/server/package-info.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MDYwMg==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r522340602", "bodyText": "New file, remove 2019.", "author": "tjquinno", "createdAt": "2020-11-12T18:55:26Z", "path": "microprofile/graphql/server/src/main/java/module-info.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright (c) 2019, 2020 Oracle and/or its affiliates. All rights reserved.", "originalCommit": "2948b0bf1973d4dc87c6d147f66ec8b382cc4a38", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "144309282b13fb70c2061408c6539d6518a30dad", "url": "https://github.com/oracle/helidon/commit/144309282b13fb70c2061408c6539d6518a30dad", "message": "Review feedback", "committedDate": "2020-11-13T01:42:01Z", "type": "commit"}, {"oid": "bb3e6bcb2f539318eae747bb03b8678fecc57c7b", "url": "https://github.com/oracle/helidon/commit/bb3e6bcb2f539318eae747bb03b8678fecc57c7b", "message": "Merge branch 'master' into graphql", "committedDate": "2020-11-13T22:08:29Z", "type": "commit"}, {"oid": "cc8a370bb771e022fac74066f0f39cb6fcdf3848", "url": "https://github.com/oracle/helidon/commit/cc8a370bb771e022fac74066f0f39cb6fcdf3848", "message": "Update pom.xml\n\nMerge issue fix.", "committedDate": "2020-11-13T22:09:35Z", "type": "commit"}, {"oid": "01cc16be32a162f6292d6bd2d9bb5a814c4f0134", "url": "https://github.com/oracle/helidon/commit/01cc16be32a162f6292d6bd2d9bb5a814c4f0134", "message": "Remove embedded GraphiQL and include instructions in example", "committedDate": "2020-11-16T05:19:53Z", "type": "commit"}, {"oid": "57acb5873fd408324c9f379dc04c01600d26c0cd", "url": "https://github.com/oracle/helidon/commit/57acb5873fd408324c9f379dc04c01600d26c0cd", "message": "Fix checkstyle", "committedDate": "2020-11-16T05:24:02Z", "type": "commit"}, {"oid": "d5829f7689c2286a82e6764266ab69a7b93b6f3c", "url": "https://github.com/oracle/helidon/commit/d5829f7689c2286a82e6764266ab69a7b93b6f3c", "message": "fix copyright", "committedDate": "2020-11-16T05:36:28Z", "type": "commit"}, {"oid": "3273454baffae638fa52ae953067543e5a19cb4e", "url": "https://github.com/oracle/helidon/commit/3273454baffae638fa52ae953067543e5a19cb4e", "message": "Add GraphQL SE example and docs", "committedDate": "2020-11-17T03:09:36Z", "type": "commit"}, {"oid": "9ff080763f2c068d89499da52a5f0e9e7242d783", "url": "https://github.com/oracle/helidon/commit/9ff080763f2c068d89499da52a5f0e9e7242d783", "message": "fix copyright", "committedDate": "2020-11-17T23:47:14Z", "type": "commit"}, {"oid": "d1e5c6621eb21eab29aa5eba025f8258837a63ba", "url": "https://github.com/oracle/helidon/commit/d1e5c6621eb21eab29aa5eba025f8258837a63ba", "message": "Reduce warning message to fine", "committedDate": "2020-11-18T00:24:47Z", "type": "commit"}, {"oid": "ad239b642d90cd58e2a57a4b40b2b4788ca5792f", "url": "https://github.com/oracle/helidon/commit/ad239b642d90cd58e2a57a4b40b2b4788ca5792f", "message": "bump extended scalars version to match graphql-java version", "committedDate": "2020-11-19T23:42:36Z", "type": "commit"}, {"oid": "8b9ba4f82a8e04e8cc3015e4f41dae42c19928c3", "url": "https://github.com/oracle/helidon/commit/8b9ba4f82a8e04e8cc3015e4f41dae42c19928c3", "message": "Excluding unwanted transitive dependencies on okhttp and okio\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-24T17:01:25Z", "type": "commit"}, {"oid": "bb5b0c3e14ff1145042a852f3d3fd7e3620d9c17", "url": "https://github.com/oracle/helidon/commit/bb5b0c3e14ff1145042a852f3d3fd7e3620d9c17", "message": "Extra validation on schema generation", "committedDate": "2020-11-25T08:37:11Z", "type": "commit"}, {"oid": "285ecfad8c25558000959214d113e70f82d50f9e", "url": "https://github.com/oracle/helidon/commit/285ecfad8c25558000959214d113e70f82d50f9e", "message": "Minor", "committedDate": "2020-11-26T01:46:24Z", "type": "commit"}, {"oid": "fd6265cabd266c88855dcbbb22e991700c7c3c5a", "url": "https://github.com/oracle/helidon/commit/fd6265cabd266c88855dcbbb22e991700c7c3c5a", "message": "Merge branch 'master' into graphql", "committedDate": "2020-12-02T10:01:05Z", "type": "commit"}, {"oid": "989fa65c527ea7127bbb523f69f610697b5facfa", "url": "https://github.com/oracle/helidon/commit/989fa65c527ea7127bbb523f69f610697b5facfa", "message": "Updates after review feedback", "committedDate": "2020-12-03T00:47:10Z", "type": "commit"}, {"oid": "f34caa4d567fe9e8d4ca010f5cbfab35dff6e839", "url": "https://github.com/oracle/helidon/commit/f34caa4d567fe9e8d4ca010f5cbfab35dff6e839", "message": "Minor mp-graphql example updates", "committedDate": "2020-12-03T03:55:25Z", "type": "commit"}, {"oid": "1be9cf37d27359f3ececd40e151490068fe232f4", "url": "https://github.com/oracle/helidon/commit/1be9cf37d27359f3ececd40e151490068fe232f4", "message": "Checkstyle.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-12-03T17:25:19Z", "type": "commit"}, {"oid": "32a37fe7a3c33330d5c83c08fbe2c9643cbc75ef", "url": "https://github.com/oracle/helidon/commit/32a37fe7a3c33330d5c83c08fbe2c9643cbc75ef", "message": "Minor doco typo", "committedDate": "2020-12-07T08:06:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNjg1NA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r537936854", "bodyText": "Should this be in a try-finally block so the server is shut down even if an assertion fails?\nI'd say don't make this change now unless you happen to be changing something more important in this file.", "author": "tjquinno", "createdAt": "2020-12-08T00:24:19Z", "path": "graphql/server/src/test/java/io/helidon/graphql/server/GraphQlSupportTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.graphql.server;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import io.helidon.media.jsonb.JsonbSupport;\n+import io.helidon.webclient.WebClient;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.WebServer;\n+\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.StaticDataFetcher;\n+import graphql.schema.idl.RuntimeWiring;\n+import graphql.schema.idl.SchemaGenerator;\n+import graphql.schema.idl.SchemaParser;\n+import graphql.schema.idl.TypeDefinitionRegistry;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+class GraphQlSupportTest {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    void testHelloWorld() {\n+        WebServer server = WebServer.builder()\n+                .routing(Routing.builder()\n+                                 .register(GraphQlSupport.create(buildSchema()))\n+                                 .build())\n+                .build()\n+                .start()\n+                .await(10, TimeUnit.SECONDS);\n+\n+        WebClient webClient = WebClient.builder()\n+                .addMediaSupport(JsonbSupport.create())\n+                .build();\n+\n+        LinkedHashMap<String, Object> response = webClient\n+                .post()\n+                .uri(\"http://localhost:\" + server.port() + \"/graphql\")\n+                .submit(\"{\\\"query\\\": \\\"{hello}\\\"}\", LinkedHashMap.class)\n+                .await(10, TimeUnit.SECONDS);\n+\n+        Map<String, Object> data = (Map<String, Object>) response.get(\"data\");\n+        assertThat(\"POST errors: \" + response.get(\"errors\"), data, notNullValue());\n+        assertThat(\"POST\", data.get(\"hello\"), is(\"world\"));\n+\n+        response = webClient\n+                .get()\n+                .uri(\"http://localhost:\" + server.port() + \"/graphql\")\n+                .queryParam(\"query\", \"{hello}\")\n+                .request(LinkedHashMap.class)\n+                .await(10, TimeUnit.SECONDS);\n+\n+        data = (Map<String, Object>) response.get(\"data\");\n+        assertThat(\"GET errors: \" + response.get(\"errors\"), data, notNullValue());\n+        assertThat(\"GET\", data.get(\"hello\"), is(\"world\"));\n+\n+        server.shutdown();", "originalCommit": "32a37fe7a3c33330d5c83c08fbe2c9643cbc75ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0MzAwNA==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r537943004", "bodyText": "Thanks. I'll add a task to do it when i'm in there at some stage.", "author": "tmiddlet2666", "createdAt": "2020-12-08T00:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNjg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxMDA5Nw==", "url": "https://github.com/oracle/helidon/pull/2504#discussion_r557810097", "bodyText": "@tjquinno will do this in a change i am doing now.", "author": "tmiddlet2666", "createdAt": "2021-01-15T01:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzkzNjg1NA=="}], "type": "inlineReview"}, {"oid": "850c00a080f41a591b1aca514d7e604dc2b73b44", "url": "https://github.com/oracle/helidon/commit/850c00a080f41a591b1aca514d7e604dc2b73b44", "message": "Initial helidon-microprofile-graphql project setup", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "238f7fea6717bb5362b9eeefb70fea938605a04c", "url": "https://github.com/oracle/helidon/commit/238f7fea6717bb5362b9eeefb70fea938605a04c", "message": "checkstyle fixes", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "59f0a6ef8e9b1138ef0898cd60f9f77625fce58d", "url": "https://github.com/oracle/helidon/commit/59f0a6ef8e9b1138ef0898cd60f9f77625fce58d", "message": "progress commit", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "eca7e48d21cc35a18b15e023070c4984d4d00e29", "url": "https://github.com/oracle/helidon/commit/eca7e48d21cc35a18b15e023070c4984d4d00e29", "message": "post adding GraphQLIT", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "91173bcc705550540e905fc15dfc2fdfc9686605", "url": "https://github.com/oracle/helidon/commit/91173bcc705550540e905fc15dfc2fdfc9686605", "message": "initial GraphQLApi work", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "79fa7279bd560a359e8a6cebad9fc03bb8869e0f", "url": "https://github.com/oracle/helidon/commit/79fa7279bd560a359e8a6cebad9fc03bb8869e0f", "message": "progress update", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "167fc83378c6fe543e5e4b20996556f5dcf597a1", "url": "https://github.com/oracle/helidon/commit/167fc83378c6fe543e5e4b20996556f5dcf597a1", "message": "progress", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "43e2512e56e96f3b5d0a24ee158dfac7918288e5", "url": "https://github.com/oracle/helidon/commit/43e2512e56e96f3b5d0a24ee158dfac7918288e5", "message": "progress", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "a0cccf77ae53e3212e616a8033ea9722e678b780", "url": "https://github.com/oracle/helidon/commit/a0cccf77ae53e3212e616a8033ea9722e678b780", "message": "add tck and runner modules", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "85718d094b90ff9b5cb2928c83458cc4dc6675dd", "url": "https://github.com/oracle/helidon/commit/85718d094b90ff9b5cb2928c83458cc4dc6675dd", "message": "fixup issues with ID fields", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "048c7630bbccd9521339c60774afe963f9a87f99", "url": "https://github.com/oracle/helidon/commit/048c7630bbccd9521339c60774afe963f9a87f99", "message": "flatten the package structure", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "56f7e2465925b7992a278ecccf0d2fd686cffec0", "url": "https://github.com/oracle/helidon/commit/56f7e2465925b7992a278ecccf0d2fd686cffec0", "message": "working on arrays", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "06bc2545b6cbef9079d4c695bb3edea166cf934d", "url": "https://github.com/oracle/helidon/commit/06bc2545b6cbef9079d4c695bb3edea166cf934d", "message": "fixup arrays and lists", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "9589fa2fd63f3812707677c6c2c454c8ec7500c1", "url": "https://github.com/oracle/helidon/commit/9589fa2fd63f3812707677c6c2c454c8ec7500c1", "message": "fixup missing scalars", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "9cfb81959f8dfb48fbcb0a84153d7068978b0948", "url": "https://github.com/oracle/helidon/commit/9cfb81959f8dfb48fbcb0a84153d7068978b0948", "message": "refactoring", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "4eaeeaf5f9a13dc71b4f6c52991123afb8755025", "url": "https://github.com/oracle/helidon/commit/4eaeeaf5f9a13dc71b4f6c52991123afb8755025", "message": "copyright and checkstyle", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "9a4f0c61d1fdb0fdd4cf3c47799cfd8a93fef695", "url": "https://github.com/oracle/helidon/commit/9a4f0c61d1fdb0fdd4cf3c47799cfd8a93fef695", "message": "add additional array and list tests", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "f74d0db2561d0631ccf43c99d4fe40b5d3693166", "url": "https://github.com/oracle/helidon/commit/f74d0db2561d0631ccf43c99d4fe40b5d3693166", "message": "fixup issue with recursion", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "0b851565c83c3e4ea90c51215f9cd049b5214b0c", "url": "https://github.com/oracle/helidon/commit/0b851565c83c3e4ea90c51215f9cd049b5214b0c", "message": "enable null serialization", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "4c7f13fc8aa4d8ccc4722bbe897a857dbaf9f9f5", "url": "https://github.com/oracle/helidon/commit/4c7f13fc8aa4d8ccc4722bbe897a857dbaf9f9f5", "message": "add temporary scalar datetime workaround", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "0dd8819c8313be44051d9ec8b87a6643e5d469b2", "url": "https://github.com/oracle/helidon/commit/0dd8819c8313be44051d9ec8b87a6643e5d469b2", "message": "add temporary scalar datetime workaround", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "c3ce77b1b4efbc850f10ed662f5990a17b8b6e08", "url": "https://github.com/oracle/helidon/commit/c3ce77b1b4efbc850f10ed662f5990a17b8b6e08", "message": "initial addition of mutations", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "0e846e31cd1ffe66954c35a3614b7664dbe695ae", "url": "https://github.com/oracle/helidon/commit/0e846e31cd1ffe66954c35a3614b7664dbe695ae", "message": "initial working mutations", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "076545565a83a79da17fe7faace38dd01666f56d", "url": "https://github.com/oracle/helidon/commit/076545565a83a79da17fe7faace38dd01666f56d", "message": "add temporary readme", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "c21d4303dd5865fa6241ed924e8f19c317bee2dc", "url": "https://github.com/oracle/helidon/commit/c21d4303dd5865fa6241ed924e8f19c317bee2dc", "message": "add temporary readme", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "b77e3f79ad155d09d45d8f7150f201decbb66a7e", "url": "https://github.com/oracle/helidon/commit/b77e3f79ad155d09d45d8f7150f201decbb66a7e", "message": "add temporary readme", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "2ce47daabd11dbb98bc19d340e716adcbf0cf68b", "url": "https://github.com/oracle/helidon/commit/2ce47daabd11dbb98bc19d340e716adcbf0cf68b", "message": "support Ignore and JsonbTransient annotations", "committedDate": "2020-11-05T03:44:27Z", "type": "commit"}, {"oid": "76e82e6f878fb5f3152d1c1a4a328bb02fd24b32", "url": "https://github.com/oracle/helidon/commit/76e82e6f878fb5f3152d1c1a4a328bb02fd24b32", "message": "add support for @Source annotation", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "5e3e5fc154ee28462cd3c91e2de263ccf557731c", "url": "https://github.com/oracle/helidon/commit/5e3e5fc154ee28462cd3c91e2de263ccf557731c", "message": "add support for @Source annotation - fix bug", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "d2dac24019e6b3c455964aef11fb829b0293b204", "url": "https://github.com/oracle/helidon/commit/d2dac24019e6b3c455964aef11fb829b0293b204", "message": "fixup bug in Source annoation", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "8e2e775ba05279b556fda5a7f929ae3bb2d8a5ff", "url": "https://github.com/oracle/helidon/commit/8e2e775ba05279b556fda5a7f929ae3bb2d8a5ff", "message": "checkstyle", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "bef5d383e659dbe64355a604c18081271206a508", "url": "https://github.com/oracle/helidon/commit/bef5d383e659dbe64355a604c18081271206a508", "message": "add in missed tests for Input annotation", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "8711b637a8df1c1412df8f9c04ab71e18539e2b0", "url": "https://github.com/oracle/helidon/commit/8711b637a8df1c1412df8f9c04ab71e18539e2b0", "message": "spotbugs", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "a28d5337848ab9b909c7fa8f102288812468b7e2", "url": "https://github.com/oracle/helidon/commit/a28d5337848ab9b909c7fa8f102288812468b7e2", "message": "add tests and helpers for number formatting", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "048fc8326ecc3b98540dcc19d372c64bc75dc00b", "url": "https://github.com/oracle/helidon/commit/048fc8326ecc3b98540dcc19d372c64bc75dc00b", "message": "tck", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "086ed00aed490286c81876468c4de75b692b5f61", "url": "https://github.com/oracle/helidon/commit/086ed00aed490286c81876468c4de75b692b5f61", "message": "add method annotation check", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "aebfad560c1ae53d66625ea25f3de0361c74131e", "url": "https://github.com/oracle/helidon/commit/aebfad560c1ae53d66625ea25f3de0361c74131e", "message": "GraphQL TCK tests.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "fc9662772b2bdc48da6a29784363ba1baeb6fff8", "url": "https://github.com/oracle/helidon/commit/fc9662772b2bdc48da6a29784363ba1baeb6fff8", "message": "Fix for getResources\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "ab00ac42e6ba63cd6d88f710fd447f0689a5dd43", "url": "https://github.com/oracle/helidon/commit/ab00ac42e6ba63cd6d88f710fd447f0689a5dd43", "message": "fixup tck so it runs. Not all tests working", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "317911802e5628cb5e84e145dc7938e783de197d", "url": "https://github.com/oracle/helidon/commit/317911802e5628cb5e84e145dc7938e783de197d", "message": "initial work on formatting", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "a53d003aa5de2b97265fe305055527e837e532a8", "url": "https://github.com/oracle/helidon/commit/a53d003aa5de2b97265fe305055527e837e532a8", "message": "more work on number formatting", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "5880b9d23e095c264f1caa732080fa98a4b8c414", "url": "https://github.com/oracle/helidon/commit/5880b9d23e095c264f1caa732080fa98a4b8c414", "message": "working on number format", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "1f86921b9e2b3b2370a0bbaaf4fafff241c208a1", "url": "https://github.com/oracle/helidon/commit/1f86921b9e2b3b2370a0bbaaf4fafff241c208a1", "message": "add /graphql/graphql.schema", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "591910947ca1d24f8f570f1bbd29e75e47928fa3", "url": "https://github.com/oracle/helidon/commit/591910947ca1d24f8f570f1bbd29e75e47928fa3", "message": "add /graphql/graphql.schema", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "5e5c29359db870e2e98d9c0e77e194f1d5d956c1", "url": "https://github.com/oracle/helidon/commit/5e5c29359db870e2e98d9c0e77e194f1d5d956c1", "message": "ingore fields progress", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "f2eea3566d0d1ac9228e6a26824090caa0ef799f", "url": "https://github.com/oracle/helidon/commit/f2eea3566d0d1ac9228e6a26824090caa0ef799f", "message": "working through tck failures", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "c94841556caf4289b214a49213a755d582e4d256", "url": "https://github.com/oracle/helidon/commit/c94841556caf4289b214a49213a755d582e4d256", "message": "progress", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "a6a8777f5f2d4975a6477650a8e58598177f135f", "url": "https://github.com/oracle/helidon/commit/a6a8777f5f2d4975a6477650a8e58598177f135f", "message": "further schema fixes", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "65631d918570ae39cef80fa51a58ea7019499509", "url": "https://github.com/oracle/helidon/commit/65631d918570ae39cef80fa51a58ea7019499509", "message": "progress NonNull", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "611e1fe6ebc12245853e17548b37c2eb2fdc0d63", "url": "https://github.com/oracle/helidon/commit/611e1fe6ebc12245853e17548b37c2eb2fdc0d63", "message": "further fixes to nulls and default values", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "09068f7c676c340f617a8b3c1e29fa9887830cfd", "url": "https://github.com/oracle/helidon/commit/09068f7c676c340f617a8b3c1e29fa9887830cfd", "message": "more tck fixes", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "bba87d6fb14b51191e92b7452ea35bf2b96428a8", "url": "https://github.com/oracle/helidon/commit/bba87d6fb14b51191e92b7452ea35bf2b96428a8", "message": "fixup setter and getter", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "645b0902d56cd63073b4405a4389a165741e921b", "url": "https://github.com/oracle/helidon/commit/645b0902d56cd63073b4405a4389a165741e921b", "message": "checkstyle", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "dedc6d84004214432cfaa3092d767a0118051669", "url": "https://github.com/oracle/helidon/commit/dedc6d84004214432cfaa3092d767a0118051669", "message": "updates to tests", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "4744518c637bcabf89fc1d460702e005183384c8", "url": "https://github.com/oracle/helidon/commit/4744518c637bcabf89fc1d460702e005183384c8", "message": "progress on default format values", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "64558b5431cce12df8a5e2b69ef7eb984fc7a327", "url": "https://github.com/oracle/helidon/commit/64558b5431cce12df8a5e2b69ef7eb984fc7a327", "message": "fixup default date/time formats", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "289ed867eed746e7bdff3cdea387c96618b270c7", "url": "https://github.com/oracle/helidon/commit/289ed867eed746e7bdff3cdea387c96618b270c7", "message": "small refactoring", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "867fdae3e23f2d3f9f992f040367832005f5df22", "url": "https://github.com/oracle/helidon/commit/867fdae3e23f2d3f9f992f040367832005f5df22", "message": "Dependency convergence + jakarta libraries", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "97823f1907d43eeb52f69b9bd421a608723e2f4f", "url": "https://github.com/oracle/helidon/commit/97823f1907d43eeb52f69b9bd421a608723e2f4f", "message": "checkstyle and copyright update", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "b34c418f31fec06ae012d2800ae295aac2c7f1d9", "url": "https://github.com/oracle/helidon/commit/b34c418f31fec06ae012d2800ae295aac2c7f1d9", "message": "non null progress", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "10878b766a8822e36e50d7eb3cb6b223488c8b67", "url": "https://github.com/oracle/helidon/commit/10878b766a8822e36e50d7eb3cb6b223488c8b67", "message": "Add checks for NonNull annotations", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "49de6182e65720066b6b725544812ab19b467746", "url": "https://github.com/oracle/helidon/commit/49de6182e65720066b6b725544812ab19b467746", "message": "number format progress", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "8d9247e32e097f87aaa0cb37120cf748dce14908", "url": "https://github.com/oracle/helidon/commit/8d9247e32e097f87aaa0cb37120cf748dce14908", "message": "minor", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "9a7e1a5980e74ed37122ca474deaa7a02f84f947", "url": "https://github.com/oracle/helidon/commit/9a7e1a5980e74ed37122ca474deaa7a02f84f947", "message": "Ensure that a new Query or Mutation cannot override an existing one with the same name", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "3610bd95507e6b0a0e1a6ee1508ac71545482849", "url": "https://github.com/oracle/helidon/commit/3610bd95507e6b0a0e1a6ee1508ac71545482849", "message": "exception handling progress", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "f10bad0f696c4b6e84b37b8d96e398e9a230e2c3", "url": "https://github.com/oracle/helidon/commit/f10bad0f696c4b6e84b37b8d96e398e9a230e2c3", "message": "exception progress", "committedDate": "2020-11-05T03:44:28Z", "type": "commit"}, {"oid": "d1ccc5cb2a262ebaddb7cf54cabcc2b12bf668a7", "url": "https://github.com/oracle/helidon/commit/d1ccc5cb2a262ebaddb7cf54cabcc2b12bf668a7", "message": "exception fixup", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "33b4e16be7ca623172aa8cfdf70151a0498fe56c", "url": "https://github.com/oracle/helidon/commit/33b4e16be7ca623172aa8cfdf70151a0498fe56c", "message": " Validate that a name for a query or mutation does not contain invalid characters", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "a06822b82f8d83fe9d73fc48b32a632070813e3c", "url": "https://github.com/oracle/helidon/commit/a06822b82f8d83fe9d73fc48b32a632070813e3c", "message": "progress on date/time - tests not working", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "cc3ec42a6c1360f673f88b8fc829a281368b3495", "url": "https://github.com/oracle/helidon/commit/cc3ec42a6c1360f673f88b8fc829a281368b3495", "message": "progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "9adc3524f4fa6cbb01309165eb0b6a3dc2da098e", "url": "https://github.com/oracle/helidon/commit/9adc3524f4fa6cbb01309165eb0b6a3dc2da098e", "message": "progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "57a9fbde1ecd12cb45d4fb837ea3463ff1a3533b", "url": "https://github.com/oracle/helidon/commit/57a9fbde1ecd12cb45d4fb837ea3463ff1a3533b", "message": "Fixup Config", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "05f8075c98597e34722f07038684b92e062ed43a", "url": "https://github.com/oracle/helidon/commit/05f8075c98597e34722f07038684b92e062ed43a", "message": "work on dates", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "6efcd6e4b845d6fa741684e0195271ecbe201093", "url": "https://github.com/oracle/helidon/commit/6efcd6e4b845d6fa741684e0195271ecbe201093", "message": "fixup date formatting", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "b68d2ec3ec570ecd30813e442991e82286507910", "url": "https://github.com/oracle/helidon/commit/b68d2ec3ec570ecd30813e442991e82286507910", "message": "progress - still issues with argument conversion", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "72a54ffc7d878b24f489ac113d0864ef6952bd28", "url": "https://github.com/oracle/helidon/commit/72a54ffc7d878b24f489ac113d0864ef6952bd28", "message": "progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "2997fae7527ac8941cb1cbdc85af3d789674f3cf", "url": "https://github.com/oracle/helidon/commit/2997fae7527ac8941cb1cbdc85af3d789674f3cf", "message": "progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "499ae627955b3ebfeeaa3c41b2ba973ed936ee52", "url": "https://github.com/oracle/helidon/commit/499ae627955b3ebfeeaa3c41b2ba973ed936ee52", "message": "Fixup arrays and revert HelidonDeployableContainer for Tomas", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "6f655a90fdae61df60f47a5ac64cf75ffe4f1b7a", "url": "https://github.com/oracle/helidon/commit/6f655a90fdae61df60f47a5ac64cf75ffe4f1b7a", "message": "Graphql tck (#2)\n\n* Changes to run TCK test.\r\n\r\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>\r\n\r\n* Changes to process GraphQLApi without explicit Jandex use (it is used implicitly by Weld).\r\nFix to service loader (must be both in module-info and in META-INF/services)\r\n\r\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "722e4c82e029ed0f917a58629aec7ad2bc21ef35", "url": "https://github.com/oracle/helidon/commit/722e4c82e029ed0f917a58629aec7ad2bc21ef35", "message": "IT refactoring progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "186b3ded4da6782712f39b33c8b64cdb48f36c76", "url": "https://github.com/oracle/helidon/commit/186b3ded4da6782712f39b33c8b64cdb48f36c76", "message": "Fixup failing tests after moving to CDI discovery", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "019ff09ff72589ad1375a454aa96f0bfd884524c", "url": "https://github.com/oracle/helidon/commit/019ff09ff72589ad1375a454aa96f0bfd884524c", "message": "progress on tck tests", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "8f1eccd3729d6dd62b5e554280de94e1d6ecd46e", "url": "https://github.com/oracle/helidon/commit/8f1eccd3729d6dd62b5e554280de94e1d6ecd46e", "message": "Work through TCK failures", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "a17bff7bade36f416e491946818b656dae66a18f", "url": "https://github.com/oracle/helidon/commit/a17bff7bade36f416e491946818b656dae66a18f", "message": "Fixup handling of Collections - part 1", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "bdd9a2f483c6ed58419f54eea45144089203b0af", "url": "https://github.com/oracle/helidon/commit/bdd9a2f483c6ed58419f54eea45144089203b0af", "message": "TCK progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "6ed519e65cffa86fca193f789024e5173eb6535c", "url": "https://github.com/oracle/helidon/commit/6ed519e65cffa86fca193f789024e5173eb6535c", "message": "Fixup LocalTime", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "f92c4342d6a18c35fa14ac041f77929cb94f6219", "url": "https://github.com/oracle/helidon/commit/f92c4342d6a18c35fa14ac041f77929cb94f6219", "message": "Fixing formatting", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "14de75b04127f43d208af1a052547330c638b31a", "url": "https://github.com/oracle/helidon/commit/14de75b04127f43d208af1a052547330c638b31a", "message": "progress on Input type conversion", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "52aa8eece3b51c176d5f005d35d9225347573b2f", "url": "https://github.com/oracle/helidon/commit/52aa8eece3b51c176d5f005d35d9225347573b2f", "message": "progress on tck", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "cf806b7aaf8bc655523c5f2fea9d42343a299188", "url": "https://github.com/oracle/helidon/commit/cf806b7aaf8bc655523c5f2fea9d42343a299188", "message": "progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "c195180ab9c511e47785f16433ab798d1a4b40b8", "url": "https://github.com/oracle/helidon/commit/c195180ab9c511e47785f16433ab798d1a4b40b8", "message": "progress on object graphs", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "6e8e26e245d9f2fd3a3b4cd4bcc1ca5bff260113", "url": "https://github.com/oracle/helidon/commit/6e8e26e245d9f2fd3a3b4cd4bcc1ca5bff260113", "message": "move from Weld to HelidonTest", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "a6ad3070fe8d180b41f6015466757a174ee7af8e", "url": "https://github.com/oracle/helidon/commit/a6ad3070fe8d180b41f6015466757a174ee7af8e", "message": "progress - some failing tests", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "c13e7ce4ed668982a16c70cd212a6f3f9206efa9", "url": "https://github.com/oracle/helidon/commit/c13e7ce4ed668982a16c70cd212a6f3f9206efa9", "message": "progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "60a7affa39db1a584dfbd111323d5131504b027f", "url": "https://github.com/oracle/helidon/commit/60a7affa39db1a584dfbd111323d5131504b027f", "message": "re-enabled GraphQLEndpointIT tests", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "f03a743d96710ad10f19c2587b902366bfb09447", "url": "https://github.com/oracle/helidon/commit/f03a743d96710ad10f19c2587b902366bfb09447", "message": "progress", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "8781ba66dedda21e7ba2ba3f0c735f3c00085f64", "url": "https://github.com/oracle/helidon/commit/8781ba66dedda21e7ba2ba3f0c735f3c00085f64", "message": "COH-20749", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "42cea9d950c7d7c3295becec453590ff6cff2334", "url": "https://github.com/oracle/helidon/commit/42cea9d950c7d7c3295becec453590ff6cff2334", "message": "fixup enums and more", "committedDate": "2020-11-05T03:44:29Z", "type": "commit"}, {"oid": "8e7c968a6b6aa4f1076402abcec083b20b7552cc", "url": "https://github.com/oracle/helidon/commit/8e7c968a6b6aa4f1076402abcec083b20b7552cc", "message": "progress", "committedDate": "2020-11-05T03:44:30Z", "type": "commit"}, {"oid": "fa4614fb51c89feba01bedb217dc6f30ac4caee1", "url": "https://github.com/oracle/helidon/commit/fa4614fb51c89feba01bedb217dc6f30ac4caee1", "message": "remove relience on jandex for annotation discovery", "committedDate": "2020-11-05T03:44:30Z", "type": "commit"}]}