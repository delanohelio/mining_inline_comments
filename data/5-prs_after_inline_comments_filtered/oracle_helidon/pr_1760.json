{"pr_number": 1760, "pr_title": "Fixes StackOverflowError unearthed by new MicroProfile Config implementation", "pr_createdAt": "2020-05-09T00:34:25Z", "pr_url": "https://github.com/oracle/helidon/pull/1760", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyODY3MA==", "url": "https://github.com/oracle/helidon/pull/1760#discussion_r429428670", "bodyText": "Please do not use assert in the code. I do not see an advantage checking for null not being returned by methods that claim to never return null (such as Optional.orElse(T)).\nWe are not using this approach anywhere in Helidon.\nNo need to remove existing assert statements from code, but please do not add new ones.", "author": "tomas-langer", "createdAt": "2020-05-22T19:51:36Z", "path": "integrations/cdi/oci-objectstorage-cdi/src/main/java/io/helidon/integrations/cdi/oci/objectstorage/OciConfigConfigSource.java", "diffHunk": "@@ -98,32 +100,45 @@ public int getOrdinal() {\n   @Override\n   public String getValue(final String propertyName) {\n     final String returnValue;\n-    if (propertyName == null || propertyName.equals(\"oci.auth.profile\") || propertyName.equals(\"oci.config.path\")) {\n+    if (propertyName == null) {\n       returnValue = null;\n+    } else if (propertyName.equals(ConfigSource.CONFIG_ORDINAL)) {\n+      returnValue = String.valueOf(this.getOrdinal());\n     } else {\n       Map<String, String> properties = this.properties;\n       if (properties == null) {\n-        final Config config = ConfigProvider.getConfig();\n-        assert config != null;\n-        final String profile = config.getOptionalValue(\"oci.auth.profile\", String.class).orElse(\"DEFAULT\");\n-        assert profile != null;\n-        final String configFilePath = config.getOptionalValue(\"oci.config.path\", String.class).orElse(null);\n-        final ConfigFileAuthenticationDetailsProvider provider;\n-        ConfigFileAuthenticationDetailsProvider temp = null;\n+        properties = PROPERTIES.get();\n+      }\n+      if (properties == null) {\n+        PROPERTIES.set(Collections.emptyMap());\n         try {\n-          if (configFilePath == null) {\n-            temp = new ConfigFileAuthenticationDetailsProvider(profile);\n-          } else {\n-            temp = new ConfigFileAuthenticationDetailsProvider(configFilePath, profile);\n+          // Reentrant call; i.e. this causes a new\n+          // OciConfigConfigSource instance to be created and queried\n+          // for various values.\n+          final Config config = ConfigProvider.getConfig();\n+          assert config != null;", "originalCommit": "ce9817820c2482316964140a2ac5796a70c500b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDMwMA==", "url": "https://github.com/oracle/helidon/pull/1760#discussion_r429430300", "bodyText": "This approach is broken by design.\nConsider a user creating a custom configuration using a builder and registering config sources, including this one.\nIf at this point, you attempt to use ConfigProvider.getConfig(), another instance of config is created (using just the defaults of MicroProfile, with only microprofile-config.properties, system properties and environment variables)\nThis config may not contain any configuration value you expect to find there, because it is not provided at all (or may provide configuration built-into the application only valid for development environment).\nAs MP does not have the concept of \"meta-configuration\", you have the following options:\n\nprovide a builder approach to create an instance of this config source \"by hand\"\nuse a config-independent way of obtaining configuration of this config source - such as system properties and environment variables.\n\nThis is an unfortunate side effect of how the specification is done, yet there is no way to get hold of a Config instance while setting up a ConfigSource that is not broken.", "author": "tomas-langer", "createdAt": "2020-05-22T19:57:25Z", "path": "integrations/cdi/oci-objectstorage-cdi/src/main/java/io/helidon/integrations/cdi/oci/objectstorage/OciConfigConfigSource.java", "diffHunk": "@@ -98,32 +100,45 @@ public int getOrdinal() {\n   @Override\n   public String getValue(final String propertyName) {\n     final String returnValue;\n-    if (propertyName == null || propertyName.equals(\"oci.auth.profile\") || propertyName.equals(\"oci.config.path\")) {\n+    if (propertyName == null) {\n       returnValue = null;\n+    } else if (propertyName.equals(ConfigSource.CONFIG_ORDINAL)) {\n+      returnValue = String.valueOf(this.getOrdinal());\n     } else {\n       Map<String, String> properties = this.properties;\n       if (properties == null) {\n-        final Config config = ConfigProvider.getConfig();\n-        assert config != null;\n-        final String profile = config.getOptionalValue(\"oci.auth.profile\", String.class).orElse(\"DEFAULT\");\n-        assert profile != null;\n-        final String configFilePath = config.getOptionalValue(\"oci.config.path\", String.class).orElse(null);\n-        final ConfigFileAuthenticationDetailsProvider provider;\n-        ConfigFileAuthenticationDetailsProvider temp = null;\n+        properties = PROPERTIES.get();\n+      }\n+      if (properties == null) {\n+        PROPERTIES.set(Collections.emptyMap());\n         try {\n-          if (configFilePath == null) {\n-            temp = new ConfigFileAuthenticationDetailsProvider(profile);\n-          } else {\n-            temp = new ConfigFileAuthenticationDetailsProvider(configFilePath, profile);\n+          // Reentrant call; i.e. this causes a new\n+          // OciConfigConfigSource instance to be created and queried\n+          // for various values.\n+          final Config config = ConfigProvider.getConfig();", "originalCommit": "ce9817820c2482316964140a2ac5796a70c500b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0MTEzMg==", "url": "https://github.com/oracle/helidon/pull/1760#discussion_r429441132", "bodyText": "I see.  I was following this discussion which implied that (careful) use of ConfigProvider.getConfig() from within a ConfigSource was possible and generally accepted.  Clearly I misunderstood the discussion.  What would you recommend instead?", "author": "ljnelson", "createdAt": "2020-05-22T20:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTE1MA==", "url": "https://github.com/oracle/helidon/pull/1760#discussion_r429531150", "bodyText": "'ConfigProvider.getConfig()' will give you either the default config, or a config previously configured by a user.\nIn case you expect that your config source's configuration in one of the default sources (system properties, env vars, 'microprofile-config.properties'), you can use the builder to build your own instance of the config using builder and just these three sources.\nThis way you never get to the situation, that your config source would be created as part of your own call to 'ConfigProvider.getConfig()'.\nYou would obviously need to document such thing clearly.\nHow to (sorry, not in front of a working IDE, typing from memory):\n'Config configOfMySource = ConfigProviderResolver.instance().newBuilder().addDiscoveredConverters().addDefaultSources().build()'\nI understand that the approach you have implemented works in a single scenario, but unfortunately there are other cases where it would not work as expected.\nThe scenarios I consider:\n\nUse of default configuration - in this case you create an additional instance of configuration and register it as current, depending on implementation of ConfigProviderResolver to be fine with a parallel call to 'getConfig()'\nUse of manual configuration with custom config sources - you would register a default instance of config as current, even though that is not desired by the user (as they are building a custom instance and want to register that one instead) - so (though possibly for a short period of time) the system would be misconfigured", "author": "tomas-langer", "createdAt": "2020-05-23T09:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTUwOQ==", "url": "https://github.com/oracle/helidon/pull/1760#discussion_r429531509", "bodyText": "My proposal is similar to the one in the mentioned discussion - see the 'CloudantConfigSource' that uses:\n'Config c = ConfigProviderResolver.instance().getBuilder().addDefaultSources().withSources(configSrc).build();' to prevent cycle", "author": "tomas-langer", "createdAt": "2020-05-23T09:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU0MTE2Ng==", "url": "https://github.com/oracle/helidon/pull/1760#discussion_r431541166", "bodyText": "I see.  Doesn't ConfigProvider.getConfig() also pick up ConfigSource instances on the classpath (i.e. it's not just the defaults)?  I think maybe that's where I must have gotten confused.", "author": "ljnelson", "createdAt": "2020-05-28T02:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDMwMA=="}], "type": "inlineReview"}, {"oid": "b8d8949dc1babd0366b3a0285815c13a2b0b5719", "url": "https://github.com/oracle/helidon/commit/b8d8949dc1babd0366b3a0285815c13a2b0b5719", "message": "Fixes StackOverflowError unearthed by new MicroProfile Config implementation.\n\nSigned-off-by: Laird Nelson <laird.nelson@oracle.com>", "committedDate": "2020-06-01T17:25:47Z", "type": "commit"}, {"oid": "42c6ce2b2d75c5293baa7cd0375a580f02c8ca51", "url": "https://github.com/oracle/helidon/commit/42c6ce2b2d75c5293baa7cd0375a580f02c8ca51", "message": "Incorporated PR feedback\n\nSigned-off-by: Laird Nelson <laird.nelson@oracle.com>", "committedDate": "2020-06-01T18:10:54Z", "type": "commit"}]}