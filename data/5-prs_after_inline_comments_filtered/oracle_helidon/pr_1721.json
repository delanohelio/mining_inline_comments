{"pr_number": 1721, "pr_title": "MP Config fixes", "pr_createdAt": "2020-05-04T15:55:59Z", "pr_url": "https://github.com/oracle/helidon/pull/1721", "timeline": [{"oid": "7f8a8cb80bdfdf8b03049a214089a18626d394f0", "url": "https://github.com/oracle/helidon/commit/7f8a8cb80bdfdf8b03049a214089a18626d394f0", "message": "Squashable 1\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-04-29T14:17:11Z", "type": "commit"}, {"oid": "43bb44d59760dae263006ba1085140c8d4847fb6", "url": "https://github.com/oracle/helidon/commit/43bb44d59760dae263006ba1085140c8d4847fb6", "message": "Priorities update and pom fixes, webserver better error message on port conflict.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-04T15:06:31Z", "type": "commit"}, {"oid": "8c3d92f87b8adccc97d561b7b52b6531113326d7", "url": "https://github.com/oracle/helidon/commit/8c3d92f87b8adccc97d561b7b52b6531113326d7", "message": "New config MP module and code style fixes.\nUpdated TCK support.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-04T15:53:40Z", "type": "commit"}, {"oid": "9bb22d526254dc2ed2686947eae8e93f8da15757", "url": "https://github.com/oracle/helidon/commit/9bb22d526254dc2ed2686947eae8e93f8da15757", "message": "Checkstyle fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-04T16:19:40Z", "type": "commit"}, {"oid": "f942d94763b4b526b8bb0c1bdd9509b9850614c7", "url": "https://github.com/oracle/helidon/commit/f942d94763b4b526b8bb0c1bdd9509b9850614c7", "message": "Checkstyle fixes 2.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-04T16:33:02Z", "type": "commit"}, {"oid": "2a9bee197ed7e1452893c3f46a8a939184ac0d4b", "url": "https://github.com/oracle/helidon/commit/2a9bee197ed7e1452893c3f46a8a939184ac0d4b", "message": "Javadoc fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-04T16:52:15Z", "type": "commit"}, {"oid": "4f3a345cfbb825e3d76c1310ed4047489c2b4016", "url": "https://github.com/oracle/helidon/commit/4f3a345cfbb825e3d76c1310ed4047489c2b4016", "message": "Added built-in converters to MP from SE.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-04T19:59:22Z", "type": "commit"}, {"oid": "ed1018eb1c377144b2da81c6ceedd7bfd68d4e62", "url": "https://github.com/oracle/helidon/commit/ed1018eb1c377144b2da81c6ceedd7bfd68d4e62", "message": "Print full config tree for troubleshooting.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-04T20:17:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwNzMwMA==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419907300", "bodyText": "Extra semicolon at the end is causing checkstyle to fail.", "author": "aseovic", "createdAt": "2020-05-05T07:15:43Z", "path": "config/config-mp/src/main/java/io/helidon/config/mp/MpConfigBuilder.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config.mp;\n+\n+import java.io.File;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.URI;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n+import java.time.Period;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ServiceLoader;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+import java.util.regex.Pattern;\n+\n+import io.helidon.common.serviceloader.HelidonServiceLoader;\n+import io.helidon.common.serviceloader.Priorities;\n+import io.helidon.config.ConfigMappers;\n+import io.helidon.config.mp.spi.MpConfigFilter;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigBuilder;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+import org.eclipse.microprofile.config.spi.ConfigSourceProvider;\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+/**\n+ * Configuration builder.\n+ */\n+public class MpConfigBuilder implements ConfigBuilder {\n+    private boolean useDefaultSources = false;\n+    private boolean useDiscoveredSources = false;\n+    private boolean useDiscoveredConverters = false;\n+\n+    private final List<OrdinalSource> sources = new LinkedList<>();\n+    private final List<OrdinalConverter> converters = new LinkedList<>();\n+\n+    private ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n+\n+    MpConfigBuilder() {\n+    }\n+\n+    @Override\n+    public ConfigBuilder addDefaultSources() {\n+        useDefaultSources = true;\n+        return this;\n+    }\n+\n+    @Override\n+    public ConfigBuilder addDiscoveredSources() {\n+        useDiscoveredSources = true;\n+        return this;\n+    }\n+\n+    @Override\n+    public ConfigBuilder addDiscoveredConverters() {\n+        useDiscoveredConverters = true;\n+        return this;\n+    }\n+\n+    @Override\n+    public ConfigBuilder forClassLoader(ClassLoader loader) {\n+        this.classLoader = loader;\n+        return this;\n+    }\n+\n+    @Override\n+    public ConfigBuilder withSources(ConfigSource... sources) {\n+        for (ConfigSource source : sources) {\n+            this.sources.add(new OrdinalSource(source));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public <T> ConfigBuilder withConverter(Class<T> aClass, int ordinal, Converter<T> converter) {\n+        this.converters.add(new OrdinalConverter(converter, aClass, ordinal));\n+        return this;\n+    }\n+\n+    @Override\n+    public ConfigBuilder withConverters(Converter<?>... converters) {\n+        for (Converter<?> converter : converters) {\n+            this.converters.add(new OrdinalConverter(converter));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Config build() {\n+        if (useDefaultSources) {\n+            sources.add(new OrdinalSource(MpConfigSources.systemProperties(), 400));\n+            sources.add(new OrdinalSource(MpConfigSources.environmentVariables(), 300));\n+            // microprofile-config.properties\n+            MpConfigSources.classPath(classLoader, \"META-INF/microprofile-config.properties\")\n+                    .stream()\n+                    .map(OrdinalSource::new)\n+                    .forEach(sources::add);\n+        }\n+        // built-in converters - required by specification\n+        addBuiltIn(converters, Boolean.class, ConfigMappers::toBoolean);\n+        addBuiltIn(converters, Boolean.TYPE, ConfigMappers::toBoolean);\n+        addBuiltIn(converters, Byte.class, Byte::parseByte);\n+        addBuiltIn(converters, Byte.TYPE, Byte::parseByte);\n+        addBuiltIn(converters, Short.class, Short::parseShort);\n+        addBuiltIn(converters, Short.TYPE, Short::parseShort);\n+        addBuiltIn(converters, Integer.class, Integer::parseInt);\n+        addBuiltIn(converters, Integer.TYPE, Integer::parseInt);\n+        addBuiltIn(converters, Long.class, Long::parseLong);\n+        addBuiltIn(converters, Long.TYPE, Long::parseLong);\n+        addBuiltIn(converters, Float.class, Float::parseFloat);\n+        addBuiltIn(converters, Float.TYPE, Float::parseFloat);\n+        addBuiltIn(converters, Double.class, Double::parseDouble);\n+        addBuiltIn(converters, Double.TYPE, Double::parseDouble);\n+        addBuiltIn(converters, Character.class, MpConfigBuilder::toChar);\n+        addBuiltIn(converters, Character.TYPE, MpConfigBuilder::toChar);\n+        addBuiltIn(converters, Class.class, MpConfigBuilder::toClass);\n+\n+        // built-in converters - Helidon\n+        //javax.math\n+        addBuiltIn(converters, BigDecimal.class, ConfigMappers::toBigDecimal);\n+        addBuiltIn(converters, BigInteger.class, ConfigMappers::toBigInteger);\n+        //java.time\n+        addBuiltIn(converters, Duration.class, ConfigMappers::toDuration);\n+        addBuiltIn(converters, Period.class, ConfigMappers::toPeriod);\n+        addBuiltIn(converters, LocalDate.class, ConfigMappers::toLocalDate);\n+        addBuiltIn(converters, LocalDateTime.class, ConfigMappers::toLocalDateTime);\n+        addBuiltIn(converters, LocalTime.class, ConfigMappers::toLocalTime);\n+        addBuiltIn(converters, ZonedDateTime.class, ConfigMappers::toZonedDateTime);\n+        addBuiltIn(converters, ZoneId.class, ConfigMappers::toZoneId);\n+        addBuiltIn(converters, ZoneOffset.class, ConfigMappers::toZoneOffset);\n+        addBuiltIn(converters, Instant.class, ConfigMappers::toInstant);\n+        addBuiltIn(converters, OffsetTime.class, ConfigMappers::toOffsetTime);\n+        addBuiltIn(converters, OffsetDateTime.class, ConfigMappers::toOffsetDateTime);\n+        addBuiltIn(converters, YearMonth.class, YearMonth::parse); ;", "originalCommit": "ed1018eb1c377144b2da81c6ceedd7bfd68d4e62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0NzkzNg==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419947936", "bodyText": "fixed", "author": "tomas-langer", "createdAt": "2020-05-05T08:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwNzMwMA=="}], "type": "inlineReview"}, {"oid": "7fcca63cc93e160cd14e01f31ebd4dc62a1b3861", "url": "https://github.com/oracle/helidon/commit/7fcca63cc93e160cd14e01f31ebd4dc62a1b3861", "message": "Extra semicolon.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-05T08:25:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MjA1Nw==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419952057", "bodyText": "filter.apply(propertyName, result) or is it last filter wins?", "author": "danielkec", "createdAt": "2020-05-05T08:43:10Z", "path": "config/config-mp/src/main/java/io/helidon/config/mp/MpConfigImpl.java", "diffHunk": "@@ -0,0 +1,392 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config.mp;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.helidon.config.mp.spi.MpConfigFilter;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+import org.eclipse.microprofile.config.spi.Converter;\n+\n+public class MpConfigImpl implements Config {\n+    private static final Logger LOGGER = Logger.getLogger(MpConfigImpl.class.getName());\n+    // for references resolving\n+    // matches string between ${ } with a negative lookbehind if there is not backslash\n+    private static final String REGEX_REFERENCE = \"(?<!\\\\\\\\)\\\\$\\\\{([^}]+)\\\\}\";\n+    private static final Pattern PATTERN_REFERENCE = Pattern.compile(REGEX_REFERENCE);\n+    // for encoding backslashes\n+    // matches a backslash with a positive lookahead if it is the backslash that encodes ${}\n+    private static final String REGEX_BACKSLASH = \"\\\\\\\\(?=\\\\$\\\\{([^}]+)\\\\})\";\n+    private static final Pattern PATTERN_BACKSLASH = Pattern.compile(REGEX_BACKSLASH);\n+    // I only care about unresolved key happening within the same thread\n+    private static final ThreadLocal<Set<String>> UNRESOLVED_KEYS = ThreadLocal.withInitial(HashSet::new);\n+\n+    private static final Pattern SPLIT_PATTERN = Pattern.compile(\"(?<!\\\\\\\\),\");\n+    private static final Pattern ESCAPED_COMMA_PATTERN = Pattern.compile(\"\\\\,\", Pattern.LITERAL);\n+\n+    private final List<ConfigSource> sources = new LinkedList<>();\n+    private final HashMap<Class<?>, Converter<?>> converters = new LinkedHashMap<>();\n+    private final boolean valueResolving;\n+    private final List<MpConfigFilter> filters = new ArrayList<>();\n+\n+    MpConfigImpl(List<ConfigSource> sources,\n+                 HashMap<Class<?>, Converter<?>> converters,\n+                 List<MpConfigFilter> filters) {\n+        this.sources.addAll(sources);\n+        this.converters.putAll(converters);\n+        this.converters.putIfAbsent(String.class, value -> value);\n+\n+        this.valueResolving = getOptionalValue(\"helidon.config.value-resolving.enabled\", Boolean.class)\n+                .orElse(true);\n+\n+        // we need to initialize the filters first, before we set up filters\n+        filters.forEach(it -> {\n+            // initialize filter with filters with higher priority already in place\n+            it.init(this);\n+            // and then add it to the list of active filters\n+            // do not do this first, as we would end up in using an uninitialized filter\n+            this.filters.add(it);\n+        });\n+    }\n+\n+    @Override\n+    public <T> T getValue(String propertyName, Class<T> propertyType) {\n+        return getOptionalValue(propertyName, propertyType)\n+                .orElseThrow(() -> new NoSuchElementException(\"Property \\\"\" + propertyName + \"\\\" is not available in \"\n+                                                                      + \"configuration\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Optional<T> getOptionalValue(String propertyName, Class<T> propertyType) {\n+        // let's resolve arrays\n+        if (propertyType.isArray()) {\n+            Class<?> componentType = propertyType.getComponentType();\n+            // first try to see if we have a direct value\n+            Optional<String> optionalValue = getOptionalValue(propertyName, String.class);\n+            if (optionalValue.isPresent()) {\n+                return Optional.of((T) toArray(propertyName, optionalValue.get(), componentType));\n+            }\n+\n+            /*\n+             we also support indexed value\n+             e.g. for key \"my.list\" you can have both:\n+             my.list=12,13,14\n+             or (not and):\n+             my.list.0=12\n+             my.list.1=13\n+             */\n+\n+            String indexedConfigKey = propertyName + \".0\";\n+            optionalValue = getOptionalValue(indexedConfigKey, String.class);\n+            if (optionalValue.isPresent()) {\n+                List<Object> result = new LinkedList<>();\n+\n+                // first element is already in\n+                result.add(convert(indexedConfigKey, componentType, optionalValue.get()));\n+\n+                // hardcoded limit to lists of 1000 elements\n+                for (int i = 1; i < 1000; i++) {\n+                    indexedConfigKey = propertyName + \".\" + i;\n+                    optionalValue = getOptionalValue(indexedConfigKey, String.class);\n+                    if (optionalValue.isPresent()) {\n+                        result.add(convert(indexedConfigKey, componentType, optionalValue.get()));\n+                    } else {\n+                        // finish the iteration on first missing index\n+                        break;\n+                    }\n+                }\n+                Object array = Array.newInstance(componentType, result.size());\n+                for (int i = 0; i < result.size(); i++) {\n+                    Object component = result.get(i);\n+                    Array.set(array, i, component);\n+                }\n+                return Optional.of((T) array);\n+            } else {\n+                return Optional.empty();\n+            }\n+        } else {\n+            return getStringValue(propertyName)\n+                    .flatMap(it -> applyFilters(propertyName, it))\n+                    .map(it -> convert(propertyName, propertyType, it));\n+        }\n+    }\n+\n+    @Override\n+    public Iterable<String> getPropertyNames() {\n+        Set<String> names = new LinkedHashSet<>();\n+        for (ConfigSource source : sources) {\n+            names.addAll(source.getPropertyNames());\n+        }\n+        return names;\n+    }\n+\n+    @Override\n+    public Iterable<ConfigSource> getConfigSources() {\n+        return Collections.unmodifiableList(sources);\n+    }\n+\n+    /**\n+     * Return the {@link Converter} used by this instance to produce instances of the specified type from string values.\n+     *\n+     * This method is from a future version of MP Config specification and may changed before it\n+     * is released. It is nevertheless needed to process annotations with default values.\n+     *\n+     * @param <T> the conversion type\n+     * @param forType the type to be produced by the converter\n+     * @return an {@link java.util.Optional} containing the converter, or empty if no converter is available for the specified type\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> Optional<Converter<T>> getConverter(Class<T> forType) {\n+        return converters.entrySet()\n+                .stream()\n+                .filter(it -> forType.isAssignableFrom(it.getKey()))\n+                .findFirst()\n+                .map(Map.Entry::getValue)\n+                .map(it -> (Converter<T>) it)\n+                .or(() -> findImplicit(forType));\n+    }\n+\n+    /**\n+     * Convert a String to a specific type.\n+     * This is a helper method to allow for processing of default values that cannot be typed (e.g. in annotations).\n+     *\n+     * @param propertyName name of the property, used for error messages\n+     * @param type  type of the property\n+     * @param value String value (may be null)\n+     * @param <T>   type\n+     * @return instance of the correct type, may return null in case null was provided and converter did not do this\n+     * @throws IllegalArgumentException in case the String provided cannot be converted to the type expected\n+     */\n+    private <T> T convert(String propertyName, Class<T> type, String value) {\n+        try {\n+            return findConverter(type)\n+                    .convert(value);\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Failed to convert property \\\"\"\n+                                                       + propertyName\n+                                                       + \"\\\" from its value \\\"\"\n+                                                       + value\n+                                                       + \"\\\" to \"\n+                                                       + type.getName(),\n+                                               e);\n+        }\n+    }\n+\n+    private Optional<String> getStringValue(String propertyName) {\n+        for (ConfigSource source : sources) {\n+            String value = source.getValue(propertyName);\n+\n+            if (null == value) {\n+                // not in this one\n+                continue;\n+            }\n+\n+            LOGGER.finest(\"Found property \" + propertyName + \" in source \" + source.getName());\n+            return Optional.of(resolveReferences(propertyName, value));\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private Optional<String> applyFilters(String propertyName, String stringValue) {\n+        String result = stringValue;\n+\n+        for (MpConfigFilter filter : filters) {\n+            result = filter.apply(propertyName, stringValue);", "originalCommit": "7fcca63cc93e160cd14e01f31ebd4dc62a1b3861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3MDI3MQ==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419970271", "bodyText": "correct!", "author": "tomas-langer", "createdAt": "2020-05-05T09:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk1MjA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk2MTU5OA==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419961598", "bodyText": "do not", "author": "danielkec", "createdAt": "2020-05-05T08:59:41Z", "path": "config/config-mp/src/main/java/io/helidon/config/mp/MpEnvironmentVariablesSource.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config.mp;\n+\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.regex.Pattern;\n+\n+import javax.annotation.Priority;\n+\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+@Priority(300)\n+class MpEnvironmentVariablesSource implements ConfigSource {\n+    private static final Pattern DISALLOWED_CHARS = Pattern.compile(\"[^a-zA-Z0-9_]\");\n+    private static final String UNDERSCORE = \"_\";\n+\n+    private final Map<String, String> env;\n+    private final Map<String, Cached> cache = new ConcurrentHashMap<>();\n+\n+    MpEnvironmentVariablesSource() {\n+        this.env = System.getenv();\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return env;\n+    }\n+\n+    @Override\n+    public String getValue(String propertyName) {\n+        // environment variable config source is immutable - we can safely cache all requested keys, so we\n+        // not not execute the regular expression on every get", "originalCommit": "7fcca63cc93e160cd14e01f31ebd4dc62a1b3861", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f87df80bc254d010b3252b1eca42c06f4614f779", "url": "https://github.com/oracle/helidon/commit/f87df80bc254d010b3252b1eca42c06f4614f779", "message": "Review fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-05T09:17:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3NzU2Mg==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419977562", "bodyText": "return (Map) props", "author": "danielkec", "createdAt": "2020-05-05T09:28:45Z", "path": "config/config-mp/src/main/java/io/helidon/config/mp/MpSystemPropertiesSource.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config.mp;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+import javax.annotation.Priority;\n+\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+@Priority(400)\n+class MpSystemPropertiesSource implements ConfigSource {\n+    private final Properties props;\n+\n+    MpSystemPropertiesSource() {\n+        this.props = System.getProperties();\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        Set<String> strings = props.stringPropertyNames();\n+\n+        Map<String, String> result = new HashMap<>();\n+        strings.forEach(it -> result.put(it, props.getProperty(it)));\n+        return result;\n+    }", "originalCommit": "7fcca63cc93e160cd14e01f31ebd4dc62a1b3861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5ODg1Mw==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419998853", "bodyText": "I do not like to treat Properties as a string map, as it is in fact a Map<String, Object>. Not sure why, but that is the implementation...", "author": "tomas-langer", "createdAt": "2020-05-05T10:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3NzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MDYyNg==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419990626", "bodyText": "Is volatile necessary here? Value is assigned only in synchronized block", "author": "danielkec", "createdAt": "2020-05-05T09:52:05Z", "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -37,11 +37,11 @@\n final class ConfigSourcesRuntime {\n     private final List<RuntimeWithData> loadedData = new LinkedList<>();\n \n-    private List<ConfigSourceRuntimeBase> allSources;\n-    private MergingStrategy mergingStrategy;\n-    private Consumer<Optional<ObjectNode>> changeListener;\n+    private final List<ConfigSourceRuntimeImpl> allSources;\n+    private final MergingStrategy mergingStrategy;\n+    private volatile Consumer<Optional<ObjectNode>> changeListener;", "originalCommit": "f87df80bc254d010b3252b1eca42c06f4614f779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5OTQ0Nw==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419999447", "bodyText": "It is not - the .onChange() on line 86 is not in synchronized block.", "author": "tomas-langer", "createdAt": "2020-05-05T10:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MDYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxOTQzMA==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r420019430", "bodyText": "missed that", "author": "danielkec", "createdAt": "2020-05-05T10:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5MDYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5NTIzMw==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r419995233", "bodyText": "prime/Prime", "author": "danielkec", "createdAt": "2020-05-05T10:00:30Z", "path": "config/encryption/src/main/java/io/helidon/config/encryption/MpEncryptionFilter.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config.encryption;\n+\n+import java.security.PrivateKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.util.HashSet;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.config.mp.spi.MpConfigFilter;\n+\n+import org.eclipse.microprofile.config.Config;\n+\n+/**\n+ * Provides possibility to decrypt passwords from configuration sources.\n+ * Configuration can be used to enforce encryption (e.g. we will fail on clear-text value).\n+ * <p>\n+ * Password in properties must be stored as follows:\n+ * <ul>\n+ * <li>${AES=base64} - encrypted password using a master password (must be provided to Prime through configuration, system\n+ * property or environment variable)</li>\n+ * <li>${RSA=base64} - encrypted password using a public key (private key must be available to Prime instance,\n+ * its location must be provided to prime through configuration, system property or environment variable)</li>", "originalCommit": "f87df80bc254d010b3252b1eca42c06f4614f779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAwMDA4NQ==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r420000085", "bodyText": "Copy/pasted, wrong original, fixing both.", "author": "tomas-langer", "createdAt": "2020-05-05T10:09:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk5NTIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNDQ2Mw==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r420014463", "bodyText": "Not a noop any more", "author": "danielkec", "createdAt": "2020-05-05T10:38:21Z", "path": "microprofile/tests/arquillian/src/main/java/io/helidon/microprofile/arquillian/HelidonDeployableContainer.java", "diffHunk": "@@ -108,12 +106,25 @@ public void setup(HelidonContainerConfiguration configuration) {\n \n     @Override\n     public void start() {\n-        dummyServer = Server.builder().build();\n+        try {\n+            if (!CDI.current()\n+                    .getBeanManager()\n+                    .getExtension(ServerCdiExtension.class)\n+                    .started()) {\n+                dummyServer = Server.builder().build();\n+            }\n+        } catch (IllegalStateException e) {\n+            // CDI not running\n+            dummyServer = Server.builder().build();\n+        }\n     }\n \n     @Override\n     public void stop() {\n         // No-op\n+        if (null != dummyServer) {\n+            dummyServer.stop();\n+        }\n     }", "originalCommit": "f87df80bc254d010b3252b1eca42c06f4614f779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNjI2Ng==", "url": "https://github.com/oracle/helidon/pull/1721#discussion_r420036266", "bodyText": "Fixed (and a few other code fixes in this class).", "author": "tomas-langer", "createdAt": "2020-05-05T11:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAxNDQ2Mw=="}], "type": "inlineReview"}, {"oid": "7441303f2ece5ba42dc51b269244710159838e65", "url": "https://github.com/oracle/helidon/commit/7441303f2ece5ba42dc51b269244710159838e65", "message": "Review fixes #2.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-05T11:23:22Z", "type": "commit"}, {"oid": "407a005b8d7020c69c535117d27228dfad620b4a", "url": "https://github.com/oracle/helidon/commit/407a005b8d7020c69c535117d27228dfad620b4a", "message": "Reverted accidental change.", "committedDate": "2020-05-05T19:44:00Z", "type": "commit"}]}