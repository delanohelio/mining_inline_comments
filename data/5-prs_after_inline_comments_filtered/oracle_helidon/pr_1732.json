{"pr_number": 1732, "pr_title": "OutputStreamPublisher now handles close on its own.", "pr_createdAt": "2020-05-06T09:57:10Z", "pr_url": "https://github.com/oracle/helidon/pull/1732", "timeline": [{"oid": "b65cbce6ebf6d45ff1acd6f64356cfbe0ce08540", "url": "https://github.com/oracle/helidon/commit/b65cbce6ebf6d45ff1acd6f64356cfbe0ce08540", "message": "OutputStreamPublisher now handles close on its own.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-06T09:53:04Z", "type": "commit"}, {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add", "url": "https://github.com/oracle/helidon/commit/86e1aec7056d3fcbd928056c2a40838d57d67add", "message": "Tests to make sure close does not hang on cancel and error.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>", "committedDate": "2020-05-06T17:11:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ==", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421258661", "bodyText": "Lock doesn't help to prevent rule \u00a71.7 violation, we can remove synchronization logic from publisher and wrap subscriber in io.helidon.common.reactive.SequentialSubscriber", "author": "danielkec", "createdAt": "2020-05-07T06:03:50Z", "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "originalCommit": "86e1aec7056d3fcbd928056c2a40838d57d67add", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1OTAxOA==", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421259018", "bodyText": "Not a blocker for this PR, just noticing", "author": "danielkec", "createdAt": "2020-05-07T06:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NDAyOA==", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421264028", "bodyText": "1.7 violation can be seen to not be reachable in this instance.", "author": "olotenko", "createdAt": "2020-05-07T06:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzAzNQ==", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421267035", "bodyText": "I'm thinking about not very probable use-case of request(-1) vs. exception in publish method", "author": "danielkec", "createdAt": "2020-05-07T06:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MDIxNA==", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421270214", "bodyText": "You can see subscriber.close ensures completion signals will be signalled once and only once, as long as they always go through complete which calls subscriber.close.", "author": "olotenko", "createdAt": "2020-05-07T06:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMwNTI2NQ==", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421305265", "bodyText": "Missed that, thanks for clarification", "author": "danielkec", "createdAt": "2020-05-07T07:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NzcxMA==", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421377710", "bodyText": "Pro tip: when designing routines with CPS, ensure a continuation is invoked always. (Not necessarily the same continuation for all outcomes, not necessarily immediately, but you've got to design routines with a guarantee that the continuation is invoked always) You want to not call any continuation only in very rare circumstances.\nThe problem with the current design of SingleSubscriberHolder is that it can omit calling the continuation, and the caller is not told that that is the case. It is the same behaviour as non-termination. The outcome is that signalCloseComplete is not guaranteed to be reachable, and the completionResult.get can wait indefinitely. The (rather long) timeout then only eventually reclaims the thread.", "author": "olotenko", "createdAt": "2020-05-07T09:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}], "type": "inlineReview"}]}