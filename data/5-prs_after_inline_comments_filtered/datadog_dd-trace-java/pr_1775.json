{"pr_number": 1775, "pr_title": "Replace disruptor with MpscCompoundQueue", "pr_createdAt": "2020-08-14T20:32:00Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1775", "timeline": [{"oid": "c563b6897e35d6348d1b189bc4e27923a83ed9ce", "url": "https://github.com/DataDog/dd-trace-java/commit/c563b6897e35d6348d1b189bc4e27923a83ed9ce", "message": "don't refer to queue implementation in the TraceProcessing pipeline's interface", "committedDate": "2020-08-14T10:51:49Z", "type": "commit"}, {"oid": "52073b0fa4243eec9f967549a7edb567211d7e11", "url": "https://github.com/DataDog/dd-trace-java/commit/52073b0fa4243eec9f967549a7edb567211d7e11", "message": "replace disruptor with JCTools MpscCompoundQueue", "committedDate": "2020-08-14T20:47:49Z", "type": "forcePushed"}, {"oid": "5b71e52786c042b2486ce0b2552f57da78705e03", "url": "https://github.com/DataDog/dd-trace-java/commit/5b71e52786c042b2486ce0b2552f57da78705e03", "message": "revapi", "committedDate": "2020-08-14T20:52:05Z", "type": "forcePushed"}, {"oid": "6de1c4eb07e55924e0d8bec7233421041da80432", "url": "https://github.com/DataDog/dd-trace-java/commit/6de1c4eb07e55924e0d8bec7233421041da80432", "message": "revapi", "committedDate": "2020-08-14T21:05:49Z", "type": "forcePushed"}, {"oid": "d12104c8aba98d227a02d54ac94ca3c5f4cdb443", "url": "https://github.com/DataDog/dd-trace-java/commit/d12104c8aba98d227a02d54ac94ca3c5f4cdb443", "message": "remove rather strange assertion", "committedDate": "2020-08-14T21:19:37Z", "type": "forcePushed"}, {"oid": "f9d087a8ecef8810fb2f80b09d6343aff79d875c", "url": "https://github.com/DataDog/dd-trace-java/commit/f9d087a8ecef8810fb2f80b09d6343aff79d875c", "message": "replace disruptor with JCTools MpscCompoundQueue", "committedDate": "2020-08-14T21:39:42Z", "type": "commit"}, {"oid": "13efa90988acf48f91a21af789a4321ce9733791", "url": "https://github.com/DataDog/dd-trace-java/commit/13efa90988acf48f91a21af789a4321ce9733791", "message": "revapi", "committedDate": "2020-08-14T21:39:42Z", "type": "commit"}, {"oid": "eab4d9342a2b9b06bdb387fd6922ad560c8b7bdd", "url": "https://github.com/DataDog/dd-trace-java/commit/eab4d9342a2b9b06bdb387fd6922ad560c8b7bdd", "message": "remove rather strange assertion", "committedDate": "2020-08-14T21:39:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1NTQ2OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470855469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * traces are published in batches to the Datadog Agent}.\n          \n          \n            \n             * traces are published in batches to the Datadog Agent.", "author": "tylerbenson", "createdAt": "2020-08-14T20:41:08Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.", "originalCommit": "0eaa82613a6bfd4b2a1697ca9e57c7b3cf3127e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1Njc2Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470856762", "bodyText": "If you don't restrict publishing to just heartbeats, then it doesn't matter if this is successfully added to the queue.", "author": "tylerbenson", "createdAt": "2020-08-14T20:44:52Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    this.primaryQueue =\n+        new MpscCompoundQueue<>(Math.max(capacity, 8), Runtime.getRuntime().availableProcessors());\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);", "originalCommit": "0eaa82613a6bfd4b2a1697ca9e57c7b3cf3127e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5MzkzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470993937", "bodyText": "This avoids computing a timestamp once per message in the consumer thread.", "author": "richardstartin", "createdAt": "2020-08-15T14:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1Njc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1OTExMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470859112", "bodyText": "If you remove this, then it doesn't matter if heartbeats are successfully added to the queue.", "author": "tylerbenson", "createdAt": "2020-08-14T20:51:06Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    this.primaryQueue =\n+        new MpscCompoundQueue<>(Math.max(capacity, 8), Runtime.getRuntime().availableProcessors());\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);\n+  }\n+\n+  public int getCapacity() {\n+    return primaryQueue.capacity();\n+  }\n+\n+  public long getRemainingCapacity() {\n+    return primaryQueue.capacity() - primaryQueue.size();\n+  }\n+\n+  public static class TraceSerializingHandler\n+      implements Runnable, MessagePassingQueue.Consumer<Object> {\n+\n+    private final MpscCompoundQueue<Object> primaryQueue;\n+    private final TraceProcessor processor;\n+    private final Monitor monitor;\n+    private final long flushIntervalMillis;\n+    private final boolean doTimeFlush;\n+    private final PayloadDispatcher payloadDispatcher;\n+    private long nextFlushMillis;\n+\n+    public TraceSerializingHandler(\n+        final MpscCompoundQueue<Object> primaryQueue,\n+        final Monitor monitor,\n+        final TraceProcessor traceProcessor,\n+        final long flushInterval,\n+        final TimeUnit timeUnit,\n+        final PayloadDispatcher payloadDispatcher) {\n+      this.primaryQueue = primaryQueue;\n+      this.monitor = monitor;\n+      this.processor = traceProcessor;\n+      this.doTimeFlush = flushInterval > 0;\n+      this.payloadDispatcher = payloadDispatcher;\n+      if (doTimeFlush) {\n+        this.flushIntervalMillis = timeUnit.toMillis(flushInterval);\n+        scheduleNextTimeFlush();\n+      } else {\n+        this.flushIntervalMillis = Long.MAX_VALUE;\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void accept(Object event) {\n+      // publish an incomplete batch if\n+      // 1. we get a heartbeat, and it's time to send (early heartbeats will be ignored)\n+      // 2. a synchronous flush command is received (at shutdown)\n+      try {\n+        if (event instanceof List) {\n+          List<DDSpan> trace = (List<DDSpan>) event;\n+          if (trace.isEmpty()) { // a heartbeat", "originalCommit": "52073b0fa4243eec9f967549a7edb567211d7e11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5MzkxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470993910", "bodyText": "There's more than one factor to consider here. If we don't do this, we take a timestamp for each message, just to check if it's been roughly one second since we last flushed. Timestamps aren't free: expect 25ns per call, and, depending on the deployment, can cost even 10x more. It's worth considering if forcing heartbeats into the queue could starve traces, but that could only happen if it took more than one second to process each trace.", "author": "richardstartin", "createdAt": "2020-08-15T14:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1OTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ4Mjk4Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r471482982", "bodyText": "Ok, I understand now why you made that call.  If you think this is the right tradeoff to make, I support your decision.  To me it seems pretty inconsequential given all the other processing we're doing on this thread, but I guess it adds up.", "author": "tylerbenson", "createdAt": "2020-08-17T13:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1OTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDQ0MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470860441", "bodyText": "Any risk of an object that isn't these two types being added to the queue?\nIf so it looks like it'll just be ignored, so I guess it doesn't matter.", "author": "tylerbenson", "createdAt": "2020-08-14T20:54:33Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MessagePassingQueue;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    this.primaryQueue =\n+        new MpscCompoundQueue<>(Math.max(capacity, 8), Runtime.getRuntime().availableProcessors());\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);\n+  }\n+\n+  public int getCapacity() {\n+    return primaryQueue.capacity();\n+  }\n+\n+  public long getRemainingCapacity() {\n+    return primaryQueue.capacity() - primaryQueue.size();\n+  }\n+\n+  public static class TraceSerializingHandler\n+      implements Runnable, MessagePassingQueue.Consumer<Object> {\n+\n+    private final MpscCompoundQueue<Object> primaryQueue;\n+    private final TraceProcessor processor;\n+    private final Monitor monitor;\n+    private final long flushIntervalMillis;\n+    private final boolean doTimeFlush;\n+    private final PayloadDispatcher payloadDispatcher;\n+    private long nextFlushMillis;\n+\n+    public TraceSerializingHandler(\n+        final MpscCompoundQueue<Object> primaryQueue,\n+        final Monitor monitor,\n+        final TraceProcessor traceProcessor,\n+        final long flushInterval,\n+        final TimeUnit timeUnit,\n+        final PayloadDispatcher payloadDispatcher) {\n+      this.primaryQueue = primaryQueue;\n+      this.monitor = monitor;\n+      this.processor = traceProcessor;\n+      this.doTimeFlush = flushInterval > 0;\n+      this.payloadDispatcher = payloadDispatcher;\n+      if (doTimeFlush) {\n+        this.flushIntervalMillis = timeUnit.toMillis(flushInterval);\n+        scheduleNextTimeFlush();\n+      } else {\n+        this.flushIntervalMillis = Long.MAX_VALUE;\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void accept(Object event) {\n+      // publish an incomplete batch if\n+      // 1. we get a heartbeat, and it's time to send (early heartbeats will be ignored)\n+      // 2. a synchronous flush command is received (at shutdown)\n+      try {\n+        if (event instanceof List) {\n+          List<DDSpan> trace = (List<DDSpan>) event;\n+          if (trace.isEmpty()) { // a heartbeat\n+            if (doTimeFlush && millisecondTime() > nextFlushMillis) {\n+              payloadDispatcher.flush();\n+              scheduleNextTimeFlush();\n+            }\n+          } else {\n+            // TODO populate `_sample_rate` metric in a way that accounts for lost/dropped traces\n+            payloadDispatcher.addTrace(processor.onTraceComplete(trace));\n+          }\n+        } else if (event instanceof FlushEvent) {\n+          payloadDispatcher.flush();\n+          ((FlushEvent) event).sync();\n+        }", "originalCommit": "5b71e52786c042b2486ce0b2552f57da78705e03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5MzI5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r470993293", "bodyText": "In a perfect world Java would have sum types and we'd be able to use types like List<DDSpan> | FlushEvent without materialising a wrapper, but we can't, and I don't want to allocate a wrapper per trace. I think it's important that this is properly encapsulated, that we don't let arbitrary types to published into the queue from outside of TraceProcessingWorker.", "author": "richardstartin", "createdAt": "2020-08-15T13:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2MDQ0MQ=="}], "type": "inlineReview"}, {"oid": "c1f6eeb1242b36e09ab93086c76da4c85b635681", "url": "https://github.com/DataDog/dd-trace-java/commit/c1f6eeb1242b36e09ab93086c76da4c85b635681", "message": "remove rather strange assertion", "committedDate": "2020-08-14T21:44:39Z", "type": "commit"}, {"oid": "c1f6eeb1242b36e09ab93086c76da4c85b635681", "url": "https://github.com/DataDog/dd-trace-java/commit/c1f6eeb1242b36e09ab93086c76da4c85b635681", "message": "remove rather strange assertion", "committedDate": "2020-08-14T21:44:39Z", "type": "forcePushed"}, {"oid": "19cd528c20b9ed905ac9af72206863206e4dd083", "url": "https://github.com/DataDog/dd-trace-java/commit/19cd528c20b9ed905ac9af72206863206e4dd083", "message": "better consumer backoff", "committedDate": "2020-08-15T14:08:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0Nzk0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r471447949", "bodyText": "So System.nanoTime() is a relative time, and the value can be negative (there is no guarantee that the value starts at 0). How does NANOSECONDS.toMillis deal with that? Also, the comparison needs to be done relative to a start time since the counter could potentially wrap in the middle of an interval.", "author": "bantonsson", "createdAt": "2020-08-17T12:35:46Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingWorker.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.util.ThreadUtil.onSpinWait;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import datadog.common.exec.CommonTaskExecutor;\n+import datadog.common.exec.DaemonThreadFactory;\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.monitor.Monitor;\n+import datadog.trace.core.processor.TraceProcessor;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.LockSupport;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jctools.queues.MpscCompoundQueue;\n+\n+/**\n+ * Worker which applies rules to traces and serializes the results. Upon completion, the serialized\n+ * traces are published in batches to the Datadog Agent}.\n+ *\n+ * <p>publishing to the buffer will not block the calling thread, but instead will return false if\n+ * the buffer is full. This is to avoid impacting an application thread.\n+ */\n+@Slf4j\n+public class TraceProcessingWorker implements AutoCloseable {\n+\n+  // empty list used to signal heartbeat, which means we could spuriously flush\n+  // if an empty list were published upstream, but care is taken in PendingTrace\n+  // and CoreTracer not to do this.\n+  private static final List<List<DDSpan>> HEARTBEAT = new ArrayList<>(0);\n+\n+  private final MpscCompoundQueue<Object> primaryQueue;\n+  private final TraceSerializingHandler serializingHandler;\n+  private final Thread serializerThread;\n+  private final boolean doHeartbeat;\n+\n+  private volatile ScheduledFuture<?> heartbeat;\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this(capacity, monitor, dispatcher, new TraceProcessor(), flushInterval, timeUnit, heartbeat);\n+  }\n+\n+  public TraceProcessingWorker(\n+      final int capacity,\n+      final Monitor monitor,\n+      final PayloadDispatcher dispatcher,\n+      final TraceProcessor processor,\n+      final long flushInterval,\n+      final TimeUnit timeUnit,\n+      final boolean heartbeat) {\n+    this.doHeartbeat = heartbeat;\n+    int parallelism = Runtime.getRuntime().availableProcessors();\n+    this.primaryQueue = new MpscCompoundQueue<>(Math.max(capacity, parallelism), parallelism);\n+    this.serializingHandler =\n+        new TraceSerializingHandler(\n+            primaryQueue, monitor, processor, flushInterval, timeUnit, dispatcher);\n+    this.serializerThread = DaemonThreadFactory.TRACE_PROCESSOR.newThread(serializingHandler);\n+  }\n+\n+  public void start() {\n+    if (doHeartbeat) {\n+      // This provides a steady stream of events to enable flushing with a low throughput.\n+      heartbeat =\n+          CommonTaskExecutor.INSTANCE.scheduleAtFixedRate(\n+              new HeartbeatTask(), this, 1000, 1000, MILLISECONDS, \"disruptor heartbeat\");\n+    }\n+    this.serializerThread.start();\n+  }\n+\n+  public boolean flush(long timeout, TimeUnit timeUnit) {\n+    CountDownLatch latch = new CountDownLatch(1);\n+    FlushEvent flush = new FlushEvent(latch);\n+    boolean offered;\n+    do {\n+      offered = primaryQueue.offer(flush);\n+    } while (!offered);\n+    try {\n+      return latch.await(timeout, timeUnit);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      return false;\n+    }\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (null != heartbeat) {\n+      heartbeat.cancel(true);\n+    }\n+    serializerThread.interrupt();\n+  }\n+\n+  public boolean publish(final List<DDSpan> data) {\n+    return primaryQueue.offer(data);\n+  }\n+\n+  void heartbeat() {\n+    // if we don't insist on publishing a heartbeat, they might get starved out\n+    // if traces are very small, it might take quite a long time to fill the buffer,\n+    // without regular heartbeats\n+    boolean success;\n+    do {\n+      success = primaryQueue.offer(HEARTBEAT);\n+    } while (!success);\n+  }\n+\n+  public int getCapacity() {\n+    return primaryQueue.capacity();\n+  }\n+\n+  public long getRemainingCapacity() {\n+    return primaryQueue.capacity() - primaryQueue.size();\n+  }\n+\n+  public static class TraceSerializingHandler implements Runnable {\n+\n+    private final MpscCompoundQueue<Object> primaryQueue;\n+    private final TraceProcessor processor;\n+    private final Monitor monitor;\n+    private final long flushIntervalMillis;\n+    private final boolean doTimeFlush;\n+    private final PayloadDispatcher payloadDispatcher;\n+    private long nextFlushMillis;\n+\n+    public TraceSerializingHandler(\n+        final MpscCompoundQueue<Object> primaryQueue,\n+        final Monitor monitor,\n+        final TraceProcessor traceProcessor,\n+        final long flushInterval,\n+        final TimeUnit timeUnit,\n+        final PayloadDispatcher payloadDispatcher) {\n+      this.primaryQueue = primaryQueue;\n+      this.monitor = monitor;\n+      this.processor = traceProcessor;\n+      this.doTimeFlush = flushInterval > 0;\n+      this.payloadDispatcher = payloadDispatcher;\n+      if (doTimeFlush) {\n+        this.flushIntervalMillis = timeUnit.toMillis(flushInterval);\n+        scheduleNextTimeFlush();\n+      } else {\n+        this.flushIntervalMillis = Long.MAX_VALUE;\n+      }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void onEvent(Object event) {\n+      // publish an incomplete batch if\n+      // 1. we get a heartbeat, and it's time to send (early heartbeats will be ignored)\n+      // 2. a synchronous flush command is received (at shutdown)\n+      try {\n+        if (event instanceof List) {\n+          List<DDSpan> trace = (List<DDSpan>) event;\n+          if (trace.isEmpty()) { // a heartbeat\n+            if (doTimeFlush && millisecondTime() > nextFlushMillis) {\n+              payloadDispatcher.flush();\n+              scheduleNextTimeFlush();\n+            }\n+          } else {\n+            // TODO populate `_sample_rate` metric in a way that accounts for lost/dropped traces\n+            payloadDispatcher.addTrace(processor.onTraceComplete(trace));\n+          }\n+        } else if (event instanceof FlushEvent) {\n+          payloadDispatcher.flush();\n+          ((FlushEvent) event).sync();\n+        }\n+      } catch (final Throwable e) {\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"Error while serializing trace\", e);\n+        }\n+        List<DDSpan> data = event instanceof List ? (List<DDSpan>) event : null;\n+        monitor.onFailedSerialize(data, e);\n+      }\n+    }\n+\n+    private void scheduleNextTimeFlush() {\n+      if (doTimeFlush) {\n+        nextFlushMillis = millisecondTime() + flushIntervalMillis;\n+      }\n+    }\n+\n+    private long millisecondTime() {\n+      // important: nanoTime is monotonic, currentTimeMillis is not\n+      return NANOSECONDS.toMillis(System.nanoTime());", "originalCommit": "19cd528c20b9ed905ac9af72206863206e4dd083", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ3MDg5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1775#discussion_r471470897", "bodyText": "This is old code but please take a look at the latest commit and let me know if it addresses your concerns", "author": "richardstartin", "createdAt": "2020-08-17T13:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0Nzk0OQ=="}], "type": "inlineReview"}, {"oid": "bb6ad0fa858f0f0d5827a5042c1b12b341152199", "url": "https://github.com/DataDog/dd-trace-java/commit/bb6ad0fa858f0f0d5827a5042c1b12b341152199", "message": "more resilient time-triggered flushes", "committedDate": "2020-08-17T13:15:55Z", "type": "commit"}, {"oid": "655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "url": "https://github.com/DataDog/dd-trace-java/commit/655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "message": "make sure non-root traces are published", "committedDate": "2020-08-17T14:43:27Z", "type": "commit"}, {"oid": "655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "url": "https://github.com/DataDog/dd-trace-java/commit/655a3a5e539e34bfa32c115ac2e7f56d91d8a4b0", "message": "make sure non-root traces are published", "committedDate": "2020-08-17T14:43:27Z", "type": "forcePushed"}]}