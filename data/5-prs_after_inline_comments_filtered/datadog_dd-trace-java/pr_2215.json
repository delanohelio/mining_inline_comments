{"pr_number": 2215, "pr_title": "Single-interface Field-injection", "pr_createdAt": "2020-12-16T22:44:46Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2215", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544682969", "bodyText": "tableswitches are generally not faster than array accesses unless the targets are very predictable.", "author": "richardstartin", "createdAt": "2020-12-16T22:55:45Z", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a small number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 8;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+\n+  // fall-back to slightly slower lookup for any additional stores", "originalCommit": "70d4ec89a726b083c75a72a2499ab175ff5754ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4NDQ1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544684456", "bodyText": "tableswitch is only used for initial allocation, and in this case the targets are predictable - actual lookup at runtime from the advice is done directly as field lookup for the fast-path, with array for the slow path:\nhttps://github.com/DataDog/dd-trace-java/pull/2215/files#diff-47bea262caab8af75c9bf136265015eed9352d1f2d3349eb859abe07a6550a09R137", "author": "mcculls", "createdAt": "2020-12-16T22:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4OTE5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544689198", "bodyText": "ok makes sense.", "author": "richardstartin", "createdAt": "2020-12-16T23:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMDk0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544700946", "bodyText": "As I understand it, the first 8 context stores will do static final field accesses which will allow for constant folding and make this basically free, and the others will call this method with a constant parameter which will index into the array\nFieldBackedContextStore store = getContextStore(N);\nbut because the array and its contents can't be trusted not to change, the access won't be completely optimised away, and there will be a small difference in access time. So I would be tempted to create a lot more of these, maybe 32 or even 64 of them, since it's a fixed cost. What do you think?", "author": "richardstartin", "createdAt": "2020-12-16T23:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwMTI4Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544701287", "bodyText": "Do you think it would be possible to generate the class with the right number of static fields once the number of context stores is known, so only the fast path exists?", "author": "richardstartin", "createdAt": "2020-12-16T23:37:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0ODI1MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544948250", "bodyText": "Yes, eventually I'd like to have a build plugin scan for uses of InstrumentationContext.get and generate the table class. It could even rewrite the advice at build time to replace InstrumentationContext.get  with field access which would avoid having to do the transformation at runtime.", "author": "mcculls", "createdAt": "2020-12-17T09:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4Mjk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxMTg0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544711842", "bodyText": "An important improvement here is that the instanceof check will only be done once, because it's here rather than having been generated in the accessors, this also makes implementing new methods such as getAndSet much easier to do.", "author": "richardstartin", "createdAt": "2020-12-17T00:04:33Z", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStore.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package datadog.trace.bootstrap;\n+\n+/**\n+ * {@link ContextStore} that attempts to store context in its keys by using bytecode-injected\n+ * fields. Delegates to a lazy {@link WeakMap} for keys that don't have a field for this store.\n+ */\n+public final class FieldBackedContextStore implements ContextStore<Object, Object> {\n+  final int storeId;\n+\n+  FieldBackedContextStore(final int storeId) {\n+    this.storeId = storeId;\n+  }\n+\n+  @Override\n+  public Object get(final Object key) {\n+    if (key instanceof FieldBackedContextAccessor) {\n+      return ((FieldBackedContextAccessor) key).get$__datadogContext$(storeId);\n+    } else {\n+      return weakStore().get(key);\n+    }\n+  }\n+\n+  @Override\n+  public void put(final Object key, final Object context) {\n+    if (key instanceof FieldBackedContextAccessor) {\n+      ((FieldBackedContextAccessor) key).put$__datadogContext$(storeId, context);\n+    } else {\n+      weakStore().put(key, context);\n+    }\n+  }\n+\n+  @Override\n+  public Object putIfAbsent(final Object key, final Object context) {\n+    if (key instanceof FieldBackedContextAccessor) {", "originalCommit": "70d4ec89a726b083c75a72a2499ab175ff5754ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjkyNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544716924", "bodyText": "If access to the map is concurrent, the BitSet can't be updated safely, unless processing of each type is guaranteed to be on the same thread. There is no JMM support for updating fields narrower than a byte, and this will lead to word tearing, though it would work with a  wrapper around a boolean[] emulating the relevant parts of BitSet's API (with the right memory barriers in place).", "author": "richardstartin", "createdAt": "2020-12-17T00:17:41Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -21,6 +28,20 @@\n   private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n       new ConcurrentHashMap<>();\n \n+  private static final Class<?> FIELD_INJECTED_MARKER =\n+      Config.get().isLegacyContextFieldInjection()\n+          ? FieldBackedContextStoreAppliedMarker.class\n+          : FieldBackedContextAccessor.class;\n+\n+  private static final boolean TRACK_EXCLUDED_CONTEXT_STORES =\n+      !Config.get().isLegacyContextFieldInjection();\n+\n+  // this map will contain entries for any root type that we wanted to field-inject\n+  // but were not able to - either because it was explicitly excluded, or because we\n+  // failed to field-inject as the type was already loaded\n+  private static final ConcurrentHashMap<String, BitSet> EXCLUDED_STORE_IDS_BY_TYPE =", "originalCommit": "70d4ec89a726b083c75a72a2499ab175ff5754ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0NDkzMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544944932", "bodyText": "yes, access can be concurrent - I'll replace this with a concurrent version", "author": "mcculls", "createdAt": "2020-12-17T09:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE2ODI3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555168279", "bodyText": "As mentioned elsewhere it turns out that each BitSet has low contention because they are only updated and read by excluded types and their sub-classes - and only during transform. Adding a simple synchronized block is enough for this use-case: 8c9fd16", "author": "mcculls", "createdAt": "2021-01-11T16:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNjkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544717627", "bodyText": "This seems to be explicitly catering for concurrency (matchedType was missing, but using putIfAbsent in case another thread added it) but the update to the BitSet isn't safe, and updates from competing threads will overwrite each other. See the comment about word tearing.", "author": "richardstartin", "createdAt": "2020-12-17T00:19:36Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -164,4 +194,63 @@ private boolean hasKeyInterface(\n     }\n     return false;\n   }\n+\n+  /**\n+   * Keep track of which stores (per-type) were explicitly excluded or we failed to field-inject.\n+   * This is used to decide when we can't apply certain store optimizations ahead of loading.\n+   */\n+  private static void excludeStoreForType(final String matchedType, final int storeId) {\n+    BitSet excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.get(matchedType);\n+    if (null == excludedStoreIdsForType) {\n+      BitSet tempStoreIds = new BitSet();\n+      tempStoreIds.set(storeId);\n+      excludedStoreIdsForType = EXCLUDED_STORE_IDS_BY_TYPE.putIfAbsent(matchedType, tempStoreIds);\n+    }", "originalCommit": "70d4ec89a726b083c75a72a2499ab175ff5754ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxODI4Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544718283", "bodyText": "In fact, the comment directly below indicates that this is designed to handle concurrent updates.", "author": "richardstartin", "createdAt": "2020-12-17T00:21:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0NTI0MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r544945241", "bodyText": "yes, I'll replace this with a concurrent version", "author": "mcculls", "createdAt": "2020-12-17T09:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTE2ODcyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555168720", "bodyText": "as above, adding a synchronized block is acceptable for this particular use-case: 8c9fd16", "author": "mcculls", "createdAt": "2021-01-11T16:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcxNzYyNw=="}], "type": "inlineReview"}, {"oid": "bbdef9dc683eb545e48f203ce4bb12cc8755de31", "url": "https://github.com/DataDog/dd-trace-java/commit/bbdef9dc683eb545e48f203ce4bb12cc8755de31", "message": "Add tests for the new field-injection strategy", "committedDate": "2020-12-18T18:13:08Z", "type": "forcePushed"}, {"oid": "e920b376199f26d3fce93d81823274822bed1181", "url": "https://github.com/DataDog/dd-trace-java/commit/e920b376199f26d3fce93d81823274822bed1181", "message": "Protect against concurrent updates to bitset\n\nThere's only a small number of excluded types and contention on them is low\nduring matching so the simplest approach is to use a synchronized block.", "committedDate": "2020-12-22T12:35:32Z", "type": "forcePushed"}, {"oid": "fbf0eff3f6750e2d5104713c144e959ccf31cf91", "url": "https://github.com/DataDog/dd-trace-java/commit/fbf0eff3f6750e2d5104713c144e959ccf31cf91", "message": "Tweak field accessor names", "committedDate": "2021-01-06T11:45:26Z", "type": "forcePushed"}, {"oid": "fe34cdbbbf307f3b11e8e8694a7d41977fa87e8c", "url": "https://github.com/DataDog/dd-trace-java/commit/fe34cdbbbf307f3b11e8e8694a7d41977fa87e8c", "message": "Tweak field accessor names", "committedDate": "2021-01-06T13:33:54Z", "type": "forcePushed"}, {"oid": "6ab9bb722fe2c72a5316f6ad98a7fbb6f02250b8", "url": "https://github.com/DataDog/dd-trace-java/commit/6ab9bb722fe2c72a5316f6ad98a7fbb6f02250b8", "message": "Tweak field accessor names", "committedDate": "2021-01-07T16:27:00Z", "type": "forcePushed"}, {"oid": "713c4ac599d3c37db63e49658745092577250845", "url": "https://github.com/DataDog/dd-trace-java/commit/713c4ac599d3c37db63e49658745092577250845", "message": "Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\nThis reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\ninvolving injection of generated helper interfaces cannot happen when using a single common\ninterface for field-injection.", "committedDate": "2021-01-07T22:38:10Z", "type": "forcePushed"}, {"oid": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "url": "https://github.com/DataDog/dd-trace-java/commit/16ad8e8e95a56a75d3521771899e38feca51aeaf", "message": "Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\nThis reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\ninvolving injection of generated helper interfaces cannot happen when using a single common\ninterface for field-injection.", "committedDate": "2021-01-11T12:44:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555242230", "bodyText": "I don't think this is thread safe with concurrent updates since extraStores is volatile, and two threads could get inside the block at the same time, and the second one to expand the array can read the updated length, so quadruple the size. The second updater could also overwrite the result of extraStores[arrayIndex] = store; below. It's probably worth making this synchronized on a private lock.", "author": "richardstartin", "createdAt": "2021-01-11T18:08:18Z", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {\n+      case 0:\n+        return contextStore0;\n+      case 1:\n+        return contextStore1;\n+      case 2:\n+        return contextStore2;\n+      case 3:\n+        return contextStore3;\n+      case 4:\n+        return contextStore4;\n+      case 5:\n+        return contextStore5;\n+      case 6:\n+        return contextStore6;\n+      case 7:\n+        return contextStore7;\n+      case 8:\n+        return contextStore8;\n+      case 9:\n+        return contextStore9;\n+      case 10:\n+        return contextStore10;\n+      case 11:\n+        return contextStore11;\n+      case 12:\n+        return contextStore12;\n+      case 13:\n+        return contextStore13;\n+      case 14:\n+        return contextStore14;\n+      case 15:\n+        return contextStore15;\n+      case 16:\n+        return contextStore16;\n+      case 17:\n+        return contextStore17;\n+      case 18:\n+        return contextStore18;\n+      case 19:\n+        return contextStore19;\n+      case 20:\n+        return contextStore20;\n+      case 21:\n+        return contextStore21;\n+      case 22:\n+        return contextStore22;\n+      case 23:\n+        return contextStore23;\n+      case 24:\n+        return contextStore24;\n+      case 25:\n+        return contextStore25;\n+      case 26:\n+        return contextStore26;\n+      case 27:\n+        return contextStore27;\n+      case 28:\n+        return contextStore28;\n+      case 29:\n+        return contextStore29;\n+      case 30:\n+        return contextStore30;\n+      case 31:\n+        return contextStore31;\n+      default:\n+        return extraStores[storeId - FAST_STORE_ID_LIMIT];\n+    }\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }\n+    return existingStore.storeId;\n+  }\n+\n+  private static String storeName(final String keyClassName, final String contextClassName) {\n+    return keyClassName + ';' + contextClassName;\n+  }\n+\n+  private static FieldBackedContextStore createStore(final int storeId) {\n+    if (storeId < FAST_STORE_ID_LIMIT) {\n+      return getContextStore(storeId);\n+    }\n+    final int arrayIndex = storeId - FAST_STORE_ID_LIMIT;\n+    if (extraStores.length <= arrayIndex) {\n+      extraStores = Arrays.copyOf(extraStores, extraStores.length << 1);\n+    }", "originalCommit": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0Nzk2NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555247964", "bodyText": "this method is only called inside a synchronized block on STORES_BY_NAME", "author": "mcculls", "createdAt": "2021-01-11T18:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MDQ2NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555260464", "bodyText": "This needs a comment for maintainability", "author": "richardstartin", "createdAt": "2021-01-11T18:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMDM2OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559510369", "bodyText": "done as part of 4de2aa4", "author": "mcculls", "createdAt": "2021-01-18T11:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0MjIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NDMwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555244307", "bodyText": "Since this method is used for looking up the weak stores (is this a correct reading?), I would suggest removing the large switch statement and putting the 32 stores into the extraStores  array  and replace this with an array lookup to reduce the bytecode weight of the method when the fallback is required. It also just simplifies the code.", "author": "richardstartin", "createdAt": "2021-01-11T18:12:07Z", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // fall-back to slightly slower lookup for any additional stores\n+  private static volatile FieldBackedContextStore[] extraStores = new FieldBackedContextStore[8];\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    switch (storeId) {", "originalCommit": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwOTU3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559509579", "bodyText": "4de2aa4", "author": "mcculls", "createdAt": "2021-01-18T11:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjA0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555246042", "bodyText": "Can you add a comment that making it clear that this class should be instantiated lazily (it is lazily instantiated in FieldBackedContextStore) because it triggers background cleanup work?", "author": "richardstartin", "createdAt": "2021-01-11T18:15:08Z", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/WeakMapContextStore.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package datadog.trace.bootstrap;\n+\n+final class WeakMapContextStore implements ContextStore<Object, Object> {\n+  private static final int MAX_SIZE = 50_000;\n+\n+  private final WeakMap<Object, Object> map = WeakMap.Provider.newWeakMap();", "originalCommit": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUwOTc3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559509775", "bodyText": "98ec83f", "author": "mcculls", "createdAt": "2021-01-18T11:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI0NjA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MTI5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555261296", "bodyText": "I'm wary of trusting that equality will have been implemented properly for ElementMatcher", "author": "richardstartin", "createdAt": "2021-01-11T18:42:21Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextProvider.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.safeHasSuperType;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.unpackContextStore;\n+import static datadog.trace.agent.tooling.context.ContextStoreUtils.wrapVisitor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.agent.tooling.Instrumenter.Default;\n+import datadog.trace.api.Config;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+/**\n+ * InstrumentationContextProvider which stores context in a field that is injected into a class and\n+ * falls back to tracking the context association in a global weak-map if the field wasn't injected.\n+ *\n+ * <p>This is accomplished by\n+ *\n+ * <ol>\n+ *   <li>Rewriting calls to {@link InstrumentationContext} to access stores based on numeric ids\n+ *   <li>Injecting fields in the earliest holder class that matches the context key\n+ *   <li>Injecting a getter and setter that retrieves context stored in the injected fields\n+ *   <li>Delegating to the superclass getter and setter if a superclass is also a context holder\n+ *   <li>Delegating to weak-map if neither this class or superclass have a field for the context\n+ * </ol>\n+ */\n+@Slf4j\n+public final class FieldBackedContextProvider implements InstrumentationContextProvider {\n+\n+  /*\n+   * Mapping from the instrumentations contextClassLoaderMatcher to a set of pairs (context holder, context class)\n+   * for which we have matchers installed. We use this to make sure we do not install matchers repeatedly for cases\n+   * when same context class is used by multiple instrumentations.\n+   */\n+  private static final HashMap<ElementMatcher<ClassLoader>, Set<Map.Entry<String, String>>>", "originalCommit": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI4NDA5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555284095", "bodyText": "this comes from the original code: https://github.com/DataDog/dd-trace-java/blob/master/dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java#L45 - that's not to say this doesn't warrant further investigation, just that if there is an issue then it affects both old and new approaches", "author": "mcculls", "createdAt": "2021-01-11T19:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MTI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDE1MDYxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r560150619", "bodyText": "I agree, leave it in place. But this assumes unequal matchers don't match the same classes, which isn't true, and wouldn't be a good strategy even if equals and hashCode were always implemented properly, since two unequal matchers can match the same classes - e.g.\nnamedOneOf(\"foo.bar.ClassLoader\", \"bar.foo.ClassLoader\")\nand\nnamed(\"foo.bar.ClassLoader\").or(named(\"bar.foo.ClassLoader\"))\nmatch the same types but are unequal objects. So this isn't just a case of implementing equals and hashCode.", "author": "richardstartin", "createdAt": "2021-01-19T12:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI2MTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTIwMTYzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555201637", "bodyText": "interesting... \ud83d\udc4d", "author": "tylerbenson", "createdAt": "2021-01-11T17:04:18Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/AgentInstaller.java", "diffHunk": "@@ -72,11 +74,16 @@ public static ResettableClassFileTransformer installBytebuddyAgent(\n \n     addByteBuddyRawSetting();\n \n-    FieldBackedProvider.resetContextMatchers();\n+    if (Config.get().isLegacyContextFieldInjection()) {\n+      FieldBackedProvider.resetContextMatchers();\n+    } else {\n+      FieldBackedContextProvider.resetContextMatchers();\n+    }\n \n     AgentBuilder.Ignored ignoredAgentBuilder =\n         new AgentBuilder.Default()\n             .disableClassFormatChanges()\n+            .assureReadEdgeTo(INSTRUMENTATION, FieldBackedContextAccessor.class)", "originalCommit": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMjM0Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555332343", "bodyText": "Please add a class comment explaining what this does.", "author": "tylerbenson", "createdAt": "2021-01-11T20:56:47Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextRequestRewriter.java", "diffHunk": "@@ -0,0 +1,167 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStore;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import java.util.Map;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextRequestRewriter implements AsmVisitorWrapper {", "originalCommit": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMDg3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559510876", "bodyText": "9584661", "author": "mcculls", "createdAt": "2021-01-18T11:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzMjM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzODA0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r555338042", "bodyText": "Class doc please.", "author": "tylerbenson", "createdAt": "2021-01-11T21:03:49Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedContextInjector.java", "diffHunk": "@@ -0,0 +1,505 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import static datadog.trace.agent.tooling.context.ShouldInjectFieldsMatcher.hasInjectedField;\n+import static datadog.trace.bootstrap.FieldBackedContextStores.getContextStoreId;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.FieldBackedContextAccessor;\n+import datadog.trace.bootstrap.FieldBackedContextStores;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.ClassFileVersion;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.FieldVisitor;\n+import net.bytebuddy.jar.asm.Label;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+@Slf4j\n+final class FieldBackedContextInjector implements AsmVisitorWrapper {", "originalCommit": "16ad8e8e95a56a75d3521771899e38feca51aeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxMDk0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r559510942", "bodyText": "9584661", "author": "mcculls", "createdAt": "2021-01-18T11:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMzODA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMjYxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2215#discussion_r560412615", "bodyText": "An example of code that wouldn't need to exist if we dropped java 7.", "author": "tylerbenson", "createdAt": "2021-01-19T19:00:22Z", "path": "dd-java-agent/agent-bootstrap/src/main/java/datadog/trace/bootstrap/FieldBackedContextStores.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package datadog.trace.bootstrap;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/** Allocates {@link ContextStore} ids and keeps track of allocated stores. */\n+@Slf4j\n+public final class FieldBackedContextStores {\n+\n+  // provide fast lookup for a fixed number of stores\n+  public static final int FAST_STORE_ID_LIMIT = 32;\n+\n+  // these fields will be accessed directly from field-injected instrumentation\n+  public static final FieldBackedContextStore contextStore0 = new FieldBackedContextStore(0);\n+  public static final FieldBackedContextStore contextStore1 = new FieldBackedContextStore(1);\n+  public static final FieldBackedContextStore contextStore2 = new FieldBackedContextStore(2);\n+  public static final FieldBackedContextStore contextStore3 = new FieldBackedContextStore(3);\n+  public static final FieldBackedContextStore contextStore4 = new FieldBackedContextStore(4);\n+  public static final FieldBackedContextStore contextStore5 = new FieldBackedContextStore(5);\n+  public static final FieldBackedContextStore contextStore6 = new FieldBackedContextStore(6);\n+  public static final FieldBackedContextStore contextStore7 = new FieldBackedContextStore(7);\n+  public static final FieldBackedContextStore contextStore8 = new FieldBackedContextStore(8);\n+  public static final FieldBackedContextStore contextStore9 = new FieldBackedContextStore(9);\n+  public static final FieldBackedContextStore contextStore10 = new FieldBackedContextStore(10);\n+  public static final FieldBackedContextStore contextStore11 = new FieldBackedContextStore(11);\n+  public static final FieldBackedContextStore contextStore12 = new FieldBackedContextStore(12);\n+  public static final FieldBackedContextStore contextStore13 = new FieldBackedContextStore(13);\n+  public static final FieldBackedContextStore contextStore14 = new FieldBackedContextStore(14);\n+  public static final FieldBackedContextStore contextStore15 = new FieldBackedContextStore(15);\n+  public static final FieldBackedContextStore contextStore16 = new FieldBackedContextStore(16);\n+  public static final FieldBackedContextStore contextStore17 = new FieldBackedContextStore(17);\n+  public static final FieldBackedContextStore contextStore18 = new FieldBackedContextStore(18);\n+  public static final FieldBackedContextStore contextStore19 = new FieldBackedContextStore(19);\n+  public static final FieldBackedContextStore contextStore20 = new FieldBackedContextStore(20);\n+  public static final FieldBackedContextStore contextStore21 = new FieldBackedContextStore(21);\n+  public static final FieldBackedContextStore contextStore22 = new FieldBackedContextStore(22);\n+  public static final FieldBackedContextStore contextStore23 = new FieldBackedContextStore(23);\n+  public static final FieldBackedContextStore contextStore24 = new FieldBackedContextStore(24);\n+  public static final FieldBackedContextStore contextStore25 = new FieldBackedContextStore(25);\n+  public static final FieldBackedContextStore contextStore26 = new FieldBackedContextStore(26);\n+  public static final FieldBackedContextStore contextStore27 = new FieldBackedContextStore(27);\n+  public static final FieldBackedContextStore contextStore28 = new FieldBackedContextStore(28);\n+  public static final FieldBackedContextStore contextStore29 = new FieldBackedContextStore(29);\n+  public static final FieldBackedContextStore contextStore30 = new FieldBackedContextStore(30);\n+  public static final FieldBackedContextStore contextStore31 = new FieldBackedContextStore(31);\n+\n+  // keep track of all allocated stores so far\n+  private static volatile FieldBackedContextStore[] stores = {\n+    contextStore0,\n+    contextStore1,\n+    contextStore2,\n+    contextStore3,\n+    contextStore4,\n+    contextStore5,\n+    contextStore6,\n+    contextStore7,\n+    contextStore8,\n+    contextStore9,\n+    contextStore10,\n+    contextStore11,\n+    contextStore12,\n+    contextStore13,\n+    contextStore14,\n+    contextStore15,\n+    contextStore16,\n+    contextStore17,\n+    contextStore18,\n+    contextStore19,\n+    contextStore20,\n+    contextStore21,\n+    contextStore22,\n+    contextStore23,\n+    contextStore24,\n+    contextStore25,\n+    contextStore26,\n+    contextStore27,\n+    contextStore28,\n+    contextStore29,\n+    contextStore30,\n+    contextStore31\n+  };\n+\n+  public static FieldBackedContextStore getContextStore(final int storeId) {\n+    return stores[storeId]; // createStore ensures array is big enough for allocated storeIds\n+  }\n+\n+  private static final ConcurrentHashMap<String, FieldBackedContextStore> STORES_BY_NAME =\n+      new ConcurrentHashMap<>();\n+\n+  public static int getContextStoreId(final String keyClassName, final String contextClassName) {\n+    final String storeName = storeName(keyClassName, contextClassName);\n+    FieldBackedContextStore existingStore = STORES_BY_NAME.get(storeName);\n+    if (null == existingStore) {\n+      synchronized (STORES_BY_NAME) {\n+        // speculatively create the next store in the sequence and attempt to map this name to it;\n+        // if another thread has mapped this name then the store will be kept for the next mapping\n+        final int newStoreId = STORES_BY_NAME.size();\n+        existingStore = STORES_BY_NAME.putIfAbsent(storeName, createStore(newStoreId));\n+        if (null == existingStore) {\n+          log.debug(\n+              \"Allocated ContextStore #{} to {} -> {}\", newStoreId, keyClassName, contextClassName);\n+          return newStoreId;\n+        }\n+      }\n+    }", "originalCommit": "9584661c878b9db3fec9341bea97b6e32a1c8ecf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e598c5a5daf128b335b5f6b2b991ffc6b7b502c5", "url": "https://github.com/DataDog/dd-trace-java/commit/e598c5a5daf128b335b5f6b2b991ffc6b7b502c5", "message": "Copy heap settings to new smoke test", "committedDate": "2021-01-19T21:18:27Z", "type": "forcePushed"}, {"oid": "7d3f65364724b1be37e4964b2782ebd20ba8d88e", "url": "https://github.com/DataDog/dd-trace-java/commit/7d3f65364724b1be37e4964b2782ebd20ba8d88e", "message": "* Mark old classes not used in the new field-injection strategy as deprecated\n\n* Support legacy and new field-injection approaches\n\n* ContextStore backed by a WeakMap\n\n* ContextStore backed by field-injected keys\n\n* Optimize store lookup for a small number of ids while still supporting additional ids\n\n* Log which context store # was allocated to which mapping\n\n* Cleanup legacy field-injection related tests and make them forked tests\n\n* Make sure JDK types can read our bootstrap accessor interface\n\n* New field-injection context provider\n\n* New field-injection request rewriter\n\n* Add method to show if a superclass of a given type previously matched or was excluded from field-injection\n\n* New context store field-injector, delegates to weak-map when it or its super class(es) don't have a field for the store.\n\n* Add tests for the new field-injection strategy\n\n* Protect against concurrent updates to bitset\n  There's only a small number of excluded types and contention on them is low\n  during matching so the simplest approach is to use a synchronized block.\n\n* Increase number of prepared field-injection stores and check id allocation\n\n* Tweak field accessor names\n\n* Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\n  This reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\n  involving injection of generated helper interfaces cannot happen when using a single common\n  interface for field-injection.\n\n* Use stores array to track all stores\n\n* Document that WeakMapContextStores should be created lazily", "committedDate": "2021-01-20T14:41:07Z", "type": "forcePushed"}, {"oid": "26eb63158100a554f3b79172ad5f5d264a4f6084", "url": "https://github.com/DataDog/dd-trace-java/commit/26eb63158100a554f3b79172ad5f5d264a4f6084", "message": "Use a single-interface for field-injection:\n\n* Mark old classes not used in the new field-injection strategy as deprecated\n\n* Support legacy and new field-injection approaches\n\n* ContextStore backed by a WeakMap\n\n* ContextStore backed by field-injected keys\n\n* Optimize store lookup for a small number of ids while still supporting additional ids\n\n* Log which context store # was allocated to which mapping\n\n* Cleanup legacy field-injection related tests and make them forked tests\n\n* Make sure JDK types can read our bootstrap accessor interface\n\n* New field-injection context provider\n\n* New field-injection request rewriter\n\n* Add method to show if a superclass of a given type previously matched or was excluded from field-injection\n\n* New context store field-injector, delegates to weak-map when it or its super class(es) don't have a field for the store.\n\n* Add tests for the new field-injection strategy\n\n* Protect against concurrent updates to bitset\n  There's only a small number of excluded types and contention on them is low\n  during matching so the simplest approach is to use a synchronized block.\n\n* Increase number of prepared field-injection stores and check id allocation\n\n* Tweak field accessor names\n\n* Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\n  This reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\n  involving injection of generated helper interfaces cannot happen when using a single common\n  interface for field-injection.\n\n* Use stores array to track all stores\n\n* Document that WeakMapContextStores should be created lazily", "committedDate": "2021-01-20T14:48:49Z", "type": "commit"}, {"oid": "26eb63158100a554f3b79172ad5f5d264a4f6084", "url": "https://github.com/DataDog/dd-trace-java/commit/26eb63158100a554f3b79172ad5f5d264a4f6084", "message": "Use a single-interface for field-injection:\n\n* Mark old classes not used in the new field-injection strategy as deprecated\n\n* Support legacy and new field-injection approaches\n\n* ContextStore backed by a WeakMap\n\n* ContextStore backed by field-injected keys\n\n* Optimize store lookup for a small number of ids while still supporting additional ids\n\n* Log which context store # was allocated to which mapping\n\n* Cleanup legacy field-injection related tests and make them forked tests\n\n* Make sure JDK types can read our bootstrap accessor interface\n\n* New field-injection context provider\n\n* New field-injection request rewriter\n\n* Add method to show if a superclass of a given type previously matched or was excluded from field-injection\n\n* New context store field-injector, delegates to weak-map when it or its super class(es) don't have a field for the store.\n\n* Add tests for the new field-injection strategy\n\n* Protect against concurrent updates to bitset\n  There's only a small number of excluded types and contention on them is low\n  during matching so the simplest approach is to use a synchronized block.\n\n* Increase number of prepared field-injection stores and check id allocation\n\n* Tweak field accessor names\n\n* Revert \"temporarily ignore VM instrumentation assertion errors on IBM J9\"\n\n  This reverts commit e1e5be31849281d0de9b8df9289667498f392181 because the underlying issue\n  involving injection of generated helper interfaces cannot happen when using a single common\n  interface for field-injection.\n\n* Use stores array to track all stores\n\n* Document that WeakMapContextStores should be created lazily", "committedDate": "2021-01-20T14:48:49Z", "type": "forcePushed"}]}