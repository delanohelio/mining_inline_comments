{"pr_number": 1739, "pr_title": "Out-of-Order Scope Close Handling", "pr_createdAt": "2020-08-03T18:24:29Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1739", "timeline": [{"oid": "2cdf4599b819a6da4a5c92c255fc8db1f062ace9", "url": "https://github.com/DataDog/dd-trace-java/commit/2cdf4599b819a6da4a5c92c255fc8db1f062ace9", "message": "Explicitly pass scopeManager\n\nBeginning to unravel messy object divisions by making pass of scopeManager explicit -- rather than using instance inner classes", "committedDate": "2020-07-31T16:01:53Z", "type": "commit"}, {"oid": "e9fdd8684b8441f816bd408694e7ca1206700623", "url": "https://github.com/DataDog/dd-trace-java/commit/e9fdd8684b8441f816bd408694e7ca1206700623", "message": "Replacing scope link list with a proper stack\n\nReplacing the scope link list with a thread local stack\n\nAs the first step - using a non-performant java.util.Stack\nIt will be replaced in a subsequent change\n\nFixing ScopeManagerTest to not probe the internals of the ScopeManager object", "committedDate": "2020-07-31T19:14:00Z", "type": "commit"}, {"oid": "1bd51dd908b0b8b5238faeaa6a47ef69a46fac92", "url": "https://github.com/DataDog/dd-trace-java/commit/1bd51dd908b0b8b5238faeaa6a47ef69a46fac92", "message": "Replacing Stack with ArrayList", "committedDate": "2020-07-31T19:22:27Z", "type": "commit"}, {"oid": "8de0e48ea8afea4c8ed1b6b39191ec81c315beee", "url": "https://github.com/DataDog/dd-trace-java/commit/8de0e48ea8afea4c8ed1b6b39191ec81c315beee", "message": "Final step in introducing stack & handling out-of-order close\n\nReplaced the ArrayList with a ContinuableScope[] in ScopeStack\n\nDropped the toRestore & depth fields from ContinuableScope\nRestoration is now managed via ContinuableScope[]\ndepth is no longer tracked on the ContinuableScope, but instead tracked by the\ntopPos member of ScopeStack\n\nIn this change, I've taken care to maintain the existing reference counting &\nnotification semantics -- despite my general feeling that they are not\ncompletely intuitive or correct.\n\nI've also taken care to do minimum of moving code around -- including in tests\nto make the change easier to review for correctness.\n\nAs such, most things have a 1-to-1 replacement...\n- ContinuableScope.depth -> ContinuableScopeManager.ScopeStack.depth\n- ContinuableScope.toRestore linked list -> ScopeManager.stack\n- ContinuableScopeManager.tlsScope.remove -> ContinuableScopeManager.ScopeStack.clear\n\nThe functional part of this change is simply improving out-of-order close behavior.\n\nPreviously, given a stack C, B, A...\nIf B was closed out-of-order, then C would be left on-top.\nOnce C was closed, B would be restored to the top of stack.\nBut B would need to close again to proper close A.\n\nIf B was not closed twice, then the stack could grow indefinitely.\n\nThe new code behaves a bit better -- given a stack C, B, A...\nIf B is closed out-of-order, then C would left on-top\nOnce C is closed, the stack will skip over B, since it is already closed -- returning to A.\nThen A can be closed properly with an extra close of B.\n\nThis doesn't eliminate the possibility of having the stack grow indefinitely,\nbut I believe it does reduce it significantly.\n\nIn hindsight, this could have been achieved via the toRestore field already on\nContinuableScope, but I've elected to implemented a conventional stack instead.\n\nThe stack clean-up works by cleaning up the stack on querying active / activeScope.\nAt access time, the ContinuableScopeManager checks if the ContinuableScope is still active.\nIf it isn't, then the stack top is moved back a scope at a time until an active\nscope is found.\n\nTo avoid doing the clean-up often, the stack is proactively unwound on a normal close in\nContinuableScope.close.", "committedDate": "2020-08-03T18:19:46Z", "type": "commit"}, {"oid": "fa31e4ed6547e6d5ec036f4801dbbbab6014347d", "url": "https://github.com/DataDog/dd-trace-java/commit/fa31e4ed6547e6d5ec036f4801dbbbab6014347d", "message": "Fixing previously overlooked OpenTel wrapper change\n\nThe OpenTel test was checking for the old out-of-order close behavior.  The test has been revised to reflect the new behavior.", "committedDate": "2020-08-03T19:17:55Z", "type": "commit"}, {"oid": "32b556328665644b8ac5b97238d441c4cdd0628a", "url": "https://github.com/DataDog/dd-trace-java/commit/32b556328665644b8ac5b97238d441c4cdd0628a", "message": "Restoring imports", "committedDate": "2020-08-03T19:48:25Z", "type": "commit"}, {"oid": "157fe113d6b84069d6beef7d519f23ca00c49410", "url": "https://github.com/DataDog/dd-trace-java/commit/157fe113d6b84069d6beef7d519f23ca00c49410", "message": "Fixing the same problem in the OpenTracing tests", "committedDate": "2020-08-03T20:16:45Z", "type": "commit"}, {"oid": "f187b73671bc54c8569ad7d3701a926c7550ffd6", "url": "https://github.com/DataDog/dd-trace-java/commit/f187b73671bc54c8569ad7d3701a926c7550ffd6", "message": "Removing stray commented out code", "committedDate": "2020-08-03T20:35:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODYwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464648609", "bodyText": "depth moved from ContinuableScope to ScopeStack", "author": "dougqh", "createdAt": "2020-08-03T20:36:54Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -66,15 +74,21 @@ private ContinuableScopeManager(\n \n   @Override\n   public AgentScope activate(final AgentSpan span, final ScopeSource source) {\n-    final ContinuableScope active = tlsScope.get();\n+    ScopeStack scopeStack = scopeStack();\n+\n+    final ContinuableScope active = scopeStack.top();\n     if (active != null && active.span().equals(span)) {\n-      return active.incrementReferences();\n+      active.incrementReferences();\n+      return active;\n     }\n-    final int currentDepth = active == null ? 0 : active.depth();\n+\n+    // DQH - This check could go before the check above, since depth limit checking is fast\n+    final int currentDepth = scopeStack.depth();", "originalCommit": "157fe113d6b84069d6beef7d519f23ca00c49410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0ODk1OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464648959", "bodyText": "tlsScope.set becomes scopeStack().push\nscopeStack is ThreadLocal", "author": "dougqh", "createdAt": "2020-08-03T20:37:38Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -86,20 +100,20 @@ public Scope handleSpan(final AgentSpan span) {\n   private Scope handleSpan(\n       final Continuation continuation, final AgentSpan span, final ScopeSource source) {\n     final ContinuableScope scope =\n-        new ContinuableScope(continuation, delegate.handleSpan(span), source);\n-    tlsScope.set(scope);\n+        new ContinuableScope(this, continuation, delegate.handleSpan(span), source);\n+    scopeStack().push(scope);", "originalCommit": "157fe113d6b84069d6beef7d519f23ca00c49410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTIxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464649210", "bodyText": "tlsScope.get becomes scopeStack().top()\ntop() is the fix-up version that unwinds the stack if necessary", "author": "dougqh", "createdAt": "2020-08-03T20:38:10Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -86,20 +100,20 @@ public Scope handleSpan(final AgentSpan span) {\n   private Scope handleSpan(\n       final Continuation continuation, final AgentSpan span, final ScopeSource source) {\n     final ContinuableScope scope =\n-        new ContinuableScope(continuation, delegate.handleSpan(span), source);\n-    tlsScope.set(scope);\n+        new ContinuableScope(this, continuation, delegate.handleSpan(span), source);\n+    scopeStack().push(scope);\n     scope.afterActivated();\n     return scope;\n   }\n \n   @Override\n   public TraceScope active() {\n-    return tlsScope.get();\n+    return scopeStack().top();", "originalCommit": "157fe113d6b84069d6beef7d519f23ca00c49410", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTc2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464649763", "bodyText": "I switched away from instance inner classes to static inner classes to make the boundaries more clear.\nI think this code could be organized better, but for the moment, I didn't move things around much to keep the diff to a minimum.", "author": "dougqh", "createdAt": "2020-08-03T20:39:22Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +122,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");", "originalCommit": "157fe113d6b84069d6beef7d519f23ca00c49410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTgwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465831802", "bodyText": "I had the same debate when I worked on this a few months ago...", "author": "tylerbenson", "createdAt": "2020-08-05T15:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0OTc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDYyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r464650625", "bodyText": "set(toRestore) becomes scopeStack().blindPop().\nblindPop -- pops the stack without checking what's on top.  The top checking was done above in the same fashion as the original code.", "author": "dougqh", "createdAt": "2020-08-03T20:41:14Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -159,18 +192,35 @@ public void close() {\n       if (null != continuation) {\n         span().context().getTrace().cancelContinuation(continuation);\n       }\n-      tlsScope.set(toRestore);\n+      if (onTop) scopeStack.blindPop();", "originalCommit": "157fe113d6b84069d6beef7d519f23ca00c49410", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NjYxMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465196611", "bodyText": "onTop is always true here because it's checked above and a return is the only non exceptional exit from that block.", "author": "richardstartin", "createdAt": "2020-08-04T17:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY1MDYyNQ=="}], "type": "inlineReview"}, {"oid": "c5786715129eb7310febc21ad45b9f913d432e8f", "url": "https://github.com/DataDog/dd-trace-java/commit/c5786715129eb7310febc21ad45b9f913d432e8f", "message": "Adding comments explaining the various ScopeStack methods", "committedDate": "2020-08-03T20:49:12Z", "type": "commit"}, {"oid": "3e62a411455e3056f6287da17805c8f9bf7e8831", "url": "https://github.com/DataDog/dd-trace-java/commit/3e62a411455e3056f6287da17805c8f9bf7e8831", "message": "Misc clean-up\n\nFixed errant stackRef intended to be stack\nAdded / clarified comments\nConsistently applied final", "committedDate": "2020-08-03T21:00:11Z", "type": "commit"}, {"oid": "d707e6de5ef65ea16f8413ba7ed062291aff1a97", "url": "https://github.com/DataDog/dd-trace-java/commit/d707e6de5ef65ea16f8413ba7ed062291aff1a97", "message": "Re-running spotless", "committedDate": "2020-08-04T15:21:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MDExNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465170117", "bodyText": "this is an assignment to a local and is never reflected onto the instance\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        stack = Arrays.copyOf(stack, stack.length >> 1);\n          \n          \n            \n                        this.stack = Arrays.copyOf(stack, stack.length >> 1);", "author": "richardstartin", "createdAt": "2020-08-04T16:17:10Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);", "originalCommit": "d707e6de5ef65ea16f8413ba7ed062291aff1a97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MTk4OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465171988", "bodyText": "What about reserving a null first element of the array and adding 1 to every position?", "author": "richardstartin", "createdAt": "2020-08-04T16:20:07Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = -1;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      if (topPos == -1) return null;", "originalCommit": "d707e6de5ef65ea16f8413ba7ed062291aff1a97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MzMxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465173310", "bodyText": "Which tests need to be removed to avoid this?\nIt feels like it's a good practice to clear the array out ASAP, i.e. in the stack's pop method. Does something prevent this?", "author": "richardstartin", "createdAt": "2020-08-04T16:22:17Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +256,131 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = -1;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == -1) return null;\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) return topScope;\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos >= 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length >> 2) {\n+            stack = Arrays.copyOf(stack, stack.length >> 1);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = -1;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      if (topPos == -1) return null;\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length << 1);\n+      }\n+      stack[topPos] = scope;\n+    }\n+\n+    /**\n+     * Fast check to see if the expectedScope is on top the stack -- this is done with any fix-up\n+     */\n+    final boolean checkTop(ContinuableScope expectedScope) {\n+      if (topPos == -1) return false;\n+\n+      return stack[topPos].equals(expectedScope);\n+    }\n+\n+    /**\n+     * Blind pop of the top stack entry This is done without fix-up, checking the stack top, or even\n+     * a depth check Responsibility lies with the caller to do the diligence of calling depth or\n+     * checkTop ahead of calling blindPop.\n+     */\n+    final void blindPop() {\n+      stack[topPos--] = null;\n+    }\n+\n+    /** Returns the current stack depth */\n+    final int depth() {\n+      return topPos + 1;\n+    }\n+\n+    // DQH - regrettably needed for pre-existing tests", "originalCommit": "d707e6de5ef65ea16f8413ba7ed062291aff1a97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNDUwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465824500", "bodyText": "I think that the proper use of top and blindPop already leads to a cleared out stack. This seems to be used to make sure that the scopes don't leak between tests even if they fail.", "author": "bantonsson", "createdAt": "2020-08-05T15:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3MzMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NDI3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465174273", "bodyText": "There's only one template in the pattern, but two parameters\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());\n          \n          \n            \n                          \"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());", "author": "richardstartin", "createdAt": "2020-08-04T16:23:48Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\n+              \"Tried to close {} scope when not on top. Ignoring!\", this, scopeStack.noFixupTop());", "originalCommit": "d707e6de5ef65ea16f8413ba7ed062291aff1a97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTgwNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465175804", "bodyText": "I hate to bikeshed but I have a strong aversion to unbraced conditional statements because I've been burnt by them in the past.", "author": "richardstartin", "createdAt": "2020-08-04T16:26:09Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,66 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;", "originalCommit": "d707e6de5ef65ea16f8413ba7ed062291aff1a97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMDA2Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465830062", "bodyText": "I'm actually a little surprised... I assumed that this was in violation to google-java-format but the check passed.  I'd support making this a build failure somehow.", "author": "tylerbenson", "createdAt": "2020-08-05T15:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3NTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNjMwMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465816303", "bodyText": "Nice touch using slot 0 as a holder for null to avoid the -1 math and checks.", "author": "bantonsson", "createdAt": "2020-08-05T15:34:37Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -308,7 +311,6 @@ final ContinuableScope top() {\n      * useful in logging to avoid side effects, but could be used in other places with caution.\n      */\n     final ContinuableScope noFixupTop() {\n-      if (topPos == -1) return null;\n       return stack[topPos];", "originalCommit": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMDQxOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465820418", "bodyText": "shh!", "author": "richardstartin", "createdAt": "2020-08-05T15:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNjMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg3Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465825872", "bodyText": "leftover?", "author": "bantonsson", "createdAt": "2020-08-05T15:48:28Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;", "originalCommit": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMzI5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465833296", "bodyText": "Yes I think we should remove this. I'll do it.", "author": "richardstartin", "createdAt": "2020-08-05T15:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg3Mg=="}], "type": "inlineReview"}, {"oid": "31cd244b968a657400cf6be1971f408e385de974", "url": "https://github.com/DataDog/dd-trace-java/commit/31cd244b968a657400cf6be1971f408e385de974", "message": "tweaks", "committedDate": "2020-08-05T16:00:37Z", "type": "commit"}, {"oid": "31cd244b968a657400cf6be1971f408e385de974", "url": "https://github.com/DataDog/dd-trace-java/commit/31cd244b968a657400cf6be1971f408e385de974", "message": "tweaks", "committedDate": "2020-08-05T16:00:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNTg1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465825855", "bodyText": "Do we really want this to be protected?  Perhaps private?", "author": "tylerbenson", "createdAt": "2020-08-05T15:48:26Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {", "originalCommit": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNjYxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465826612", "bodyText": "Delete?", "author": "tylerbenson", "createdAt": "2020-08-05T15:49:36Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+", "originalCommit": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTIyMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465831221", "bodyText": "The cost of noFixupTop seems minimal.  Perhaps we don't need the guard clause here?", "author": "tylerbenson", "createdAt": "2020-08-05T15:56:19Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {", "originalCommit": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMjM4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465832384", "bodyText": "Not related to this PR, but we should encapsulate this in the Monitor...", "author": "tylerbenson", "createdAt": "2020-08-05T15:58:09Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -108,47 +121,65 @@ public void addScopeListener(final ScopeListener listener) {\n     scopeListeners.add(listener);\n   }\n \n-  private class ContinuableScope extends DelegatingScope implements Scope {\n+  protected ScopeStack scopeStack() {\n+    return this.tlsScopeStack.get();\n+  }\n+\n+  private static final class ContinuableScope extends DelegatingScope implements Scope {\n+    private final ContinuableScopeManager scopeManager;\n+\n     /** Scope to placed in the thread local after close. May be null. */\n-    private final ContinuableScope toRestore;\n+    // private final ContinuableScope toRestore;\n+\n     /** Continuation that created this scope. May be null. */\n     private final ContinuableScopeManager.Continuation continuation;\n     /** Flag to propagate this scope across async boundaries. */\n     private final AtomicBoolean isAsyncPropagating = new AtomicBoolean(false);\n-    /** depth of scope on thread */\n-    private final int depth;\n \n     private final ScopeSource source;\n \n     private final AtomicInteger referenceCount = new AtomicInteger(1);\n \n     ContinuableScope(\n+        final ContinuableScopeManager scopeManager,\n         final ContinuableScopeManager.Continuation continuation,\n         final Scope delegate,\n         final ScopeSource source) {\n       super(delegate);\n       assert delegate.span() != null;\n+      this.scopeManager = scopeManager;\n       this.continuation = continuation;\n-      toRestore = tlsScope.get();\n-      depth = toRestore == null ? 0 : toRestore.depth() + 1;\n       this.source = source;\n     }\n \n     @Override\n     public void close() {\n-      if (referenceCount.decrementAndGet() > 0) {\n-        return;\n-      }\n-\n-      if (tlsScope.get() != this) {\n-        log.debug(\"Tried to close {} scope when {} is on top. Ignoring!\", this, tlsScope.get());\n+      ScopeStack scopeStack = scopeManager.scopeStack();\n+\n+      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n+      // first round of out-of-order handling.\n+      // When reference counts are being used, we don't check the stack top --\n+      // so potentially we undercount errors\n+      // Also we don't report closed until the reference count == 0 which seems\n+      // incorrect given the OpenTracing semantics\n+      // Both these issues should be corrected at a later date\n+\n+      boolean alive = decrementReferences();\n+      if (alive) return;\n+\n+      boolean onTop = scopeStack.checkTop(this);\n+      if (!onTop) {\n+        if (log.isDebugEnabled()) {\n+          // Using noFixupTop because I don't want to have code with side effects in logging code\n+          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+        }\n \n-        statsDClient.incrementCounter(\"scope.close.error\");\n+        scopeManager.statsDClient.incrementCounter(\"scope.close.error\");\n \n         if (source == ScopeSource.MANUAL) {\n-          statsDClient.incrementCounter(\"scope.user.close.error\");\n+          scopeManager.statsDClient.incrementCounter(\"scope.user.close.error\");", "originalCommit": "ef92f428cc30972a6d0fed01ff6ced1f9eccdaf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0Mzc2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465843765", "bodyText": "How did you decide on 16?", "author": "tylerbenson", "createdAt": "2020-08-05T16:15:55Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];", "originalCommit": "31cd244b968a657400cf6be1971f408e385de974", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0NDc1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465844751", "bodyText": "Looks like this is intended to reduce the size of the stack. Please comment and maybe extract to a separate method?\nAlso, do we need to set a minimum for the default size?", "author": "tylerbenson", "createdAt": "2020-08-05T16:17:24Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }", "originalCommit": "31cd244b968a657400cf6be1971f408e385de974", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MDMwNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465850304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n          \n          \n            \n                 * Pushes a new scope onto the current stack, the new scope is pushed onto the stack without", "author": "tylerbenson", "createdAt": "2020-08-05T16:25:44Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without", "originalCommit": "31cd244b968a657400cf6be1971f408e385de974", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MTM5MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465851391", "bodyText": "Should we have a separate methods to handle growing/shrinking the stack?", "author": "tylerbenson", "createdAt": "2020-08-05T16:27:23Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length * 2);\n+      }", "originalCommit": "31cd244b968a657400cf6be1971f408e385de974", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1NDA3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1739#discussion_r465854073", "bodyText": "seems like the next call to top() would result in shrinking the array.  Consider setting a new array with default/minimum size instead?", "author": "tylerbenson", "createdAt": "2020-08-05T16:31:27Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -205,21 +252,132 @@ public String toString() {\n     }\n   }\n \n+  static final class ScopeStack {\n+    ContinuableScope[] stack = new ContinuableScope[16];\n+    int topPos = 0;\n+\n+    /**\n+     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n+     * top scope isn't active, then the stack is popped back to the top-most active Scope\n+     */\n+    final ContinuableScope top() {\n+      int priorTopPos = this.topPos;\n+      if (priorTopPos == 0) {\n+        return null;\n+      }\n+\n+      // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n+      // only bothering to do this here because of the loop below\n+      ContinuableScope[] stack = this.stack;\n+      priorTopPos = Math.min(priorTopPos, stack.length);\n+\n+      // Peel first iteration\n+      ContinuableScope topScope = stack[priorTopPos];\n+      if (topScope.alive()) {\n+        return topScope;\n+      }\n+\n+      // null out top position, it is no longer alive\n+      stack[topPos] = null;\n+\n+      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n+        ContinuableScope curScope = stack[curPos];\n+        if (curScope.alive()) {\n+          // save the position for next time\n+          topPos = curPos;\n+\n+          if (topPos < stack.length / 4) {\n+            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          }\n+\n+          return curScope;\n+        }\n+\n+        // no longer alive -- trigger listener & null out\n+        curScope.onProperClose();\n+        stack[curPos] = null;\n+      }\n+\n+      // empty stack -- save topPos for next time\n+      topPos = 0;\n+      return null;\n+    }\n+\n+    /**\n+     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n+     * useful in logging to avoid side effects, but could be used in other places with caution.\n+     */\n+    final ContinuableScope noFixupTop() {\n+      return stack[topPos];\n+    }\n+\n+    /**\n+     * Pushes a new scope unto the stack Currently, the new scope is pushed onto the stack without\n+     * any stack fix-up. This works under two assumptions... 1 - Normally, the stack doesn't need\n+     * fix-up because the stack is proactively clean by Scope.close 2 - If the stack does need\n+     * fix-up, it has probably already been done by calling active to get the parent scope\n+     */\n+    final void push(final ContinuableScope scope) {\n+      // no proactive stack cleaning in push\n+      // In most cases, the span construction will have asked for the activeScope\n+      // and done any necessary stack clean-up\n+\n+      ++topPos;\n+      if (topPos == stack.length) {\n+        // Could scan the stack for dead activations and compact before expansion.\n+        // Probably not worth it\n+        stack = Arrays.copyOf(stack, stack.length * 2);\n+      }\n+      stack[topPos] = scope;\n+    }\n+\n+    /**\n+     * Fast check to see if the expectedScope is on top the stack -- this is done with any fix-up\n+     */\n+    final boolean checkTop(ContinuableScope expectedScope) {\n+      return expectedScope.equals(stack[topPos]);\n+    }\n+\n+    /**\n+     * Blind pop of the top stack entry This is done without fix-up, checking the stack top, or even\n+     * a depth check Responsibility lies with the caller to do the diligence of calling depth or\n+     * checkTop ahead of calling blindPop.\n+     */\n+    final void blindPop() {\n+      stack[topPos--] = null;\n+    }\n+\n+    /** Returns the current stack depth */\n+    final int depth() {\n+      return topPos;\n+    }\n+\n+    // DQH - regrettably needed for pre-existing tests\n+    final void clear() {\n+      topPos = 0;\n+      Arrays.fill(stack, null);", "originalCommit": "31cd244b968a657400cf6be1971f408e385de974", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}