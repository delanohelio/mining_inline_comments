{"pr_number": 1679, "pr_title": "trace agent v0.5", "pr_createdAt": "2020-07-14T11:25:27Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1679", "timeline": [{"oid": "caa73b783716155776283bbd36ac5df4734a9cd3", "url": "https://github.com/DataDog/dd-trace-java/commit/caa73b783716155776283bbd36ac5df4734a9cd3", "message": "add trace format discovery mechanism", "committedDate": "2020-07-14T11:26:13Z", "type": "forcePushed"}, {"oid": "28442dabab42e76bdbf3b84e5edf415f5e078233", "url": "https://github.com/DataDog/dd-trace-java/commit/28442dabab42e76bdbf3b84e5edf415f5e078233", "message": "add trace format discovery mechanism", "committedDate": "2020-07-14T11:34:07Z", "type": "forcePushed"}, {"oid": "eced5621e52cac6b924b226c48e1c6d462c00650", "url": "https://github.com/DataDog/dd-trace-java/commit/eced5621e52cac6b924b226c48e1c6d462c00650", "message": "improve agent api tests for v0.5", "committedDate": "2020-07-14T20:36:37Z", "type": "forcePushed"}, {"oid": "9d7dfc4e60292b2aeace5d4583344593fd044060", "url": "https://github.com/DataDog/dd-trace-java/commit/9d7dfc4e60292b2aeace5d4583344593fd044060", "message": "revapi", "committedDate": "2020-07-14T21:30:13Z", "type": "forcePushed"}, {"oid": "6a572a45bc42b861722a7a6d3134aef3099fb434", "url": "https://github.com/DataDog/dd-trace-java/commit/6a572a45bc42b861722a7a6d3134aef3099fb434", "message": "select trace mapper lazily in case the agent is unavailable or slow during application startup", "committedDate": "2020-07-15T09:07:39Z", "type": "forcePushed"}, {"oid": "11df138e446ad2bce8eacf0dd4ee13f337b65891", "url": "https://github.com/DataDog/dd-trace-java/commit/11df138e446ad2bce8eacf0dd4ee13f337b65891", "message": "make smoke tests 404 on agent v0.5 endpoint", "committedDate": "2020-07-15T11:24:45Z", "type": "forcePushed"}, {"oid": "3e4186a202d3b0a13a71c44056ae4d8f05f174d7", "url": "https://github.com/DataDog/dd-trace-java/commit/3e4186a202d3b0a13a71c44056ae4d8f05f174d7", "message": "don't trigger agent connection until at least one trace has been published", "committedDate": "2020-07-16T21:34:51Z", "type": "forcePushed"}, {"oid": "2c009aa409abb8d919c0a87bf2b65162edb8968d", "url": "https://github.com/DataDog/dd-trace-java/commit/2c009aa409abb8d919c0a87bf2b65162edb8968d", "message": "remove unused DDAgentWriter from Monitor methods which avoids unsafe publication of", "committedDate": "2020-07-20T14:58:00Z", "type": "forcePushed"}, {"oid": "6b36a3766a5218e8c567a53fab8dfea45dff695a", "url": "https://github.com/DataDog/dd-trace-java/commit/6b36a3766a5218e8c567a53fab8dfea45dff695a", "message": "revapi", "committedDate": "2020-07-21T09:38:25Z", "type": "forcePushed"}, {"oid": "d939a2f04c546615185363dd0d2ba604c1d2fd50", "url": "https://github.com/DataDog/dd-trace-java/commit/d939a2f04c546615185363dd0d2ba604c1d2fd50", "message": "revapi", "committedDate": "2020-07-21T10:00:27Z", "type": "forcePushed"}, {"oid": "7855b8ce3660be2fd2e1559acfec4e49c6277178", "url": "https://github.com/DataDog/dd-trace-java/commit/7855b8ce3660be2fd2e1559acfec4e49c6277178", "message": "revapi", "committedDate": "2020-07-21T10:05:39Z", "type": "forcePushed"}, {"oid": "e421c3a32512a68c716bd2a59c9170b1288b6609", "url": "https://github.com/DataDog/dd-trace-java/commit/e421c3a32512a68c716bd2a59c9170b1288b6609", "message": "make CoreTracerTest happy", "committedDate": "2020-07-21T10:48:38Z", "type": "forcePushed"}, {"oid": "b43511383be141761375333f71f0f129830ead4d", "url": "https://github.com/DataDog/dd-trace-java/commit/b43511383be141761375333f71f0f129830ead4d", "message": "get rid of trace wrapper", "committedDate": "2020-07-21T17:39:07Z", "type": "forcePushed"}, {"oid": "bfd5f69a54a078b1211a564fd38021ab723027d3", "url": "https://github.com/DataDog/dd-trace-java/commit/bfd5f69a54a078b1211a564fd38021ab723027d3", "message": "improve encapsulation of endpoint specific payload logic", "committedDate": "2020-07-23T11:14:26Z", "type": "forcePushed"}, {"oid": "9807b6df52e4f6fd3c631c4f52c214a589914a3a", "url": "https://github.com/DataDog/dd-trace-java/commit/9807b6df52e4f6fd3c631c4f52c214a589914a3a", "message": "dictionary encode trace messages", "committedDate": "2020-07-30T08:16:01Z", "type": "forcePushed"}, {"oid": "ef1b866f7252ba4c84a1a3656cee98d076910148", "url": "https://github.com/DataDog/dd-trace-java/commit/ef1b866f7252ba4c84a1a3656cee98d076910148", "message": "dictionary encode trace messages", "committedDate": "2020-07-30T08:18:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzNjI5MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r462836291", "bodyText": "This one seems to be unused and shadowed by the method parameter in writeLongAsString", "author": "bantonsson", "createdAt": "2020-07-30T08:30:02Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Util.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.core.serialization.msgpack;\n+\n+public class Util {\n+\n+  private static final byte[] DIGIT_TENS = {\n+    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n+    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n+    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n+    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n+    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n+    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n+    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n+    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n+    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n+    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n+  };\n+\n+  private static final byte[] DIGIT_ONES = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+  };\n+\n+  private final byte[] numberByteArray = new byte[20]; // this is max long digits and sign", "originalCommit": "ef1b866f7252ba4c84a1a3656cee98d076910148", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4fdd8908b6c951932be72e2a742d876a165df7f1", "url": "https://github.com/DataDog/dd-trace-java/commit/4fdd8908b6c951932be72e2a742d876a165df7f1", "message": "dictionary encode trace messages", "committedDate": "2020-07-30T08:35:30Z", "type": "forcePushed"}, {"oid": "b472bcfe3f8e076950ce096300335c983365eab3", "url": "https://github.com/DataDog/dd-trace-java/commit/b472bcfe3f8e076950ce096300335c983365eab3", "message": "revapi", "committedDate": "2020-07-30T09:21:53Z", "type": "forcePushed"}, {"oid": "95c69821949f35bd0876b9f468b85953f4356e67", "url": "https://github.com/DataDog/dd-trace-java/commit/95c69821949f35bd0876b9f468b85953f4356e67", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour", "committedDate": "2020-07-30T16:31:37Z", "type": "forcePushed"}, {"oid": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "url": "https://github.com/DataDog/dd-trace-java/commit/dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour", "committedDate": "2020-07-30T17:50:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3MzM1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463173353", "bodyText": "@dougqh here's the fallback mechanism (i.e. pick the latest one this deployment knows about).", "author": "richardstartin", "createdAt": "2020-07-30T17:57:34Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -36,9 +38,10 @@\n   private static final String DATADOG_META_TRACER_VERSION = \"Datadog-Meta-Tracer-Version\";\n   private static final String DATADOG_CONTAINER_ID = \"Datadog-Container-ID\";\n   private static final String X_DATADOG_TRACE_COUNT = \"X-Datadog-Trace-Count\";\n-\n-  private static final String TRACES_ENDPOINT_V3 = \"v0.3/traces\";\n-  private static final String TRACES_ENDPOINT_V4 = \"v0.4/traces\";\n+  private static final String V3_ENDPOINT = \"v0.3/traces\";\n+  private static final String V4_ENDPOINT = \"v0.4/traces\";\n+  private static final String V5_ENDPOINT = \"v0.5/traces\";\n+  private static final String[] ENDPOINTS = new String[] {V5_ENDPOINT, V4_ENDPOINT, V3_ENDPOINT};", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3MzY4Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463173683", "bodyText": "@dougqh discovery/fallback mechanism", "author": "richardstartin", "createdAt": "2020-07-30T17:58:11Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -305,16 +335,44 @@ private static HttpUrl getUrl(final String host, final int port, final String en\n     }\n   }\n \n-  void detectEndpointAndBuildClient() {\n+  String detectEndpointAndBuildClient() {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NDYxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463174610", "bodyText": "@dougqh this is the V5 mapper", "author": "richardstartin", "createdAt": "2020-07-30T17:59:48Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NTA3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463175079", "bodyText": "@dougqh this ensures that null values are dictionary encoded as the empty string \u00af_(\u30c4)_/\u00af", "author": "richardstartin", "createdAt": "2020-07-30T18:00:27Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NjAzMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463176031", "bodyText": "this is a quite hacky workaround for the Packer's API releasing a slice of the buffer to a consumer, it gets published into the first slot of this array.", "author": "richardstartin", "createdAt": "2020-07-30T18:02:12Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NzI2Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463177266", "bodyText": "This happens when the dictionary fills up before the traces do, and we need some way to signal to the Packer packing the traces themselves that the dictionary is full. There are probably other ways of doing this and we can/should refactor this to be cleaner later.", "author": "richardstartin", "createdAt": "2020-07-30T18:04:22Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3NzcyMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463177721", "bodyText": "This is responsible for mapping the deduplicated strings to msgpack strings.", "author": "richardstartin", "createdAt": "2020-07-30T18:05:09Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {\n+        dictionaryWriter.flush();\n+        // signal the need for a flush because the string table filled up\n+        // faster than the message content\n+        throw DICTIONARY_FULL;\n+      }\n+      encoding.put(target, code);\n+      writable.writeInt(code);\n+      ++code;\n+    } else {\n+      writable.writeInt(encoded);\n+    }\n+  }\n+\n+  @Override\n+  public Payload newPayload() {\n+    return new PayloadV0_5(getDictionary());\n+  }\n+\n+  private ByteBuffer getDictionary() {\n+    if (dictionary[0] == null) {\n+      dictionaryWriter.flush();\n+    }\n+    return dictionary[0];\n+  }\n+\n+  @Override\n+  public void reset() {\n+    dictionaryWriter.reset();\n+    code = 0;\n+    dictionary[0] = null;\n+    encoding.clear();\n+  }\n+\n+  private static class DictionaryMapper implements Mapper<Object> {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3ODA5OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463178099", "bodyText": "The WritableByteChannel comes from the HTTP API. Need to write an array of the dictionary and the body (traces) into the channel.", "author": "richardstartin", "createdAt": "2020-07-30T18:05:53Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,201 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      Map<String, Object> tags = span.getTags();\n+      Map<String, String> baggage = span.getBaggage();\n+      // since tags can \"override\" baggage, we need to count the non overlapping ones\n+      int size = tags.size();\n+      boolean overlap = false;\n+      for (String key : baggage.keySet()) {\n+        if (!tags.containsKey(key)) {\n+          size++;\n+        } else {\n+          overlap = true;\n+        }\n+      }\n+      writable.startMap(size);\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!overlap || !tags.containsKey(entry.getKey())) {\n+          writeDictionaryEncoded(writable, entry.getKey());\n+          writeDictionaryEncoded(writable, entry.getValue());\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writeDictionaryEncoded(writable, entry.getValue());\n+      }\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {\n+        dictionaryWriter.flush();\n+        // signal the need for a flush because the string table filled up\n+        // faster than the message content\n+        throw DICTIONARY_FULL;\n+      }\n+      encoding.put(target, code);\n+      writable.writeInt(code);\n+      ++code;\n+    } else {\n+      writable.writeInt(encoded);\n+    }\n+  }\n+\n+  @Override\n+  public Payload newPayload() {\n+    return new PayloadV0_5(getDictionary());\n+  }\n+\n+  private ByteBuffer getDictionary() {\n+    if (dictionary[0] == null) {\n+      dictionaryWriter.flush();\n+    }\n+    return dictionary[0];\n+  }\n+\n+  @Override\n+  public void reset() {\n+    dictionaryWriter.reset();\n+    code = 0;\n+    dictionary[0] = null;\n+    encoding.clear();\n+  }\n+\n+  private static class DictionaryMapper implements Mapper<Object> {\n+\n+    private final byte[] numberByteArray = new byte[20]; // this is max long digits and sign\n+\n+    @Override\n+    public void map(Object data, Writable packer) {\n+      if (data instanceof UTF8BytesString) {\n+        packer.writeUTF8(((UTF8BytesString) data).getUtf8Bytes());\n+      } else if (data instanceof Long || data instanceof Integer) {\n+        writeLongAsString(((Number) data).longValue(), packer, numberByteArray);\n+      } else {\n+        assert null != data : \"enclosing mapper should not provide null values\";\n+        String string = String.valueOf(data);\n+        byte[] utf8 = StringTables.getKeyBytesUTF8(string);\n+        if (null == utf8) {\n+          utf8 = StringTables.getTagBytesUTF8(string);\n+          if (null == utf8) {\n+            packer.writeString(string, NO_CACHING);\n+            return;\n+          }\n+        }\n+        packer.writeUTF8(utf8);\n+      }\n+    }\n+  }\n+\n+  private static class PayloadV0_5 extends Payload {\n+\n+    // msgpack array header with 2 elements (FIXARRAY | 2)\n+    private final ByteBuffer header = ByteBuffer.allocate(1).put(0, (byte) 0x92);\n+    private final ByteBuffer dictionary;\n+\n+    private PayloadV0_5(ByteBuffer dictionary) {\n+      this.dictionary = dictionary;\n+    }\n+\n+    @Override\n+    int sizeInBytes() {\n+      return sizeInBytes(header) + sizeInBytes(dictionary) + sizeInBytes(body);\n+    }\n+\n+    @Override\n+    public void writeTo(WritableByteChannel channel) throws IOException {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3ODc3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463178777", "bodyText": "mediates between DDAgentApi and TraceProcessingDisruptor - discovers the endpoint, which mapper should be used etc.", "author": "richardstartin", "createdAt": "2020-07-30T18:07:10Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/PayloadDispatcher.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class PayloadDispatcher implements ByteBufferConsumer {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE3OTM1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463179357", "bodyText": "this interface was extracted because it's so very difficult to create DDSpan without creating a CoreTracer and PendingTrace, and it can't be done without violating access constraints.", "author": "richardstartin", "createdAt": "2020-07-30T18:08:13Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpanData.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package datadog.trace.core;", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MDMzMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463180332", "bodyText": "this allows this class to be reused for writing the dictionary, where the dictionary packer can be reset manually after the dictionary packer and the traces packer is flushed.", "author": "richardstartin", "createdAt": "2020-07-30T18:09:55Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Packer.java", "diffHunk": "@@ -98,17 +108,29 @@ private void initBuffer() {\n       //    overflow into the now reset buffer, doing the serialisation work again.\n       buffer.mark();\n       ++messageCount;\n+      return true;\n     } catch (BufferOverflowException e) {\n       // go back to the last successfully written message\n       buffer.reset();\n-      if (buffer.position() == MAX_ARRAY_HEADER_SIZE) {\n-        throw e;\n+      if (!manualReset) {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MDU2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463180567", "bodyText": "Old code moved here for reuse.", "author": "richardstartin", "createdAt": "2020-07-30T18:10:19Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Util.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.core.serialization.msgpack;", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTU5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r463181598", "bodyText": "This will incur a small cost. Without DDSpanData it was possible to get naked access to the underlying map via DDSpanContext, whereas in implementing this interface it is prudent to wrap.", "author": "richardstartin", "createdAt": "2020-07-30T18:12:17Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/DDSpan.java", "diffHunk": "@@ -368,6 +368,11 @@ public int getError() {\n     return context.getErrorFlag() ? 1 : 0;\n   }\n \n+  @Override\n+  public Map<String, String> getBaggage() {", "originalCommit": "dadf197c3038a3ca6a829937e6d1bd88e13d5d3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a4391364c215f9eec25ed2ec4fe9051f759a5a1", "url": "https://github.com/DataDog/dd-trace-java/commit/7a4391364c215f9eec25ed2ec4fe9051f759a5a1", "message": "post rebase spotless", "committedDate": "2020-07-31T18:59:00Z", "type": "forcePushed"}, {"oid": "d78961ae741e64a53339251a449be3251f3057db", "url": "https://github.com/DataDog/dd-trace-java/commit/d78961ae741e64a53339251a449be3251f3057db", "message": "post rebase spotless", "committedDate": "2020-07-31T19:12:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1OTU4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464359584", "bodyText": "I assume that the 1s connect timeout is to make sure that we don't hang for a long time trying to connect to the agent. Would it make sense to have it configurable just in case, for troubleshooting?", "author": "bantonsson", "createdAt": "2020-08-03T11:40:23Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/DDAgentApi.java", "diffHunk": "@@ -305,16 +335,44 @@ private static HttpUrl getUrl(final String host, final int port, final String en\n     }\n   }\n \n-  void detectEndpointAndBuildClient() {\n+  String detectEndpointAndBuildClient() {\n+    // TODO clean this up\n     if (httpClient == null) {\n-      final HttpUrl v4Url = getUrl(host, port, TRACES_ENDPOINT_V4);\n-      if (endpointAvailable(v4Url, unixDomainSocketPath, timeoutMillis, true)) {\n-        tracesUrl = v4Url;\n-      } else {\n-        log.debug(\"API v0.4 endpoints not available. Downgrading to v0.3\");\n-        tracesUrl = getUrl(host, port, TRACES_ENDPOINT_V3);\n+      this.agentRunning = isAgentRunning();\n+      // TODO should check agentRunning, but CoreTracerTest depends on being\n+      //  able to detect an endpoint without an open socket...\n+      for (String candidate : ENDPOINTS) {\n+        tracesUrl = getUrl(host, port, candidate);\n+        this.httpClient = buildClientIfAvailable(tracesUrl, unixDomainSocketPath, timeoutMillis);\n+        if (null != httpClient) {\n+          detectedVersion = candidate;\n+          log.debug(\"connected to agent {}\", candidate);\n+          return candidate;\n+        } else {\n+          log.debug(\"API {} endpoints not available. Downgrading\", candidate);\n+        }\n+      }\n+      if (null == tracesUrl) {\n+        log.error(\"no compatible agent detected\");\n       }\n-      httpClient = buildHttpClient(unixDomainSocketPath, timeoutMillis);\n+    } else {\n+      log.warn(\"No connectivity to datadog agent\");\n+    }\n+    if (null == detectedVersion) {\n+      log.debug(\"Tried all of {}, no connectivity to datadog agent\", ENDPOINTS);\n+    }\n+    return detectedVersion;\n+  }\n+\n+  private boolean isAgentRunning() {\n+    try (Socket socket = new Socket()) {\n+      socket.setSoTimeout(CONNECT_TIMEOUT_MS);", "originalCommit": "d78961ae741e64a53339251a449be3251f3057db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NTA1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464465051", "bodyText": "that's the idea", "author": "richardstartin", "createdAt": "2020-08-03T14:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM1OTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NDk0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464374946", "bodyText": "Lovely little dance here with the Packer", "author": "bantonsson", "createdAt": "2020-08-03T12:15:07Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapperV0_5.java", "diffHunk": "@@ -0,0 +1,206 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+import static datadog.trace.core.serialization.msgpack.Util.writeLongAsString;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.StringTables;\n+import datadog.trace.core.TagsAndBaggageConsumer;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.io.IOException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.WritableByteChannel;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapperV0_5 implements TraceMapper {\n+\n+  private static final class DictionaryFull extends BufferOverflowException {\n+    @Override\n+    public synchronized Throwable fillInStackTrace() {\n+      return this;\n+    }\n+  }\n+\n+  private static final DictionaryFull DICTIONARY_FULL = new DictionaryFull();\n+\n+  private final ByteBuffer[] dictionary = new ByteBuffer[1];\n+  private final Packer dictionaryWriter;\n+  private final DictionaryMapper dictionaryMapper = new DictionaryMapper();\n+  private final Map<Object, Integer> encoding = new HashMap<>();\n+  private int code = 0;\n+\n+  public TraceMapperV0_5() {\n+    this(2 << 20);\n+  }\n+\n+  public TraceMapperV0_5(int bufferSize) {\n+    this.dictionaryWriter =\n+        new Packer(\n+            new ByteBufferConsumer() {\n+              @Override\n+              public void accept(int messageCount, ByteBuffer buffer) {\n+                dictionary[0] = buffer;\n+              }\n+            },\n+            ByteBuffer.allocate(bufferSize),\n+            true);\n+    reset();\n+  }\n+\n+  @Override\n+  public void map(List<? extends DDSpanData> trace, final Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpanData span : trace) {\n+      writable.startArray(12);\n+      /* 1  */\n+      writeDictionaryEncoded(writable, span.getServiceName());\n+      /* 2  */\n+      writeDictionaryEncoded(writable, span.getOperationName());\n+      /* 3  */\n+      writeDictionaryEncoded(writable, span.getResourceName());\n+      /* 4  */\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeInt(span.getError());\n+      /* 10  */\n+      span.processTagsAndBaggage(\n+          new TagsAndBaggageConsumer() {\n+            @Override\n+            public void accept(Map<String, Object> tags, Map<String, String> baggage) {\n+              // since tags can \"override\" baggage, we need to count the non overlapping ones\n+              int size = tags.size();\n+              boolean overlap = false;\n+              for (String key : baggage.keySet()) {\n+                if (!tags.containsKey(key)) {\n+                  size++;\n+                } else {\n+                  overlap = true;\n+                }\n+              }\n+              writable.startMap(size);\n+              for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+                // tags and baggage may intersect, but tags take priority\n+                if (!overlap || !tags.containsKey(entry.getKey())) {\n+                  writeDictionaryEncoded(writable, entry.getKey());\n+                  writeDictionaryEncoded(writable, entry.getValue());\n+                }\n+              }\n+              for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+                writeDictionaryEncoded(writable, entry.getKey());\n+                writeDictionaryEncoded(writable, entry.getValue());\n+              }\n+            }\n+          });\n+      /* 11  */\n+      writable.startMap(span.getMetrics().size());\n+      for (Map.Entry<String, Number> entry : span.getMetrics().entrySet()) {\n+        writeDictionaryEncoded(writable, entry.getKey());\n+        writable.writeObject(entry.getValue(), NO_CACHING);\n+      }\n+      /* 12 */\n+      writeDictionaryEncoded(writable, span.getType());\n+    }\n+  }\n+\n+  private void writeDictionaryEncoded(Writable writable, Object value) {\n+    Object target = null == value ? \"\" : value;\n+    Integer encoded = encoding.get(target);\n+    if (null == encoded) {\n+      if (!dictionaryWriter.format(target, dictionaryMapper)) {\n+        dictionaryWriter.flush();\n+        // signal the need for a flush because the string table filled up\n+        // faster than the message content\n+        throw DICTIONARY_FULL;\n+      }\n+      encoding.put(target, code);\n+      writable.writeInt(code);\n+      ++code;\n+    } else {\n+      writable.writeInt(encoded);\n+    }\n+  }\n+\n+  @Override\n+  public Payload newPayload() {\n+    return new PayloadV0_5(getDictionary());\n+  }\n+\n+  private ByteBuffer getDictionary() {\n+    if (dictionary[0] == null) {\n+      dictionaryWriter.flush();\n+    }\n+    return dictionary[0];", "originalCommit": "d78961ae741e64a53339251a449be3251f3057db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NTUxNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464465516", "bodyText": "Yes, this is less than ideal and I think it could be improved.", "author": "richardstartin", "createdAt": "2020-08-03T14:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NDk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NjExMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464376111", "bodyText": "Shouldn't this be moved a few lines below and use the payload.sizeInBytes()?", "author": "bantonsson", "createdAt": "2020-08-03T12:17:47Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/PayloadDispatcher.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import datadog.trace.core.DDSpanData;\n+import datadog.trace.core.serialization.msgpack.ByteBufferConsumer;\n+import datadog.trace.core.serialization.msgpack.Packer;\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class PayloadDispatcher implements ByteBufferConsumer {\n+\n+  static final int DEFAULT_BUFFER_SIZE = 2 << 20; // 2MB\n+\n+  private final DDAgentApi api;\n+  private int representativeCount;\n+  private TraceMapper traceMapper;\n+  private Packer packer;\n+  private final Monitor monitor;\n+\n+  PayloadDispatcher(DDAgentApi api, Monitor monitor) {\n+    this.api = api;\n+    this.monitor = monitor;\n+  }\n+\n+  void flush() {\n+    if (null != packer) {\n+      packer.flush();\n+    }\n+  }\n+\n+  void addTrace(List<? extends DDSpanData> trace) {\n+    selectTraceMapper();\n+    // the call below is blocking and will trigger IO if a flush is necessary\n+    // there are alternative approaches to avoid blocking here, such as\n+    // introducing an unbound queue and another thread to do the IO\n+    // however, we can't block the application threads from here.\n+    if (null != traceMapper) {\n+      packer.format(trace, traceMapper);\n+    } else { // if the mapper is null, then there's no agent running, so we should drop\n+      log.debug(\"dropping {} traces because no agent was detected\", 1);\n+    }\n+    ++representativeCount;\n+  }\n+\n+  private void selectTraceMapper() {\n+    if (null == traceMapper) {\n+      this.traceMapper = api.selectTraceMapper();\n+      if (null == packer) {\n+        this.packer = new Packer(this, ByteBuffer.allocate(DEFAULT_BUFFER_SIZE));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void accept(int messageCount, ByteBuffer buffer) {\n+    // the packer calls this when the buffer is full,\n+    // or when the packer is flushed at a heartbeat\n+    if (messageCount > 0) {\n+      final int sizeInBytes = buffer.limit() - buffer.position();\n+      monitor.onSerialize(sizeInBytes);", "originalCommit": "d78961ae741e64a53339251a449be3251f3057db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NTYyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464465625", "bodyText": "I think so, yes", "author": "richardstartin", "createdAt": "2020-08-03T14:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NjExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDM3NzM0NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1679#discussion_r464377345", "bodyText": "Perhaps move out the magic 20 to a constant since its use is now split over multiple files?", "author": "bantonsson", "createdAt": "2020-08-03T12:20:27Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Util.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.core.serialization.msgpack;\n+\n+public class Util {\n+\n+  private static final byte[] DIGIT_TENS = {\n+    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n+    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n+    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n+    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n+    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n+    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n+    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n+    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n+    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n+    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n+  };\n+\n+  private static final byte[] DIGIT_ONES = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+  };\n+\n+  public static void writeLongAsString(\n+      final long value, final Writable destination, byte[] numberByteArray) {\n+    int pos = 20; // start from the end", "originalCommit": "d78961ae741e64a53339251a449be3251f3057db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92c1fa4a45ffda761b3a962ecf7f3733f754a4ec", "url": "https://github.com/DataDog/dd-trace-java/commit/92c1fa4a45ffda761b3a962ecf7f3733f754a4ec", "message": "add trace format discovery mechanism", "committedDate": "2020-08-04T08:42:39Z", "type": "commit"}, {"oid": "25fe8c64d2d638f0e85b51dcc8bff584077b0b50", "url": "https://github.com/DataDog/dd-trace-java/commit/25fe8c64d2d638f0e85b51dcc8bff584077b0b50", "message": "remove unused DDAgentWriter from Monitor methods which avoids unsafe publication of", "committedDate": "2020-08-04T08:42:39Z", "type": "commit"}, {"oid": "15145476906c9b4ea26a15edda4e6d0298bd7a33", "url": "https://github.com/DataDog/dd-trace-java/commit/15145476906c9b4ea26a15edda4e6d0298bd7a33", "message": "dictionary encode trace messages", "committedDate": "2020-08-04T08:43:08Z", "type": "commit"}, {"oid": "073061368a828e5d1171f81211f48bee4ebd42d7", "url": "https://github.com/DataDog/dd-trace-java/commit/073061368a828e5d1171f81211f48bee4ebd42d7", "message": "port baggage overlap to v0.5", "committedDate": "2020-08-04T08:43:11Z", "type": "commit"}, {"oid": "76784e2406dc7577cdfbda7f89be588cbb87be00", "url": "https://github.com/DataDog/dd-trace-java/commit/76784e2406dc7577cdfbda7f89be588cbb87be00", "message": "ensure dictionary encoded values are never null", "committedDate": "2020-08-04T08:43:11Z", "type": "commit"}, {"oid": "c01b20672eae92275cb1f038d2b7800a30444d2f", "url": "https://github.com/DataDog/dd-trace-java/commit/c01b20672eae92275cb1f038d2b7800a30444d2f", "message": "review comments", "committedDate": "2020-08-04T08:59:36Z", "type": "forcePushed"}, {"oid": "848d02b258e5a1d2cfe38820d3ab58aa63a923f1", "url": "https://github.com/DataDog/dd-trace-java/commit/848d02b258e5a1d2cfe38820d3ab58aa63a923f1", "message": "introduce DDSpanData to make it possible to test trace processing without creating a tracer or pending trace", "committedDate": "2020-08-04T09:11:10Z", "type": "commit"}, {"oid": "0a3f467a43af02d427538b5f1a14efd267da3719", "url": "https://github.com/DataDog/dd-trace-java/commit/0a3f467a43af02d427538b5f1a14efd267da3719", "message": "add subsystem PBT for dictionary encoded payloads, fix dictionary flushing behaviour", "committedDate": "2020-08-04T09:11:10Z", "type": "commit"}, {"oid": "4b9ebeb37392d865e802771fc5833c7456e43656", "url": "https://github.com/DataDog/dd-trace-java/commit/4b9ebeb37392d865e802771fc5833c7456e43656", "message": "post rebase spotless", "committedDate": "2020-08-04T09:11:10Z", "type": "commit"}, {"oid": "abd86a5a5ce933a25a3b08f3b1cba37d02cfb8b7", "url": "https://github.com/DataDog/dd-trace-java/commit/abd86a5a5ce933a25a3b08f3b1cba37d02cfb8b7", "message": "select different buffer sizes depending on format", "committedDate": "2020-08-04T09:11:10Z", "type": "commit"}, {"oid": "ea4d181f02f7f6fea6455ca83b9466ffc5a37d75", "url": "https://github.com/DataDog/dd-trace-java/commit/ea4d181f02f7f6fea6455ca83b9466ffc5a37d75", "message": "review comments", "committedDate": "2020-08-04T09:11:10Z", "type": "commit"}, {"oid": "8d031d81eba76ecd3fdc4eb772ba462644b4a4b7", "url": "https://github.com/DataDog/dd-trace-java/commit/8d031d81eba76ecd3fdc4eb772ba462644b4a4b7", "message": "revapi", "committedDate": "2020-08-04T09:12:11Z", "type": "forcePushed"}, {"oid": "9ea345cffe816446bad6ae091c262ba50d9cddd2", "url": "https://github.com/DataDog/dd-trace-java/commit/9ea345cffe816446bad6ae091c262ba50d9cddd2", "message": "revapi", "committedDate": "2020-08-04T09:33:22Z", "type": "commit"}, {"oid": "9ea345cffe816446bad6ae091c262ba50d9cddd2", "url": "https://github.com/DataDog/dd-trace-java/commit/9ea345cffe816446bad6ae091c262ba50d9cddd2", "message": "revapi", "committedDate": "2020-08-04T09:33:22Z", "type": "forcePushed"}]}