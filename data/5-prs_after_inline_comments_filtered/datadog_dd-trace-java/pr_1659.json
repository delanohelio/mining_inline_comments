{"pr_number": 1659, "pr_title": "replace msgpack-java", "pr_createdAt": "2020-07-07T17:51:55Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1659", "timeline": [{"oid": "bb788929a76c264ca5713842ec9c4a290caeda1a", "url": "https://github.com/DataDog/dd-trace-java/commit/bb788929a76c264ca5713842ec9c4a290caeda1a", "message": "replace msgpack-java", "committedDate": "2020-07-07T21:54:36Z", "type": "forcePushed"}, {"oid": "c564e337f16789c0caeaf54f5ffa2cf0b688afff", "url": "https://github.com/DataDog/dd-trace-java/commit/c564e337f16789c0caeaf54f5ffa2cf0b688afff", "message": "replace msgpack-java", "committedDate": "2020-07-07T22:03:30Z", "type": "forcePushed"}, {"oid": "0a6b4e23931a2cc25cd1d9b3274192913feb6cd7", "url": "https://github.com/DataDog/dd-trace-java/commit/0a6b4e23931a2cc25cd1d9b3274192913feb6cd7", "message": "replace msgpack-java", "committedDate": "2020-07-08T04:26:07Z", "type": "forcePushed"}, {"oid": "4dd504b6ca8d9331fd2b84fed2b079f367c023c8", "url": "https://github.com/DataDog/dd-trace-java/commit/4dd504b6ca8d9331fd2b84fed2b079f367c023c8", "message": "replace msgpack-java", "committedDate": "2020-07-08T04:37:15Z", "type": "forcePushed"}, {"oid": "543af4cb02554768f73c51d9dfec8bca66fd246d", "url": "https://github.com/DataDog/dd-trace-java/commit/543af4cb02554768f73c51d9dfec8bca66fd246d", "message": "replace msgpack-java", "committedDate": "2020-07-08T04:55:51Z", "type": "forcePushed"}, {"oid": "2d7c893ebb83bf94ddbe238917f70a4e24b034fb", "url": "https://github.com/DataDog/dd-trace-java/commit/2d7c893ebb83bf94ddbe238917f70a4e24b034fb", "message": "revapi", "committedDate": "2020-07-08T05:09:18Z", "type": "forcePushed"}, {"oid": "070dd0b07d3741620c4c533c1098718d12fed3d0", "url": "https://github.com/DataDog/dd-trace-java/commit/070dd0b07d3741620c4c533c1098718d12fed3d0", "message": "revapi", "committedDate": "2020-07-08T14:27:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1MTM5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r451651396", "bodyText": "Nit: Isn't this functionally equivalent to l % 100?", "author": "jbachorik", "createdAt": "2020-07-08T15:54:54Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceMapper.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package datadog.trace.common.writer.ddagent;\n+\n+import static datadog.trace.core.StringTables.DURATION;\n+import static datadog.trace.core.StringTables.ERROR;\n+import static datadog.trace.core.StringTables.META;\n+import static datadog.trace.core.StringTables.METRICS;\n+import static datadog.trace.core.StringTables.NAME;\n+import static datadog.trace.core.StringTables.PARENT_ID;\n+import static datadog.trace.core.StringTables.RESOURCE;\n+import static datadog.trace.core.StringTables.SERVICE;\n+import static datadog.trace.core.StringTables.SPAN_ID;\n+import static datadog.trace.core.StringTables.START;\n+import static datadog.trace.core.StringTables.TRACE_ID;\n+import static datadog.trace.core.StringTables.TYPE;\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.CONSTANT_KEYS;\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.CONSTANT_TAGS;\n+import static datadog.trace.core.serialization.msgpack.EncodingCachingStrategies.NO_CACHING;\n+\n+import datadog.trace.core.DDSpan;\n+import datadog.trace.core.serialization.msgpack.Mapper;\n+import datadog.trace.core.serialization.msgpack.Writable;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class TraceMapper implements Mapper<List<DDSpan>> {\n+  @Override\n+  public void map(List<DDSpan> trace, Writable writable) {\n+    writable.startArray(trace.size());\n+    for (DDSpan span : trace) {\n+      writable.startMap(12);\n+      /* 1  */\n+      writable.writeUTF8(SERVICE);\n+      writable.writeString(span.getServiceName(), CONSTANT_TAGS);\n+      /* 2  */\n+      writable.writeUTF8(NAME);\n+      writable.writeString(span.getOperationName(), CONSTANT_TAGS);\n+      /* 3  */\n+      writable.writeUTF8(RESOURCE);\n+      writable.writeString(span.getResourceName(), NO_CACHING);\n+      /* 4  */\n+      writable.writeUTF8(TRACE_ID);\n+      writable.writeLong(span.getTraceId().toLong());\n+      /* 5  */\n+      writable.writeUTF8(SPAN_ID);\n+      writable.writeLong(span.getSpanId().toLong());\n+      /* 6  */\n+      writable.writeUTF8(PARENT_ID);\n+      writable.writeLong(span.getParentId().toLong());\n+      /* 7  */\n+      writable.writeUTF8(START);\n+      writable.writeLong(span.getStartTime());\n+      /* 8  */\n+      writable.writeUTF8(DURATION);\n+      writable.writeLong(span.getDurationNano());\n+      /* 9  */\n+      writable.writeUTF8(TYPE);\n+      writable.writeString(span.getType(), CONSTANT_TAGS);\n+      /* 10 */\n+      writable.writeUTF8(ERROR);\n+      writable.writeInt(span.getError());\n+      /* 11 */\n+      writable.writeUTF8(METRICS);\n+      writable.writeMap(span.getMetrics(), CONSTANT_KEYS);\n+      /* 12 */\n+      writable.writeUTF8(META);\n+      Map<String, String> baggage = span.context().getBaggageItems();\n+      Map<String, Object> tags = span.context().getTags();\n+      writable.startMap(baggage.size() + tags.size());\n+      for (Map.Entry<String, String> entry : baggage.entrySet()) {\n+        // tags and baggage may intersect, but tags take priority\n+        if (!tags.containsKey(entry.getKey())) {\n+          writable.writeString(entry.getKey(), CONSTANT_KEYS);\n+          writable.writeObject(entry.getValue(), NO_CACHING);\n+        }\n+      }\n+      for (Map.Entry<String, Object> entry : tags.entrySet()) {\n+        writable.writeString(entry.getKey(), CONSTANT_KEYS);\n+        if (entry.getValue() instanceof Long || entry.getValue() instanceof Integer) {\n+          // TODO it would be nice not to need to do this, either because\n+          //  the agent would accept variably typed tag values, or numeric\n+          //  tags get moved to the metrics\n+          writeLongAsString(((Number) entry.getValue()).longValue(), writable);\n+        } else {\n+          writable.writeString(String.valueOf(entry.getValue()), NO_CACHING);\n+        }\n+      }\n+    }\n+  }\n+\n+  private static final byte[] DIGIT_TENS = {\n+    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n+    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n+    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n+    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n+    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n+    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n+    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n+    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n+    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n+    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n+  };\n+\n+  private static final byte[] DIGIT_ONES = {\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+  };\n+\n+  private final byte[] numberByteArray = new byte[20]; // this is max long digits and sign\n+\n+  private void writeLongAsString(final long value, final Writable destination) {\n+    int pos = 20; // start from the end\n+    long l = value;\n+    boolean negative = (l < 0);\n+    if (!negative) {\n+      l = -l; // do the conversion on negative values to not overflow Long.MIN_VALUE\n+    }\n+\n+    int r;\n+    // convert 2 digits per iteration with longs until quotient fits into an int\n+    long lq;\n+    while (l <= Integer.MIN_VALUE) {\n+      lq = l / 100;\n+      r = (int) ((lq * 100) - l);", "originalCommit": "070dd0b07d3741620c4c533c1098718d12fed3d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1NjM5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r451656394", "bodyText": "This isn't new code. cc @bantonsson :)", "author": "richardstartin", "createdAt": "2020-07-08T16:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1MTM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzOTMwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r460839307", "bodyText": "Sorry for being late to the game. Was on vacation.\nYes, and no. This is a modulo operation, but since l has been swapped to negative numbers this is more like 100 - (l % 100). The reason to reuse lq in this way is that lq is an input to the next iteration so we need to compute it anyway, as well as a division (modulo) would either have been optimized into something similar to this for speed, or if the div instruction is used, it would be at least 5 times slower than a mul.", "author": "bantonsson", "createdAt": "2020-07-27T11:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1MTM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4MTYyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r451681620", "bodyText": "Would it make sense to pre-fill the known mappings into the config map?", "author": "jbachorik", "createdAt": "2020-07-08T16:41:05Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Codec.java", "diffHunk": "@@ -0,0 +1,281 @@\n+package datadog.trace.core.serialization.msgpack;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+public final class Codec extends ClassValue<Writer<?>> {\n+\n+  public static final Codec INSTANCE = new Codec();\n+\n+  private final Map<Class<?>, Writer<?>> config;\n+\n+  public Codec(Map<Class<?>, Writer<?>> config) {\n+    this.config = config;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public Codec() {\n+    this(Collections.<Class<?>, Writer<?>>emptyMap());\n+  }\n+\n+  @Override\n+  protected Writer<?> computeValue(Class<?> clazz) {\n+    Writer<?> writer = config.get(clazz);\n+    if (null != writer) {\n+      return writer;\n+    }\n+    if (Number.class.isAssignableFrom(clazz)) {\n+      if (Double.class == clazz) {\n+        return new DoubleWriter();\n+      }\n+      if (Float.class == clazz) {\n+        return new FloatWriter();\n+      }\n+      if (Integer.class == clazz) {\n+        return new IntWriter();\n+      }\n+      if (Long.class == clazz) {\n+        return new LongWriter();\n+      }\n+      if (Short.class == clazz) {\n+        return new ShortWriter();\n+      }\n+    }\n+    if (clazz.isArray()) {\n+      if (byte[].class == clazz) {\n+        return new ByteArrayWriter();\n+      }\n+      if (int[].class == clazz) {\n+        return new IntArrayWriter();\n+      }\n+      if (long[].class == clazz) {\n+        return new LongArrayWriter();\n+      }\n+      if (double[].class == clazz) {\n+        return new DoubleArrayWriter();\n+      }\n+      if (float[].class == clazz) {\n+        return new FloatArrayWriter();\n+      }\n+      if (short[].class == clazz) {\n+        return new ShortArrayWriter();\n+      }\n+      if (char[].class == clazz) {\n+        return new CharArrayWriter();\n+      }\n+      if (boolean[].class == clazz) {\n+        return new BooleanArrayWriter();\n+      }\n+      return new ObjectArrayWriter();\n+    }\n+    if (Boolean.class == clazz) {\n+      return new BooleanWriter();\n+    }\n+    if (CharSequence.class.isAssignableFrom(clazz)) {\n+      return CharSequenceWriter.INSTANCE;\n+    }\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      return new MapWriter();\n+    }\n+    if (Collection.class.isAssignableFrom(clazz)) {\n+      return new CollectionWriter();\n+    }\n+    if (ByteBuffer.class.isAssignableFrom(clazz)) {\n+      return new ByteBufferWriter();\n+    }", "originalCommit": "070dd0b07d3741620c4c533c1098718d12fed3d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAzNDIwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452034202", "bodyText": "I might end with almost as much code as there is here. Worth trying though.", "author": "richardstartin", "createdAt": "2020-07-09T07:58:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4MTYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI2ODkxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452268915", "bodyText": "The comment here is wrong now...  want to document the reason for this choice?", "author": "tylerbenson", "createdAt": "2020-07-09T14:41:16Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingDisruptor.java", "diffHunk": "@@ -55,10 +58,9 @@ public TraceProcessingDisruptor(\n             ProducerType.MULTI,\n             // use sleeping wait strategy because it reduces CPU usage,\n             // and is cheaper for application threads publishing traces\n-            new SleepingWaitStrategy(0, MILLISECONDS.toNanos(10)));\n+            new BlockingWaitStrategy());", "originalCommit": "05c04dcd56eab6ab7bf82dfc5c82970ebb9d8bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3ODk2MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452278961", "bodyText": "Does this mean the trace that triggers the exception will be serialized twice?  Perhaps there should be a buffer to avoid relying on the exception?  ie, flush if the payload exceeds x, but allow it to go over by y.\nAlso, wouldn't messageCount be off by one at this point?", "author": "tylerbenson", "createdAt": "2020-07-09T14:54:15Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Packer.java", "diffHunk": "@@ -0,0 +1,695 @@\n+package datadog.trace.core.serialization.msgpack;\n+\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+\n+/** Not thread-safe (use one per thread). */\n+public class Packer implements Writable, MessageFormatter {\n+\n+  private static final int UTF8_BUFFER_SIZE = 8;\n+  private static final int MAX_ARRAY_HEADER_SIZE = 5;\n+\n+  // see https://github.com/msgpack/msgpack/blob/master/spec.md\n+  private static final byte NULL = (byte) 0xC0;\n+\n+  private static final byte FALSE = (byte) 0xC2;\n+  private static final byte TRUE = (byte) 0xC3;\n+\n+  private static final byte UINT8 = (byte) 0xCC;\n+  private static final byte UINT16 = (byte) 0xCD;\n+  private static final byte UINT32 = (byte) 0xCE;\n+  private static final byte UINT64 = (byte) 0xCF;\n+\n+  private static final byte INT8 = (byte) 0xD0;\n+  private static final byte INT16 = (byte) 0xD1;\n+  private static final byte INT32 = (byte) 0xD2;\n+  private static final byte INT64 = (byte) 0xD3;\n+\n+  private static final byte FLOAT32 = (byte) 0xCA;\n+  private static final byte FLOAT64 = (byte) 0xCB;\n+\n+  private static final byte STR8 = (byte) 0xD9;\n+  private static final byte STR16 = (byte) 0xDA;\n+  private static final byte STR32 = (byte) 0xDB;\n+\n+  private static final byte BIN8 = (byte) 0xC4;\n+  private static final byte BIN16 = (byte) 0xC5;\n+  private static final byte BIN32 = (byte) 0xC6;\n+\n+  private static final byte ARRAY16 = (byte) 0xDC;\n+  private static final byte ARRAY32 = (byte) 0xDD;\n+\n+  private static final byte MAP16 = (byte) 0xDE;\n+  private static final byte MAP32 = (byte) 0xDF;\n+\n+  private static final int NEGFIXNUM = 0xE0;\n+  private static final int FIXSTR = 0xA0;\n+  private static final int FIXARRAY = 0x90;\n+  private static final int FIXMAP = 0x80;\n+\n+  private final Codec codec;\n+\n+  private final ByteBufferConsumer sink;\n+  private final ByteBuffer buffer;\n+  private int messageCount = 0;\n+\n+  private final byte[] utf8Buffer = new byte[UTF8_BUFFER_SIZE * 4];\n+\n+  public Packer(Codec codec, ByteBufferConsumer sink, ByteBuffer buffer) {\n+    this.codec = codec;\n+    this.sink = sink;\n+    this.buffer = buffer;\n+    this.buffer.position(MAX_ARRAY_HEADER_SIZE);\n+    buffer.mark();\n+  }\n+\n+  public Packer(ByteBufferConsumer sink, ByteBuffer buffer) {\n+    this(Codec.INSTANCE, sink, buffer);\n+  }\n+\n+  @Override\n+  public <T> void format(T message, Mapper<T> mapper) {\n+    try {\n+      mapper.map(message, this);\n+      buffer.mark();\n+      ++messageCount;\n+    } catch (BufferOverflowException e) {", "originalCommit": "05c04dcd56eab6ab7bf82dfc5c82970ebb9d8bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI5NTAzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452295037", "bodyText": "No, maybe I should add a comment.\nWhat happens here is when an entire message is put into the buffer (i.e. it's possible without overflow) the buffer gets marked (i.e. take a snapshot of the buffer's current position, where the next message would start), which is important. When there is overflow, the buffer is reset, so the position is restored to that snapshot. Now there are two cases:\n\nThat snapshot position is the start of the buffer, so the object being mapped is larger than we have space for. This is unrecoverable, and we're relying on this not being possible.\nOtherwise, the snapshot position is where the last successfully written message ended. If we flip the buffer, it can be dispatched. After it's been dispatched, we can write the message which caused the overflow into the now reset buffer.\n\nSo, crucially, messageCountcan't have been incremented if we reach the catch block. Does that make sense?", "author": "richardstartin", "createdAt": "2020-07-09T15:16:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQyOTQyMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452429422", "bodyText": "oh, right... I see.  If the exception is thrown, then messageCount won't have been incremented.  Probably good to comment inline.  I still don't understand why it wouldn't result in duplicate serialization though.", "author": "tylerbenson", "createdAt": "2020-07-09T19:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3ODk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzNzQ3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452437479", "bodyText": "I don't see how the above doesn't explain it, given some understanding of ByteBuffer.\n\nByteBuffer.mark records the current position, stored in a field called mark\nByteBuffer.reset sets position to mark - it effectively undoes any operation since the last mark() call.\nByteBuffer.flip sets limit to position, sets position to zero\nByteBuffer.slice creates a view over the buffer between position and limit\n\nOnly successfully serialised records get marked. If an attempt is made to serialise a record and the buffer overflows, whatever's in the buffer since the last mark will be discarded; it won't be in the slice created in flush. Unsuccessful serialisation attempts are repeated after flushing when there's room to accommodate the record.", "author": "richardstartin", "createdAt": "2020-07-09T19:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3ODk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3OTQwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452279406", "bodyText": "what is this for?", "author": "tylerbenson", "createdAt": "2020-07-09T14:54:52Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/Packer.java", "diffHunk": "@@ -0,0 +1,695 @@\n+package datadog.trace.core.serialization.msgpack;\n+\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+\n+/** Not thread-safe (use one per thread). */\n+public class Packer implements Writable, MessageFormatter {\n+\n+  private static final int UTF8_BUFFER_SIZE = 8;\n+  private static final int MAX_ARRAY_HEADER_SIZE = 5;\n+\n+  // see https://github.com/msgpack/msgpack/blob/master/spec.md\n+  private static final byte NULL = (byte) 0xC0;\n+\n+  private static final byte FALSE = (byte) 0xC2;\n+  private static final byte TRUE = (byte) 0xC3;\n+\n+  private static final byte UINT8 = (byte) 0xCC;\n+  private static final byte UINT16 = (byte) 0xCD;\n+  private static final byte UINT32 = (byte) 0xCE;\n+  private static final byte UINT64 = (byte) 0xCF;\n+\n+  private static final byte INT8 = (byte) 0xD0;\n+  private static final byte INT16 = (byte) 0xD1;\n+  private static final byte INT32 = (byte) 0xD2;\n+  private static final byte INT64 = (byte) 0xD3;\n+\n+  private static final byte FLOAT32 = (byte) 0xCA;\n+  private static final byte FLOAT64 = (byte) 0xCB;\n+\n+  private static final byte STR8 = (byte) 0xD9;\n+  private static final byte STR16 = (byte) 0xDA;\n+  private static final byte STR32 = (byte) 0xDB;\n+\n+  private static final byte BIN8 = (byte) 0xC4;\n+  private static final byte BIN16 = (byte) 0xC5;\n+  private static final byte BIN32 = (byte) 0xC6;\n+\n+  private static final byte ARRAY16 = (byte) 0xDC;\n+  private static final byte ARRAY32 = (byte) 0xDD;\n+\n+  private static final byte MAP16 = (byte) 0xDE;\n+  private static final byte MAP32 = (byte) 0xDF;\n+\n+  private static final int NEGFIXNUM = 0xE0;\n+  private static final int FIXSTR = 0xA0;\n+  private static final int FIXARRAY = 0x90;\n+  private static final int FIXMAP = 0x80;\n+\n+  private final Codec codec;\n+\n+  private final ByteBufferConsumer sink;\n+  private final ByteBuffer buffer;\n+  private int messageCount = 0;\n+\n+  private final byte[] utf8Buffer = new byte[UTF8_BUFFER_SIZE * 4];\n+\n+  public Packer(Codec codec, ByteBufferConsumer sink, ByteBuffer buffer) {\n+    this.codec = codec;\n+    this.sink = sink;\n+    this.buffer = buffer;\n+    this.buffer.position(MAX_ARRAY_HEADER_SIZE);\n+    buffer.mark();\n+  }\n+\n+  public Packer(ByteBufferConsumer sink, ByteBuffer buffer) {\n+    this(Codec.INSTANCE, sink, buffer);\n+  }\n+\n+  @Override\n+  public <T> void format(T message, Mapper<T> mapper) {\n+    try {\n+      mapper.map(message, this);\n+      buffer.mark();\n+      ++messageCount;\n+    } catch (BufferOverflowException e) {\n+      // go back to the last successfully written message\n+      buffer.reset();\n+      if (buffer.position() == MAX_ARRAY_HEADER_SIZE) {\n+        throw e;\n+      }\n+      flush();\n+      format(message, mapper);\n+    }\n+  }\n+\n+  @Override\n+  public void flush() {\n+    buffer.flip();", "originalCommit": "05c04dcd56eab6ab7bf82dfc5c82970ebb9d8bee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI5NTYzMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452295632", "bodyText": "https://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#flip()", "author": "richardstartin", "createdAt": "2020-07-09T15:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3OTQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQzMDM1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452430353", "bodyText": "so buffer is a circular structure, where the index 0 isn't necessarily the beginning of the buffer?", "author": "tylerbenson", "createdAt": "2020-07-09T19:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3OTQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4NzA5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452487093", "bodyText": "nah", "author": "richardstartin", "createdAt": "2020-07-09T21:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI3OTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI4MzY4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452283684", "bodyText": "So this is now a blocking call that might trigger IO, right?  Can you add a comment to that effect because that isn't obvious from the method name.", "author": "tylerbenson", "createdAt": "2020-07-09T15:00:19Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingDisruptor.java", "diffHunk": "@@ -174,43 +177,10 @@ public void onEvent(\n       }\n     }\n \n-    private void serialize(List<DDSpan> trace, int representativeCount) throws IOException {\n+    private void serialize(List<DDSpan> trace, int representativeCount) {\n       // TODO populate `_sample_rate` metric in a way that accounts for lost/dropped traces\n+      packer.format(processor.onTraceComplete(trace), traceMapper);", "originalCommit": "05c04dcd56eab6ab7bf82dfc5c82970ebb9d8bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI4NDczOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1659#discussion_r452284739", "bodyText": "or when flush is called via heartbeat.", "author": "tylerbenson", "createdAt": "2020-07-09T15:01:43Z", "path": "dd-trace-core/src/main/java/datadog/trace/common/writer/ddagent/TraceProcessingDisruptor.java", "diffHunk": "@@ -223,6 +193,33 @@ private long millisecondTime() {\n       // important: nanoTime is monotonic, currentTimeMillis is not\n       return NANOSECONDS.toMillis(System.nanoTime());\n     }\n+\n+    @Override\n+    public void accept(int messageCount, ByteBuffer buffer) {\n+      // the packer calls this when the buffer is full", "originalCommit": "05c04dcd56eab6ab7bf82dfc5c82970ebb9d8bee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66942b49b03c446a17900364f1101e58b8cf16f8", "url": "https://github.com/DataDog/dd-trace-java/commit/66942b49b03c446a17900364f1101e58b8cf16f8", "message": "clarifying comments", "committedDate": "2020-07-09T15:52:25Z", "type": "forcePushed"}, {"oid": "756dbae8c3aa0f61f9aafc5f252d3dbee7087f32", "url": "https://github.com/DataDog/dd-trace-java/commit/756dbae8c3aa0f61f9aafc5f252d3dbee7087f32", "message": "clarifying comments", "committedDate": "2020-07-09T16:01:25Z", "type": "forcePushed"}, {"oid": "21d00d46b6a04aebc8ddbe06d3212a18fc992ec0", "url": "https://github.com/DataDog/dd-trace-java/commit/21d00d46b6a04aebc8ddbe06d3212a18fc992ec0", "message": "clarifying comments", "committedDate": "2020-07-09T17:38:33Z", "type": "forcePushed"}, {"oid": "714fc96c33bb1bea0867c9663270b279d790d143", "url": "https://github.com/DataDog/dd-trace-java/commit/714fc96c33bb1bea0867c9663270b279d790d143", "message": "clarifying comments", "committedDate": "2020-07-09T17:51:45Z", "type": "forcePushed"}, {"oid": "446aab6acb84acc5660b925854a049be22af6f61", "url": "https://github.com/DataDog/dd-trace-java/commit/446aab6acb84acc5660b925854a049be22af6f61", "message": "clarifying comments", "committedDate": "2020-07-09T18:57:36Z", "type": "forcePushed"}, {"oid": "78727c25c20e0782b1636a04b32fed8fa1f68802", "url": "https://github.com/DataDog/dd-trace-java/commit/78727c25c20e0782b1636a04b32fed8fa1f68802", "message": "replace msgpack-java", "committedDate": "2020-07-09T19:56:52Z", "type": "commit"}, {"oid": "0548a7b60d7c484f778f33b971206a9ad14281c6", "url": "https://github.com/DataDog/dd-trace-java/commit/0548a7b60d7c484f778f33b971206a9ad14281c6", "message": "clarifying comments", "committedDate": "2020-07-09T19:56:52Z", "type": "forcePushed"}, {"oid": "19f1198f40c15c2aed754225b96080fc60703a5c", "url": "https://github.com/DataDog/dd-trace-java/commit/19f1198f40c15c2aed754225b96080fc60703a5c", "message": "special case for UTF8ByteString for now", "committedDate": "2020-07-09T21:33:58Z", "type": "commit"}, {"oid": "e13f19f9f27c8718e3ac5c4b60ccdd0abcbba631", "url": "https://github.com/DataDog/dd-trace-java/commit/e13f19f9f27c8718e3ac5c4b60ccdd0abcbba631", "message": "clarifying comments", "committedDate": "2020-07-09T21:33:58Z", "type": "commit"}, {"oid": "3a02905de4b38c7996ff961cca0965c72b6f7cd6", "url": "https://github.com/DataDog/dd-trace-java/commit/3a02905de4b38c7996ff961cca0965c72b6f7cd6", "message": "revapi, again", "committedDate": "2020-07-09T21:36:33Z", "type": "commit"}, {"oid": "3a02905de4b38c7996ff961cca0965c72b6f7cd6", "url": "https://github.com/DataDog/dd-trace-java/commit/3a02905de4b38c7996ff961cca0965c72b6f7cd6", "message": "revapi, again", "committedDate": "2020-07-09T21:36:33Z", "type": "forcePushed"}, {"oid": "11016b1bbc8435aa6b848dd6cf7816a6024e03d9", "url": "https://github.com/DataDog/dd-trace-java/commit/11016b1bbc8435aa6b848dd6cf7816a6024e03d9", "message": "Merge branch 'master' into rgs/msgpack", "committedDate": "2020-07-09T22:23:28Z", "type": "commit"}]}