{"pr_number": 2061, "pr_title": "Aerospike 4 instrumentation", "pr_createdAt": "2020-11-09T14:50:06Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2061", "timeline": [{"oid": "d279f880a180dec6d39c666af1ce3f172abf3b7a", "url": "https://github.com/DataDog/dd-trace-java/commit/d279f880a180dec6d39c666af1ce3f172abf3b7a", "message": "Aerospike direct NioEventLoop instrumentation", "committedDate": "2020-11-09T14:51:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MDMzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519880335", "bodyText": "Is injecting Runnable absolutely necessary? We're trying to migrate away from doing this at all.", "author": "richardstartin", "createdAt": "2020-11-09T15:03:34Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/NioEventLoopInstrumentation.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public final class NioEventLoopInstrumentation extends Instrumenter.Default {\n+  public NioEventLoopInstrumentation() {\n+    super(\"aerospike\", \"java_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"com.aerospike.client.async.NioEventLoop\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStoreForAll() {\n+    return singletonMap(Runnable.class.getName(), State.class.getName());", "originalCommit": "d279f880a180dec6d39c666af1ce3f172abf3b7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5MjQ3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519892476", "bodyText": "I'm open to suggestions - Aerospike has a direct-NIO event loop that's closely modelled on the Netty event loop, but doesn't implement Executor. Given the similarity I re-used the approach taken for the Netty event loop. Is there a different approach that we'll be using in the future for executor-like classes?", "author": "mcculls", "createdAt": "2020-11-09T15:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5NzE5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519897196", "bodyText": "I think the simplest approach would be to wrap in java.util.concurrent.FutureTask having looked at the source code of NioEventLoop - context will get captured in its constructor and activated for when it's run, and there are no cases where the type of the Runnable is checked.", "author": "richardstartin", "createdAt": "2020-11-09T15:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MDMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk5ODU2OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519998568", "bodyText": "confirmed simple wrapping works - thanks", "author": "mcculls", "createdAt": "2020-11-09T17:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MDMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MjE5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519882196", "bodyText": "How do we know this is safe to do? Is there a strict natural limit imposed elsewhere?", "author": "richardstartin", "createdAt": "2020-11-09T15:06:07Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/TracingListenerHelper.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import com.aerospike.client.listener.BatchListListener;\n+import com.aerospike.client.listener.BatchSequenceListener;\n+import com.aerospike.client.listener.DeleteListener;\n+import com.aerospike.client.listener.ExecuteListener;\n+import com.aerospike.client.listener.ExistsArrayListener;\n+import com.aerospike.client.listener.ExistsListener;\n+import com.aerospike.client.listener.ExistsSequenceListener;\n+import com.aerospike.client.listener.RecordArrayListener;\n+import com.aerospike.client.listener.RecordListener;\n+import com.aerospike.client.listener.RecordSequenceListener;\n+import com.aerospike.client.listener.WriteListener;\n+import datadog.trace.api.Function;\n+import datadog.trace.api.cache.DDCache;\n+import datadog.trace.api.cache.DDCaches;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+\n+public final class TracingListenerHelper implements Function<String, String> {\n+  public static final TracingListenerHelper INSTANCE = new TracingListenerHelper();\n+\n+  private static final String LISTENER_PKG_PREFIX = \"com.aerospike.client.listener.\";\n+\n+  private static final DDCache<String, String> LISTENER_NAME_CACHE = DDCaches.newUnboundedCache(16);", "originalCommit": "d279f880a180dec6d39c666af1ce3f172abf3b7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4NDA3MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519884070", "bodyText": "This comes from the method signature so this seems like a safe choice", "author": "richardstartin", "createdAt": "2020-11-09T15:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MjE5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkwMjA0NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519902044", "bodyText": "The instrumented Aerospike client has a fixed number of method signatures involving listeners - these vary over releases (last I checked there were 24) so I was reluctant to impose a fixed limit. And a lot of the time only a few methods are actually used from the client.\nUnfortunately none of the listener types share an interface or base class, so we either have to dynamically deduce the listener type or statically have multiple advice classes. We'd end up with one per listener type, so 11 advice classes.\nIt's also possible for null listeners to be passed in (fire and forget scenario) so we can't always rely on the incoming listener type. AFAIK ByteBuddy doesn't give us the instrumented parameter type (only string representations) we end up having to match the method signature to the listener type.", "author": "mcculls", "createdAt": "2020-11-09T15:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4MjE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4NjEzMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519886131", "bodyText": "Just an idea. I like giving the advice class a verb name which I find makes reading this method a bit easier. On the left hand side you have the constraints for what this will match, and on the right a description of what it will do when it matches, rather than just the name of the class the code sits in.", "author": "richardstartin", "createdAt": "2020-11-09T15:11:28Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/NodeInstrumentation.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.instrumentation.aerospike4.AerospikeClientDecorator.DECORATE;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.aerospike.client.cluster.Node;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.DDSpanTypes;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public final class NodeInstrumentation extends Instrumenter.Default {\n+  public NodeInstrumentation() {\n+    super(\"aerospike\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"com.aerospike.client.cluster.Node\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AerospikeClientDecorator\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod().and(named(\"getConnection\")), getClass().getName() + \"$ConnectionAdvice\");", "originalCommit": "d279f880a180dec6d39c666af1ce3f172abf3b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4NzcwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519887700", "bodyText": "Why is this instrumentation necessary? Custom executor? If so, shouldn't com.aerospike.client.async.NioEventLoop be whitelisted in the Java executor instrumentation?", "author": "richardstartin", "createdAt": "2020-11-09T15:13:40Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/NioEventLoopInstrumentation.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExecutorInstrumentationUtils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.RunnableWrapper;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Map;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public final class NioEventLoopInstrumentation extends Instrumenter.Default {", "originalCommit": "d279f880a180dec6d39c666af1ce3f172abf3b7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5MjI1NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519892254", "bodyText": "I see the justification for doing this here - it's a completely custom executor, with no newTaskFor method. The executor instrumentation should just handle this case and wrap in a FutureTask which I think is preferable to field-injecting Runnable, since it looks safe to wrap commands there. If you keep this instrumentation for whatever reason (improved modularity perhaps) may I suggest you wrap in FutureTask on entry to execute and let the RunnableFuture instrumentation handle propagation instead?", "author": "richardstartin", "createdAt": "2020-11-09T15:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4NzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5NTQ1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519895451", "bodyText": "Aerospike ships with their own direct-NIO event loop which doesn't implement Executor or extend any of the ExecutorService types. I re-used the existing event loop approach because that appeared to be the direction we were taking for concurrent classes, but if that's not right then I'll see if I can make this more specific and potentially simplify things.\nPS. without this instrumentation we lose the active scope as the work passes through the Aerospike NIO event loop. (When Aerospike is configured to use Netty then we don't lose the scope because the existing Netty event loop code kicks in.)", "author": "mcculls", "createdAt": "2020-11-09T15:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4NzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5Nzc3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519897777", "bodyText": "Let me know if wrapping in FutureTask doesn't propagate context here.", "author": "richardstartin", "createdAt": "2020-11-09T15:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4NzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkwMjY2NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r519902664", "bodyText": "thanks for the suggestion, will do", "author": "mcculls", "createdAt": "2020-11-09T15:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg4NzcwMA=="}], "type": "inlineReview"}, {"oid": "ec5f0bae731cd65904375e674bc686c6b4ba50b9", "url": "https://github.com/DataDog/dd-trace-java/commit/ec5f0bae731cd65904375e674bc686c6b4ba50b9", "message": "Aerospike direct NioEventLoop instrumentation", "committedDate": "2020-11-09T17:36:42Z", "type": "forcePushed"}, {"oid": "652e4f6cce1d66ceed472b9004a701257d988764", "url": "https://github.com/DataDog/dd-trace-java/commit/652e4f6cce1d66ceed472b9004a701257d988764", "message": "Aerospike direct NioEventLoop instrumentation", "committedDate": "2020-11-09T17:52:00Z", "type": "forcePushed"}, {"oid": "8265c8daea8a8b8f4edfac080e60f96ee38a4f6e", "url": "https://github.com/DataDog/dd-trace-java/commit/8265c8daea8a8b8f4edfac080e60f96ee38a4f6e", "message": "Aerospike direct NioEventLoop instrumentation", "committedDate": "2020-11-09T17:58:27Z", "type": "forcePushed"}, {"oid": "64af5c7875fd2b18817f78ace16e6e7695b7114b", "url": "https://github.com/DataDog/dd-trace-java/commit/64af5c7875fd2b18817f78ace16e6e7695b7114b", "message": "Initial Aerospike tests", "committedDate": "2020-11-11T14:34:57Z", "type": "forcePushed"}, {"oid": "0c5b0871601bd2c5c4f8401c49bceef7362c17ce", "url": "https://github.com/DataDog/dd-trace-java/commit/0c5b0871601bd2c5c4f8401c49bceef7362c17ce", "message": "Initial Aerospike tests", "committedDate": "2020-11-11T15:11:58Z", "type": "forcePushed"}, {"oid": "7ce8eb40a6f3688f5a8c274d1a5b1f3236ebd923", "url": "https://github.com/DataDog/dd-trace-java/commit/7ce8eb40a6f3688f5a8c274d1a5b1f3236ebd923", "message": "Aerospike client tests", "committedDate": "2020-11-11T16:52:23Z", "type": "forcePushed"}, {"oid": "e828acb8079ca41afc32980d4fa906943bff83c8", "url": "https://github.com/DataDog/dd-trace-java/commit/e828acb8079ca41afc32980d4fa906943bff83c8", "message": "Aerospike client tests", "committedDate": "2020-11-11T17:36:21Z", "type": "forcePushed"}, {"oid": "8126ab4d967ae761fc2a4f164c0755d1a1c38e2f", "url": "https://github.com/DataDog/dd-trace-java/commit/8126ab4d967ae761fc2a4f164c0755d1a1c38e2f", "message": "Aerospike client tests", "committedDate": "2020-11-11T17:54:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMDkxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522030912", "bodyText": "DDSpanTypes.AEROSPIKE? (I know they're reversed, but I'm questioning why)", "author": "richardstartin", "createdAt": "2020-11-12T11:19:41Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/AerospikeClientDecorator.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+\n+import com.aerospike.client.AerospikeClient;\n+import com.aerospike.client.cluster.Cluster;\n+import com.aerospike.client.cluster.Node;\n+import com.aerospike.client.cluster.Partition;\n+import datadog.trace.api.Config;\n+import datadog.trace.api.DDSpanTypes;\n+import datadog.trace.api.DDTags;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+public class AerospikeClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Node> {\n+  public static final UTF8BytesString AEROSPIKE_JAVA =\n+      UTF8BytesString.createConstant(\"aerospike-java\");\n+\n+  public static final AerospikeClientDecorator DECORATE = new AerospikeClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"aerospike\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"aerospike\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return \"java-aerospike\";", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NTIwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522045207", "bodyText": "I was following other instrumentation, like cassandra, where they use \"java-{type}\" as the component - I assume this is to handle cases where other languages might instrument their drivers (Go, Python, etc.) and you want to disambiguate between them.", "author": "mcculls", "createdAt": "2020-11-12T11:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NzMwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522057306", "bodyText": "but I think I should be adding a UTF8ByteString constant here since this is a CharSequence return?", "author": "mcculls", "createdAt": "2020-11-12T12:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMDkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTk2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522075965", "bodyText": "I think we could just add another UTF8ByteString. Don't worry about using createConstant though, because I have found recently that was a well intentioned but counterproductive optimisation.", "author": "richardstartin", "createdAt": "2020-11-12T12:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMDkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMjE5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522032194", "bodyText": "How big a string does this allocate?", "author": "richardstartin", "createdAt": "2020-11-12T11:21:48Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/AerospikeClientDecorator.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+\n+import com.aerospike.client.AerospikeClient;\n+import com.aerospike.client.cluster.Cluster;\n+import com.aerospike.client.cluster.Node;\n+import com.aerospike.client.cluster.Partition;\n+import datadog.trace.api.Config;\n+import datadog.trace.api.DDSpanTypes;\n+import datadog.trace.api.DDTags;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+public class AerospikeClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Node> {\n+  public static final UTF8BytesString AEROSPIKE_JAVA =\n+      UTF8BytesString.createConstant(\"aerospike-java\");\n+\n+  public static final AerospikeClientDecorator DECORATE = new AerospikeClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"aerospike\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"aerospike\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return \"java-aerospike\";\n+  }\n+\n+  @Override\n+  protected CharSequence spanType() {\n+    return DDSpanTypes.AEROSPIKE;\n+  }\n+\n+  @Override\n+  protected String dbType() {\n+    return \"aerospike\";\n+  }\n+\n+  @Override\n+  protected String dbUser(final Node node) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbInstance(final Node node) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbHostname(final Node node) {\n+    return null;\n+  }\n+\n+  public AgentSpan onConnection(\n+      final AgentSpan span, final Node node, final Cluster cluster, final Partition partition) {\n+\n+    final InetSocketAddress socketAddress = node.getAddress();\n+    span.setTag(Tags.PEER_HOSTNAME, socketAddress.getHostName());\n+    span.setTag(Tags.PEER_PORT, socketAddress.getPort());\n+    final InetAddress remoteAddress = socketAddress.getAddress();\n+    if (remoteAddress instanceof Inet4Address) {\n+      span.setTag(Tags.PEER_HOST_IPV4, remoteAddress.getHostAddress());\n+    } else if (remoteAddress instanceof Inet6Address) {\n+      span.setTag(Tags.PEER_HOST_IPV6, remoteAddress.getHostAddress());\n+    }\n+\n+    if (cluster != null && cluster.getUser() != null) {\n+      span.setTag(Tags.DB_USER, new String(cluster.getUser(), StandardCharsets.UTF_8));\n+    }\n+\n+    if (partition != null) {\n+      String instanceName = partition.toString();", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NDg1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522054857", "bodyText": "partitions in Aerospike are the namespace (equivalent of table names in RDBMS) plus a number (with a colon separator)\nnamespaces can be up to 31 bytes long, but are typically shorter than that\nyou can have a maximum of 32 namespaces in a cluster (2 if you're using the community edition of Aerospike)", "author": "mcculls", "createdAt": "2020-11-12T12:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMjE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMzY4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522033681", "bodyText": "Does Cluster.getUser() return a byte[]? If so that's exactly what we'd want for serialisation later. Maybe we could wrap this in UTF8ByteString (which would need some modifications to support constructing from a byte[], but this would pay dividends for long ASCII strings like URLs if we did).", "author": "richardstartin", "createdAt": "2020-11-12T11:24:22Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/AerospikeClientDecorator.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+\n+import com.aerospike.client.AerospikeClient;\n+import com.aerospike.client.cluster.Cluster;\n+import com.aerospike.client.cluster.Node;\n+import com.aerospike.client.cluster.Partition;\n+import datadog.trace.api.Config;\n+import datadog.trace.api.DDSpanTypes;\n+import datadog.trace.api.DDTags;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+public class AerospikeClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Node> {\n+  public static final UTF8BytesString AEROSPIKE_JAVA =\n+      UTF8BytesString.createConstant(\"aerospike-java\");\n+\n+  public static final AerospikeClientDecorator DECORATE = new AerospikeClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"aerospike\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"aerospike\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return \"java-aerospike\";\n+  }\n+\n+  @Override\n+  protected CharSequence spanType() {\n+    return DDSpanTypes.AEROSPIKE;\n+  }\n+\n+  @Override\n+  protected String dbType() {\n+    return \"aerospike\";\n+  }\n+\n+  @Override\n+  protected String dbUser(final Node node) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbInstance(final Node node) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbHostname(final Node node) {\n+    return null;\n+  }\n+\n+  public AgentSpan onConnection(\n+      final AgentSpan span, final Node node, final Cluster cluster, final Partition partition) {\n+\n+    final InetSocketAddress socketAddress = node.getAddress();\n+    span.setTag(Tags.PEER_HOSTNAME, socketAddress.getHostName());\n+    span.setTag(Tags.PEER_PORT, socketAddress.getPort());\n+    final InetAddress remoteAddress = socketAddress.getAddress();\n+    if (remoteAddress instanceof Inet4Address) {\n+      span.setTag(Tags.PEER_HOST_IPV4, remoteAddress.getHostAddress());\n+    } else if (remoteAddress instanceof Inet6Address) {\n+      span.setTag(Tags.PEER_HOST_IPV6, remoteAddress.getHostAddress());\n+    }\n+\n+    if (cluster != null && cluster.getUser() != null) {\n+      span.setTag(Tags.DB_USER, new String(cluster.getUser(), StandardCharsets.UTF_8));", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MTAwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522041006", "bodyText": "yes, it's a byte[] - I can rework this to use UTF8ByteString", "author": "mcculls", "createdAt": "2020-11-12T11:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMzY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzNDU1NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522034554", "bodyText": "I feel like I've seen this code before, and this PR doesn't add significantly to the number of times I have seen it, so it's harsh to pick on this PR, but could this be moved into a utility method taking a span and an InetSocketAddress?", "author": "richardstartin", "createdAt": "2020-11-12T11:25:52Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/AerospikeClientDecorator.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+\n+import com.aerospike.client.AerospikeClient;\n+import com.aerospike.client.cluster.Cluster;\n+import com.aerospike.client.cluster.Node;\n+import com.aerospike.client.cluster.Partition;\n+import datadog.trace.api.Config;\n+import datadog.trace.api.DDSpanTypes;\n+import datadog.trace.api.DDTags;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.DBTypeProcessingDatabaseClientDecorator;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+public class AerospikeClientDecorator extends DBTypeProcessingDatabaseClientDecorator<Node> {\n+  public static final UTF8BytesString AEROSPIKE_JAVA =\n+      UTF8BytesString.createConstant(\"aerospike-java\");\n+\n+  public static final AerospikeClientDecorator DECORATE = new AerospikeClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"aerospike\"};\n+  }\n+\n+  @Override\n+  protected String service() {\n+    return \"aerospike\";\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return \"java-aerospike\";\n+  }\n+\n+  @Override\n+  protected CharSequence spanType() {\n+    return DDSpanTypes.AEROSPIKE;\n+  }\n+\n+  @Override\n+  protected String dbType() {\n+    return \"aerospike\";\n+  }\n+\n+  @Override\n+  protected String dbUser(final Node node) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbInstance(final Node node) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected String dbHostname(final Node node) {\n+    return null;\n+  }\n+\n+  public AgentSpan onConnection(\n+      final AgentSpan span, final Node node, final Cluster cluster, final Partition partition) {\n+\n+    final InetSocketAddress socketAddress = node.getAddress();\n+    span.setTag(Tags.PEER_HOSTNAME, socketAddress.getHostName());", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MDM3OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522040378", "bodyText": "I think there's a method in the base decorator I can use - originally this was extracted out because it used the Node for the provided host/port rather than the lower-level address, but now they're using the same types it can use the base method.", "author": "mcculls", "createdAt": "2020-11-12T11:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzNDU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzNzY0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522037649", "bodyText": "I don't think you need the activeScope() != null check. Either wrapping in FutureTask is safe or it isn't - it doesn't depend on whether there is an active scope - and FutureTask's constructor is instrumented to do this check already", "author": "richardstartin", "createdAt": "2020-11-12T11:31:18Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/NioEventLoopInstrumentation.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public final class NioEventLoopInstrumentation extends Instrumenter.Default {\n+  public NioEventLoopInstrumentation() {\n+    super(\"aerospike\", \"java_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"com.aerospike.client.async.NioEventLoop\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"execute\"))\n+            .and(takesArguments(1))\n+            .and(takesArgument(0, Runnable.class)),\n+        getClass().getName() + \"$WrapAsFutureTaskAdvice\");\n+  }\n+\n+  public static final class WrapAsFutureTaskAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void enterExecute(@Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      if (activeScope() != null && !(task instanceof RunnableFuture) && !exclude(RUNNABLE, task)) {", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3NzU1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r523077553", "bodyText": "BTW the tests hang if I remove the activeScope() != null check, seems to get stuck shutting down the internal thread. I suspect this is because it's instrumenting an internal runnable which gets loaded onto the same NIO event loop and there's some subtle interaction, but will confirm", "author": "mcculls", "createdAt": "2020-11-13T16:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzNzY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE4NDQ5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r524184494", "bodyText": "found the issue - needed to exclude some internal Runnables, one of which relied on propagating exceptions outside of the event loop, and the wrapping was interfering with that propagation: c69d046", "author": "mcculls", "createdAt": "2020-11-16T11:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzNzY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzODA1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522038057", "bodyText": "You can use NameMatchers.namedOneOf(\"getNodeRead\", \"getNodeWrite\") here.", "author": "richardstartin", "createdAt": "2020-11-12T11:32:01Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/PartitionInstrumentation.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.instrumentation.aerospike4.AerospikeClientDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.aerospike.client.cluster.Cluster;\n+import com.aerospike.client.cluster.Node;\n+import com.aerospike.client.cluster.Partition;\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.DDSpanTypes;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+@AutoService(Instrumenter.class)\n+public final class PartitionInstrumentation extends Instrumenter.Default {\n+  public PartitionInstrumentation() {\n+    super(\"aerospike\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"com.aerospike.client.cluster.Partition\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AerospikeClientDecorator\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"getNodeRead\").or(named(\"getNodeWrite\")))", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MjkwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522042908", "bodyText": "I'm going to check this out to play with it a bit, but I'm fairly sure this could all be simplified a lot by doing a type check in AbstractTracingListener and making that class concrete.", "author": "richardstartin", "createdAt": "2020-11-12T11:40:49Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/TracingListenerHelper.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import com.aerospike.client.listener.BatchListListener;\n+import com.aerospike.client.listener.BatchSequenceListener;\n+import com.aerospike.client.listener.DeleteListener;\n+import com.aerospike.client.listener.ExecuteListener;\n+import com.aerospike.client.listener.ExistsArrayListener;\n+import com.aerospike.client.listener.ExistsListener;\n+import com.aerospike.client.listener.ExistsSequenceListener;\n+import com.aerospike.client.listener.RecordArrayListener;\n+import com.aerospike.client.listener.RecordListener;\n+import com.aerospike.client.listener.RecordSequenceListener;\n+import com.aerospike.client.listener.WriteListener;\n+import datadog.trace.api.Function;\n+import datadog.trace.api.cache.DDCache;\n+import datadog.trace.api.cache.DDCaches;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+\n+public final class TracingListenerHelper implements Function<String, String> {\n+  public static final TracingListenerHelper INSTANCE = new TracingListenerHelper();\n+\n+  // won't grow more than the number of AerospikeClient methods that use a listener\n+  private static final DDCache<String, String> SIGNATURE_TO_LISTENER_NAME =\n+      DDCaches.newUnboundedCache(16);\n+\n+  private static final String LISTENER_PKG_PREFIX = \"com.aerospike.client.listener.\";\n+\n+  public Object traceListener(\n+      final String signature, final AgentScope scope, final Object listener) {\n+\n+    final String listenerName = SIGNATURE_TO_LISTENER_NAME.computeIfAbsent(signature, this);\n+\n+    switch (listenerName) {", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0Nzc5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522047795", "bodyText": "I think I see what you mean - since the listeners are all interfaces we could fold them into one base class - yes, that might work and would be much simpler", "author": "mcculls", "createdAt": "2020-11-12T11:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MjkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5ODMzOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522098338", "bodyText": "On second thoughts, I don't have the time to go in to that level of detail and trust your instincts to simplify this if possible. If you convince yourself this is the simplest it can be then let's leave it as is.", "author": "richardstartin", "createdAt": "2020-11-12T13:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MjkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MzQwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522043400", "bodyText": "How does this differ from https://github.com/DataDog/dd-trace-java/pull/2061/files#diff-cd1e92d8edc4b34d91cc8baec6b82010a916939e45d29d746cabaf5dc6064873R17-R27 ?", "author": "richardstartin", "createdAt": "2020-11-12T11:41:42Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/TracingExistsSequenceListener.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import com.aerospike.client.AerospikeException;\n+import com.aerospike.client.Key;\n+import com.aerospike.client.listener.ExistsSequenceListener;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.context.TraceScope;\n+\n+public final class TracingExistsSequenceListener\n+    extends AbstractTracingListener<ExistsSequenceListener> implements ExistsSequenceListener {\n+\n+  public TracingExistsSequenceListener(\n+      final AgentScope clientScope, final ExistsSequenceListener listener) {\n+    super(clientScope, listener);\n+  }\n+\n+  @Override\n+  public void onExists(final Key key, final boolean exists) {\n+    listener.onExists(key, exists);\n+  }\n+\n+  @Override\n+  public void onSuccess() {\n+    super.onSuccess();\n+\n+    if (listener != null) {\n+      try (final TraceScope scope = continuation.activate()) {\n+        listener.onSuccess();\n+      }\n+    } else {\n+      continuation.cancel();\n+    }\n+  }", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0OTM3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522049373", "bodyText": "this doesn't have arguments, while the other one does - to collapse it further we'd need to use a function to carry the arguments across", "author": "mcculls", "createdAt": "2020-11-12T11:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MzQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1NTg0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522055840", "bodyText": "Sorry I meant here - I see that several of these are very close but annoyingly different", "author": "richardstartin", "createdAt": "2020-11-12T12:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MzQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1ODAxNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522058017", "bodyText": "yes, those are the same - I can collapse this down by inheriting all of these interfaces into the same base class which would avoid this duplication", "author": "mcculls", "createdAt": "2020-11-12T12:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MzQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwMTE1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522201152", "bodyText": "Just to be safe and ensure the scope isn't being passed around where it shouldn't, I'd prefer if this took the AgentSpan directly.", "author": "tylerbenson", "createdAt": "2020-11-12T15:38:36Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/AbstractTracingListener.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.instrumentation.aerospike4.AerospikeClientDecorator.DECORATE;\n+\n+import com.aerospike.client.AerospikeException;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope.Continuation;\n+\n+public abstract class AbstractTracingListener<L> {\n+  protected final AgentSpan clientSpan;\n+  protected final Continuation continuation;\n+  protected final L listener;\n+\n+  public AbstractTracingListener(final AgentScope clientScope, final L listener) {\n+    this.clientSpan = clientScope.span();", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwNzg5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522207896", "bodyText": "Many of these Listeners look the same.  What's the difference?  Can the duplication be reduced?", "author": "tylerbenson", "createdAt": "2020-11-12T15:47:01Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/TracingExecuteListener.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import com.aerospike.client.AerospikeException;\n+import com.aerospike.client.Key;\n+import com.aerospike.client.listener.ExecuteListener;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.context.TraceScope;\n+\n+public final class TracingExecuteListener extends AbstractTracingListener<ExecuteListener>", "originalCommit": "1229e925a95b27ba179240fc371553199ab3c3c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwOTE2OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522209168", "bodyText": "Looks like Richard already brought this up.", "author": "tylerbenson", "createdAt": "2020-11-12T15:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwNzg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIyMzA0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522223040", "bodyText": "So these listeners don't share any superclass or interface, but they do have very similar methods - except for some differences in parameter types. The tricky thing with collapsing them into one type is that we'd need to handle the appropriate dispatch to the wrapped listener.\nFor example, if you have FooListener and BarListener that both have an onComplete method but don't share a common superclass then you need to do the appropriate cast on the wrapped listener before calling onComplete - either that or you need to use reflection, which is much slower.\nIn the end it's a choice between doing this statically vs dynamically - the static approach is more type-safe and faster but involves more boilerplate, the dynamic approach avoids the boilerplate but is slower and less type-safe.", "author": "mcculls", "createdAt": "2020-11-12T16:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwNzg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI0NzMyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522247329", "bodyText": "if the onComplete method is in the super class, it should still implicitly satisfy the interface, right?\nfor example, would this work?\ninterface Foo {\n  void foo();\n}\n\nabstract class Bar {\n  void foo() {}\n}\n\nclass Impl extends Bar implements Foo {}", "author": "tylerbenson", "createdAt": "2020-11-12T16:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwNzg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI1NDE4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r522254184", "bodyText": "ah, the problem is with the delegate call... never mind.", "author": "tylerbenson", "createdAt": "2020-11-12T16:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIwNzg5Ng=="}], "type": "inlineReview"}, {"oid": "f2ba105851a80d130edad2de91fb86ddab62af62", "url": "https://github.com/DataDog/dd-trace-java/commit/f2ba105851a80d130edad2de91fb86ddab62af62", "message": "Aerospike4 instrumentation", "committedDate": "2020-11-13T16:14:23Z", "type": "commit"}, {"oid": "3d77965f23646c69423b3943af2eeabc46231348", "url": "https://github.com/DataDog/dd-trace-java/commit/3d77965f23646c69423b3943af2eeabc46231348", "message": "Aerospike direct NioEventLoop instrumentation", "committedDate": "2020-11-13T16:14:23Z", "type": "commit"}, {"oid": "1fe34cb41ad828176761ed433c0003392a9f7245", "url": "https://github.com/DataDog/dd-trace-java/commit/1fe34cb41ad828176761ed433c0003392a9f7245", "message": "Move DB detail instrumentation from Node to Command/Partition", "committedDate": "2020-11-13T16:14:23Z", "type": "commit"}, {"oid": "5fc2014f29d8e691dc294b1d8acf5d2962f80115", "url": "https://github.com/DataDog/dd-trace-java/commit/5fc2014f29d8e691dc294b1d8acf5d2962f80115", "message": "Aerospike client tests", "committedDate": "2020-11-13T16:14:23Z", "type": "commit"}, {"oid": "62267c4a15849c2da23f586ce122909c0ebf3da8", "url": "https://github.com/DataDog/dd-trace-java/commit/62267c4a15849c2da23f586ce122909c0ebf3da8", "message": "abstract", "committedDate": "2020-11-13T16:14:23Z", "type": "commit"}, {"oid": "0e4577dfdea6b89501722aebbc192d1094cbf8b9", "url": "https://github.com/DataDog/dd-trace-java/commit/0e4577dfdea6b89501722aebbc192d1094cbf8b9", "message": "Wrap cluster.getUser byte array as UTF8BytesString", "committedDate": "2020-11-13T16:20:21Z", "type": "commit"}, {"oid": "4ba42b31d3829f743b2f979038b5141d777c02ea", "url": "https://github.com/DataDog/dd-trace-java/commit/4ba42b31d3829f743b2f979038b5141d777c02ea", "message": "Use BaseDecorator.onPeerConnection", "committedDate": "2020-11-13T16:23:07Z", "type": "commit"}, {"oid": "f4a5101eaa090d32ee6622206ea4d6fdd6a86d50", "url": "https://github.com/DataDog/dd-trace-java/commit/f4a5101eaa090d32ee6622206ea4d6fdd6a86d50", "message": "Prefer namedOneOf", "committedDate": "2020-11-13T16:54:43Z", "type": "commit"}, {"oid": "b0bf3692d121c3d1430bc728ccef97e40861681b", "url": "https://github.com/DataDog/dd-trace-java/commit/b0bf3692d121c3d1430bc728ccef97e40861681b", "message": "Cleanup aerospike strings", "committedDate": "2020-11-13T17:37:17Z", "type": "forcePushed"}, {"oid": "8d755f42337531ca8b4a34ab23d3e047a77e19d5", "url": "https://github.com/DataDog/dd-trace-java/commit/8d755f42337531ca8b4a34ab23d3e047a77e19d5", "message": "Cleanup aerospike strings", "committedDate": "2020-11-13T17:46:19Z", "type": "commit"}, {"oid": "8d755f42337531ca8b4a34ab23d3e047a77e19d5", "url": "https://github.com/DataDog/dd-trace-java/commit/8d755f42337531ca8b4a34ab23d3e047a77e19d5", "message": "Cleanup aerospike strings", "committedDate": "2020-11-13T17:46:19Z", "type": "forcePushed"}, {"oid": "03509a9c9cd2a90d78614c395d911d57d5387f7c", "url": "https://github.com/DataDog/dd-trace-java/commit/03509a9c9cd2a90d78614c395d911d57d5387f7c", "message": "Merge and simplify listener tracing wrappers", "committedDate": "2020-11-13T23:04:48Z", "type": "commit"}, {"oid": "4ee09845ac971c57c19304d839d7956be139b591", "url": "https://github.com/DataDog/dd-trace-java/commit/4ee09845ac971c57c19304d839d7956be139b591", "message": "Further listener simplification", "committedDate": "2020-11-13T23:52:44Z", "type": "commit"}, {"oid": "e5b6242dfe86aa38946a13e03472c5b53e7658c5", "url": "https://github.com/DataDog/dd-trace-java/commit/e5b6242dfe86aa38946a13e03472c5b53e7658c5", "message": "Remove redundant check", "committedDate": "2020-11-14T00:00:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1NTcwNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r524055705", "bodyText": "I would be tempted not to do this, despite the obvious opportunity for code deduplication.\n\nWe still instrument Runnable, so context will be captured twice, which may be confusing, and doubles work done.\nIt allocates to capture the parameters.\n\nAs painful as it is, I would consider duplicating what's below into each onSuccess overload.\n  DECORATE.beforeFinish(clientSpan);\n    clientSpan.finish();\n\n    if (listener != null) {\n      try (final TraceScope scope = continuation.activate()) {\n        // action\n      }\n    } else {\n      continuation.cancel();\n    }\nAll of this is much easier to follow now it's all centralised in a single class, and it's much easier to see what's common and what differs between each case, so thanks for simplifying this.", "author": "richardstartin", "createdAt": "2020-11-16T09:58:48Z", "path": "dd-java-agent/instrumentation/aerospike-4/src/main/java/datadog/trace/instrumentation/aerospike4/TracingListener.java", "diffHunk": "@@ -0,0 +1,217 @@\n+package datadog.trace.instrumentation.aerospike4;\n+\n+import static datadog.trace.instrumentation.aerospike4.AerospikeClientDecorator.DECORATE;\n+\n+import com.aerospike.client.AerospikeException;\n+import com.aerospike.client.BatchRead;\n+import com.aerospike.client.Key;\n+import com.aerospike.client.Record;\n+import com.aerospike.client.listener.BatchListListener;\n+import com.aerospike.client.listener.BatchSequenceListener;\n+import com.aerospike.client.listener.DeleteListener;\n+import com.aerospike.client.listener.ExecuteListener;\n+import com.aerospike.client.listener.ExistsArrayListener;\n+import com.aerospike.client.listener.ExistsListener;\n+import com.aerospike.client.listener.ExistsSequenceListener;\n+import com.aerospike.client.listener.RecordArrayListener;\n+import com.aerospike.client.listener.RecordListener;\n+import com.aerospike.client.listener.RecordSequenceListener;\n+import com.aerospike.client.listener.WriteListener;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.context.TraceScope.Continuation;\n+import java.util.List;\n+\n+public final class TracingListener\n+    implements ExistsListener,\n+        ExistsSequenceListener,\n+        ExistsArrayListener,\n+        RecordListener,\n+        RecordSequenceListener,\n+        RecordArrayListener,\n+        BatchSequenceListener,\n+        BatchListListener,\n+        WriteListener,\n+        ExecuteListener,\n+        DeleteListener {\n+\n+  private final AgentSpan clientSpan;\n+  private final Continuation continuation;\n+  private final Object listener;\n+\n+  public TracingListener(\n+      final AgentSpan clientSpan, final Continuation continuation, final Object listener) {\n+    this.clientSpan = clientSpan;\n+    this.continuation = continuation;\n+    this.listener = listener;\n+  }\n+\n+  @Override\n+  public void onExists(final Key key, final boolean exists) {\n+    if (listener != null) {\n+      ((ExistsSequenceListener) listener).onExists(key, exists);\n+    }\n+  }\n+\n+  @Override\n+  public void onRecord(final Key key, final Record record) throws AerospikeException {\n+    if (listener != null) {\n+      ((RecordSequenceListener) listener).onRecord(key, record);\n+    }\n+  }\n+\n+  @Override\n+  public void onRecord(final BatchRead record) {\n+    if (listener != null) {\n+      ((BatchSequenceListener) listener).onRecord(record);\n+    }\n+  }\n+\n+  @Override\n+  public void onSuccess(final Key key, final boolean exists) {\n+    onSuccess(\n+        new Runnable() {", "originalCommit": "e5b6242dfe86aa38946a13e03472c5b53e7658c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2MTk0NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2061#discussion_r524061945", "bodyText": "ok, luckily the change to use Runnable was a separate commit so I've just reverted that step: ff12cb8", "author": "mcculls", "createdAt": "2020-11-16T10:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1NTcwNQ=="}], "type": "inlineReview"}, {"oid": "ff12cb840b04af2da62c4fb60b20f899874d63aa", "url": "https://github.com/DataDog/dd-trace-java/commit/ff12cb840b04af2da62c4fb60b20f899874d63aa", "message": "Revert \"Further listener simplification\" to avoid creating extra runnables\n\nThis reverts commit 4ee09845ac971c57c19304d839d7956be139b591.", "committedDate": "2020-11-16T10:01:41Z", "type": "commit"}, {"oid": "c69d04650a0884d581eb9b4627ceefd556a843ad", "url": "https://github.com/DataDog/dd-trace-java/commit/c69d04650a0884d581eb9b4627ceefd556a843ad", "message": "Don't wrap Runnables belonging to NioEventLoop(s) as they want to propagate CloseException\noutside of the event loop on close() and wrapping them in FutureTask interferes with that", "committedDate": "2020-11-16T11:50:05Z", "type": "commit"}]}