{"pr_number": 1261, "pr_title": "speedup context injection matchers", "pr_createdAt": "2020-02-27T09:51:14Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1261", "timeline": [{"oid": "2cf97980e2070c1031c1466e827b2a48162a1efb", "url": "https://github.com/DataDog/dd-trace-java/commit/2cf97980e2070c1031c1466e827b2a48162a1efb", "message": "Make FieldBackedProvider inject fields only once", "committedDate": "2020-02-27T10:07:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1NzIxOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385157218", "bodyText": "Yes, that assumption sounds reasonable to me, but I think it speaks to the fact that our abstraction isn't quite right.\nIt seems to me that the contextClasses should carry a ClassLoaderMatcher constraint that is incorporated into the Instrumenter activation implicitly.  An Instrumenter could safely add additional criteria, but cannot remove the requirement needed by the contextClasses.", "author": "dougqh", "createdAt": "2020-02-27T14:23:15Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java", "diffHunk": "@@ -342,38 +343,63 @@ public void visitLdcInsn(final Object value) {\n     };\n   }\n \n+  private static final Set<Map.Entry<String, String>> INSTALLED_CONTEXT_MATCHERS = new HashSet<>();\n+\n+  /** Clear set that prevents multiple matchers for same context class */\n+  public static void resetContextMatchers() {\n+    synchronized (INSTALLED_CONTEXT_MATCHERS) {\n+      INSTALLED_CONTEXT_MATCHERS.clear();\n+    }\n+  }\n+\n   @Override\n   public AgentBuilder.Identified.Extendable additionalInstrumentation(\n       AgentBuilder.Identified.Extendable builder) {\n \n     if (fieldInjectionEnabled) {\n       for (final Map.Entry<String, String> entry : instrumenter.contextStore().entrySet()) {\n-        /**\n-         * For each context store defined in a current instrumentation we create an agent builder\n-         * that injects necessary fields.\n+        /*\n+        Note: this synchronization should not have any impact on performace since this is done when agent builder is being made,\n+        it doesn't affect actual class transformation.\n          */\n-        builder =\n-            builder\n-                .type(\n-                    not(isInterface()).and(safeHasSuperType(named(entry.getKey()))),\n-                    instrumenter.classLoaderMatcher())\n-                .and(safeToInjectFieldsMatcher())\n-                // Added here instead of AgentInstaller's ignores because it's relatively\n-                // expensive. https://github.com/DataDog/dd-trace-java/pull/1045\n-                .and(not(isAnnotatedWith(named(\"javax.decorator.Decorator\"))))\n-                .transform(AgentBuilder.Transformer.NoOp.INSTANCE);\n+        synchronized (INSTALLED_CONTEXT_MATCHERS) {\n+          // FIXME: This makes an assunption that class loader matchers for instrumenters that use", "originalCommit": "2cf97980e2070c1031c1466e827b2a48162a1efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE3ODMwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385178301", "bodyText": "Yes, our abstractions are wrong and I'm not immediately sure how to fix that. I think we have to introduce the notion of 'compound instrumenter' - i.e. 'instrumenter' that covers multiple instances of Instrumenter.Default and defines common settings for them.\nCurrently we do not have this mechanism.", "author": "mar-kolya", "createdAt": "2020-02-27T15:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3MTI1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r494571251", "bodyText": "We ended up disabling field injection of Runnables and Callables when classloader matchers were added for AkkaForkJoinPool and ScalaForkJoinPool because they share context stores with the RunnableInstrumentation and CallableInstrumentation - see #1910", "author": "richardstartin", "createdAt": "2020-09-24T19:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1NzIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDU3NTg1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r494575857", "bodyText": "interesting", "author": "mar-kolya", "createdAt": "2020-09-24T19:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1NzIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDUzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385160537", "bodyText": "A Set<Map.Entry<String, String>> looks rather odd.  My first thought was how this different from a Setof just the Entry keys.  But I guess we're accumulating this from multiple maps, so it makes sense.  Still not very obvious.\nI also think there's likely a better option than reducing statics here.  Ultimately, the reset boundary is contained by the caller, so I think it would be better for the caller to construct and pass in object rather than introducing a static that the caller must remember to reset.", "author": "dougqh", "createdAt": "2020-02-27T14:28:04Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java", "diffHunk": "@@ -342,38 +343,63 @@ public void visitLdcInsn(final Object value) {\n     };\n   }\n \n+  private static final Set<Map.Entry<String, String>> INSTALLED_CONTEXT_MATCHERS = new HashSet<>();", "originalCommit": "2cf97980e2070c1031c1466e827b2a48162a1efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE3OTYxMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385179613", "bodyText": "I do not have a strong opinion here overall, but I feel passing it from 'outside' has two problems:\n\nWe spread way to much internal knowledge outside\nWe would pipe it through quite a few levels\n\nOverall I'm not sure it's worth the effort. Proper fix here is to fix our abstraction (with compound instrumenter of something) so we do not have to resort to this hack. But as far as hack goes I do not think that passing set all over the place is much better than using static.", "author": "mar-kolya", "createdAt": "2020-02-27T15:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzMDI5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385330298", "bodyText": "For me, the need to have the caller call reset is spreading the outside knowledge.\nBut I think this is fine for now, I think we agree the real issue is that we're missing a concept that connects multiple related Instrumenters.  But I don't think, we should try to fix that in this PR.", "author": "dougqh", "createdAt": "2020-02-27T19:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MDUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTMzMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385161330", "bodyText": "I know this wasn't part of this change, but I think we might be well served to move the construction of this Matcher into a helper method.  Doesn't need to be part of this PR.", "author": "dougqh", "createdAt": "2020-02-27T14:29:16Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldBackedProvider.java", "diffHunk": "@@ -342,38 +343,63 @@ public void visitLdcInsn(final Object value) {\n     };\n   }\n \n+  private static final Set<Map.Entry<String, String>> INSTALLED_CONTEXT_MATCHERS = new HashSet<>();\n+\n+  /** Clear set that prevents multiple matchers for same context class */\n+  public static void resetContextMatchers() {\n+    synchronized (INSTALLED_CONTEXT_MATCHERS) {\n+      INSTALLED_CONTEXT_MATCHERS.clear();\n+    }\n+  }\n+\n   @Override\n   public AgentBuilder.Identified.Extendable additionalInstrumentation(\n       AgentBuilder.Identified.Extendable builder) {\n \n     if (fieldInjectionEnabled) {\n       for (final Map.Entry<String, String> entry : instrumenter.contextStore().entrySet()) {\n-        /**\n-         * For each context store defined in a current instrumentation we create an agent builder\n-         * that injects necessary fields.\n+        /*\n+        Note: this synchronization should not have any impact on performace since this is done when agent builder is being made,\n+        it doesn't affect actual class transformation.\n          */\n-        builder =\n-            builder\n-                .type(\n-                    not(isInterface()).and(safeHasSuperType(named(entry.getKey()))),\n-                    instrumenter.classLoaderMatcher())\n-                .and(safeToInjectFieldsMatcher())\n-                // Added here instead of AgentInstaller's ignores because it's relatively\n-                // expensive. https://github.com/DataDog/dd-trace-java/pull/1045\n-                .and(not(isAnnotatedWith(named(\"javax.decorator.Decorator\"))))\n-                .transform(AgentBuilder.Transformer.NoOp.INSTANCE);\n+        synchronized (INSTALLED_CONTEXT_MATCHERS) {\n+          // FIXME: This makes an assunption that class loader matchers for instrumenters that use\n+          // same context classes should be the same - which seems reasonable, but is not checked.\n+          if (INSTALLED_CONTEXT_MATCHERS.contains(entry)) {\n+            log.debug(\"Skipping builder for {} {}\", instrumenter.getClass().getName(), entry);\n+            continue;\n+          }\n \n-        /**\n-         * We inject helpers here as well as when instrumentation is applied to ensure that helpers\n-         * are present even if instrumented classes are not loaded, but classes with state fields\n-         * added are loaded (e.g. sun.net.www.protocol.https.HttpsURLConnectionImpl).\n-         */\n-        builder = injectHelpersIntoBootstrapClassloader(builder);\n+          log.debug(\"Making builder for {} {}\", instrumenter.getClass().getName(), entry);\n+          INSTALLED_CONTEXT_MATCHERS.add(entry);\n \n-        builder =\n-            builder.transform(\n-                getTransformerForASMVisitor(\n-                    getFieldInjectionVisitor(entry.getKey(), entry.getValue())));\n+          /**\n+           * For each context store defined in a current instrumentation we create an agent builder\n+           * that injects necessary fields.\n+           */\n+          builder =\n+              builder\n+                  .type(\n+                      not(isInterface()).and(safeHasSuperType(named(entry.getKey()))),\n+                      instrumenter.classLoaderMatcher())\n+                  .and(safeToInjectFieldsMatcher())\n+                  // Added here instead of AgentInstaller's ignores because it's relatively\n+                  // expensive. https://github.com/DataDog/dd-trace-java/pull/1045\n+                  .and(not(isAnnotatedWith(named(\"javax.decorator.Decorator\"))))", "originalCommit": "2cf97980e2070c1031c1466e827b2a48162a1efb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE3NDgwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385174808", "bodyText": "I'm actually questioning correctness of this matcher at all - i have a feeling we should not put it here at all", "author": "mar-kolya", "createdAt": "2020-02-27T15:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyNzQ1OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385227458", "bodyText": "I'll look into this as separate PR.", "author": "mar-kolya", "createdAt": "2020-02-27T16:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzODU4OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1261#discussion_r385238589", "bodyText": "#1267", "author": "mar-kolya", "createdAt": "2020-02-27T16:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2MTMzMA=="}], "type": "inlineReview"}, {"oid": "9b711c9918bb7bee6d4b03fb864661b61be7b630", "url": "https://github.com/DataDog/dd-trace-java/commit/9b711c9918bb7bee6d4b03fb864661b61be7b630", "message": "Make FieldBackedProvider inject fields only once", "committedDate": "2020-02-27T14:58:27Z", "type": "forcePushed"}, {"oid": "3723b4f014603d8585bae499d7b61402a018f34e", "url": "https://github.com/DataDog/dd-trace-java/commit/3723b4f014603d8585bae499d7b61402a018f34e", "message": "Make FieldBackedProvider inject fields only once", "committedDate": "2020-02-27T15:21:49Z", "type": "forcePushed"}, {"oid": "d53c1380161bf383d5455f43f471cb4999c06dba", "url": "https://github.com/DataDog/dd-trace-java/commit/d53c1380161bf383d5455f43f471cb4999c06dba", "message": "Make FieldBackedProvider inject fields only once", "committedDate": "2020-02-27T15:24:01Z", "type": "commit"}, {"oid": "d53c1380161bf383d5455f43f471cb4999c06dba", "url": "https://github.com/DataDog/dd-trace-java/commit/d53c1380161bf383d5455f43f471cb4999c06dba", "message": "Make FieldBackedProvider inject fields only once", "committedDate": "2020-02-27T15:24:01Z", "type": "forcePushed"}, {"oid": "3d4ab938889b5a43908427e02a113787ab76b013", "url": "https://github.com/DataDog/dd-trace-java/commit/3d4ab938889b5a43908427e02a113787ab76b013", "message": "Merge branch 'master' into mar-kolya/speedup-context-injection-matchers", "committedDate": "2020-02-28T01:01:33Z", "type": "commit"}, {"oid": "cf5fe9feff114cb2c4dc73b712989fcb9f2d9999", "url": "https://github.com/DataDog/dd-trace-java/commit/cf5fe9feff114cb2c4dc73b712989fcb9f2d9999", "message": "Merge branch 'master' into mar-kolya/speedup-context-injection-matchers", "committedDate": "2020-02-28T01:07:37Z", "type": "commit"}, {"oid": "cf5fe9feff114cb2c4dc73b712989fcb9f2d9999", "url": "https://github.com/DataDog/dd-trace-java/commit/cf5fe9feff114cb2c4dc73b712989fcb9f2d9999", "message": "Merge branch 'master' into mar-kolya/speedup-context-injection-matchers", "committedDate": "2020-02-28T01:07:37Z", "type": "forcePushed"}]}