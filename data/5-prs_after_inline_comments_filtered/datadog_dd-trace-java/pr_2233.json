{"pr_number": 2233, "pr_title": "Allow for the span completing a Scala Promise to be reactivated", "pr_createdAt": "2020-12-22T14:51:32Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2233", "timeline": [{"oid": "ac3f0baf2372fff8a08e937a77031d3e906e655c", "url": "https://github.com/DataDog/dd-trace-java/commit/ac3f0baf2372fff8a08e937a77031d3e906e655c", "message": "Move jcenter after maven central", "committedDate": "2020-12-22T15:59:44Z", "type": "forcePushed"}, {"oid": "9f548df0f7e8463653414c4c32467f56173bf4b7", "url": "https://github.com/DataDog/dd-trace-java/commit/9f548df0f7e8463653414c4c32467f56173bf4b7", "message": "Move jcenter after maven central", "committedDate": "2020-12-22T16:58:05Z", "type": "forcePushed"}, {"oid": "12cdbec990bc0c95a3bb3a6d9f61364dff280531", "url": "https://github.com/DataDog/dd-trace-java/commit/12cdbec990bc0c95a3bb3a6d9f61364dff280531", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-11T10:58:36Z", "type": "forcePushed"}, {"oid": "ec4231e3f7b3defc0a2df82e7fa9daabfabd391c", "url": "https://github.com/DataDog/dd-trace-java/commit/ec4231e3f7b3defc0a2df82e7fa9daabfabd391c", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-11T12:51:47Z", "type": "forcePushed"}, {"oid": "cc08b4a4d78e1004225224aa54a7fcd226bb50cf", "url": "https://github.com/DataDog/dd-trace-java/commit/cc08b4a4d78e1004225224aa54a7fcd226bb50cf", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-11T13:26:39Z", "type": "forcePushed"}, {"oid": "852eb69209893b102561f284ec32801fd6ace597", "url": "https://github.com/DataDog/dd-trace-java/commit/852eb69209893b102561f284ec32801fd6ace597", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-12T13:18:45Z", "type": "forcePushed"}, {"oid": "e2b0a91684f0b2a9d61263fafb236318cae39d24", "url": "https://github.com/DataDog/dd-trace-java/commit/e2b0a91684f0b2a9d61263fafb236318cae39d24", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-12T16:14:48Z", "type": "forcePushed"}, {"oid": "685405a0112e245e3b5eb5a2ad6590c18aa0144e", "url": "https://github.com/DataDog/dd-trace-java/commit/685405a0112e245e3b5eb5a2ad6590c18aa0144e", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-13T15:06:36Z", "type": "forcePushed"}, {"oid": "dc96f1de95c44f3bda273ee8c06cf92cd616c109", "url": "https://github.com/DataDog/dd-trace-java/commit/dc96f1de95c44f3bda273ee8c06cf92cd616c109", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-13T15:47:00Z", "type": "forcePushed"}, {"oid": "244b5560dcfae6bb74eb727089b22f4676298e10", "url": "https://github.com/DataDog/dd-trace-java/commit/244b5560dcfae6bb74eb727089b22f4676298e10", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-14T09:21:33Z", "type": "forcePushed"}, {"oid": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "url": "https://github.com/DataDog/dd-trace-java/commit/d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-14T10:21:06Z", "type": "commit"}, {"oid": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "url": "https://github.com/DataDog/dd-trace-java/commit/d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "message": "Allow for the span completing a Scala promise to be reactivated", "committedDate": "2021-01-14T10:21:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMzMDQwNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557330404", "bodyText": "there are a few remaining references to SortedSet in Config which should be updated for consistency, but that can be done in a follow-up PR", "author": "mcculls", "createdAt": "2021-01-14T11:33:35Z", "path": "internal-api/src/main/java/datadog/trace/api/Config.java", "diffHunk": "@@ -877,12 +877,12 @@ public String getFinalProfilingUrl() {\n   }\n \n   public boolean isIntegrationEnabled(\n-      final SortedSet<String> integrationNames, final boolean defaultEnabled) {\n+      final Iterable<String> integrationNames, final boolean defaultEnabled) {\n     return isEnabled(integrationNames, \"integration.\", \".enabled\", defaultEnabled);\n   }\n \n   public boolean isJmxFetchIntegrationEnabled(\n-      final SortedSet<String> integrationNames, final boolean defaultEnabled) {\n+      final Iterable<String> integrationNames, final boolean defaultEnabled) {", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMzMTk1MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557331950", "bodyText": "could use try-with-resources for scope", "author": "mcculls", "createdAt": "2021-01-14T11:36:38Z", "path": "dd-trace-ot/src/main/java/datadog/opentracing/CustomScopeManagerWrapper.java", "diffHunk": "@@ -63,6 +63,15 @@ public AgentSpan activeSpan() {\n     return converter.toAgentSpan(delegate.activeSpan());\n   }\n \n+  @Override\n+  public TraceScope.Continuation captureSpan(final AgentSpan span, ScopeSource source) {\n+    // I can't see a better way to do this, and I don't know if this even makes sense.\n+    AgentScope scope = this.activate(span, source);\n+    TraceScope.Continuation continuation = scope.capture();\n+    scope.close();", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMzMjYxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557332614", "bodyText": "ie. perhaps\ntry (AgentScope scope = this.activate(span, source)) {\n  return scope.capture();\n}", "author": "mcculls", "createdAt": "2021-01-14T11:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMzMTk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzMzNTg4OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557335888", "bodyText": "s/assoicated/associated/", "author": "mcculls", "createdAt": "2021-01-14T11:44:17Z", "path": "dd-java-agent/instrumentation/scala-promise/src/main/java/datadog/trace/instrumentation/scala/PromiseHelper.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package datadog.trace.instrumentation.scala;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.captureSpan;\n+\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.State;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import scala.util.Failure;\n+import scala.util.Success;\n+import scala.util.Try;\n+\n+public class PromiseHelper {\n+  public static final boolean completionPriority =\n+      Config.get()\n+          .isIntegrationEnabled(\n+              Collections.singletonList(\"scala_promise_completion_priority\"), false);\n+\n+  /**\n+   * Get the {@code Span} that should be associated with the {@code Try} completing this {@code\n+   * Promise}.\n+   *\n+   * @return the Span or null\n+   */\n+  public static AgentSpan getSpan() {\n+    AgentSpan span = null;\n+    final TraceScope scope = activeScope();\n+    if (null != scope && scope.isAsyncPropagating()) {\n+      if (scope instanceof AgentScope) {\n+        span = ((AgentScope) scope).span();\n+      } else {\n+        span = activeSpan();\n+      }\n+    }\n+    return span;\n+  }\n+\n+  /**\n+   * Get the {@code Try} that should be associated with the {@code Span}. Will create a new copy of\n+   * the {@code Try} if the existing one already has a different {@code Span} associated.\n+   *\n+   * @param resolved the current Try\n+   * @param span the current Span\n+   * @param existing the currently stored Span for the Try\n+   * @return the Try that should be assoicated with the Span", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0MDM4Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557340387", "bodyText": "is this dangling $ a quirk of scala?", "author": "mcculls", "createdAt": "2021-01-14T11:52:43Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.13/src/main/java/datadog/trace/instrumentation/scala/concurrent/PromiseObjectInstrumentation213.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.instrumentation.scala.concurrent;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static scala.concurrent.impl.Promise.Transformation;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.scala.PromiseHelper;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.util.Try;\n+\n+/**\n+ * A Scala {@code Promise} is always completed with a {@code Try}, so if we want the completing span\n+ * to take priority over any spans captured while adding computations to a {@code Future} associated\n+ * with a {@code Promise}, then we capture the active span when the {@code Try} is resolved.\n+ */\n+@AutoService(Instrumenter.class)\n+public class PromiseObjectInstrumentation213 extends Instrumenter.Tracing {\n+\n+  public PromiseObjectInstrumentation213() {\n+    super(\"scala_promise_resolve\", \"scala_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"scala.concurrent.impl.Promise$\");", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTU2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557355563", "bodyText": "Yes, the Promise$ is the Scala object for Promise, and not the trait or class. An object is a singleton.", "author": "bantonsson", "createdAt": "2021-01-14T12:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0MDM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0MTEzMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557341131", "bodyText": "same question - is this dangling $ a quirk of scala?", "author": "mcculls", "createdAt": "2021-01-14T11:54:08Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.10/src/main/java/datadog/trace/instrumentation/scala/concurrent/PromiseObjectInstrumentation210.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.instrumentation.scala.concurrent;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.scala.PromiseHelper;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.impl.CallbackRunnable;\n+import scala.util.Try;\n+\n+/**\n+ * A Scala {@code Promise} is always completed with a {@code Try}, so if we want the completing span\n+ * to take priority over any spans captured while adding computations to a {@code Future} associated\n+ * with a {@code Promise}, then we capture the active span when the {@code Try} is resolved.\n+ */\n+@AutoService(Instrumenter.class)\n+public class PromiseObjectInstrumentation210 extends Instrumenter.Tracing {\n+\n+  public PromiseObjectInstrumentation210() {\n+    super(\"scala_promise_resolve\", \"scala_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"scala.concurrent.impl.Promise$\");", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM2MDAxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557360010", "bodyText": "Yes again \ud83d\ude09 I'll add comments in the code.", "author": "bantonsson", "createdAt": "2021-01-14T12:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0MTEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0Mzg2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557343865", "bodyText": "I assume these muzzle checks weren't needed because the instrumentation already refers to Promise.Transformation and will be muzzled when that's not available", "author": "mcculls", "createdAt": "2021-01-14T11:59:06Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.13/src/main/java/datadog/trace/instrumentation/scala/concurrent/PromiseTransformationInstrumentation.java", "diffHunk": "@@ -111,34 +112,36 @@ private static void muzzleCheck(final Transformation callback) {\n         state.closeContinuation();\n       }\n     }\n-\n-    /** Promise.Transformation was introduced in scala 2.13 */\n-    private static void muzzleCheck(final Transformation callback) {\n-      callback.submitWithValue(null);\n-    }\n   }\n \n   public static final class SubmitWithValue {\n     @Advice.OnMethodEnter\n-    public static <F, T> void beforeExecute(@Advice.This Transformation<F, T> task) {\n+    public static <F, T> void beforeExecute(\n+        @Advice.This Transformation<F, T> task, @Advice.Argument(value = 0) Try<T> resolved) {\n       // about to enter an ExecutionContext so capture the scope if necessary\n       // (this used to happen automatically when the RunnableInstrumentation\n       // was relied on, and happens anyway if the ExecutionContext is backed\n       // by a wrapping Executor (e.g. FJP, ScheduledThreadPoolExecutor)\n-      State state = InstrumentationContext.get(Transformation.class, State.class).get(task);\n+      ContextStore<Transformation, State> tStore =\n+          InstrumentationContext.get(Transformation.class, State.class);\n+      State state = tStore.get(task);\n+      if (PromiseHelper.completionPriority) {\n+        final AgentSpan span = InstrumentationContext.get(Try.class, AgentSpan.class).get(resolved);\n+        State oState = state;\n+        state = PromiseHelper.handleSpan(span, state);\n+        if (state != oState) {\n+          tStore.put(task, state);\n+        }\n+      }\n+      // If nothing else has been picked up, then try to pick up the current Scope\n       if (null == state) {\n         final TraceScope scope = activeScope();\n         if (scope != null) {\n           state = State.FACTORY.create();\n           state.captureAndSetContinuation(scope);\n-          InstrumentationContext.get(Transformation.class, State.class).put(task, state);\n+          tStore.put(task, state);\n         }\n       }\n     }\n-\n-    /** Promise.Transformation was introduced in scala 2.13 */\n-    private static void muzzleCheck(final Transformation callback) {", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTcwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557355706", "bodyText": "Exactly", "author": "bantonsson", "createdAt": "2021-01-14T12:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0Mzg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0NzM5MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557347391", "bodyText": "I'm not sure about this change because it replaces something that was clear (enabled) with something less clear - ie. defaultEnabled is not the same as defaultEnabled() and is not actually the \"default\" , but a combination of the default with a configuration override.\nAFAICT this change is just so the scala instrumentations can see if the instrumentation is enabled from the POV of the base class - is there a reason they can't use super.enabled() to do that?", "author": "mcculls", "createdAt": "2021-01-14T12:05:31Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/Instrumenter.java", "diffHunk": "@@ -86,7 +86,7 @@\n     private final String instrumentationPrimaryName;\n     private InstrumentationContextProvider contextProvider;\n     private boolean initialized;\n-    private final boolean enabled;\n+    protected final boolean defaultEnabled;", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1OTQxMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557359413", "bodyText": "Sure, I can change it back to enabled. I can see how confusing defaultEnabled is, even though enabled is a bit misleading as well.", "author": "bantonsson", "createdAt": "2021-01-14T12:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0NzM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0ODk3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557348977", "bodyText": "this change is fine, but I think the other changes in this file are unnecessary given subclasses can call super.isEnabled() to get the enabled state of the base class which they can then override in their isEnabled method", "author": "mcculls", "createdAt": "2021-01-14T12:08:22Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/Instrumenter.java", "diffHunk": "@@ -135,7 +135,7 @@ private void lazyInit() {\n \n     @Override\n     public final AgentBuilder instrument(final AgentBuilder parentAgentBuilder) {\n-      if (!enabled) {\n+      if (!isEnabled()) {", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0OTM1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557349353", "bodyText": "super.isEnabled() ?", "author": "mcculls", "createdAt": "2021-01-14T12:09:03Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.13/src/main/java/datadog/trace/instrumentation/scala/concurrent/PromiseObjectInstrumentation213.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.instrumentation.scala.concurrent;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static scala.concurrent.impl.Promise.Transformation;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.scala.PromiseHelper;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.util.Try;\n+\n+/**\n+ * A Scala {@code Promise} is always completed with a {@code Try}, so if we want the completing span\n+ * to take priority over any spans captured while adding computations to a {@code Future} associated\n+ * with a {@code Promise}, then we capture the active span when the {@code Try} is resolved.\n+ */\n+@AutoService(Instrumenter.class)\n+public class PromiseObjectInstrumentation213 extends Instrumenter.Tracing {\n+\n+  public PromiseObjectInstrumentation213() {\n+    super(\"scala_promise_resolve\", \"scala_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"scala.concurrent.impl.Promise$\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"scala.util.Try\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return Collections.singletonMap(\n+        isMethod().and(named(\"scala$concurrent$impl$Promise$$resolve\")),\n+        getClass().getName() + \"$Resolve\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\"datadog.trace.instrumentation.scala.PromiseHelper\"};\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    // Only enable this if integrations have been enabled and the extra \"integration\"\n+    // scala_promise_completion_priority has been enabled specifically\n+    return defaultEnabled", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0OTcwNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557349704", "bodyText": "contextStore ?", "author": "mcculls", "createdAt": "2021-01-14T12:09:39Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.13/src/main/java/datadog/trace/instrumentation/scala/concurrent/PromiseTransformationInstrumentation.java", "diffHunk": "@@ -111,34 +112,36 @@ private static void muzzleCheck(final Transformation callback) {\n         state.closeContinuation();\n       }\n     }\n-\n-    /** Promise.Transformation was introduced in scala 2.13 */\n-    private static void muzzleCheck(final Transformation callback) {\n-      callback.submitWithValue(null);\n-    }\n   }\n \n   public static final class SubmitWithValue {\n     @Advice.OnMethodEnter\n-    public static <F, T> void beforeExecute(@Advice.This Transformation<F, T> task) {\n+    public static <F, T> void beforeExecute(\n+        @Advice.This Transformation<F, T> task, @Advice.Argument(value = 0) Try<T> resolved) {\n       // about to enter an ExecutionContext so capture the scope if necessary\n       // (this used to happen automatically when the RunnableInstrumentation\n       // was relied on, and happens anyway if the ExecutionContext is backed\n       // by a wrapping Executor (e.g. FJP, ScheduledThreadPoolExecutor)\n-      State state = InstrumentationContext.get(Transformation.class, State.class).get(task);\n+      ContextStore<Transformation, State> tStore =", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM0OTg0Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557349843", "bodyText": "oldState ?", "author": "mcculls", "createdAt": "2021-01-14T12:09:53Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.13/src/main/java/datadog/trace/instrumentation/scala/concurrent/PromiseTransformationInstrumentation.java", "diffHunk": "@@ -111,34 +112,36 @@ private static void muzzleCheck(final Transformation callback) {\n         state.closeContinuation();\n       }\n     }\n-\n-    /** Promise.Transformation was introduced in scala 2.13 */\n-    private static void muzzleCheck(final Transformation callback) {\n-      callback.submitWithValue(null);\n-    }\n   }\n \n   public static final class SubmitWithValue {\n     @Advice.OnMethodEnter\n-    public static <F, T> void beforeExecute(@Advice.This Transformation<F, T> task) {\n+    public static <F, T> void beforeExecute(\n+        @Advice.This Transformation<F, T> task, @Advice.Argument(value = 0) Try<T> resolved) {\n       // about to enter an ExecutionContext so capture the scope if necessary\n       // (this used to happen automatically when the RunnableInstrumentation\n       // was relied on, and happens anyway if the ExecutionContext is backed\n       // by a wrapping Executor (e.g. FJP, ScheduledThreadPoolExecutor)\n-      State state = InstrumentationContext.get(Transformation.class, State.class).get(task);\n+      ContextStore<Transformation, State> tStore =\n+          InstrumentationContext.get(Transformation.class, State.class);\n+      State state = tStore.get(task);\n+      if (PromiseHelper.completionPriority) {\n+        final AgentSpan span = InstrumentationContext.get(Try.class, AgentSpan.class).get(resolved);\n+        State oState = state;", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1MDgxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557350819", "bodyText": "super.isEnabled() ?", "author": "mcculls", "createdAt": "2021-01-14T12:11:43Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.13/src/main/java/datadog/trace/instrumentation/scala/concurrent/DefaultPromiseInstrumentation.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package datadog.trace.instrumentation.scala.concurrent;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static scala.concurrent.impl.Promise.Transformation;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.scala.PromiseHelper;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.util.Try;\n+\n+/**\n+ * In Scala 2.13+ there is shortcut that bypass the call to {@code resolve} for a {@code Try} when\n+ * we know that the value is already resolved, i.e. for some transformations like {@code map}, so\n+ * only pick up the completing span if the resolved {@code Try} doesn't have a an existing span set\n+ * from the {@code resolve} method.\n+ */\n+@AutoService(Instrumenter.class)\n+public class DefaultPromiseInstrumentation extends Instrumenter.Tracing {\n+\n+  public DefaultPromiseInstrumentation() {\n+    super(\"scala_promise_complete\", \"scala_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"scala.concurrent.impl.Promise$DefaultPromise\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"scala.util.Try\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return Collections.singletonMap(\n+        isMethod().and(named(\"tryComplete0\")), getClass().getName() + \"$TryComplete\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\"datadog.trace.instrumentation.scala.PromiseHelper\"};\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    // Only enable this if integrations have been enabled and the extra \"integration\"\n+    // scala_promise_completion_priority has been enabled specifically\n+    return defaultEnabled", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1MTI1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557351255", "bodyText": "super.isEnabled() ?", "author": "mcculls", "createdAt": "2021-01-14T12:12:36Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.10/src/main/java/datadog/trace/instrumentation/scala/concurrent/PromiseObjectInstrumentation210.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package datadog.trace.instrumentation.scala.concurrent;\n+\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.Config;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.scala.PromiseHelper;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import scala.concurrent.impl.CallbackRunnable;\n+import scala.util.Try;\n+\n+/**\n+ * A Scala {@code Promise} is always completed with a {@code Try}, so if we want the completing span\n+ * to take priority over any spans captured while adding computations to a {@code Future} associated\n+ * with a {@code Promise}, then we capture the active span when the {@code Try} is resolved.\n+ */\n+@AutoService(Instrumenter.class)\n+public class PromiseObjectInstrumentation210 extends Instrumenter.Tracing {\n+\n+  public PromiseObjectInstrumentation210() {\n+    super(\"scala_promise_resolve\", \"scala_concurrent\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"scala.concurrent.impl.Promise$\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return singletonMap(\"scala.util.Try\", AgentSpan.class.getName());\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return Collections.singletonMap(\n+        isMethod().and(named(\"scala$concurrent$impl$Promise$$resolveTry\")),\n+        getClass().getName() + \"$ResolveTry\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\"datadog.trace.instrumentation.scala.PromiseHelper\"};\n+  }\n+\n+  @Override\n+  public boolean isEnabled() {\n+    // Only enable this if integrations have been enabled and the extra \"integration\"\n+    // scala_promise_completion_priority has been enabled specifically\n+    return defaultEnabled", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1MTk1MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557351950", "bodyText": "contextStore ?", "author": "mcculls", "createdAt": "2021-01-14T12:13:57Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.10/src/main/java/datadog/trace/instrumentation/scala/concurrent/CallbackRunnableInstrumentation.java", "diffHunk": "@@ -93,18 +104,30 @@ public static void after(@Advice.Enter TraceScope scope) {\n \n   public static final class ExecuteWithValue {\n     @Advice.OnMethodEnter\n-    public static <T> void beforeExecute(@Advice.This CallbackRunnable<T> task) {\n+    public static <T> void beforeExecute(\n+        @Advice.This CallbackRunnable<T> task, @Advice.Argument(value = 0) Try<T> resolved) {\n       // about to enter an ExecutionContext so capture the scope if necessary\n       // (this used to happen automatically when the RunnableInstrumentation\n       // was relied on, and happens anyway if the ExecutionContext is backed\n       // by a wrapping Executor (e.g. FJP, ScheduledThreadPoolExecutor)\n-      State state = InstrumentationContext.get(CallbackRunnable.class, State.class).get(task);\n+      ContextStore<CallbackRunnable, State> rStore =", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NzU3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557357577", "bodyText": "I have different names here for tStore and rStore to separate them. Having two named contextStore would just be confusing to me.", "author": "bantonsson", "createdAt": "2021-01-14T12:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1MTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM2MTk4OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557361989", "bodyText": "Ignore that comment. I see now that refactoring has removed that. I'll change it to contextStore", "author": "bantonsson", "createdAt": "2021-01-14T12:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1MTk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1MjI1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2233#discussion_r557352256", "bodyText": "oldState ?", "author": "mcculls", "createdAt": "2021-01-14T12:14:34Z", "path": "dd-java-agent/instrumentation/scala-promise/scala-promise-2.10/src/main/java/datadog/trace/instrumentation/scala/concurrent/CallbackRunnableInstrumentation.java", "diffHunk": "@@ -93,18 +104,30 @@ public static void after(@Advice.Enter TraceScope scope) {\n \n   public static final class ExecuteWithValue {\n     @Advice.OnMethodEnter\n-    public static <T> void beforeExecute(@Advice.This CallbackRunnable<T> task) {\n+    public static <T> void beforeExecute(\n+        @Advice.This CallbackRunnable<T> task, @Advice.Argument(value = 0) Try<T> resolved) {\n       // about to enter an ExecutionContext so capture the scope if necessary\n       // (this used to happen automatically when the RunnableInstrumentation\n       // was relied on, and happens anyway if the ExecutionContext is backed\n       // by a wrapping Executor (e.g. FJP, ScheduledThreadPoolExecutor)\n-      State state = InstrumentationContext.get(CallbackRunnable.class, State.class).get(task);\n+      ContextStore<CallbackRunnable, State> rStore =\n+          InstrumentationContext.get(CallbackRunnable.class, State.class);\n+      State state = rStore.get(task);\n+      if (PromiseHelper.completionPriority) {\n+        final AgentSpan span = InstrumentationContext.get(Try.class, AgentSpan.class).get(resolved);\n+        State oState = state;", "originalCommit": "d9a8c43af3fe4924294e6e7fdee9849ffbc35879", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9d4b4ec31e34bb7cc8a8799529c1e620fb57e61a", "url": "https://github.com/DataDog/dd-trace-java/commit/9d4b4ec31e34bb7cc8a8799529c1e620fb57e61a", "message": "Changes based on PR comments", "committedDate": "2021-01-14T13:27:03Z", "type": "commit"}]}