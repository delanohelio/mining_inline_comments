{"pr_number": 2227, "pr_title": "Split Jetty instrumentation out and enable by default", "pr_createdAt": "2020-12-18T18:18:14Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2227", "timeline": [{"oid": "6d6ce17ebb0df39e8fac6297f4cf61e65bb6de6b", "url": "https://github.com/DataDog/dd-trace-java/commit/6d6ce17ebb0df39e8fac6297f4cf61e65bb6de6b", "message": "Split Jetty instrumentation out and enable by default\n\nPrior jetty instrumentation used a different operation name (`jetty.request`), but this would impact metrics if enabled when `servlet.request` was previously expected. Since it was disabled by default and considered \"beta\", this is deemed an acceptable change.\n\nCurrent instrumentation should work with Jetty 7-10 (though 10 isn't explicitly tested because it wasn't compiled for Java 8).  Jetty 11 is still not supported since it requires Servlet 4.\n\nNote the odd overlap in supported versions:\n* Jetty 8.0 is instrumented by 7.0 instrumentation\n* Jetty 8.1-8.2 is instrumented by 7.6 instrumentation\n\n[skip ci]", "committedDate": "2020-12-18T19:59:08Z", "type": "forcePushed"}, {"oid": "f79ee45fc414957a5fd91aa4630edb26ed54076d", "url": "https://github.com/DataDog/dd-trace-java/commit/f79ee45fc414957a5fd91aa4630edb26ed54076d", "message": "Split Jetty instrumentation out and enable by default\n\nPrior jetty instrumentation used a different operation name (`jetty.request`), but this would impact metrics if enabled when `servlet.request` was previously expected. Since it was disabled by default and considered \"beta\", this is deemed an acceptable change.\n\nCurrent instrumentation should work with Jetty 7-10 (though 10 isn't explicitly tested because it wasn't compiled for Java 8).  Jetty 11 is still not supported since it requires Servlet 4.\n\nNote the odd overlap in supported versions:\n* Jetty 8.0 is instrumented by 7.0 instrumentation\n* Jetty 8.1-8.2 is instrumented by 7.6 instrumentation", "committedDate": "2020-12-30T21:38:00Z", "type": "forcePushed"}, {"oid": "1cfdf9af5af0c3598b3ff143bb5d0b34a053827f", "url": "https://github.com/DataDog/dd-trace-java/commit/1cfdf9af5af0c3598b3ff143bb5d0b34a053827f", "message": "Split Jetty instrumentation out and enable by default\n\nPrior jetty instrumentation used a different operation name (`jetty.request`), but this would impact metrics if enabled when `servlet.request` was previously expected. Since it was disabled by default and considered \"beta\", this is deemed an acceptable change.\n\nCurrent instrumentation should work with Jetty 7-10 (though 10 isn't explicitly tested because it wasn't compiled for Java 8).  Jetty 11 is still not supported since it requires Servlet 4.\n\nNote the odd overlap in supported versions:\n* Jetty 8.0 is instrumented by 7.0 instrumentation\n* Jetty 8.1-8.2 is instrumented by 7.6 instrumentation", "committedDate": "2021-01-04T16:36:48Z", "type": "forcePushed"}, {"oid": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "url": "https://github.com/DataDog/dd-trace-java/commit/f72f57d7cc9f8b007d908b25628d5a0a69198156", "message": "Split Jetty instrumentation out and enable by default\n\nPrior jetty instrumentation used a different operation name (`jetty.request`), but this would impact metrics if enabled when `servlet.request` was previously expected. Since it was disabled by default and considered \"beta\", this is deemed an acceptable change.\n\nCurrent instrumentation should work with Jetty 7-10 (though 10 isn't explicitly tested because it wasn't compiled for Java 8).  Jetty 11 is still not supported since it requires Servlet 4.\n\nNote the odd overlap in supported versions:\n* Jetty 8.0 is instrumented by 7.0 instrumentation\n* Jetty 8.1-8.2 is instrumented by 7.6 instrumentation", "committedDate": "2021-01-04T17:41:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwOTM2OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551509369", "bodyText": "Out of interest is there something better than this we could use at this level of specificity?", "author": "richardstartin", "createdAt": "2021-01-04T19:07:41Z", "path": "dd-java-agent/instrumentation/jetty-7.0/src/main/java/datadog/trace/instrumentation/jetty70/HttpServletRequestExtractAdapter.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package datadog.trace.instrumentation.jetty70;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentPropagation;\n+import java.util.Enumeration;\n+import javax.servlet.http.HttpServletRequest;\n+\n+public class HttpServletRequestExtractAdapter\n+    implements AgentPropagation.ContextVisitor<HttpServletRequest> {\n+\n+  public static final HttpServletRequestExtractAdapter GETTER =\n+      new HttpServletRequestExtractAdapter();\n+\n+  @Override\n+  public void forEachKey(HttpServletRequest carrier, AgentPropagation.KeyClassifier classifier) {\n+    Enumeration<String> headerNames = carrier.getHeaderNames();\n+    while (headerNames.hasMoreElements()) {", "originalCommit": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3NTIzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551575235", "bodyText": "#2227 (comment)", "author": "tylerbenson", "createdAt": "2021-01-04T21:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwOTM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMDQwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551510402", "bodyText": "Not sure how those PascalCase parameter names got through, seems we're using the wrong conventions. This makes instance calls look like static calls.", "author": "richardstartin", "createdAt": "2021-01-04T19:09:15Z", "path": "dd-java-agent/instrumentation/jetty-7.0/src/main/java/datadog/trace/instrumentation/jetty70/JettyDecorator.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package datadog.trace.instrumentation.jetty70;\n+\n+import datadog.trace.bootstrap.instrumentation.api.URIDataAdapter;\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.bootstrap.instrumentation.decorator.HttpServerDecorator;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Response;\n+\n+public class JettyDecorator extends HttpServerDecorator<Request, Request, Response> {\n+  public static final CharSequence SERVLET_REQUEST = UTF8BytesString.create(\"servlet.request\");\n+  public static final CharSequence JETTY_SERVER = UTF8BytesString.create(\"jetty-server\");\n+  public static final JettyDecorator DECORATE = new JettyDecorator();\n+  public static final String DD_CONTEXT_PATH_ATTRIBUTE = \"datadog.context.path\";\n+  public static final String DD_SERVLET_PATH_ATTRIBUTE = \"datadog.servlet.path\";\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"jetty\"};\n+  }\n+\n+  @Override\n+  protected CharSequence component() {\n+    return JETTY_SERVER;\n+  }\n+\n+  @Override\n+  protected String method(final Request Request) {\n+    return Request.getMethod();\n+  }\n+\n+  @Override\n+  protected URIDataAdapter url(final Request Request) {\n+    return new RequestURIDataAdapter(Request);\n+  }\n+\n+  @Override\n+  protected String peerHostIP(final Request Request) {\n+    return Request.getRemoteAddr();\n+  }\n+\n+  @Override\n+  protected int peerPort(final Request Request) {\n+    return Request.getRemotePort();\n+  }", "originalCommit": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxODg0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551518840", "bodyText": "oops.  This is probably a bad find/replace.  Good catch.", "author": "tylerbenson", "createdAt": "2021-01-04T19:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMDQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxOTI4Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551519282", "bodyText": "I'm more worried about the format checker than this particular instance of the problem", "author": "richardstartin", "createdAt": "2021-01-04T19:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMDQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3NjUxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551576515", "bodyText": "We don't actually have checkstyle anymore (I forgot we removed it) and apparently this isn't something that google java format cares about.", "author": "tylerbenson", "createdAt": "2021-01-04T21:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMDQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMTI3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551511273", "bodyText": "I thought there was some consensus against hooking the status code being set like this? Am I mistaken?", "author": "richardstartin", "createdAt": "2021-01-04T19:10:56Z", "path": "dd-java-agent/instrumentation/jetty-7.0/src/main/java/datadog/trace/instrumentation/jetty70/JettyGeneratorInstrumentation.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package datadog.trace.instrumentation.jetty70;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.eclipse.jetty.http.Generator;\n+import org.eclipse.jetty.server.HttpConnection;\n+import org.eclipse.jetty.server.Response;\n+\n+@AutoService(Instrumenter.class)\n+public final class JettyGeneratorInstrumentation extends Instrumenter.Tracing {\n+\n+  public JettyGeneratorInstrumentation() {\n+    super(\"jetty\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.eclipse.jetty.http.Generator\"));\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    // The lifecycle of these objects are aligned, and are recycled by jetty, minimizing leak risk.\n+    return singletonMap(\"org.eclipse.jetty.http.Generator\", \"org.eclipse.jetty.server.Response\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        named(\"setResponse\").and(takesArgument(0, int.class)),\n+        JettyGeneratorInstrumentation.class.getName() + \"$SetResponseAdvice\");\n+  }\n+\n+  // This advice ensures that the right status is updated on the response.\n+  public static class SetResponseAdvice {\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static void updateResponse(\n+        @Advice.This final Generator generator, @Advice.Argument(0) final int status) {\n+      Response response =\n+          InstrumentationContext.get(Generator.class, Response.class).get(generator);\n+      if (response != null) {\n+        response.setStatus(status);\n+      }\n+    }", "originalCommit": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MTM0NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551561345", "bodyText": "In cases where an exception is thrown to the app server, Jetty doesn't necessarily set the 500 status code on the response.  Instead it writes it directly to the \"generator\". This instrumentation slightly modifies that behavior so that the response is correctly updated, allowing that instrumentation to get the correct status from the response. This instrumentation isn't touching the span directly.", "author": "tylerbenson", "createdAt": "2021-01-04T20:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3MTkzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551571935", "bodyText": "I understand that, but this doesn't look like the right approach. I don't think we should be mutating the Response object like this for the sake of tracing convenience, which makes me think this is the wrong level to instrument at. Generator is extremely low level, and if this really is the right level, I would prefer to instrument sendError instead to capture status codes and - leaving the Response object alone at all costs - associate the span with the generator and set a tag on the span in sendError.", "author": "richardstartin", "createdAt": "2021-01-04T21:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5ODU1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551598552", "bodyText": "I can try to instrument org.eclipse.jetty.http.AbstractGenerator#sendError instead, but I think it will result in more complicated instrumentation because the lifecycle of a span is different from the Generator (something you've expressed concerns about in the past).", "author": "tylerbenson", "createdAt": "2021-01-04T22:08:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwMzc3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551603775", "bodyText": "This sort of thing makes me uncomfortable - the question has to be why isn't the status code set? Perhaps it's a performance optimisation - the Response is dead as far as Jetty is concerned so why bother setting the status code? If this is the intent of the framework, this is OK. On the other hand, if this perturbs downstream logic the approach is just wrong, and we've had problems of that nature in the past with Spring, invoking all HandlerMappings in a Filter to get HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE set for our own convenience but badly breaking the application. I looked around and I can't see any obvious negative side effects following on from setting the Response's status code.\n\nbecause the lifecycle of a span is different from the Generator (something you've expressed concerns about in the past)\n\nI don't recall expressing concerns like that. My personal priorities when I create or review PRs, such as this one, are as follows:\n\nNo observable side effects (e.g. don't invoke unknown HandlerMappings with unknown consequences, don't set a status code on an application object if there may be logic downstream)\nMake it efficient\nDeveloper convenience", "author": "richardstartin", "createdAt": "2021-01-04T22:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMDEwMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551610102", "bodyText": "I think in order to resolve this there needs to be some explanation in a comment about if and why it's OK to set the Response's (i.e. an application object) status code without perturbing any downstream logic. This way, if at some point in the future this breaks, it will be more obvious why because it will be clear that the author was under the impression that this was benign. I think adding something in to the comment about how this helps meet HttpServerDecorator.onResponses expectations that the status code has been set so the coupling is made clear.", "author": "richardstartin", "createdAt": "2021-01-04T22:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMTI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMjE3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551512179", "bodyText": "I have to ask - what happens if this assumption is violated? I think the consequences should be included in a comment like this.", "author": "richardstartin", "createdAt": "2021-01-04T19:12:50Z", "path": "dd-java-agent/instrumentation/jetty-7.0/src/main/java/datadog/trace/instrumentation/jetty70/JettyServerInstrumentation.java", "diffHunk": "@@ -0,0 +1,142 @@\n+package datadog.trace.instrumentation.jetty70;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.bootstrap.instrumentation.decorator.HttpServerDecorator.DD_SPAN_ATTRIBUTE;\n+import static datadog.trace.instrumentation.jetty70.HttpServletRequestExtractAdapter.GETTER;\n+import static datadog.trace.instrumentation.jetty70.JettyDecorator.DECORATE;\n+import static datadog.trace.instrumentation.jetty70.JettyDecorator.SERVLET_REQUEST;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isConstructor;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesNoArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.Config;\n+import datadog.trace.api.CorrelationIdentifier;\n+import datadog.trace.api.DDTags;\n+import datadog.trace.api.GlobalTracer;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.eclipse.jetty.http.Generator;\n+import org.eclipse.jetty.server.HttpConnection;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Response;\n+\n+@AutoService(Instrumenter.class)\n+public final class JettyServerInstrumentation extends Instrumenter.Tracing {\n+\n+  public JettyServerInstrumentation() {\n+    super(\"jetty\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"org.eclipse.jetty.server.HttpConnection\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".JettyDecorator\",\n+      packageName + \".HttpServletRequestExtractAdapter\",\n+      packageName + \".RequestURIDataAdapter\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    // The lifecycle of these objects are aligned, and are recycled by jetty, minimizing leak risk.\n+    return singletonMap(\"org.eclipse.jetty.http.Generator\", \"org.eclipse.jetty.server.Response\");\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isConstructor(), JettyServerInstrumentation.class.getName() + \"$ConstructorAdvice\");\n+    transformers.put(\n+        named(\"handleRequest\").and(takesNoArguments()),\n+        JettyServerInstrumentation.class.getName() + \"$HandleRequestAdvice\");\n+    transformers.put(\n+        named(\"reset\").and(takesArgument(0, boolean.class)),\n+        JettyServerInstrumentation.class.getName() + \"$ResetAdvice\");\n+    return transformers;\n+  }\n+\n+  // This advice is needed to link the Generator with the Response so we can get the right status\n+  public static class ConstructorAdvice {\n+    @Advice.OnMethodExit(suppress = Throwable.class)\n+    public static void link(\n+        @Advice.FieldValue(\"_generator\") final Generator generator,\n+        @Advice.FieldValue(\"_response\") final Response response) {\n+      InstrumentationContext.get(Generator.class, Response.class).put(generator, response);\n+    }\n+  }\n+\n+  // handleRequest is used instead of handle to allow the incoming request to be fully parsed.\n+  public static class HandleRequestAdvice {\n+\n+    @Advice.OnMethodEnter(suppress = Throwable.class)\n+    public static AgentScope onEnter(@Advice.This final HttpConnection connection) {\n+      Request req = connection.getRequest();\n+\n+      Object existingSpan = req.getAttribute(DD_SPAN_ATTRIBUTE);\n+      if (existingSpan instanceof AgentSpan) {\n+        // Request already gone through initial processing.\n+        return activateSpan((AgentSpan) existingSpan);\n+      }\n+\n+      final AgentSpan.Context extractedContext = propagate().extract(req, GETTER);\n+\n+      final AgentSpan span = startSpan(SERVLET_REQUEST, extractedContext).setMeasured(true);\n+      DECORATE.afterStart(span);\n+      DECORATE.onConnection(span, req);\n+      DECORATE.onRequest(span, req);\n+\n+      final AgentScope scope = activateSpan(span);\n+      scope.setAsyncPropagation(true);\n+      req.setAttribute(DD_SPAN_ATTRIBUTE, span);\n+      req.setAttribute(CorrelationIdentifier.getTraceIdKey(), GlobalTracer.get().getTraceId());\n+      req.setAttribute(CorrelationIdentifier.getSpanIdKey(), GlobalTracer.get().getSpanId());\n+      return scope;\n+    }\n+\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class)\n+    public static void closeScope(@Advice.Enter final AgentScope scope) {\n+      scope.close();\n+    }\n+  }\n+\n+  // Working assumption is that all channels get reset rather than GC'd.\n+  // This should give us the final status code and the broadest span time measurement.", "originalCommit": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUzNzkwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551537901", "bodyText": "I'll include a comment.  The effect of this assumption failing (for example by the connection being discarded rather than recycled) is that the span would not complete (and should be garbage collected along with the request).", "author": "tylerbenson", "createdAt": "2021-01-04T20:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMjE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYwNjI1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551606251", "bodyText": "I think the comment should state when the assumption can be violated. Why is it reasonable to assume the channels get reset instead of garbage collected? Why would they be garbage collected instead of reset. Should this virtually never happen or does it only happen during high load or does it happen most of the time?", "author": "richardstartin", "createdAt": "2021-01-04T22:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMjE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyMDM4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551620384", "bodyText": "As far as I could observe on the few versions that I tested, this seems to always happen.  I don't know how to definitively prove it though. Ideas?", "author": "tylerbenson", "createdAt": "2021-01-04T23:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMjE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzMTE1MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551631150", "bodyText": "Having looked at the implementation of HttpConnection in Jetty 7.0.0 I find this comment a little misleading - I think you're trying to say that you expect HttpConnection.handle() to complete, since the call to handleRequest is being used to mark the start of the span, and the call to reset(boolean) in the finally block is being used to complete the span. Is the mention of garbage collection because you think it can cause this loop to terminate abruptly without the finally block containing the call to reset executing? I don't see how correctness could be related to garbage collection here? The finally block containing the call to reset must execute if handleRequest is invoked.\n    public void handle() throws IOException\n    {\n        // Loop while more in buffer\n        boolean more_in_buffer =true; // assume true until proven otherwise\n        boolean progress=true;\n        \n        try\n        {               \n            assert getCurrentConnection()==null;\n            assert _handling==false;\n            _handling=true;\n            setCurrentConnection(this);\n\n            while (more_in_buffer)\n            {\n                try\n                {\n                    if (_request._async.isAsync())\n                    {\n                        // TODO - handle the case of input being read for a \n                        // suspended request.\n                        \n                        Log.debug(\"async request\",_request);\n                        if (!_request._async.isComplete())\n                            handleRequest();\n                        else if (!_parser.isComplete()) \n                        {\n                            long parsed=_parser.parseAvailable();\n                            progress|=parsed>0;\n                        }\n                        \n                        if (_generator.isCommitted() && !_generator.isComplete())\n                            progress|=_generator.flushBuffer()>0;\n                        if (_endp.isBufferingOutput())\n                            _endp.flush();\n                    }\n                    else\n                    {\n                        // If we are not ended then parse available\n                        if (!_parser.isComplete()) \n                            progress|=_parser.parseAvailable()>0;\n\n                        // Do we have more generating to do?\n                        // Loop here because some writes may take multiple steps and\n                        // we need to flush them all before potentially blocking in the\n                        // next loop.\n                        while (_generator.isCommitted() && !_generator.isComplete())\n                        {\n                            long written=_generator.flushBuffer();\n                            if (written<=0)\n                                break;\n                            progress=true;\n                            if (_endp.isBufferingOutput())\n                                _endp.flush();\n                        }\n\n                        // Flush buffers\n                        if (_endp.isBufferingOutput())\n                        {\n                            _endp.flush();\n                            if (!_endp.isBufferingOutput())\n                                progress=true;\n                        }\n\n                        if (!progress) \n                            return;\n                    }\n                    progress=false;\n                }\n                catch (HttpException e)\n                {\n                    if (Log.isDebugEnabled())\n                    {\n                        Log.debug(\"uri=\"+_uri);\n                        Log.debug(\"fields=\"+_requestFields);\n                        Log.debug(e);\n                    }\n                    _generator.sendError(e.getStatus(), e.getReason(), null, true);\n\n                    _parser.reset(true);\n                    _endp.close();\n                    throw e;\n                }\n                finally\n                {\n                    more_in_buffer = _parser.isMoreInBuffer() || _endp.isBufferingInput();  \n\n                    if (_parser.isComplete() && _generator.isComplete() && !_endp.isBufferingOutput())\n                    {  \n                        if (!_generator.isPersistent())\n                        {\n                            _parser.reset(true);\n                            more_in_buffer=false;\n                        }\n\n                        if (more_in_buffer)\n                        {\n                            reset(false);\n                            more_in_buffer = _parser.isMoreInBuffer() || _endp.isBufferingInput(); \n                        }\n                        else\n                            reset(true);\n                        progress=true;\n                    }\n\n                    if (_request.isAsyncStarted())\n                    {\n                        Log.debug(\"return with suspended request\");\n                        more_in_buffer=false;\n                    }\n                    else if (_generator.isCommitted() && !_generator.isComplete() && _endp instanceof SelectChannelEndPoint) // TODO remove SelectChannel dependency\n                        ((SelectChannelEndPoint)_endp).setWritable(false);\n                }\n            }\n        }\n        finally\n        {\n            setCurrentConnection(null);\n            _handling=false;\n        }\n    }", "author": "richardstartin", "createdAt": "2021-01-04T23:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxMjE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxNDYyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551514620", "bodyText": "Again, since we're being really specific can we target a container specific carrier with better APIs here?", "author": "richardstartin", "createdAt": "2021-01-04T19:17:32Z", "path": "dd-java-agent/instrumentation/jetty-7.6/src/main/java/datadog/trace/instrumentation/jetty76/HttpServletRequestExtractAdapter.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package datadog.trace.instrumentation.jetty76;\n+\n+import datadog.trace.bootstrap.instrumentation.api.AgentPropagation;\n+import java.util.Enumeration;\n+import javax.servlet.http.HttpServletRequest;\n+\n+public class HttpServletRequestExtractAdapter\n+    implements AgentPropagation.ContextVisitor<HttpServletRequest> {\n+\n+  public static final HttpServletRequestExtractAdapter GETTER =\n+      new HttpServletRequestExtractAdapter();\n+\n+  @Override\n+  public void forEachKey(HttpServletRequest carrier, AgentPropagation.KeyClassifier classifier) {\n+    Enumeration<String> headerNames = carrier.getHeaderNames();", "originalCommit": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU0MDg1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551540855", "bodyText": "I'll change the type to be the jetty Request instead.  Unfortunately it doesn't seem like there is any better method to use, so we're stuck with Enumeration getHeaderNames().", "author": "tylerbenson", "createdAt": "2021-01-04T20:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxNDYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3NTgzNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551575834", "bodyText": "Request.getAttributes() gives you an AttributesMap which is a wrapper around a HashMap which is probably a better choice. It exposes the map's key set.", "author": "richardstartin", "createdAt": "2021-01-04T21:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxNDYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NDU0Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551594547", "bodyText": "but we want the headers, not the attributes.\nThe underlying code for headers is HttpFields, so maybe we could use org.eclipse.jetty.http.HttpFields#getFieldNamesCollection, but I don't think that will help that much since it requires a copy and isn't available on older versions.", "author": "tylerbenson", "createdAt": "2021-01-04T21:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxNDYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxNzEwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551517107", "bodyText": "org.eclipse.jetty.http.Generator is an interface, but it seems to have a fairly stable implementation hierarchy. Could we match on named(\"org.eclipse.jetty.http.HttpGenerator\") but create a context store as above instead? Does the comment above necessarily hold if the implementation of Generator is user supplied? Can it be user supplied?", "author": "richardstartin", "createdAt": "2021-01-04T19:22:33Z", "path": "dd-java-agent/instrumentation/jetty-7.6/src/main/java/datadog/trace/instrumentation/jetty76/JettyGeneratorInstrumentation.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package datadog.trace.instrumentation.jetty76;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.eclipse.jetty.http.Generator;\n+import org.eclipse.jetty.server.AbstractHttpConnection;\n+import org.eclipse.jetty.server.Response;\n+\n+@AutoService(Instrumenter.class)\n+public final class JettyGeneratorInstrumentation extends Instrumenter.Tracing {\n+\n+  public JettyGeneratorInstrumentation() {\n+    super(\"jetty\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.eclipse.jetty.http.Generator\"));\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    // The lifecycle of these objects are aligned, and are recycled by jetty, minimizing leak risk.\n+    return singletonMap(\"org.eclipse.jetty.http.Generator\", \"org.eclipse.jetty.server.Response\");", "originalCommit": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU0Mzk2OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551543969", "bodyText": "Jetty 8.2 has a protected newHttpGenerator factory method where a custom generator could potentially be returned.  I'm not too concerned about that case though and would be willing to adjust since the purpose of this instrumentation is to ensure an accurate status code when exceptions are thrown.  So if they are using a custom generator, there would be relatively minimal loss in functionality.", "author": "tylerbenson", "createdAt": "2021-01-04T20:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxNzEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1NDc3MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551554770", "bodyText": "I'll change the instrumentation to use AbstractGenerator instead. That is where the instrumented method is declared.", "author": "tylerbenson", "createdAt": "2021-01-04T20:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxNzEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUxODIwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2227#discussion_r551518200", "bodyText": "We're using namedOneOf elsewhere.", "author": "richardstartin", "createdAt": "2021-01-04T19:24:35Z", "path": "dd-java-agent/instrumentation/jetty-9/src/main/java/datadog/trace/instrumentation/jetty9/JettyServerInstrumentation.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package datadog.trace.instrumentation.jetty9;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.bootstrap.instrumentation.decorator.HttpServerDecorator.DD_SPAN_ATTRIBUTE;\n+import static datadog.trace.instrumentation.jetty9.HttpServletRequestExtractAdapter.GETTER;\n+import static datadog.trace.instrumentation.jetty9.JettyDecorator.DECORATE;\n+import static datadog.trace.instrumentation.jetty9.JettyDecorator.SERVLET_REQUEST;\n+import static net.bytebuddy.matcher.ElementMatchers.declaresMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesNoArguments;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.api.Config;\n+import datadog.trace.api.CorrelationIdentifier;\n+import datadog.trace.api.DDTags;\n+import datadog.trace.api.GlobalTracer;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.eclipse.jetty.server.HttpChannel;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.Response;\n+\n+@AutoService(Instrumenter.class)\n+public final class JettyServerInstrumentation extends Instrumenter.Tracing {\n+\n+  public JettyServerInstrumentation() {\n+    super(\"jetty\", \"jetty-9\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return named(\"org.eclipse.jetty.server.HttpChannel\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".JettyDecorator\",\n+      packageName + \".HttpServletRequestExtractAdapter\",\n+      packageName + \".RequestURIDataAdapter\",\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        takesNoArguments()\n+            .and(\n+                named(\"handle\")\n+                    .or(\n+                        // In 9.0.3 the handle logic was extracted out to \"handle\"\n+                        // but we still want to instrument run in case handle is missing\n+                        // (without the risk of double instrumenting).\n+                        named(\"run\")\n+                            .and(\n+                                new ElementMatcher.Junction.AbstractBase<MethodDescription>() {\n+                                  @Override\n+                                  public boolean matches(MethodDescription target) {\n+                                    // TODO this could probably be made into a nicer matcher.\n+                                    return !declaresMethod(named(\"handle\"))\n+                                        .matches(target.getDeclaringType().asErasure());\n+                                  }\n+                                }))),\n+        JettyServerInstrumentation.class.getName() + \"$HandleAdvice\");\n+    transformers.put(\n+        // name changed to recycle in 9.3.0\n+        named(\"reset\").or(named(\"recycle\")).and(takesNoArguments()),", "originalCommit": "f72f57d7cc9f8b007d908b25628d5a0a69198156", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6eddfcdcacc31be091c71f2806c920d8242ca87c", "url": "https://github.com/DataDog/dd-trace-java/commit/6eddfcdcacc31be091c71f2806c920d8242ca87c", "message": "Code Review Fixes", "committedDate": "2021-01-04T22:49:20Z", "type": "forcePushed"}, {"oid": "c44e6f49e9dcdf4e8dc2badd299120e334efd521", "url": "https://github.com/DataDog/dd-trace-java/commit/c44e6f49e9dcdf4e8dc2badd299120e334efd521", "message": "Split Jetty instrumentation out and enable by default\n\nPrior jetty instrumentation used a different operation name (`jetty.request`), but this would impact metrics if enabled when `servlet.request` was previously expected. Since it was disabled by default and considered \"beta\", this is deemed an acceptable change.\n\nCurrent instrumentation should work with Jetty 7-10 (though 10 isn't explicitly tested because it wasn't compiled for Java 8).  Jetty 11 is still not supported since it requires Servlet 4.\n\nNote the odd overlap in supported versions:\n* Jetty 8.0 is instrumented by 7.0 instrumentation\n* Jetty 8.1-8.2 is instrumented by 7.6 instrumentation", "committedDate": "2021-01-05T19:53:18Z", "type": "commit"}, {"oid": "5381ae584ce321567837e6b8d9030f7eeaea493a", "url": "https://github.com/DataDog/dd-trace-java/commit/5381ae584ce321567837e6b8d9030f7eeaea493a", "message": "Code Review Fixes", "committedDate": "2021-01-05T19:56:00Z", "type": "commit"}, {"oid": "943ecf0b1ad1dc07989902c4a7320b9c551f279c", "url": "https://github.com/DataDog/dd-trace-java/commit/943ecf0b1ad1dc07989902c4a7320b9c551f279c", "message": "Improve comments", "committedDate": "2021-01-05T19:56:00Z", "type": "commit"}, {"oid": "943ecf0b1ad1dc07989902c4a7320b9c551f279c", "url": "https://github.com/DataDog/dd-trace-java/commit/943ecf0b1ad1dc07989902c4a7320b9c551f279c", "message": "Improve comments", "committedDate": "2021-01-05T19:56:00Z", "type": "forcePushed"}]}