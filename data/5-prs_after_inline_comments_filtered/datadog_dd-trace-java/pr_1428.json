{"pr_number": 1428, "pr_title": "Implementation of JFR binary format writer", "pr_createdAt": "2020-05-04T15:47:34Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1428", "timeline": [{"oid": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088", "url": "https://github.com/DataDog/dd-trace-java/commit/a9ce361bc89e70019e3b4cdb780590bdb3f8e088", "message": "Minimum viable implementation of JFR binary format writer", "committedDate": "2020-05-04T15:37:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjIwMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419546203", "bodyText": "It is very unclear what is the aim here: is there some sampling going on? If so it is hard to see it in the code.", "author": "mar-kolya", "createdAt": "2020-05-04T16:02:00Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/sampler/SamplerWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package com.datadog.profiling.sampler;\n+\n+import com.datadog.profiling.jfr.JfrChunkWriter;\n+import com.datadog.profiling.jfr.JfrWriter;\n+import com.datadog.profiling.jfr.Type;\n+import com.datadog.profiling.jfr.TypedValue;\n+import com.datadog.profiling.jfr.Types;\n+import java.io.IOException;\n+import java.lang.management.ThreadInfo;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public final class SamplerWriter {", "originalCommit": "a9ce361bc89e70019e3b4cdb780590bdb3f8e088", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3Mjk3OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419572978", "bodyText": "As another data point, I would expect SampleWriter to write samples, but a SamplingWriter to sample and write, just as I would expect JfrChunkWriter to write JFR chunks, as opposed to applying a chunking operation.", "author": "richardstartin", "createdAt": "2020-05-04T16:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NzQzOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420297438", "bodyText": "Well, naming is hard \ud83d\ude01\nWhat would be the proper name for something that takes thread info generated by a JMX thread sampler and turns that into JFR events and writes them?", "author": "jbachorik", "createdAt": "2020-05-05T17:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU0NjIwMw=="}], "type": "inlineReview"}, {"oid": "651b02e07f40b00f5017c94799d24e989562b068", "url": "https://github.com/DataDog/dd-trace-java/commit/651b02e07f40b00f5017c94799d24e989562b068", "message": "Fix typo", "committedDate": "2020-05-04T16:30:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419570194", "bodyText": "Is it worth using Unsafe.putLong here for efficiency?", "author": "richardstartin", "createdAt": "2020-05-04T16:37:34Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);\n+  private byte[] array;\n+  private int pointer = 0;\n+\n+  ByteArrayWriter(int size) {\n+    array = new byte[size];\n+  }\n+\n+  ByteArrayWriter writeChar(char data) {\n+    writeChar(pointer, data);\n+    return this;\n+  }\n+\n+  long writeChar(long offset, char data) {\n+    return writeByte(offset, (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeShort(short data) {\n+    writeShort(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShort(long offset, short data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  ByteArrayWriter writeInt(int data) {\n+    writeInt(pointer, data);\n+    return this;\n+  }\n+\n+  long writeInt(long offset, int data) {\n+    return writeLong(offset, data);\n+  }\n+\n+  static int getPackedIntLen(long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 1;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 2;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 3;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 4;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 5;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 6;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 7;\n+    }\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return 8;\n+    }\n+    return 9;\n+  }\n+\n+  ByteArrayWriter writeLong(long data) {\n+    writeLong(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLong(long offset, long data) {\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    data >>= 7;\n+    if ((data & COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  ByteArrayWriter writeFloat(float data) {\n+    writeFloat(pointer, data);\n+    return this;\n+  }\n+\n+  long writeFloat(long offset, float data) {\n+    return writeIntRaw(offset, Float.floatToIntBits(data));\n+  }\n+\n+  ByteArrayWriter writeDouble(double data) {\n+    writeDouble(pointer, data);\n+    return this;\n+  }\n+\n+  long writeDouble(long offset, double data) {\n+    return writeLongRaw(offset, Double.doubleToLongBits(data));\n+  }\n+\n+  ByteArrayWriter writeBoolean(boolean data) {\n+    writeBoolean(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  ByteArrayWriter writeByte(byte data) {\n+    writeByte(pointer, data);\n+    return this;\n+  }\n+\n+  long writeByte(long offset, byte data) {\n+    int newOffset = (int) (offset + 1);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    array[(int) offset] = data;\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeBytes(byte... data) {\n+    writeBytes(pointer, data);\n+    return this;\n+  }\n+\n+  long writeBytes(long offset, byte... data) {\n+    int newOffset = (int) (offset + data.length);\n+    if (newOffset >= array.length) {\n+      array = Arrays.copyOf(array, newOffset * 2);\n+    }\n+    System.arraycopy(data, 0, array, (int) offset, data.length);\n+    pointer = Math.max(newOffset, pointer);\n+    return newOffset;\n+  }\n+\n+  ByteArrayWriter writeUTF(String data) {\n+    writeUTF(pointer, data);\n+    return this;\n+  }\n+\n+  long writeUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);\n+    pos = writeInt(pos, out.length);\n+    pos = writeBytes(pos, out);\n+    return pos;\n+  }\n+\n+  ByteArrayWriter writeShortRaw(short data) {\n+    writeShortRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeShortRaw(long offset, short data) {\n+    return writeBytes(offset, (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeIntRaw(int data) {\n+    writeIntRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeIntRaw(long offset, int data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 24) & 0xff),\n+        (byte) ((data >> 16) & 0xff),\n+        (byte) ((data >> 8) & 0xff),\n+        (byte) (data & 0xff));\n+  }\n+\n+  ByteArrayWriter writeLongRaw(long data) {\n+    writeLongRaw(pointer, data);\n+    return this;\n+  }\n+\n+  long writeLongRaw(long offset, long data) {\n+    return writeBytes(\n+        offset,\n+        (byte) ((data >> 56) & 0xff),", "originalCommit": "651b02e07f40b00f5017c94799d24e989562b068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MjkyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420292929", "bodyText": "I am a bit afraid of the interplay with various JDK versions :/\nHaving Unsafe in one's codebase is becoming a huge landmine nowadays, unfortunately.", "author": "jbachorik", "createdAt": "2020-05-05T17:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwMzM0Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420303347", "bodyText": "Well, if you use ByteBuffer, it will handle this for you without performing this expensive operation.", "author": "richardstartin", "createdAt": "2020-05-05T18:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwOTg0Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420309843", "bodyText": "Yes, ByteBuffer and/or memory mapped file would be the next step - once we get out of the PoC phase and will decide that we want to really productize this.", "author": "jbachorik", "createdAt": "2020-05-05T18:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MDE5NA=="}], "type": "inlineReview"}, {"oid": "892c581fb0d3dfec657954a630c8e9c98475cfe2", "url": "https://github.com/DataDog/dd-trace-java/commit/892c581fb0d3dfec657954a630c8e9c98475cfe2", "message": "Add comments", "committedDate": "2020-05-04T18:24:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419940345", "bodyText": "Could use -EXT_BIT instead.", "author": "richardstartin", "createdAt": "2020-05-05T08:21:43Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/ByteArrayWriter.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+/** JFR specific binary encoding writer. Data is written to auto-scaled byte-array. */\n+final class ByteArrayWriter {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = ~((EXT_BIT - 1) & 0xff);", "originalCommit": "892c581fb0d3dfec657954a630c8e9c98475cfe2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjU3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420296575", "bodyText": "I think it will get messed up by the Java handling of everything as signed :/\nI even tried the suggested change but the files is not loadable afterwards.", "author": "jbachorik", "createdAt": "2020-05-05T17:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwMjY0Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420302646", "bodyText": "You mean\nprivate static final long COMPRESSED_INT_MASK = -EXT_BIT;\ndoesn't work? (in 2's complement they are equivalent expressions)", "author": "richardstartin", "createdAt": "2020-05-05T18:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxMjI4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r420312284", "bodyText": "D'oh ... I left the & 0xff part there ... When I remove it the file is not corrupted.", "author": "jbachorik", "createdAt": "2020-05-05T18:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk0MDM0NQ=="}], "type": "inlineReview"}, {"oid": "0423be9bf5a82feed23c136641bba82c39dc3b12", "url": "https://github.com/DataDog/dd-trace-java/commit/0423be9bf5a82feed23c136641bba82c39dc3b12", "message": "Add support for annotation elements.\nWithout annotation elements the JMC parser gets confused when parsing timestamps, time spans etc.", "committedDate": "2020-05-05T14:17:50Z", "type": "commit"}, {"oid": "091e25510c93e46345aca97a80f692e81df607c6", "url": "https://github.com/DataDog/dd-trace-java/commit/091e25510c93e46345aca97a80f692e81df607c6", "message": "Remove the cyclical dependency between Metadata-Types-TypeFactory", "committedDate": "2020-05-05T16:12:58Z", "type": "commit"}, {"oid": "5cd0a3b6ef33a6c7881465b05eba05096b36492c", "url": "https://github.com/DataDog/dd-trace-java/commit/5cd0a3b6ef33a6c7881465b05eba05096b36492c", "message": "Add annotation registration support method to JFRWriter", "committedDate": "2020-05-05T17:45:45Z", "type": "commit"}, {"oid": "97188b2007f9a9c413b97dc32324b67fc4b58688", "url": "https://github.com/DataDog/dd-trace-java/commit/97188b2007f9a9c413b97dc32324b67fc4b58688", "message": "First batch of unit tests", "committedDate": "2020-05-05T17:53:00Z", "type": "commit"}, {"oid": "af00f3fa8c919f8068acecb4d873e2f90890115f", "url": "https://github.com/DataDog/dd-trace-java/commit/af00f3fa8c919f8068acecb4d873e2f90890115f", "message": "Simplify the the COMPRESSED_INT_MASK calculation", "committedDate": "2020-05-05T18:17:43Z", "type": "commit"}, {"oid": "7930576fc85e341ecea634b56de0a655fcd60efd", "url": "https://github.com/DataDog/dd-trace-java/commit/7930576fc85e341ecea634b56de0a655fcd60efd", "message": "Another batch of unit tests", "committedDate": "2020-05-06T17:52:37Z", "type": "commit"}, {"oid": "c96bd9d1aedb54397d83a90017d2dd59452073a1", "url": "https://github.com/DataDog/dd-trace-java/commit/c96bd9d1aedb54397d83a90017d2dd59452073a1", "message": "Another batch of unit tests", "committedDate": "2020-05-07T18:31:25Z", "type": "commit"}, {"oid": "6c9e3993954373014400cd2c1a6af21613769c77", "url": "https://github.com/DataDog/dd-trace-java/commit/6c9e3993954373014400cd2c1a6af21613769c77", "message": "Move ChunkTest to the right place", "committedDate": "2020-05-07T18:37:33Z", "type": "commit"}, {"oid": "44a0fc70631d19c08af61acb2912b3e491a8c6be", "url": "https://github.com/DataDog/dd-trace-java/commit/44a0fc70631d19c08af61acb2912b3e491a8c6be", "message": "Next batch of tests and cleanups", "committedDate": "2020-05-11T13:27:25Z", "type": "commit"}, {"oid": "62e9580ff90901b27ce18820336cb772d87a6d2b", "url": "https://github.com/DataDog/dd-trace-java/commit/62e9580ff90901b27ce18820336cb772d87a6d2b", "message": "Make IBM Java8 happy", "committedDate": "2020-05-11T13:56:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyNTkxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r419925910", "bodyText": "why not putting this a static (constant) field?", "author": "jpbempel", "createdAt": "2020-05-05T07:54:23Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/BaseJFRType.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+/** Common JFR type super-class */\n+abstract class BaseJFRType implements JFRType {\n+  private final long id;\n+  private final String name;\n+  private final String supertype;\n+  private final ConstantPools constantPools;\n+  private final Types types;\n+  private final TypedValue nullValue = TypedValue.of(this, (Object) null);", "originalCommit": "892c581fb0d3dfec657954a630c8e9c98475cfe2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NjQxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423676414", "bodyText": "Because it needs a link to the actual type instance. I started with a static field but it didn't work.", "author": "jbachorik", "createdAt": "2020-05-12T11:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkyNTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1OTU5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423559594", "bodyText": "This algorithm is present multiple times, could be factored into a static function", "author": "jpbempel", "createdAt": "2020-05-12T08:35:26Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Chunk.java", "diffHunk": "@@ -0,0 +1,227 @@\n+package com.datadog.profiling.jfr;\n+\n+/** A representation of JFR chunk - self contained set of JFR data. */\n+public final class Chunk {\n+  private static final byte[] MAGIC = new byte[] {'F', 'L', 'R', '\\0'};\n+  private static final short MAJOR_VERSION = 2;\n+  private static final short MINOR_VERSION = 0;\n+\n+  private static final long CHUNK_SIZE_OFFSET = 8;\n+  private static final long CONSTANT_OFFSET_OFFSET = 16;\n+  private static final long METADATA_OFFSET_OFFSET = 24;\n+  private static final long DURATION_NANOS_OFFSET = 40;\n+\n+  private final ByteArrayWriter writer = new ByteArrayWriter(65536);\n+  private final ConstantPools constantPools;\n+  private final Metadata metadata;\n+  private final long startTicks;\n+  private final long startNanos;\n+\n+  Chunk(Metadata metadata, ConstantPools constantPools) {\n+    this.metadata = metadata;\n+    this.constantPools = constantPools;\n+    this.startTicks = System.nanoTime();\n+    this.startNanos = System.currentTimeMillis() * 1_000_000L;\n+    writeHeader();\n+  }\n+\n+  /**\n+   * Write a custom event\n+   *\n+   * @param event the event value\n+   * @return {@literal this} for chaining\n+   * @throws IllegalArgumentException if the event type has not got 'jdk.jfr.Event' as its super\n+   *     type\n+   */\n+  public Chunk writeEvent(TypedValue event) {\n+    if (!\"jdk.jfr.Event\".equals(event.getType().getSupertype())) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    ByteArrayWriter eventWriter = new ByteArrayWriter(32767);\n+    eventWriter.writeLong(event.getType().getId());\n+    for (TypedFieldValue fieldValue : event.getFieldValues()) {\n+      writeTypedValue(eventWriter, fieldValue.getValue());\n+    }\n+\n+    int len = eventWriter.length();\n+    int extraLen = 0;\n+    do {\n+      extraLen = ByteArrayWriter.getPackedIntLen(len + extraLen);\n+    } while (ByteArrayWriter.getPackedIntLen(len + extraLen) != extraLen);", "originalCommit": "62e9580ff90901b27ce18820336cb772d87a6d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2NzMxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423867319", "bodyText": "Done", "author": "jbachorik", "createdAt": "2020-05-12T16:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU1OTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MjU2Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423582566", "bodyText": "Could it be resolve now?", "author": "jpbempel", "createdAt": "2020-05-12T09:10:10Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/Metadata.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+/** JFR type repository class. */\n+final class Metadata {\n+  private static final String CLASS_KEY = \"class\";\n+  private static final String FIELD_KEY = \"field\";\n+  private static final String NAME_KEY = \"name\";\n+  private static final String ID_KEY = \"id\";\n+  private static final String VALUE_KEY = \"value\";\n+  private static final String SUPER_TYPE_KEY = \"superType\";\n+  private static final String CONSTANT_POOL_KEY = \"constantPool\";\n+  private static final String SIMPLE_TYPE_KEY = \"simpleType\";\n+  private static final String ROOT_KEY = \"root\";\n+  private static final String METADATA_KEY = \"metadata\";\n+  private static final String TRUE_VALUE = \"true\";\n+  private static final String REGION_KEY = \"region\";\n+  private static final String DIMENSION_KEY = \"dimension\";\n+  private static final String ANNOTATION_KEY = \"annotation\";\n+  private static final String VAL_1_VALUE = \"1\";\n+\n+  private final AtomicLong typeCounter = new AtomicLong(1);\n+  private final ConstantPools constantPools;\n+  private final Map<String, Type> metadata = new HashMap<>();\n+  private final Map<String, Integer> stringTable = new HashMap<>();\n+  private final Map<Integer, String> reverseStringTable = new TreeMap<>();\n+  private final Set<ResolvableType> unresolvedTypes = new HashSet<>();\n+\n+  Metadata(ConstantPools constantPools) {\n+    this.constantPools = constantPools;\n+    fillStrings();\n+  }\n+\n+  /** Pre-fill the string constant pool with all used constant strings */\n+  private void fillStrings() {\n+    storeString(VAL_1_VALUE);\n+    storeString(CLASS_KEY);\n+    storeString(FIELD_KEY);\n+    storeString(NAME_KEY);\n+    storeString(ID_KEY);\n+    storeString(VALUE_KEY);\n+    storeString(SUPER_TYPE_KEY);\n+    storeString(CONSTANT_POOL_KEY);\n+    storeString(SIMPLE_TYPE_KEY);\n+    storeString(ROOT_KEY);\n+    storeString(METADATA_KEY);\n+    storeString(TRUE_VALUE);\n+    storeString(REGION_KEY);\n+    storeString(DIMENSION_KEY);\n+    storeString(ANNOTATION_KEY);\n+  }\n+\n+  /**\n+   * Register a built-in type\n+   *\n+   * @param typeDef a {@link com.datadog.profiling.jfr.Types.Builtin built-in} type\n+   */\n+  void registerBuiltin(Types.Builtin typeDef) {\n+    Type type = metadata.computeIfAbsent(typeDef.getTypeName(), this::createBuiltinType);\n+    storeTypeStrings(type);\n+  }\n+\n+  /**\n+   * Register a {@linkplain Type} instance\n+   *\n+   * @param typeName the type name\n+   * @param supertype super type; may be {@literal null}\n+   * @param typeStructureProvider type structure provider to be called lazily when a new type is\n+   *     created\n+   * @return registered type - either a new type or or a previously registered with the same name\n+   */\n+  Type registerType(\n+      String typeName, String supertype, Supplier<TypeStructure> typeStructureProvider) {\n+    Type type = metadata.get(typeName);\n+    if (type == null) {\n+      type =\n+          createCustomType(\n+              typeName,\n+              supertype,\n+              typeStructureProvider != null ? typeStructureProvider.get() : TypeStructure.EMPTY);\n+      metadata.put(typeName, type);\n+    }\n+    storeTypeStrings(type);\n+    return type;\n+  }\n+\n+  /**\n+   * Retrieve a type with the given name.\n+   *\n+   * @param name the type name\n+   * @param asResolvable if the type is not found to be registered should a {@link ResolvableType\n+   *     resolvable} wrapper be returned instead?\n+   * @return the type of the given name\n+   */\n+  Type getType(String name, boolean asResolvable) {\n+    Type found = metadata.get(name);\n+    if (found == null) {\n+      if (asResolvable) {\n+        found = new ResolvableType(name, this);\n+      }\n+    }\n+    return found;\n+  }\n+\n+  /**\n+   * Create a new built-in type of the given name. !Package visibility only because of unit testing!\n+   *\n+   * @param name the type name\n+   * @return new built-in type\n+   * @throws IllegalArgumentException if a the type name is not representing a built-in\n+   */\n+  Type createBuiltinType(String name) {\n+    if (!Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    Types.Builtin type = Types.Builtin.ofName(name);\n+    return new BuiltinType(\n+        typeCounter.getAndIncrement(),\n+        type,\n+        type == Types.Builtin.STRING ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Create a new custom type of the given name and structure. !Package visibility only because of\n+   * unit testing!\n+   *\n+   * @param name the type name\n+   * @param supertype the super type name - may be {@literal null}\n+   * @param structure the type structure - fields, annotations\n+   * @return new custom type\n+   * @throws IllegalArgumentException if the name belongs to one of the built-in types\n+   */\n+  Type createCustomType(String name, String supertype, TypeStructure structure) {\n+    if (Types.Builtin.hasType(name)) {\n+      throw new IllegalArgumentException();\n+    }\n+    return new CompositeType(\n+        typeCounter.getAndIncrement(),\n+        name,\n+        supertype,\n+        structure,\n+        // TODO hack for event types not to go to constant pool\n+        !\"jdk.jfr.Event\".equals(supertype) ? constantPools : null,\n+        this);\n+  }\n+\n+  /**\n+   * Retrieve a type from the metadata storage\n+   *\n+   * @param type the (enumerated) type to retrieve from the metadata storage\n+   * @param asResolvable should a {@linkplain ResolvableType} wrapper be returned if the requested\n+   *     type is not present in the metadata storage yet?\n+   * @return the specified {@linkplain Type} instance or {@linkplain null} if that type is not in\n+   *     the metadata storage yet and 'asResolvable' was {@literal false}\n+   */\n+  Type getType(NamedType type, boolean asResolvable) {\n+    return getType(type.getTypeName(), asResolvable);\n+  }\n+\n+  /**\n+   * Add a new unresolved {@linkplain ResolvableType} instance.\n+   *\n+   * @param type unresolved type\n+   */\n+  void addUnresolved(ResolvableType type) {\n+    unresolvedTypes.add(type);\n+  }\n+\n+  /**\n+   * Resolve all dangling unresolved {@link ResolvableType resolvable types}. This needs to be done\n+   * if some of the type definitions are using forward references to not yet registered types.\n+   */\n+  void resolveTypes() {\n+    unresolvedTypes.removeIf(ResolvableType::resolve);\n+  }\n+\n+  private void storeTypeStrings(Type type) {\n+    storeString(type.getTypeName());\n+    if (type.getSupertype() != null) {\n+      storeString(type.getSupertype());\n+    }\n+    storeString(String.valueOf(type.getId()));\n+    for (TypedField field : type.getFields()) {\n+      storeString(field.getName());\n+      storeAnnotationStrings(field.getAnnotations());\n+    }\n+    storeAnnotationStrings(type.getAnnotations());\n+  }\n+\n+  private void storeAnnotationStrings(List<Annotation> annotations) {\n+    for (Annotation annotation : annotations) {\n+      if (annotation.value != null) {\n+        storeString(annotation.value);\n+      }\n+    }\n+  }\n+\n+  private void storeString(String value) {\n+    stringTable.computeIfAbsent(\n+        value,\n+        k -> {\n+          int pointer = stringTable.size();\n+          reverseStringTable.put(pointer, k);\n+          return pointer;\n+        });\n+  }\n+\n+  private int stringIndex(String value) {\n+    // TODO handle NPE", "originalCommit": "62e9580ff90901b27ce18820336cb772d87a6d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3Njg2MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423676861", "bodyText": "Well, may be. I don't think that TODO is even valid any more. Will check.", "author": "jbachorik", "createdAt": "2020-05-12T12:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MjU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2ODA3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423868076", "bodyText": "null argument is an error and should not ever happen.\nAdded @Nonnull annotation and a test to assert that NPE is properly thrown.", "author": "jbachorik", "createdAt": "2020-05-12T16:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU4MjU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjM4Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423662386", "bodyText": "should return Collections.emptyList()\nas all other implementation of BaseType expect to return non-null\nsee BuiltinType", "author": "jpbempel", "createdAt": "2020-05-12T11:32:22Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;", "originalCommit": "62e9580ff90901b27ce18820336cb772d87a6d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY3NzI3NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423677274", "bodyText": "Rather, all the methods should throw an UnsupportedOperationException as this type is only a placeholder and never should escape to be used directly.", "author": "jbachorik", "createdAt": "2020-05-12T12:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjU0OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423662548", "bodyText": "same as above", "author": "jpbempel", "createdAt": "2020-05-12T11:32:40Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/jfr/SelfType.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.datadog.profiling.jfr;\n+\n+import java.util.List;\n+\n+/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ */\n+final class SelfType extends BaseType {\n+  static final SelfType INSTANCE = new SelfType();\n+\n+  private SelfType() {\n+    super(Long.MIN_VALUE, \"\", null, null);\n+  }\n+\n+  @Override\n+  public boolean isBuiltin() {\n+    return false;\n+  }\n+\n+  @Override\n+  public List<TypedField> getFields() {\n+    return null;\n+  }\n+\n+  @Override\n+  public TypedField getField(String name) {\n+    return null;\n+  }\n+\n+  @Override\n+  public List<Annotation> getAnnotations() {\n+    return null;", "originalCommit": "62e9580ff90901b27ce18820336cb772d87a6d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2NzQ3OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1428#discussion_r423867478", "bodyText": "Done", "author": "jbachorik", "createdAt": "2020-05-12T16:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY2MjU0OA=="}], "type": "inlineReview"}, {"oid": "49302a04263364698d021f96123fd67444b625bf", "url": "https://github.com/DataDog/dd-trace-java/commit/49302a04263364698d021f96123fd67444b625bf", "message": "Addressing review comments.", "committedDate": "2020-05-12T16:23:53Z", "type": "commit"}, {"oid": "a22623334a8bab965c434dcf7dda13d741f82aed", "url": "https://github.com/DataDog/dd-trace-java/commit/a22623334a8bab965c434dcf7dda13d741f82aed", "message": "Make format check happy again", "committedDate": "2020-05-12T16:56:02Z", "type": "commit"}]}