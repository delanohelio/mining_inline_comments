{"pr_number": 1327, "pr_title": "Netty 3.8-3.10 instrumentation", "pr_createdAt": "2020-03-20T09:52:59Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1327", "timeline": [{"oid": "44905cb2d620bd7b2d02e16c1ba074b9d1c82606", "url": "https://github.com/DataDog/dd-trace-java/commit/44905cb2d620bd7b2d02e16c1ba074b9d1c82606", "message": "Implement netty 3.9 instrumentation", "committedDate": "2020-03-20T09:32:10Z", "type": "commit"}, {"oid": "7e45aa731f9409bd51d0d1be8a57d515a1b7bef6", "url": "https://github.com/DataDog/dd-trace-java/commit/7e45aa731f9409bd51d0d1be8a57d515a1b7bef6", "message": "Add module", "committedDate": "2020-03-20T09:36:52Z", "type": "commit"}, {"oid": "baf02ff526e6c88bee3317bd83896c6afd680560", "url": "https://github.com/DataDog/dd-trace-java/commit/baf02ff526e6c88bee3317bd83896c6afd680560", "message": "Remove unneccesary checks", "committedDate": "2020-03-20T09:41:35Z", "type": "commit"}, {"oid": "2d84dd7eecf6bc0a006e7783838d59d18066527c", "url": "https://github.com/DataDog/dd-trace-java/commit/2d84dd7eecf6bc0a006e7783838d59d18066527c", "message": "Add a comment for a special case to this netty version", "committedDate": "2020-03-20T09:45:09Z", "type": "commit"}, {"oid": "8e4f9c4dc6943ff69f13d27b88c0da37bfa7dcba", "url": "https://github.com/DataDog/dd-trace-java/commit/8e4f9c4dc6943ff69f13d27b88c0da37bfa7dcba", "message": "refine gradle config", "committedDate": "2020-03-20T09:52:16Z", "type": "commit"}, {"oid": "eb99b410c57cd95140b330588115eb3cd556f606", "url": "https://github.com/DataDog/dd-trace-java/commit/eb99b410c57cd95140b330588115eb3cd556f606", "message": "gross hack for muzzle", "committedDate": "2020-03-20T10:25:26Z", "type": "commit"}, {"oid": "9297ff39f47b797a9990b169692234144e66bfb6", "url": "https://github.com/DataDog/dd-trace-java/commit/9297ff39f47b797a9990b169692234144e66bfb6", "message": "Less ambiguous name, also doesn't collide with netty class", "committedDate": "2020-03-20T12:00:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjM5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395762398", "bodyText": "Why don't we want it to work with those versions?", "author": "tylerbenson", "createdAt": "2020-03-20T16:44:56Z", "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty39;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        \"org.jboss.netty.buffer.EmptyChannelBuffer\", // Not in 3.8\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10", "originalCommit": "9297ff39f47b797a9990b169692234144e66bfb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5ODc3Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395798776", "bodyText": "I hadn't run it against 3.8 but from the diff it looked like it wouldn't work, turns out the tests pass against 3.8 so I'll rename to 3.8 and adjust the muzzle checks\nFor 2.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader", "author": "devinsba", "createdAt": "2020-03-20T17:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5Mjc5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396492794", "bodyText": "Turns out 3.10 failure was caused by the version of the client used in the tests. Updated and it works. Updated the description", "author": "devinsba", "createdAt": "2020-03-23T14:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2MjM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2OTQwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395769407", "bodyText": "I don't think we need the if here... only on clients actually used by AWS-SDK", "author": "tylerbenson", "createdAt": "2020-03-20T16:56:48Z", "path": "dd-java-agent/instrumentation/netty-3.9/src/main/java/datadog/trace/instrumentation/netty39/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package datadog.trace.instrumentation.netty39.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty39.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty39.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty39.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      // AWS calls are often signed, so we can't add headers without breaking the signature.\n+      if (!request.headers().contains(\"amz-sdk-invocation-id\")) {\n+        propagate().inject(span, request.headers(), SETTER);\n+      }", "originalCommit": "9297ff39f47b797a9990b169692234144e66bfb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5ODkzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395798937", "bodyText": "\ud83d\udc4d", "author": "devinsba", "createdAt": "2020-03-20T17:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc2OTQwNw=="}], "type": "inlineReview"}, {"oid": "4ae71c8087c84c257690a7631b3ee157098c450b", "url": "https://github.com/DataDog/dd-trace-java/commit/4ae71c8087c84c257690a7631b3ee157098c450b", "message": "Works with 3.8 also, still need to fix muzzle again", "committedDate": "2020-03-20T18:12:39Z", "type": "commit"}, {"oid": "c8fc300df0e0bdd1e21978e548e2fcb48e433055", "url": "https://github.com/DataDog/dd-trace-java/commit/c8fc300df0e0bdd1e21978e548e2fcb48e433055", "message": "Not used by aws sdk", "committedDate": "2020-03-20T18:14:41Z", "type": "commit"}, {"oid": "59dffa3d5d6e3f19bde08a1cf5a46d79059c9dbd", "url": "https://github.com/DataDog/dd-trace-java/commit/59dffa3d5d6e3f19bde08a1cf5a46d79059c9dbd", "message": "Minimal change to make muzzle pass", "committedDate": "2020-03-20T18:27:47Z", "type": "commit"}, {"oid": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "url": "https://github.com/DataDog/dd-trace-java/commit/b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "message": "Clarify muzzle specific checks", "committedDate": "2020-03-20T18:57:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395875587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.ChannelFutureListener\",\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.ChannelFutureListener\");\n          \n      \n    \n    \n  \n\nYou shouldn't need the manual 3.10 restrictions, muzzle should cover that.", "author": "tylerbenson", "createdAt": "2020-03-20T20:30:47Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "originalCommit": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTI4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395885281", "bodyText": "If you need a way to ensure the instrumentation all applies consistently, I suggest doing something like this instead:\nhttps://github.com/DataDog/dd-trace-java/blob/master/dd-java-agent/instrumentation/rabbitmq-amqp-2.7/src/main/java/datadog/trace/instrumentation/rabbitmq/amqp/RabbitCommandInstrumentation.java#L70-L77", "author": "tylerbenson", "createdAt": "2020-03-20T20:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTI4OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395889289", "bodyText": "It doesn't, I think because the accesses that would eliminate 3.10 happen outside of the advice class: https://circleci.com/gh/DataDog/dd-trace-java/49282?utm_campaign=vcs-integration-link&utm_medium=referral&utm_source=github-build-link", "author": "devinsba", "createdAt": "2020-03-20T21:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTY4Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395889686", "bodyText": "Will check that link \ud83d\udc4d", "author": "devinsba", "createdAt": "2020-03-20T21:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395876458", "bodyText": "Static import...", "author": "tylerbenson", "createdAt": "2020-03-20T20:32:50Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelFutureListener\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class OperationCompleteAdvice {\n+    @Advice.OnMethodEnter\n+    public static TraceScope activateScope(@Advice.Argument(0) final ChannelFuture future) {\n+      /*\n+      Idea here is:\n+       - To return scope only if we have captured it.\n+       - To capture scope only in case of error.\n+       */\n+      final Throwable cause = future.getCause();\n+      if (cause == null) {\n+        return null;\n+      }\n+\n+      final ContextStore<Channel, ChannelTraceContext> contextStore =\n+          InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+      final TraceScope.Continuation continuation =\n+          contextStore\n+              .putIfAbsent(future.getChannel(), ChannelTraceContext.Factory.INSTANCE)\n+              .getConnectionContinuationAndRemove();\n+      if (continuation == null) {\n+        return null;\n+      }\n+      final TraceScope parentScope = continuation.activate();\n+\n+      final AgentSpan errorSpan = startSpan(\"netty.connect\").setTag(Tags.COMPONENT, \"netty\");\n+      try (final AgentScope scope = activateSpan(errorSpan, false)) {\n+        NettyHttpServerDecorator.DECORATE.onError(errorSpan, cause);\n+        NettyHttpServerDecorator.DECORATE.beforeFinish(errorSpan);", "originalCommit": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTk1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395889952", "bodyText": "Got lost in the rename I think", "author": "devinsba", "createdAt": "2020-03-20T21:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3Mjg3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396672875", "bodyText": "I'm honestly not huge fan of our heavy use of static imports, but I'm not pushing for a change either way.", "author": "dougqh", "createdAt": "2020-03-23T18:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NTE4OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396675189", "bodyText": "FWIW, in this particular case I think using NettyHttpServerDecorator.DECORATE makes some sense b/c it's not clear whether DECORATE here would refer to the client decorator or the server decorator.", "author": "trask", "createdAt": "2020-03-23T18:40:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg3NjQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NTk4MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395885980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.Channel\",\n          \n          \n            \n                    // 3.7: cannot find symbol method headers() for type HttpRequest\n          \n          \n            \n                    \"org.jboss.netty.handler.codec.http.DefaultHttpHeaders\", // Not in 3.7\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.Channel\");\n          \n      \n    \n    \n  \n\nSame as above.", "author": "tylerbenson", "createdAt": "2020-03-20T20:56:23Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelInstrumentation extends Instrumenter.Default {\n+  public NettyChannelInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.Channel\",\n+        // 3.7: cannot find symbol method headers() for type HttpRequest\n+        \"org.jboss.netty.handler.codec.http.DefaultHttpHeaders\", // Not in 3.7\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "originalCommit": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4NzI4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r395887281", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hasClassesNamed(\n          \n          \n            \n                    \"org.jboss.netty.channel.ChannelPipeline\",\n          \n          \n            \n                    // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n          \n          \n            \n                    \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n          \n          \n            \n                    );\n          \n          \n            \n                return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");", "author": "tylerbenson", "createdAt": "2020-03-20T20:59:37Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\n+        \"org.jboss.netty.channel.ChannelPipeline\",\n+        // 3.10: NoSuchMethodError: org.jboss.netty.handler.codec.http.HttpRequest.setHeader\n+        \"org.jboss.netty.channel.StaticChannelPipeline\" // Not in 3.10\n+        );", "originalCommit": "b4be2b18e4aaef5ff65bf386359d69d51d8a56fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "17f73b6896714f46b754103880e55dde4b16ff28", "url": "https://github.com/DataDog/dd-trace-java/commit/17f73b6896714f46b754103880e55dde4b16ff28", "message": "Fix small things from review", "committedDate": "2020-03-23T14:01:58Z", "type": "commit"}, {"oid": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "url": "https://github.com/DataDog/dd-trace-java/commit/5ac54ce10d36f5d6ec60e27793802c7899a69365", "message": "Update to support 3.10 also and make muzzle check less brittle", "committedDate": "2020-03-23T14:30:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjQ3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396646479", "bodyText": "Not necessarily for this PR, but now, that having a classLoaderMatcher check is the norm to combat matching costs.  I think we should make the concept of key class for a library a required part of almost every instrumentation.\nI also think we should revisit the idea of a Library as a first class concept as well.  While at first, I think this seems like more work.  I think right now we end up duplicating some classLoaderMatcher code because we lack the concept of a library.", "author": "dougqh", "createdAt": "2020-03-23T17:57:09Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzkyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396647925", "bodyText": "ChannelTraceContext.class will trigger a class load in the agent ClassLoader.\nHowever, I'm assuming we should only need ChannelTraceContext in the target ClassLoader.\nThis comes up enough that I'm wondering if we should make doing this the right way easier somehow.", "author": "dougqh", "createdAt": "2020-03-23T17:59:08Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelFutureListenerInstrumentation.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.server.NettyHttpServerDecorator.DECORATE;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.bootstrap.instrumentation.api.Tags;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelFuture;\n+\n+@AutoService(Instrumenter.class)\n+public class ChannelFutureListenerInstrumentation extends Instrumenter.Default {\n+\n+  public ChannelFutureListenerInstrumentation() {\n+    super(\n+        NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME,\n+        NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelFutureListener\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelFutureListener\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(named(\"operationComplete\"))\n+            .and(takesArgument(0, named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        ChannelFutureListenerInstrumentation.class.getName() + \"$OperationCompleteAdvice\");\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0OTM3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396649373", "bodyText": "Whoops. Updating.\nI agree on the doing the right thing part. I think a lot of the code in these classes could be generated at compile time, maybe using compile retention annotations", "author": "devinsba", "createdAt": "2020-03-23T18:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzkyNQ=="}], "type": "inlineReview"}, {"oid": "d4a4c5619c7bc303c73d701b023638b7a51a3913", "url": "https://github.com/DataDog/dd-trace-java/commit/d4a4c5619c7bc303c73d701b023638b7a51a3913", "message": "Less class loads", "committedDate": "2020-03-23T18:03:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1MzUwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396653500", "bodyText": "I'm guessing this is idiomatic to our code base.  However, compareAndSet to me evokes a specific atomicity guarantee that this does seem to provide.\nI'm not necessarily suggesting a change -- just that this is confusing to a casual reader.", "author": "dougqh", "createdAt": "2020-03-23T18:07:41Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/ChannelTraceContext.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import lombok.Data;\n+\n+@Data\n+public class ChannelTraceContext {\n+  public static class Factory implements ContextStore.Factory<ChannelTraceContext> {\n+    public static final Factory INSTANCE = new Factory();\n+\n+    @Override\n+    public ChannelTraceContext create() {\n+      return new ChannelTraceContext();\n+    }\n+  }\n+\n+  TraceScope.Continuation connectionContinuation;\n+  AgentSpan serverSpan;\n+  AgentSpan clientSpan;\n+  AgentSpan clientParentSpan;\n+\n+  public boolean compareAndSet(", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MTQ2Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396671466", "bodyText": "I'll just change the call sites. I don't expect these objects to be used on multiple threads", "author": "devinsba", "createdAt": "2020-03-23T18:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1MzUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDc0OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396654748", "bodyText": "Shouldn't closing be in a finally block?", "author": "dougqh", "createdAt": "2020-03-23T18:09:37Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeScope;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.ADDITIONAL_INSTRUMENTATION_NAMES;\n+import static datadog.trace.instrumentation.netty38.NettyChannelPipelineInstrumentation.INSTRUMENTATION_NAME;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.returns;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.context.TraceScope;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelInstrumentation extends Instrumenter.Default {\n+  public NettyChannelInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.Channel\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.Channel\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(named(\"connect\"))\n+            .and(returns(named(\"org.jboss.netty.channel.ChannelFuture\"))),\n+        NettyChannelInstrumentation.class.getName() + \"$ChannelConnectAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  public static class ChannelConnectAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static void addConnectContinuation(@Advice.This final Channel channel) {\n+      final TraceScope scope = activeScope();\n+      if (scope != null) {\n+        final TraceScope.Continuation continuation = scope.capture();\n+        if (continuation != null) {\n+          final ContextStore<Channel, ChannelTraceContext> contextStore =\n+              InstrumentationContext.get(Channel.class, ChannelTraceContext.class);\n+\n+          if (!contextStore\n+              .putIfAbsent(channel, ChannelTraceContext.Factory.INSTANCE)\n+              .compareAndSet(null, continuation)) {\n+            continuation.close();", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODY4OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658689", "bodyText": "This close is only on failure, so when the continuation is not null in the above check. So we close this one as a duplicate", "author": "devinsba", "createdAt": "2020-03-23T18:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NjE5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396656195", "bodyText": "Should we log here?", "author": "dougqh", "createdAt": "2020-03-23T18:12:02Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MTIyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396661229", "bodyText": "Oh, this shouldn't be needed anymore. I'm handling this by doing the remove. Removing", "author": "devinsba", "createdAt": "2020-03-23T18:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NjE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Njc2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396656763", "bodyText": "Why not just pipeline.remove(handler.getClass().getName())?\nDoes remove fail if it is missing?", "author": "dougqh", "createdAt": "2020-03-23T18:13:02Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/NettyChannelPipelineInstrumentation.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package datadog.trace.instrumentation.netty38;\n+\n+import static datadog.trace.agent.tooling.ClassLoaderMatcher.hasClassesNamed;\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.DDElementMatchers.implementsInterface;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import datadog.trace.bootstrap.CallDepthThreadLocalMap;\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.InstrumentationContext;\n+import datadog.trace.instrumentation.netty38.client.HttpClientRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.client.HttpClientTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerRequestTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerResponseTracingHandler;\n+import datadog.trace.instrumentation.netty38.server.HttpServerTracingHandler;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandler;\n+import org.jboss.netty.channel.ChannelPipeline;\n+import org.jboss.netty.handler.codec.http.HttpClientCodec;\n+import org.jboss.netty.handler.codec.http.HttpRequestDecoder;\n+import org.jboss.netty.handler.codec.http.HttpRequestEncoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseDecoder;\n+import org.jboss.netty.handler.codec.http.HttpResponseEncoder;\n+import org.jboss.netty.handler.codec.http.HttpServerCodec;\n+\n+@AutoService(Instrumenter.class)\n+public class NettyChannelPipelineInstrumentation extends Instrumenter.Default {\n+\n+  static final String INSTRUMENTATION_NAME = \"netty\";\n+  static final String[] ADDITIONAL_INSTRUMENTATION_NAMES = {\"netty-3.9\"};\n+\n+  public NettyChannelPipelineInstrumentation() {\n+    super(INSTRUMENTATION_NAME, ADDITIONAL_INSTRUMENTATION_NAMES);\n+  }\n+\n+  @Override\n+  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+    // Optimization for expensive typeMatcher.\n+    return hasClassesNamed(\"org.jboss.netty.channel.ChannelPipeline\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<TypeDescription> typeMatcher() {\n+    return implementsInterface(named(\"org.jboss.netty.channel.ChannelPipeline\"));\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {\n+      packageName + \".AbstractNettyAdvice\",\n+      packageName + \".ChannelTraceContext\",\n+      packageName + \".ChannelTraceContext$Factory\",\n+      NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdviceUtil\",\n+      // Util\n+      packageName + \".util.CombinedSimpleChannelHandler\",\n+      // client helpers\n+      packageName + \".client.NettyHttpClientDecorator\",\n+      packageName + \".client.NettyResponseInjectAdapter\",\n+      packageName + \".client.HttpClientRequestTracingHandler\",\n+      packageName + \".client.HttpClientResponseTracingHandler\",\n+      packageName + \".client.HttpClientTracingHandler\",\n+      // server helpers\n+      packageName + \".server.NettyHttpServerDecorator\",\n+      packageName + \".server.NettyRequestExtractAdapter\",\n+      packageName + \".server.HttpServerRequestTracingHandler\",\n+      packageName + \".server.HttpServerResponseTracingHandler\",\n+      packageName + \".server.HttpServerTracingHandler\"\n+    };\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    final Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(1, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd2ArgsAdvice\");\n+    transformers.put(\n+        isMethod()\n+            .and(nameStartsWith(\"add\"))\n+            .and(takesArgument(2, named(\"org.jboss.netty.channel.ChannelHandler\"))),\n+        NettyChannelPipelineInstrumentation.class.getName() + \"$ChannelPipelineAdd3ArgsAdvice\");\n+    return transformers;\n+  }\n+\n+  @Override\n+  public Map<String, String> contextStore() {\n+    return Collections.singletonMap(\n+        \"org.jboss.netty.channel.Channel\", ChannelTraceContext.class.getName());\n+  }\n+\n+  /**\n+   * When certain handlers are added to the pipeline, we want to add our corresponding tracing\n+   * handlers. If those handlers are later removed, we may want to remove our handlers. That is not\n+   * currently implemented.\n+   */\n+  public static class ChannelPipelineAdviceUtil {\n+    public static void wrapHandler(\n+        final ContextStore<Channel, ChannelTraceContext> contextStore,\n+        final ChannelPipeline pipeline,\n+        final ChannelHandler handler) {\n+      try {\n+        // Server pipeline handlers\n+        if (handler instanceof HttpServerCodec) {\n+          pipeline.addLast(\n+              HttpServerTracingHandler.class.getName(), new HttpServerTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestDecoder) {\n+          pipeline.addLast(\n+              HttpServerRequestTracingHandler.class.getName(),\n+              new HttpServerRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseEncoder) {\n+          pipeline.addLast(\n+              HttpServerResponseTracingHandler.class.getName(),\n+              new HttpServerResponseTracingHandler(contextStore));\n+        } else\n+        // Client pipeline handlers\n+        if (handler instanceof HttpClientCodec) {\n+          pipeline.addLast(\n+              HttpClientTracingHandler.class.getName(), new HttpClientTracingHandler(contextStore));\n+        } else if (handler instanceof HttpRequestEncoder) {\n+          pipeline.addLast(\n+              HttpClientRequestTracingHandler.class.getName(),\n+              new HttpClientRequestTracingHandler(contextStore));\n+        } else if (handler instanceof HttpResponseDecoder) {\n+          pipeline.addLast(\n+              HttpClientResponseTracingHandler.class.getName(),\n+              new HttpClientResponseTracingHandler(contextStore));\n+        }\n+      } catch (final IllegalArgumentException e) {\n+        // Prevented adding duplicate handlers.\n+      } finally {\n+        CallDepthThreadLocalMap.reset(ChannelPipeline.class);\n+      }\n+    }\n+  }\n+\n+  public static class ChannelPipelineAdd2ArgsAdvice extends AbstractNettyAdvice {\n+    @Advice.OnMethodEnter\n+    public static int checkDepth(\n+        @Advice.This final ChannelPipeline pipeline,\n+        @Advice.Argument(1) final ChannelHandler handler) {\n+      // Pipelines are created once as a factory and then copied multiple times using the same add\n+      // methods as we are hooking. If our handler has already been added we need to remove it so we\n+      // don't end up with duplicates (this throws an exception)\n+      if (pipeline.get(handler.getClass().getName()) != null) {", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODIyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658220", "bodyText": "Yeah it throws: throw new NoSuchElementException(name);", "author": "devinsba", "createdAt": "2020-03-23T18:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Njc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3MzgxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396673815", "bodyText": "Okay, then I guess the test & remove makes sense.", "author": "dougqh", "createdAt": "2020-03-23T18:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Njc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Nzc4NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396657784", "bodyText": "finally block?", "author": "dougqh", "createdAt": "2020-03-23T18:14:48Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();\n+        throw throwable;\n+      }\n+    }\n+\n+    if (null != parentScope) {", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MzkxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396663910", "bodyText": "Probably should be, yeah. Should probably fix this in 4.0 also", "author": "devinsba", "createdAt": "2020-03-23T18:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Nzc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NDgzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396674837", "bodyText": "Forward porting to 4.0 and 4.1 also", "author": "devinsba", "createdAt": "2020-03-23T18:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1Nzc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODA0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658040", "bodyText": "Do we not finish the span if there isn't an Exception?", "author": "dougqh", "createdAt": "2020-03-23T18:15:11Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientRequestTracingHandler.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activeSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.propagate;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.startSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+import static datadog.trace.instrumentation.netty38.client.NettyResponseInjectAdapter.SETTER;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.context.TraceScope;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import java.net.InetSocketAddress;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelDownstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+\n+@Slf4j\n+public class HttpClientRequestTracingHandler extends SimpleChannelDownstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientRequestTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void writeRequested(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    if (!(msg.getMessage() instanceof HttpRequest)) {\n+      ctx.sendDownstream(msg);\n+      return;\n+    }\n+\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    TraceScope parentScope = null;\n+    final TraceScope.Continuation continuation = channelTraceContext.getConnectionContinuation();\n+    if (continuation != null) {\n+      parentScope = continuation.activate();\n+      channelTraceContext.setConnectionContinuation(null);\n+    }\n+\n+    final HttpRequest request = (HttpRequest) msg.getMessage();\n+\n+    channelTraceContext.setClientParentSpan(activeSpan());\n+\n+    final AgentSpan span = startSpan(\"netty.client.request\");\n+    try (final AgentScope scope = activateSpan(span, false)) {\n+      DECORATE.afterStart(span);\n+      DECORATE.onRequest(span, request);\n+      DECORATE.onPeerConnection(span, (InetSocketAddress) ctx.getChannel().getRemoteAddress());\n+\n+      propagate().inject(span, request.headers(), SETTER);\n+\n+      channelTraceContext.setClientSpan(span);\n+\n+      try {\n+        ctx.sendDownstream(msg);\n+      } catch (final Throwable throwable) {\n+        DECORATE.onError(span, throwable);\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDA0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396660040", "bodyText": "It's closed in the response handler if there isn't an error sending downstream", "author": "devinsba", "createdAt": "2020-03-23T18:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY3NDI1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396674252", "bodyText": "Ah, that makes sense.", "author": "dougqh", "createdAt": "2020-03-23T18:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODMyMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396658323", "bodyText": "finally?", "author": "dougqh", "createdAt": "2020-03-23T18:15:36Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/HttpClientResponseTracingHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.activateSpan;\n+import static datadog.trace.bootstrap.instrumentation.api.AgentTracer.noopSpan;\n+import static datadog.trace.instrumentation.netty38.client.NettyHttpClientDecorator.DECORATE;\n+\n+import datadog.trace.bootstrap.ContextStore;\n+import datadog.trace.bootstrap.instrumentation.api.AgentScope;\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan;\n+import datadog.trace.instrumentation.netty38.ChannelTraceContext;\n+import org.jboss.netty.channel.Channel;\n+import org.jboss.netty.channel.ChannelHandlerContext;\n+import org.jboss.netty.channel.MessageEvent;\n+import org.jboss.netty.channel.SimpleChannelUpstreamHandler;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+public class HttpClientResponseTracingHandler extends SimpleChannelUpstreamHandler {\n+\n+  private final ContextStore<Channel, ChannelTraceContext> contextStore;\n+\n+  public HttpClientResponseTracingHandler(\n+      final ContextStore<Channel, ChannelTraceContext> contextStore) {\n+    this.contextStore = contextStore;\n+  }\n+\n+  @Override\n+  public void messageReceived(final ChannelHandlerContext ctx, final MessageEvent msg)\n+      throws Exception {\n+    final ChannelTraceContext channelTraceContext =\n+        contextStore.putIfAbsent(ctx.getChannel(), ChannelTraceContext.Factory.INSTANCE);\n+\n+    AgentSpan parent = channelTraceContext.getClientParentSpan();\n+    if (parent == null) {\n+      parent = noopSpan();\n+      channelTraceContext.setClientParentSpan(noopSpan());\n+    }\n+    final AgentSpan span = channelTraceContext.getClientSpan();\n+\n+    final boolean finishSpan = msg.getMessage() instanceof HttpResponse;\n+\n+    if (span != null && finishSpan) {\n+      try (final AgentScope scope = activateSpan(span, false)) {\n+        DECORATE.onResponse(span, (HttpResponse) msg.getMessage());\n+        DECORATE.beforeFinish(span);\n+        span.finish();", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4MDI2OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396680268", "bodyText": "I think the span needs to be finished while it's in scope. Not 100% sure on that with our impl but it's a common pattern I've seen", "author": "devinsba", "createdAt": "2020-03-23T18:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4Nzc0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396687742", "bodyText": "This code is the same in the other 2 versions of the netty instrumentation", "author": "devinsba", "createdAt": "2020-03-23T19:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1ODMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1OTIxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396659214", "bodyText": "Probably not for this PR, but we probably shouldn't build URI just to extract pieces to tags later.\nThat creates a hot allocation point under load.", "author": "dougqh", "createdAt": "2020-03-23T18:17:01Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.HOST;\n+\n+import datadog.trace.bootstrap.instrumentation.decorator.HttpClientDecorator;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+@Slf4j\n+public class NettyHttpClientDecorator extends HttpClientDecorator<HttpRequest, HttpResponse> {\n+  public static final NettyHttpClientDecorator DECORATE = new NettyHttpClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"netty\", \"netty-3.9\"};\n+  }\n+\n+  @Override\n+  protected String component() {\n+    return \"netty-client\";\n+  }\n+\n+  @Override\n+  protected String method(final HttpRequest httpRequest) {\n+    return httpRequest.getMethod().getName();\n+  }\n+\n+  @Override\n+  protected URI url(final HttpRequest request) throws URISyntaxException {\n+    final URI uri = new URI(request.getUri());", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MzM2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1327#discussion_r396663363", "bodyText": "Again, probably not this PR.\nBut why does this return Integer rather than int?\nAlso, we might want to create our Integer cache for HttpStatus codes, since most of them lie outside the default cache range.", "author": "dougqh", "createdAt": "2020-03-23T18:22:09Z", "path": "dd-java-agent/instrumentation/netty-3.8/src/main/java/datadog/trace/instrumentation/netty38/client/NettyHttpClientDecorator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package datadog.trace.instrumentation.netty38.client;\n+\n+import static org.jboss.netty.handler.codec.http.HttpHeaders.Names.HOST;\n+\n+import datadog.trace.bootstrap.instrumentation.decorator.HttpClientDecorator;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import lombok.extern.slf4j.Slf4j;\n+import org.jboss.netty.handler.codec.http.HttpRequest;\n+import org.jboss.netty.handler.codec.http.HttpResponse;\n+\n+@Slf4j\n+public class NettyHttpClientDecorator extends HttpClientDecorator<HttpRequest, HttpResponse> {\n+  public static final NettyHttpClientDecorator DECORATE = new NettyHttpClientDecorator();\n+\n+  @Override\n+  protected String[] instrumentationNames() {\n+    return new String[] {\"netty\", \"netty-3.9\"};\n+  }\n+\n+  @Override\n+  protected String component() {\n+    return \"netty-client\";\n+  }\n+\n+  @Override\n+  protected String method(final HttpRequest httpRequest) {\n+    return httpRequest.getMethod().getName();\n+  }\n+\n+  @Override\n+  protected URI url(final HttpRequest request) throws URISyntaxException {\n+    final URI uri = new URI(request.getUri());\n+    if ((uri.getHost() == null || uri.getHost().equals(\"\")) && request.headers().contains(HOST)) {\n+      return new URI(\"http://\" + request.headers().get(HOST) + request.getUri());\n+    } else {\n+      return uri;\n+    }\n+  }\n+\n+  @Override\n+  protected Integer status(final HttpResponse httpResponse) {", "originalCommit": "5ac54ce10d36f5d6ec60e27793802c7899a69365", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5aa1800bec90358ec10be6b3869dd549409c8dac", "url": "https://github.com/DataDog/dd-trace-java/commit/5aa1800bec90358ec10be6b3869dd549409c8dac", "message": "Get rid of half baked map methods. Close parentScope in a finally block (+forward port)", "committedDate": "2020-03-23T18:44:11Z", "type": "commit"}]}