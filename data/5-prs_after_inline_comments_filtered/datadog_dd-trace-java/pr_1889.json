{"pr_number": 1889, "pr_title": "ScopeListener and ScopeManager fixes", "pr_createdAt": "2020-09-18T22:18:58Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1889", "timeline": [{"oid": "0e23187d66b7c814bc1440214d1448bfd4d227c7", "url": "https://github.com/DataDog/dd-trace-java/commit/0e23187d66b7c814bc1440214d1448bfd4d227c7", "message": "Some failing tests", "committedDate": "2020-09-18T20:34:48Z", "type": "commit"}, {"oid": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4", "url": "https://github.com/DataDog/dd-trace-java/commit/89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4", "message": "Fix issues with ContinuableScopeManager", "committedDate": "2020-09-18T22:12:07Z", "type": "commit"}, {"oid": "9d8ea2d0e183464b34aca0b777007f86751c96a2", "url": "https://github.com/DataDog/dd-trace-java/commit/9d8ea2d0e183464b34aca0b777007f86751c96a2", "message": "This check is no longer necessary and probably causes problems", "committedDate": "2020-09-18T22:12:56Z", "type": "commit"}, {"oid": "6876b8a0a7a09bd54344694bb4590576ac5cae62", "url": "https://github.com/DataDog/dd-trace-java/commit/6876b8a0a7a09bd54344694bb4590576ac5cae62", "message": "Fix tests in OT project", "committedDate": "2020-09-18T22:50:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491226548", "bodyText": "Can you clarify the difference between topPos starting at 0, with element 0 maintained to be always null, and topPos starting at -1 and returning null whenever topPos is -1?", "author": "richardstartin", "createdAt": "2020-09-18T22:52:48Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,109 +261,78 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top a non-empty stack is always active Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n-    int topPos = 0;\n+    private static final int MIN_STACK_LENGTH = 16;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // -1 if empty\n+    int topPos = -1;", "originalCommit": "89fe80f77e3d0cefe50ed00f5f7baa1bfb5d7ba4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNzE2NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491227164", "bodyText": "I didn't follow the point about topPos being used for two different purposes, leading to off-by-one errors. What else is topPos used for other than accessing the top of the stack?", "author": "richardstartin", "createdAt": "2020-09-18T22:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMDAxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491230010", "bodyText": "So, I reverted all the changes to topPos (0 based rather than -1 based) and the new tests all pass. I don't think this change is necessary.\nb18e63f", "author": "richardstartin", "createdAt": "2020-09-18T23:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNTk3Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r491235977", "bodyText": "Oh.  I completely missed that.  I saw sometimes topPos pointed to the active scope and sometimes didn't.  I agree with having it zero based", "author": "randomanderson", "createdAt": "2020-09-18T23:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIyNjU0OA=="}], "type": "inlineReview"}, {"oid": "b18e63f1110930218df2b97a0f60a274c2b5dbab", "url": "https://github.com/DataDog/dd-trace-java/commit/b18e63f1110930218df2b97a0f60a274c2b5dbab", "message": "anchor toppos at 0", "committedDate": "2020-09-18T23:17:10Z", "type": "commit"}, {"oid": "6076473dc811133379059311510fc474395b3f1e", "url": "https://github.com/DataDog/dd-trace-java/commit/6076473dc811133379059311510fc474395b3f1e", "message": "Fix some comments", "committedDate": "2020-09-18T23:41:41Z", "type": "commit"}, {"oid": "b6985538d4d8f485557af5c2a2374128487db093", "url": "https://github.com/DataDog/dd-trace-java/commit/b6985538d4d8f485557af5c2a2374128487db093", "message": "Fix out of order + multiple activations", "committedDate": "2020-09-19T00:01:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1OTc5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492159794", "bodyText": "If the first one fails, the second one is going to get run. Perhaps these should have their own try blocks?", "author": "arkban", "createdAt": "2020-09-21T15:38:57Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/log/LogContextScopeListener.java", "diffHunk": "@@ -45,10 +43,6 @@ public void afterScopeActivated() {\n \n   @Override\n   public void afterScopeClosed() {\n-    if (activeSpan() != null) {\n-      afterScopeActivated();\n-      return;\n-    }\n     try {\n       removeMethod.invoke(null, CorrelationIdentifier.getTraceIdKey());\n       removeMethod.invoke(null, CorrelationIdentifier.getSpanIdKey());", "originalCommit": "b6985538d4d8f485557af5c2a2374128487db093", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgxNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492160816", "bodyText": "Why remove the \"Ignoring!\" phrase? That was a useful canary to check if things went sideways.", "author": "arkban", "createdAt": "2020-09-21T15:40:28Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -148,24 +148,15 @@ protected ScopeStack scopeStack() {\n \n     @Override\n     public void close() {\n-      ScopeStack scopeStack = scopeManager.scopeStack();\n-\n-      // DQH - Aug 2020 - Preserving our broken reference counting semantics for the\n-      // first round of out-of-order handling.\n-      // When reference counts are being used, we don't check the stack top --\n-      // so potentially we undercount errors\n-      // Also we don't report closed until the reference count == 0 which seems\n-      // incorrect given the OpenTracing semantics\n-      // Both these issues should be corrected at a later date\n+      final ScopeStack scopeStack = scopeManager.scopeStack();\n \n-      boolean alive = decrementReferences();\n-      if (alive) return;\n+      final boolean alive = decrementReferences();\n \n-      boolean onTop = scopeStack.checkTop(this);\n+      final boolean onTop = scopeStack.checkTop(this);\n       if (!onTop) {\n         if (log.isDebugEnabled()) {\n-          // Using noFixupTop because I don't want to have code with side effects in logging code\n-          log.debug(\"Tried to close {} scope when not on top. Ignoring!\", scopeStack.noFixupTop());\n+          log.debug(\n+              \"Tried to close {} scope when not on top.  Current top: {}\", this, scopeStack.top());", "originalCommit": "b6985538d4d8f485557af5c2a2374128487db093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MTQzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492251435", "bodyText": "Depending on perspective this isn't ignored anymore.  The close isn't dropped the way that it used to be.", "author": "dougqh", "createdAt": "2020-09-21T18:07:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjcwNzA3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492707073", "bodyText": "While true, I'm asking from the perspective of a black box user like myself. It was one of the \"canary\" phrases we used to tell when things went sideways.", "author": "arkban", "createdAt": "2020-09-22T12:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MTQzNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492161434", "bodyText": "Is it possible for cancelFromContinuedScopeClose() to throw and prevent this from being reached?", "author": "arkban", "createdAt": "2020-09-21T15:41:23Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -177,19 +168,17 @@ public void close() {\n             throw new RuntimeException(\"Tried to close scope when not on top\");\n           }\n         }\n+      }\n \n+      if (alive) {\n         return;\n       }\n \n       if (null != continuation) {\n-        span.context().getTrace().cancelContinuation(continuation);\n+        continuation.cancelFromContinuedScopeClose();\n       }\n-      scopeStack.blindPop();\n \n-      // DQH - As covered above, I feel our close notification semantics are incorrect with\n-      // especially where reference counting is concerned.  Unfortunately, sorting out the\n-      // semantics will also require sorting out the tests which have codified the ill-behavior.\n-      onProperClose();\n+      scopeStack.cleanup();", "originalCommit": "b6985538d4d8f485557af5c2a2374128487db093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4MzExMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492383111", "bodyText": "Yes.  If a user throws an exception in a TraceInterceptor.  I changed the ordering in #1894 to prevent this", "author": "randomanderson", "createdAt": "2020-09-21T22:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MTQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NTUwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492165506", "bodyText": "Does this mean that topPos is 1-indexed? I'm asking because it says here 0 if empty, yet all the calls like stack[topPos] seem to use topPos as if it was 0-indexed.", "author": "arkban", "createdAt": "2020-09-21T15:47:14Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty", "originalCommit": "b6985538d4d8f485557af5c2a2374128487db093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MjA0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492252049", "bodyText": "Originally, I had topPos == -1 when the stack was empty.  I think I preferred it that way.", "author": "dougqh", "createdAt": "2020-09-21T18:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NTUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492166127", "bodyText": "Should this be private? Seems like internal state.", "author": "arkban", "createdAt": "2020-09-21T15:48:12Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];", "originalCommit": "b6985538d4d8f485557af5c2a2374128487db093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0NTkxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492245915", "bodyText": "Originally, I didn't make them private because I didn't want synthetic accessors to be generated.", "author": "dougqh", "createdAt": "2020-09-21T17:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NzUyNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492167526", "bodyText": "Why not use an ArrayList? You might do better off with that and calling ArrayList.trimToSize() when it's capacity grows beyond what you want.", "author": "arkban", "createdAt": "2020-09-21T15:50:08Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/scopemanager/ContinuableScopeManager.java", "diffHunk": "@@ -264,101 +253,66 @@ public void afterActivated() {\n     }\n   }\n \n+  /**\n+   * The invariant is that the top of a non-empty stack is always active. Anytime a scope is closed,\n+   * cleanup() is called to ensure the invariant\n+   */\n   static final class ScopeStack {\n-    ContinuableScope[] stack = new ContinuableScope[16];\n+    private static final int MIN_STACK_LENGTH = 16;\n+\n+    ContinuableScope[] stack = new ContinuableScope[MIN_STACK_LENGTH];\n+    // The position of the top-most scope guaranteed to be active\n+    // 0 if empty\n     int topPos = 0;\n \n-    /**\n-     * top - accesses the top of the ScopeStack making sure the Scope on-top is still active If the\n-     * top scope isn't active, then the stack is popped back to the top-most active Scope\n-     */\n+    /** top - accesses the top of the ScopeStack */\n     final ContinuableScope top() {\n-      int priorTopPos = this.topPos;\n-      if (priorTopPos == 0) {\n-        return null;\n-      }\n+      return stack[topPos];\n+    }\n \n+    void cleanup() {\n       // localizing & clamping stackPos to enable ArrayBoundsCheck elimination\n       // only bothering to do this here because of the loop below\n-      ContinuableScope[] stack = this.stack;\n-      priorTopPos = Math.min(priorTopPos, stack.length);\n-\n-      // Peel first iteration\n-      ContinuableScope topScope = stack[priorTopPos];\n-      if (topScope.alive()) {\n-        return topScope;\n-      }\n+      final ContinuableScope[] stack = this.stack;\n+      topPos = Math.min(topPos, stack.length);\n \n-      // null out top position, it is no longer alive\n-      stack[topPos] = null;\n-\n-      for (int curPos = topPos - 1; curPos > 0; --curPos) {\n-        ContinuableScope curScope = stack[curPos];\n+      boolean changedTop = false;\n+      while (topPos > 0) {\n+        final ContinuableScope curScope = stack[topPos];\n         if (curScope.alive()) {\n-          // save the position for next time\n-          topPos = curPos;\n-\n-          if (topPos < stack.length / 4) {\n-            this.stack = Arrays.copyOf(stack, stack.length / 2);\n+          if (changedTop) {\n+            curScope.afterActivated();\n           }\n-\n-          return curScope;\n+          break;\n         }\n \n         // no longer alive -- trigger listener & null out\n         curScope.onProperClose();\n-        stack[curPos] = null;\n+        stack[topPos] = null;\n+        --topPos;\n+        changedTop = true;\n       }\n \n-      // empty stack -- save topPos for next time\n-      topPos = 0;\n-      return null;\n-    }\n-\n-    /**\n-     * Similar to top but without the fix-up behavior that skips over any closed Scopes Mostly\n-     * useful in logging to avoid side effects, but could be used in other places with caution.\n-     */\n-    final ContinuableScope noFixupTop() {\n-      return stack[topPos];\n+      if (topPos < stack.length / 4 && stack.length > MIN_STACK_LENGTH * 4) {\n+        this.stack = Arrays.copyOf(stack, stack.length / 2);\n+      }", "originalCommit": "b6985538d4d8f485557af5c2a2374128487db093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI1MDA4Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492250086", "bodyText": "Yes, in retrospect, an ArrayList probably would work fine.  I'm not quite sure why I chose to use an array directly.\nI wanted a stack, but I didn't want Stack since it has sync overhead.\nI think I also wanted to control the contraction, but honestly, I think we could just skip the contraction altogether.", "author": "dougqh", "createdAt": "2020-09-21T18:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NzUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5MzQ0MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1889#discussion_r492393441", "bodyText": "I remembered the prototype.  I had a bulk clear which was easier to do with an array directly, but that's not really worth the trouble when the listener also needs to be notified.\nIn a separate conversation, @randomanderson proposed an ArrayDeque which I think should work nicely.", "author": "dougqh", "createdAt": "2020-09-21T23:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NzUyNg=="}], "type": "inlineReview"}]}