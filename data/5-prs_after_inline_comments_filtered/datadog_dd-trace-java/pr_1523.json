{"pr_number": 1523, "pr_title": "MLT binary format support", "pr_createdAt": "2020-06-02T13:19:37Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1523", "timeline": [{"oid": "526728ebc51d138fb9214e8bae693724fc64ec1f", "url": "https://github.com/DataDog/dd-trace-java/commit/526728ebc51d138fb9214e8bae693724fc64ec1f", "message": "MLT specfic stacktrace collector prototype", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "6a78f18f10a9757ba8d776142b06a1e382ad4c8f", "url": "https://github.com/DataDog/dd-trace-java/commit/6a78f18f10a9757ba8d776142b06a1e382ad4c8f", "message": "Include duration info", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "392791ebd01441b5553410c49e03b81f5924842c", "url": "https://github.com/DataDog/dd-trace-java/commit/392791ebd01441b5553410c49e03b81f5924842c", "message": "Small adjustments", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "fee54b1b6b4f08941ef5a4dd387143280344c9bb", "url": "https://github.com/DataDog/dd-trace-java/commit/fee54b1b6b4f08941ef5a4dd387143280344c9bb", "message": "Fix hash code computation not to allocate byte array on hot path", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "638dd0a860b15873c54df1004f256631b9e9fb29", "url": "https://github.com/DataDog/dd-trace-java/commit/638dd0a860b15873c54df1004f256631b9e9fb29", "message": "Global tracer", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "8f1247029d6f045851b0fbde874355bc568e9447", "url": "https://github.com/DataDog/dd-trace-java/commit/8f1247029d6f045851b0fbde874355bc568e9447", "message": "Fix string constant pool handling for thread name", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "3d2b0996a41169a48746dc8bc789a9494467285d", "url": "https://github.com/DataDog/dd-trace-java/commit/3d2b0996a41169a48746dc8bc789a9494467285d", "message": "Scope wiring\n\nrename\nwire to Sampler and session", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "a1b31c6d390ad1b88cbb49e76b9f7abf11b672d0", "url": "https://github.com/DataDog/dd-trace-java/commit/a1b31c6d390ad1b88cbb49e76b9f7abf11b672d0", "message": "fixes", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "fba5d64e39848ddba892ee1d9fc136bd7e2b11f8", "url": "https://github.com/DataDog/dd-trace-java/commit/fba5d64e39848ddba892ee1d9fc136bd7e2b11f8", "message": "WIP", "committedDate": "2020-06-02T09:52:02Z", "type": "commit"}, {"oid": "7f6df54611cca624d2ce5333287c79132f765030", "url": "https://github.com/DataDog/dd-trace-java/commit/7f6df54611cca624d2ce5333287c79132f765030", "message": "WIP", "committedDate": "2020-06-02T09:52:28Z", "type": "commit"}, {"oid": "8c41476a8137e667c41597bdee73ab1fec7c42aa", "url": "https://github.com/DataDog/dd-trace-java/commit/8c41476a8137e667c41597bdee73ab1fec7c42aa", "message": "Add comments and final cleanup", "committedDate": "2020-06-02T09:52:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MDA5Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1523#discussion_r433880092", "bodyText": "FAR: could be hoisted out of the loop and maybe into a constant", "author": "jpbempel", "createdAt": "2020-06-02T13:36:46Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/io/MLTReader.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.datadog.profiling.mlt.io;\n+\n+import static com.datadog.profiling.mlt.io.MLTConstants.MAGIC;\n+\n+import com.datadog.profiling.util.LEB128ByteArrayReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/** The MLT binary format reader */\n+public final class MLTReader {\n+  /**\n+   * Read all subsequent MLT chunks from the given data\n+   *\n+   * @param data the MLT binary format data\n+   * @return the list of all chunks contained in the input data in order of appearance\n+   */\n+  public List<MLTChunk> readMLTChunks(byte[] data) {\n+    LEB128ByteArrayReader r = new LEB128ByteArrayReader(data);\n+    List<MLTChunk> chunks = new ArrayList<>();\n+    while (r.hasMore()) {\n+      chunks.add(readMLTChunk(r));\n+    }\n+    return chunks;\n+  }\n+\n+  private MLTChunk readMLTChunk(LEB128ByteArrayReader r) {\n+    int chunkBase = r.position();\n+    byte[] magic = r.readBytes(4);\n+    if (!Arrays.equals(MAGIC, magic)) {\n+      throw new IllegalStateException();\n+    }\n+\n+    byte version = r.readByte();\n+    int size = r.readIntRaw();\n+    int cpOffset = r.readIntRaw();\n+    long ts = r.readLong();\n+    long duration = r.readLong();\n+    long threadId = r.readLong();\n+\n+    int eventStart =\n+        r.getAndSetPos(cpOffset + chunkBase); // save the position and jump to constant pools\n+    ConstantPool<String> stringPool = readStringConstantPool(r);\n+    ConstantPool<FrameElement> framePool = readFrameConstantPool(r, stringPool);\n+    ConstantPool<FrameSequence> stackPool = readStackConstantPool(r, framePool);\n+\n+    // save the chunk end position and restore the event sequence position\n+    int endpos = r.getAndSetPos(eventStart);\n+    List<FrameSequence> stackElements = readStackEvents(r, stackPool);\n+\n+    MLTChunk chunk =\n+        new MLTChunk(\n+            version,\n+            size,\n+            ts,\n+            duration,\n+            threadId,\n+            stringPool.get(0),\n+            stringPool,\n+            framePool,\n+            stackPool,\n+            stackElements);\n+    r.getAndSetPos(endpos); // move to the end of chunk\n+    return chunk;\n+  }\n+\n+  private List<FrameSequence> readStackEvents(\n+      LEB128ByteArrayReader r, ConstantPool<FrameSequence> stackPool) {\n+    int eventCount = r.readInt();\n+    int ptr = 0;\n+    FrameSequence lastElement = null;\n+    List<FrameSequence> stackElements = new ArrayList<>(eventCount);\n+    for (int i = 0; i < eventCount; i++) {\n+      int cnt = 1;\n+      ptr = r.readInt();\n+      if ((ptr & MLTConstants.EVENT_REPEAT_FLAG) == MLTConstants.EVENT_REPEAT_FLAG) {\n+        if (lastElement == null) {\n+          throw new IllegalStateException();\n+        }\n+        cnt = (ptr & MLTConstants.EVENT_REPEAT_MASK);\n+      } else {\n+        lastElement = stackPool.get(ptr);\n+      }\n+      for (int j = 0; j < cnt; j++) {\n+        stackElements.add(lastElement);\n+      }\n+    }\n+    return stackElements;\n+  }\n+\n+  private ConstantPool<FrameSequence> readStackConstantPool(\n+      LEB128ByteArrayReader r, ConstantPool<FrameElement> framePool) {\n+    int cpSize;\n+    ConstantPool<FrameSequence> stackPool = new ConstantPool<>();\n+    cpSize = r.readInt();\n+    for (int i = 0; i < cpSize; i++) {\n+      int ptr = r.readInt();\n+      byte type = r.readByte();\n+      int[] framePtrs = new int[0];", "originalCommit": "8c41476a8137e667c41597bdee73ab1fec7c42aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkzNTAxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1523#discussion_r433935019", "bodyText": "Nice catch! Done!", "author": "jbachorik", "createdAt": "2020-06-02T14:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MDA5Mg=="}], "type": "inlineReview"}, {"oid": "1a77beac7de4b71925184e1bcab544753d93239e", "url": "https://github.com/DataDog/dd-trace-java/commit/1a77beac7de4b71925184e1bcab544753d93239e", "message": "Switch primitive collection library.\nFastUtils have much smaller impact on the final agent size than eclipse-collections and offer pretty much the same performance.", "committedDate": "2020-06-02T14:33:06Z", "type": "commit"}, {"oid": "510678482109960e77bb6fe93415ef99875dca24", "url": "https://github.com/DataDog/dd-trace-java/commit/510678482109960e77bb6fe93415ef99875dca24", "message": "Minimize the agent shadow jar - no need to include full JMC client", "committedDate": "2020-06-02T14:33:35Z", "type": "commit"}, {"oid": "79daa896fc97a4a46e31d31b2721cfeeca95cd83", "url": "https://github.com/DataDog/dd-trace-java/commit/79daa896fc97a4a46e31d31b2721cfeeca95cd83", "message": "Add a 'smokey' smoke test for MLT being enabled", "committedDate": "2020-06-02T14:44:08Z", "type": "commit"}, {"oid": "3978c9bf44e5eef87237d12791929763b198f2ab", "url": "https://github.com/DataDog/dd-trace-java/commit/3978c9bf44e5eef87237d12791929763b198f2ab", "message": "Hoist the array allocation out of the main loop", "committedDate": "2020-06-02T14:47:48Z", "type": "commit"}, {"oid": "7fdc9dcc0bb75a9db8e31ded84fd2defc08f01a3", "url": "https://github.com/DataDog/dd-trace-java/commit/7fdc9dcc0bb75a9db8e31ded84fd2defc08f01a3", "message": "Make formatter happy", "committedDate": "2020-06-02T17:24:34Z", "type": "commit"}, {"oid": "274eaea7c0988a11630ff07134d241d200840fc8", "url": "https://github.com/DataDog/dd-trace-java/commit/274eaea7c0988a11630ff07134d241d200840fc8", "message": "Unbreak the agent broken due to 'miminization'", "committedDate": "2020-06-03T08:11:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4OTMyNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1523#discussion_r434389324", "bodyText": "Why do these methods read more data than they produce? Are the values 8 byte aligned? If so, it possible to read the 2 bytes you need and then skip the 6 you don't? Or the other way around depending on endianness.", "author": "richardstartin", "createdAt": "2020-06-03T08:15:52Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/util/LEB128ByteArrayReader.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.datadog.profiling.util;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+/** Byte-array writer with default support for LEB128 encoded integer types */\n+public final class LEB128ByteArrayReader {\n+  private static final int EXT_BIT = 0x80;\n+  private static final long COMPRESSED_INT_MASK = 0x7f;\n+  private final byte[] array;\n+  private int pointer = 0;\n+\n+  public LEB128ByteArrayReader(byte[] data) {\n+    array = Arrays.copyOf(data, data.length);\n+  }\n+\n+  /** Reset the reader - set the reading position back to 0 */\n+  public void reset() {\n+    pointer = 0;\n+  }\n+\n+  /**\n+   * Check whether there is more data to read\n+   *\n+   * @return {@literal true} if there is more data to read\n+   */\n+  public boolean hasMore() {\n+    return pointer < array.length;\n+  }\n+\n+  /**\n+   * Get the current position and set the new one\n+   *\n+   * @param pos the new position\n+   * @return the previous position\n+   */\n+  public int getAndSetPos(int pos) {\n+    if (pos > array.length) {\n+      throw new ArrayIndexOutOfBoundsException();\n+    }\n+    int current = pointer;\n+    pointer = pos;\n+    return current;\n+  }\n+\n+  public char readChar() {\n+    return (char) (readLong() & 0xffff);", "originalCommit": "274eaea7c0988a11630ff07134d241d200840fc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwMTQ2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1523#discussion_r434401463", "bodyText": "Well... readLong() reads LEB128 packed integer number (perhaps the name is slightly misleading but I shamelessly copied it from the JFR code) which will have the necessary number of bytes required to hold that particular value. So, for char it will be 1-2 bytes, assuming that the reader is actually reading something that was written as a packed char.\nI admit, the parser is not totally robust and can read in junk if the read order does not correspond to the writer order. Should improve that once we know we are going to use this parser in production - for now it is used only in controlled test env so I didn't want to spend more time on hardening it.\nAs for reading char as 'long' - we are using unsigned LEB128 packing but in java all integer types are signed. So the type must be widened first and then masked :/", "author": "jbachorik", "createdAt": "2020-06-03T08:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4OTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MTI1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1523#discussion_r434441253", "bodyText": "OK I see, I didn't read the readLong() method carefully, I see it terminates when it finds the MSB is unset, so it's a form or varint coding.\nNote that char is unsigned, but I see your point for short and int.", "author": "richardstartin", "createdAt": "2020-06-03T09:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4OTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NDIwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1523#discussion_r434464200", "bodyText": "\ud83d\udc4d", "author": "jbachorik", "createdAt": "2020-06-03T10:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4OTMyNA=="}], "type": "inlineReview"}]}