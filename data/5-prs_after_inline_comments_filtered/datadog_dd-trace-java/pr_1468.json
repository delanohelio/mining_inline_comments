{"pr_number": 1468, "pr_title": "JMX implementation of Profiling Session", "pr_createdAt": "2020-05-18T09:44:37Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1468", "timeline": [{"oid": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "url": "https://github.com/DataDog/dd-trace-java/commit/e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "message": "draft wiring with SamplerWriter", "committedDate": "2020-05-19T14:35:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1NDk2Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427354966", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n          \n          \n            \n              private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();", "author": "jbachorik", "createdAt": "2020-05-19T14:38:35Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTI0Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895242", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1NDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwOTk0NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427409945", "bodyText": "This looks quite suspicious - force creating an array when the session is always bound to a single thread.\nI know that it is used in the sample() method but it would feel more appropriate to have a sampler class factored out which would maintain a set of thread IDs which are supposed to be sampled (maybe wrapped as Session instances if that makes sense).", "author": "jbachorik", "createdAt": "2020-05-19T15:50:42Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+    this.id = id;\n+    this.threadIds = new long[] { threadId };", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTQyNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895425", "bodyText": "moved to JMXSampler", "author": "jpbempel", "createdAt": "2020-05-20T10:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwOTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMDc5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427420795", "bodyText": "Passing around a map which is essentially an internal state of the JMXSessionFactory does not look really nice.\nCan't this be resolved with a session having active flag for true when refCount > 0 and a callback to the instantiating factory to notify that a session has become inactive when the flag is flipped. The factory would then do a concurrent update of the map depending on the current value of the active flag, thus preventing data race when a session is brought back to life.", "author": "jbachorik", "createdAt": "2020-05-19T16:05:47Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTUyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895527", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMDc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMTA3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427421075", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  log.warn(\"ThreadStack provider is oo op. It will not provide thread stacks.\");\n          \n          \n            \n                  log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");", "author": "jbachorik", "createdAt": "2020-05-19T16:06:08Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+    this.id = id;\n+    this.threadIds = new long[] { threadId };\n+    this.sink = sinkSupplier.get();\n+    this.sessions = sessions;\n+    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+    if (provider instanceof NoneThreadStackProvider) {\n+      log.warn(\"ThreadStack provider is oo op. It will not provide thread stacks.\");", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTYwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895607", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMjI5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427422293", "bodyText": "A bit of bike-shedding but a name less bound to the actual implementation would be nice - something like activate or use?", "author": "jbachorik", "createdAt": "2020-05-19T16:07:53Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSession.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import datadog.trace.profiling.Session;\n+import java.lang.management.ThreadInfo;\n+import java.util.Map;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSession implements Session {\n+  private final String id;\n+  private final long[] threadIds;\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final Map<Long, JMXSession> sessions;\n+  private final AtomicInteger refCount = new AtomicInteger();\n+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n+\n+  public JMXSession(String id, long threadId, Supplier<StackTraceSink> sinkSupplier, Map<Long, JMXSession> sessions) {\n+    this.id = id;\n+    this.threadIds = new long[] { threadId };\n+    this.sink = sinkSupplier.get();\n+    this.sessions = sessions;\n+    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+    if (provider instanceof NoneThreadStackProvider) {\n+      log.warn(\"ThreadStack provider is oo op. It will not provide thread stacks.\");\n+    }\n+    start();\n+  }\n+\n+  public void close() {\n+    sessions.computeIfPresent(threadIds[0], this::closeSession);\n+  }\n+\n+  private JMXSession closeSession(Long key, JMXSession jmxSession) {\n+    int current = jmxSession.decRefCount();\n+    if (current == 0) {\n+      executor.shutdown();\n+      byte[] buffer = sink.flush();\n+      log.info(\"Closing session, flushing {} bytes\", buffer.length);\n+      return null;\n+    }\n+    return jmxSession;\n+  }\n+\n+  void incRefCount() {", "originalCommit": "e91ee3405eb6dfb7c6f01d681533f84ed5c80a6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NTcwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r427895700", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T10:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQyMjI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4MDA1MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428080051", "bodyText": "Please, package private only. I guess this class should not be used outside of MLT directly.", "author": "jbachorik", "createdAt": "2020-05-20T14:55:55Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import java.lang.management.ThreadInfo;\n+import java.util.Arrays;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSampler {", "originalCommit": "1ffc830ff319a0cd49fbbff4765691a92a319c70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExMzkzMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428113932", "bodyText": "done", "author": "jpbempel", "createdAt": "2020-05-20T15:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4MDA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4MDk3MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428080971", "bodyText": "Can you add some comments about pre/post-conditions? Like that a thread ID will always be added so calling it multiple time will result in multiple occurrences of the same ID etc.", "author": "jbachorik", "createdAt": "2020-05-20T14:57:06Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSampler.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.core.util.NoneThreadStackProvider;\n+import datadog.trace.core.util.ThreadStackAccess;\n+import datadog.trace.core.util.ThreadStackProvider;\n+import java.lang.management.ThreadInfo;\n+import java.util.Arrays;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSampler {\n+  private final StackTraceSink sink;\n+  private final ThreadStackProvider provider;\n+  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+  private long samplingCount;\n+  private AtomicReference<long[]> threadIds = new AtomicReference<>();\n+\n+  public JMXSampler(StackTraceSink sink) {\n+    this.sink = sink;\n+    provider = ThreadStackAccess.getCurrentThreadStackProvider();\n+    if (provider instanceof NoneThreadStackProvider) {\n+      log.warn(\"ThreadStack provider is no op. It will not provide thread stacks.\");\n+    }\n+    // TODO period as parameter\n+    executor.scheduleAtFixedRate(this::sample, 0, 10, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void shutdown() {\n+    executor.shutdown();\n+    byte[] buffer = sink.flush();\n+    log.info(\"Flushing remaining {} bytes\", buffer.length);\n+  }\n+\n+  public void addThreadId(long threadId) {", "originalCommit": "1ffc830ff319a0cd49fbbff4765691a92a319c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4Mzc5Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1468#discussion_r428083792", "bodyText": "I think that the interplay between closeSession() and createSession in regards of thread safety should be documented here.\nIf I am not missing something the code is data-race free thanks to closeSession being run as the ConcurrentHashMap computation which is guaranteed to run at most once and atomically. Unfortunately, this is not a general characteristic of all ConcurrentMap types so it would be good to have it documented for future maintenance.", "author": "jbachorik", "createdAt": "2020-05-20T15:00:29Z", "path": "dd-java-agent/agent-profiling/profiling-controller/src/main/java/com/datadog/profiling/mlt/JMXSessionFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.datadog.profiling.mlt;\n+\n+import datadog.trace.profiling.Session;\n+import datadog.trace.profiling.SessionFactory;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class JMXSessionFactory implements SessionFactory {\n+  private final Map<Long, JMXSession> jmxSessions = new ConcurrentHashMap<>();\n+  private final JMXSampler sampler;\n+\n+  public JMXSessionFactory(StackTraceSink sink) {\n+    this.sampler = new JMXSampler(sink);\n+  }\n+\n+  @Override\n+  public Session createSession(String id, Thread thread) {\n+    long threadId = thread.getId();\n+    JMXSession session =\n+        jmxSessions.computeIfAbsent(threadId, key -> createNewSession(id, threadId));\n+    session.activate();\n+    return session;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    sampler.shutdown();\n+  }\n+\n+  private JMXSession createNewSession(String id, long threadId) {\n+    sampler.addThreadId(threadId);\n+    return new JMXSession(id, threadId, this::cleanup);\n+  }\n+\n+  private void cleanup(JMXSession session) {\n+    jmxSessions.computeIfPresent(session.getThreadId(), this::closeSession);\n+  }\n+\n+  private JMXSession closeSession(Long key, JMXSession jmxSession) {", "originalCommit": "1ffc830ff319a0cd49fbbff4765691a92a319c70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0408a6bb6c6c471e179906c7bab81363ff0cbd46", "url": "https://github.com/DataDog/dd-trace-java/commit/0408a6bb6c6c471e179906c7bab81363ff0cbd46", "message": "JMX implementation of Profiling Session", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "3b11f0b35a24792b396f0c746d182b95da4ba24e", "url": "https://github.com/DataDog/dd-trace-java/commit/3b11f0b35a24792b396f0c746d182b95da4ba24e", "message": "formatting", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "4cb76a8e62691cf3f9ae264b69c7ee1e36e98c8d", "url": "https://github.com/DataDog/dd-trace-java/commit/4cb76a8e62691cf3f9ae264b69c7ee1e36e98c8d", "message": "Wire with SamplerWriter", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "cd25b19872fe0fdef1902a3bed8698fe9d7d1cdd", "url": "https://github.com/DataDog/dd-trace-java/commit/cd25b19872fe0fdef1902a3bed8698fe9d7d1cdd", "message": "draft wiring with SamplerWriter", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "bb2e1a7e7b82b3edfb5fb635df1b5311c51ee11c", "url": "https://github.com/DataDog/dd-trace-java/commit/bb2e1a7e7b82b3edfb5fb635df1b5311c51ee11c", "message": "Move sampling executor to the factory", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "fbe3da5657f84da994ccd2572b4083e7f1b828c4", "url": "https://github.com/DataDog/dd-trace-java/commit/fbe3da5657f84da994ccd2572b4083e7f1b828c4", "message": "move Sampling logic to JMXSampler", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "c8c648cc3395ca016dae45bea36a5c9fd890c431", "url": "https://github.com/DataDog/dd-trace-java/commit/c8c648cc3395ca016dae45bea36a5c9fd890c431", "message": "add test", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "498d64fe777a7bf164e4ac18d11152cbb2412ef8", "url": "https://github.com/DataDog/dd-trace-java/commit/498d64fe777a7bf164e4ac18d11152cbb2412ef8", "message": "add test for Sampler", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "973e8978c4bcc0a5566aad2e4a5b18b7d39d7139", "url": "https://github.com/DataDog/dd-trace-java/commit/973e8978c4bcc0a5566aad2e4a5b18b7d39d7139", "message": "fix package name", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "5ea49ef2b9b879c33aaebe1da9eb6404672469c5", "url": "https://github.com/DataDog/dd-trace-java/commit/5ea49ef2b9b879c33aaebe1da9eb6404672469c5", "message": "add DaemonThreadFactory for sampler thread\n\nAdd comments regarding concurrenty", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "a46ff114904419dbd99c8a0f00b248f8b4fd152a", "url": "https://github.com/DataDog/dd-trace-java/commit/a46ff114904419dbd99c8a0f00b248f8b4fd152a", "message": "formatting", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "89d71eec14bc13667f71f385610a68f9d2cf6bbd", "url": "https://github.com/DataDog/dd-trace-java/commit/89d71eec14bc13667f71f385610a68f9d2cf6bbd", "message": "increase test coverage", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "b53f2c31fc382802beb5d90e961ae69e6da34f39", "url": "https://github.com/DataDog/dd-trace-java/commit/b53f2c31fc382802beb5d90e961ae69e6da34f39", "message": "improve test coverage", "committedDate": "2020-05-20T22:14:04Z", "type": "commit"}, {"oid": "b53f2c31fc382802beb5d90e961ae69e6da34f39", "url": "https://github.com/DataDog/dd-trace-java/commit/b53f2c31fc382802beb5d90e961ae69e6da34f39", "message": "improve test coverage", "committedDate": "2020-05-20T22:14:04Z", "type": "forcePushed"}]}