{"pr_number": 3273, "pr_title": "[STORM-3638] Add fast process liveness check", "pr_createdAt": "2020-05-21T23:18:03Z", "pr_url": "https://github.com/apache/storm/pull/3273", "timeline": [{"oid": "04b690d861c22d1a95af8b5add2e174b8590abf7", "url": "https://github.com/apache/storm/commit/04b690d861c22d1a95af8b5add2e174b8590abf7", "message": "[STORM-3638] Add fast process checking.", "committedDate": "2020-05-21T23:12:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwMjE5MQ==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434102191", "bodyText": "This doesn't seem needed", "author": "Ethanlm", "createdAt": "2020-06-02T18:46:32Z", "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -62,12 +67,14 @@\n  * Represents a container that a worker will run in.\n  */\n public abstract class Container implements Killable {\n+    public static final boolean IS_ON_WINDOWS = \"Windows_NT\".equals(System.getenv(\"OS\"));", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5MDU3NA==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434890574", "bodyText": "Removed", "author": "bipinprasad", "createdAt": "2020-06-03T22:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwMjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTA0MQ==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434109041", "bodyText": "can be simplified with StringUtils.join(pids, ',');", "author": "Ethanlm", "createdAt": "2020-06-02T18:59:00Z", "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5MzA3NA==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434893074", "bodyText": "Changed", "author": "bipinprasad", "createdAt": "2020-06-03T22:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTE2Mw==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434109163", "bodyText": "here too", "author": "Ethanlm", "createdAt": "2020-06-02T18:59:12Z", "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5MzUzMg==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434893532", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-06-03T22:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTIyNw==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434109227", "bodyText": "here too", "author": "Ethanlm", "createdAt": "2020-06-02T18:59:19Z", "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o user -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified UID.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5Mzc3NQ==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434893775", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-06-03T22:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDk2OA==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434124968", "bodyText": "processed --> processes", "author": "Ethanlm", "createdAt": "2020-06-02T19:26:34Z", "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o user -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified UID.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o uid -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"uid\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"UID\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain UID, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                try {\n+                    if (uid == Integer.parseInt(line)) {\n+                        return true;\n+                    }\n+                } catch (Exception ex) {\n+                    LOG.warn(\"Expecting UID integer but got {} in output of ps command\", line);\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o uid -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as UIDs {}: but expected userId is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), uid);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get the userId for a user name. This works on Posix systems by using \"id -u\" command.\n+     * Throw IllegalArgumentException on Windows.\n+     *\n+     * @param user username to be converted to UID. This is optional, in which case current user is returned.\n+     * @return UID for the specified user (if supplied), else UID of current user, -1 upon Exception.\n+     */\n+    public static int getUserId(String user) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"id\");\n+        cmdArgs.add(\"-u\");\n+        if (user != null && !user.isEmpty()) {\n+            cmdArgs.add(user);\n+        }\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#1: {}\", line);\n+            try {\n+                return Integer.parseInt(line.trim());\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting UID integer but got {} in output of \\\"id -u {}\\\" command\", line, user);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs)), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get the userId of the onwer of the path by running \"ls -n path\" command.\n+     * This command works on Posix systems only.\n+     *\n+     * @param fpath full path to the file.\n+     * @return UID for the specified if successful, -1 upon failure.\n+     */\n+    public static int getPathOwnerUId(String fpath) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        File f = new File(fpath);\n+        if (!f.exists()) {\n+            LOG.error(\"Cannot determine owner of non-existent file {}\", fpath);\n+            return -1;\n+        }\n+        LOG.debug(\"CMD: ls -n {}\", fpath);\n+        ProcessBuilder pb = new ProcessBuilder(\"ls\", \"-n\", fpath);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-OUTLINE: {}\", line);\n+            line = line.trim();\n+            String[] parts = line.split(\"\\\\s+\");\n+            if (parts.length < 3) {\n+                LOG.error(\"Expecting at least 3 space separated fields in \\\"ls -n {}\\\" output, got {}\", fpath, line);\n+                return -1;\n+            }\n+            try {\n+                return Integer.parseInt(parts[2]);\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting at third field {} to be numeric UID \\\"ls -n {}\\\" output, got {}\", parts[2], fpath, line);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"ls -n %s\\\"\", fpath), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get UID of the owner to the workerId PIDs Root directory.\n+     *\n+     * @return User ID (UID) of owner of the PID file, -1 if file is missing.\n+     */\n+    private int getPidPathOwnerUid(String workerId, long pid) {\n+        return getPathOwnerUId(ConfigUtils.workerPidPath(conf, workerId, pid));\n+    }\n+\n+    /**\n+     * Find if all processed for the user on workId are dead.", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg5NDA1MA==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434894050", "bodyText": "fixed", "author": "bipinprasad", "createdAt": "2020-06-03T22:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNzk3NA==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434127974", "bodyText": "We don't have to check the owner of pid file. Checking the owner of the worker-id directory should be good enough.", "author": "Ethanlm", "createdAt": "2020-06-02T19:32:15Z", "path": "storm-server/src/main/java/org/apache/storm/daemon/supervisor/Container.java", "diffHunk": "@@ -290,49 +301,368 @@ private boolean isWindowsProcessAlive(long pid, String user) throws IOException\n         return ret;\n     }\n \n-    private boolean isPosixProcessAlive(long pid, String user) throws IOException {\n-        boolean ret = false;\n+    private static boolean isPosixProcessAlive(long pid, String user) throws IOException {\n+        LOG.debug(\"CMD: ps -o user -p {}\", pid);\n         ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", String.valueOf(pid));\n-        pb.redirectError(Redirect.INHERIT);\n-        Process p = pb.start();\n-        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-            String first = in.readLine();\n-            assert (\"USER\".equals(first));\n-            String processUser;\n-            while ((processUser = in.readLine()) != null) {\n-                if (user.equals(processUser)) {\n-                    ret = true;\n-                    break;\n-                } else {\n-                    LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, processUser, user);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n                 }\n+                LOG.info(\"Found {} running as {}, but expected it to be {}\", pid, line, user);\n             }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %d\\\"\", pid);\n+            throw new IOException(err, ex);\n         }\n-        return ret;\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, user);\n+        }\n+        return isAnyPosixProcessAlive(pids, user);\n     }\n-    \n+\n+    /**\n+     * Are any of the processes alive and running for the specified userId. If collection is empty or null\n+     * then the return value is trivially false.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    public static boolean isAnyProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        if (pids == null || pids.isEmpty()) {\n+            return false;\n+        }\n+        if (ServerUtils.IS_ON_WINDOWS) {\n+            return isAnyWindowsProcessAlive(pids, uid);\n+        }\n+        return isAnyPosixProcessAlive(pids, uid);\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified user.\n+     * Command reference https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/tasklist.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"tasklist\");\n+        cmdArgs.add(\"/fo\");\n+        cmdArgs.add(\"list\");\n+        pids.forEach(pid -> {\n+            cmdArgs.add(\"/fi\");\n+            cmdArgs.add(\"pid eq \" + pid);\n+        });\n+        cmdArgs.add(\"/v\");\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 0;\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                if (line.contains(\"User Name:\")) { //Check for : in case someone called their user \"User Name\"\n+                    //This line contains the user name for the pid we're looking up\n+                    //Example line: \"User Name:    exampleDomain\\exampleUser\"\n+                    List<String> userNameLineSplitOnWhitespace = Arrays.asList(line.split(\":\"));\n+                    if (userNameLineSplitOnWhitespace.size() == 2) {\n+                        List<String> userAndMaybeDomain = Arrays.asList(userNameLineSplitOnWhitespace.get(1).trim().split(\"\\\\\\\\\"));\n+                        String processUser = userAndMaybeDomain.size() == 2 ? userAndMaybeDomain.get(1) : userAndMaybeDomain.get(0);\n+                        processUser = processUser.trim();\n+                        if (user.equals(processUser)) {\n+                            return true;\n+                        }\n+                        unexpectedUsers.add(processUser);\n+                    } else {\n+                        LOG.error(\"Received unexpected output from tasklist command. Expected one colon in user name line. Line was {}\",\n+                                line);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs));\n+            throw new IOException(err, ex);\n+        }\n+        String pidsAsStr = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidsAsStr);\n+        } else {\n+            LOG.info(\"{} of the Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pidsAsStr, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Find if any of the Windows processes are alive and owned by the specified userId.\n+     * This overridden method is provided for symmetry, but is not implemented.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyWindowsProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        throw new IllegalArgumentException(\"UID is not supported on Windows\");\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified user.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param user the user that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, String user) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o user -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"user\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"USER\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain USER, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                if (user.equals(line)) {\n+                    return true;\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o user -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as user(s) {}: but expected user is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), user);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Are any of the processes alive and running for the specified UID.\n+     *\n+     * @param pids the PIDs of the running processes\n+     * @param uid the userId that is expected to own that process\n+     * @return true if any one of the processes is owned by user and alive, else false\n+     * @throws IOException on I/O exception\n+     */\n+    private static boolean isAnyPosixProcessAlive(Collection<Long> pids, int uid) throws IOException {\n+        String pidParams = pids.stream().map(String::valueOf).collect(Collectors.joining(\",\"));\n+        LOG.debug(\"CMD: ps -o uid -p {}\", pidParams);\n+        ProcessBuilder pb = new ProcessBuilder(\"ps\", \"-o\", \"uid\", \"-p\", pidParams);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        List<String> unexpectedUsers = new ArrayList<>();\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            int lineNo = 1;\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+            if (!\"UID\".equals(line.trim())) {\n+                LOG.error(\"Expecting first line to contain UID, found \\\"{}\\\"\", line);\n+                return false;\n+            }\n+            while ((line = in.readLine()) != null) {\n+                lineNo++;\n+                LOG.debug(\"CMD-LINE#{}: {}\", lineNo, line);\n+                line = line.trim();\n+                try {\n+                    if (uid == Integer.parseInt(line)) {\n+                        return true;\n+                    }\n+                } catch (Exception ex) {\n+                    LOG.warn(\"Expecting UID integer but got {} in output of ps command\", line);\n+                }\n+                unexpectedUsers.add(line);\n+            }\n+        } catch (IOException ex) {\n+            String err = String.format(\"Cannot read output of command \\\"ps -o uid -p %s\\\"\", pidParams);\n+            throw new IOException(err, ex);\n+        }\n+        if (unexpectedUsers.isEmpty()) {\n+            LOG.info(\"None of the processes {} are alive\", pidParams);\n+        } else {\n+            LOG.info(\"{} of {} Processes {} are running as UIDs {}: but expected userId is {}\",\n+                    unexpectedUsers.size(), pids.size(), pidParams, String.join(\",\", new TreeSet<>(unexpectedUsers)), uid);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get the userId for a user name. This works on Posix systems by using \"id -u\" command.\n+     * Throw IllegalArgumentException on Windows.\n+     *\n+     * @param user username to be converted to UID. This is optional, in which case current user is returned.\n+     * @return UID for the specified user (if supplied), else UID of current user, -1 upon Exception.\n+     */\n+    public static int getUserId(String user) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        List<String> cmdArgs = new ArrayList<>();\n+        cmdArgs.add(\"id\");\n+        cmdArgs.add(\"-u\");\n+        if (user != null && !user.isEmpty()) {\n+            cmdArgs.add(user);\n+        }\n+        LOG.debug(\"CMD: {}\", String.join(\" \", cmdArgs));\n+        ProcessBuilder pb = new ProcessBuilder(cmdArgs);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-LINE#1: {}\", line);\n+            try {\n+                return Integer.parseInt(line.trim());\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting UID integer but got {} in output of \\\"id -u {}\\\" command\", line, user);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"%s\\\"\", String.join(\" \", cmdArgs)), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get the userId of the onwer of the path by running \"ls -n path\" command.\n+     * This command works on Posix systems only.\n+     *\n+     * @param fpath full path to the file.\n+     * @return UID for the specified if successful, -1 upon failure.\n+     */\n+    public static int getPathOwnerUId(String fpath) {\n+        if (IS_ON_WINDOWS) {\n+            throw new IllegalArgumentException(\"Not supported in Windows platform\");\n+        }\n+        File f = new File(fpath);\n+        if (!f.exists()) {\n+            LOG.error(\"Cannot determine owner of non-existent file {}\", fpath);\n+            return -1;\n+        }\n+        LOG.debug(\"CMD: ls -n {}\", fpath);\n+        ProcessBuilder pb = new ProcessBuilder(\"ls\", \"-n\", fpath);\n+        pb.redirectError(ProcessBuilder.Redirect.INHERIT);\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(pb.start().getInputStream()))) {\n+            String line = in.readLine();\n+            LOG.debug(\"CMD-OUTLINE: {}\", line);\n+            line = line.trim();\n+            String[] parts = line.split(\"\\\\s+\");\n+            if (parts.length < 3) {\n+                LOG.error(\"Expecting at least 3 space separated fields in \\\"ls -n {}\\\" output, got {}\", fpath, line);\n+                return -1;\n+            }\n+            try {\n+                return Integer.parseInt(parts[2]);\n+            } catch (NumberFormatException ex) {\n+                LOG.error(\"Expecting at third field {} to be numeric UID \\\"ls -n {}\\\" output, got {}\", parts[2], fpath, line);\n+                return -1;\n+            }\n+        } catch (IOException ex) {\n+            LOG.error(String.format(\"Cannot read output of command \\\"ls -n %s\\\"\", fpath), ex);\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Get UID of the owner to the workerId PIDs Root directory.\n+     *\n+     * @return User ID (UID) of owner of the PID file, -1 if file is missing.\n+     */\n+    private int getPidPathOwnerUid(String workerId, long pid) {\n+        return getPathOwnerUId(ConfigUtils.workerPidPath(conf, workerId, pid));\n+    }\n+\n+    /**\n+     * Find if all processed for the user on workId are dead.\n+     * This method attempts to optimize the calls by:\n+     * <p>\n+     *     <li>creating a collection of ProcessIds and checking all of them at once</li>\n+     *     <li>using userId one Posix systems instead of user</li>\n+     * </p>\n+     *\n+     * @return true if all processes for the user are dead on the worker\n+     * @throws IOException if external commands have exception.\n+     */\n     @Override\n     public boolean areAllProcessesDead() throws IOException {\n         Set<Long> pids = getAllPids();\n         String user = getRunWorkerAsUser();\n \n         boolean allDead = true;\n-        for (Long pid : pids) {\n-            LOG.debug(\"Checking if pid {} owner {} is alive\", pid, user);\n-            if (!isProcessAlive(pid, user)) {\n-                LOG.debug(\"{}: PID {} is dead\", workerId, pid);\n+        try {\n+            if (pids.isEmpty()) {\n+                return true;\n+            }\n+            if (ServerUtils.IS_ON_WINDOWS) {\n+                return allDead = !isAnyProcessAlive(pids, user);\n+            }\n+            // optimized for Posix - try to use uid\n+            if (!cachedUserToUidMap.containsKey(user)) {\n+                int uid = getPidPathOwnerUid(workerId, pids.iterator().next());", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNjc3Ng==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434906776", "bodyText": "Replaced with check on directory instead of file. also changed corresponding command to use \"ls -dn\" instead of \"ls -n\".", "author": "bipinprasad", "createdAt": "2020-06-03T23:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTA5Mg==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434129092", "bodyText": "This is not the Assert we want to use I suppose.", "author": "Ethanlm", "createdAt": "2020-06-02T19:34:12Z", "path": "storm-server/src/test/java/org/apache/storm/daemon/supervisor/ContainerTest.java", "diffHunk": "@@ -13,24 +13,34 @@\n package org.apache.storm.daemon.supervisor;\n \n import com.google.common.base.Joiner;\n+\n+import java.io.BufferedReader;\n import java.io.File;\n import java.io.IOException;\n+import java.io.InputStreamReader;\n import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n+\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.logging.log4j.core.util.Assert;", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMTUzMw==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434901533", "bodyText": "good catch", "author": "bipinprasad", "createdAt": "2020-06-03T22:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTk1NQ==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434129955", "bodyText": "why not import org.junit.Assert  to make this line cleaner", "author": "Ethanlm", "createdAt": "2020-06-02T19:35:54Z", "path": "storm-server/src/test/java/org/apache/storm/daemon/supervisor/ContainerTest.java", "diffHunk": "@@ -271,4 +281,88 @@ public boolean runProfiling(ProfileRequest request, boolean stop) throws IOExcep\n             return false;\n         }\n     }\n+\n+    private Collection<Long> getRunningProcessIds() throws IOException {\n+        // get list of few running processes\n+        Collection<Long> pids = new ArrayList<>();\n+        Process p = Runtime.getRuntime().exec(ServerUtils.IS_ON_WINDOWS ? \"tasklist\" : \"ps -e\");\n+        try (BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String line;\n+            while ((line = input.readLine()) != null) {\n+                line = line.trim();\n+                if (line.isEmpty()) {\n+                    continue;\n+                }\n+                try {\n+                    pids.add(Long.parseLong(line.split(\"\\\\s\")[0]));\n+                } catch (Exception ex) {\n+                    continue;\n+                }\n+            }\n+        }\n+        return pids;\n+    }\n+\n+    @Test\n+    public void testIsProcessAlive() throws Exception {\n+        // specific selected process should be alive for a randomly generated user\n+        String randomUser = RandomStringUtils.randomAlphanumeric(12);\n+\n+        // get list of few running processes\n+        Collection<Long> pids = getRunningProcessIds();\n+        Assert.isNonEmpty(pids);\n+        for (long pid: pids) {\n+            boolean status = Container.isProcessAlive(pid, randomUser);\n+            org.junit.Assert.assertFalse(\"Random user \" + randomUser + \" is not expected to own any process\", status);", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMTY1MA==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434901650", "bodyText": "changed", "author": "bipinprasad", "createdAt": "2020-06-03T22:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMDMwNQ==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434130305", "bodyText": "should \"not\" be alive?", "author": "Ethanlm", "createdAt": "2020-06-02T19:36:35Z", "path": "storm-server/src/test/java/org/apache/storm/daemon/supervisor/ContainerTest.java", "diffHunk": "@@ -271,4 +281,88 @@ public boolean runProfiling(ProfileRequest request, boolean stop) throws IOExcep\n             return false;\n         }\n     }\n+\n+    private Collection<Long> getRunningProcessIds() throws IOException {\n+        // get list of few running processes\n+        Collection<Long> pids = new ArrayList<>();\n+        Process p = Runtime.getRuntime().exec(ServerUtils.IS_ON_WINDOWS ? \"tasklist\" : \"ps -e\");\n+        try (BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String line;\n+            while ((line = input.readLine()) != null) {\n+                line = line.trim();\n+                if (line.isEmpty()) {\n+                    continue;\n+                }\n+                try {\n+                    pids.add(Long.parseLong(line.split(\"\\\\s\")[0]));\n+                } catch (Exception ex) {\n+                    continue;\n+                }\n+            }\n+        }\n+        return pids;\n+    }\n+\n+    @Test\n+    public void testIsProcessAlive() throws Exception {\n+        // specific selected process should be alive for a randomly generated user", "originalCommit": "04b690d861c22d1a95af8b5add2e174b8590abf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwNzExMQ==", "url": "https://github.com/apache/storm/pull/3273#discussion_r434907111", "bodyText": "fixed", "author": "bipinprasad", "createdAt": "2020-06-03T23:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzMDMwNQ=="}], "type": "inlineReview"}, {"oid": "2fea038ad4f9f1308f74aafacdb49eee811341df", "url": "https://github.com/apache/storm/commit/2fea038ad4f9f1308f74aafacdb49eee811341df", "message": "[STORM-3638] Fix comment; use StringUtils.join ; check owner of worker-root instead of pid; use org.junit.Assert in test", "committedDate": "2020-06-04T13:09:12Z", "type": "commit"}, {"oid": "e90dffb08712f06084bdb870145c78d858abbb93", "url": "https://github.com/apache/storm/commit/e90dffb08712f06084bdb870145c78d858abbb93", "message": "[STORM-3638] Fix comment; use StringUtils.join ; check owner of worker-root instead of pid; use org.junit.Assert in test", "committedDate": "2020-06-04T13:09:52Z", "type": "commit"}]}