{"pr_number": 3322, "pr_title": "[STORM-3685] Detect and prevent cycles when Topology is submitted.", "pr_createdAt": "2020-08-07T17:24:26Z", "pr_url": "https://github.com/apache/storm/pull/3322", "timeline": [{"oid": "ffcf11615a596bfdb59c124a3a7c0726978231f0", "url": "https://github.com/apache/storm/commit/ffcf11615a596bfdb59c124a3a7c0726978231f0", "message": "[STORM-3685] Detect and prevent cycles when Topology is submitted.", "committedDate": "2020-08-07T17:16:54Z", "type": "commit"}, {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "url": "https://github.com/apache/storm/commit/0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "message": "[STORM-3685] Warn instead of rejecting Topology with cycles.", "committedDate": "2020-08-07T17:57:57Z", "type": "commit"}, {"oid": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "url": "https://github.com/apache/storm/commit/0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "message": "[STORM-3685] Warn instead of rejecting Topology with cycles.", "committedDate": "2020-08-07T17:57:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTU4Ng==", "url": "https://github.com/apache/storm/pull/3322#discussion_r469539586", "bodyText": "The topology here must be a userTopology (if it is a system topology, it will have loops because of ackers).\nSo I think we don't need to check Utils.isSystemId. And we don't need to get_inputs on spout since it will be empty. (see https://github.com/apache/storm/blob/master/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java#L162-L166)", "author": "Ethanlm", "createdAt": "2020-08-12T20:52:09Z", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {", "originalCommit": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0Nzc3NQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r470047775", "bodyText": "I wondered about the code in TopologyDetails.getComponents() - but seems superfluous. I will remove the get_inputs on spout and check for isSystemId check.", "author": "bipinprasad", "createdAt": "2020-08-13T15:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUzOTU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MjYyNQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r469562625", "bodyText": "can we use non-stateful bolt? We don't really use it anywhere. And it will insert some bolts into the topology. So the unit test result might be hard to understand. For example, like https://github.com/apache/storm/blob/master/storm-server/src/test/java/org/apache/storm/scheduler/resource/TestResourceAwareScheduler.java#L200-L201", "author": "Ethanlm", "createdAt": "2020-08-12T21:40:19Z", "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +254,184 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName;\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            private IRichSpout makeDummySpout() {\n+                return new BaseRichSpout() {\n+                    @Override\n+                    public void declareOutputFields(OutputFieldsDeclarer declarer) {\n+                    }\n+\n+                    @Override\n+                    public void open(Map<String, Object> conf, TopologyContext context, SpoutOutputCollector collector) {\n+                    }\n+\n+                    @Override\n+                    public void nextTuple() {\n+                    }\n+\n+                    private void writeObject(java.io.ObjectOutputStream stream) {\n+                    }\n+                };\n+            }\n+\n+            private IStatefulBolt makeDummyStatefulBolt() {", "originalCommit": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2MDE3MA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r470060170", "bodyText": "Replaced with TestWordSpout and TestWordCounter", "author": "bipinprasad", "createdAt": "2020-08-13T16:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MjYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mjk4MQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r469562981", "bodyText": "This seems repeating the log message in validateConfs, and can be probably removed.", "author": "Ethanlm", "createdAt": "2020-08-12T21:41:06Z", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));\n+            return ret;\n+        }\n+\n+        Set<String> unreachable = new HashSet<>(edgesOut.keySet());\n+        topology.get_spouts().forEach((spoutId, spout)  -> {\n+            Stack<String> dfsStack = new Stack<>();\n+            dfsStack.push(spoutId);\n+            Set<String> seen = new HashSet<>();\n+            seen.add(spoutId);\n+            findComponentCyclesRecursion(dfsStack, edgesOut, seen, ret);\n+            unreachable.removeAll(seen);\n+        });\n+\n+        // warning about unreachable components\n+        if (!unreachable.isEmpty()) {\n+            LOG.warn(\"Topology {} contains unreachable components \\\"{}\\\"\", topoId, String.join(\",\", unreachable));\n+        }\n+\n+        // detected cycles\n+        if (!ret.isEmpty()) {\n+            LOG.error(\"Topology {} contains cycles {}\", topoId,", "originalCommit": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyMjkwMQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r470122901", "bodyText": "removed", "author": "bipinprasad", "createdAt": "2020-08-13T17:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2Mjk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MzEzOA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r469563138", "bodyText": "Looks like this needs to be tmp = tmp.subList(prevIdx, tmp.size()); otherwise the result will not be accurate", "author": "Ethanlm", "createdAt": "2020-08-12T21:41:29Z", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());", "originalCommit": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2MTU2OA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r470061568", "bodyText": "fixed", "author": "bipinprasad", "createdAt": "2020-08-13T16:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU2MzEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NzMyMA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r469577320", "bodyText": "I haven't read the complete implementation of findComponentCycles. But there seems to be an issue on detecting complex cycles.\n tb = new TopologyBuilder();\n                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n                    tb.setSpout(\"spout2\", new TestWordSpout(), 10);\n                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\").shuffleGrouping(\"spout2\");\n\nThe result ( is\n contains cycles bolt3,bolt4 ; spout2,bolt4,bolt3\n\nspout2 shouldn't be in the result. Please let me know if I am doing anything wrong.", "author": "Ethanlm", "createdAt": "2020-08-12T22:16:21Z", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,131 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for spouts and bolts in a topology. The mapping contains ids of the spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of out bound edges of SpoutIds/BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_spouts() != null) {\n+            topology.get_spouts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle detected\n+                List<String> cycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    cycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    cycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        tmp.subList(prevIdx, tmp.size());\n+                    }\n+                    tmp.add(compId2);\n+                    cycle.addAll(tmp);\n+                }\n+                cycles.add(cycle);\n+                edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                continue;\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {", "originalCommit": "0139cbfbbf6558efa23887e41dc63d80ce4a1e9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA3NDM3Mw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r470074373", "bodyText": "This specific result will be fixed by the tmp.sublist.\nHowever, I am wondering if this will misclassify diamonds as a cycle (undesired), in which case, the code should be changed to require that #1974 be true for cycles.", "author": "bipinprasad", "createdAt": "2020-08-13T16:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NzMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyNzIxMg==", "url": "https://github.com/apache/storm/pull/3322#discussion_r470127212", "bodyText": "Added the complex cycle(s) test case. Exclude diamond connections from loops.", "author": "bipinprasad", "createdAt": "2020-08-13T17:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NzMyMA=="}], "type": "inlineReview"}, {"oid": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "url": "https://github.com/apache/storm/commit/91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "message": "[STORM-3685] Exclude diamonds and add a complex cycle(s) test case.", "committedDate": "2020-08-13T17:51:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4OTYyMw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480389623", "bodyText": "Should this be \"Three Level\" component hierarchy?", "author": "Ethanlm", "createdAt": "2020-08-31T20:46:36Z", "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",", "originalCommit": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MTc2NA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480451764", "bodyText": "Yes. Fixed.", "author": "bipinprasad", "createdAt": "2020-08-31T22:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4OTYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MTAyOQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480391029", "bodyText": "The description seems incorrect.\nIt should be\n // (S1 -> B1 -> B2 -> B3 -> B4 <- S2), (B4 -> B3), (B4 -> B1)", "author": "Ethanlm", "createdAt": "2020-08-31T20:49:40Z", "path": "storm-client/test/jvm/org/apache/storm/utils/UtilsTest.java", "diffHunk": "@@ -237,4 +247,167 @@ public void checkVersionInfo() {\n         assertNotNull(found);\n         assertEquals(key, found.getVersion());\n     }\n+\n+    @Test\n+    public void testFindComponentCycles() {\n+        class CycleDetectionScenario {\n+            final String testName;\n+            final String testDescription;\n+            final StormTopology topology;\n+            final int expectedCycles;\n+\n+            CycleDetectionScenario() {\n+                testName = \"dummy\";\n+                testDescription = \"dummy test\";\n+                topology = null;\n+                expectedCycles = 0;\n+            }\n+\n+            CycleDetectionScenario(String testName, String testDescription, StormTopology topology, int expectedCycles) {\n+                this.testName = testName.replace(' ', '-');\n+                this.testDescription = testDescription;\n+                this.topology = topology;\n+                this.expectedCycles = expectedCycles;\n+            }\n+\n+            public List<CycleDetectionScenario> createTestScenarios() {\n+                List<CycleDetectionScenario> ret = new ArrayList<>();\n+                int testNo = 0;\n+                CycleDetectionScenario s;\n+                TopologyBuilder tb;\n+\n+                // Base case\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    s = new CycleDetectionScenario(String.format(\"(%d) Base\", testNo),\n+                            \"Three level component hierarchy with no loops\",\n+                            tb.createTopology(),\n+                            0);\n+                    ret.add(s);\n+                }\n+\n+                // single loop with one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3  (also connect bolt3 to spout 1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt3\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // single loop with three bolts\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) One Loop\", testNo),\n+                            \"Four level component hierarchy with 1 cycle in bolt3,bolt4,bolt5\",\n+                            tb.createTopology(),\n+                            1));\n+                }\n+\n+                // two loops with three bolts, and one bolt\n+                {\n+                    testNo++;\n+                    tb = new TopologyBuilder();\n+                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n+                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\");\n+                    tb.setBolt(\"bolt11\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt12\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n+                    tb.setBolt(\"bolt21\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    tb.setBolt(\"bolt22\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\");\n+                    // loop bolt 3 -> 4 -> 5 -> 3 (also connect bolt3 to spout1)\n+                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt5\");\n+                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"bolt3\");\n+                    tb.setBolt(\"bolt5\", new TestWordCounter(), 10).shuffleGrouping(\"bolt4\");\n+                    // loop bolt 6  (also connect bolt6 to spout 1)\n+                    tb.setBolt(\"bolt6\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt6\");\n+                    ret.add(new CycleDetectionScenario(String.format(\"(%d) Two Loops\", testNo),\n+                            \"Four level component hierarchy with 2 cycles in bolt3,bolt4,bolt5 and bolt6\",\n+                            tb.createTopology(),\n+                            2));\n+                }\n+\n+                // complex cycle\n+                {\n+                    // (S1 -> B1 -> B2 -> B3 -> B4 <- S2), (B4 -> B3), (B4 -> B2)", "originalCommit": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ1MjU4Nw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480452587", "bodyText": "fixed", "author": "bipinprasad", "createdAt": "2020-08-31T22:54:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDgyNA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480394824", "bodyText": "With a slightly modified test case,\n                    tb.setSpout(\"spout1\", new TestWordSpout(), 10);\n                    tb.setSpout(\"spout2\", new TestWordSpout(), 10);\n                    tb.setBolt(\"bolt1\", new TestWordCounter(), 10).shuffleGrouping(\"spout1\").shuffleGrouping(\"bolt4\").shuffleGrouping(\"bolt2\");\n                    tb.setBolt(\"bolt2\", new TestWordCounter(), 10).shuffleGrouping(\"bolt1\");\n                    tb.setBolt(\"bolt3\", new TestWordCounter(), 10).shuffleGrouping(\"bolt2\").shuffleGrouping(\"bolt4\");\n                    tb.setBolt(\"bolt4\", new TestWordCounter(), 10).shuffleGrouping(\"spout2\");\n\nI am seeing\njava.lang.NullPointerException\n\tat org.apache.storm.utils.Utils.findComponentCyclesRecursion(Utils.java:1961)\n\tat org.apache.storm.utils.Utils.findComponentCyclesRecursion(Utils.java:1981)\n\nI am reading the code to try to figure out why", "author": "Ethanlm", "createdAt": "2020-08-31T20:57:28Z", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {", "originalCommit": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwODA5Nw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480408097", "bodyText": "Fixed the NPE. But now I will add to randomly generate some topologies. To make sure that that this code is well exercised.", "author": "bipinprasad", "createdAt": "2020-08-31T21:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyNTY1MQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480425651", "bodyText": "Sounds good. I would add this test case too.", "author": "Ethanlm", "createdAt": "2020-08-31T22:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NzMxNw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480397317", "bodyText": "Comments  here and below need to be updated since the mapping only contains bolts.", "author": "Ethanlm", "createdAt": "2020-08-31T21:02:31Z", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.", "originalCommit": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NjYzNw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480446637", "bodyText": "Key can be bolt or spout. Value contains bolt ids only.", "author": "bipinprasad", "createdAt": "2020-08-31T22:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NzMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIxMDEwOQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r481210109", "bodyText": "okay", "author": "Ethanlm", "createdAt": "2020-09-01T15:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NzMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMTEwNg==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480401106", "bodyText": "This doesn't mean it has cycles. We should separate them.", "author": "Ethanlm", "createdAt": "2020-08-31T21:10:44Z", "path": "storm-client/src/jvm/org/apache/storm/utils/Utils.java", "diffHunk": "@@ -1907,4 +1909,117 @@ private void readArchive(ZipFile zipFile) throws IOException {\n             }\n         }\n     }\n+\n+    /**\n+     * Create a map of forward edges for bolts in a topology. Note that spouts can be source but not a target in\n+     * the edge. The mapping contains ids of spouts and bolts.\n+     *\n+     * @param topology StormTopology to examine.\n+     * @return a map with entry for each SpoutId/BoltId to a set of outbound edges of BoltIds.\n+     */\n+    private static Map<String, Set<String>> getStormTopologyForwardGraph(StormTopology topology) {\n+        Map<String, Set<String>> edgesOut = new HashMap<>();\n+\n+        if (topology.get_bolts() != null) {\n+            topology.get_bolts().entrySet().forEach(entry -> {\n+                if (!Utils.isSystemId(entry.getKey())) {\n+                    entry.getValue().get_common().get_inputs().forEach((k, v) -> {\n+                        edgesOut.computeIfAbsent(k.get_componentId(), x -> new HashSet<>()).add(entry.getKey());\n+                    });\n+                }\n+            });\n+        }\n+        return edgesOut;\n+    }\n+\n+    /**\n+     * Use recursive descent to detect cycles. This is a Depth First recursion. Component Cycle is recorded when encountered.\n+     * In addition, the last link in the cycle is removed to avoid re-detecting same cycle/subcycle.\n+     *\n+     * @param stack used for recursion.\n+     * @param edgesOut outbound edge connections, modified when cycle is detected.\n+     * @param seen keeps track of component ids that have already been seen.\n+     * @param cycles list of cycles seen so far.\n+     */\n+    private static void findComponentCyclesRecursion(\n+            Stack<String> stack, Map<String, Set<String>> edgesOut, Set<String> seen, List<List<String>> cycles) {\n+        if (stack.isEmpty()) {\n+            return;\n+        }\n+        String compId1 = stack.peek();\n+        if (!edgesOut.containsKey(compId1) || edgesOut.get(compId1).isEmpty()) {\n+            stack.pop();\n+            return;\n+        }\n+        Set<String> children = new HashSet<>(edgesOut.get(compId1));\n+        for (String compId2: children) {\n+            if (seen.contains(compId2)) {\n+                // cycle/diamond detected\n+                List<String> possibleCycle = new ArrayList<>();\n+                if (compId1.equals(compId2)) {\n+                    possibleCycle.add(compId2);\n+                } else if (edgesOut.get(compId2).contains(compId1)) {\n+                    possibleCycle.addAll(Arrays.asList(compId1, compId2));\n+                } else {\n+                    List<String> tmp = Collections.list(stack.elements());\n+                    int prevIdx = tmp.indexOf(compId2);\n+                    if (prevIdx >= 0) {\n+                        // cycle (as opposed to diamond)\n+                        tmp = tmp.subList(prevIdx, tmp.size());\n+                        tmp.add(compId2);\n+                        possibleCycle.addAll(tmp);\n+                    }\n+                }\n+                if (!possibleCycle.isEmpty()) {\n+                    cycles.add(possibleCycle);\n+                    edgesOut.get(compId1).remove(compId2); // disconnect this cycle\n+                    continue;\n+                }\n+            }\n+            seen.add(compId2);\n+            stack.push(compId2);\n+            findComponentCyclesRecursion(stack, edgesOut, seen, cycles);\n+        }\n+        stack.pop();\n+    }\n+\n+    /**\n+     * Find and return components cycles in the topology graph when starting from spout.\n+     * Return a list of cycles. Each cycle may consist of one or more components.\n+     * Components that cannot be reached from any of the spouts are ignored.\n+     *\n+     * @return a List of cycles. Each cycle has a list of component names.\n+     *\n+     */\n+    public static List<List<String>> findComponentCycles(StormTopology topology, String topoId) {\n+        List<List<String>> ret = new ArrayList<>();\n+        Map<String, Set<String>> edgesOut = getStormTopologyForwardGraph(topology);\n+        Set<String> allComponentIds = new HashSet<>();\n+        edgesOut.forEach((k, v) -> {\n+            allComponentIds.add(k) ;\n+            allComponentIds.addAll(v);\n+        });\n+\n+        if (topology.get_spouts_size() == 0) {\n+            LOG.error(\"Topology {} does not contain any spouts, cannot traverse graph to determine cycles\", topoId);\n+            ret.add(new ArrayList(edgesOut.keySet()));", "originalCommit": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NDUwNA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480464504", "bodyText": "Changed to return no cycle.", "author": "bipinprasad", "createdAt": "2020-08-31T23:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMTEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r480402134", "bodyText": "I feel like this is not the right place to detect cycles.  We should probably put it in another function, like\nStormCommon.validateBasic\nhttps://git.vzbuilders.com/storm/storm/blob/master/storm-client/src/jvm/org/apache/storm/daemon/StormCommon.java#L156\nor create a new method.", "author": "Ethanlm", "createdAt": "2020-08-31T21:12:52Z", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -233,7 +235,7 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology);\n+        validateConfs(conf, topology, name);", "originalCommit": "91f97dc9160abf36e59636a2bcd5a3d9eccbf75f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0NjA3Mg==", "url": "https://github.com/apache/storm/pull/3322#discussion_r481446072", "bodyText": "Created new method StormCommon.validateCycleFree", "author": "bipinprasad", "createdAt": "2020-09-01T21:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEyMTY1NA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482121654", "bodyText": "Moving it to Utils is also okay, like\nUtils.validateTopologyBlobStoreMap\nUtils.validateTopologyName\netc.\nProbably makes more sense since findComponentCycles is implemented inside Utils.\nAnd we could make Utils.findComponentCycles \"@VisibleForTesting\". So the public method will be only Utils. validateCycleFree and the internal implementation can be changed if we'd like in the future.", "author": "Ethanlm", "createdAt": "2020-09-02T14:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM0Njk2Mw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482346963", "bodyText": "@bipinprasad\nSorry for not being clear at the first comment. What do you think about moving it to Utils?^ Trying to not expose too many public methods.  Also StormCommon is org.apache.storm.daemon.StormCommon. StormSubmitter is completely on client side. I feel like Utils is a better place for this.", "author": "Ethanlm", "createdAt": "2020-09-02T19:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzExMjkzNw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r483112937", "bodyText": "Ok. Will switch.", "author": "bipinprasad", "createdAt": "2020-09-03T16:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5OTg4Mg==", "url": "https://github.com/apache/storm/pull/3322#discussion_r483199882", "bodyText": "Moved from StormCommons to Utils.", "author": "bipinprasad", "createdAt": "2020-09-03T19:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMjEzNA=="}], "type": "inlineReview"}, {"oid": "4117a14089b00e06ad514b4420ed4d4791229d27", "url": "https://github.com/apache/storm/commit/4117a14089b00e06ad514b4420ed4d4791229d27", "message": "[STORM-3685] Fix NPE in a new test and add randomized 100 randomized topologies for cycle detection.", "committedDate": "2020-08-31T22:25:40Z", "type": "commit"}, {"oid": "4a29dacf4b8ffa11d48ea752c9d9180757dbf4fb", "url": "https://github.com/apache/storm/commit/4a29dacf4b8ffa11d48ea752c9d9180757dbf4fb", "message": "[STORM-3685] Missing spouts not signaled as error. Randomize spout/bolt connections counts. Fix topo comments.", "committedDate": "2020-08-31T23:23:08Z", "type": "commit"}, {"oid": "cc7a66d5c3771455926039cce900637b9350e800", "url": "https://github.com/apache/storm/commit/cc7a66d5c3771455926039cce900637b9350e800", "message": "[STORM-3685] Add new method StormCommon.validateCycleFree() and use in StormSubmitter.submitTopologyAs().", "committedDate": "2020-09-01T21:40:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjAwMg==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116002", "bodyText": "Is this used anywhere?", "author": "Ethanlm", "createdAt": "2020-09-02T14:31:35Z", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -51,6 +52,7 @@\n import org.apache.storm.validation.ConfigValidation;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n+import sun.net.ProgressListener;", "originalCommit": "cc7a66d5c3771455926039cce900637b9350e800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIyNTMzNQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482225335", "bodyText": "No. Will remove this.", "author": "bipinprasad", "createdAt": "2020-09-02T17:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116135", "bodyText": "We should remove this", "author": "Ethanlm", "createdAt": "2020-09-02T14:31:46Z", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);\n+            System.out.println(ex.get_msg());", "originalCommit": "cc7a66d5c3771455926039cce900637b9350e800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMDIwOA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482230208", "bodyText": "Did we not want to warn the user when submitting?", "author": "bipinprasad", "createdAt": "2020-09-02T17:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NTY3NA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482255674", "bodyText": "LOG.warn should be sufficient. We don't need System.out.println()", "author": "Ethanlm", "createdAt": "2020-09-02T17:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1ODAwNA==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482258004", "bodyText": "ok. removed sysout.", "author": "bipinprasad", "createdAt": "2020-09-02T17:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482116433", "bodyText": "Will ex already contains ex.get_msg()? If so, we will see repeating messages, which should be avoid.", "author": "Ethanlm", "createdAt": "2020-09-02T14:32:12Z", "path": "storm-client/src/jvm/org/apache/storm/StormSubmitter.java", "diffHunk": "@@ -235,7 +237,14 @@ public static void submitTopologyAs(String name, Map<String, Object> topoConf, S\n         conf.putAll(topoConf);\n         topoConf.putAll(prepareZookeeperAuthentication(conf));\n \n-        validateConfs(conf, topology, name);\n+        validateConfs(conf);\n+\n+        try {\n+            StormCommon.validateCycleFree(topology, name);\n+        } catch (InvalidTopologyException ex) {\n+            LOG.warn(ex.get_msg(), ex);", "originalCommit": "cc7a66d5c3771455926039cce900637b9350e800", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIzMTkyMQ==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482231921", "bodyText": "The constructor seems to imply that the message will not be in the Exception, since the proper super method is not called.", "author": "bipinprasad", "createdAt": "2020-09-02T17:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1NjMzMg==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482256332", "bodyText": "Do you have an output example that I can take a look?", "author": "Ethanlm", "createdAt": "2020-09-02T17:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI2MTcwMg==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482261702", "bodyText": "InvalidTopologyException constructor does not call Exception.super(msg): https://github.com/apache/storm/blob/master/storm-client/src/jvm/org/apache/storm/generated/InvalidTopologyException.java#L111\nhence, its msg variable is not available in the Exception.getMessage()", "author": "bipinprasad", "createdAt": "2020-09-02T17:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM0NjA4Nw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r482346087", "bodyText": "Right. So the log will look like\n19:22:23.981 [main] WARN  o.a.s.StormSubmitter - Topology wc contains cycles in components \"count,split\"\norg.apache.storm.generated.InvalidTopologyException: null\n\tat org.apache.storm.daemon.StormCommon.validateCycleFree(StormCommon.java:596) ~[storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.StormSubmitter.submitTopologyAs(StormSubmitter.java:244) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.StormSubmitter.submitTopology(StormSubmitter.java:214) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.StormSubmitter.submitTopology(StormSubmitter.java:177) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.topology.ConfigurableTopology.submit(ConfigurableTopology.java:119) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.starter.WordCountTopology.run(WordCountTopology.java:58) [storm-starter-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.topology.ConfigurableTopology.start(ConfigurableTopology.java:68) [storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\tat org.apache.storm.starter.WordCountTopology.main(WordCountTopology.java:36) [storm-starter-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\nWe can probably use WrappedInvalidTopologyException inside validateCycleFree method so the stacktrace will make more sense. What do you think?\nIt will be like\norg.apache.storm.utils.WrappedInvalidTopologyException: Topology wc2 contains cycles in components \"count,split\"\n\tat org.apache.storm.daemon.StormCommon.validateCycleFree(StormCommon.java:596) ~[storm-client-2.3.0-SNAPSHOT.jar:2.3.0-SNAPSHOT]\n\t.....", "author": "Ethanlm", "createdAt": "2020-09-02T19:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5OTUzNw==", "url": "https://github.com/apache/storm/pull/3322#discussion_r483199537", "bodyText": "That is better than a scary \"null\" in the stack trace.\nChanged.", "author": "bipinprasad", "createdAt": "2020-09-03T19:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjExNjQzMw=="}], "type": "inlineReview"}, {"oid": "77e79fc25c1120d2e368c24e0fbb729779c35c94", "url": "https://github.com/apache/storm/commit/77e79fc25c1120d2e368c24e0fbb729779c35c94", "message": "[STORM-3685] Remove unused imports and unused private static method; fix @throws tag; remove superfluous sysout..", "committedDate": "2020-09-02T18:48:28Z", "type": "commit"}, {"oid": "c34bf1b4a02035e2af94f7f37ef6dc71a635f347", "url": "https://github.com/apache/storm/commit/c34bf1b4a02035e2af94f7f37ef6dc71a635f347", "message": "[STORM-3685] Move validateCycleFree() to Utils and throw WrappedInvalidTopologyException.", "committedDate": "2020-09-03T19:08:05Z", "type": "commit"}]}