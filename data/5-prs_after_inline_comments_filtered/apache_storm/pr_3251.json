{"pr_number": 3251, "pr_title": "STORM-3623 executors should only report their metrics for V2 metric tick", "pr_createdAt": "2020-04-17T14:55:17Z", "pr_url": "https://github.com/apache/storm/pull/3251", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNTcyOA==", "url": "https://github.com/apache/storm/pull/3251#discussion_r411805728", "bodyText": "This is way cleaner.", "author": "kishorvpatil", "createdAt": "2020-04-21T01:38:57Z", "path": "storm-client/src/jvm/org/apache/storm/executor/Executor.java", "diffHunk": "@@ -339,47 +342,106 @@ private void addV2Metrics(List<IMetricsConsumer.DataPoint> dataPoints) {\n             return;\n         }\n         StormMetricRegistry stormMetricRegistry = workerData.getMetricRegistry();\n-        for (Map.Entry<String, Gauge> entry : stormMetricRegistry.registry().getGauges().entrySet()) {\n-            String name = entry.getKey();\n-            Object v = entry.getValue().getValue();\n-            if (v instanceof Number) {\n-                IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(name, v);\n-                dataPoints.add(dataPoint);\n-            } else {\n-                LOG.warn(\"Cannot report {}, its value is not a Number {}\", name, v);\n+        Map<String, Metric> metrics = stormMetricRegistry.getExecutorMetrics(this);", "originalCommit": "2de00549174c6fd206277e1f38fd71d8de481144", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNzkyNQ==", "url": "https://github.com/apache/storm/pull/3251#discussion_r411807925", "bodyText": "should StormMetricRegistry expose getGauges(), getCounters(), getMeters(), getHistograms and getTimers. i.e similar to com.codahale.metrics.MetricRegistry\nI would actually recommend, StormMetricRegistry extending com.codahale.metrics.MetricRegistry", "author": "kishorvpatil", "createdAt": "2020-04-21T01:45:30Z", "path": "storm-client/src/jvm/org/apache/storm/executor/Executor.java", "diffHunk": "@@ -339,47 +342,106 @@ private void addV2Metrics(List<IMetricsConsumer.DataPoint> dataPoints) {\n             return;\n         }\n         StormMetricRegistry stormMetricRegistry = workerData.getMetricRegistry();\n-        for (Map.Entry<String, Gauge> entry : stormMetricRegistry.registry().getGauges().entrySet()) {\n-            String name = entry.getKey();\n-            Object v = entry.getValue().getValue();\n-            if (v instanceof Number) {\n-                IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(name, v);\n-                dataPoints.add(dataPoint);\n-            } else {\n-                LOG.warn(\"Cannot report {}, its value is not a Number {}\", name, v);\n+        Map<String, Metric> metrics = stormMetricRegistry.getExecutorMetrics(this);\n+        processGauges(metrics, dataPoints);\n+        processCounters(metrics, dataPoints);\n+        processHistograms(metrics, dataPoints);\n+        processMeters(metrics, dataPoints);\n+        processTimers(metrics, dataPoints);\n+\n+        // at this point, we should have no metrics left to process\n+        if (!metrics.isEmpty()) {\n+            for (Map.Entry<String, Metric> entry : metrics.entrySet()) {\n+                LOG.warn(\"Unable to process metric {} {}\", entry.getKey(), entry.getValue());\n             }\n         }\n-        for (Map.Entry<String, Counter> entry : stormMetricRegistry.registry().getCounters().entrySet()) {\n-            Object value = entry.getValue().getCount();\n-            IMetricsConsumer.DataPoint dataPoint = new IMetricsConsumer.DataPoint(entry.getKey(), value);\n-            dataPoints.add(dataPoint);\n+    }\n+\n+    private void processGauges(Map<String, Metric> metrics, List<IMetricsConsumer.DataPoint> dataPoints) {\n+        Set<String> processedMetrics = new HashSet<>();", "originalCommit": "2de00549174c6fd206277e1f38fd71d8de481144", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2MTk2NQ==", "url": "https://github.com/apache/storm/pull/3251#discussion_r412261965", "bodyText": "We would need something like getExecutorGauges().  I think it's overkill, but I can add it if desired.\nI don't think extending com.codahale.metrics.MetricRegistry is a good idea.  We should enforce API that tie registering metrics with the taskids so we can track.  What benefit would we get?", "author": "agresch", "createdAt": "2020-04-21T14:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNzkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxODM3NA==", "url": "https://github.com/apache/storm/pull/3251#discussion_r412318374", "bodyText": "Will add API for getGauges() etc. with a taskId filter.", "author": "agresch", "createdAt": "2020-04-21T16:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgwNzkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxMTQ3Nw==", "url": "https://github.com/apache/storm/pull/3251#discussion_r413811477", "bodyText": "instead of going through every metric and check if it's a gauge, I think we probably just need separate maps for different metric types.", "author": "Ethanlm", "createdAt": "2020-04-23T13:50:34Z", "path": "storm-client/src/jvm/org/apache/storm/metrics2/StormMetricRegistry.java", "diffHunk": "@@ -35,38 +45,154 @@\n     \n     private final MetricRegistry registry = new MetricRegistry();\n     private final List<StormReporter> reporters = new ArrayList<>();\n+    private final ConcurrentMap<Integer, Map<String, Metric>> taskIdMetrics = new ConcurrentHashMap<>();\n     private String hostName = null;\n \n     public <T> SimpleGauge<T> gauge(\n         T initialValue, String name, String topologyId, String componentId, Integer taskId, Integer port) {\n         String metricName = metricName(name, topologyId, componentId, taskId, port);\n-        return (SimpleGauge<T>) registry.gauge(metricName, () -> new SimpleGauge<>(initialValue));\n+        SimpleGauge<T> gauge = (SimpleGauge<T>) registry.gauge(metricName, () -> new SimpleGauge<>(initialValue));\n+        saveMetricTaskIdMapping(taskId, metricName, gauge);\n+        return gauge;\n+    }\n+\n+    public <T> Gauge<T> gauge(String name, Gauge<T> gauge, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        gauge = registry.register(metricName, gauge);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, gauge);\n+        return gauge;\n     }\n \n     public JcMetrics jcMetrics(String name, String topologyId, String componentId, Integer taskId, Integer port) {\n-        return new JcMetrics(\n-            gauge(0L, name + \"-capacity\", topologyId, componentId, taskId, port),\n-            gauge(0L, name + \"-population\", topologyId, componentId, taskId, port)\n-        );\n+        SimpleGauge<Long> capacityGauge = gauge(0L, name + \"-capacity\", topologyId, componentId, taskId, port);\n+        SimpleGauge<Long> populationGauge = gauge(0L, name + \"-population\", topologyId, componentId, taskId, port);\n+        return new JcMetrics(capacityGauge, populationGauge);\n     }\n \n     public Meter meter(String name, WorkerTopologyContext context, String componentId, Integer taskId, String streamId) {\n         String metricName = metricName(name, context.getStormId(), componentId, streamId, taskId, context.getThisWorkerPort());\n-        return registry.meter(metricName);\n+        Meter meter = registry.meter(metricName);\n+        saveMetricTaskIdMapping(taskId, metricName, meter);\n+        return meter;\n+    }\n+\n+    public Meter meter(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Meter meter = registry.meter(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, meter);\n+        return meter;\n     }\n \n     public Counter counter(String name, WorkerTopologyContext context, String componentId, Integer taskId, String streamId) {\n         String metricName = metricName(name, context.getStormId(), componentId, streamId, taskId, context.getThisWorkerPort());\n-        return registry.counter(metricName);\n+        Counter counter = registry.counter(metricName);\n+        saveMetricTaskIdMapping(taskId, metricName, counter);\n+        return counter;\n     }\n \n     public Counter counter(String name, String topologyId, String componentId, Integer taskId, Integer workerPort, String streamId) {\n         String metricName = metricName(name, topologyId, componentId, streamId, taskId, workerPort);\n-        return registry.counter(metricName);\n+        Counter counter = registry.counter(metricName);\n+        saveMetricTaskIdMapping(taskId, metricName, counter);\n+        return counter;\n     }\n-    \n-    public MetricRegistry registry() {\n-        return registry;\n+\n+    public Counter counter(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Counter counter = registry.counter(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, counter);\n+        return counter;\n+    }\n+\n+    public void metricSet(String prefix, MetricSet set, TopologyContext context) {\n+        String baseName = metricName(prefix, context);\n+        // Instead of registering the metrics as a set, register them individually.\n+        // This allows fetching the individual metrics by type (getTaskGauges())\n+        // to work as expected.\n+        for (Map.Entry<String, Metric> entry : set.getMetrics().entrySet()) {\n+            String metricName = baseName + \".\" + entry.getKey();\n+            Metric metric = registry.register(metricName, entry.getValue());\n+            saveMetricTaskIdMapping(context.getThisTaskId(), metricName, metric);\n+        }\n+    }\n+\n+    public Timer timer(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Timer timer = registry.timer(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, timer);\n+        return timer;\n+    }\n+\n+    public Histogram histogram(String name, TopologyContext context) {\n+        String metricName = metricName(name, context);\n+        Histogram histogram = registry.histogram(metricName);\n+        saveMetricTaskIdMapping(context.getThisTaskId(), metricName, histogram);\n+        return histogram;\n+    }\n+\n+    private void saveMetricTaskIdMapping(Integer taskId, String name, Metric metric) {\n+        Map<String, Metric> metrics = taskIdMetrics.computeIfAbsent(taskId, (tid) -> new HashMap<>());\n+        metrics.put(name, metric);\n+    }\n+\n+    public Map<String, Gauge> getTaskGauges(int taskId) {\n+        Map<String, Gauge> taskGaugeMap = new HashMap<>();\n+        Collection<Gauge> gauges = registry.getGauges().values();\n+        Map<String, Metric> taskMetrics = taskIdMetrics.getOrDefault(taskId, Collections.emptyMap());\n+        for (Map.Entry<String, Metric> entry : taskMetrics.entrySet()) {\n+            if (gauges.contains(entry.getValue())) {", "originalCommit": "d52872844735bac3d14b5aada74ffbbdc042bf24", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "url": "https://github.com/apache/storm/commit/6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "message": "STORM-3623 executors should only report their metrics for V2 metric tick", "committedDate": "2020-04-27T21:43:41Z", "type": "commit"}, {"oid": "6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "url": "https://github.com/apache/storm/commit/6976624228386c25e9ac6dd2b8ef87a9deeb1ad9", "message": "STORM-3623 executors should only report their metrics for V2 metric tick", "committedDate": "2020-04-27T21:43:41Z", "type": "forcePushed"}]}