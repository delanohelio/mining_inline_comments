{"pr_number": 3644, "pr_title": "HHH-14318 Work on @JoinFormula and @JoinColumnOrFormula support", "pr_createdAt": "2020-11-12T22:54:34Z", "pr_url": "https://github.com/hibernate/hibernate-orm/pull/3644", "timeline": [{"oid": "8649534f34d1918723cd399e0717dcf6b4530957", "url": "https://github.com/hibernate/hibernate-orm/commit/8649534f34d1918723cd399e0717dcf6b4530957", "message": "HHH-14318 Work on @JoinFormula and @JoinColumnOrFormula support", "committedDate": "2020-11-13T11:08:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NDAzMg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522944032", "bodyText": "Why this change? MutableInteger was added to explicitly replace such uses of AtomicInteger", "author": "sebersole", "createdAt": "2020-11-13T13:18:13Z", "path": "hibernate-core/src/main/java/org/hibernate/boot/model/TypeDefinition.java", "diffHunk": "@@ -50,7 +51,7 @@\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class TypeDefinition implements Serializable {\n-\tpublic static final MutableInteger NAME_COUNTER = new MutableInteger();\n+\tpublic static final AtomicInteger NAME_COUNTER = new AtomicInteger();", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3MjEzMw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523072133", "bodyText": "Since this is static and thus accessible by multiple threads, this must use a thread safe data structure like AtomicInteger.", "author": "beikov", "createdAt": "2020-11-13T16:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NDAzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE2MzgwMg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523163802", "bodyText": "Ah, missed the static.. carry on.", "author": "sebersole", "createdAt": "2020-11-13T19:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NDAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NTM4Mw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522945383", "bodyText": "Could we stick with the standard code style for multi-line statements?  Or at least one of the 2 prevalent ones?", "author": "sebersole", "createdAt": "2020-11-13T13:20:47Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/Bindable.java", "diffHunk": "@@ -78,6 +79,21 @@ default void visitJdbcTypes(\n \t\tthrow new NotYetImplementedFor6Exception( getClass() );\n \t}\n \n+\tdefault void visitJdbcTypes(\n+\t\t\tClause clause,\n+\t\t\tTypeConfiguration typeConfiguration,\n+\t\t\tIndexedConsumer<JdbcMapping> action) {\n+\t\tvisitJdbcTypes( new Consumer<JdbcMapping>() {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNzY3Mg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523027672", "bodyText": "Also, why not just switch everything to use this method rather than the form accepting a Consumer?", "author": "sebersole", "createdAt": "2020-11-13T15:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0NjQwNQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522946405", "bodyText": "I think both table and JdbcMapping make sense as well.  Would also allow us to clean up some of the functional interfaces around column handling", "author": "sebersole", "createdAt": "2020-11-13T13:22:40Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMapping.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+/**\n+ * A column mapping.\n+ *\n+ * @author Christian Beikov\n+ */\n+public interface ColumnMapping {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0ODEyOQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522948129", "bodyText": "I'd rather leave table expression off here...  While today embeddable values need to map to a single table, so far I have been working in 6 under the assumption that we want to start allowing compositions across tables.  We cannot fully make that transition until we can pull \"writing\" under this new mapping model, but as much as possible let's design the mapping model with this in mind.\nAnd of course the is no notion of a JdbcMapping for multiple columns, unless we start considering complex SQL types (arrays, etc)", "author": "sebersole", "createdAt": "2020-11-13T13:25:47Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ColumnMappings.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.hibernate.mapping.IndexedConsumer;\n+\n+/**\n+ * A container for multiple column mappings.\n+ *\n+ * @author Christian Beikov\n+ */\n+public interface ColumnMappings {\n+\t// todo: table expression? jdbc mapping?", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0OTM1Mw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522949353", "bodyText": "\ud83d\udc4d", "author": "sebersole", "createdAt": "2020-11-13T13:28:09Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableMappingType.java", "diffHunk": "@@ -311,17 +310,13 @@ public CascadeStyle getCascadeStyle() {\n \t\t\t}\n \t\t\telse if ( subtype instanceof CompositeType ) {\n \t\t\t\tfinal CompositeType subCompositeType = (CompositeType) subtype;\n-\t\t\t\tfinal int columnSpan = subCompositeType.getColumnSpan( sessionFactory );\n-\n-\t\t\t\tfinal List<String> customReadExpressions = new ArrayList<>( columnSpan );\n-\t\t\t\tfinal List<String> customWriteExpressions = new ArrayList<>( columnSpan );\n-\n-\t\t\t\tfinal Iterator<Selectable> columnIterator = bootDescriptor.getColumnIterator();\n-\t\t\t\twhile ( columnIterator.hasNext() ) {\n-\t\t\t\t\tfinal Selectable selectable = columnIterator.next();\n-\t\t\t\t\tcustomReadExpressions.add( selectable.getCustomReadExpression() );\n-\t\t\t\t\tcustomWriteExpressions.add( selectable.getCustomWriteExpression() );\n-\t\t\t\t}\n+\t\t\t\tfinal ColumnMappings subMappings = ColumnMappingsImpl.from(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk0OTgxMg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522949812", "bodyText": "Again with the code style here and below", "author": "sebersole", "createdAt": "2020-11-13T13:29:06Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ForeignKeyDescriptor.java", "diffHunk": "@@ -61,7 +61,59 @@ default void visitColumns(ColumnConsumer consumer) {\n \n \tvoid visitReferringColumns(ColumnConsumer consumer);\n \n+\tdefault void visitReferringColumns(IndexedColumnConsumer consumer) {\n+\t\tvisitReferringColumns( new ColumnConsumer() {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk1MDMyMQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522950321", "bodyText": "Perhaps both this and a IndexedColumnMappingConsumer make sense?  If the target already has ColumnMappings, imo it makes sense to allow a consumer to access the aggregation.", "author": "sebersole", "createdAt": "2020-11-13T13:30:04Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/IndexedColumnConsumer.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+/**\n+ * Consumer used to visit columns for a given model part\n+ *\n+ * @author Steve Ebersole\n+ */\n+@FunctionalInterface\n+public interface IndexedColumnConsumer {\n+\tvoid accept(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjk1MjI1Mg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r522952252", "bodyText": "Similar question regarding ColumnConsumer and IndexedColumnConsumer... why not just pass the ColumnMapping rather than each of its aggregated values individually?", "author": "sebersole", "createdAt": "2020-11-13T13:33:48Z", "path": "hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java", "diffHunk": "@@ -917,9 +917,8 @@ private QuerySpec generateSubSelect(\n \n \t\tfinal SqlExpressionResolver sqlExpressionResolver = creationState.getSqlExpressionResolver();\n \n-\t\tfinal MutableInteger count = new MutableInteger();\n \t\tfkDescriptor.visitTargetColumns(\n-\t\t\t\t(table, column, isFormula, customReadExpr, customWriteExpr, jdbcMapping) -> {\n+\t\t\t\t(valuesPosition, table, column, isFormula, customReadExpr, customWriteExpr, jdbcMapping) -> {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzMTgwMw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523031803", "bodyText": "\ud83d\udc4d", "author": "sebersole", "createdAt": "2020-11-13T15:41:22Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableValuedModelPart.java", "diffHunk": "@@ -38,14 +36,7 @@\n \t */\n \tString getContainingTableExpression();\n \n-\t/**\n-\t * The column expressions (column name or formula) to which this embedded value\n-\t * is mapped\n-\t */\n-\tList<String> getMappedColumnExpressions();\n-\n-\tList<String> getCustomReadExpressions();\n-\tList<String> getCustomWriteExpressions();\n+\tColumnMappings getColumnMappings();", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzI4NA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523037284", "bodyText": "\ud83d\udc4d", "author": "sebersole", "createdAt": "2020-11-13T15:49:50Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/MappingModelHelper.java", "diffHunk": "@@ -33,10 +33,7 @@ public static Expression buildColumnReferenceExpression(\n \t\t\tif ( sqlExpressionResolver == null ) {\n \t\t\t\treturn new ColumnReference(\n \t\t\t\t\t\tbasicPart.getContainingTableExpression(),\n-\t\t\t\t\t\tbasicPart.getMappedColumnExpression(),\n-\t\t\t\t\t\tbasicPart.isMappedColumnExpressionFormula(),\n-\t\t\t\t\t\tbasicPart.getCustomReadExpression(),\n-\t\t\t\t\t\tbasicPart.getCustomWriteExpression(),\n+\t\t\t\t\t\tbasicPart,", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzNzYxMA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523037610", "bodyText": "Multi-line code style", "author": "sebersole", "createdAt": "2020-11-13T15:50:19Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/ModelPart.java", "diffHunk": "@@ -98,5 +98,31 @@ default void visitColumns(ColumnConsumer consumer) {\n \n \t}\n \n+\tdefault void visitColumns(IndexedColumnConsumer consumer) {\n+\t\tvisitColumns( new ColumnConsumer() {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAzODQ0Ng==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523038446", "bodyText": "Multi-line code style", "author": "sebersole", "createdAt": "2020-11-13T15:51:40Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/ColumnMappingsImpl.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping.internal;\n+\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import org.hibernate.dialect.Dialect;\n+import org.hibernate.internal.util.collections.ArrayHelper;\n+import org.hibernate.internal.util.collections.CollectionHelper;\n+import org.hibernate.mapping.Component;\n+import org.hibernate.mapping.IndexedConsumer;\n+import org.hibernate.mapping.Selectable;\n+import org.hibernate.mapping.Value;\n+import org.hibernate.metamodel.mapping.ColumnConsumer;\n+import org.hibernate.metamodel.mapping.ColumnMappings;\n+import org.hibernate.metamodel.mapping.IndexedColumnConsumer;\n+import org.hibernate.metamodel.mapping.JdbcMapping;\n+import org.hibernate.query.sqm.function.SqmFunctionRegistry;\n+\n+/**\n+ * @author Christian Beikov\n+ */\n+public class ColumnMappingsImpl implements ColumnMappings {\n+\n+\tprivate final String[] columnExpressions;\n+\tprivate final String[] customReadExpressions;\n+\tprivate final String[] customWriteExpressions;\n+\tprivate final boolean[] mappedColumnExpressionFormula;\n+\n+\tpublic ColumnMappingsImpl(\n+\t\t\tString[] columnExpressions,\n+\t\t\tString[] customReadExpressions,\n+\t\t\tString[] customWriteExpressions,\n+\t\t\tboolean[] mappedColumnExpressionFormula) {\n+\t\tthis.columnExpressions = columnExpressions;\n+\t\tthis.customReadExpressions = customReadExpressions;\n+\t\tthis.customWriteExpressions = customWriteExpressions;\n+\t\tthis.mappedColumnExpressionFormula = mappedColumnExpressionFormula;\n+\t}\n+\n+\tpublic static ColumnMappings from(Component component, Dialect dialect, SqmFunctionRegistry sqmFunctionRegistry) {\n+\t\treturn from( component::forEachColumn, component.getPropertySpan(), dialect, sqmFunctionRegistry );\n+\t}\n+\n+\tpublic static ColumnMappings from(Value value, Dialect dialect, SqmFunctionRegistry sqmFunctionRegistry) {\n+\t\tif ( value instanceof Component ) {\n+\t\t\treturn from( (Component) value, dialect, sqmFunctionRegistry );\n+\t\t}\n+\t\treturn from( consumer -> {\n+\t\t\tIterator<Selectable> columnIterator = value.getColumnIterator();\n+\t\t\tint columnIndex = 0;\n+\t\t\twhile ( columnIterator.hasNext() ) {\n+\t\t\t\tconsumer.accept( columnIndex, columnIterator.next() );\n+\t\t\t\tcolumnIndex++;\n+\t\t\t}\n+\t\t}, value.getColumnSpan(), dialect, sqmFunctionRegistry );\n+\t}\n+\n+\tprivate static ColumnMappings from(\n+\t\t\tfinal Consumer<IndexedConsumer<Selectable>> consumer,\n+\t\t\tfinal int propertySpan,\n+\t\t\tfinal Dialect dialect,\n+\t\t\tfinal SqmFunctionRegistry sqmFunctionRegistry) {\n+\t\tfinal List<String> columnExpressions = CollectionHelper.arrayList( propertySpan );\n+\t\tfinal List<String> customReadExpressions = CollectionHelper.arrayList( propertySpan );\n+\t\tfinal List<String> customWriteExpressions = CollectionHelper.arrayList( propertySpan );\n+\t\tfinal List<Boolean> isFormulas = CollectionHelper.arrayList( propertySpan );\n+\n+\t\tconsumer.accept( (index, selectable) -> {", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NTYyNQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523045625", "bodyText": "I'm tempted to say that ColumnReference should accept the ColumnMapping rather than the individual pieces.  I understand you probably chose that because it matches the existing contracts.\nBut this is point I brought up in regards to model parts accepting a ColumnConsumer, but that really a ColumnMappingConsumer makes sense as well.  There is never a time when a model part wont have the  ColumnMapping reference(s) already, so concerns about instantiations isn't really a hinderance there.\nI'm not sure there is ever a time when we would not want a ColumnMapping on the ColumnReference for some reason (\"PK tables\", e.g.), but if so we could e.g. add a ModelColumnReference also that takes the ColumnMapping.\nI just think we added this ColumnMapping contract because it cleaned up a lot of code.  It would be a shame to not use it in other places where we could be using it.", "author": "sebersole", "createdAt": "2020-11-13T16:02:49Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java", "diffHunk": "@@ -181,11 +186,11 @@ public DomainResult createDomainResult(\n \t\t\t\t\t\t\t),\n \t\t\t\t\t\t\ts ->\n \t\t\t\t\t\t\t\t\tnew ColumnReference(\n-\t\t\t\t\t\t\t\t\t\t\tidentificationVariable,", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0OTI5MA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523049290", "bodyText": "The more I see it the more I really like your naming pattern here better - #forEachColumn as opposed to #visitColumns.  It better matches with the Java naming.\nI'm actually thinking of a general refactoring to make that change.  What do y'all think?", "author": "sebersole", "createdAt": "2020-11-13T16:08:50Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java", "diffHunk": "@@ -255,46 +260,49 @@ public Predicate generateJoinPredicate(\n \t\tfinal String lhsTableExpression = lhs.getTableExpression();\n \t\tif ( lhsTableExpression.equals( keyColumnContainingTable ) ) {\n \t\t\tassert rhsTableExpression.equals( targetColumnContainingTable );\n-\t\t\treturn getPredicate( lhs, rhs, creationContext, keyColumnExpressions, targetColumnExpressions );\n+\t\t\treturn getPredicate( lhs, rhs, creationContext, keyColumnMappings, targetColumnMappings );\n \t\t}\n \t\telse {\n \t\t\tassert rhsTableExpression.equals( keyColumnContainingTable );\n-\t\t\treturn getPredicate( lhs, rhs, creationContext, targetColumnExpressions, keyColumnExpressions );\n+\t\t\treturn getPredicate( lhs, rhs, creationContext, targetColumnMappings, keyColumnMappings );\n \t\t}\n \t}\n \n \tprivate Predicate getPredicate(\n \t\t\tTableReference lhs,\n \t\t\tTableReference rhs,\n \t\t\tSqlAstCreationContext creationContext,\n-\t\t\tList<String> lhsExpressions,\n-\t\t\tList<String> rhsColumnExpressions) {\n+\t\t\tColumnMappings lhsMappings,\n+\t\t\tColumnMappings rhsMappings) {\n \t\tfinal Junction predicate = new Junction( Junction.Nature.CONJUNCTION );\n-\t\tfor ( int i = 0; i < lhsExpressions.size(); i++ ) {\n-\t\t\tfinal JdbcMapping jdbcMapping = jdbcMappings.get( i );\n-\t\t\tfinal ComparisonPredicate comparisonPredicate = new ComparisonPredicate(\n-\t\t\t\t\tnew ColumnReference(\n-\t\t\t\t\t\t\tlhs,\n-\t\t\t\t\t\t\tlhsExpressions.get( i ),\n-\t\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tjdbcMapping,\n-\t\t\t\t\t\t\tcreationContext.getSessionFactory()\n-\t\t\t\t\t),\n-\t\t\t\t\tComparisonOperator.EQUAL,\n-\t\t\t\t\tnew ColumnReference(\n-\t\t\t\t\t\t\trhs,\n-\t\t\t\t\t\t\trhsColumnExpressions.get( i ),\n-\t\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tnull,\n-\t\t\t\t\t\t\tjdbcMapping,\n-\t\t\t\t\t\t\tcreationContext.getSessionFactory()\n-\t\t\t\t\t)\n-\t\t\t);\n-\t\t\tpredicate.add( comparisonPredicate );\n-\t\t}\n+\t\tlhsMappings.forEachColumn(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MTA4Mw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3644#discussion_r523051083", "bodyText": "Another case where this code would be a lot cleaner passing along the ColumnMapping", "author": "sebersole", "createdAt": "2020-11-13T16:11:48Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java", "diffHunk": "@@ -115,35 +116,39 @@ public DomainResult createCollectionFetchDomainResult(\n \t\t\tfinal TableReference tableReference = tableGroup.resolveTableReference( keyColumnContainingTable );\n \t\t\tfinal String identificationVariable = tableReference.getIdentificationVariable();\n \n-\t\t\tList<SqlSelection> sqlSelections = new ArrayList<>();\n-\t\t\tfor ( int i = 0; i < keyColumnExpressions.size(); i++ ) {\n-\t\t\t\tfinal JdbcMapping jdbcMapping = jdbcMappings.get( i );\n-\t\t\t\tfinal String columnExpression = targetColumnExpressions.get( i );\n-\t\t\t\tfinal SqlSelection sqlSelection = sqlExpressionResolver.resolveSqlSelection(\n-\t\t\t\t\t\tsqlExpressionResolver.resolveSqlExpression(\n-\t\t\t\t\t\t\t\tSqlExpressionResolver.createColumnReferenceKey(\n-\t\t\t\t\t\t\t\t\t\ttableReference,\n-\t\t\t\t\t\t\t\t\t\tcolumnExpression\n+\t\t\tList<SqlSelection> sqlSelections = new ArrayList<>( targetColumnMappings.getColumnSpan() );\n+\t\t\ttargetColumnMappings.forEachColumn(", "originalCommit": "8649534f34d1918723cd399e0717dcf6b4530957", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c63b686e9eb49b46a39c1a08463600aad18524d4", "url": "https://github.com/hibernate/hibernate-orm/commit/c63b686e9eb49b46a39c1a08463600aad18524d4", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T10:56:13Z", "type": "forcePushed"}, {"oid": "ca5520e21e4c7547632fc505fb0a51a931bfe0fa", "url": "https://github.com/hibernate/hibernate-orm/commit/ca5520e21e4c7547632fc505fb0a51a931bfe0fa", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T15:29:14Z", "type": "forcePushed"}, {"oid": "a03a0d04dac8cfa2f17b851e1e4fda9e3630c814", "url": "https://github.com/hibernate/hibernate-orm/commit/a03a0d04dac8cfa2f17b851e1e4fda9e3630c814", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T17:20:49Z", "type": "forcePushed"}, {"oid": "5aed3fbcac4cfee28fd3066255d420ded8fa37e5", "url": "https://github.com/hibernate/hibernate-orm/commit/5aed3fbcac4cfee28fd3066255d420ded8fa37e5", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-10T23:23:09Z", "type": "forcePushed"}, {"oid": "884e2c59d7c3ec147ea6db703d606b3016a15524", "url": "https://github.com/hibernate/hibernate-orm/commit/884e2c59d7c3ec147ea6db703d606b3016a15524", "message": "Use new parent PostgreSQLDialect for @RequiresDialect rather than subclass", "committedDate": "2020-12-11T10:58:05Z", "type": "commit"}, {"oid": "1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "url": "https://github.com/hibernate/hibernate-orm/commit/1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-14T12:52:42Z", "type": "commit"}, {"oid": "1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "url": "https://github.com/hibernate/hibernate-orm/commit/1dd656c99205d25b3f1d25ce0b7b0c231f52aaf9", "message": "HHH-14318 Introduce column mapping abstract to support formulas easily", "committedDate": "2020-12-14T12:52:42Z", "type": "forcePushed"}]}