{"pr_number": 538, "pr_title": "Sql template", "pr_createdAt": "2020-03-13T12:19:39Z", "pr_url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538", "timeline": [{"oid": "752f9fc8b9086c5c9b97a36dfcbbf794da252f55", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/752f9fc8b9086c5c9b97a36dfcbbf794da252f55", "message": "Template poc", "committedDate": "2020-03-16T08:55:12Z", "type": "forcePushed"}, {"oid": "0dce2e0728b22505f935d33689fd51f7e3d93bcb", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/0dce2e0728b22505f935d33689fd51f7e3d93bcb", "message": "Template poc", "committedDate": "2020-03-16T09:52:48Z", "type": "forcePushed"}, {"oid": "46b7c9cce74bf349602425a28d0323ba23b493ca", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/46b7c9cce74bf349602425a28d0323ba23b493ca", "message": "Start data object to param mapping", "committedDate": "2020-03-17T08:40:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MDY0Nw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r395570647", "bodyText": "How about naming it batchUpdate since it returns an asynchronous result of Void type?", "author": "BillyYccc", "createdAt": "2020-03-20T11:14:29Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/BatchTemplate.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.impl.BatchTemplateImpl;\n+import io.vertx.sqlclient.template.impl.QueryTemplateImpl;\n+import io.vertx.sqlclient.template.impl.TupleMapper;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@VertxGen\n+public interface BatchTemplate<T> {\n+\n+  @GenIgnore\n+  static BatchTemplate<Map<String, Object>> create(SqlClient client, String template) {\n+    TupleMapper tupleMapper = new TupleMapper(client, template);\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), tupleMapper::mapTuple);\n+  }\n+\n+  static <T> BatchTemplate<T> create(SqlClient client, Function<T, Tuple> mapper, String template) {\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), mapper);\n+  }\n+\n+  static <T> BatchTemplate<T> create(SqlClient client, Class<T> clazz, String template) {\n+    TupleMapper tupleMapper = new TupleMapper(client, template);\n+    Function<T, Tuple> mapper = t -> tupleMapper.mapTuple(JsonObject.mapFrom(t).getMap());\n+    return new BatchTemplateImpl<>(client, new TupleMapper(client, template), mapper);\n+  }\n+\n+  @GenIgnore\n+  default Future<Void> batch(List<T> list) {\n+    Promise<Void> promise = Promise.promise();\n+    batch(list, promise);\n+    return promise.future();\n+  }\n+\n+  @GenIgnore\n+  void batch(List<T> list, Handler<AsyncResult<Void>> result);", "originalCommit": "e66f7a582bdca254546bd8da1c371174a3ffb507", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "43956b45a1b133dd0baaba456a3fd28a10995790", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/43956b45a1b133dd0baaba456a3fd28a10995790", "message": "New SqlTemplate essai", "committedDate": "2020-03-24T09:01:23Z", "type": "forcePushed"}, {"oid": "45a19f26e820fdbb19e1f7b59d2d4a0808e65aad", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/45a19f26e820fdbb19e1f7b59d2d4a0808e65aad", "message": "More work", "committedDate": "2020-04-30T14:46:48Z", "type": "forcePushed"}, {"oid": "5534f9281a122885f98a09a369d65f27a656b88c", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/5534f9281a122885f98a09a369d65f27a656b88c", "message": "improve examples", "committedDate": "2020-05-01T09:12:31Z", "type": "forcePushed"}, {"oid": "0d8de52ddde0d75d20b9c455ebc5e5413c5a26d0", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/0d8de52ddde0d75d20b9c455ebc5e5413c5a26d0", "message": "Project modifications", "committedDate": "2020-05-05T09:42:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU0NTE2Mg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420545162", "bodyText": "BTW you should have 2020 license headers in files (IntelliJ copyright update can help)", "author": "jponge", "createdAt": "2020-05-06T04:56:52Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODIzNQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420918235", "bodyText": "If i am not mistaken this is not used and can be removed", "author": "zenios", "createdAt": "2020-05-06T16:16:49Z", "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2Nzk5Mw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421267993", "bodyText": "this is referenced from index.adoc", "author": "vietj", "createdAt": "2020-05-07T06:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODc5Nw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420918797", "bodyText": "If i am not mistaken this is not used and can be removed", "author": "zenios", "createdAt": "2020-05-06T16:17:43Z", "path": "vertx-sql-client-template/src/main/java/examples/TemplateExamples.java", "diffHunk": "@@ -0,0 +1,397 @@\n+package examples;\n+\n+import io.vertx.codegen.QualifiedCase;\n+import io.vertx.codegen.SnakeCase;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.docgen.Source;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.ParamsMapped;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+import io.vertx.sqlclient.template.annotations.TemplateParam;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+@Source\n+public class TemplateExamples {\n+\n+  static class User {\n+    public long id;\n+    public String firstName;\n+    public String lastName;\n+  }\n+\n+  public void queryExample(SqlClient client) {\n+    Map<String, Object> params = Collections.singletonMap(\"id\", 1);\n+\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .execute(params)\n+      .onSuccess(users -> {\n+        users.forEach(row -> {\n+          System.out.println(row.getString(\"first_name\") + \" \" + row.getString(\"last_name\"));\n+        });\n+      });\n+  }\n+\n+  public void insertExample(SqlClient client) {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", 1);\n+    params.put(\"firstName\", \"Dale\");\n+    params.put(\"lastName\", \"Cooper\");\n+\n+    SqlTemplate\n+      .forUpdate(client, \"INSERT INTO users VALUES (:id,:firstName,:lastName)\")\n+      .execute(params)\n+      .onSuccess(v -> {\n+        System.out.println(\"Successful update\");\n+      });\n+  }\n+\n+  private static final Function<Row, User> ROW_USER_MAPPER = row -> {\n+    User user = new User();\n+    user.id = row.getInteger(\"id\");\n+    user.firstName = row.getString(\"firstName\");\n+    user.lastName = row.getString(\"lastName\");\n+    return user;\n+  };\n+\n+  public void rowUserMapper() {\n+    Function<Row, User> ROW_USER_MAPPER = row -> {\n+      User user = new User();\n+      user.id = row.getInteger(\"id\");\n+      user.firstName = row.getString(\"firstName\");\n+      user.lastName = row.getString(\"lastName\");\n+      return user;\n+    };\n+  }\n+\n+  public void bindingRowWithCustomFunction(SqlClient client) {\n+    SqlTemplate\n+      .forQuery(client, \"SELECT * FROM users WHERE id=:id\")\n+      .mapTo(ROW_USER_MAPPER)\n+      .execute(Collections.singletonMap(\"id\", 1))\n+      .onSuccess(users -> {\n+        users.forEach(user -> {\n+          System.out.println(user.firstName + \" \" + user.lastName);\n+        });\n+      });\n+  }\n+\n+  private static final Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+    Map<String, Object> params = new HashMap<>();\n+    params.put(\"id\", user.id);\n+    params.put(\"firstName\", user.firstName);\n+    params.put(\"lastName\", user.lastName);\n+    return params;\n+  };\n+\n+  public void paramsUserMapper() {\n+    Function<User, Map<String, Object>> PARAMS_USER_MAPPER = user -> {\n+      Map<String, Object> params = new HashMap<>();\n+      params.put(\"id\", user.id);\n+      params.put(\"firstName\", user.firstName);\n+      params.put(\"lastName\", user.lastName);\n+      return params;\n+    };\n+  }", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzkwMw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421267903", "bodyText": "this is referenced from index.adoc", "author": "vietj", "createdAt": "2020-05-07T06:29:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxODc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODAyNA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420938024", "bodyText": "Why not?\ndefault void execute(I parameters, Handler<AsyncResult<R>> handler) {\nexecute(parameters).onComplete(handler);\n}", "author": "zenios", "createdAt": "2020-05-06T16:46:26Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template update string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, SqlResult<Void>> forUpdate(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(SqlTemplateImpl.NULL_COLLECTOR), Function.identity());\n+  }\n+\n+  /**\n+   * Set a parameters user defined mapping function.\n+   *\n+   * <p> At query execution, the {@code mapper} function is called to map the parameters object\n+   * to a {@code Map<String, Object>} that configures the prepared query.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Function<T, Map<String, Object>> mapper);\n+\n+  /**\n+   * Set a parameters user defined class mapping.\n+   *\n+   * <p> At query execution, the parameters object is is mapped to a {@code Map<String, Object>} that\n+   * configures the prepared query.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Class<T> type);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, the {@code mapper} function is called to map the resulting\n+   * rows to objects.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Function<Row, U> mapper);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, resulting rows are mapped to {@code type} instances.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Class<U> type);\n+\n+  /**\n+   * Set a collector that will process the output and produce a custom result.\n+   *\n+   * @param collector the collector\n+   * @return a new template\n+   */\n+  @GenIgnore\n+  <U> SqlTemplate<I, SqlResult<U>> collecting(Collector<Row, ?, U> collector);\n+\n+  /**\n+   * Execute the query with the {@code parameters}\n+   *\n+   * @param parameters the query parameters\n+   * @param handler the result handler\n+   */\n+  void execute(I parameters, Handler<AsyncResult<R>> handler);", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODA5Mg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420938092", "bodyText": "Why not?\ndefault void executeBatch(List<I> batch, Handler<AsyncResult<R>> handler) {\nexecuteBatch(batch).onComplete(handler);\n}", "author": "zenios", "createdAt": "2020-05-06T16:46:32Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template update string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, SqlResult<Void>> forUpdate(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = new io.vertx.sqlclient.template.impl.SqlTemplate((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(SqlTemplateImpl.NULL_COLLECTOR), Function.identity());\n+  }\n+\n+  /**\n+   * Set a parameters user defined mapping function.\n+   *\n+   * <p> At query execution, the {@code mapper} function is called to map the parameters object\n+   * to a {@code Map<String, Object>} that configures the prepared query.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Function<T, Map<String, Object>> mapper);\n+\n+  /**\n+   * Set a parameters user defined class mapping.\n+   *\n+   * <p> At query execution, the parameters object is is mapped to a {@code Map<String, Object>} that\n+   * configures the prepared query.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <T> SqlTemplate<T, R> mapFrom(Class<T> type);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, the {@code mapper} function is called to map the resulting\n+   * rows to objects.\n+   *\n+   * @param mapper the mapping function\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Function<Row, U> mapper);\n+\n+  /**\n+   * Set a row user defined mapping function.\n+   *\n+   * <p> When the query execution completes, resulting rows are mapped to {@code type} instances.\n+   *\n+   * <p> This feature relies on {@link io.vertx.core.json.JsonObject#mapFrom} feature. This likely requires\n+   * to use Jackson databind in the project.\n+   *\n+   * @param type the mapping type\n+   * @return a new template\n+   */\n+  <U> SqlTemplate<I, RowSet<U>> mapTo(Class<U> type);\n+\n+  /**\n+   * Set a collector that will process the output and produce a custom result.\n+   *\n+   * @param collector the collector\n+   * @return a new template\n+   */\n+  @GenIgnore\n+  <U> SqlTemplate<I, SqlResult<U>> collecting(Collector<Row, ?, U> collector);\n+\n+  /**\n+   * Execute the query with the {@code parameters}\n+   *\n+   * @param parameters the query parameters\n+   * @param handler the result handler\n+   */\n+  void execute(I parameters, Handler<AsyncResult<R>> handler);\n+\n+  /**\n+   * Like {@link #execute(Object, Handler)} but returns a {@code Future} of the asynchronous result\n+   */\n+  Future<R> execute(I params);\n+\n+  /**\n+   * Execute a batch query with the {@code batch}.\n+   *\n+   * <p>Each item in the batch is mapped to a tuple.\n+   *\n+   * @param batch the batch\n+   * @param handler the result handler\n+   */\n+  void executeBatch(List<I> batch, Handler<AsyncResult<R>> handler);", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzQ2MA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421267460", "bodyText": "because in practice the underlying query will actually use internally a Promise<R> that is created from the handler, so if you pass a promise to an executeBatch it will not be rewrapped into another promise.", "author": "vietj", "createdAt": "2020-05-07T06:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk0MDA4NA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420940084", "bodyText": "when this property when ?", "author": "zenios", "createdAt": "2020-05-06T16:49:38Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/annotations/TemplateParam.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.vertx.sqlclient.template.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotate a Vert.x data object property for custom configuration when this property when", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MTQ1Ng==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420961456", "bodyText": "This will not work for postgresql :: cast\nThis is how spring does it\nhttps://github.com/spring-projects/spring-framework/blob/4ca64684f6d5b7414ca3628a6b372a7c586fd2a6/spring-jdbc/src/main/java/org/springframework/jdbc/core/namedparam/NamedParameterUtils.java#L82\nAnother solution is to use ${name} via this pattern\nPattern.compile(\"\\\\$\\\\{\\\\s*(.*?)\\\\s*}\");\n\nWe could also cache the result", "author": "zenios", "createdAt": "2020-05-06T17:22:47Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class SqlTemplate {\n+\n+  private static Pattern PARAM_PATTERN = Pattern.compile(\":(\\\\p{javaUnicodeIdentifierStart}\\\\p{javaUnicodeIdentifierPart}*)\");", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NjU3MQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421266571", "bodyText": "I like this idea", "author": "vietj", "createdAt": "2020-05-07T06:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MTQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjU0Ng==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420962546", "bodyText": "This can be remove if we use the default method on interface", "author": "zenios", "createdAt": "2020-05-06T17:24:20Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2ODc3OA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421268778", "bodyText": "This is important to keep this and delegate to the original query", "author": "vietj", "createdAt": "2020-05-07T06:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjYyNA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420962624", "bodyText": "This can be remove if we use the default method on interface", "author": "zenios", "createdAt": "2020-05-06T17:24:28Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,\n+                         Function<T, Map<String, Object>> paramsMapper) {\n+    this.client = client;\n+    this.sqlTemplate = sqlTemplate;\n+    this.queryMapper = foobar;\n+    this.paramsMapper = paramsMapper;\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Function<T1, Map<String, Object>> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, queryMapper, mapper);\n+  }\n+\n+  @Override\n+  public <T1> SqlTemplate<T1, R> mapFrom(Class<T1> type) {\n+    return mapFrom(params -> JsonObject.mapFrom(params).getMap());\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, SqlResult<U>> collecting(Collector<Row, ?, U> collector) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.collecting(collector), paramsMapper);\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Class<U> type) {\n+    return mapTo(row -> {\n+      JsonObject json = new JsonObject();\n+      for (int i = 0;i < row.size();i++) {\n+        json.getMap().put(row.getColumnName(i), row.getValue(i));\n+      }\n+      return json.mapTo(type);\n+    });\n+  }\n+\n+  @Override\n+  public <U> SqlTemplate<T, RowSet<U>> mapTo(Function<Row, U> mapper) {\n+    return new SqlTemplateImpl<>(client, sqlTemplate, query -> query.mapping(mapper), paramsMapper);\n+  }\n+\n+  private Tuple toTuple(T params) {\n+    return sqlTemplate.mapTuple(paramsMapper.apply(params));\n+  }\n+\n+  @Override\n+  public void execute(T parameters, Handler<AsyncResult<R>> handler) {\n+\n+    queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(parameters), handler);\n+  }\n+\n+  @Override\n+  public Future<R> execute(T params) {\n+    return queryMapper\n+      .apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .execute(toTuple(params));\n+  }\n+\n+  @Override\n+  public void executeBatch(List<T> batch, Handler<AsyncResult<R>> handler) {\n+    queryMapper.apply(client.preparedQuery(sqlTemplate.getSql()))\n+      .executeBatch(batch\n+        .stream()\n+        .map(this::toTuple)\n+        .collect(Collectors.toList()), handler);\n+  }", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2ODczNg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421268736", "bodyText": "This is important to keep this and delegate to the original query", "author": "vietj", "createdAt": "2020-05-07T06:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2MjYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4MDAzMg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r420980032", "bodyText": "placeholder not place holder", "author": "zenios", "createdAt": "2020-05-06T17:51:15Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package io.vertx.sqlclient.impl;\n+\n+import io.vertx.sqlclient.SqlClient;\n+\n+public interface SqlClientInternal extends SqlClient {\n+\n+  /**\n+   * Append a query place holder in the {@code query}.", "originalCommit": "830d45927f9e149a05cddd36dbe0dc66c3bc3174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5OTc2MQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421799761", "bodyText": "We should document the return value", "author": "zenios", "createdAt": "2020-05-07T21:17:19Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientInternal.java", "diffHunk": "@@ -5,13 +5,13 @@\n public interface SqlClientInternal extends SqlClient {\n \n   /**\n-   * Append a query place holder in the {@code query}.\n+   * Append a query placeholder in the {@code query}.\n    *\n    * <p>The index starts at {@code 0}\n    *\n    * @param queryBuilder the builder to append to\n-   * @param index the place holder index\n+   * @param index the placeholder index\n    */\n-  int appendQueryPlaceHolder(StringBuilder queryBuilder, int index, int current);\n+  int appendQueryPlaceholder(StringBuilder queryBuilder, int index, int current);", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODExOA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808118", "bodyText": "An SQL template.", "author": "zenios", "createdAt": "2020-05-07T21:34:21Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODYxMQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808611", "bodyText": "Create an SQL template", "author": "zenios", "createdAt": "2020-05-07T21:35:35Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTgwODY4MA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r421808680", "bodyText": "Create an SQL template", "author": "zenios", "createdAt": "2020-05-07T21:35:43Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/SqlTemplate.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package io.vertx.sqlclient.template;\n+\n+import io.vertx.codegen.annotations.GenIgnore;\n+import io.vertx.codegen.annotations.VertxGen;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.impl.SqlClientInternal;\n+import io.vertx.sqlclient.template.impl.SqlTemplateImpl;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+\n+/**\n+ * A SQL template.\n+ *\n+ * <p>SQL templates are useful for interacting with a relational database.\n+ *\n+ * <p>SQL templates execute queries using named instead of positional parameters. Query execution is parameterized\n+ * by a map of string to objects instead of a {@link io.vertx.sqlclient.Tuple}. The default source of parameters is a\n+ * simple map, a user defined mapping can be used instead given it maps the source to such a map.\n+ *\n+ * <p>SQL template default results are {@link Row}, a user defined mapping can be used instead, mapping the\n+ * result set {@link Row} to a {@link RowSet} of the mapped type.\n+ */\n+@VertxGen\n+public interface SqlTemplate<I, R> {\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning {@link Row}.\n+   *\n+   * @param client the wrapped SQL client\n+   * @param template the template query string\n+   * @return the template\n+   */\n+  static SqlTemplate<Map<String, Object>, RowSet<Row>> forQuery(SqlClient client, String template) {\n+    io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate = io.vertx.sqlclient.template.impl.SqlTemplate.create((SqlClientInternal) client, template);\n+    return new SqlTemplateImpl<>(client, sqlTemplate, Function.identity(), Function.identity());\n+  }\n+\n+  /**\n+   * Create a SQL template for query purpose consuming map parameters and returning void.", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyOTMzMw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422229333", "bodyText": "foobar should be named queryMapper?", "author": "BillyYccc", "createdAt": "2020-05-08T16:06:37Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/impl/SqlTemplateImpl.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package io.vertx.sqlclient.template.impl;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.sqlclient.PreparedQuery;\n+import io.vertx.sqlclient.Row;\n+import io.vertx.sqlclient.RowSet;\n+import io.vertx.sqlclient.SqlClient;\n+import io.vertx.sqlclient.SqlResult;\n+import io.vertx.sqlclient.Tuple;\n+import io.vertx.sqlclient.template.SqlTemplate;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+\n+public class SqlTemplateImpl<T, R> implements SqlTemplate<T, R> {\n+\n+  //\n+  public static final Collector<Row, Void, Void> NULL_COLLECTOR = Collector.of(() -> null, (v, row) -> {}, (a, b) -> null);\n+\n+  protected final SqlClient client;\n+  protected final io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate;\n+  protected final Function<T, Map<String, Object>> paramsMapper;\n+  protected Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> queryMapper;\n+\n+  public SqlTemplateImpl(SqlClient client,\n+                         io.vertx.sqlclient.template.impl.SqlTemplate sqlTemplate,\n+                         Function<PreparedQuery<RowSet<Row>>, PreparedQuery<R>> foobar,", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzMTQyNg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422231426", "bodyText": "we need to override this method in MSSQLConnectionImpl and MSSQLPoolImpl for sql server client.\nThe syntax is like postgres as:\n    queryBuilder.append('@').append(1 + index);\n    return index;", "author": "BillyYccc", "createdAt": "2020-05-08T16:10:43Z", "path": "vertx-sql-client/src/main/java/io/vertx/sqlclient/impl/SqlClientBase.java", "diffHunk": "@@ -37,7 +37,13 @@\n import java.util.function.Function;\n import java.util.stream.Collector;\n \n-public abstract class SqlClientBase<C extends SqlClient> implements SqlClient, CommandScheduler {\n+public abstract class SqlClientBase<C extends SqlClient> implements SqlClientInternal, CommandScheduler {\n+\n+  @Override\n+  public int appendQueryPlaceholder(StringBuilder queryBuilder, int index, int current) {\n+    queryBuilder.append(\"?\");", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MjU5Mw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422462593", "bodyText": "oh good to know I will do it", "author": "vietj", "createdAt": "2020-05-09T07:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzMTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422238805", "bodyText": "it seems we don't support mapping string/numeric datat type to enum type(name/ordinal). I wonder if we could support this here.", "author": "BillyYccc", "createdAt": "2020-05-08T16:25:14Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MzA0Mg==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422463042", "bodyText": "I think we can map it to get/set String easily", "author": "vietj", "createdAt": "2020-05-09T07:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2MzE0Nw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422463147", "bodyText": "at least for beginning, some might want to provide at some point a custom function for this type", "author": "vietj", "createdAt": "2020-05-09T07:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMTc4OQ==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422701789", "bodyText": "I've checked in such mapping support in master for PostgreSQL and implement support for templates in this PR.", "author": "vietj", "createdAt": "2020-05-10T21:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIzODgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422241738", "bodyText": "can we add tests for data object type like geometrics data object and numeric data object to check whether it works?", "author": "BillyYccc", "createdAt": "2020-05-08T16:31:14Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {\n+        case \"java.time.LocalDateTime\":\n+          return \"getLocalDateTime\";\n+        case \"java.time.LocalDate\":\n+          return \"getLocalDate\";\n+        case \"java.time.LocalTime\":\n+          return \"getLocalTime\";\n+        case \"java.time.OffsetTime\":\n+          return \"getOffsetTime\";\n+        case \"java.time.OffsetDateTime\":\n+          return \"getOffsetDateTime\";\n+        case \"java.time.temporal.Temporal\":\n+          return \"getTemporal\";\n+        case \"java.util.UUID\":\n+          return \"getUUID\";\n+        case \"io.vertx.core.buffer.Buffer\":\n+          return \"getBuffer\";\n+      }\n+      DataObjectInfo dataObject = type.getDataObject();", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2Mjc5Mw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422462793", "bodyText": "yes, I'm not sure they work, we'll write the tests and figure out after :-)", "author": "vietj", "createdAt": "2020-05-09T07:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTQyMw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422861423", "bodyText": "I added support and tests for such types", "author": "vietj", "createdAt": "2020-05-11T08:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTc0Ng==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422861746", "bodyText": "Actually they are mapped to generic types with row.get(Box.class, pos)", "author": "vietj", "createdAt": "2020-05-11T08:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MzQ4NA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422243484", "bodyText": "MySQL is using java.time.Duration type, can we add the mapping here using Row#get(java.time.Duration.class, index)?", "author": "BillyYccc", "createdAt": "2020-05-08T16:34:37Z", "path": "vertx-sql-client-template/src/main/java/io/vertx/sqlclient/template/generator/RowMapperGen.java", "diffHunk": "@@ -0,0 +1,215 @@\n+package io.vertx.sqlclient.template.generator;\n+\n+import io.vertx.codegen.DataObjectModel;\n+import io.vertx.codegen.MapperKind;\n+import io.vertx.codegen.PropertyInfo;\n+import io.vertx.codegen.annotations.DataObject;\n+import io.vertx.codegen.type.AnnotationValueInfo;\n+import io.vertx.codegen.type.ClassTypeInfo;\n+import io.vertx.codegen.type.DataObjectInfo;\n+import io.vertx.codegen.type.MapperInfo;\n+import io.vertx.codegen.type.PrimitiveTypeInfo;\n+import io.vertx.codegen.type.TypeInfo;\n+import io.vertx.sqlclient.template.annotations.Column;\n+import io.vertx.sqlclient.template.annotations.RowMapped;\n+\n+import java.io.PrintWriter;\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+/**\n+ * @author <a href=\"mailto:julien@julienviet.com\">Julien Viet</a>\n+ */\n+public class RowMapperGen extends MapperGenBase {\n+\n+  public RowMapperGen() {\n+    kinds = Collections.singleton(\"dataObject\");\n+    name = \"data_object_mappers\";\n+  }\n+\n+  @Override\n+  public Collection<Class<? extends Annotation>> annotations() {\n+    return Collections.singletonList(DataObject.class);\n+  }\n+\n+  @Override\n+  protected String genSimpleName(DataObjectModel model) {\n+    return model.getType().getSimpleName() + \"RowMapper\";\n+  }\n+\n+  @Override\n+  protected Optional<AnnotationValueInfo> getAnnotation(DataObjectModel model) {\n+    return model\n+      .getAnnotations()\n+      .stream().filter(ann -> ann.getName().equals(RowMapped.class.getName()))\n+      .findFirst();\n+  }\n+\n+  @Override\n+  protected void renderMembers(String visibility, DataObjectModel model, PrintWriter writer) {\n+    genFromRow(visibility, model, writer);\n+  }\n+\n+  @Override\n+  protected String genFunctionExtends(DataObjectModel model) {\n+    return \"java.util.function.Function<io.vertx.sqlclient.Row, \" + model.getType().getSimpleName() + \">\";\n+  }\n+\n+  private void genFromRow(String visibility, DataObjectModel model, PrintWriter writer) {\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.function.Function<io.vertx.sqlclient.Row, \" +  model.getType().getSimpleName() + \"> INSTANCE = new \" + genSimpleName(model) + \"();\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" static final java.util.stream.Collector<io.vertx.sqlclient.Row, ?, java.util.List<\" + model.getType().getSimpleName() + \">> COLLECTOR = \" + \"java.util.stream.Collectors.mapping(INSTANCE, java.util.stream.Collectors.toList());\\n\");\n+    writer.print(\"\\n\");\n+    writer.print(\"  \" + visibility + \" \" + model.getType().getSimpleName() + \" apply(io.vertx.sqlclient.Row row) {\\n\");\n+    writer.print(\"    \" + model.getType().getSimpleName() + \" obj = new \" + model.getType().getSimpleName() + \"();\\n\");\n+    writer.print(\"    Object val;\\n\");\n+    genFromSingleValued(model, writer);\n+    writer.print(\"    return obj;\\n\");\n+    writer.print(\"  }\\n\");\n+  }\n+\n+  private void genFromSingleValued(DataObjectModel model, PrintWriter writer) {\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(PropertyInfo::isSetter)\n+      .forEach(prop -> {\n+        String rowType = rowType(prop.getType());\n+        switch (prop.getKind()) {\n+          case VALUE: {\n+            String meth = getter(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, wrapExpr(prop.getType(), \"(\" + rowType + \")val\"));\n+            }\n+            break;\n+          }\n+          case LIST: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.ArrayList::new))\");\n+            }\n+            break;\n+          }\n+          case SET: {\n+            String meth = getArrayType(prop.getType());\n+            if (meth != null) {\n+              bilto4(writer, meth, prop, \"java.util.Arrays.stream((\" + rowType + \"[])val).map(elt -> \" + wrapExpr(prop.getType(), \"elt\") + \").collect(java.util.stream.Collectors.toCollection(java.util.HashSet::new))\");\n+            }\n+            break;\n+          }\n+        }\n+      });\n+    model\n+      .getPropertyMap()\n+      .values()\n+      .stream()\n+      .filter(prop -> PK.contains(prop.getKind()))\n+      .filter(prop -> prop.isAdder() && !prop.isSetter())\n+      .forEach(prop -> {\n+        String meth = getArrayType(prop.getType());\n+        String rowType = rowType(prop.getType());\n+        if (meth != null) {\n+          String columnName = getMappingName(prop, Column.class.getName());\n+          if (columnName != null) {\n+            writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+            writer.print(\"    if (val != null) {\\n\");\n+            writer.print(\"      for (\" + rowType + \" elt : (\" + rowType + \"[])val) {\\n\");\n+            writer.print(\"        obj.\" + prop.getAdderMethod() + \"(\" + wrapExpr(prop.getType(), \"elt\") + \");\\n\");\n+            writer.print(\"      }\\n\");\n+            writer.print(\"    }\\n\");\n+          }\n+        }\n+      });\n+  }\n+\n+  private void bilto4(PrintWriter writer, String meth, PropertyInfo prop, String converter) {\n+    String columnName = getMappingName(prop, Column.class.getName());\n+    if (columnName != null) {\n+      writer.print(\"    val = row.\" + meth + \"(\\\"\" + columnName + \"\\\");\\n\");\n+      writer.print(\"    if (val != null) {\\n\");\n+      writer.print(\"      obj.\" + prop.getSetterMethod() + \"(\" + converter +  \");\\n\");\n+      writer.print(\"    }\\n\");\n+    }\n+  }\n+\n+  private static String wrapExpr(TypeInfo type, String expr) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      MapperInfo deserializer = dataObject.getDeserializer();\n+      if (deserializer != null) {\n+        if (deserializer.getKind() == MapperKind.SELF) {\n+          return \"new \" + type.getName() + \"(\" + expr + \")\";\n+        } else {\n+          return deserializer.getQualifiedName() + \".\" + String.join(\".\", deserializer\n+            .getSelectors()) + \"(\" + expr + \")\";\n+        }\n+      }\n+      throw new UnsupportedOperationException();\n+    } else {\n+      return expr;\n+    }\n+  }\n+\n+  private static String rowType(TypeInfo type) {\n+    DataObjectInfo dataObject = type.getDataObject();\n+    if (dataObject != null) {\n+      return rowType(dataObject.getJsonType());\n+    }\n+    return type.getName();\n+  }\n+\n+  private static String getter(TypeInfo type) {\n+    switch (type.getKind()) {\n+      case PRIMITIVE:\n+        PrimitiveTypeInfo pt = (PrimitiveTypeInfo) type;\n+        return getter(pt.getBoxed());\n+      case BOXED_PRIMITIVE:\n+        return \"get\" + type.getSimpleName();\n+      case STRING:\n+        return \"getString\";\n+      case JSON_OBJECT:\n+        return \"getJsonObject\";\n+      case JSON_ARRAY:\n+        return \"getJsonArray\";\n+    }\n+    if (type instanceof ClassTypeInfo) {\n+      ClassTypeInfo ct = (ClassTypeInfo) type;\n+      switch (ct.getName()) {", "originalCommit": "040029de3c2c0c1b292364ee6dd3164a3666de58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2Mjg1Nw==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422462857", "bodyText": "I will try adding a specific tests for this using test container and implement it.", "author": "vietj", "createdAt": "2020-05-09T07:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MzQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTI2OA==", "url": "https://github.com/eclipse-vertx/vertx-sql-client/pull/538#discussion_r422861268", "bodyText": "I added support for this and specific integration tests", "author": "vietj", "createdAt": "2020-05-11T08:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI0MzQ4NA=="}], "type": "inlineReview"}, {"oid": "99d0e6996328ecf695239dd332aee526e006c7dd", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/99d0e6996328ecf695239dd332aee526e006c7dd", "message": "Support enum types", "committedDate": "2020-05-10T21:16:24Z", "type": "forcePushed"}, {"oid": "2228b0280dcad79604c6d7c2be77f756713baee6", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2228b0280dcad79604c6d7c2be77f756713baee6", "message": "SQL template feature", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "da90c8d93aa4225205ebb19da528c0c17d763583", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/da90c8d93aa4225205ebb19da528c0c17d763583", "message": "Project modifications", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "ac84a73ddf132750187d1209ed55320dcd5008f1", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/ac84a73ddf132750187d1209ed55320dcd5008f1", "message": "Implement correctly the actual SQL formatting for each database independently of place holder syntax", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "abddc8531f6e94ce14b7c9372a46daa07ee785e5", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/abddc8531f6e94ce14b7c9372a46daa07ee785e5", "message": "Use ${...} for properties as it eliminates ambiguity when parsing templates", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "2082edbc58b130bb97e025e67c6f81dfb8ecdb91", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2082edbc58b130bb97e025e67c6f81dfb8ecdb91", "message": "Typo", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "182bb749ab8a32bd8e81c3d40000aa03a486a430", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/182bb749ab8a32bd8e81c3d40000aa03a486a430", "message": "Typos", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "c3458e3a290e65d7c3340ef7a4ff248dfcb89e7a", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/c3458e3a290e65d7c3340ef7a4ff248dfcb89e7a", "message": "Typos", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "9e7a564b72e9befd48b5d54ada2c7ea857616c6a", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/9e7a564b72e9befd48b5d54ada2c7ea857616c6a", "message": "Javadoc", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "8155345d5a13a0c670c9b3c7c5cec2a07ba61989", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/8155345d5a13a0c670c9b3c7c5cec2a07ba61989", "message": "Typo", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "d15073af21cd13f06c860d3b8c0792e4fc35ad59", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/d15073af21cd13f06c860d3b8c0792e4fc35ad59", "message": "MS SQL uses the same parameter mapping than PG", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "61df1b54e91dd0e2c1b1dc2c969d2ed795f2e402", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/61df1b54e91dd0e2c1b1dc2c969d2ed795f2e402", "message": "Minor cleanup", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "c7c8cd3ce3cc2f4886acbc6a2307f12d7028822a", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/c7c8cd3ce3cc2f4886acbc6a2307f12d7028822a", "message": "Support enum types", "committedDate": "2020-05-11T08:06:02Z", "type": "commit"}, {"oid": "2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "message": "Map any java class using its class and consequently mapping MySQL duration and PosgreSQL specific data types", "committedDate": "2020-05-11T08:07:42Z", "type": "commit"}, {"oid": "2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/2effe5a6275af21ad6adeb6c485dd747fa1d3b92", "message": "Map any java class using its class and consequently mapping MySQL duration and PosgreSQL specific data types", "committedDate": "2020-05-11T08:07:42Z", "type": "forcePushed"}, {"oid": "3d4ac5d0926c70be7649bfda161fa6a2c453ed40", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/3d4ac5d0926c70be7649bfda161fa6a2c453ed40", "message": "Rename ParamsMapper -> ParametersMapped and ParamMapper -> ParametersMapper", "committedDate": "2020-05-11T08:42:03Z", "type": "commit"}, {"oid": "e81b867f2fd752e30183c33039fead92dbac2883", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/e81b867f2fd752e30183c33039fead92dbac2883", "message": "Rename to SQL Templates", "committedDate": "2020-05-11T08:59:34Z", "type": "commit"}, {"oid": "0a9aaffbc187fdaa39b0b3c6c9edf244f8022301", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/0a9aaffbc187fdaa39b0b3c6c9edf244f8022301", "message": "Finally rename to Vert.x SQL Templates", "committedDate": "2020-05-11T13:40:32Z", "type": "commit"}, {"oid": "b75cdcc7870e5090d064ef45c65586d5535e12af", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/b75cdcc7870e5090d064ef45c65586d5535e12af", "message": "Fixup", "committedDate": "2020-05-11T13:42:27Z", "type": "commit"}, {"oid": "a266727ca1aca7f69a23ec331fe215c5531e0cf1", "url": "https://github.com/eclipse-vertx/vertx-sql-client/commit/a266727ca1aca7f69a23ec331fe215c5531e0cf1", "message": "Use ${maven.artifactId} instead of vertx-sql-client-templates", "committedDate": "2020-05-12T16:29:36Z", "type": "commit"}]}