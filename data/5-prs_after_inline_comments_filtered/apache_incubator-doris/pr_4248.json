{"pr_number": 4248, "pr_title": "[Feature][Cache] Cache proxy and coordinator #2581", "pr_createdAt": "2020-08-04T07:47:38Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4248", "timeline": [{"oid": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "url": "https://github.com/apache/incubator-doris/commit/ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "message": "[Feature][Cache] Cache proxy and coordinator #2581\n1. Cache's abstract proxy class and BE's Cache implementation\n2. Cache coordinator implemented by consistent hashing", "committedDate": "2020-08-04T07:44:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4MzM5OQ==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r464983399", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Encapsulates access to BE, including network and other exception handlin\n          \n          \n            \n             * Encapsulates access to BE, including network and other exception handling", "author": "kangkaisen", "createdAt": "2020-08-04T11:30:14Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk5MTgxNA==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r464991814", "bodyText": "Please code format this file.", "author": "kangkaisen", "createdAt": "2020-08-04T11:47:51Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin\n+ */\n+public class CacheBeProxy extends CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public void updateCache(UpdateCacheRequest request, Status status) {\n+        PUniqueId sqlKey = request.sql_key;\n+        Backend backend = CacheCoordinator.getInstance().findBackend(sqlKey);\n+        if (backend == null) {\n+            LOG.warn(\"update cache can't find backend, sqlKey {}\", sqlKey);\n+            return;\n+        }\n+        TNetworkAddress address = new TNetworkAddress(backend.getHost(), backend.getBrpcPort());\n+        try {\n+            PUpdateCacheRequest updateRequest = request.getRpcRequest();\n+            Future<PCacheResponse> future = BackendServiceProxy.getInstance().updateCache(address, updateRequest);\n+            PCacheResponse response = future.get(10000,TimeUnit.MICROSECONDS);\n+            if( response.status == PCacheStatus.CACHE_OK) {", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNTYwMg==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465415602", "bodyText": "If do nothing, we could remove finally.", "author": "kangkaisen", "createdAt": "2020-08-05T01:15:38Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin\n+ */\n+public class CacheBeProxy extends CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public void updateCache(UpdateCacheRequest request, Status status) {\n+        PUniqueId sqlKey = request.sql_key;\n+        Backend backend = CacheCoordinator.getInstance().findBackend(sqlKey);\n+        if (backend == null) {\n+            LOG.warn(\"update cache can't find backend, sqlKey {}\", sqlKey);\n+            return;\n+        }\n+        TNetworkAddress address = new TNetworkAddress(backend.getHost(), backend.getBrpcPort());\n+        try {\n+            PUpdateCacheRequest updateRequest = request.getRpcRequest();\n+            Future<PCacheResponse> future = BackendServiceProxy.getInstance().updateCache(address, updateRequest);\n+            PCacheResponse response = future.get(10000,TimeUnit.MICROSECONDS);\n+            if( response.status == PCacheStatus.CACHE_OK) {\n+                status.setStatus(new Status(TStatusCode.OK, \"CACHE_OK\"));\n+            }else {\n+                status.setStatus(response.status.toString());\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"update cache exception, sqlKey {}, e {}\", sqlKey, e);\n+            status.setRpcStatus(e.getMessage());\n+            SimpleScheduler.addToBlacklist(backend.getId());\n+        } finally {", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDI1OA==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465420258", "bodyText": "What's the meaning of checkBackend?  which clearBackend firstly, then addBackend. rebuildBackend or resetBackend seems better?", "author": "kangkaisen", "createdAt": "2020-08-05T01:32:55Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheCoordinator.java", "diffHunk": "@@ -0,0 +1,162 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.proto.PUniqueId;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.Iterator;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Use consistent hashing to find the BE corresponding to the key to avoid the change of BE leading to failure to hit the Cache\n+ */\n+public class CacheCoordinator {\n+    private static final Logger LOG = LogManager.getLogger(CacheCoordinator.class);\n+    private static final int VIRTUAL_NODES = 10;\n+    private static final int REFRESH_NODE_TIME = 300000;\n+    public boolean DebugModel = false;\n+    private Hashtable<Long, Backend> realNodes = new Hashtable<>();\n+    private SortedMap<Long, Backend> virtualNodes = new TreeMap<>();\n+    private static Lock belock = new ReentrantLock();\n+\n+    private long lastRefreshTime;\n+    private static CacheCoordinator cachePartition;\n+\n+    public static CacheCoordinator getInstance() {\n+        if (cachePartition == null) {\n+            cachePartition = new CacheCoordinator();\n+        }\n+        return cachePartition;\n+    }\n+\n+    protected CacheCoordinator() {\n+    }\n+\n+    /**\n+     * Using the consistent hash and the hi part of sqlkey to get the backend node\n+     *\n+     * @param sqlKey 128 bit's sql md5\n+     * @return Backend\n+     */\n+    public Backend findBackend(PUniqueId sqlKey) {\n+        checkBackend();\n+        Backend virtualNode = null;\n+        try {\n+            belock.lock();\n+            SortedMap<Long, Backend> headMap = virtualNodes.headMap(sqlKey.hi);\n+            SortedMap<Long, Backend> tailMap = virtualNodes.tailMap(sqlKey.hi);\n+            int retryTimes = 0;\n+            while (true) {\n+                if (tailMap == null || tailMap.size() == 0) {\n+                    tailMap = headMap;\n+                    retryTimes += 1;\n+                }\n+                Long key = tailMap.firstKey();\n+                virtualNode = tailMap.get(key);\n+                if (SimpleScheduler.isAlive(virtualNode)) {\n+                    break;\n+                } else {\n+                    LOG.debug(\"backend {} not alive, key {}, retry {}\", virtualNode.getId(), key, retryTimes);\n+                    virtualNode = null;\n+                }\n+                tailMap = tailMap.tailMap(key + 1);\n+                retryTimes++;\n+                if (retryTimes >= 5) {\n+                    LOG.warn(\"find backend, reach max retry times {}\", retryTimes);\n+                    break;\n+                }\n+            }\n+        } finally {\n+            belock.unlock();\n+        }\n+        return virtualNode;\n+    }\n+\n+    public void checkBackend() {", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDYyOA==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465420628", "bodyText": "getParam \uff1f", "author": "kangkaisen", "createdAt": "2020-08-05T01:34:30Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMDY2Nw==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465420667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public void Debug() {\n          \n          \n            \n                    public void debug() {", "author": "kangkaisen", "createdAt": "2020-08-05T01:34:39Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {\n+            PCacheParam param = new PCacheParam();\n+            param.partition_key = partition_key;\n+            param.last_version = last_version;\n+            param.last_version_time = last_version_time;\n+            return param;\n+        }\n+\n+        public void Debug() {", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMTI0Ng==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465421246", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        row = Lists.newArrayList();\n          \n          \n            \n                        rows = Lists.newArrayList();", "author": "kangkaisen", "createdAt": "2020-08-05T01:36:40Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {\n+            PCacheParam param = new PCacheParam();\n+            param.partition_key = partition_key;\n+            param.last_version = last_version;\n+            param.last_version_time = last_version_time;\n+            return param;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"cache param, part key {}, version {}, time {}\",\n+                    partition_key, last_version, last_version_time);\n+        }\n+    }\n+\n+    public static class CacheValue extends PCacheValue {\n+        public CacheParam param;\n+        public TResultBatch resultBatch;\n+\n+        public CacheValue() {\n+            param = null;\n+            row = Lists.newArrayList();", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyMjcyNQ==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465422725", "bodyText": "Need a concrete method name", "author": "kangkaisen", "createdAt": "2020-08-05T01:42:24Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheProxy.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.proto.PCacheParam;\n+import org.apache.doris.proto.PCacheValue;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TResultBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.security.MessageDigest;\n+import java.util.List;\n+\n+/**\n+ * It encapsulates the request and response parameters and methods, \n+ * Based on this abstract class, the cache can be placed in FE/BE  and other places such as redis\n+ */\n+public abstract class CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public static class CacheParam extends PCacheParam {\n+        public CacheParam(PCacheParam param) {\n+            partition_key = param.partition_key;\n+            last_version = param.last_version;\n+            last_version_time = param.last_version_time;\n+        }\n+\n+        public CacheParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            partition_key = partitionKey;\n+            last_version = lastVersion;\n+            last_version_time = lastVersionTime;\n+        }\n+\n+        public PCacheParam getRParam() {\n+            PCacheParam param = new PCacheParam();\n+            param.partition_key = partition_key;\n+            param.last_version = last_version;\n+            param.last_version_time = last_version_time;\n+            return param;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"cache param, part key {}, version {}, time {}\",\n+                    partition_key, last_version, last_version_time);\n+        }\n+    }\n+\n+    public static class CacheValue extends PCacheValue {\n+        public CacheParam param;\n+        public TResultBatch resultBatch;\n+\n+        public CacheValue() {\n+            param = null;\n+            row = Lists.newArrayList();\n+            data_size = 0;\n+            resultBatch = new TResultBatch();\n+        }\n+\n+        public void addRpcResult(PCacheValue value) {\n+            param = new CacheParam(value.param);\n+            data_size += value.data_size;\n+            row.addAll(value.row);\n+        }\n+\n+        public RowBatch getRowBatch() {\n+            for (byte[] one : row) {\n+                resultBatch.addToRows(ByteBuffer.wrap(one));\n+            }\n+            RowBatch batch = new RowBatch();\n+            resultBatch.setPacket_seq(1);\n+            resultBatch.setIs_compressed(false);\n+            batch.setBatch(resultBatch);\n+            batch.setEos(true);\n+            return batch;\n+        }\n+\n+        public void addUpdateResult(long partitionKey, long lastVersion, long lastVersionTime, List<byte[]> rowList) {\n+            param = new CacheParam(partitionKey, lastVersion, lastVersionTime);\n+            for (byte[] buf : rowList) {\n+                data_size += buf.length;\n+                row.add(buf);\n+            }\n+        }\n+\n+        public PCacheValue getRpcValue() {\n+            PCacheValue value = new PCacheValue();\n+            value.param = param.getRParam();\n+            value.data_size = data_size;\n+            value.row = row;\n+            return value;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"cache value, partkey {}, ver:{}, time {}, row_num {}, data_size {}\",\n+                    param.partition_key, param.last_version, param.last_version_time,\n+                    row.size(),\n+                    data_size);\n+            for (int i = 0; i < row.size(); i++) {\n+                LOG.info(\"{}:{}\", i, row.get(i));\n+            }\n+        }\n+    }\n+\n+    public static class UpdateCacheRequest extends PUpdateCacheRequest {\n+        public int value_count;\n+        public int row_count;\n+        public int data_size;\n+        private String sqlStr;\n+        private List<CacheValue> valueList;\n+\n+        public UpdateCacheRequest(String sqlStr) {\n+            this.sqlStr = sqlStr;\n+            this.sql_key = getMd5(this.sqlStr);\n+            this.valueList = Lists.newArrayList();\n+            value_count = 0;\n+            row_count = 0;\n+            data_size = 0;\n+        }\n+\n+        public void addValue(long partitionKey, long lastVersion, long lastVersionTime, List<byte[]> rowList) {\n+            CacheValue value = new CacheValue();\n+            value.addUpdateResult(partitionKey, lastVersion, lastVersionTime, rowList);\n+            valueList.add(value);\n+            value_count++;\n+        }\n+\n+        public PUpdateCacheRequest getRpcRequest() {\n+            value_count = valueList.size();\n+            PUpdateCacheRequest request = new PUpdateCacheRequest();\n+            request.value = Lists.newArrayList();\n+            request.sql_key = sql_key;\n+            for (CacheValue value : valueList) {\n+                request.value.add(value.getRpcValue());\n+                row_count += value.row.size();\n+                data_size = value.data_size;\n+            }\n+            return request;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"update cache request, sql_key {}, value_size {}\", DebugUtil.printId(sql_key),\n+                    valueList.size());\n+            for (CacheValue value : valueList) {\n+                value.Debug();\n+            }\n+        }\n+    }\n+\n+\n+    public static class FetchCacheRequest extends PFetchCacheRequest {\n+        private String sqlStr;\n+        private List<CacheParam> paramList;\n+\n+        public FetchCacheRequest(String sqlStr) {\n+            this.sqlStr = sqlStr;\n+            this.sql_key = getMd5(this.sqlStr);\n+            this.paramList = Lists.newArrayList();\n+        }\n+\n+        public void addParam(long partitionKey, long lastVersion, long lastVersionTime) {\n+            CacheParam param = new CacheParam(partitionKey, lastVersion, lastVersionTime);\n+            paramList.add(param);\n+        }\n+\n+        public PFetchCacheRequest getRpcRequest() {\n+            PFetchCacheRequest request = new PFetchCacheRequest();\n+            request.param = Lists.newArrayList();\n+            request.sql_key = sql_key;\n+            for (CacheParam param : paramList) {\n+                request.param.add(param.getRParam());\n+            }\n+            return request;\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"fetch cache request, sql_key {}, param count {}\", DebugUtil.printId(sql_key), paramList.size());\n+            for (CacheParam param : paramList) {\n+                param.Debug();\n+            }\n+        }\n+    }\n+\n+    public static class FetchCacheResult extends PFetchCacheResult {\n+        public int all_count;\n+        public int value_count;\n+        public int row_count;\n+        public int data_size;\n+        private List<CacheValue> valueList;\n+\n+        public FetchCacheResult() {\n+            valueList = Lists.newArrayList();\n+            all_count = 0;\n+            value_count = 0;\n+            row_count = 0;\n+            data_size = 0;\n+        }\n+\n+        public List<CacheValue> getValueList() {\n+            return valueList;\n+        }\n+\n+        public void setResult(PFetchCacheResult rpcResult) {\n+            value_count = rpcResult.value.size();\n+            for (int i = 0; i < rpcResult.value.size(); i++) {\n+                PCacheValue rpcValue = rpcResult.value.get(i);\n+                CacheValue value = new CacheValue();\n+                value.addRpcResult(rpcValue);\n+                valueList.add(value);\n+                row_count += value.row.size();\n+                data_size += value.data_size;\n+            }\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"fetch cache result, value size {}\", valueList.size());\n+            for (CacheValue value : valueList) {\n+                value.Debug();\n+            }\n+        }\n+    }\n+\n+    public enum CacheProxyType {\n+        FE,\n+        BE,\n+        OUTER\n+    }\n+\n+    protected CacheProxy(){\n+    }\n+\n+    public static CacheProxy getCacheProxy(CacheProxyType type) {\n+        switch (type) {\n+            case BE:\n+                return new CacheBeProxy();\n+            case FE:\n+            case OUTER:\n+                return null;\n+        }\n+        return null;\n+    }\n+\n+    public abstract void updateCache(UpdateCacheRequest request, Status status);\n+\n+    public abstract FetchCacheResult fetchCache(FetchCacheRequest request, int timeoutMs, Status status);\n+\n+    public abstract void clearCache(PClearCacheRequest clearRequest);\n+\n+\n+    public static PUniqueId getMd5(String str) {\n+        MessageDigest msgDigest;\n+        try {\n+            //128 bit\n+            msgDigest = MessageDigest.getInstance(\"MD5\");\n+        } catch (Exception e) {\n+            return null;\n+        }\n+        final byte[] digest = msgDigest.digest(str.getBytes());\n+        PUniqueId key = new PUniqueId();\n+        key.lo = getLong(digest, 0);//64 bit\n+        key.hi = getLong(digest, 8);//64 bit\n+        return key;\n+    }\n+\n+    public static final long getLong(final byte[] array, final int offset) {", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQyNDk3NQ==", "url": "https://github.com/apache/incubator-doris/pull/4248#discussion_r465424975", "bodyText": "Would better make the 10000 static const value. In the future, we maybe need it to be configurable.", "author": "kangkaisen", "createdAt": "2020-08-05T01:50:07Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheBeProxy.java", "diffHunk": "@@ -0,0 +1,167 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.proto.PCacheStatus;\n+import org.apache.doris.proto.PCacheResponse;\n+import org.apache.doris.proto.PUpdateCacheRequest;\n+import org.apache.doris.proto.PFetchCacheRequest;\n+import org.apache.doris.proto.PFetchCacheResult;\n+import org.apache.doris.proto.PClearType;\n+import org.apache.doris.proto.PClearCacheRequest;\n+import org.apache.doris.qe.SimpleScheduler;\n+import org.apache.doris.rpc.BackendServiceProxy;\n+import org.apache.doris.rpc.RpcException;\n+import org.apache.doris.system.Backend;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.proto.PUniqueId;\n+import org.apache.doris.thrift.TNetworkAddress;\n+\n+import org.apache.doris.thrift.TStatusCode;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.List;\n+\n+/**\n+ * Encapsulates access to BE, including network and other exception handlin\n+ */\n+public class CacheBeProxy extends CacheProxy {\n+    private static final Logger LOG = LogManager.getLogger(CacheBeProxy.class);\n+\n+    public void updateCache(UpdateCacheRequest request, Status status) {\n+        PUniqueId sqlKey = request.sql_key;\n+        Backend backend = CacheCoordinator.getInstance().findBackend(sqlKey);\n+        if (backend == null) {\n+            LOG.warn(\"update cache can't find backend, sqlKey {}\", sqlKey);\n+            return;\n+        }\n+        TNetworkAddress address = new TNetworkAddress(backend.getHost(), backend.getBrpcPort());\n+        try {\n+            PUpdateCacheRequest updateRequest = request.getRpcRequest();\n+            Future<PCacheResponse> future = BackendServiceProxy.getInstance().updateCache(address, updateRequest);\n+            PCacheResponse response = future.get(10000,TimeUnit.MICROSECONDS);", "originalCommit": "ae3682141c19f5f539ffb94a7fa2dec627ea8b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "48b1efb950ba3131f4b513b420aeb7354ed006c8", "url": "https://github.com/apache/incubator-doris/commit/48b1efb950ba3131f4b513b420aeb7354ed006c8", "message": "Adjusted the formatting code, naming and variables according to the comments", "committedDate": "2020-08-05T08:01:16Z", "type": "commit"}]}