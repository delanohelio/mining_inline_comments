{"pr_number": 3715, "pr_title": "[Spark load][Fe 3/5] Fe create job", "pr_createdAt": "2020-05-28T12:23:59Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3715", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwODk2OQ==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432208969", "bodyText": "Is this OK to put a new State in the middle of original states?", "author": "imay", "createdAt": "2020-05-29T01:27:50Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/JobState.java", "diffHunk": "@@ -21,6 +21,7 @@\n public enum JobState {\n     UNKNOWN, // this is only for ISSUE #2354\n     PENDING, // init state\n+    ETL,     // load data partition, sort and aggregation with etl cluster", "originalCommit": "5315bd408b27c6b06c34a39bf4e5a69f6d9bcd71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5NzMzNQ==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432797335", "bodyText": "JobState will be persisted in meta data by name, so the order of these state is not important", "author": "wyb", "createdAt": "2020-05-30T01:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwODk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTQ1Nw==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432209457", "bodyText": "use JSON to serialize", "author": "imay", "createdAt": "2020-05-29T01:29:49Z", "path": "fe/src/main/java/org/apache/doris/analysis/ResourceDesc.java", "diffHunk": "@@ -0,0 +1,121 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.analysis;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Resource;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.common.io.Text;\n+import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.util.PrintableMap;\n+import org.apache.doris.load.EtlJobType;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+// Resource descriptor\n+//\n+// Spark example:\n+// WITH RESOURCE \"spark0\"\n+// (\n+//   \"spark.jars\" = \"xxx.jar,yyy.jar\",\n+//   \"spark.files\" = \"/tmp/aaa,/tmp/bbb\",\n+//   \"spark.executor.memory\" = \"1g\",\n+//   \"spark.yarn.queue\" = \"queue0\"\n+// )\n+public class ResourceDesc implements Writable {\n+    protected String name;\n+    protected Map<String, String> properties;\n+    protected EtlJobType etlJobType;\n+\n+    // Only used for recovery\n+    private ResourceDesc() {\n+    }\n+\n+    public ResourceDesc(String name, Map<String, String> properties) {\n+        this.name = name;\n+        this.properties = properties;\n+        if (this.properties == null) {\n+            this.properties = Maps.newHashMap();\n+        }\n+        this.etlJobType = EtlJobType.UNKNOWN;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Map<String, String> getProperties() {\n+        return properties;\n+    }\n+\n+    public EtlJobType getEtlJobType() {\n+        return etlJobType;\n+    }\n+\n+    public void analyze() throws AnalysisException {\n+        // check resource exist or not\n+        Resource resource = Catalog.getCurrentCatalog().getResourceMgr().getResource(getName());\n+        if (resource == null) {\n+            throw new AnalysisException(\"Resource does not exist. name: \" + getName());\n+        }\n+        if (resource.getType() == Resource.ResourceType.SPARK) {\n+            etlJobType = EtlJobType.SPARK;\n+        }\n+    }\n+\n+    @Override\n+    public void write(DataOutput out) throws IOException {", "originalCommit": "5315bd408b27c6b06c34a39bf4e5a69f6d9bcd71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5NzkxNw==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432797917", "bodyText": "I remove this serialization, because it is not used", "author": "wyb", "createdAt": "2020-05-30T01:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTg1OA==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432209858", "bodyText": "This is not a good idea to make Broker to extends Resource. I think they are two things", "author": "imay", "createdAt": "2020-05-29T01:31:22Z", "path": "fe/src/main/java/org/apache/doris/analysis/BrokerDesc.java", "diffHunk": "@@ -17,61 +17,36 @@\n \n package org.apache.doris.analysis;\n \n-import org.apache.doris.common.io.Text;\n-import org.apache.doris.common.io.Writable;\n+import org.apache.doris.common.AnalysisException;\n+import org.apache.doris.load.EtlJobType;\n import org.apache.doris.common.util.PrintableMap;\n \n-import com.google.common.collect.Maps;\n-\n import java.io.DataInput;\n-import java.io.DataOutput;\n import java.io.IOException;\n import java.util.Map;\n \n // Broker descriptor\n-public class BrokerDesc implements Writable {\n-    private String name;\n-    private Map<String, String> properties;\n-\n+//\n+// Broker example:\n+// WITH BROKER \"broker0\"\n+// (\n+//   \"username\" = \"user0\",\n+//   \"password\" = \"password0\"\n+// )\n+public class BrokerDesc extends ResourceDesc {", "originalCommit": "5315bd408b27c6b06c34a39bf4e5a69f6d9bcd71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5NzM4Mg==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432797382", "bodyText": "ok", "author": "wyb", "createdAt": "2020-05-30T01:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5ODU3OQ==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432798579", "bodyText": "I think 1 day is long enough~", "author": "morningman", "createdAt": "2020-05-30T01:39:45Z", "path": "fe/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -491,6 +491,12 @@\n     @ConfField(mutable = true, masterOnly = true)\n     public static int hadoop_load_default_timeout_second = 86400 * 3; // 3 day\n \n+    /*\n+     * Default spark load timeout\n+     */\n+    @ConfField(mutable = true, masterOnly = true)\n+    public static int spark_load_default_timeout_second = 86400 * 3; // 3 days", "originalCommit": "79b3089908e163e21d2a168a118e0ff13278bb63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTA0Nw==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432799047", "bodyText": "I think brokerDesc should be in the subclass of BulkLoadJob.\nAlthough currently both broker load and spark load need a broker, but for spark load, it may not be required in future.", "author": "morningman", "createdAt": "2020-05-30T01:46:29Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BulkLoadJob.java", "diffHunk": "@@ -0,0 +1,328 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.apache.doris.analysis.BrokerDesc;\n+import org.apache.doris.analysis.DataDescription;\n+import org.apache.doris.analysis.LoadStmt;\n+import org.apache.doris.analysis.SqlParser;\n+import org.apache.doris.analysis.SqlScanner;\n+import org.apache.doris.catalog.AuthorizationInfo;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Database;\n+import org.apache.doris.catalog.Table;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.FeMetaVersion;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.common.io.Text;\n+import org.apache.doris.common.util.LogBuilder;\n+import org.apache.doris.common.util.LogKey;\n+import org.apache.doris.common.util.SqlParserUtils;\n+import org.apache.doris.load.BrokerFileGroup;\n+import org.apache.doris.load.BrokerFileGroupAggInfo;\n+import org.apache.doris.load.FailMsg;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.qe.OriginStatement;\n+import org.apache.doris.qe.SessionVariable;\n+import org.apache.doris.qe.SqlModeHelper;\n+import org.apache.doris.transaction.TabletCommitInfo;\n+import org.apache.doris.transaction.TransactionState;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * parent class of BrokerLoadJob and SparkLoadJob from load stmt\n+ */\n+public abstract class BulkLoadJob extends LoadJob {\n+    private static final Logger LOG = LogManager.getLogger(BulkLoadJob.class);\n+\n+    // input params\n+    protected BrokerDesc brokerDesc;", "originalCommit": "79b3089908e163e21d2a168a118e0ff13278bb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMwOTEzOA==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r433309138", "bodyText": "After discussion with @morningman, I will improve this later, including persistence with json", "author": "wyb", "createdAt": "2020-06-01T15:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTQxMw==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432799413", "bodyText": "this property is hard to understand and is coupled with the detail implementation of the global dict.\nHow about changing it to a more abstract nouns?", "author": "morningman", "createdAt": "2020-05-30T01:51:39Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/SparkLoadJob.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import com.google.common.base.Strings;\n+import org.apache.doris.analysis.BrokerDesc;\n+import org.apache.doris.analysis.ResourceDesc;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Resource;\n+import org.apache.doris.catalog.SparkResource;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.common.io.Text;\n+import org.apache.doris.load.EtlJobType;\n+import org.apache.doris.load.FailMsg;\n+import org.apache.doris.qe.OriginStatement;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.PushTask;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.spark.launcher.SparkAppHandle;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * There are 4 steps in SparkLoadJob:\n+ * Step1: SparkLoadPendingTask will be created by unprotectedExecuteJob method and submit spark etl job.\n+ * Step2: LoadEtlChecker will check spark etl job status periodly and send push tasks to be when spark etl job is finished.\n+ * Step3: LoadLoadingChecker will check loading status periodly and commit transaction when push tasks are finished.\n+ * Step4: PublishVersionDaemon will send publish version tasks to be and finish transaction.\n+ */\n+public class SparkLoadJob extends BulkLoadJob {\n+    private static final Logger LOG = LogManager.getLogger(SparkLoadJob.class);\n+\n+    // for global dict\n+    public static final String BITMAP_DATA_PROPERTY = \"bitmap_data\";", "originalCommit": "79b3089908e163e21d2a168a118e0ff13278bb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMxMzQ1MA==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r433313450", "bodyText": "This is for temporary use. I am investigating load from hive table, and i will update it recently.", "author": "wyb", "createdAt": "2020-06-01T15:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTQ5OA==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432799498", "bodyText": "Why using Preconditions here?\nIt may be some other kind of resource.", "author": "morningman", "createdAt": "2020-05-30T01:52:49Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/SparkLoadJob.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import com.google.common.base.Strings;\n+import org.apache.doris.analysis.BrokerDesc;\n+import org.apache.doris.analysis.ResourceDesc;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Resource;\n+import org.apache.doris.catalog.SparkResource;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.common.io.Text;\n+import org.apache.doris.load.EtlJobType;\n+import org.apache.doris.load.FailMsg;\n+import org.apache.doris.qe.OriginStatement;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.PushTask;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.spark.launcher.SparkAppHandle;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * There are 4 steps in SparkLoadJob:\n+ * Step1: SparkLoadPendingTask will be created by unprotectedExecuteJob method and submit spark etl job.\n+ * Step2: LoadEtlChecker will check spark etl job status periodly and send push tasks to be when spark etl job is finished.\n+ * Step3: LoadLoadingChecker will check loading status periodly and commit transaction when push tasks are finished.\n+ * Step4: PublishVersionDaemon will send publish version tasks to be and finish transaction.\n+ */\n+public class SparkLoadJob extends BulkLoadJob {\n+    private static final Logger LOG = LogManager.getLogger(SparkLoadJob.class);\n+\n+    // for global dict\n+    public static final String BITMAP_DATA_PROPERTY = \"bitmap_data\";\n+\n+    // --- members below need persist ---\n+    // create from resourceDesc when job created\n+    private SparkResource sparkResource;\n+    // members below updated when job state changed to etl\n+    private long etlStartTimestamp = -1;\n+    // for spark yarn\n+    private String appId = \"\";\n+    // spark job outputPath\n+    private String etlOutputPath = \"\";\n+    // members below updated when job state changed to loading\n+    // { tableId.partitionId.indexId.bucket.schemaHash -> (etlFilePath, etlFileSize) }\n+    private Map<String, Pair<String, Long>> tabletMetaToFileInfo = Maps.newHashMap();\n+\n+    // --- members below not persist ---\n+    // temporary use\n+    // one SparkLoadJob has only one table to load\n+    // hivedb.table for global dict\n+    private String hiveTableName = \"\";\n+    private ResourceDesc resourceDesc;\n+    // for spark standalone\n+    private SparkAppHandle sparkAppHandle;\n+    // for straggler wait long time to commit transaction\n+    private long quorumFinishTimestamp = -1;\n+    // below for push task\n+    private Map<Long, Set<Long>> tableToLoadPartitions = Maps.newHashMap();\n+    //private Map<Long, PushBrokerScannerParams> indexToPushBrokerReaderParams = Maps.newHashMap();\n+    private Map<Long, Integer> indexToSchemaHash = Maps.newHashMap();\n+    private Map<Long, Map<Long, PushTask>> tabletToSentReplicaPushTask = Maps.newHashMap();\n+    private Set<Long> finishedReplicas = Sets.newHashSet();\n+    private Set<Long> quorumTablets = Sets.newHashSet();\n+    private Set<Long> fullTablets = Sets.newHashSet();\n+\n+    // only for log replay\n+    public SparkLoadJob() {\n+        super();\n+        jobType = EtlJobType.SPARK;\n+    }\n+\n+    public SparkLoadJob(long dbId, String label, ResourceDesc resourceDesc, OriginStatement originStmt)\n+            throws MetaNotFoundException {\n+        super(dbId, label, originStmt);\n+        this.resourceDesc = resourceDesc;\n+        timeoutSecond = Config.spark_load_default_timeout_second;\n+        jobType = EtlJobType.SPARK;\n+    }\n+\n+    public String getHiveTableName() {\n+        return hiveTableName;\n+    }\n+\n+    @Override\n+    protected void setJobProperties(Map<String, String> properties) throws DdlException {\n+        super.setJobProperties(properties);\n+\n+        // set spark resource and broker desc\n+        setResourceInfo();\n+\n+        // global dict\n+        if (properties != null) {\n+            if (properties.containsKey(BITMAP_DATA_PROPERTY)) {\n+                hiveTableName = properties.get(BITMAP_DATA_PROPERTY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * merge system conf with load stmt\n+     * @throws DdlException\n+     */\n+    private void setResourceInfo() throws DdlException {\n+        // spark resource\n+        String resourceName = resourceDesc.getName();\n+        Resource oriResource = Catalog.getCurrentCatalog().getResourceMgr().getResource(resourceName);\n+        if (oriResource == null) {\n+            throw new DdlException(\"Resource does not exist. name: \" + resourceName);\n+        }\n+        Preconditions.checkState(oriResource instanceof SparkResource);", "originalCommit": "79b3089908e163e21d2a168a118e0ff13278bb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE4MTE4Nw==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r433181187", "bodyText": "remove this check", "author": "wyb", "createdAt": "2020-06-01T11:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTYxOQ==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r432799619", "bodyText": "Save the error msg somewhere for user to get?", "author": "morningman", "createdAt": "2020-05-30T01:54:41Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/SparkLoadJob.java", "diffHunk": "@@ -0,0 +1,249 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import com.google.common.base.Strings;\n+import org.apache.doris.analysis.BrokerDesc;\n+import org.apache.doris.analysis.ResourceDesc;\n+import org.apache.doris.catalog.Catalog;\n+import org.apache.doris.catalog.Resource;\n+import org.apache.doris.catalog.SparkResource;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.MetaNotFoundException;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.common.io.Text;\n+import org.apache.doris.load.EtlJobType;\n+import org.apache.doris.load.FailMsg;\n+import org.apache.doris.qe.OriginStatement;\n+import org.apache.doris.task.AgentTaskQueue;\n+import org.apache.doris.task.PushTask;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.spark.launcher.SparkAppHandle;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * There are 4 steps in SparkLoadJob:\n+ * Step1: SparkLoadPendingTask will be created by unprotectedExecuteJob method and submit spark etl job.\n+ * Step2: LoadEtlChecker will check spark etl job status periodly and send push tasks to be when spark etl job is finished.\n+ * Step3: LoadLoadingChecker will check loading status periodly and commit transaction when push tasks are finished.\n+ * Step4: PublishVersionDaemon will send publish version tasks to be and finish transaction.\n+ */\n+public class SparkLoadJob extends BulkLoadJob {\n+    private static final Logger LOG = LogManager.getLogger(SparkLoadJob.class);\n+\n+    // for global dict\n+    public static final String BITMAP_DATA_PROPERTY = \"bitmap_data\";\n+\n+    // --- members below need persist ---\n+    // create from resourceDesc when job created\n+    private SparkResource sparkResource;\n+    // members below updated when job state changed to etl\n+    private long etlStartTimestamp = -1;\n+    // for spark yarn\n+    private String appId = \"\";\n+    // spark job outputPath\n+    private String etlOutputPath = \"\";\n+    // members below updated when job state changed to loading\n+    // { tableId.partitionId.indexId.bucket.schemaHash -> (etlFilePath, etlFileSize) }\n+    private Map<String, Pair<String, Long>> tabletMetaToFileInfo = Maps.newHashMap();\n+\n+    // --- members below not persist ---\n+    // temporary use\n+    // one SparkLoadJob has only one table to load\n+    // hivedb.table for global dict\n+    private String hiveTableName = \"\";\n+    private ResourceDesc resourceDesc;\n+    // for spark standalone\n+    private SparkAppHandle sparkAppHandle;\n+    // for straggler wait long time to commit transaction\n+    private long quorumFinishTimestamp = -1;\n+    // below for push task\n+    private Map<Long, Set<Long>> tableToLoadPartitions = Maps.newHashMap();\n+    //private Map<Long, PushBrokerScannerParams> indexToPushBrokerReaderParams = Maps.newHashMap();\n+    private Map<Long, Integer> indexToSchemaHash = Maps.newHashMap();\n+    private Map<Long, Map<Long, PushTask>> tabletToSentReplicaPushTask = Maps.newHashMap();\n+    private Set<Long> finishedReplicas = Sets.newHashSet();\n+    private Set<Long> quorumTablets = Sets.newHashSet();\n+    private Set<Long> fullTablets = Sets.newHashSet();\n+\n+    // only for log replay\n+    public SparkLoadJob() {\n+        super();\n+        jobType = EtlJobType.SPARK;\n+    }\n+\n+    public SparkLoadJob(long dbId, String label, ResourceDesc resourceDesc, OriginStatement originStmt)\n+            throws MetaNotFoundException {\n+        super(dbId, label, originStmt);\n+        this.resourceDesc = resourceDesc;\n+        timeoutSecond = Config.spark_load_default_timeout_second;\n+        jobType = EtlJobType.SPARK;\n+    }\n+\n+    public String getHiveTableName() {\n+        return hiveTableName;\n+    }\n+\n+    @Override\n+    protected void setJobProperties(Map<String, String> properties) throws DdlException {\n+        super.setJobProperties(properties);\n+\n+        // set spark resource and broker desc\n+        setResourceInfo();\n+\n+        // global dict\n+        if (properties != null) {\n+            if (properties.containsKey(BITMAP_DATA_PROPERTY)) {\n+                hiveTableName = properties.get(BITMAP_DATA_PROPERTY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * merge system conf with load stmt\n+     * @throws DdlException\n+     */\n+    private void setResourceInfo() throws DdlException {\n+        // spark resource\n+        String resourceName = resourceDesc.getName();\n+        Resource oriResource = Catalog.getCurrentCatalog().getResourceMgr().getResource(resourceName);\n+        if (oriResource == null) {\n+            throw new DdlException(\"Resource does not exist. name: \" + resourceName);\n+        }\n+        Preconditions.checkState(oriResource instanceof SparkResource);\n+        sparkResource = ((SparkResource) oriResource).getCopiedResource();\n+        sparkResource.update(resourceDesc);\n+\n+        // broker desc\n+        Map<String, String> brokerProperties = sparkResource.getBrokerPropertiesWithoutPrefix();\n+        brokerDesc = new BrokerDesc(sparkResource.getBroker(), brokerProperties);\n+    }\n+\n+    /**\n+     * load job already cancelled or finished, clear job below:\n+     * 1. kill etl job and delete etl files\n+     * 2. clear push tasks and infos that not persist\n+     */\n+    private void clearJob() {\n+        Preconditions.checkState(state == JobState.FINISHED || state == JobState.CANCELLED);\n+\n+        LOG.debug(\"kill etl job and delete etl files. id: {}, state: {}\", id, state);\n+        // TODO(wyb): spark-load\n+        //SparkEtlJobHandler handler = new SparkEtlJobHandler();\n+        if (state == JobState.CANCELLED) {\n+            if ((!Strings.isNullOrEmpty(appId) && sparkResource.isYarnMaster()) || sparkAppHandle != null) {\n+                try {\n+                    // TODO(wyb): spark-load\n+                    //handler.killEtlJob(sparkAppHandle, appId, id, sparkResource);\n+                } catch (Exception e) {\n+                    LOG.warn(\"kill etl job failed. id: {}, state: {}\", id, state, e);", "originalCommit": "79b3089908e163e21d2a168a118e0ff13278bb63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzMyMjgzNg==", "url": "https://github.com/apache/incubator-doris/pull/3715#discussion_r433322836", "bodyText": "I think it\u2019s not necessary, because clear job is just trying to kill etl job as much as possible.", "author": "wyb", "createdAt": "2020-06-01T15:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTYxOQ=="}], "type": "inlineReview"}, {"oid": "edfa6683fc8d3cee5d2ee29ba28bad3093efb99f", "url": "https://github.com/apache/incubator-doris/commit/edfa6683fc8d3cee5d2ee29ba28bad3093efb99f", "message": "Add create spark load job", "committedDate": "2020-06-03T13:27:27Z", "type": "commit"}, {"oid": "edfa6683fc8d3cee5d2ee29ba28bad3093efb99f", "url": "https://github.com/apache/incubator-doris/commit/edfa6683fc8d3cee5d2ee29ba28bad3093efb99f", "message": "Add create spark load job", "committedDate": "2020-06-03T13:27:27Z", "type": "forcePushed"}, {"oid": "7f6a7c6807334cfd4ee9042bbaa41576a55f3cf5", "url": "https://github.com/apache/incubator-doris/commit/7f6a7c6807334cfd4ee9042bbaa41576a55f3cf5", "message": "Remove unused import", "committedDate": "2020-06-03T14:32:52Z", "type": "commit"}]}