{"pr_number": 4430, "pr_title": "[ODBC SCAN NODE] 3/4 Add ODBC_TABLE and ODBC_SCAN NODE in FE.", "pr_createdAt": "2020-08-24T04:12:01Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4430", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMjExNQ==", "url": "https://github.com/apache/incubator-doris/pull/4430#discussion_r476402115", "bodyText": "Would better Serde by json", "author": "kangkaisen", "createdAt": "2020-08-25T12:16:41Z", "path": "fe/fe-core/src/main/java/org/apache/doris/catalog/OdbcTable.java", "diffHunk": "@@ -0,0 +1,296 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.catalog;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.doris.common.DdlException;\n+import org.apache.doris.common.io.Text;\n+import org.apache.doris.thrift.TOdbcTable;\n+import org.apache.doris.thrift.TTableDescriptor;\n+import org.apache.doris.thrift.TTableType;\n+import org.apache.doris.thrift.TOdbcTableType;\n+\n+import com.google.common.base.Strings;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.zip.Adler32;\n+\n+public class OdbcTable extends Table {\n+    private static final Logger LOG = LogManager.getLogger(OlapTable.class);\n+\n+    private static final String ODBC_HOST = \"host\";\n+    private static final String ODBC_PORT = \"port\";\n+    private static final String ODBC_USER = \"user\";\n+    private static final String ODBC_PASSWORD = \"password\";\n+    private static final String ODBC_DATABASE = \"database\";\n+    private static final String ODBC_TABLE = \"table\";\n+    private static final String ODBC_DRIVER = \"driver\";\n+    private static final String ODBC_TYPE = \"type\";\n+\n+    private static Map<String, TOdbcTableType> TABLE_TYPE_MAP;\n+    static {\n+        Map<String, TOdbcTableType> tempMap = new HashMap<>();\n+        tempMap.put(\"oracle\", TOdbcTableType.ORACLE);\n+        // we will support mysql driver in the future after we slove the core problem of\n+        // driver and static library\n+        //tempMap.put(\"mysql\", TOdbcTableType.MYSQL);\n+        TABLE_TYPE_MAP = Collections.unmodifiableMap(tempMap);\n+    }\n+\n+    private String host;\n+    private String port;\n+    private String userName;\n+    private String passwd;\n+    private String odbcDatabaseName;\n+    private String odbcTableName;\n+    private String driver;\n+    private String odbcTableTypeName;\n+\n+    public OdbcTable() {\n+        super(TableType.ODBC);\n+    }\n+\n+    public OdbcTable(long id, String name, List<Column> schema, Map<String, String> properties)\n+            throws DdlException {\n+        super(id, name, TableType.ODBC, schema);\n+        validate(properties);\n+    }\n+\n+    private void validate(Map<String, String> properties) throws DdlException {\n+        if (properties == null) {\n+            throw new DdlException(\"Please set properties of odbc table, \"\n+                    + \"they are: host, port, user, password, database and table\");\n+        }\n+\n+        // Set up\n+        host = properties.get(ODBC_HOST);\n+        if (Strings.isNullOrEmpty(host)) {\n+            throw new DdlException(\"Host of Odbc table is null. \"\n+                    + \"Please add properties('host'='xxx.xxx.xxx.xxx') when create table\");\n+        }\n+\n+        port = properties.get(ODBC_PORT);\n+        if (Strings.isNullOrEmpty(port)) {\n+            // Maybe null pointer or number convert\n+            throw new DdlException(\"Port of Odbc table is null. \"\n+                    + \"Please add properties('port'='3306') when create table\");\n+        } else {\n+            try {\n+                Integer.valueOf(port);\n+            } catch (Exception e) {\n+                throw new DdlException(\"Port of Odbc table must be a number.\"\n+                        + \"Please add properties('port'='3306') when create table\");\n+\n+            }\n+        }\n+\n+        userName = properties.get(ODBC_USER);\n+        if (Strings.isNullOrEmpty(userName)) {\n+            throw new DdlException(\"User of Odbc table is null. \"\n+                    + \"Please add properties('user'='root') when create table\");\n+        }\n+\n+        passwd = properties.get(ODBC_PASSWORD);\n+        if (passwd == null) {\n+            throw new DdlException(\"Password of Odbc table is null. \"\n+                    + \"Please add properties('password'='xxxx') when create table\");\n+        }\n+\n+        odbcDatabaseName = properties.get(ODBC_DATABASE);\n+        if (Strings.isNullOrEmpty(odbcDatabaseName)) {\n+            throw new DdlException(\"Database of Odbc table is null. \"\n+                    + \"Please add properties('database'='xxxx') when create table\");\n+        }\n+\n+        odbcTableName = properties.get(ODBC_TABLE);\n+        if (Strings.isNullOrEmpty(odbcTableName)) {\n+            throw new DdlException(\"Database of Odbc table is null. \"\n+                    + \"Please add properties('table'='xxxx') when create table\");\n+        }\n+\n+        driver = properties.get(ODBC_DRIVER);\n+        if (Strings.isNullOrEmpty(driver)) {\n+            throw new DdlException(\"Driver of Odbc table is null. \"\n+                    + \"Please add properties('diver'='xxxx') when create table\");\n+        }\n+\n+        String tableType = properties.get(ODBC_TYPE);\n+        if (Strings.isNullOrEmpty(tableType)) {\n+            throw new DdlException(\"Type of Odbc table is null. \"\n+                    + \"Please add properties('type'='xxxx') when create table\");\n+        } else {\n+            odbcTableTypeName = tableType.toLowerCase();\n+            if (!TABLE_TYPE_MAP.containsKey(odbcTableTypeName)) {\n+                throw new DdlException(\"Invaild Odbc table type:\" + tableType\n+                + \" Now Odbc table type only support:\" + supportTableType());\n+            }\n+        }\n+    }\n+\n+    public String getHost() {\n+        return host;\n+    }\n+\n+    public String getPort() {\n+        return port;\n+    }\n+\n+    public String getUserName() {\n+        return userName;\n+    }\n+\n+    public String getPasswd() {\n+        return passwd;\n+    }\n+\n+    public String getOdbcDatabaseName() {\n+        return odbcDatabaseName;\n+    }\n+\n+    public String getOdbcTableName() {\n+        return odbcTableName;\n+    }\n+\n+    public String getOdbcDriver() {\n+        return driver;\n+    }\n+\n+    public String getOdbcTableTypeName() {\n+        return odbcTableTypeName;\n+    }\n+\n+    public TOdbcTableType getOdbcTableType() {\n+        return TABLE_TYPE_MAP.get(odbcTableTypeName);\n+    }\n+\n+    public TTableDescriptor toThrift() {\n+        TOdbcTable tOdbcTable =\n+                new TOdbcTable();\n+\n+        tOdbcTable.host = host;\n+        tOdbcTable.port = port;\n+        tOdbcTable.user = userName;\n+        tOdbcTable.passwd = passwd;\n+        tOdbcTable.db = odbcDatabaseName;\n+        tOdbcTable.table = odbcTableName;\n+        tOdbcTable.driver = driver;\n+        tOdbcTable.type = getOdbcTableType();\n+\n+        TTableDescriptor tTableDescriptor = new TTableDescriptor(getId(), TTableType.ODBC_TABLE,\n+                fullSchema.size(), 0, getName(), \"\");\n+        tTableDescriptor.setOdbcTable(tOdbcTable);\n+        return tTableDescriptor;\n+    }\n+\n+    @Override\n+    public int getSignature(int signatureVersion) {\n+        Adler32 adler32 = new Adler32();\n+        adler32.update(signatureVersion);\n+        String charsetName = \"UTF-8\";\n+\n+        try {\n+            // name\n+            adler32.update(name.getBytes(charsetName));\n+            // type\n+            adler32.update(type.name().getBytes(charsetName));\n+            // host\n+            adler32.update(host.getBytes(charsetName));\n+            // port\n+            adler32.update(port.getBytes(charsetName));\n+            // username\n+            adler32.update(userName.getBytes(charsetName));\n+            // passwd\n+            adler32.update(passwd.getBytes(charsetName));\n+            // odbc db\n+            adler32.update(odbcDatabaseName.getBytes(charsetName));\n+            // odbc table\n+            adler32.update(odbcTableName.getBytes(charsetName));\n+            // odbc driver\n+            adler32.update(driver.getBytes(charsetName));\n+            // odbc type\n+            adler32.update(odbcTableTypeName.getBytes(charsetName));\n+        } catch (UnsupportedEncodingException e) {\n+            LOG.error(\"encoding error\", e);\n+            return -1;\n+        }\n+\n+        return Math.abs((int) adler32.getValue());\n+    }\n+\n+    @Override\n+    public void write(DataOutput out) throws IOException {\n+        super.write(out);\n+\n+        Map<String, String> serializeMap = Maps.newHashMap();", "originalCommit": "5f7a62a304aa42ce2a4699ea16d883333626524f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMjc3Nw==", "url": "https://github.com/apache/incubator-doris/pull/4430#discussion_r476402777", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // this is just to avoid mysql scan node's cardinality being -1. So that we can calculate the join cost\n          \n          \n            \n                    // this is just to avoid odbc scan node's cardinality being -1. So that we can calculate the join cost", "author": "kangkaisen", "createdAt": "2020-08-25T12:17:55Z", "path": "fe/fe-core/src/main/java/org/apache/doris/planner/OdbcScanNode.java", "diffHunk": "@@ -0,0 +1,200 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.planner;\n+\n+import com.google.common.base.CharMatcher;\n+import org.apache.doris.analysis.Analyzer;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.ExprSubstitutionMap;\n+import org.apache.doris.analysis.SlotDescriptor;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.analysis.TupleDescriptor;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.OdbcTable;\n+import org.apache.doris.common.UserException;\n+import org.apache.doris.thrift.TExplainLevel;\n+import org.apache.doris.thrift.TOdbcScanNode;\n+import org.apache.doris.thrift.TOdbcTableType;\n+import org.apache.doris.thrift.TPlanNode;\n+import org.apache.doris.thrift.TPlanNodeType;\n+import org.apache.doris.thrift.TScanRangeLocations;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Lists;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Full scan of an ODBC table.\n+ */\n+public class OdbcScanNode extends ScanNode {\n+    private static final Logger LOG = LogManager.getLogger(OdbcScanNode.class);\n+\n+    private static String mysqlProperName(String name) {\n+        return \"`\" + name + \"`\";\n+    }\n+\n+    private static String databaseProperName(TOdbcTableType tableType, String name) {\n+        switch (tableType) {\n+            case MYSQL:\n+                return mysqlProperName(name);\n+        }\n+\n+        return name;\n+    }\n+\n+    // now we do not support push down filter with char not in ASCII\n+    private static boolean isASCIIString(String filter) {\n+        return CharMatcher.ascii().matchesAllOf(filter);\n+    }\n+\n+    private final List<String> columns = new ArrayList<String>();\n+    private final List<String> filters = new ArrayList<String>();\n+    private String tblName;\n+    private String driver;\n+    private TOdbcTableType odbcType;\n+\n+    /**\n+     * Constructs node to scan given data files of table 'tbl'.\n+     */\n+    public OdbcScanNode(PlanNodeId id, TupleDescriptor desc, OdbcTable tbl) {\n+        super(id, desc, \"SCAN ODBC\");\n+        driver = tbl.getOdbcDriver();\n+        odbcType = tbl.getOdbcTableType();\n+        tblName = databaseProperName(odbcType, tbl.getOdbcTableName());\n+    }\n+\n+    @Override\n+    protected String debugString() {\n+        MoreObjects.ToStringHelper helper = MoreObjects.toStringHelper(this);\n+        return helper.addValue(super.debugString()).toString();\n+    }\n+\n+    @Override\n+    public void finalize(Analyzer analyzer) throws UserException {\n+        // Convert predicates to Odbc columns and filters.\n+        createOdbcColumns(analyzer);\n+        createOdbcFilters(analyzer);\n+        computeStats(analyzer);\n+    }\n+\n+    @Override\n+    protected String getNodeExplainString(String prefix, TExplainLevel detailLevel) {\n+        StringBuilder output = new StringBuilder();\n+        output.append(prefix).append(\"TABLE: \").append(tblName).append(\"\\n\");\n+        output.append(prefix).append(\"Query: \").append(getOdbcQueryStr()).append(\"\\n\");\n+        return output.toString();\n+    }\n+\n+    private String getOdbcQueryStr() {\n+        StringBuilder sql = new StringBuilder(\"SELECT \");\n+        sql.append(Joiner.on(\", \").join(columns));\n+        sql.append(\" FROM \").append(tblName);\n+\n+        if (!filters.isEmpty()) {\n+            sql.append(\" WHERE (\");\n+            sql.append(Joiner.on(\") AND (\").join(filters));\n+            sql.append(\")\");\n+        }\n+        return sql.toString();\n+    }\n+\n+    private void createOdbcColumns(Analyzer analyzer) {\n+        for (SlotDescriptor slot : desc.getSlots()) {\n+            if (!slot.isMaterialized()) {\n+                continue;\n+            }\n+            Column col = slot.getColumn();\n+            columns.add(databaseProperName(odbcType, col.getName()));\n+        }\n+        // this happens when count(*)\n+        if (0 == columns.size()) {\n+            columns.add(\"*\");\n+        }\n+    }\n+\n+    // We convert predicates of the form <slotref> op <constant> to Odbc filters\n+    private void createOdbcFilters(Analyzer analyzer) {\n+        if (conjuncts.isEmpty()) {\n+            return;\n+\n+        }\n+        List<SlotRef> slotRefs = Lists.newArrayList();\n+        Expr.collectList(conjuncts, SlotRef.class, slotRefs);\n+        ExprSubstitutionMap sMap = new ExprSubstitutionMap();\n+        for (SlotRef slotRef : slotRefs) {\n+            SlotRef tmpRef = (SlotRef) slotRef.clone();\n+            tmpRef.setTblName(null);\n+            tmpRef.setLabel(databaseProperName(odbcType, tmpRef.getColumnName()));\n+            sMap.put(slotRef, tmpRef);\n+        }\n+        ArrayList<Expr> odbcConjuncts = Expr.cloneList(conjuncts, sMap);\n+        for (Expr p : odbcConjuncts) {\n+            String filter = p.toMySql();\n+            if (isASCIIString(filter)) {\n+                filters.add(filter);\n+                conjuncts.remove(p);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void toThrift(TPlanNode msg) {\n+        msg.node_type = TPlanNodeType.ODBC_SCAN_NODE;\n+\n+        TOdbcScanNode odbcScanNode = new TOdbcScanNode();\n+        odbcScanNode.tuple_id = desc.getId().asInt();\n+        odbcScanNode.table_name = tblName;\n+        odbcScanNode.driver = driver;\n+        odbcScanNode.type = odbcType;\n+        odbcScanNode.columns = columns;\n+        odbcScanNode.filters = filters;\n+\n+        msg.odbc_scan_node = odbcScanNode;\n+    }\n+\n+    /**\n+     * We query Odbc Meta to get request's data location\n+     * extra result info will pass to backend ScanNode\n+     */\n+    @Override\n+    public List<TScanRangeLocations> getScanRangeLocations(long maxScanRangeLength) {\n+        return null;\n+    }\n+\n+    @Override\n+    public int getNumInstances() {\n+        return 1;\n+    }\n+\n+    @Override\n+    public void computeStats(Analyzer analyzer) {\n+        super.computeStats(analyzer);\n+        // even if current node scan has no data,at least on backend will be assigned when the fragment actually execute\n+        numNodes = numNodes <= 0 ? 1 : numNodes;\n+        // this is just to avoid mysql scan node's cardinality being -1. So that we can calculate the join cost", "originalCommit": "5f7a62a304aa42ce2a4699ea16d883333626524f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMzg0NA==", "url": "https://github.com/apache/incubator-doris/pull/4430#discussion_r476403844", "bodyText": "Add this config to FE config doc.", "author": "kangkaisen", "createdAt": "2020-08-25T12:19:48Z", "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -1146,6 +1146,12 @@\n     @ConfField(mutable = true, masterOnly = true)\n     public static boolean enable_spark_load = false;\n \n+    /**\n+     * enable use odbc table\n+     */\n+    @ConfField(mutable = true, masterOnly = true)\n+    public static boolean enable_odbc_table = false;", "originalCommit": "5f7a62a304aa42ce2a4699ea16d883333626524f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEwNDA1OQ==", "url": "https://github.com/apache/incubator-doris/pull/4430#discussion_r477104059", "bodyText": "Sorry\uff0c I forgot that. I will add it", "author": "HappenLee", "createdAt": "2020-08-26T07:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMzg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDc0ODM3Mg==", "url": "https://github.com/apache/incubator-doris/pull/4430#discussion_r480748372", "bodyText": "missing break;", "author": "morningman", "createdAt": "2020-09-01T04:03:55Z", "path": "fe/fe-core/src/main/java/org/apache/doris/load/ExportJob.java", "diffHunk": "@@ -284,6 +286,8 @@ private ScanNode genScanNode() throws UserException {\n                 scanNode.init(analyzer);\n                 ((OlapScanNode) scanNode).selectBestRollupByRollupSelector(analyzer);\n                 break;\n+            case ODBC:\n+                scanNode = new OdbcScanNode(new PlanNodeId(0), exportTupleDesc, (OdbcTable) this.exportTable);", "originalCommit": "3e34a5fcd479439ed79d53c2de7046aa11219e23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2248528aa16937da973c2d19edb49da579871aa", "url": "https://github.com/apache/incubator-doris/commit/b2248528aa16937da973c2d19edb49da579871aa", "message": "add break keyword", "committedDate": "2020-09-02T03:39:38Z", "type": "forcePushed"}, {"oid": "2685da7e0e24ae6089b41400267ba10f58687a56", "url": "https://github.com/apache/incubator-doris/commit/2685da7e0e24ae6089b41400267ba10f58687a56", "message": "fix the ut problem", "committedDate": "2020-09-02T07:49:12Z", "type": "forcePushed"}, {"oid": "70628e7f53c2639edc0a4ebc924f8dbdaa5b0c9c", "url": "https://github.com/apache/incubator-doris/commit/70628e7f53c2639edc0a4ebc924f8dbdaa5b0c9c", "message": "[ODBC SCAN NODE] 3/4 Add ODBC_TABLE and ODBC_SCAN NODE in FE.\n\nwe can create odbc_table use SQL like\n\n```\nCREATE EXTERNAL TABLE `baseall_oracle` (\n  `k1` decimal(9, 3) NOT NULL COMMENT \"\",\n  `k2` char(10) NOT NULL COMMENT \"\",\n  `k3` datetime NOT NULL COMMENT \"\",\n  `k5` varchar(20) NOT NULL COMMENT \"\",\n  `k6` double NOT NULL COMMENT \"\"\n) ENGINE=ODBC\nPROPERTIES (\n\"host\" = \"192.168.0.1\",\n\"port\" = \"8086\",\n\"user\" = \"happenlee\",\n\"password\" = \"doris\",\n\"database\" = \"doris\",\n\"table\" = \"baseall\",\n\"driver\" = \"Oracle 19 ODBC driver\",\n\"type\" = \"oracle\"\n);\n```\n\nNow we only support Oracle and MySQL Database and this feature default turned off by conf enable_odbc_table.", "committedDate": "2020-09-03T11:05:09Z", "type": "commit"}, {"oid": "c1fc4341e35f46423ed1e683646dcfb6526cc694", "url": "https://github.com/apache/incubator-doris/commit/c1fc4341e35f46423ed1e683646dcfb6526cc694", "message": "change some code and revise the fe_config.md", "committedDate": "2020-09-03T11:05:09Z", "type": "commit"}, {"oid": "c1c468d677d7ca3e14f60111b921e621a00f28f8", "url": "https://github.com/apache/incubator-doris/commit/c1c468d677d7ca3e14f60111b921e621a00f28f8", "message": "support filter push down in utf-8 coding", "committedDate": "2020-09-03T11:05:09Z", "type": "commit"}, {"oid": "47f66b0307382ae53a33b9be01af3a8c1eafb578", "url": "https://github.com/apache/incubator-doris/commit/47f66b0307382ae53a33b9be01af3a8c1eafb578", "message": "add break keyword", "committedDate": "2020-09-03T11:05:09Z", "type": "commit"}, {"oid": "29175896a0185dc6f455034aec44b46711364814", "url": "https://github.com/apache/incubator-doris/commit/29175896a0185dc6f455034aec44b46711364814", "message": "fix the ut problem", "committedDate": "2020-09-03T11:05:09Z", "type": "commit"}, {"oid": "29175896a0185dc6f455034aec44b46711364814", "url": "https://github.com/apache/incubator-doris/commit/29175896a0185dc6f455034aec44b46711364814", "message": "fix the ut problem", "committedDate": "2020-09-03T11:05:09Z", "type": "forcePushed"}]}