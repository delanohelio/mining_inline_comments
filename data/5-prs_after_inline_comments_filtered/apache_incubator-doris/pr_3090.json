{"pr_number": 3090, "pr_title": "(#3088) Support Java version 64 bits Integers for BITMAP type", "pr_createdAt": "2020-03-12T08:45:54Z", "pr_url": "https://github.com/apache/incubator-doris/pull/3090", "timeline": [{"oid": "d21566232411809199e0cf9ac6c208e555cdd454", "url": "https://github.com/apache/incubator-doris/commit/d21566232411809199e0cf9ac6c208e555cdd454", "message": "(#3088) Support Java version 64 bits Integers for BITMAP type", "committedDate": "2020-03-12T08:42:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY3OTUzMw==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r391679533", "bodyText": "Why only support BITMAP64 and not support EMPTY, SINGLE32, BITMAP32, SINGLE64?\nPlease explain which concrete methods are custom.", "author": "kangkaisen", "createdAt": "2020-03-12T14:57:16Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1456 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+import org.roaringbitmap.longlong.Roaring64NavigableMap;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+\n+/**\n+ *  used in spark load progress to build 64 bits int bitmap\n+ *  forked from https://github.com/RoaringBitmap/RoaringBitmap/blob/RoaringBitmap-0.8.13/RoaringBitmap/src/main/java/org/roaringbitmap/longlong/Roaring64NavigableMap.java\n+ *  mainly overwrite serialize/deserialize method to keep the storage format consist with be's 64 bit int bitmap\n+ *  for bitmap using in doris,we don't care the way ordering long\n+ *  so disable constructor with args signedLongs and using the default order\n+ */\n+public class Roaring64Map {", "originalCommit": "d21566232411809199e0cf9ac6c208e555cdd454", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "628b0dba3e88a87adb2def6c30a389463f6b25ae", "url": "https://github.com/apache/incubator-doris/commit/628b0dba3e88a87adb2def6c30a389463f6b25ae", "message": "1 add ut\n2 add bitmapvalue", "committedDate": "2020-03-19T06:41:38Z", "type": "commit"}, {"oid": "792211134a47d85efb0480cc84a501c871262124", "url": "https://github.com/apache/incubator-doris/commit/792211134a47d85efb0480cc84a501c871262124", "message": "1 new method add(int)\n2 put 32bit integer and long type which fits 32bit  to container 0", "committedDate": "2020-03-20T11:46:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5MTk0NQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396191945", "bodyText": "4294967293 will return false.\nwhich is not consistent with is32BitsEnough in BE\nbool is32BitsEnough() const { return maximum() <= std::numeric_limits<uint32_t>::max(); }", "author": "kangkaisen", "createdAt": "2020-03-23T03:01:14Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,372 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  Keep compatibility with doris be's bitmap_value.h\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value){\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    // if singvalue is 32-bit enough,need to cast it to int and write to container at position 0 directly\n+                    if (isLongValue32bitEnough(singleValue)) {\n+                        bitmap.add((int)singleValue);\n+                    } else {\n+                        bitmap.add(singleValue);\n+                    }\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.add(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                if (isLongValue32bitEnough(value)) {\n+                    return bitmap.contains((int)value);\n+                } else {\n+                    return bitmap.contains(value);\n+                }\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = input.readInt();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (singleValue <= Integer.MAX_VALUE) {\n+                    size = 4;\n+                } else {\n+                    size = 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;\n+    }\n+\n+    private void convertToSmallerType() {\n+        if (bitmapType == BITMAP_VALUE) {\n+            if (bitmap.getLongCardinality() == 0) {\n+                this.bitmap = null;\n+                this.bitmapType = EMPTY;\n+            } else if (bitmap.getLongCardinality() == 1) {\n+                this.singleValue = bitmap.select(0);\n+                this.bitmapType = SINGLE_VALUE;\n+                this.bitmap = null;\n+            }\n+        }\n+    }\n+\n+    private boolean isLongValue32bitEnough(long value) {", "originalCommit": "792211134a47d85efb0480cc84a501c871262124", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyNjE2Nw==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396326167", "bodyText": "In java,32-bit integers can be represented and used with arithmetic operation using long.\nBut support 64-bit unsigned integer is really a complex thing in java system.\nSo here I think it's ok to support unsigned 32-bit integers in FE's bitmap.\nBut I prefer 64-bit unsigned integer not being considered for the time being.", "author": "wangbo", "createdAt": "2020-03-23T09:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5MTk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3NjU0Mg==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396876542", "bodyText": "OK", "author": "kangkaisen", "createdAt": "2020-03-24T02:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5MTk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396194344", "bodyText": "/**\n     * Add value x\n     *\n     */\n    void add(uint32_t x) {\n        roarings[0].add(x);\n        roarings[0].setCopyOnWrite(copyOnWrite);\n    }\n    void add(uint64_t x) {\n        roarings[highBytes(x)].add(lowBytes(x));\n        roarings[highBytes(x)].setCopyOnWrite(copyOnWrite);\n    }\n\nIn BE.  container 0 content is 0 ~ std::numeric_limits<uint32_t>::max()", "author": "kangkaisen", "createdAt": "2020-03-23T03:13:52Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n+     * to another, and from one RoaringBitmap version to another.\n+     *\n+     * Consider calling {@link #runOptimize} before serialization to improve compression.\n+     *\n+     * The current bitmap is not modified.\n+     *\n+     * @param out the DataOutput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void serialize(DataOutput out) throws IOException {\n+        if (highToBitmap.size() == 0) {\n+            return;\n+        }\n+        if (is32BitsEnough()) {\n+            out.write(BITMAP32);\n+            highToBitmap.get(0).serialize(out);\n+            return;\n+        }\n+\n+        out.write(BITMAP64);\n+        encodeVarint64(highToBitmap.size(), out);\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            out.writeInt(entry.getKey().intValue());\n+            entry.getValue().serialize(out);\n+        }\n+    }\n+\n+\n+    /**\n+     * Deserialize (retrieve) this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from one java version to\n+     * another, and from one RoaringBitmap version to another.\n+     *\n+     * The current bitmap is overwritten.\n+     *\n+     * @param in the DataInput stream\n+     * @throws IOException Signals that an I/O exception has occurred.\n+     */\n+    public void deserialize(DataInput in, int bitmapType) throws IOException {\n+        this.clear();\n+        highToBitmap = new TreeMap<>();\n+\n+        long nbHighs = 1;\n+        if (bitmapType == BITMAP64) {\n+            nbHighs = decodeVarint64(in);\n+        }\n+\n+        for (int i = 0; i < nbHighs; i++) {\n+            int high = in.readInt();\n+            RoaringBitmap provider = new RoaringBitmap();\n+            provider.deserialize(in);\n+\n+            highToBitmap.put(high, provider);\n+        }\n+\n+        resetPerfHelpers();\n+    }\n+\n+\n+\n+    /*---------------------------- method below is new written for doris's own bitmap --------------------------------*/\n+\n+    public boolean is32BitsEnough() {\n+        return highToBitmap.size() == 1 && highToBitmap.get(0) != null;\n+    }\n+\n+    public void add(long value) {\n+        addLong(value);\n+    }\n+\n+    public void add(int value) {", "originalCommit": "792211134a47d85efb0480cc84a501c871262124", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwMTE0OA==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396201148", "bodyText": "Java doesn't support unsigned integer directly, must use additional method to transfer which means we need to judge whether a integer value fits in unsigned 32-bit manually\nSo I don't think there is a graceful implementation to support unsigned integer in java.\nJava types is narrower than C++,So I think if we want to transfer bitmap between C++ and java,it's better to keep C++ compatible with java types actively.", "author": "wangbo", "createdAt": "2020-03-23T03:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIwMzQxNQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396203415", "bodyText": "In Java\uff0cwe could convert signed integer to unsigned integer easily.\nThere is no any reason to change C++ implementation, you should change java implementation.", "author": "kangkaisen", "createdAt": "2020-03-23T04:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyODc3NA==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396328774", "bodyText": "OK.\nNow for Doris's  BitmapValue,\njava version support range [0, Long.MAX_VALUE]\nC++ version support range [0,Long.MAX_VALUE * 2]", "author": "wangbo", "createdAt": "2020-03-23T09:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3NjYwMQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396876601", "bodyText": "OK", "author": "kangkaisen", "createdAt": "2020-03-24T02:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE5NDM0NA=="}], "type": "inlineReview"}, {"oid": "b96746713b8d4d93cabb832c3f3017fc385c727d", "url": "https://github.com/apache/incubator-doris/commit/b96746713b8d4d93cabb832c3f3017fc385c727d", "message": "cast input integer to unsigned long", "committedDate": "2020-03-23T13:11:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4MjcyNQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396882725", "bodyText": "Would better keep the method name and body consistent with BE implementation", "author": "kangkaisen", "createdAt": "2020-03-24T03:25:54Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;\n+    }\n+\n+    private void convertToSmallerType() {\n+        if (bitmapType == BITMAP_VALUE) {\n+            if (bitmap.getLongCardinality() == 0) {\n+                this.bitmap = null;\n+                this.bitmapType = EMPTY;\n+            } else if (bitmap.getLongCardinality() == 1) {\n+                this.singleValue = bitmap.select(0);\n+                this.bitmapType = SINGLE_VALUE;\n+                this.bitmap = null;\n+            }\n+        }\n+    }\n+\n+    private boolean isLongValue32bitEnough(long value) {\n+        return value >> 32 == 0;", "originalCommit": "b96746713b8d4d93cabb832c3f3017fc385c727d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMDE2NA==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396900164", "bodyText": "So here can use compare Integer.MAX_VALUE * 2 to instead of >>.\nBut be doesn't have isLongValue32bitEnough , I prefer to make it a method", "author": "wangbo", "createdAt": "2020-03-24T04:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4MjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NTUyOQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396885529", "bodyText": "would better use new Roaring64Map(), not null.", "author": "kangkaisen", "createdAt": "2020-03-24T03:37:58Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;", "originalCommit": "b96746713b8d4d93cabb832c3f3017fc385c727d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5OTc5NA==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396899794", "bodyText": "For status from bitmap to single value,calling clear()  is necessary.\nnew a bitmap here costs more memory;\nWe just need to keep the status transfer logic correct,NPE can be avoid.", "author": "wangbo", "createdAt": "2020-03-24T04:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjQyOQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396886429", "bodyText": "This check is unnecessary.\nIf you add this check, you must change the singleValue to invalid value when clear.", "author": "kangkaisen", "createdAt": "2020-03-24T03:42:27Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {", "originalCommit": "b96746713b8d4d93cabb832c3f3017fc385c727d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwMzM3OA==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396903378", "bodyText": "If user input two identical value in a row, the check can avoid the generation of a bitmap.\nAnd change singleValue to invalid is not a necessary operator, because single value must comes from empty,even after BitmapValue clear();", "author": "wangbo", "createdAt": "2020-03-24T05:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4Njk1NA==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396886954", "bodyText": "Would better change the singleValue to a negative value.", "author": "kangkaisen", "createdAt": "2020-03-24T03:44:50Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/BitmapValue.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *  doris's own java version bitmap\n+ *  try to keep compatibility with doris be's bitmap_value.h,but still has some difference from bitmap_value.h\n+ *  major difference from be:\n+ *      1. java bitmap support integer range [0, Long.MAX],while be's bitmap support range [0, Long.MAX * 2]\n+ *          Now Long.MAX_VALUE is enough for doris's spark load and support unsigned integer in java need to pay more\n+ *      2. getSizeInBytes method is different from fe to be, details description see method comment\n+ */\n+public class BitmapValue {\n+\n+    public static final int EMPTY = 0;\n+    public static final int SINGLE32 = 1;\n+    public static final int BITMAP32 = 2;\n+    public static final int SINGLE64 = 3;\n+    public static final int BITMAP64 = 4;\n+\n+    public static final int SINGLE_VALUE = 1;\n+    public static final int BITMAP_VALUE = 2;\n+\n+    private int bitmapType;\n+    private long singleValue;\n+    private Roaring64Map bitmap;\n+\n+    public BitmapValue() {\n+        bitmapType = EMPTY;\n+    }\n+\n+    public void add(int value) {\n+        add(Util.toUnsignedLong(value));\n+    }\n+\n+    public void add(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                singleValue = value;\n+                bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE_VALUE:\n+                if (this.singleValue != value) {\n+                    bitmap = new Roaring64Map();\n+                    bitmap.add(value);\n+                    bitmap.add(singleValue);\n+                    bitmapType = BITMAP_VALUE;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.addLong(value);\n+                break;\n+        }\n+    }\n+\n+    public boolean contains(int value) {\n+        return contains(Util.toUnsignedLong(value));\n+    }\n+\n+    public boolean contains(long value) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return false;\n+            case SINGLE_VALUE:\n+                return singleValue == value;\n+            case BITMAP_VALUE:\n+                return bitmap.contains(value);\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    public long cardinality() {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                return 0;\n+            case SINGLE_VALUE:\n+                return 1;\n+            case BITMAP_VALUE:\n+                return bitmap.getLongCardinality();\n+        }\n+        return 0;\n+    }\n+\n+    public void serialize(DataOutput output) throws IOException {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                output.writeByte(EMPTY);\n+                break;\n+            case SINGLE_VALUE:\n+                // is 32-bit enough\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    output.write(SINGLE32);\n+                    output.writeInt((int)singleValue);\n+                } else {\n+                    output.writeByte(SINGLE64);\n+                    output.writeLong(singleValue);\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                bitmap.serialize(output);\n+                break;\n+        }\n+    }\n+\n+    public void deserialize(DataInput input) throws IOException {\n+        clear();\n+        int bitmapType = input.readByte();\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE32:\n+                singleValue = Util.toUnsignedLong(input.readInt());\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case SINGLE64:\n+                singleValue = input.readLong();\n+                this.bitmapType = SINGLE_VALUE;\n+                break;\n+            case BITMAP32:\n+            case BITMAP64:\n+                bitmap = bitmap == null ? new Roaring64Map() : bitmap;\n+                bitmap.deserialize(input, bitmapType);\n+                this.bitmapType = BITMAP_VALUE;\n+                break;\n+            default:\n+                throw new RuntimeException(String.format(\"unknown bitmap type %s \", bitmapType));\n+        }\n+    }\n+\n+    // In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+    public void and(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.singleValue == other.singleValue) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                    case BITMAP_VALUE:\n+                        if (other.bitmap.contains(singleValue)) {\n+                            break;\n+                        }\n+                        clear();\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        clear();\n+                        break;\n+                    case SINGLE_VALUE:\n+                        if (this.bitmap.contains(other.singleValue)) {\n+                            clear();\n+                            this.bitmapType = SINGLE_VALUE;\n+                            this.singleValue = other.singleValue;\n+                        } else {\n+                            clear();\n+                        }\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.and(other.bitmap);\n+                        convertToSmallerType();\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    // In-place bitwise OR (union) operation. The current bitmap is modified.\n+    public void or(BitmapValue other) {\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.singleValue = other.singleValue;\n+                        this.bitmapType = SINGLE_VALUE;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        long thisSingleValue = this.singleValue;\n+                        clear();\n+                        add(thisSingleValue);\n+                        add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        other.add(this.singleValue);\n+                        this.bitmap = other.bitmap;\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        this.add(other.singleValue);\n+                        break;\n+                    case BITMAP_VALUE:\n+                        this.bitmap.or(other.bitmap);\n+                        this.bitmapType = BITMAP_VALUE;\n+                        break;\n+                }\n+                break;\n+        }\n+    }\n+\n+    public boolean equals(BitmapValue other) {\n+        boolean ret = false;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                        ret = true;\n+                        break;\n+                    case SINGLE_VALUE:\n+                    case BITMAP_VALUE:\n+                        ret = false;\n+                        break;\n+                }\n+                break;\n+            case SINGLE_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case BITMAP_VALUE:\n+                        break;\n+                    case SINGLE_VALUE:\n+                        ret = this.singleValue == other.singleValue;\n+                        break;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                switch (other.bitmapType) {\n+                    case EMPTY:\n+                    case SINGLE_VALUE:\n+                        ret = false;\n+                        break;\n+                    case BITMAP_VALUE:\n+                        ret = bitmap.equals(other.bitmap);\n+                        break;\n+                }\n+                break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     *  usage note:\n+     *      now getSizeInBytes is different from be' impl\n+     *      The reason is that java's roaring didn't implement method #shrinkToFit but be's getSizeInBytes need it\n+     *      Implementing java's shrinkToFit means refactor roaring whose fields are all unaccess in Doris Fe's package\n+     *      That would be an another big project\n+     */\n+    // TODO(wb): keep getSizeInBytes consistent with be and refactor roaring\n+    public long getSizeInBytes() {\n+        long size = 0;\n+        switch (bitmapType) {\n+            case EMPTY:\n+                size = 1;\n+                break;\n+            case SINGLE_VALUE:\n+                if (isLongValue32bitEnough(singleValue)) {\n+                    size = 1 + 4;\n+                } else {\n+                    size = 1 + 8;\n+                }\n+                break;\n+            case BITMAP_VALUE:\n+                size = 1 + bitmap.getSizeInBytes();\n+        }\n+        return size;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String toStringStr = \"{}\";\n+        switch (bitmapType) {\n+            case EMPTY:\n+                break;\n+            case SINGLE_VALUE:\n+                toStringStr = String.format(\"{%s}\", singleValue);\n+                break;\n+            case BITMAP_VALUE:\n+                toStringStr = this.bitmap.toString();\n+                break;\n+        }\n+        return toStringStr;\n+    }\n+\n+    public void clear() {\n+        this.bitmapType = EMPTY;\n+        this.bitmap = null;", "originalCommit": "b96746713b8d4d93cabb832c3f3017fc385c727d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg5OTc4Mg==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r396899782", "bodyText": "\ud83d\udc4c", "author": "wangbo", "createdAt": "2020-03-24T04:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4Njk1NA=="}], "type": "inlineReview"}, {"oid": "3791cce57938755efc442cb6036ddea3916ebdcd", "url": "https://github.com/apache/incubator-doris/commit/3791cce57938755efc442cb6036ddea3916ebdcd", "message": "1 modify and/or/isLongValue32bitEnough to keep consistent with be\n2 reduce equals code\n3 change comment to trigger rebuild", "committedDate": "2020-03-25T03:25:13Z", "type": "commit"}, {"oid": "3791cce57938755efc442cb6036ddea3916ebdcd", "url": "https://github.com/apache/incubator-doris/commit/3791cce57938755efc442cb6036ddea3916ebdcd", "message": "1 modify and/or/isLongValue32bitEnough to keep consistent with be\n2 reduce equals code\n3 change comment to trigger rebuild", "committedDate": "2020-03-25T03:25:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0NDExNQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r398644115", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version\n          \n          \n            \n                 * Unlike RoaringBitmap, there is no specification for now: it may change from one java version", "author": "morningman", "createdAt": "2020-03-26T15:03:59Z", "path": "fe/src/main/java/org/apache/doris/load/loadv2/Roaring64Map.java", "diffHunk": "@@ -0,0 +1,1462 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.load.loadv2;\n+\n+import org.roaringbitmap.BitmapDataProvider;\n+import org.roaringbitmap.BitmapDataProviderSupplier;\n+import org.roaringbitmap.IntConsumer;\n+import org.roaringbitmap.IntIterator;\n+import org.roaringbitmap.RoaringBitmap;\n+import org.roaringbitmap.RoaringBitmapSupplier;\n+import org.roaringbitmap.Util;\n+import org.roaringbitmap.buffer.MutableRoaringBitmap;\n+import org.roaringbitmap.longlong.ImmutableLongBitmapDataProvider;\n+import org.roaringbitmap.longlong.LongConsumer;\n+import org.roaringbitmap.longlong.LongIterator;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.AbstractMap;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import static org.apache.doris.common.util.Util.decodeVarint64;\n+import static org.apache.doris.common.util.Util.encodeVarint64;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP32;\n+import static org.apache.doris.load.loadv2.BitmapValue.BITMAP64;\n+\n+/**\n+ *\n+ * forked version 0.8.13\n+ * major change as below :\n+ *  1. overwrite serialize/deserialize method\n+ *  2. add a new method is32BitsEnough\n+ *  3. fork some Util method from org.roaringbitmap.longlong RoaringIntPacking\n+ * for details to see the end of the class\n+ */\n+public class Roaring64Map {\n+\n+    // Not final to enable initialization in Externalizable.readObject\n+    private NavigableMap<Integer, BitmapDataProvider> highToBitmap;\n+\n+    // If true, we handle longs a plain java longs: -1 if right before 0\n+    // If false, we handle longs as unsigned longs: 0 has no predecessor and Long.MAX_VALUE + 1L is\n+    // expressed as a\n+    // negative long\n+    private boolean signedLongs = false;\n+\n+    private BitmapDataProviderSupplier supplier;\n+\n+    // By default, we cache cardinalities\n+    private transient boolean doCacheCardinalities = true;\n+\n+    // Prevent recomputing all cardinalities when requesting consecutive ranks\n+    private transient int firstHighNotValid = highestHigh() + 1;\n+\n+    // This boolean needs firstHighNotValid == Integer.MAX_VALUE to be allowed to be true\n+    // If false, it means nearly all cumulated cardinalities are valid, except high=Integer.MAX_VALUE\n+    // If true, it means all cumulated cardinalities are valid, even high=Integer.MAX_VALUE\n+    private transient boolean allValid = false;\n+\n+    // TODO: I would prefer not managing arrays myself\n+    private transient long[] sortedCumulatedCardinality = new long[0];\n+    private transient int[] sortedHighs = new int[0];\n+\n+    // We guess consecutive .addLong will be on proximate longs: we remember the bitmap attached to\n+    // this bucket in order\n+    // to skip the indirection\n+    private transient Map.Entry<Integer, BitmapDataProvider> latestAddedHigh = null;\n+\n+    private static final boolean DEFAULT_ORDER_IS_SIGNED = false;\n+    private static final boolean DEFAULT_CARDINALITIES_ARE_CACHED = true;\n+\n+    /**\n+     * By default, we consider longs are unsigned longs: normal longs: 0 is the lowest possible long.\n+     * Long.MAX_VALUE is followed by Long.MIN_VALUE. -1L is the highest possible value\n+     */\n+    public Roaring64Map() {\n+        this(DEFAULT_ORDER_IS_SIGNED);\n+    }\n+\n+    /**\n+     *\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     */\n+    public Roaring64Map(boolean signedLongs) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED);\n+    }\n+\n+    /**\n+     * By default, use RoaringBitmap as underlyings {@link BitmapDataProvider}\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities) {\n+        this(signedLongs, cacheCardinalities, new RoaringBitmapSupplier());\n+    }\n+\n+    /**\n+     * By default, longs are managed as unsigned longs and cardinalities are cached.\n+     *\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(BitmapDataProviderSupplier supplier) {\n+        this(DEFAULT_ORDER_IS_SIGNED, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     * By default, we activating cardinalities caching.\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, BitmapDataProviderSupplier supplier) {\n+        this(signedLongs, DEFAULT_CARDINALITIES_ARE_CACHED, supplier);\n+    }\n+\n+    /**\n+     *\n+     * @param signedLongs true if longs has to be ordered as plain java longs. False to handle them as\n+     *        unsigned 64bits long (as RoaringBitmap with unsigned integers)\n+     * @param cacheCardinalities true if cardinalities have to be cached. It will prevent many\n+     *        iteration along the NavigableMap\n+     * @param supplier provide the logic to instantiate new {@link BitmapDataProvider}, typically\n+     *        instantiated once per high.\n+     */\n+    public Roaring64Map(boolean signedLongs, boolean cacheCardinalities,\n+                        BitmapDataProviderSupplier supplier) {\n+        this.signedLongs = signedLongs;\n+        this.supplier = supplier;\n+\n+        if (signedLongs) {\n+            highToBitmap = new TreeMap<>();\n+        } else {\n+            highToBitmap = new TreeMap<>(unsignedComparator());\n+        }\n+\n+        this.doCacheCardinalities = cacheCardinalities;\n+        resetPerfHelpers();\n+    }\n+\n+    private void resetPerfHelpers() {\n+        firstHighNotValid = highestHigh(signedLongs) + 1;\n+        allValid = false;\n+\n+        sortedCumulatedCardinality = new long[0];\n+        sortedHighs = new int[0];\n+\n+        latestAddedHigh = null;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    NavigableMap<Integer, BitmapDataProvider> getHighToBitmap() {\n+        return highToBitmap;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    int getLowestInvalidHigh() {\n+        return firstHighNotValid;\n+    }\n+\n+    // Package-friendly: for the sake of unit-testing\n+    // @VisibleForTesting\n+    long[] getSortedCumulatedCardinality() {\n+        return sortedCumulatedCardinality;\n+    }\n+\n+    /**\n+     * Add the value to the container (set the value to \"true\"), whether it already appears or not.\n+     *\n+     * Java lacks native unsigned longs but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Long#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 9223372036854775807, -9223372036854775808, -9223372036854775807,..., -1.\n+     *\n+     * @param x long value\n+     */\n+    public void addLong(long x) {\n+        int high = high(x);\n+        int low = low(x);\n+\n+        // Copy the reference to prevent race-condition\n+        Map.Entry<Integer, BitmapDataProvider> local = latestAddedHigh;\n+\n+        BitmapDataProvider bitmap;\n+        if (local != null && local.getKey().intValue() == high) {\n+            bitmap = local.getValue();\n+        } else {\n+            bitmap = highToBitmap.get(high);\n+            if (bitmap == null) {\n+                bitmap = newRoaringBitmap();\n+                pushBitmapForHigh(high, bitmap);\n+            }\n+            latestAddedHigh = new AbstractMap.SimpleImmutableEntry<>(high, bitmap);\n+        }\n+        bitmap.add(low);\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /**\n+     * Add the integer value to the container (set the value to \"true\"), whether it already appears or\n+     * not.\n+     *\n+     * Javac lacks native unsigned integers but the x argument is considered to be unsigned. Within\n+     * bitmaps, numbers are ordered according to\u00a0{@link Integer#compareUnsigned}. We order the numbers\n+     * like 0, 1, ..., 2147483647, -2147483648, -2147483647,..., -1.\n+     *\n+     * @param x integer value\n+     */\n+    public void addInt(int x) {\n+        addLong(Util.toUnsignedLong(x));\n+    }\n+\n+    private BitmapDataProvider newRoaringBitmap() {\n+        return supplier.newEmpty();\n+    }\n+\n+    private void invalidateAboveHigh(int high) {\n+        // The cardinalities after this bucket may not be valid anymore\n+        if (compare(firstHighNotValid, high) > 0) {\n+            // High was valid up to now\n+            firstHighNotValid = high;\n+\n+            int indexNotValid = binarySearch(sortedHighs, firstHighNotValid);\n+\n+            final int indexAfterWhichToReset;\n+            if (indexNotValid >= 0) {\n+                indexAfterWhichToReset = indexNotValid;\n+            } else {\n+                // We have invalidate a high not already present: added a value for a brand new high\n+                indexAfterWhichToReset = -indexNotValid - 1;\n+            }\n+\n+            // This way, sortedHighs remains sorted, without making a new/shorter array\n+            Arrays.fill(sortedHighs, indexAfterWhichToReset, sortedHighs.length, highestHigh());\n+        }\n+        allValid = false;\n+    }\n+\n+    private int compare(int x, int y) {\n+        if (signedLongs) {\n+            return Integer.compare(x, y);\n+        } else {\n+            return compareUnsigned(x, y);\n+        }\n+    }\n+\n+    private void pushBitmapForHigh(int high, BitmapDataProvider bitmap) {\n+        // TODO .size is too slow\n+        // int nbHighBefore = highToBitmap.headMap(high).size();\n+\n+        BitmapDataProvider previous = highToBitmap.put(high, bitmap);\n+        assert previous == null : \"Should push only not-existing high\";\n+    }\n+\n+    /**\n+     * Returns the number of distinct integers added to the bitmap (e.g., number of bits set).\n+     *\n+     * @return the cardinality\n+     */\n+    public long getLongCardinality() {\n+        if (doCacheCardinalities) {\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+            int indexOk = ensureCumulatives(highestHigh());\n+\n+            // ensureCumulatives may have removed empty bitmaps\n+            if (highToBitmap.isEmpty()) {\n+                return 0L;\n+            }\n+\n+\n+            return sortedCumulatedCardinality[indexOk - 1];\n+        } else {\n+            long cardinality = 0L;\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                cardinality += bitmap.getLongCardinality();\n+            }\n+            return cardinality;\n+        }\n+    }\n+\n+    /**\n+     *\n+     * @return the cardinality as an int\n+     *\n+     * @throws UnsupportedOperationException if the cardinality does not fit in an int\n+     */\n+    public int getIntCardinality() throws UnsupportedOperationException {\n+        long cardinality = getLongCardinality();\n+\n+        if (cardinality > Integer.MAX_VALUE) {\n+            // TODO: we should handle cardinality fitting in an unsigned int\n+            throw new UnsupportedOperationException(\n+                    \"Can not call .getIntCardinality as the cardinality is bigger than Integer.MAX_VALUE\");\n+        }\n+\n+        return (int) cardinality;\n+    }\n+\n+    /**\n+     * Return the jth value stored in this bitmap.\n+     *\n+     * @param j index of the value\n+     *\n+     * @return the value\n+     * @throws IllegalArgumentException if j is out of the bounds of the bitmap cardinality\n+     */\n+    public long select(final long j) throws IllegalArgumentException {\n+        if (!doCacheCardinalities) {\n+            return selectNoCache(j);\n+        }\n+\n+        // Ensure all cumulatives as we we have straightforward way to know in advance the high of the\n+        // j-th value\n+        int indexOk = ensureCumulatives(highestHigh());\n+\n+        if (highToBitmap.isEmpty()) {\n+            return throwSelectInvalidIndex(j);\n+        }\n+\n+        // Use normal binarySearch as cardinality does not depends on considering longs signed or\n+        // unsigned\n+        // We need sortedCumulatedCardinality not to contain duplicated, else binarySearch may return\n+        // any of the duplicates: we need to ensure it holds no high associated to an empty bitmap\n+        int position = Arrays.binarySearch(sortedCumulatedCardinality, 0, indexOk, j);\n+\n+        if (position >= 0) {\n+            if (position == indexOk - 1) {\n+                // .select has been called on this.getCardinality\n+                return throwSelectInvalidIndex(j);\n+            }\n+\n+            // There is a bucket leading to this cardinality: the j-th element is the first element of\n+            // next bucket\n+            int high = sortedHighs[position + 1];\n+            BitmapDataProvider nextBitmap = highToBitmap.get(high);\n+            return pack(high, nextBitmap.select(0));\n+        } else {\n+            // There is no bucket with this cardinality\n+            int insertionPoint = -position - 1;\n+\n+            final long previousBucketCardinality;\n+            if (insertionPoint == 0) {\n+                previousBucketCardinality = 0L;\n+            } else if (insertionPoint >= indexOk) {\n+                return throwSelectInvalidIndex(j);\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+\n+            // We get a 'select' query for a single bitmap: should fit in an int\n+            final int givenBitmapSelect = (int) (j - previousBucketCardinality);\n+\n+            int high = sortedHighs[insertionPoint];\n+            BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+            int low = lowBitmap.select(givenBitmapSelect);\n+\n+            return pack(high, low);\n+        }\n+    }\n+\n+    // For benchmarks: compute without using cardinalities cache\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long selectNoCache(long j) {\n+        long left = j;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            long lowCardinality = entry.getValue().getCardinality();\n+\n+            if (left >= lowCardinality) {\n+                left -= lowCardinality;\n+            } else {\n+                // It is legit for left to be negative\n+                int leftAsUnsignedInt = (int) left;\n+                return pack(entry.getKey(), entry.getValue().select(leftAsUnsignedInt));\n+            }\n+        }\n+\n+        return throwSelectInvalidIndex(j);\n+    }\n+\n+    private long throwSelectInvalidIndex(long j) {\n+        // see org.roaringbitmap.buffer.ImmutableRoaringBitmap.select(int)\n+        throw new IllegalArgumentException(\n+                \"select \" + j + \" when the cardinality is \" + this.getLongCardinality());\n+    }\n+\n+    /**\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public Iterator<Long> iterator() {\n+        final LongIterator it = getLongIterator();\n+\n+        return new Iterator<Long>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return it.hasNext();\n+            }\n+\n+            @Override\n+            public Long next() {\n+                return it.next();\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // TODO?\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    public void forEach(final LongConsumer lc) {\n+        for (final Map.Entry<Integer, BitmapDataProvider> highEntry : highToBitmap.entrySet()) {\n+            highEntry.getValue().forEach(new IntConsumer() {\n+\n+                @Override\n+                public void accept(int low) {\n+                    lc.accept(pack(highEntry.getKey(), low));\n+                }\n+            });\n+        }\n+    }\n+\n+    public long rankLong(long id) {\n+        int high = high(id);\n+        int low = low(id);\n+\n+        if (!doCacheCardinalities) {\n+            return rankLongNoCache(high, low);\n+        }\n+\n+        int indexOk = ensureCumulatives(high);\n+\n+        int highPosition = binarySearch(sortedHighs, 0, indexOk, high);\n+\n+        if (highPosition >= 0) {\n+            // There is a bucket holding this item\n+\n+            final long previousBucketCardinality;\n+            if (highPosition == 0) {\n+                previousBucketCardinality = 0;\n+            } else {\n+                previousBucketCardinality = sortedCumulatedCardinality[highPosition - 1];\n+            }\n+\n+            BitmapDataProvider lowBitmap = highToBitmap.get(sortedHighs[highPosition]);\n+\n+            // Rank is previous cardinality plus rank in current bitmap\n+            return previousBucketCardinality + lowBitmap.rankLong(low);\n+        } else {\n+            // There is no bucket holding this item: insertionPoint is previous bitmap\n+            int insertionPoint = -highPosition - 1;\n+\n+            if (insertionPoint == 0) {\n+                // this key is before all inserted keys\n+                return 0;\n+            } else {\n+                // The rank is the cardinality of this previous bitmap\n+                return sortedCumulatedCardinality[insertionPoint - 1];\n+            }\n+        }\n+    }\n+\n+    // https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring64map.hh\n+    private long rankLongNoCache(int high, int low) {\n+        long result = 0L;\n+\n+        BitmapDataProvider lastBitmap = highToBitmap.get(high);\n+        if (lastBitmap == null) {\n+            // There is no value with same high: the rank is a sum of cardinalities\n+            for (Map.Entry<Integer, BitmapDataProvider> bitmap : highToBitmap.entrySet()) {\n+                if (bitmap.getKey().intValue() > high) {\n+                    break;\n+                } else {\n+                    result += bitmap.getValue().getLongCardinality();\n+                }\n+            }\n+        } else {\n+            for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+                if (bitmap == lastBitmap) {\n+                    result += bitmap.rankLong(low);\n+                    break;\n+                } else {\n+                    result += bitmap.getLongCardinality();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     *\n+     * @param high for which high bucket should we compute the cardinality\n+     * @return the highest validatedIndex\n+     */\n+    protected int ensureCumulatives(int high) {\n+        if (allValid) {\n+            // the whole array is valid (up-to its actual length, not its capacity)\n+            return highToBitmap.size();\n+        } else if (compare(high, firstHighNotValid) < 0) {\n+            // The high is strictly below the first not valid: it is valid\n+\n+            // sortedHighs may have only a subset of valid values on the right. However, these invalid\n+            // values have been set to maxValue, and we are here as high < firstHighNotValid ==> high <\n+            // maxHigh()\n+            int position = binarySearch(sortedHighs, high);\n+\n+            if (position >= 0) {\n+                // This high has a bitmap: +1 as this index will be used as right (excluded) bound in a\n+                // binary-search\n+                return position + 1;\n+            } else {\n+                // This high has no bitmap: it could be between 2 highs with bitmaps\n+                int insertionPosition = -position - 1;\n+                return insertionPosition;\n+            }\n+        } else {\n+\n+            // For each deprecated buckets\n+            SortedMap<Integer, BitmapDataProvider> tailMap =\n+                    highToBitmap.tailMap(firstHighNotValid, true);\n+\n+            // TODO .size on tailMap make an iterator: arg\n+            int indexOk = highToBitmap.size() - tailMap.size();\n+\n+            // TODO: It should be possible to compute indexOk based on sortedHighs array\n+            // assert indexOk == binarySearch(sortedHighs, firstHighNotValid);\n+\n+            Iterator<Map.Entry<Integer, BitmapDataProvider>> it = tailMap.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry<Integer, BitmapDataProvider> e = it.next();\n+                int currentHigh = e.getKey();\n+\n+                if (compare(currentHigh, high) > 0) {\n+                    // No need to compute more than needed\n+                    break;\n+                } else if (e.getValue().isEmpty()) {\n+                    // highToBitmap can not be modified as we iterate over it\n+                    if (latestAddedHigh != null && latestAddedHigh.getKey().intValue() == currentHigh) {\n+                        // Dismiss the cached bitmap as it is removed from the NavigableMap\n+                        latestAddedHigh = null;\n+                    }\n+                    it.remove();\n+                } else {\n+                    ensureOne(e, currentHigh, indexOk);\n+\n+                    // We have added one valid cardinality\n+                    indexOk++;\n+                }\n+\n+            }\n+\n+            if (highToBitmap.isEmpty() || indexOk == highToBitmap.size()) {\n+                // We have compute all cardinalities\n+                allValid = true;\n+            }\n+\n+            return indexOk;\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, key);\n+        } else {\n+            return unsignedBinarySearch(array, 0, array.length, key,\n+                    unsignedComparator());\n+        }\n+    }\n+\n+    private int binarySearch(int[] array, int from, int to, int key) {\n+        if (signedLongs) {\n+            return Arrays.binarySearch(array, from, to, key);\n+        } else {\n+            return unsignedBinarySearch(array, from, to, key, unsignedComparator());\n+        }\n+    }\n+\n+    // From Arrays.binarySearch (Comparator). Check with org.roaringbitmap.Util.unsignedBinarySearch\n+    private static int unsignedBinarySearch(int[] a, int fromIndex, int toIndex, int key,\n+                                            Comparator<? super Integer> c) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            int midVal = a[mid];\n+            int cmp = c.compare(midVal, key);\n+            if (cmp < 0) {\n+                low = mid + 1;\n+            } else if (cmp > 0) {\n+                high = mid - 1;\n+            } else {\n+                return mid; // key found\n+            }\n+        }\n+        return -(low + 1); // key not found.\n+    }\n+\n+    private void ensureOne(Map.Entry<Integer, BitmapDataProvider> e, int currentHigh, int indexOk) {\n+        // sortedHighs are valid only up to some index\n+        assert indexOk <= sortedHighs.length : indexOk + \" is bigger than \" + sortedHighs.length;\n+\n+        final int index;\n+        if (indexOk == 0) {\n+            if (sortedHighs.length == 0) {\n+                index = -1;\n+                // } else if (sortedHighs[0] == currentHigh) {\n+                // index = 0;\n+            } else {\n+                index = -1;\n+            }\n+        } else if (indexOk < sortedHighs.length) {\n+            index = -indexOk - 1;\n+        } else {\n+            index = -sortedHighs.length - 1;\n+        }\n+        assert index == binarySearch(sortedHighs, 0, indexOk, currentHigh) : \"Computed \" + index\n+                + \" differs from dummy binary-search index: \"\n+                + binarySearch(sortedHighs, 0, indexOk, currentHigh);\n+\n+        if (index >= 0) {\n+            // This would mean calling .ensureOne is useless: should never got here at the first time\n+            throw new IllegalStateException(\"Unexpectedly found \" + currentHigh + \" in \"\n+                    + Arrays.toString(sortedHighs) + \" strictly before index\" + indexOk);\n+        } else {\n+            int insertionPosition = -index - 1;\n+\n+            // This is a new key\n+            if (insertionPosition >= sortedHighs.length) {\n+                int previousSize = sortedHighs.length;\n+\n+                // TODO softer growing factor\n+                int newSize = Math.min(Integer.MAX_VALUE, sortedHighs.length * 2 + 1);\n+\n+                // Insertion at the end\n+                sortedHighs = Arrays.copyOf(sortedHighs, newSize);\n+                sortedCumulatedCardinality = Arrays.copyOf(sortedCumulatedCardinality, newSize);\n+\n+                // Not actually needed. But simplify the reading of array content\n+                Arrays.fill(sortedHighs, previousSize, sortedHighs.length, highestHigh());\n+                Arrays.fill(sortedCumulatedCardinality, previousSize, sortedHighs.length, Long.MAX_VALUE);\n+            }\n+            sortedHighs[insertionPosition] = currentHigh;\n+\n+            final long previousCardinality;\n+            if (insertionPosition >= 1) {\n+                previousCardinality = sortedCumulatedCardinality[insertionPosition - 1];\n+            } else {\n+                previousCardinality = 0;\n+            }\n+\n+            sortedCumulatedCardinality[insertionPosition] =\n+                    previousCardinality + e.getValue().getLongCardinality();\n+\n+            if (currentHigh == highestHigh()) {\n+                // We are already on the highest high. Do not set allValid as it is set anyway out of the\n+                // loop\n+                firstHighNotValid = currentHigh;\n+            } else {\n+                // The first not valid is the next high\n+                // TODO: The entry comes from a NavigableMap: it may be quite cheap to know the next high\n+                firstHighNotValid = currentHigh + 1;\n+            }\n+        }\n+    }\n+\n+\n+\n+    private int highestHigh() {\n+        return highestHigh(signedLongs);\n+    }\n+\n+    /**\n+     * In-place bitwise OR (union) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void or(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).or((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).or((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise XOR (symmetric difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void xor(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> e2 : x2.highToBitmap.entrySet()) {\n+            // Keep object to prevent auto-boxing\n+            Integer high = e2.getKey();\n+\n+            BitmapDataProvider lowBitmap1 = this.highToBitmap.get(high);\n+\n+            BitmapDataProvider lowBitmap2 = e2.getValue();\n+\n+            // TODO Reviewers: is it a good idea to rely on BitmapDataProvider except in methods\n+            // expecting an actual MutableRoaringBitmap?\n+            // TODO This code may lead to closing a buffer Bitmap in current Navigable even if current is\n+            // not on buffer\n+            if ((lowBitmap1 == null || lowBitmap1 instanceof RoaringBitmap)\n+                    && lowBitmap2 instanceof RoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    RoaringBitmap lowBitmap2Clone = ((RoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((RoaringBitmap) lowBitmap1).xor((RoaringBitmap) lowBitmap2);\n+                }\n+            } else if ((lowBitmap1 == null || lowBitmap1 instanceof MutableRoaringBitmap)\n+                    && lowBitmap2 instanceof MutableRoaringBitmap) {\n+                if (lowBitmap1 == null) {\n+                    // Clone to prevent future modification of this modifying the input Bitmap\n+                    BitmapDataProvider lowBitmap2Clone = ((MutableRoaringBitmap) lowBitmap2).clone();\n+\n+                    pushBitmapForHigh(high, lowBitmap2Clone);\n+                } else {\n+                    ((MutableRoaringBitmap) lowBitmap1).xor((MutableRoaringBitmap) lowBitmap2);\n+                }\n+            } else {\n+                throw new UnsupportedOperationException(\n+                        \".or is not between \" + this.getClass() + \" and \" + lowBitmap2.getClass());\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * In-place bitwise AND (intersection) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void and(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 == null) {\n+                // None of given high values are present in x2\n+                thisIterator.remove();\n+            } else {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).and((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).and((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * In-place bitwise ANDNOT (difference) operation. The current bitmap is modified.\n+     *\n+     * @param x2 other bitmap\n+     */\n+    public void andNot(final Roaring64Map x2) {\n+        boolean firstBucket = true;\n+\n+        Iterator<Map.Entry<Integer, BitmapDataProvider>> thisIterator = highToBitmap.entrySet().iterator();\n+        while (thisIterator.hasNext()) {\n+            Map.Entry<Integer, BitmapDataProvider> e1 = thisIterator.next();\n+\n+            // Keep object to prevent auto-boxing\n+            Integer high = e1.getKey();\n+\n+            BitmapDataProvider lowBitmap2 = x2.highToBitmap.get(high);\n+\n+            if (lowBitmap2 != null) {\n+                BitmapDataProvider lowBitmap1 = e1.getValue();\n+\n+                if (lowBitmap2 instanceof RoaringBitmap && lowBitmap1 instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) lowBitmap1).andNot((RoaringBitmap) lowBitmap2);\n+                } else if (lowBitmap2 instanceof MutableRoaringBitmap\n+                        && lowBitmap1 instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) lowBitmap1).andNot((MutableRoaringBitmap) lowBitmap2);\n+                } else {\n+                    throw new UnsupportedOperationException(\n+                            \".and is not between \" + this.getClass() + \" and \" + lowBitmap1.getClass());\n+                }\n+            }\n+\n+            if (firstBucket) {\n+                firstBucket = false;\n+\n+                // Invalidate the lowest high as lowest not valid\n+                firstHighNotValid = Math.min(firstHighNotValid, high);\n+                allValid = false;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A string describing the bitmap.\n+     *\n+     * @return the string\n+     */\n+    @Override\n+    public String toString() {\n+        final StringBuilder answer = new StringBuilder();\n+        final LongIterator i = this.getLongIterator();\n+        answer.append(\"{\");\n+        if (i.hasNext()) {\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+        }\n+        while (i.hasNext()) {\n+            answer.append(\",\");\n+            // to avoid using too much memory, we limit the size\n+            if (answer.length() > 0x80000) {\n+                answer.append(\"...\");\n+                break;\n+            }\n+            if (signedLongs) {\n+                answer.append(i.next());\n+            } else {\n+                answer.append(toUnsignedString(i.next()));\n+            }\n+\n+        }\n+        answer.append(\"}\");\n+        return answer.toString();\n+    }\n+\n+\n+    /**\n+     *\n+     * For better performance, consider the Use the {@link #forEach forEach} method.\n+     *\n+     * @return a custom iterator over set bits, the bits are traversed in ascending sorted order\n+     */\n+    public LongIterator getLongIterator() {\n+        final Iterator<Map.Entry<Integer, BitmapDataProvider>> it = highToBitmap.entrySet().iterator();\n+\n+        return toIterator(it, false);\n+    }\n+\n+    protected LongIterator toIterator(final Iterator<Map.Entry<Integer, BitmapDataProvider>> it,\n+                                      final boolean reversed) {\n+        return new LongIterator() {\n+\n+            protected int currentKey;\n+            protected IntIterator currentIt;\n+\n+            @Override\n+            public boolean hasNext() {\n+                if (currentIt == null) {\n+                    // Were initially empty\n+                    if (!moveToNextEntry(it)) {\n+                        return false;\n+                    }\n+                }\n+\n+                while (true) {\n+                    if (currentIt.hasNext()) {\n+                        return true;\n+                    } else {\n+                        if (!moveToNextEntry(it)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            /**\n+             *\n+             * @param it the underlying iterator which has to be moved to next long\n+             * @return true if we MAY have more entries. false if there is definitely nothing more\n+             */\n+            private boolean moveToNextEntry(Iterator<Map.Entry<Integer, BitmapDataProvider>> it) {\n+                if (it.hasNext()) {\n+                    Map.Entry<Integer, BitmapDataProvider> next = it.next();\n+                    currentKey = next.getKey();\n+                    if (reversed) {\n+                        currentIt = next.getValue().getReverseIntIterator();\n+                    } else {\n+                        currentIt = next.getValue().getIntIterator();\n+                    }\n+\n+                    // We may have more long\n+                    return true;\n+                } else {\n+                    // We know there is nothing more\n+                    return false;\n+                }\n+            }\n+\n+            @Override\n+            public long next() {\n+                if (hasNext()) {\n+                    return pack(currentKey, currentIt.next());\n+                } else {\n+                    throw new IllegalStateException(\"empty\");\n+                }\n+            }\n+\n+            @Override\n+            public LongIterator clone() {\n+                throw new UnsupportedOperationException(\"TODO\");\n+            }\n+        };\n+    }\n+\n+    public boolean contains(long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            return false;\n+        }\n+\n+        int low = low(x);\n+        return lowBitmap.contains(low);\n+    }\n+\n+\n+    public int getSizeInBytes() {\n+        return (int) getLongSizeInBytes();\n+    }\n+\n+    public long getLongSizeInBytes() {\n+        long size = 8;\n+\n+        // Size of containers\n+        size += highToBitmap.values().stream().mapToLong(p -> p.getLongSizeInBytes()).sum();\n+\n+        // Size of Map data-structure: we consider each TreeMap entry costs 40 bytes\n+        // http://java-performance.info/memory-consumption-of-java-data-types-2/\n+        size += 8 + 40 * highToBitmap.size();\n+\n+        // Size of (boxed) Integers used as keys\n+        size += 16 * highToBitmap.size();\n+\n+        // The cache impacts the size in heap\n+        size += 8 * sortedCumulatedCardinality.length;\n+        size += 4 * sortedHighs.length;\n+\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return getLongCardinality() == 0L;\n+    }\n+\n+    public ImmutableLongBitmapDataProvider limit(long x) {\n+        throw new UnsupportedOperationException(\"TODO\");\n+    }\n+\n+    /**\n+     * Use a run-length encoding where it is estimated as more space efficient\n+     *\n+     * @return whether a change was applied\n+     */\n+    public boolean runOptimize() {\n+        boolean hasChanged = false;\n+        for (BitmapDataProvider lowBitmap : highToBitmap.values()) {\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                hasChanged |= ((RoaringBitmap) lowBitmap).runOptimize();\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                hasChanged |= ((MutableRoaringBitmap) lowBitmap).runOptimize();\n+            }\n+        }\n+        return hasChanged;\n+    }\n+\n+    public long serializedSizeInBytes() {\n+        long nbBytes = 0L;\n+\n+        // .writeBoolean for signedLongs boolean\n+        nbBytes += 1;\n+\n+        // .writeInt for number of different high values\n+        nbBytes += 4;\n+\n+        for (Map.Entry<Integer, BitmapDataProvider> entry : highToBitmap.entrySet()) {\n+            // .writeInt for high\n+            nbBytes += 4;\n+\n+            // The low bitmap size in bytes\n+            nbBytes += entry.getValue().serializedSizeInBytes();\n+        }\n+\n+        return nbBytes;\n+    }\n+\n+    /**\n+     * reset to an empty bitmap; result occupies as much space a newly created bitmap.\n+     */\n+    public void clear() {\n+        this.highToBitmap.clear();\n+        resetPerfHelpers();\n+    }\n+\n+    /**\n+     * Return the set values as an array, if the cardinality is smaller than 2147483648. The long\n+     * values are in sorted order.\n+     *\n+     * @return array representing the set values.\n+     */\n+    public long[] toArray() {\n+        long cardinality = this.getLongCardinality();\n+        if (cardinality > Integer.MAX_VALUE) {\n+            throw new IllegalStateException(\"The cardinality does not fit in an array\");\n+        }\n+\n+        final long[] array = new long[(int) cardinality];\n+\n+        int pos = 0;\n+        LongIterator it = getLongIterator();\n+\n+        while (it.hasNext()) {\n+            array[pos++] = it.next();\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Generate a bitmap with the specified values set to true. The provided longs values don't have\n+     * to be in sorted order, but it may be preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     * @return a new bitmap\n+     */\n+    public static Roaring64Map bitmapOf(final long... dat) {\n+        final Roaring64Map ans = new Roaring64Map();\n+        ans.add(dat);\n+        return ans;\n+    }\n+\n+    /**\n+     * Set all the specified values to true. This can be expected to be slightly faster than calling\n+     * \"add\" repeatedly. The provided integers values don't have to be in sorted order, but it may be\n+     * preferable to sort them from a performance point of view.\n+     *\n+     * @param dat set values\n+     */\n+    public void add(long... dat) {\n+        for (long oneLong : dat) {\n+            addLong(oneLong);\n+        }\n+    }\n+\n+    /**\n+     * Add to the current bitmap all longs in [rangeStart,rangeEnd).\n+     *\n+     * @param rangeStart inclusive beginning of range\n+     * @param rangeEnd exclusive ending of range\n+     */\n+    public void add(final long rangeStart, final long rangeEnd) {\n+        int startHigh = high(rangeStart);\n+        int startLow = low(rangeStart);\n+\n+        int endHigh = high(rangeEnd);\n+        int endLow = low(rangeEnd);\n+\n+        for (int high = startHigh; high <= endHigh; high++) {\n+            final int currentStartLow;\n+            if (startHigh == high) {\n+                // The whole range starts in this bucket\n+                currentStartLow = startLow;\n+            } else {\n+                // Add the bucket from the beginning\n+                currentStartLow = 0;\n+            }\n+\n+            long startLowAsLong = Util.toUnsignedLong(currentStartLow);\n+\n+            final long endLowAsLong;\n+            if (endHigh == high) {\n+                // The whole range ends in this bucket\n+                endLowAsLong = Util.toUnsignedLong(endLow);\n+            } else {\n+                // Add the bucket until the end: we have a +1 as, in RoaringBitmap.add(long,long), the end\n+                // is excluded\n+                endLowAsLong = Util.toUnsignedLong(-1) + 1;\n+            }\n+\n+            if (endLowAsLong > startLowAsLong) {\n+                // Initialize the bitmap only if there is access data to write\n+                BitmapDataProvider bitmap = highToBitmap.get(high);\n+                if (bitmap == null) {\n+                    bitmap = new MutableRoaringBitmap();\n+                    pushBitmapForHigh(high, bitmap);\n+                }\n+\n+                if (bitmap instanceof RoaringBitmap) {\n+                    ((RoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else if (bitmap instanceof MutableRoaringBitmap) {\n+                    ((MutableRoaringBitmap) bitmap).add(startLowAsLong, endLowAsLong);\n+                } else {\n+                    throw new UnsupportedOperationException(\"TODO. Not for \" + bitmap.getClass());\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(startHigh);\n+    }\n+\n+    public LongIterator getReverseLongIterator() {\n+        return toIterator(highToBitmap.descendingMap().entrySet().iterator(), true);\n+    }\n+\n+    public void removeLong(long x) {\n+        int high = high(x);\n+\n+        BitmapDataProvider bitmap = highToBitmap.get(high);\n+\n+        if (bitmap != null) {\n+            int low = low(x);\n+            bitmap.remove(low);\n+\n+            // Invalidate only if actually modified\n+            invalidateAboveHigh(high);\n+        }\n+\n+    }\n+\n+    public void trim() {\n+        for (BitmapDataProvider bitmap : highToBitmap.values()) {\n+            bitmap.trim();\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return highToBitmap.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        Roaring64Map other = (Roaring64Map) obj;\n+        return Objects.equals(highToBitmap, other.highToBitmap);\n+    }\n+\n+\n+\n+    /**\n+     * Add the value if it is not already present, otherwise remove it.\n+     *\n+     * @param x long value\n+     */\n+    public void flip(final long x) {\n+        int high = high(x);\n+        BitmapDataProvider lowBitmap = highToBitmap.get(high);\n+        if (lowBitmap == null) {\n+            // The value is not added: add it without any flip specific code\n+            addLong(x);\n+        } else {\n+            int low = low(x);\n+\n+            // .flip is not in BitmapDataProvider contract\n+            // TODO Is it relevant to calling .flip with a cast?\n+            if (lowBitmap instanceof RoaringBitmap) {\n+                ((RoaringBitmap) lowBitmap).flip(low);\n+            } else if (lowBitmap instanceof MutableRoaringBitmap) {\n+                ((MutableRoaringBitmap) lowBitmap).flip(low);\n+            } else {\n+                // Fallback to a manual flip\n+                if (lowBitmap.contains(low)) {\n+                    lowBitmap.remove(low);\n+                } else {\n+                    lowBitmap.add(low);\n+                }\n+            }\n+        }\n+\n+        invalidateAboveHigh(high);\n+    }\n+\n+    /* ------------------ method below from Roaring64NavigableMap and being overwritten ----------------------------- */\n+\n+    /**\n+     * Serialize this bitmap.\n+     *\n+     * Unlike RoaringBitmap, there is no specification for now: it may change from onve java version", "originalCommit": "3791cce57938755efc442cb6036ddea3916ebdcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAwNjMwMQ==", "url": "https://github.com/apache/incubator-doris/pull/3090#discussion_r399006301", "bodyText": "\ud83d\udc4c", "author": "wangbo", "createdAt": "2020-03-27T02:50:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0NDExNQ=="}], "type": "inlineReview"}, {"oid": "3de5b2af8aff246a2aba787f9f166d7b8249a31b", "url": "https://github.com/apache/incubator-doris/commit/3de5b2af8aff246a2aba787f9f166d7b8249a31b", "message": "fix misspell", "committedDate": "2020-03-27T02:52:51Z", "type": "commit"}]}