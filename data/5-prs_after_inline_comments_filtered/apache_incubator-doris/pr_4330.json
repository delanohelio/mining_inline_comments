{"pr_number": 4330, "pr_title": "[Feature][Cache] Sql cache and partition cache #2581", "pr_createdAt": "2020-08-11T13:44:42Z", "pr_url": "https://github.com/apache/incubator-doris/pull/4330", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzMDI4NQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468630285", "bodyText": "What's the meaning of nokeyStmt ?", "author": "kangkaisen", "createdAt": "2020-08-11T14:35:23Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/PartitionCache.java", "diffHunk": "@@ -0,0 +1,215 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.InlineViewRef;\n+import org.apache.doris.analysis.QueryStmt;\n+import org.apache.doris.analysis.SelectStmt;\n+import org.apache.doris.analysis.TableRef;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.metric.MetricRepo;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TUniqueId;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+\n+public class PartitionCache extends Cache {\n+    private static final Logger LOG = LogManager.getLogger(PartitionCache.class);\n+    private SelectStmt nokeyStmt;", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI0NjE2OA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r472246168", "bodyText": "After rewriting, there is no partition key select statement", "author": "marising", "createdAt": "2020-08-18T14:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzMDI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzMjc1MA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468632750", "bodyText": "Only session variable is enough? because session variable  could be global, global  session variable is persist.", "author": "kangkaisen", "createdAt": "2020-08-11T14:38:44Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheAnalyzer.java", "diffHunk": "@@ -0,0 +1,450 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.AggregateInfo;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.CastExpr;\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.InlineViewRef;\n+import org.apache.doris.analysis.QueryStmt;\n+import org.apache.doris.analysis.SelectStmt;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.analysis.StatementBase;\n+import org.apache.doris.analysis.TableRef;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.metric.MetricRepo;\n+import org.apache.doris.planner.OlapScanNode;\n+import org.apache.doris.planner.Planner;\n+import org.apache.doris.planner.ScanNode;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Status;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.thrift.TUniqueId;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Analyze which caching mode a SQL is suitable for\n+ * 1. T + 1 update is suitable for SQL mode\n+ * 2. Partition by date, update the data of the day in near real time, which is suitable for Partition mode\n+ */\n+public class CacheAnalyzer {\n+    private static final Logger LOG = LogManager.getLogger(CacheAnalyzer.class);\n+\n+    /**\n+     * NoNeed : disable config or variable, not query, not scan table etc.\n+     */\n+    public enum CacheMode {\n+        NoNeed,\n+        None,\n+        TTL,\n+        Sql,\n+        Partition\n+    }\n+\n+    private ConnectContext context;\n+    private boolean enableSqlCache = false;\n+    private boolean enablePartitionCache = false;\n+    private TUniqueId queryId;\n+    private CacheMode cacheMode;\n+    private CacheTable latestTable;\n+    private StatementBase parsedStmt;\n+    private SelectStmt selectStmt;\n+    private List<ScanNode> scanNodes;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo partitionInfo;\n+    private Column partColumn;\n+    private CompoundPredicate partitionPredicate;\n+    private Cache cache;\n+\n+    public Cache getCache() {\n+        return cache;\n+    }\n+\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, Planner planner) {\n+        this.context = context;\n+        this.queryId = context.queryId();\n+        this.parsedStmt = parsedStmt;\n+        scanNodes = planner.getScanNodes();\n+        latestTable = new CacheTable();\n+        checkCacheConfig();\n+    }\n+\n+    //for unit test\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, List<ScanNode> scanNodes) {\n+        this.context = context;\n+        this.parsedStmt = parsedStmt;\n+        this.scanNodes = scanNodes;\n+        checkCacheConfig();\n+    }\n+\n+    private void checkCacheConfig() {\n+        if (Config.cache_enable_sql_mode) {\n+            if (context.getSessionVariable().isEnableSqlCache()) {", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI1OTc0Mg==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r472259742", "bodyText": "I understand that getsessionvariable() can obtain session variables and global variables. Session variables have higher priority than global variables. I don't know if I understand correctly.", "author": "marising", "createdAt": "2020-08-18T14:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzMjc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU2MjIzOQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r473562239", "bodyText": "Yes. Session variables have higher priority than global variables..", "author": "kangkaisen", "createdAt": "2020-08-20T03:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzMjc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzNjc4OQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468636789", "bodyText": "Rename hitAll  to isEos or isFinished ?", "author": "kangkaisen", "createdAt": "2020-08-11T14:44:08Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/StmtExecutor.java", "diffHunk": "@@ -575,6 +583,78 @@ private void handleSetStmt() {\n         context.getState().setOk();\n     }\n \n+    private void sendChannel(MysqlChannel channel, List<CacheProxy.CacheValue> cacheValues, boolean hitAll)", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI2Njg2OQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r472266869", "bodyText": "This means whether the query partitions are all hit\uff0cso isHitAll is better\uff1f", "author": "marising", "createdAt": "2020-08-18T15:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzNjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU2NDg0MA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r473564840", "bodyText": "I think sendChannel  shouldn't know query cache hit logic. which only to know how to send and when finish.", "author": "kangkaisen", "createdAt": "2020-08-20T03:24:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzNjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5MjA5MA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r474392090", "bodyText": "ok\uff0ci change hitAll to isEos", "author": "marising", "createdAt": "2020-08-21T03:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYzNjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0MDE0MQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468640141", "bodyText": "Do we need update cache every time?", "author": "kangkaisen", "createdAt": "2020-08-11T14:48:34Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/StmtExecutor.java", "diffHunk": "@@ -575,6 +583,78 @@ private void handleSetStmt() {\n         context.getState().setOk();\n     }\n \n+    private void sendChannel(MysqlChannel channel, List<CacheProxy.CacheValue> cacheValues, boolean hitAll)\n+            throws Exception {\n+        RowBatch batch = null;\n+        for (CacheBeProxy.CacheValue value : cacheValues) {\n+            batch = value.getRowBatch();\n+            for (ByteBuffer row : batch.getBatch().getRows()) {\n+                channel.sendOnePacket(row);\n+            }\n+            context.updateReturnRows(batch.getBatch().getRows().size());\n+        }\n+        if (hitAll) {\n+            if (batch != null) {\n+                statisticsForAuditLog = batch.getQueryStatistics();\n+            }\n+            context.getState().setEof();\n+            return;\n+        }\n+    }\n+\n+    private boolean handleCacheStmt(CacheAnalyzer cacheAnalyzer,MysqlChannel channel) throws Exception {\n+        RowBatch batch = null;\n+        CacheBeProxy.FetchCacheResult cacheResult = cacheAnalyzer.getCacheData();\n+        CacheMode mode = cacheAnalyzer.getCacheMode();\n+        if (cacheResult != null) {\n+            isCached = true;\n+            if (cacheAnalyzer.getHitRange() == Cache.HitRange.Full) {\n+                sendChannel(channel, cacheResult.getValueList(), true);\n+                return true;\n+            }\n+            //rewrite sql\n+            if (mode == CacheMode.Partition) {\n+                if (cacheAnalyzer.getHitRange() == Cache.HitRange.Left) {\n+                    sendChannel(channel, cacheResult.getValueList(), false);\n+                }\n+                SelectStmt newSelectStmt = cacheAnalyzer.getRewriteStmt();\n+                newSelectStmt.reset();\n+                analyzer = new Analyzer(context.getCatalog(), context);\n+                newSelectStmt.analyze(analyzer);\n+                planner = new Planner();\n+                planner.plan(newSelectStmt, analyzer, context.getSessionVariable().toThrift());\n+            }\n+        }\n+\n+        coord = new Coordinator(context, analyzer, planner);\n+        QeProcessorImpl.INSTANCE.registerQuery(context.queryId(),\n+                new QeProcessorImpl.QueryInfo(context, originStmt.originStmt, coord));\n+        coord.exec();\n+\n+        while (true) {\n+            batch = coord.getNext();\n+            if (batch.getBatch() != null) {\n+                cacheAnalyzer.copyRowBatch(batch);\n+                for (ByteBuffer row : batch.getBatch().getRows()) {\n+                    channel.sendOnePacket(row);\n+                }\n+                context.updateReturnRows(batch.getBatch().getRows().size());\n+            }\n+            if (batch.isEos()) {\n+                break;\n+            }\n+        }\n+        \n+        if (cacheResult != null && cacheAnalyzer.getHitRange() == Cache.HitRange.Right) {\n+            sendChannel(channel, cacheResult.getValueList(), false);\n+        }\n+\n+        cacheAnalyzer.updateCache();", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYwOTI0NQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r472609245", "bodyText": "The updateCache method determines whether the background Cache needs to be updated\n    public void updateCache() {\n        if (cacheMode == CacheMode.None || cacheMode == CacheMode.NoNeed) {\n            return;\n        }\n        cache.updateCache();\n    }", "author": "marising", "createdAt": "2020-08-19T02:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0MDE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDUyMw==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468644523", "bodyText": "I don't understand this comment.", "author": "kangkaisen", "createdAt": "2020-08-11T14:54:28Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/PartitionRange.java", "diffHunk": "@@ -0,0 +1,596 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DateLiteral;\n+import org.apache.doris.analysis.InPredicate;\n+import org.apache.doris.analysis.PartitionValue;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.IntLiteral;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.PrimitiveType;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionKey;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.planner.PartitionColumnFilter;\n+\n+import org.apache.doris.common.AnalysisException;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Convert the range of the partition to the list\n+ * all partition by day/week/month split to day list\n+ */\n+public class PartitionRange {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRange.class);\n+\n+    public class PartitionSingle {\n+        private Partition partition;\n+        private PartitionKey partitionKey;\n+        private long partitionId;\n+        private PartitionKeyType cacheKey;\n+        private boolean fromCache;\n+        private boolean tooNew;\n+\n+        public Partition getPartition() {\n+            return partition;\n+        }\n+\n+        public void setPartition(Partition partition) {\n+            this.partition = partition;\n+        }\n+\n+        public PartitionKey getPartitionKey() {\n+            return partitionKey;\n+        }\n+\n+        public void setPartitionKey(PartitionKey key) {\n+            this.partitionKey = key;\n+        }\n+\n+        public long getPartitionId() {\n+            return partitionId;\n+        }\n+\n+        public void setPartitionId(long partitionId) {\n+            this.partitionId = partitionId;\n+        }\n+\n+        public PartitionKeyType getCacheKey() {\n+            return cacheKey;\n+        }\n+\n+        public void setCacheKey(PartitionKeyType cacheKey) {\n+            this.cacheKey.clone(cacheKey);\n+        }\n+\n+        public boolean isFromCache() {\n+            return fromCache;\n+        }\n+\n+        public void setFromCache(boolean fromCache) {\n+            this.fromCache = fromCache;\n+        }\n+\n+        public boolean isTooNew() {\n+            return tooNew;\n+        }\n+\n+        public void setTooNew(boolean tooNew) {\n+            this.tooNew = tooNew;\n+        }\n+\n+        public PartitionSingle() {\n+            this.partitionId = 0;\n+            this.cacheKey = new PartitionKeyType();\n+            this.fromCache = false;\n+            this.tooNew = false;\n+        }\n+\n+        public void Debug() {\n+            if (partition != null) {\n+                LOG.info(\"partition id {}, cacheKey {}, version {}, time {}, fromCache {}, tooNew {} \",\n+                        partitionId, cacheKey.realValue(),\n+                        partition.getVisibleVersion(), partition.getVisibleVersionTime(),\n+                        fromCache, tooNew);\n+            } else {\n+                LOG.info(\"partition id {}, cacheKey {}, fromCache {}, tooNew {} \", partitionId,\n+                        cacheKey.realValue(), fromCache, tooNew);\n+            }\n+        }\n+    }\n+\n+    public enum KeyType {\n+        DEFAULT,\n+        LONG,\n+        DATE,\n+        DATETIME,\n+        TIME\n+    }\n+\n+    public static class PartitionKeyType {\n+        private SimpleDateFormat df8 = new SimpleDateFormat(\"yyyyMMdd\");\n+        private SimpleDateFormat df10 = new SimpleDateFormat(\"yyyy-MM-dd\");\n+\n+        public KeyType keyType = KeyType.DEFAULT;\n+        public long value;\n+        public Date date;\n+\n+        public boolean init(Type type, String str) {\n+            if (type.getPrimitiveType() == PrimitiveType.DATE) {\n+                try {\n+                    date = df10.parse(str);\n+                } catch (Exception e) {\n+                    LOG.warn(\"parse error str{}.\", str);\n+                    return false;\n+                }\n+                keyType = KeyType.DATE;\n+            } else {\n+                value = Long.valueOf(str);\n+                keyType = KeyType.LONG;\n+            }\n+            return true;\n+        }\n+\n+        public boolean init(Type type, LiteralExpr expr) {\n+            switch (type.getPrimitiveType()) {\n+                case BOOLEAN:\n+                case TIME:\n+                case DATETIME:\n+                case FLOAT:\n+                case DOUBLE:\n+                case DECIMAL:\n+                case DECIMALV2:\n+                case CHAR:\n+                case VARCHAR:\n+                case LARGEINT:\n+                    LOG.info(\"PartitionCache not support such key type {}\", type.toSql());\n+                    return false;\n+                case DATE:\n+                    date = getDateValue(expr);\n+                    keyType = KeyType.DATE;\n+                    break;\n+                case TINYINT:\n+                case SMALLINT:\n+                case INT:\n+                case BIGINT:\n+                    value = expr.getLongValue();\n+                    keyType = KeyType.LONG;\n+                    break;\n+            }\n+            return true;\n+        }\n+\n+        public void clone(PartitionKeyType key) {\n+            keyType = key.keyType;\n+            value = key.value;\n+            date = key.date;\n+        }\n+\n+        public boolean equals(PartitionKeyType key) {\n+            return realValue() == key.realValue();\n+        }\n+\n+        public void add(int num) {\n+            if (keyType == KeyType.DATE) {\n+                date = new Date(date.getTime() + num * 3600 * 24 * 1000);\n+            } else {\n+                value += num;\n+            }\n+        }\n+\n+        public String toString() {\n+            if (keyType == KeyType.DEFAULT) {\n+                return \"\";\n+            } else if (keyType == KeyType.DATE) {\n+                return df10.format(date);\n+            } else {\n+                return String.valueOf(value);\n+            }\n+        }\n+\n+        public long realValue() {\n+            if (keyType == KeyType.DATE) {\n+                return Long.parseLong(df8.format(date));\n+            } else {\n+                return value;\n+            }\n+        }\n+\n+        private Date getDateValue(LiteralExpr expr) {\n+            value = expr.getLongValue() / 1000000;\n+            Date dt = null;\n+            try {\n+                dt = df8.parse(String.valueOf(value));\n+            } catch (Exception e) {\n+            }\n+            return dt;\n+        }\n+    }\n+\n+    private CompoundPredicate partitionKeyPredicate;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo rangePartitionInfo;\n+    private Column partitionColumn;\n+    private List<PartitionSingle> partitionSingleList;\n+\n+    public CompoundPredicate getPartitionKeyPredicate() {\n+        return partitionKeyPredicate;\n+    }\n+\n+    public void setPartitionKeyPredicate(CompoundPredicate partitionKeyPredicate) {\n+        this.partitionKeyPredicate = partitionKeyPredicate;\n+    }\n+\n+    public RangePartitionInfo getRangePartitionInfo() {\n+        return rangePartitionInfo;\n+    }\n+\n+    public void setRangePartitionInfo(RangePartitionInfo rangePartitionInfo) {\n+        this.rangePartitionInfo = rangePartitionInfo;\n+    }\n+\n+    public Column getPartitionColumn() {\n+        return partitionColumn;\n+    }\n+\n+    public void setPartitionColumn(Column partitionColumn) {\n+        this.partitionColumn = partitionColumn;\n+    }\n+\n+    public List<PartitionSingle> getPartitionSingleList() {\n+        return partitionSingleList;\n+    }\n+\n+    public PartitionRange() {\n+    }\n+\n+    public PartitionRange(CompoundPredicate partitionKeyPredicate, OlapTable olapTable,\n+                          RangePartitionInfo rangePartitionInfo) {\n+        this.partitionKeyPredicate = partitionKeyPredicate;\n+        this.olapTable = olapTable;\n+        this.rangePartitionInfo = rangePartitionInfo;\n+        this.partitionSingleList = Lists.newArrayList();\n+    }\n+\n+    /**\n+     * analytics PartitionKey and PartitionInfo\n+     *\n+     * @return\n+     */\n+    public boolean analytics() {\n+        if (rangePartitionInfo.getPartitionColumns().size() != 1) {\n+            return false;\n+        }\n+        partitionColumn = rangePartitionInfo.getPartitionColumns().get(0);\n+        PartitionColumnFilter filter = createPartitionFilter(this.partitionKeyPredicate, partitionColumn);\n+        try {\n+            if (!buildPartitionKeyRange(filter, partitionColumn)) {\n+                return false;\n+            }\n+            getTablePartitionList(olapTable);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"get partition range failed, because:\", e);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public boolean setCacheFlag(long cacheKey) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getCacheKey().realValue() == cacheKey) {\n+                single.setFromCache(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    public boolean setTooNewByID(long partitionId) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getPartition().getId() == partitionId) {\n+                single.setTooNew(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    public boolean setTooNewByKey(long cacheKey) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getCacheKey().realValue() == cacheKey) {\n+                single.setTooNew(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    /**\n+     * Support left or right hit cache, not support middle.\n+     * 20200113-2020115, not support 20200114", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI3NzA2NQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r472277065", "bodyText": "It's my problem. I explained it in detail in be, but it's simplified here", "author": "marising", "createdAt": "2020-08-18T15:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0NDUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0OTQxMg==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468649412", "bodyText": "diskPartitionRange ? need a better name.", "author": "kangkaisen", "createdAt": "2020-08-11T15:00:51Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/PartitionRange.java", "diffHunk": "@@ -0,0 +1,596 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DateLiteral;\n+import org.apache.doris.analysis.InPredicate;\n+import org.apache.doris.analysis.PartitionValue;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.IntLiteral;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.PrimitiveType;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionKey;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.planner.PartitionColumnFilter;\n+\n+import org.apache.doris.common.AnalysisException;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Convert the range of the partition to the list\n+ * all partition by day/week/month split to day list\n+ */\n+public class PartitionRange {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRange.class);\n+\n+    public class PartitionSingle {\n+        private Partition partition;\n+        private PartitionKey partitionKey;\n+        private long partitionId;\n+        private PartitionKeyType cacheKey;\n+        private boolean fromCache;\n+        private boolean tooNew;\n+\n+        public Partition getPartition() {\n+            return partition;\n+        }\n+\n+        public void setPartition(Partition partition) {\n+            this.partition = partition;\n+        }\n+\n+        public PartitionKey getPartitionKey() {\n+            return partitionKey;\n+        }\n+\n+        public void setPartitionKey(PartitionKey key) {\n+            this.partitionKey = key;\n+        }\n+\n+        public long getPartitionId() {\n+            return partitionId;\n+        }\n+\n+        public void setPartitionId(long partitionId) {\n+            this.partitionId = partitionId;\n+        }\n+\n+        public PartitionKeyType getCacheKey() {\n+            return cacheKey;\n+        }\n+\n+        public void setCacheKey(PartitionKeyType cacheKey) {\n+            this.cacheKey.clone(cacheKey);\n+        }\n+\n+        public boolean isFromCache() {\n+            return fromCache;\n+        }\n+\n+        public void setFromCache(boolean fromCache) {\n+            this.fromCache = fromCache;\n+        }\n+\n+        public boolean isTooNew() {\n+            return tooNew;\n+        }\n+\n+        public void setTooNew(boolean tooNew) {\n+            this.tooNew = tooNew;\n+        }\n+\n+        public PartitionSingle() {\n+            this.partitionId = 0;\n+            this.cacheKey = new PartitionKeyType();\n+            this.fromCache = false;\n+            this.tooNew = false;\n+        }\n+\n+        public void Debug() {\n+            if (partition != null) {\n+                LOG.info(\"partition id {}, cacheKey {}, version {}, time {}, fromCache {}, tooNew {} \",\n+                        partitionId, cacheKey.realValue(),\n+                        partition.getVisibleVersion(), partition.getVisibleVersionTime(),\n+                        fromCache, tooNew);\n+            } else {\n+                LOG.info(\"partition id {}, cacheKey {}, fromCache {}, tooNew {} \", partitionId,\n+                        cacheKey.realValue(), fromCache, tooNew);\n+            }\n+        }\n+    }\n+\n+    public enum KeyType {\n+        DEFAULT,\n+        LONG,\n+        DATE,\n+        DATETIME,\n+        TIME\n+    }\n+\n+    public static class PartitionKeyType {\n+        private SimpleDateFormat df8 = new SimpleDateFormat(\"yyyyMMdd\");\n+        private SimpleDateFormat df10 = new SimpleDateFormat(\"yyyy-MM-dd\");\n+\n+        public KeyType keyType = KeyType.DEFAULT;\n+        public long value;\n+        public Date date;\n+\n+        public boolean init(Type type, String str) {\n+            if (type.getPrimitiveType() == PrimitiveType.DATE) {\n+                try {\n+                    date = df10.parse(str);\n+                } catch (Exception e) {\n+                    LOG.warn(\"parse error str{}.\", str);\n+                    return false;\n+                }\n+                keyType = KeyType.DATE;\n+            } else {\n+                value = Long.valueOf(str);\n+                keyType = KeyType.LONG;\n+            }\n+            return true;\n+        }\n+\n+        public boolean init(Type type, LiteralExpr expr) {\n+            switch (type.getPrimitiveType()) {\n+                case BOOLEAN:\n+                case TIME:\n+                case DATETIME:\n+                case FLOAT:\n+                case DOUBLE:\n+                case DECIMAL:\n+                case DECIMALV2:\n+                case CHAR:\n+                case VARCHAR:\n+                case LARGEINT:\n+                    LOG.info(\"PartitionCache not support such key type {}\", type.toSql());\n+                    return false;\n+                case DATE:\n+                    date = getDateValue(expr);\n+                    keyType = KeyType.DATE;\n+                    break;\n+                case TINYINT:\n+                case SMALLINT:\n+                case INT:\n+                case BIGINT:\n+                    value = expr.getLongValue();\n+                    keyType = KeyType.LONG;\n+                    break;\n+            }\n+            return true;\n+        }\n+\n+        public void clone(PartitionKeyType key) {\n+            keyType = key.keyType;\n+            value = key.value;\n+            date = key.date;\n+        }\n+\n+        public boolean equals(PartitionKeyType key) {\n+            return realValue() == key.realValue();\n+        }\n+\n+        public void add(int num) {\n+            if (keyType == KeyType.DATE) {\n+                date = new Date(date.getTime() + num * 3600 * 24 * 1000);\n+            } else {\n+                value += num;\n+            }\n+        }\n+\n+        public String toString() {\n+            if (keyType == KeyType.DEFAULT) {\n+                return \"\";\n+            } else if (keyType == KeyType.DATE) {\n+                return df10.format(date);\n+            } else {\n+                return String.valueOf(value);\n+            }\n+        }\n+\n+        public long realValue() {\n+            if (keyType == KeyType.DATE) {\n+                return Long.parseLong(df8.format(date));\n+            } else {\n+                return value;\n+            }\n+        }\n+\n+        private Date getDateValue(LiteralExpr expr) {\n+            value = expr.getLongValue() / 1000000;\n+            Date dt = null;\n+            try {\n+                dt = df8.parse(String.valueOf(value));\n+            } catch (Exception e) {\n+            }\n+            return dt;\n+        }\n+    }\n+\n+    private CompoundPredicate partitionKeyPredicate;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo rangePartitionInfo;\n+    private Column partitionColumn;\n+    private List<PartitionSingle> partitionSingleList;\n+\n+    public CompoundPredicate getPartitionKeyPredicate() {\n+        return partitionKeyPredicate;\n+    }\n+\n+    public void setPartitionKeyPredicate(CompoundPredicate partitionKeyPredicate) {\n+        this.partitionKeyPredicate = partitionKeyPredicate;\n+    }\n+\n+    public RangePartitionInfo getRangePartitionInfo() {\n+        return rangePartitionInfo;\n+    }\n+\n+    public void setRangePartitionInfo(RangePartitionInfo rangePartitionInfo) {\n+        this.rangePartitionInfo = rangePartitionInfo;\n+    }\n+\n+    public Column getPartitionColumn() {\n+        return partitionColumn;\n+    }\n+\n+    public void setPartitionColumn(Column partitionColumn) {\n+        this.partitionColumn = partitionColumn;\n+    }\n+\n+    public List<PartitionSingle> getPartitionSingleList() {\n+        return partitionSingleList;\n+    }\n+\n+    public PartitionRange() {\n+    }\n+\n+    public PartitionRange(CompoundPredicate partitionKeyPredicate, OlapTable olapTable,\n+                          RangePartitionInfo rangePartitionInfo) {\n+        this.partitionKeyPredicate = partitionKeyPredicate;\n+        this.olapTable = olapTable;\n+        this.rangePartitionInfo = rangePartitionInfo;\n+        this.partitionSingleList = Lists.newArrayList();\n+    }\n+\n+    /**\n+     * analytics PartitionKey and PartitionInfo\n+     *\n+     * @return\n+     */\n+    public boolean analytics() {\n+        if (rangePartitionInfo.getPartitionColumns().size() != 1) {\n+            return false;\n+        }\n+        partitionColumn = rangePartitionInfo.getPartitionColumns().get(0);\n+        PartitionColumnFilter filter = createPartitionFilter(this.partitionKeyPredicate, partitionColumn);\n+        try {\n+            if (!buildPartitionKeyRange(filter, partitionColumn)) {\n+                return false;\n+            }\n+            getTablePartitionList(olapTable);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"get partition range failed, because:\", e);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public boolean setCacheFlag(long cacheKey) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getCacheKey().realValue() == cacheKey) {\n+                single.setFromCache(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    public boolean setTooNewByID(long partitionId) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getPartition().getId() == partitionId) {\n+                single.setTooNew(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    public boolean setTooNewByKey(long cacheKey) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getCacheKey().realValue() == cacheKey) {\n+                single.setTooNew(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    /**\n+     * Support left or right hit cache, not support middle.\n+     * 20200113-2020115, not support 20200114\n+     */\n+    public Cache.HitRange diskPartitionRange(List<PartitionSingle> rangeList) {", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYxMTE5OQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r472611199", "bodyText": "buildDiskPartitionRange();", "author": "marising", "createdAt": "2020-08-19T02:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0OTQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU2NzIzNg==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r473567236", "bodyText": "OK", "author": "kangkaisen", "createdAt": "2020-08-20T03:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0OTQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MDk2OA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468650968", "bodyText": "need a better name.", "author": "kangkaisen", "createdAt": "2020-08-11T15:02:51Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/RowBatchBuilder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+public class RowBatchBuilder {\n+    private static final Logger LOG = LogManager.getLogger(RowBatchBuilder.class);\n+\n+    private CacheBeProxy.UpdateCacheRequest updateRequest;\n+    private CacheAnalyzer.CacheMode cacheMode;\n+    private int keyIndex;\n+    private Type keyType;\n+    private HashMap<Long, PartitionRange.PartitionSingle> cachePartMap;\n+    private List<byte[]> rowList;\n+    private int batchSize;\n+    private int rowSize;\n+    private int dataSize;\n+\n+    public int getRowSize() {\n+        return rowSize;\n+    }\n+\n+    public RowBatchBuilder(CacheAnalyzer.CacheMode model) {\n+        cacheMode = model;\n+        keyIndex = 0;\n+        keyType = Type.INVALID;\n+        rowList = Lists.newArrayList();\n+        cachePartMap = new HashMap<>();\n+        batchSize = 0;\n+        rowSize = 0;\n+        dataSize = 0;\n+    }\n+\n+    public void partitionIndex(ArrayList<Expr> resultExpr,", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MTgwMA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468651800", "bodyText": "Add a comment for this method.", "author": "kangkaisen", "createdAt": "2020-08-11T15:04:03Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/PartitionRange.java", "diffHunk": "@@ -0,0 +1,596 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.DateLiteral;\n+import org.apache.doris.analysis.InPredicate;\n+import org.apache.doris.analysis.PartitionValue;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.LiteralExpr;\n+import org.apache.doris.analysis.IntLiteral;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.PrimitiveType;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.PartitionKey;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.planner.PartitionColumnFilter;\n+\n+import org.apache.doris.common.AnalysisException;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Convert the range of the partition to the list\n+ * all partition by day/week/month split to day list\n+ */\n+public class PartitionRange {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRange.class);\n+\n+    public class PartitionSingle {\n+        private Partition partition;\n+        private PartitionKey partitionKey;\n+        private long partitionId;\n+        private PartitionKeyType cacheKey;\n+        private boolean fromCache;\n+        private boolean tooNew;\n+\n+        public Partition getPartition() {\n+            return partition;\n+        }\n+\n+        public void setPartition(Partition partition) {\n+            this.partition = partition;\n+        }\n+\n+        public PartitionKey getPartitionKey() {\n+            return partitionKey;\n+        }\n+\n+        public void setPartitionKey(PartitionKey key) {\n+            this.partitionKey = key;\n+        }\n+\n+        public long getPartitionId() {\n+            return partitionId;\n+        }\n+\n+        public void setPartitionId(long partitionId) {\n+            this.partitionId = partitionId;\n+        }\n+\n+        public PartitionKeyType getCacheKey() {\n+            return cacheKey;\n+        }\n+\n+        public void setCacheKey(PartitionKeyType cacheKey) {\n+            this.cacheKey.clone(cacheKey);\n+        }\n+\n+        public boolean isFromCache() {\n+            return fromCache;\n+        }\n+\n+        public void setFromCache(boolean fromCache) {\n+            this.fromCache = fromCache;\n+        }\n+\n+        public boolean isTooNew() {\n+            return tooNew;\n+        }\n+\n+        public void setTooNew(boolean tooNew) {\n+            this.tooNew = tooNew;\n+        }\n+\n+        public PartitionSingle() {\n+            this.partitionId = 0;\n+            this.cacheKey = new PartitionKeyType();\n+            this.fromCache = false;\n+            this.tooNew = false;\n+        }\n+\n+        public void Debug() {\n+            if (partition != null) {\n+                LOG.info(\"partition id {}, cacheKey {}, version {}, time {}, fromCache {}, tooNew {} \",\n+                        partitionId, cacheKey.realValue(),\n+                        partition.getVisibleVersion(), partition.getVisibleVersionTime(),\n+                        fromCache, tooNew);\n+            } else {\n+                LOG.info(\"partition id {}, cacheKey {}, fromCache {}, tooNew {} \", partitionId,\n+                        cacheKey.realValue(), fromCache, tooNew);\n+            }\n+        }\n+    }\n+\n+    public enum KeyType {\n+        DEFAULT,\n+        LONG,\n+        DATE,\n+        DATETIME,\n+        TIME\n+    }\n+\n+    public static class PartitionKeyType {\n+        private SimpleDateFormat df8 = new SimpleDateFormat(\"yyyyMMdd\");\n+        private SimpleDateFormat df10 = new SimpleDateFormat(\"yyyy-MM-dd\");\n+\n+        public KeyType keyType = KeyType.DEFAULT;\n+        public long value;\n+        public Date date;\n+\n+        public boolean init(Type type, String str) {\n+            if (type.getPrimitiveType() == PrimitiveType.DATE) {\n+                try {\n+                    date = df10.parse(str);\n+                } catch (Exception e) {\n+                    LOG.warn(\"parse error str{}.\", str);\n+                    return false;\n+                }\n+                keyType = KeyType.DATE;\n+            } else {\n+                value = Long.valueOf(str);\n+                keyType = KeyType.LONG;\n+            }\n+            return true;\n+        }\n+\n+        public boolean init(Type type, LiteralExpr expr) {\n+            switch (type.getPrimitiveType()) {\n+                case BOOLEAN:\n+                case TIME:\n+                case DATETIME:\n+                case FLOAT:\n+                case DOUBLE:\n+                case DECIMAL:\n+                case DECIMALV2:\n+                case CHAR:\n+                case VARCHAR:\n+                case LARGEINT:\n+                    LOG.info(\"PartitionCache not support such key type {}\", type.toSql());\n+                    return false;\n+                case DATE:\n+                    date = getDateValue(expr);\n+                    keyType = KeyType.DATE;\n+                    break;\n+                case TINYINT:\n+                case SMALLINT:\n+                case INT:\n+                case BIGINT:\n+                    value = expr.getLongValue();\n+                    keyType = KeyType.LONG;\n+                    break;\n+            }\n+            return true;\n+        }\n+\n+        public void clone(PartitionKeyType key) {\n+            keyType = key.keyType;\n+            value = key.value;\n+            date = key.date;\n+        }\n+\n+        public boolean equals(PartitionKeyType key) {\n+            return realValue() == key.realValue();\n+        }\n+\n+        public void add(int num) {\n+            if (keyType == KeyType.DATE) {\n+                date = new Date(date.getTime() + num * 3600 * 24 * 1000);\n+            } else {\n+                value += num;\n+            }\n+        }\n+\n+        public String toString() {\n+            if (keyType == KeyType.DEFAULT) {\n+                return \"\";\n+            } else if (keyType == KeyType.DATE) {\n+                return df10.format(date);\n+            } else {\n+                return String.valueOf(value);\n+            }\n+        }\n+\n+        public long realValue() {\n+            if (keyType == KeyType.DATE) {\n+                return Long.parseLong(df8.format(date));\n+            } else {\n+                return value;\n+            }\n+        }\n+\n+        private Date getDateValue(LiteralExpr expr) {\n+            value = expr.getLongValue() / 1000000;\n+            Date dt = null;\n+            try {\n+                dt = df8.parse(String.valueOf(value));\n+            } catch (Exception e) {\n+            }\n+            return dt;\n+        }\n+    }\n+\n+    private CompoundPredicate partitionKeyPredicate;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo rangePartitionInfo;\n+    private Column partitionColumn;\n+    private List<PartitionSingle> partitionSingleList;\n+\n+    public CompoundPredicate getPartitionKeyPredicate() {\n+        return partitionKeyPredicate;\n+    }\n+\n+    public void setPartitionKeyPredicate(CompoundPredicate partitionKeyPredicate) {\n+        this.partitionKeyPredicate = partitionKeyPredicate;\n+    }\n+\n+    public RangePartitionInfo getRangePartitionInfo() {\n+        return rangePartitionInfo;\n+    }\n+\n+    public void setRangePartitionInfo(RangePartitionInfo rangePartitionInfo) {\n+        this.rangePartitionInfo = rangePartitionInfo;\n+    }\n+\n+    public Column getPartitionColumn() {\n+        return partitionColumn;\n+    }\n+\n+    public void setPartitionColumn(Column partitionColumn) {\n+        this.partitionColumn = partitionColumn;\n+    }\n+\n+    public List<PartitionSingle> getPartitionSingleList() {\n+        return partitionSingleList;\n+    }\n+\n+    public PartitionRange() {\n+    }\n+\n+    public PartitionRange(CompoundPredicate partitionKeyPredicate, OlapTable olapTable,\n+                          RangePartitionInfo rangePartitionInfo) {\n+        this.partitionKeyPredicate = partitionKeyPredicate;\n+        this.olapTable = olapTable;\n+        this.rangePartitionInfo = rangePartitionInfo;\n+        this.partitionSingleList = Lists.newArrayList();\n+    }\n+\n+    /**\n+     * analytics PartitionKey and PartitionInfo\n+     *\n+     * @return\n+     */\n+    public boolean analytics() {\n+        if (rangePartitionInfo.getPartitionColumns().size() != 1) {\n+            return false;\n+        }\n+        partitionColumn = rangePartitionInfo.getPartitionColumns().get(0);\n+        PartitionColumnFilter filter = createPartitionFilter(this.partitionKeyPredicate, partitionColumn);\n+        try {\n+            if (!buildPartitionKeyRange(filter, partitionColumn)) {\n+                return false;\n+            }\n+            getTablePartitionList(olapTable);\n+        } catch (AnalysisException e) {\n+            LOG.warn(\"get partition range failed, because:\", e);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public boolean setCacheFlag(long cacheKey) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getCacheKey().realValue() == cacheKey) {\n+                single.setFromCache(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    public boolean setTooNewByID(long partitionId) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getPartition().getId() == partitionId) {\n+                single.setTooNew(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    public boolean setTooNewByKey(long cacheKey) {\n+        boolean find = false;\n+        for (PartitionSingle single : partitionSingleList) {\n+            if (single.getCacheKey().realValue() == cacheKey) {\n+                single.setTooNew(true);\n+                find = true;\n+                break;\n+            }\n+        }\n+        return find;\n+    }\n+\n+    /**\n+     * Support left or right hit cache, not support middle.\n+     * 20200113-2020115, not support 20200114\n+     */\n+    public Cache.HitRange diskPartitionRange(List<PartitionSingle> rangeList) {\n+        Cache.HitRange hitRange = Cache.HitRange.None;\n+        if (partitionSingleList.size() == 0) {\n+            return hitRange;\n+        }\n+        int begin = partitionSingleList.size() - 1;\n+        int end = 0;\n+        for (int i = 0; i < partitionSingleList.size(); i++) {\n+            if (!partitionSingleList.get(i).isFromCache()) {\n+                if (begin > i) {\n+                    begin = i;\n+                }\n+                if (end < i) {\n+                    end = i;\n+                }\n+            }\n+        }\n+        if (end < begin) {\n+            hitRange = Cache.HitRange.Full;\n+            return hitRange;\n+        }\n+\n+        if (end == partitionSingleList.size() - 1) {\n+            hitRange = Cache.HitRange.Left;\n+        }\n+        if (begin == 0) {\n+            hitRange = Cache.HitRange.Right;\n+        }\n+\n+        rangeList.add(partitionSingleList.get(begin));\n+        rangeList.add(partitionSingleList.get(end));\n+        LOG.info(\"the new range for scan be is [{},{}], hit range\", rangeList.get(0).getCacheKey().realValue(),\n+                rangeList.get(1).getCacheKey().realValue(), hitRange);\n+        return hitRange;\n+    }\n+\n+    public List<PartitionSingle> updatePartitionRange() {", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NTkwMQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468655901", "bodyText": "Why AggregateInfo cannot be distinct agg? if distinct cache result is final result, I think which is OK.", "author": "kangkaisen", "createdAt": "2020-08-11T15:09:52Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheAnalyzer.java", "diffHunk": "@@ -0,0 +1,450 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.AggregateInfo;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.CastExpr;\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.InlineViewRef;\n+import org.apache.doris.analysis.QueryStmt;\n+import org.apache.doris.analysis.SelectStmt;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.analysis.StatementBase;\n+import org.apache.doris.analysis.TableRef;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.metric.MetricRepo;\n+import org.apache.doris.planner.OlapScanNode;\n+import org.apache.doris.planner.Planner;\n+import org.apache.doris.planner.ScanNode;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Status;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.thrift.TUniqueId;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Analyze which caching mode a SQL is suitable for\n+ * 1. T + 1 update is suitable for SQL mode\n+ * 2. Partition by date, update the data of the day in near real time, which is suitable for Partition mode\n+ */\n+public class CacheAnalyzer {\n+    private static final Logger LOG = LogManager.getLogger(CacheAnalyzer.class);\n+\n+    /**\n+     * NoNeed : disable config or variable, not query, not scan table etc.\n+     */\n+    public enum CacheMode {\n+        NoNeed,\n+        None,\n+        TTL,\n+        Sql,\n+        Partition\n+    }\n+\n+    private ConnectContext context;\n+    private boolean enableSqlCache = false;\n+    private boolean enablePartitionCache = false;\n+    private TUniqueId queryId;\n+    private CacheMode cacheMode;\n+    private CacheTable latestTable;\n+    private StatementBase parsedStmt;\n+    private SelectStmt selectStmt;\n+    private List<ScanNode> scanNodes;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo partitionInfo;\n+    private Column partColumn;\n+    private CompoundPredicate partitionPredicate;\n+    private Cache cache;\n+\n+    public Cache getCache() {\n+        return cache;\n+    }\n+\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, Planner planner) {\n+        this.context = context;\n+        this.queryId = context.queryId();\n+        this.parsedStmt = parsedStmt;\n+        scanNodes = planner.getScanNodes();\n+        latestTable = new CacheTable();\n+        checkCacheConfig();\n+    }\n+\n+    //for unit test\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, List<ScanNode> scanNodes) {\n+        this.context = context;\n+        this.parsedStmt = parsedStmt;\n+        this.scanNodes = scanNodes;\n+        checkCacheConfig();\n+    }\n+\n+    private void checkCacheConfig() {\n+        if (Config.cache_enable_sql_mode) {\n+            if (context.getSessionVariable().isEnableSqlCache()) {\n+                enableSqlCache = true;\n+            }\n+        }\n+        if (Config.cache_enable_partition_mode) {\n+            if (context.getSessionVariable().isEnablePartitionCache()) {\n+                enablePartitionCache = true;\n+            }\n+        }\n+    }\n+\n+    public CacheMode getCacheMode() {\n+        return cacheMode;\n+    }\n+\n+    public class CacheTable implements Comparable<CacheTable> {\n+        public OlapTable olapTable;\n+        public long latestId;\n+        public long latestVersion;\n+        public long latestTime;\n+\n+        public CacheTable() {\n+            olapTable = null;\n+            latestId = 0;\n+            latestVersion = 0;\n+            latestTime = 0;\n+        }\n+\n+        @Override\n+        public int compareTo(CacheTable table) {\n+            return (int) (table.latestTime - this.latestTime);\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"table {}, partition id {}, ver {}, time {}\", olapTable.getName(), latestId, latestVersion, latestTime);\n+        }\n+    }\n+\n+    public boolean enableCache() {\n+        return enableSqlCache || enablePartitionCache;\n+    }\n+\n+    public boolean enableSqlCache() {\n+        return enableSqlCache;\n+    }\n+\n+    public boolean enablePartitionCache() {\n+        return enablePartitionCache;\n+    }\n+\n+    /**\n+     * Check cache mode with SQL and table\n+     * 1\u3001Only Olap table\n+     * 2\u3001The update time of the table is before Config.last_version_interval_time\n+     * 2\u3001PartitionType is PartitionType.RANGE, and partition key has only one column\n+     * 4\u3001Partition key must be included in the group by clause\n+     * 5\u3001Where clause must contain only one partition key predicate\n+     * CacheMode.Sql\n+     * xxx FROM user_profile, updated before Config.last_version_interval_time\n+     * CacheMode.Partition, partition by event_date, only the partition of today will be updated.\n+     * SELECT xxx FROM app_event WHERE event_date >= 20191201 AND event_date <= 20191207 GROUP BY event_date\n+     * SELECT xxx FROM app_event INNER JOIN user_Profile ON app_event.user_id = user_profile.user_id xxx\n+     * SELECT xxx FROM app_event INNER JOIN user_profile ON xxx INNER JOIN site_channel ON xxx\n+     */\n+    public void checkCacheMode(long now) {\n+        cacheMode = innerCheckCacheMode(now);\n+    }\n+\n+    private CacheMode innerCheckCacheMode(long now) {\n+        if (!enableCache()) {\n+            return CacheMode.NoNeed;\n+        }\n+        if (!(parsedStmt instanceof SelectStmt) || scanNodes.size() == 0) {\n+            return CacheMode.NoNeed;\n+        }\n+        MetricRepo.COUNTER_QUERY_TABLE.increase(1L);\n+\n+        this.selectStmt = (SelectStmt) parsedStmt;\n+        //Check the last version time of the table\n+        List<CacheTable> tblTimeList = Lists.newArrayList();\n+        for (int i = 0; i < scanNodes.size(); i++) {\n+            ScanNode node = scanNodes.get(i);\n+            if (!(node instanceof OlapScanNode)) {\n+                return CacheMode.None;\n+            }\n+            OlapScanNode oNode = (OlapScanNode) node;\n+            OlapTable oTable = oNode.getOlapTable();\n+            CacheTable cTable = getLastUpdateTime(oTable);\n+            tblTimeList.add(cTable);\n+        }\n+        MetricRepo.COUNTER_QUERY_OLAP_TABLE.increase(1L);\n+        Collections.sort(tblTimeList);\n+        latestTable = tblTimeList.get(0);\n+        latestTable.Debug();\n+\n+        if (now == 0) {\n+            now = nowtime();\n+        }\n+        if (enableSqlCache() &&\n+                (now - latestTable.latestTime) >= Config.cache_last_version_interval_second * 1000) {\n+            LOG.info(\"TIME:{},{},{}\", now, latestTable.latestTime, Config.cache_last_version_interval_second*1000);\n+            cache = new SqlCache(this.queryId, this.selectStmt);\n+            ((SqlCache) cache).setCacheInfo(this.latestTable);\n+            MetricRepo.COUNTER_CACHE_MODE_SQL.increase(1L);\n+            return CacheMode.Sql;\n+        }\n+\n+        if (!enablePartitionCache()) {\n+            return CacheMode.None;\n+        }\n+\n+        //Check if selectStmt matches partition key\n+        //Only one table can be updated in Config.cache_last_version_interval_second range\n+        for (int i = 1; i < tblTimeList.size(); i++) {\n+            if ((now - tblTimeList.get(i).latestTime) < Config.cache_last_version_interval_second * 1000) {\n+                LOG.info(\"the time of other tables is newer than {}\", Config.cache_last_version_interval_second);\n+                return CacheMode.None;\n+            }\n+        }\n+        olapTable = latestTable.olapTable;\n+        if (olapTable.getPartitionInfo().getType() != PartitionType.RANGE) {\n+            LOG.info(\"the partition of OlapTable not RANGE type\");\n+            return CacheMode.None;\n+        }\n+        partitionInfo = (RangePartitionInfo) olapTable.getPartitionInfo();\n+        List<Column> columns = partitionInfo.getPartitionColumns();\n+        //Partition key has only one column\n+        if (columns.size() != 1) {\n+            LOG.info(\"the size of columns for partition key is {}\", columns.size());\n+            return CacheMode.None;\n+        }\n+        partColumn = columns.get(0);\n+        //Check if group expr contain partition column\n+        if (!checkGroupByPartitionKey(this.selectStmt, partColumn)) {\n+            LOG.info(\"not group by partition key, key {}\", partColumn.getName());\n+            return CacheMode.None;\n+        }\n+        //Check if whereClause have one CompoundPredicate of partition column\n+        List<CompoundPredicate> compoundPredicates = Lists.newArrayList();\n+        getPartitionKeyFromSelectStmt(this.selectStmt, partColumn, compoundPredicates);\n+        if (compoundPredicates.size() != 1) {\n+            LOG.info(\"the predicate size include partition key has {}\", compoundPredicates.size());\n+            return CacheMode.None;\n+        }\n+        partitionPredicate = compoundPredicates.get(0);\n+        cache = new PartitionCache(this.queryId, this.selectStmt);\n+        ((PartitionCache) cache).setCacheInfo(this.latestTable, this.partitionInfo, this.partColumn,\n+                this.partitionPredicate);\n+        MetricRepo.COUNTER_CACHE_MODE_PARTITION.increase(1L);\n+        return CacheMode.Partition;\n+    }\n+\n+    public CacheBeProxy.FetchCacheResult getCacheData() {\n+        CacheProxy.FetchCacheResult cacheResult = null;\n+        cacheMode = innerCheckCacheMode(0);\n+        if (cacheMode == CacheMode.NoNeed) {\n+            return cacheResult;\n+        }\n+        if (cacheMode == CacheMode.None) {\n+            LOG.info(\"check cache mode {}, queryid {}\", cacheMode, DebugUtil.printId(queryId));\n+            return cacheResult;\n+        }\n+        Status status = new Status();\n+        cacheResult = cache.getCacheData(status);\n+\n+        if (status.ok() && cacheResult != null) {\n+            LOG.info(\"hit cache, mode {}, queryid {}, all count {}, value count {}, row count {}, data size {}\",\n+                    cacheMode, DebugUtil.printId(queryId),\n+                    cacheResult.all_count, cacheResult.value_count,\n+                    cacheResult.row_count, cacheResult.data_size);\n+        } else {\n+            LOG.info(\"miss cache, mode {}, queryid {}, code {}, msg {}\", cacheMode,\n+                    DebugUtil.printId(queryId), status.getErrorCode(), status.getErrorMsg());\n+            cacheResult = null;\n+        }\n+        return cacheResult;\n+    }\n+\n+    public long nowtime() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    private void getPartitionKeyFromSelectStmt(SelectStmt stmt, Column partColumn,\n+                                               List<CompoundPredicate> compoundPredicates) {\n+        getPartitionKeyFromWhereClause(stmt.getWhereClause(), partColumn, compoundPredicates);\n+        List<TableRef> tableRefs = stmt.getTableRefs();\n+        for (TableRef tblRef : tableRefs) {\n+            if (tblRef instanceof InlineViewRef) {\n+                InlineViewRef viewRef = (InlineViewRef) tblRef;\n+                QueryStmt queryStmt = viewRef.getViewStmt();\n+                if (queryStmt instanceof SelectStmt) {\n+                    getPartitionKeyFromSelectStmt((SelectStmt) queryStmt, partColumn, compoundPredicates);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Only support case 1\n+     * 1.key >= a and key <= b\n+     * 2.key = a or key = b\n+     * 3.key in(a,b,c)\n+     */\n+    private void getPartitionKeyFromWhereClause(Expr expr, Column partColumn,\n+                                                List<CompoundPredicate> compoundPredicates) {\n+        if (expr == null) {\n+            return;\n+        }\n+        if (expr instanceof CompoundPredicate) {\n+            CompoundPredicate cp = (CompoundPredicate) expr;\n+            if (cp.getOp() == CompoundPredicate.Operator.AND) {\n+                if (cp.getChildren().size() == 2 && cp.getChild(0) instanceof BinaryPredicate &&\n+                        cp.getChild(1) instanceof BinaryPredicate) {\n+                    BinaryPredicate leftPre = (BinaryPredicate) cp.getChild(0);\n+                    BinaryPredicate rightPre = (BinaryPredicate) cp.getChild(1);\n+                    String leftColumn = getColumnName(leftPre);\n+                    String rightColumn = getColumnName(rightPre);\n+                    if (leftColumn.equalsIgnoreCase(partColumn.getName()) &&\n+                            rightColumn.equalsIgnoreCase(partColumn.getName())) {\n+                        compoundPredicates.add(cp);\n+                    }\n+                }\n+            }\n+            for (Expr subExpr : expr.getChildren()) {\n+                getPartitionKeyFromWhereClause(subExpr, partColumn, compoundPredicates);\n+            }\n+        }\n+    }\n+\n+    private String getColumnName(BinaryPredicate predicate) {\n+        SlotRef slot = null;\n+        if (predicate.getChild(0) instanceof SlotRef) {\n+            slot = (SlotRef) predicate.getChild(0);\n+        } else if (predicate.getChild(0) instanceof CastExpr) {\n+            CastExpr expr = (CastExpr) predicate.getChild(0);\n+            if (expr.getChild(0) instanceof SlotRef) {\n+                slot = (SlotRef) expr.getChild(0);\n+            }\n+        }\n+\n+        if (slot != null) {\n+            return slot.getColumnName();\n+        }\n+        return \"\";\n+    }\n+\n+    /**\n+     * Check the selectStmt and tableRefs always group by partition key\n+     * 1. At least one group by\n+     * 2. group by must contain partition key\n+     * 3. AggregateInfo cannot be distinct agg", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyOTU2OA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r474429568", "bodyText": "Yes, It's support COUNT(DISTINCT xxx)", "author": "marising", "createdAt": "2020-08-21T06:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NTkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NjY4Mg==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468656682", "bodyText": "Why don't support key = a?  only one BinaryPredicate.", "author": "kangkaisen", "createdAt": "2020-08-11T15:10:54Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheAnalyzer.java", "diffHunk": "@@ -0,0 +1,450 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.AggregateInfo;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.CastExpr;\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.InlineViewRef;\n+import org.apache.doris.analysis.QueryStmt;\n+import org.apache.doris.analysis.SelectStmt;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.analysis.StatementBase;\n+import org.apache.doris.analysis.TableRef;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.metric.MetricRepo;\n+import org.apache.doris.planner.OlapScanNode;\n+import org.apache.doris.planner.Planner;\n+import org.apache.doris.planner.ScanNode;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Status;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.thrift.TUniqueId;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Analyze which caching mode a SQL is suitable for\n+ * 1. T + 1 update is suitable for SQL mode\n+ * 2. Partition by date, update the data of the day in near real time, which is suitable for Partition mode\n+ */\n+public class CacheAnalyzer {\n+    private static final Logger LOG = LogManager.getLogger(CacheAnalyzer.class);\n+\n+    /**\n+     * NoNeed : disable config or variable, not query, not scan table etc.\n+     */\n+    public enum CacheMode {\n+        NoNeed,\n+        None,\n+        TTL,\n+        Sql,\n+        Partition\n+    }\n+\n+    private ConnectContext context;\n+    private boolean enableSqlCache = false;\n+    private boolean enablePartitionCache = false;\n+    private TUniqueId queryId;\n+    private CacheMode cacheMode;\n+    private CacheTable latestTable;\n+    private StatementBase parsedStmt;\n+    private SelectStmt selectStmt;\n+    private List<ScanNode> scanNodes;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo partitionInfo;\n+    private Column partColumn;\n+    private CompoundPredicate partitionPredicate;\n+    private Cache cache;\n+\n+    public Cache getCache() {\n+        return cache;\n+    }\n+\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, Planner planner) {\n+        this.context = context;\n+        this.queryId = context.queryId();\n+        this.parsedStmt = parsedStmt;\n+        scanNodes = planner.getScanNodes();\n+        latestTable = new CacheTable();\n+        checkCacheConfig();\n+    }\n+\n+    //for unit test\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, List<ScanNode> scanNodes) {\n+        this.context = context;\n+        this.parsedStmt = parsedStmt;\n+        this.scanNodes = scanNodes;\n+        checkCacheConfig();\n+    }\n+\n+    private void checkCacheConfig() {\n+        if (Config.cache_enable_sql_mode) {\n+            if (context.getSessionVariable().isEnableSqlCache()) {\n+                enableSqlCache = true;\n+            }\n+        }\n+        if (Config.cache_enable_partition_mode) {\n+            if (context.getSessionVariable().isEnablePartitionCache()) {\n+                enablePartitionCache = true;\n+            }\n+        }\n+    }\n+\n+    public CacheMode getCacheMode() {\n+        return cacheMode;\n+    }\n+\n+    public class CacheTable implements Comparable<CacheTable> {\n+        public OlapTable olapTable;\n+        public long latestId;\n+        public long latestVersion;\n+        public long latestTime;\n+\n+        public CacheTable() {\n+            olapTable = null;\n+            latestId = 0;\n+            latestVersion = 0;\n+            latestTime = 0;\n+        }\n+\n+        @Override\n+        public int compareTo(CacheTable table) {\n+            return (int) (table.latestTime - this.latestTime);\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"table {}, partition id {}, ver {}, time {}\", olapTable.getName(), latestId, latestVersion, latestTime);\n+        }\n+    }\n+\n+    public boolean enableCache() {\n+        return enableSqlCache || enablePartitionCache;\n+    }\n+\n+    public boolean enableSqlCache() {\n+        return enableSqlCache;\n+    }\n+\n+    public boolean enablePartitionCache() {\n+        return enablePartitionCache;\n+    }\n+\n+    /**\n+     * Check cache mode with SQL and table\n+     * 1\u3001Only Olap table\n+     * 2\u3001The update time of the table is before Config.last_version_interval_time\n+     * 2\u3001PartitionType is PartitionType.RANGE, and partition key has only one column\n+     * 4\u3001Partition key must be included in the group by clause\n+     * 5\u3001Where clause must contain only one partition key predicate\n+     * CacheMode.Sql\n+     * xxx FROM user_profile, updated before Config.last_version_interval_time\n+     * CacheMode.Partition, partition by event_date, only the partition of today will be updated.\n+     * SELECT xxx FROM app_event WHERE event_date >= 20191201 AND event_date <= 20191207 GROUP BY event_date\n+     * SELECT xxx FROM app_event INNER JOIN user_Profile ON app_event.user_id = user_profile.user_id xxx\n+     * SELECT xxx FROM app_event INNER JOIN user_profile ON xxx INNER JOIN site_channel ON xxx\n+     */\n+    public void checkCacheMode(long now) {\n+        cacheMode = innerCheckCacheMode(now);\n+    }\n+\n+    private CacheMode innerCheckCacheMode(long now) {\n+        if (!enableCache()) {\n+            return CacheMode.NoNeed;\n+        }\n+        if (!(parsedStmt instanceof SelectStmt) || scanNodes.size() == 0) {\n+            return CacheMode.NoNeed;\n+        }\n+        MetricRepo.COUNTER_QUERY_TABLE.increase(1L);\n+\n+        this.selectStmt = (SelectStmt) parsedStmt;\n+        //Check the last version time of the table\n+        List<CacheTable> tblTimeList = Lists.newArrayList();\n+        for (int i = 0; i < scanNodes.size(); i++) {\n+            ScanNode node = scanNodes.get(i);\n+            if (!(node instanceof OlapScanNode)) {\n+                return CacheMode.None;\n+            }\n+            OlapScanNode oNode = (OlapScanNode) node;\n+            OlapTable oTable = oNode.getOlapTable();\n+            CacheTable cTable = getLastUpdateTime(oTable);\n+            tblTimeList.add(cTable);\n+        }\n+        MetricRepo.COUNTER_QUERY_OLAP_TABLE.increase(1L);\n+        Collections.sort(tblTimeList);\n+        latestTable = tblTimeList.get(0);\n+        latestTable.Debug();\n+\n+        if (now == 0) {\n+            now = nowtime();\n+        }\n+        if (enableSqlCache() &&\n+                (now - latestTable.latestTime) >= Config.cache_last_version_interval_second * 1000) {\n+            LOG.info(\"TIME:{},{},{}\", now, latestTable.latestTime, Config.cache_last_version_interval_second*1000);\n+            cache = new SqlCache(this.queryId, this.selectStmt);\n+            ((SqlCache) cache).setCacheInfo(this.latestTable);\n+            MetricRepo.COUNTER_CACHE_MODE_SQL.increase(1L);\n+            return CacheMode.Sql;\n+        }\n+\n+        if (!enablePartitionCache()) {\n+            return CacheMode.None;\n+        }\n+\n+        //Check if selectStmt matches partition key\n+        //Only one table can be updated in Config.cache_last_version_interval_second range\n+        for (int i = 1; i < tblTimeList.size(); i++) {\n+            if ((now - tblTimeList.get(i).latestTime) < Config.cache_last_version_interval_second * 1000) {\n+                LOG.info(\"the time of other tables is newer than {}\", Config.cache_last_version_interval_second);\n+                return CacheMode.None;\n+            }\n+        }\n+        olapTable = latestTable.olapTable;\n+        if (olapTable.getPartitionInfo().getType() != PartitionType.RANGE) {\n+            LOG.info(\"the partition of OlapTable not RANGE type\");\n+            return CacheMode.None;\n+        }\n+        partitionInfo = (RangePartitionInfo) olapTable.getPartitionInfo();\n+        List<Column> columns = partitionInfo.getPartitionColumns();\n+        //Partition key has only one column\n+        if (columns.size() != 1) {\n+            LOG.info(\"the size of columns for partition key is {}\", columns.size());\n+            return CacheMode.None;\n+        }\n+        partColumn = columns.get(0);\n+        //Check if group expr contain partition column\n+        if (!checkGroupByPartitionKey(this.selectStmt, partColumn)) {\n+            LOG.info(\"not group by partition key, key {}\", partColumn.getName());\n+            return CacheMode.None;\n+        }\n+        //Check if whereClause have one CompoundPredicate of partition column\n+        List<CompoundPredicate> compoundPredicates = Lists.newArrayList();\n+        getPartitionKeyFromSelectStmt(this.selectStmt, partColumn, compoundPredicates);\n+        if (compoundPredicates.size() != 1) {\n+            LOG.info(\"the predicate size include partition key has {}\", compoundPredicates.size());\n+            return CacheMode.None;\n+        }\n+        partitionPredicate = compoundPredicates.get(0);\n+        cache = new PartitionCache(this.queryId, this.selectStmt);\n+        ((PartitionCache) cache).setCacheInfo(this.latestTable, this.partitionInfo, this.partColumn,\n+                this.partitionPredicate);\n+        MetricRepo.COUNTER_CACHE_MODE_PARTITION.increase(1L);\n+        return CacheMode.Partition;\n+    }\n+\n+    public CacheBeProxy.FetchCacheResult getCacheData() {\n+        CacheProxy.FetchCacheResult cacheResult = null;\n+        cacheMode = innerCheckCacheMode(0);\n+        if (cacheMode == CacheMode.NoNeed) {\n+            return cacheResult;\n+        }\n+        if (cacheMode == CacheMode.None) {\n+            LOG.info(\"check cache mode {}, queryid {}\", cacheMode, DebugUtil.printId(queryId));\n+            return cacheResult;\n+        }\n+        Status status = new Status();\n+        cacheResult = cache.getCacheData(status);\n+\n+        if (status.ok() && cacheResult != null) {\n+            LOG.info(\"hit cache, mode {}, queryid {}, all count {}, value count {}, row count {}, data size {}\",\n+                    cacheMode, DebugUtil.printId(queryId),\n+                    cacheResult.all_count, cacheResult.value_count,\n+                    cacheResult.row_count, cacheResult.data_size);\n+        } else {\n+            LOG.info(\"miss cache, mode {}, queryid {}, code {}, msg {}\", cacheMode,\n+                    DebugUtil.printId(queryId), status.getErrorCode(), status.getErrorMsg());\n+            cacheResult = null;\n+        }\n+        return cacheResult;\n+    }\n+\n+    public long nowtime() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    private void getPartitionKeyFromSelectStmt(SelectStmt stmt, Column partColumn,\n+                                               List<CompoundPredicate> compoundPredicates) {\n+        getPartitionKeyFromWhereClause(stmt.getWhereClause(), partColumn, compoundPredicates);\n+        List<TableRef> tableRefs = stmt.getTableRefs();\n+        for (TableRef tblRef : tableRefs) {\n+            if (tblRef instanceof InlineViewRef) {\n+                InlineViewRef viewRef = (InlineViewRef) tblRef;\n+                QueryStmt queryStmt = viewRef.getViewStmt();\n+                if (queryStmt instanceof SelectStmt) {\n+                    getPartitionKeyFromSelectStmt((SelectStmt) queryStmt, partColumn, compoundPredicates);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Only support case 1\n+     * 1.key >= a and key <= b\n+     * 2.key = a or key = b", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMjQxNA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r472922414", "bodyText": "Other cases are more complicated, I think the first version is simpler", "author": "marising", "createdAt": "2020-08-19T10:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NzExMQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r468657111", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public long latestId;\n          \n          \n            \n                    public long latestPartitionId;", "author": "kangkaisen", "createdAt": "2020-08-11T15:11:30Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheAnalyzer.java", "diffHunk": "@@ -0,0 +1,450 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.AggregateInfo;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.CastExpr;\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.InlineViewRef;\n+import org.apache.doris.analysis.QueryStmt;\n+import org.apache.doris.analysis.SelectStmt;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.analysis.StatementBase;\n+import org.apache.doris.analysis.TableRef;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.metric.MetricRepo;\n+import org.apache.doris.planner.OlapScanNode;\n+import org.apache.doris.planner.Planner;\n+import org.apache.doris.planner.ScanNode;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Status;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.thrift.TUniqueId;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Analyze which caching mode a SQL is suitable for\n+ * 1. T + 1 update is suitable for SQL mode\n+ * 2. Partition by date, update the data of the day in near real time, which is suitable for Partition mode\n+ */\n+public class CacheAnalyzer {\n+    private static final Logger LOG = LogManager.getLogger(CacheAnalyzer.class);\n+\n+    /**\n+     * NoNeed : disable config or variable, not query, not scan table etc.\n+     */\n+    public enum CacheMode {\n+        NoNeed,\n+        None,\n+        TTL,\n+        Sql,\n+        Partition\n+    }\n+\n+    private ConnectContext context;\n+    private boolean enableSqlCache = false;\n+    private boolean enablePartitionCache = false;\n+    private TUniqueId queryId;\n+    private CacheMode cacheMode;\n+    private CacheTable latestTable;\n+    private StatementBase parsedStmt;\n+    private SelectStmt selectStmt;\n+    private List<ScanNode> scanNodes;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo partitionInfo;\n+    private Column partColumn;\n+    private CompoundPredicate partitionPredicate;\n+    private Cache cache;\n+\n+    public Cache getCache() {\n+        return cache;\n+    }\n+\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, Planner planner) {\n+        this.context = context;\n+        this.queryId = context.queryId();\n+        this.parsedStmt = parsedStmt;\n+        scanNodes = planner.getScanNodes();\n+        latestTable = new CacheTable();\n+        checkCacheConfig();\n+    }\n+\n+    //for unit test\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, List<ScanNode> scanNodes) {\n+        this.context = context;\n+        this.parsedStmt = parsedStmt;\n+        this.scanNodes = scanNodes;\n+        checkCacheConfig();\n+    }\n+\n+    private void checkCacheConfig() {\n+        if (Config.cache_enable_sql_mode) {\n+            if (context.getSessionVariable().isEnableSqlCache()) {\n+                enableSqlCache = true;\n+            }\n+        }\n+        if (Config.cache_enable_partition_mode) {\n+            if (context.getSessionVariable().isEnablePartitionCache()) {\n+                enablePartitionCache = true;\n+            }\n+        }\n+    }\n+\n+    public CacheMode getCacheMode() {\n+        return cacheMode;\n+    }\n+\n+    public class CacheTable implements Comparable<CacheTable> {\n+        public OlapTable olapTable;\n+        public long latestId;", "originalCommit": "b6b24bcd98ac993a9026166d4cb9bb0aeebde2c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcyMDE0OA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r474720148", "bodyText": "Please comment rewrite what format Expr to what another format Expr.", "author": "kangkaisen", "createdAt": "2020-08-21T14:06:42Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/PartitionCache.java", "diffHunk": "@@ -0,0 +1,215 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.InlineViewRef;\n+import org.apache.doris.analysis.QueryStmt;\n+import org.apache.doris.analysis.SelectStmt;\n+import org.apache.doris.analysis.TableRef;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.metric.MetricRepo;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.thrift.TUniqueId;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+\n+public class PartitionCache extends Cache {\n+    private static final Logger LOG = LogManager.getLogger(PartitionCache.class);\n+    private SelectStmt nokeyStmt;\n+    private SelectStmt rewriteStmt;\n+    private CompoundPredicate partitionPredicate;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo partitionInfo;\n+    private Column partColumn;\n+\n+    private PartitionRange range;\n+    private List<PartitionRange.PartitionSingle> newRangeList;\n+\n+    public SelectStmt getRewriteStmt() {\n+        return rewriteStmt;\n+    }\n+\n+    public SelectStmt getNokeyStmt() {\n+        return nokeyStmt;\n+    }\n+\n+    public PartitionCache(TUniqueId queryId, SelectStmt selectStmt) {\n+        super(queryId, selectStmt);\n+    }\n+\n+    public void setCacheInfo(CacheAnalyzer.CacheTable latestTable, RangePartitionInfo partitionInfo, Column partColumn,\n+                             CompoundPredicate partitionPredicate) {\n+        this.latestTable = latestTable;\n+        this.olapTable = latestTable.olapTable;\n+        this.partitionInfo = partitionInfo;\n+        this.partColumn = partColumn;\n+        this.partitionPredicate = partitionPredicate;\n+        this.newRangeList = Lists.newArrayList();\n+    }\n+\n+    public CacheProxy.FetchCacheResult getCacheData(Status status) {\n+        CacheProxy.FetchCacheRequest request;\n+        rewriteSelectStmt(null);\n+        request = new CacheBeProxy.FetchCacheRequest(nokeyStmt.toSql());\n+        range = new PartitionRange(this.partitionPredicate, this.olapTable,\n+                this.partitionInfo);\n+        if (!range.analytics()) {\n+            status.setStatus(\"analytics range error\");\n+            return null;\n+        }\n+\n+        for (PartitionRange.PartitionSingle single : range.getPartitionSingleList()) {\n+            request.addParam(single.getCacheKey().realValue(),\n+                    single.getPartition().getVisibleVersion(),\n+                    single.getPartition().getVisibleVersionTime()\n+            );\n+        }\n+\n+        CacheProxy.FetchCacheResult cacheResult = proxy.fetchCache(request, 10000, status);\n+        if (status.ok() && cacheResult != null) {\n+            cacheResult.all_count = range.getPartitionSingleList().size();\n+            for (CacheBeProxy.CacheValue value : cacheResult.getValueList()) {\n+                range.setCacheFlag(value.param.partition_key);\n+            }\n+            MetricRepo.COUNTER_CACHE_HIT_PARTITION.increase(1L);\n+            MetricRepo.COUNTER_CACHE_PARTITION_ALL.increase((long) range.getPartitionSingleList().size());\n+            MetricRepo.COUNTER_CACHE_PARTITION_HIT.increase((long) cacheResult.getValueList().size());\n+        }\n+\n+        range.setTooNewByID(latestTable.latestPartitionId);\n+        //build rewrite sql\n+        this.hitRange = range.buildDiskPartitionRange(newRangeList);\n+        if (newRangeList != null && newRangeList.size() > 0) {\n+            rewriteSelectStmt(newRangeList);\n+        }\n+        return cacheResult;\n+    }\n+\n+    public void copyRowBatch(RowBatch rowBatch) {\n+        if (rowBatchBuilder == null) {\n+            rowBatchBuilder = new RowBatchBuilder(CacheAnalyzer.CacheMode.Partition);\n+            rowBatchBuilder.buildPartitionIndex(selectStmt.getResultExprs(), selectStmt.getColLabels(),\n+                    partColumn, range.buildUpdatePartitionRange());\n+        }\n+        rowBatchBuilder.copyRowData(rowBatch);\n+    }\n+\n+    public void updateCache() {\n+        if (!super.checkRowLimit()) {\n+            return;\n+        }\n+\n+        CacheBeProxy.UpdateCacheRequest updateRequest = rowBatchBuilder.buildPartitionUpdateRequest(nokeyStmt.toSql());\n+        if (updateRequest.value_count > 0) {\n+            CacheBeProxy proxy = new CacheBeProxy();\n+            Status status = new Status();\n+            proxy.updateCache(updateRequest, CacheProxy.UPDATE_TIMEOUT, status);\n+            LOG.info(\"update cache model {}, queryid {}, sqlkey {}, value count {}, row count {}, data size {}\",\n+                    CacheAnalyzer.CacheMode.Partition, DebugUtil.printId(queryId),\n+                    DebugUtil.printId(updateRequest.sql_key),\n+                    updateRequest.value_count, updateRequest.row_count, updateRequest.data_size);\n+        }\n+    }\n+\n+    /**\n+     * Set the predicate containing partition key to null\n+     */\n+    public void rewriteSelectStmt(List<PartitionRange.PartitionSingle> newRangeList) {\n+        if (newRangeList == null || newRangeList.size() == 0) {\n+            this.nokeyStmt = (SelectStmt) this.selectStmt.clone();\n+            rewriteSelectStmt(nokeyStmt, this.partitionPredicate, null);\n+        } else {\n+            this.rewriteStmt = (SelectStmt) this.selectStmt.clone();\n+            rewriteSelectStmt(rewriteStmt, this.partitionPredicate, newRangeList);\n+        }\n+    }\n+\n+    private void rewriteSelectStmt(SelectStmt newStmt, CompoundPredicate predicate,\n+                                   List<PartitionRange.PartitionSingle> newRangeList) {\n+        newStmt.setWhereClause(\n+                rewriteWhereClause(newStmt.getWhereClause(), predicate, newRangeList)\n+        );\n+        List<TableRef> tableRefs = newStmt.getTableRefs();\n+        for (TableRef tblRef : tableRefs) {\n+            if (tblRef instanceof InlineViewRef) {\n+                InlineViewRef viewRef = (InlineViewRef) tblRef;\n+                QueryStmt queryStmt = viewRef.getViewStmt();\n+                if (queryStmt instanceof SelectStmt) {\n+                    rewriteSelectStmt((SelectStmt) queryStmt, predicate, newRangeList);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * P1 And P2 And P3 And P4", "originalCommit": "31c7654ea75877847b6f449b47b9d387922c722e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcyMDY2NA==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r474720664", "bodyText": "Too many log info. please change some log to debug level.", "author": "kangkaisen", "createdAt": "2020-08-21T14:07:37Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/CacheAnalyzer.java", "diffHunk": "@@ -0,0 +1,451 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import org.apache.doris.analysis.AggregateInfo;\n+import org.apache.doris.analysis.BinaryPredicate;\n+import org.apache.doris.analysis.CastExpr;\n+import org.apache.doris.analysis.CompoundPredicate;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.analysis.InlineViewRef;\n+import org.apache.doris.analysis.QueryStmt;\n+import org.apache.doris.analysis.SelectStmt;\n+import org.apache.doris.analysis.SlotRef;\n+import org.apache.doris.analysis.StatementBase;\n+import org.apache.doris.analysis.TableRef;\n+import org.apache.doris.catalog.OlapTable;\n+import org.apache.doris.catalog.RangePartitionInfo;\n+import org.apache.doris.catalog.PartitionType;\n+import org.apache.doris.catalog.Partition;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.common.util.DebugUtil;\n+import org.apache.doris.metric.MetricRepo;\n+import org.apache.doris.planner.OlapScanNode;\n+import org.apache.doris.planner.Planner;\n+import org.apache.doris.planner.ScanNode;\n+import org.apache.doris.qe.ConnectContext;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Status;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.thrift.TUniqueId;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Analyze which caching mode a SQL is suitable for\n+ * 1. T + 1 update is suitable for SQL mode\n+ * 2. Partition by date, update the data of the day in near real time, which is suitable for Partition mode\n+ */\n+public class CacheAnalyzer {\n+    private static final Logger LOG = LogManager.getLogger(CacheAnalyzer.class);\n+\n+    /**\n+     * NoNeed : disable config or variable, not query, not scan table etc.\n+     */\n+    public enum CacheMode {\n+        NoNeed,\n+        None,\n+        TTL,\n+        Sql,\n+        Partition\n+    }\n+\n+    private ConnectContext context;\n+    private boolean enableSqlCache = false;\n+    private boolean enablePartitionCache = false;\n+    private TUniqueId queryId;\n+    private CacheMode cacheMode;\n+    private CacheTable latestTable;\n+    private StatementBase parsedStmt;\n+    private SelectStmt selectStmt;\n+    private List<ScanNode> scanNodes;\n+    private OlapTable olapTable;\n+    private RangePartitionInfo partitionInfo;\n+    private Column partColumn;\n+    private CompoundPredicate partitionPredicate;\n+    private Cache cache;\n+\n+    public Cache getCache() {\n+        return cache;\n+    }\n+\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, Planner planner) {\n+        this.context = context;\n+        this.queryId = context.queryId();\n+        this.parsedStmt = parsedStmt;\n+        scanNodes = planner.getScanNodes();\n+        latestTable = new CacheTable();\n+        checkCacheConfig();\n+    }\n+\n+    //for unit test\n+    public CacheAnalyzer(ConnectContext context, StatementBase parsedStmt, List<ScanNode> scanNodes) {\n+        this.context = context;\n+        this.parsedStmt = parsedStmt;\n+        this.scanNodes = scanNodes;\n+        checkCacheConfig();\n+    }\n+\n+    private void checkCacheConfig() {\n+        if (Config.cache_enable_sql_mode) {\n+            if (context.getSessionVariable().isEnableSqlCache()) {\n+                enableSqlCache = true;\n+            }\n+        }\n+        if (Config.cache_enable_partition_mode) {\n+            if (context.getSessionVariable().isEnablePartitionCache()) {\n+                enablePartitionCache = true;\n+            }\n+        }\n+    }\n+\n+    public CacheMode getCacheMode() {\n+        return cacheMode;\n+    }\n+\n+    public class CacheTable implements Comparable<CacheTable> {\n+        public OlapTable olapTable;\n+        public long latestPartitionId;\n+        public long latestVersion;\n+        public long latestTime;\n+\n+        public CacheTable() {\n+            olapTable = null;\n+            latestPartitionId = 0;\n+            latestVersion = 0;\n+            latestTime = 0;\n+        }\n+\n+        @Override\n+        public int compareTo(CacheTable table) {\n+            return (int) (table.latestTime - this.latestTime);\n+        }\n+\n+        public void Debug() {\n+            LOG.info(\"table {}, partition id {}, ver {}, time {}\", olapTable.getName(), latestPartitionId, latestVersion, latestTime);\n+        }\n+    }\n+\n+    public boolean enableCache() {\n+        return enableSqlCache || enablePartitionCache;\n+    }\n+\n+    public boolean enableSqlCache() {\n+        return enableSqlCache;\n+    }\n+\n+    public boolean enablePartitionCache() {\n+        return enablePartitionCache;\n+    }\n+\n+    /**\n+     * Check cache mode with SQL and table\n+     * 1\u3001Only Olap table\n+     * 2\u3001The update time of the table is before Config.last_version_interval_time\n+     * 2\u3001PartitionType is PartitionType.RANGE, and partition key has only one column\n+     * 4\u3001Partition key must be included in the group by clause\n+     * 5\u3001Where clause must contain only one partition key predicate\n+     * CacheMode.Sql\n+     * xxx FROM user_profile, updated before Config.last_version_interval_time\n+     * CacheMode.Partition, partition by event_date, only the partition of today will be updated.\n+     * SELECT xxx FROM app_event WHERE event_date >= 20191201 AND event_date <= 20191207 GROUP BY event_date\n+     * SELECT xxx FROM app_event INNER JOIN user_Profile ON app_event.user_id = user_profile.user_id xxx\n+     * SELECT xxx FROM app_event INNER JOIN user_profile ON xxx INNER JOIN site_channel ON xxx\n+     */\n+    public void checkCacheMode(long now) {\n+        cacheMode = innerCheckCacheMode(now);\n+    }\n+\n+    private CacheMode innerCheckCacheMode(long now) {\n+        if (!enableCache()) {\n+            return CacheMode.NoNeed;\n+        }\n+        if (!(parsedStmt instanceof SelectStmt) || scanNodes.size() == 0) {\n+            return CacheMode.NoNeed;\n+        }\n+        MetricRepo.COUNTER_QUERY_TABLE.increase(1L);\n+\n+        this.selectStmt = (SelectStmt) parsedStmt;\n+        //Check the last version time of the table\n+        List<CacheTable> tblTimeList = Lists.newArrayList();\n+        for (int i = 0; i < scanNodes.size(); i++) {\n+            ScanNode node = scanNodes.get(i);\n+            if (!(node instanceof OlapScanNode)) {\n+                return CacheMode.None;\n+            }\n+            OlapScanNode oNode = (OlapScanNode) node;\n+            OlapTable oTable = oNode.getOlapTable();\n+            CacheTable cTable = getLastUpdateTime(oTable);\n+            tblTimeList.add(cTable);\n+        }\n+        MetricRepo.COUNTER_QUERY_OLAP_TABLE.increase(1L);\n+        Collections.sort(tblTimeList);\n+        latestTable = tblTimeList.get(0);\n+        latestTable.Debug();\n+\n+        if (now == 0) {\n+            now = nowtime();\n+        }\n+        if (enableSqlCache() &&\n+                (now - latestTable.latestTime) >= Config.cache_last_version_interval_second * 1000) {\n+            LOG.info(\"TIME:{},{},{}\", now, latestTable.latestTime, Config.cache_last_version_interval_second*1000);\n+            cache = new SqlCache(this.queryId, this.selectStmt);\n+            ((SqlCache) cache).setCacheInfo(this.latestTable);\n+            MetricRepo.COUNTER_CACHE_MODE_SQL.increase(1L);\n+            return CacheMode.Sql;\n+        }\n+\n+        if (!enablePartitionCache()) {\n+            return CacheMode.None;\n+        }\n+\n+        //Check if selectStmt matches partition key\n+        //Only one table can be updated in Config.cache_last_version_interval_second range\n+        for (int i = 1; i < tblTimeList.size(); i++) {\n+            if ((now - tblTimeList.get(i).latestTime) < Config.cache_last_version_interval_second * 1000) {\n+                LOG.info(\"the time of other tables is newer than {}\", Config.cache_last_version_interval_second);\n+                return CacheMode.None;\n+            }\n+        }\n+        olapTable = latestTable.olapTable;\n+        if (olapTable.getPartitionInfo().getType() != PartitionType.RANGE) {\n+            LOG.info(\"the partition of OlapTable not RANGE type\");", "originalCommit": "31c7654ea75877847b6f449b47b9d387922c722e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcyMzk3MQ==", "url": "https://github.com/apache/incubator-doris/pull/4330#discussion_r474723971", "bodyText": "Add a comment for this class.", "author": "kangkaisen", "createdAt": "2020-08-21T14:12:12Z", "path": "fe/fe-core/src/main/java/org/apache/doris/qe/cache/RowBatchBuilder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.qe.cache;\n+\n+import com.google.common.collect.Lists;\n+import org.apache.doris.analysis.Expr;\n+import org.apache.doris.catalog.Column;\n+import org.apache.doris.catalog.Type;\n+import org.apache.doris.qe.RowBatch;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+public class RowBatchBuilder {", "originalCommit": "31c7654ea75877847b6f449b47b9d387922c722e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "54ad31a03feb7208e9ab447c9be00904c5b44810", "url": "https://github.com/apache/incubator-doris/commit/54ad31a03feb7208e9ab447c9be00904c5b44810", "message": "[Feature][Cache] Sql cache and partition cache #2581\n1. Analyze what mode of cache can be used by query\n2. Query cache before executing query in StmtExecutor\n3. Two cache mode, sqlcache and partitioncache, are implemented", "committedDate": "2020-09-02T10:24:19Z", "type": "commit"}, {"oid": "54ad31a03feb7208e9ab447c9be00904c5b44810", "url": "https://github.com/apache/incubator-doris/commit/54ad31a03feb7208e9ab447c9be00904c5b44810", "message": "[Feature][Cache] Sql cache and partition cache #2581\n1. Analyze what mode of cache can be used by query\n2. Query cache before executing query in StmtExecutor\n3. Two cache mode, sqlcache and partitioncache, are implemented", "committedDate": "2020-09-02T10:24:19Z", "type": "forcePushed"}]}