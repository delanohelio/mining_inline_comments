{"pr_number": 2725, "pr_title": "Add timestampadd/timestampdiff function", "pr_createdAt": "2020-01-10T03:51:57Z", "pr_url": "https://github.com/apache/incubator-doris/pull/2725", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDUyNw==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365064527", "bodyText": "remove this comment?", "author": "kangkaisen", "createdAt": "2020-01-10T04:00:00Z", "path": "fe/src/main/java/org/apache/doris/analysis/TimestampArithmeticExpr.java", "diffHunk": "@@ -120,65 +120,142 @@ private Type fixType() {\n     @Override\n     public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n         // Check if name of function call is date_sub or date_add.\n+        String funcOpName;\n         if (funcName != null) {\n-            if (funcName.toUpperCase().equals(\"DATE_ADD\")\n-                    || funcName.toUpperCase().equals(\"DAYS_ADD\")\n-                    || funcName.toUpperCase().equals(\"ADDDATE\")) {\n-                op = ArithmeticExpr.Operator.ADD;\n-            } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n-                    || funcName.toUpperCase().equals(\"DAYS_SUB\")\n-                    || funcName.toUpperCase().equals(\"SUBDATE\")) {\n-                op = ArithmeticExpr.Operator.SUBTRACT;\n+            if (funcName.equalsIgnoreCase(\"TIMESTAMPDIFF\")) {\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                // The first child must return a timestamp or null.\n+                if (!getChild(1).getType().isDateType() && !getChild(1).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 1);\n+                }\n+\n+                type = Type.BIGINT;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit, \"DIFF\");\n             } else {\n-                throw new AnalysisException(\"Encountered function name '\" + funcName\n-                        + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n-                        + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE'\"\n-                        + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                if (funcName.toUpperCase().equals(\"DATE_ADD\")\n+                        || funcName.toUpperCase().equals(\"DAYS_ADD\")\n+                        || funcName.toUpperCase().equals(\"ADDDATE\")\n+                        || funcName.toUpperCase().equals(\"TIMESTAMPADD\")) {\n+                    op = ArithmeticExpr.Operator.ADD;\n+                } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n+                        || funcName.toUpperCase().equals(\"DAYS_SUB\")\n+                        || funcName.toUpperCase().equals(\"SUBDATE\")) {\n+                    op = ArithmeticExpr.Operator.SUBTRACT;\n+                } else {\n+                    throw new AnalysisException(\"Encountered function name '\" + funcName\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n+                            + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE/TIMESTAMPADD'\"\n+                            + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                }\n+\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                if (!getChild(1).getType().isScalarType()) {\n+                    throw new AnalysisException(\"must be a scalar type.\");\n+                }\n+\n+                // The second child must be of type 'INT' or castable to it.\n+                if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n+                    if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+                    }\n+                    castChild(Type.INT, 1);\n+                }\n+\n+                type = dateType;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit,\n+                        (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n+                // For the month interval, use the invisible special-case implementation.", "originalCommit": "f5bd079a53cf6b6e0a38375fd58e95283ec90321", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NTMyMg==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365065322", "bodyText": "Done", "author": "HangyuanLiu", "createdAt": "2020-01-10T04:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDc0MQ==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365064741", "bodyText": "fn is {} name is {} thie log should be remove or change to debug level.  There will be a lot of this log from doris 0.11", "author": "kangkaisen", "createdAt": "2020-01-10T04:01:12Z", "path": "fe/src/main/java/org/apache/doris/analysis/TimestampArithmeticExpr.java", "diffHunk": "@@ -120,65 +120,142 @@ private Type fixType() {\n     @Override\n     public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n         // Check if name of function call is date_sub or date_add.\n+        String funcOpName;\n         if (funcName != null) {\n-            if (funcName.toUpperCase().equals(\"DATE_ADD\")\n-                    || funcName.toUpperCase().equals(\"DAYS_ADD\")\n-                    || funcName.toUpperCase().equals(\"ADDDATE\")) {\n-                op = ArithmeticExpr.Operator.ADD;\n-            } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n-                    || funcName.toUpperCase().equals(\"DAYS_SUB\")\n-                    || funcName.toUpperCase().equals(\"SUBDATE\")) {\n-                op = ArithmeticExpr.Operator.SUBTRACT;\n+            if (funcName.equalsIgnoreCase(\"TIMESTAMPDIFF\")) {\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                // The first child must return a timestamp or null.\n+                if (!getChild(1).getType().isDateType() && !getChild(1).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 1);\n+                }\n+\n+                type = Type.BIGINT;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit, \"DIFF\");\n             } else {\n-                throw new AnalysisException(\"Encountered function name '\" + funcName\n-                        + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n-                        + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE'\"\n-                        + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                if (funcName.toUpperCase().equals(\"DATE_ADD\")\n+                        || funcName.toUpperCase().equals(\"DAYS_ADD\")\n+                        || funcName.toUpperCase().equals(\"ADDDATE\")\n+                        || funcName.toUpperCase().equals(\"TIMESTAMPADD\")) {\n+                    op = ArithmeticExpr.Operator.ADD;\n+                } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n+                        || funcName.toUpperCase().equals(\"DAYS_SUB\")\n+                        || funcName.toUpperCase().equals(\"SUBDATE\")) {\n+                    op = ArithmeticExpr.Operator.SUBTRACT;\n+                } else {\n+                    throw new AnalysisException(\"Encountered function name '\" + funcName\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'. \"\n+                            + \"Expected function name 'DATE_ADD/DAYS_ADD/ADDDATE/TIMESTAMPADD'\"\n+                            + \"or 'DATE_SUB/DAYS_SUB/SUBDATE\");\n+                }\n+\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }\n+\n+                if (!getChild(1).getType().isScalarType()) {\n+                    throw new AnalysisException(\"must be a scalar type.\");\n+                }\n+\n+                // The second child must be of type 'INT' or castable to it.\n+                if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n+                    if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+                    }\n+                    castChild(Type.INT, 1);\n+                }\n+\n+                type = dateType;\n+                opcode = getOpCode();\n+                funcOpName = String.format(\"%sS_%s\", timeUnit,\n+                        (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n+                // For the month interval, use the invisible special-case implementation.\n+                // \"ADD_MONTHS(t, m)\" by definition is different from \"t + INTERVAL m MONTHS\".\n+                // if (timeUnit == TimeUnit.MONTH) {\n+                //     funcOpName += \"_INTERVAL\";\n+                // }\n+            }\n+        } else {\n+            timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+            if (timeUnit == null) {\n+                throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                        + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n             }\n-        }\n-        timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n-        if (timeUnit == null) {\n-            throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n-                    + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n-        }\n \n-        Type dateType = fixType();\n-        if (dateType.isDate() && timeUnit.isDateTime()) {\n-            dateType = Type.DATETIME;\n-        }\n-        // The first child must return a timestamp or null.\n-        if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n-            if (!dateType.isValid()) {\n-                throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n-                        + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n-                        + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+            Type dateType = fixType();\n+            if (dateType.isDate() && timeUnit.isDateTime()) {\n+                dateType = Type.DATETIME;\n+            }\n+            // The first child must return a timestamp or null.\n+            if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                if (!dateType.isValid()) {\n+                    throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                            + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                            + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                }\n+                castChild(dateType, 0);\n             }\n-            castChild(dateType, 0);\n-        }\n \n-        if (!getChild(1).getType().isScalarType()) {\n-            throw new AnalysisException(\"must be a scalar type.\");\n-        }\n+            if (!getChild(1).getType().isScalarType()) {\n+                throw new AnalysisException(\"must be a scalar type.\");\n+            }\n \n-        // The second child must be of type 'INT' or castable to it.\n-        if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n-            if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n-                throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n-                        + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n-                        + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+            // The second child must be of type 'INT' or castable to it.\n+            if (!getChild(1).getType().isScalarType(PrimitiveType.INT)) {\n+                if (!ScalarType.canCastTo((ScalarType) getChild(1).getType(), Type.INT)) {\n+                    throw new AnalysisException(\"Operand '\" + getChild(1).toSql()\n+                            + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                            + getChild(1).getType() + \"' which is incompatible with expected type 'INT'.\");\n+                }\n+                castChild(Type.INT, 1);\n             }\n-            castChild(Type.INT, 1);\n-        }\n \n-        type = dateType;\n-        opcode = getOpCode();\n-        String funcOpName = String.format(\"%sS_%s\",  timeUnit,\n-                (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n-        // For the month interval, use the invisible special-case implementation.\n-        // \"ADD_MONTHS(t, m)\" by definition is different from \"t + INTERVAL m MONTHS\".\n-        // if (timeUnit == TimeUnit.MONTH) {\n-        //     funcOpName += \"_INTERVAL\";\n-        // }\n+            type = dateType;\n+            opcode = getOpCode();\n+            funcOpName = String.format(\"%sS_%s\", timeUnit,\n+                    (op == ArithmeticExpr.Operator.ADD) ? \"ADD\" : \"SUB\");\n+        }\n \n         fn = getBuiltinFunction(analyzer, funcOpName.toLowerCase(),\n                 collectChildReturnTypes(), Function.CompareMode.IS_NONSTRICT_SUPERTYPE_OF);", "originalCommit": "f5bd079a53cf6b6e0a38375fd58e95283ec90321", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NTM1MA==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365065350", "bodyText": "OK", "author": "HangyuanLiu", "createdAt": "2020-01-10T04:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2NDc0MQ=="}], "type": "inlineReview"}, {"oid": "c02ed755e82978733568dc583f9d880ddbbbfd6e", "url": "https://github.com/apache/incubator-doris/commit/c02ed755e82978733568dc583f9d880ddbbbfd6e", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T04:03:49Z", "type": "commit"}, {"oid": "c02ed755e82978733568dc583f9d880ddbbbfd6e", "url": "https://github.com/apache/incubator-doris/commit/c02ed755e82978733568dc583f9d880ddbbbfd6e", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T04:03:49Z", "type": "forcePushed"}, {"oid": "d2ea231dafa23da6aecc51973eea53c3fdfa625c", "url": "https://github.com/apache/incubator-doris/commit/d2ea231dafa23da6aecc51973eea53c3fdfa625c", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T08:10:16Z", "type": "commit"}, {"oid": "d2ea231dafa23da6aecc51973eea53c3fdfa625c", "url": "https://github.com/apache/incubator-doris/commit/d2ea231dafa23da6aecc51973eea53c3fdfa625c", "message": "add timestampadd/timestampdiff function", "committedDate": "2020-01-10T08:10:16Z", "type": "forcePushed"}, {"oid": "68dc4e40193855ec6203d9588fc49dcc9ed1ca16", "url": "https://github.com/apache/incubator-doris/commit/68dc4e40193855ec6203d9588fc49dcc9ed1ca16", "message": "add doc", "committedDate": "2020-01-10T08:10:48Z", "type": "commit"}, {"oid": "f22d576b34594911b5ac7d561c493df77c05b3ec", "url": "https://github.com/apache/incubator-doris/commit/f22d576b34594911b5ac7d561c493df77c05b3ec", "message": "Merge remote-tracking branch 'origin/timestampdiff' into timestampdiff\n\n# Conflicts:\n#\tbe/src/exprs/timestamp_functions.cpp\n#\tbe/test/exprs/timestamp_functions_test.cpp", "committedDate": "2020-01-10T08:11:04Z", "type": "commit"}, {"oid": "afeaba2202af796189bedb6ddbabbbeb51de1094", "url": "https://github.com/apache/incubator-doris/commit/afeaba2202af796189bedb6ddbabbbeb51de1094", "message": "fix format", "committedDate": "2020-01-13T07:12:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwNzg1NA==", "url": "https://github.com/apache/incubator-doris/pull/2725#discussion_r365807854", "bodyText": "seems that these codes are the same with others.\nCould you try to reduce these same code?", "author": "imay", "createdAt": "2020-01-13T13:39:35Z", "path": "fe/src/main/java/org/apache/doris/analysis/TimestampArithmeticExpr.java", "diffHunk": "@@ -120,69 +120,141 @@ private Type fixType() {\n     @Override\n     public void analyzeImpl(Analyzer analyzer) throws AnalysisException {\n         // Check if name of function call is date_sub or date_add.\n+        String funcOpName;\n         if (funcName != null) {\n-            if (funcName.toUpperCase().equals(\"DATE_ADD\")\n-                    || funcName.toUpperCase().equals(\"DAYS_ADD\")\n-                    || funcName.toUpperCase().equals(\"ADDDATE\")) {\n-                op = ArithmeticExpr.Operator.ADD;\n-            } else if (funcName.toUpperCase().equals(\"DATE_SUB\")\n-                    || funcName.toUpperCase().equals(\"DAYS_SUB\")\n-                    || funcName.toUpperCase().equals(\"SUBDATE\")) {\n-                op = ArithmeticExpr.Operator.SUBTRACT;\n+            if (funcName.equalsIgnoreCase(\"TIMESTAMPDIFF\")) {\n+                timeUnit = TIME_UNITS_MAP.get(timeUnitIdent.toUpperCase());\n+                if (timeUnit == null) {\n+                    throw new AnalysisException(\"Invalid time unit '\" + timeUnitIdent\n+                            + \"' in timestamp arithmetic expression '\" + toSql() + \"'.\");\n+                }\n+                Type dateType = fixType();\n+                if (dateType.isDate() && timeUnit.isDateTime()) {\n+                    dateType = Type.DATETIME;\n+                }\n+                // The first child must return a timestamp or null.\n+                if (!getChild(0).getType().isDateType() && !getChild(0).getType().isNull()) {\n+                    if (!dateType.isValid()) {\n+                        throw new AnalysisException(\"Operand '\" + getChild(0).toSql()\n+                                + \"' of timestamp arithmetic expression '\" + toSql() + \"' returns type '\"\n+                                + getChild(0).getType() + \"'. Expected type 'TIMESTAMP/DATE/DATETIME'.\");\n+                    }\n+                    castChild(dateType, 0);\n+                }", "originalCommit": "afeaba2202af796189bedb6ddbabbbeb51de1094", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b478b4dba14f6874060b3bd57a27cf3f9da0859", "url": "https://github.com/apache/incubator-doris/commit/8b478b4dba14f6874060b3bd57a27cf3f9da0859", "message": "fix format", "committedDate": "2020-01-14T04:07:15Z", "type": "commit"}, {"oid": "8b478b4dba14f6874060b3bd57a27cf3f9da0859", "url": "https://github.com/apache/incubator-doris/commit/8b478b4dba14f6874060b3bd57a27cf3f9da0859", "message": "fix format", "committedDate": "2020-01-14T04:07:15Z", "type": "forcePushed"}]}