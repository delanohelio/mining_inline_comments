{"pr_number": 2847, "pr_title": "Doris support in memory olap table", "pr_createdAt": "2020-02-06T07:26:42Z", "pr_url": "https://github.com/apache/incubator-doris/pull/2847", "timeline": [{"oid": "773e0e34a57ed1c4edccc45735dc5fe80ba4d97f", "url": "https://github.com/apache/incubator-doris/commit/773e0e34a57ed1c4edccc45735dc5fe80ba4d97f", "message": "Fix UT", "committedDate": "2020-02-06T10:57:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NTAxMg==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r376175012", "bodyText": "Could we put this isInMemory in tableProperty to avoid modifying meta version?", "author": "morningman", "createdAt": "2020-02-07T01:37:52Z", "path": "fe/src/main/java/org/apache/doris/catalog/OlapTable.java", "diffHunk": "@@ -1011,17 +1010,17 @@ public void readFields(DataInput in) throws IOException {\n                 tableProperty = TableProperty.read(in);\n             }\n         }\n+        // inMemory\n+        if (Catalog.getCurrentCatalogJournalVersion() >= FeMetaVersion.VERSION_72) {\n+            isInMemory = in.readBoolean();", "originalCommit": "773e0e34a57ed1c4edccc45735dc5fe80ba4d97f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE4NzA0Ng==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r376187046", "bodyText": "OK.\nI didn't notice the TableProperty,  Thanks for your reminder.", "author": "kangkaisen", "createdAt": "2020-02-07T02:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3NTAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEwODU2Mw==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r377108563", "bodyText": "String errMsg; can be put in the following if clause", "author": "morningman", "createdAt": "2020-02-10T14:50:39Z", "path": "fe/src/main/java/org/apache/doris/alter/SchemaChangeHandler.java", "diffHunk": "@@ -1405,6 +1420,88 @@ private void sendClearAlterTask(Database db, OlapTable olapTable) {\n         LOG.info(\"send clear alter task for table {}, number: {}\", olapTable.getName(), batchTask.getTaskNum());\n     }\n \n+    public void sendUpdateTabletMetaInfoTask(Database db, OlapTable olapTable, boolean isInMemory) throws DdlException {\n+        List<Partition> partitions = Lists.newArrayList();\n+        db.readLock();\n+        try {\n+            partitions.addAll(olapTable.getPartitions());\n+        } finally {\n+            db.readUnlock();\n+        }\n+        for(Partition partition: partitions) {\n+            sendUpdateTabletMetaTaskForPartition(db, olapTable, partition, isInMemory);\n+        }\n+    }\n+\n+    public void sendUpdateTabletMetaTaskForPartition(Database db,\n+                                                     OlapTable olapTable,\n+                                                     Partition partition,\n+                                                     boolean isInMemory) throws DdlException {\n+        // be id -> <tablet id,schemaHash>\n+        Map<Long, Set<Pair<Long, Integer>>> beIdToTabletIdWithHash = Maps.newHashMap();\n+        db.readLock();\n+        try {\n+            for (MaterializedIndex index : partition.getMaterializedIndices(IndexExtState.VISIBLE)) {\n+                int schemaHash = olapTable.getSchemaHashByIndexId(index.getId());\n+                for (Tablet tablet : index.getTablets()) {\n+                    for (Replica replica : tablet.getReplicas()) {\n+                        Set<Pair<Long, Integer>> tabletIdWithHash = beIdToTabletIdWithHash.computeIfAbsent(replica.getBackendId(), k -> Sets.newHashSet());\n+                        tabletIdWithHash.add(new Pair<>(tablet.getId(), schemaHash));\n+                    }\n+                }\n+            }\n+        } finally {\n+            db.readUnlock();\n+        }\n+\n+        int totalTaskNum = beIdToTabletIdWithHash.keySet().size();\n+        MarkedCountDownLatch<Long, Set<Pair<Long, Integer>>> countDownLatch = new MarkedCountDownLatch<>(totalTaskNum);\n+        AgentBatchTask batchTask = new AgentBatchTask();\n+        for(Map.Entry<Long, Set<Pair<Long, Integer>>> kv: beIdToTabletIdWithHash.entrySet()) {\n+            countDownLatch.addMark(kv.getKey(), kv.getValue());\n+            UpdateTabletMetaInfoTask task = new UpdateTabletMetaInfoTask(kv.getKey(), kv.getValue(),\n+                                                isInMemory,countDownLatch);\n+            batchTask.addTask(task);\n+        }\n+        if (!FeConstants.runningUnitTest) {\n+            // send all tasks and wait them finished\n+            AgentTaskQueue.addBatchTask(batchTask);\n+            AgentTaskExecutor.submit(batchTask);\n+            LOG.info(\"send update tablet meta task for table {}, partitions {}, number: {}\",\n+                    olapTable.getName(), partition.getName(), batchTask.getTaskNum());\n+\n+            // estimate timeout\n+            long timeout = Config.tablet_create_timeout_second * 1000L * totalTaskNum;\n+            timeout = Math.min(timeout, Config.max_create_table_timeout_second * 1000);\n+            boolean ok = false;\n+            try {\n+                ok = countDownLatch.await(timeout, TimeUnit.MILLISECONDS);\n+            } catch (InterruptedException e) {\n+                LOG.warn(\"InterruptedException: \", e);\n+            }\n+\n+            String errMsg;", "originalCommit": "564e1cb6a7c600b197b1dbc57bfbdb168b1413a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQzOTU3NQ==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r377439575", "bodyText": "OK", "author": "kangkaisen", "createdAt": "2020-02-11T04:10:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEwODU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzExMTI2OQ==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r377111269", "bodyText": "sendUpdateTabletMetaTaskForPartition()\nwhat if this method is partial success? And some of the tablet's meta on BE changed to in memory and some are not?", "author": "morningman", "createdAt": "2020-02-10T14:54:55Z", "path": "fe/src/main/java/org/apache/doris/alter/SchemaChangeHandler.java", "diffHunk": "@@ -1405,6 +1420,88 @@ private void sendClearAlterTask(Database db, OlapTable olapTable) {\n         LOG.info(\"send clear alter task for table {}, number: {}\", olapTable.getName(), batchTask.getTaskNum());\n     }\n \n+    public void sendUpdateTabletMetaInfoTask(Database db, OlapTable olapTable, boolean isInMemory) throws DdlException {\n+        List<Partition> partitions = Lists.newArrayList();\n+        db.readLock();\n+        try {\n+            partitions.addAll(olapTable.getPartitions());\n+        } finally {\n+            db.readUnlock();\n+        }\n+        for(Partition partition: partitions) {\n+            sendUpdateTabletMetaTaskForPartition(db, olapTable, partition, isInMemory);\n+        }\n+    }\n+\n+    public void sendUpdateTabletMetaTaskForPartition(Database db,", "originalCommit": "564e1cb6a7c600b197b1dbc57bfbdb168b1413a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ0MDM0Mg==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r377440342", "bodyText": "If partial success, we will return error to user, and the error msg warn user to retry.\nBecause this operation is idempotent\uff0cSo retry is OK.\nIf we want to avoid partial success, we need to support tablet meta rollback operation. I think which is complex and unnecessary.", "author": "kangkaisen", "createdAt": "2020-02-11T04:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzExMTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ2NjU3Nw==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r377466577", "bodyText": "I am more worried that if the user does not retry, there will be an inconsistent state, that is, some tablet properties on BE are in memory, and FE is not in memory. There is no mechanism to find it in this case.\nWe need a correction mechanism to handle this. For example, when reporting to FE, compare with this attribute of FE.", "author": "morningman", "createdAt": "2020-02-11T06:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzExMTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzUxNDM0OQ==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r377514349", "bodyText": "OK.", "author": "kangkaisen", "createdAt": "2020-02-11T09:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzExMTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4Mzg0Nw==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r377983847", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static void handleSetTabletMetaInfo(long backendId, Set<Pair<Long, Integer>>tabletWithoutPartitionId) {\n          \n          \n            \n                private static void handleSetTabletMetaInfo(long backendId, Set<Pair<Long, Integer>> tabletWithoutPartitionId) {", "author": "kangpinghuang", "createdAt": "2020-02-12T00:43:19Z", "path": "fe/src/main/java/org/apache/doris/master/ReportHandler.java", "diffHunk": "@@ -884,13 +885,14 @@ private static void handleForceCreateReplica(List<CreateReplicaTask> createRepli\n     }\n     \n \n-    private static void handleSetTabletMetaInfo(long backendId, SetMultimap<Long, Integer> tabletWithoutPartitionId) {\n+    private static void handleSetTabletMetaInfo(long backendId, Set<Pair<Long, Integer>>tabletWithoutPartitionId) {", "originalCommit": "63fed51361332b4d3ec4576874ae3fcf13eba28b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxNzQ0Ng==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r378017446", "bodyText": "OK", "author": "kangkaisen", "createdAt": "2020-02-12T02:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4Mzg0Nw=="}], "type": "inlineReview"}, {"oid": "13ce036e71cd4670c192b6f74832c5288d380949", "url": "https://github.com/apache/incubator-doris/commit/13ce036e71cd4670c192b6f74832c5288d380949", "message": "Doris support in memory olap table", "committedDate": "2020-02-12T07:41:40Z", "type": "forcePushed"}, {"oid": "1fd2014747a61ce7f62159429a8a65a5cedf013b", "url": "https://github.com/apache/incubator-doris/commit/1fd2014747a61ce7f62159429a8a65a5cedf013b", "message": "Add disable_storage_page_cache config", "committedDate": "2020-02-16T09:59:18Z", "type": "forcePushed"}, {"oid": "13ce036e71cd4670c192b6f74832c5288d380949", "url": "https://github.com/apache/incubator-doris/commit/13ce036e71cd4670c192b6f74832c5288d380949", "message": "Doris support in memory olap table", "committedDate": "2020-02-12T07:41:40Z", "type": "forcePushed"}, {"oid": "1c1d00950ac102e00c0e89e6042538f793b28929", "url": "https://github.com/apache/incubator-doris/commit/1c1d00950ac102e00c0e89e6042538f793b28929", "message": "Doris support in memory olap table", "committedDate": "2020-02-17T05:27:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMTA4Nw==", "url": "https://github.com/apache/incubator-doris/pull/2847#discussion_r380131087", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                for(Triple<Long, Integer, Boolean> triple: tabletToInMemory) {\n          \n          \n            \n                                for (Triple<Long, Integer, Boolean> triple: tabletToInMemory) {", "author": "imay", "createdAt": "2020-02-17T11:34:32Z", "path": "fe/src/main/java/org/apache/doris/task/UpdateTabletMetaInfoTask.java", "diffHunk": "@@ -18,50 +18,134 @@\n package org.apache.doris.task;\n \n import java.util.List;\n-import java.util.Map;\n+import java.util.Set;\n \n+import org.apache.commons.lang3.tuple.Triple;\n import org.apache.doris.catalog.Catalog;\n import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.MarkedCountDownLatch;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.common.Status;\n+import org.apache.doris.thrift.TStatusCode;\n import org.apache.doris.thrift.TTabletMetaInfo;\n+import org.apache.doris.thrift.TTabletMetaType;\n import org.apache.doris.thrift.TTaskType;\n import org.apache.doris.thrift.TUpdateTabletMetaInfoReq;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n import com.google.common.collect.Lists;\n-import com.google.common.collect.SetMultimap;\n \n public class UpdateTabletMetaInfoTask extends AgentTask {\n \n-    private static final Logger LOG = LogManager.getLogger(ClearTransactionTask.class);\n+    private static final Logger LOG = LogManager.getLogger(UpdateTabletMetaInfoTask.class);\n \n-    private SetMultimap<Long, Integer> tabletWithoutPartitionId;\n+    // used for synchronous process\n+    private MarkedCountDownLatch<Long, Set<Pair<Long, Integer>>> latch;\n \n-    public UpdateTabletMetaInfoTask(long backendId, SetMultimap<Long, Integer> tabletWithoutPartitionId) {\n-        super(null, backendId, TTaskType.UPDATE_TABLET_META_INFO, -1L, -1L, -1L, -1L, -1L, backendId);\n-        this.tabletWithoutPartitionId = tabletWithoutPartitionId;\n+    private Set<Pair<Long, Integer>> tableIdWithSchemaHash;\n+    private boolean isInMemory;\n+    private TTabletMetaType metaType;\n+\n+    // <tablet id, tablet schema hash, tablet in memory>\n+    private List<Triple<Long, Integer, Boolean>> tabletToInMemory;\n+\n+    public UpdateTabletMetaInfoTask(long backendId, Set<Pair<Long, Integer>> tableIdWithSchemaHash,\n+                                    TTabletMetaType metaType) {\n+        super(null, backendId, TTaskType.UPDATE_TABLET_META_INFO,\n+                -1L, -1L, -1L, -1L, -1L, tableIdWithSchemaHash.hashCode());\n+        this.tableIdWithSchemaHash = tableIdWithSchemaHash;\n+        this.metaType = metaType;\n+    }\n+\n+    public UpdateTabletMetaInfoTask(long backendId,\n+                                    Set<Pair<Long, Integer>> tableIdWithSchemaHash,\n+                                    boolean isInMemory,\n+                                    MarkedCountDownLatch<Long, Set<Pair<Long, Integer>>> latch) {\n+        this(backendId, tableIdWithSchemaHash, TTabletMetaType.INMEMORY);\n+        this.isInMemory = isInMemory;\n+        this.latch = latch;\n+    }\n+\n+    public UpdateTabletMetaInfoTask(long backendId,\n+                                    List<Triple<Long, Integer, Boolean>> tabletToInMemory) {\n+        super(null, backendId, TTaskType.UPDATE_TABLET_META_INFO,\n+                -1L, -1L, -1L, -1L, -1L, tabletToInMemory.hashCode());\n+        this.metaType = TTabletMetaType.INMEMORY;\n+        this.tabletToInMemory = tabletToInMemory;\n+    }\n+\n+    public void countDownLatch(long backendId, Set<Pair<Long, Integer>> tablets) {\n+        if (this.latch != null) {\n+            if (latch.markedCountDown(backendId, tablets)) {\n+                LOG.debug(\"UpdateTabletMetaInfoTask current latch count: {}, backend: {}, tablets:{}\",\n+                        latch.getCount(), backendId, tablets);\n+            }\n+        }\n+    }\n+\n+    // call this always means one of tasks is failed. count down to zero to finish entire task\n+    public void countDownToZero(String errMsg) {\n+        if (this.latch != null) {\n+            latch.countDownToZero(new Status(TStatusCode.CANCELLED, errMsg));\n+            LOG.debug(\"UpdateTabletMetaInfoTask count down to zero. error msg: {}\", errMsg);\n+        }\n+    }\n+\n+    public Set<Pair<Long, Integer>> getTablets() {\n+        return tableIdWithSchemaHash;\n     }\n     \n     public TUpdateTabletMetaInfoReq toThrift() {\n         TUpdateTabletMetaInfoReq updateTabletMetaInfoReq = new TUpdateTabletMetaInfoReq();\n         List<TTabletMetaInfo> metaInfos = Lists.newArrayList();\n-        int tabletEntryNum = 0;\n-        for (Map.Entry<Long, Integer> entry : tabletWithoutPartitionId.entries()) {\n-            // add at most 10000 tablet meta during one sync to avoid too large task\n-            if (tabletEntryNum > 10000) {\n+        switch (metaType) {\n+            case PARTITIONID: {\n+                int tabletEntryNum = 0;\n+                for (Pair<Long, Integer> pair : tableIdWithSchemaHash) {\n+                    // add at most 10000 tablet meta during one sync to avoid too large task\n+                    if (tabletEntryNum > 10000) {\n+                        break;\n+                    }\n+                    TTabletMetaInfo metaInfo = new TTabletMetaInfo();\n+                    metaInfo.setTablet_id(pair.first);\n+                    metaInfo.setSchema_hash(pair.second);\n+                    TabletMeta tabletMeta = Catalog.getInstance().getTabletInvertedIndex().getTabletMeta(pair.first);\n+                    if (tabletMeta == null) {\n+                        LOG.warn(\"could not find tablet [{}] in meta ignore it\", pair.second);\n+                        continue;\n+                    }\n+                    metaInfo.setPartition_id(tabletMeta.getPartitionId());\n+                    metaInfo.setMeta_type(metaType);\n+                    metaInfos.add(metaInfo);\n+                    ++tabletEntryNum;\n+                }\n                 break;\n             }\n-            TTabletMetaInfo metaInfo = new TTabletMetaInfo();\n-            metaInfo.setTablet_id(entry.getKey());\n-            metaInfo.setSchema_hash(entry.getValue());\n-            TabletMeta tabletMeta = Catalog.getInstance().getTabletInvertedIndex().getTabletMeta(entry.getKey());\n-            if (tabletMeta == null) {\n-                LOG.warn(\"could not find tablet [{}] in meta ignore it\", entry.getKey());\n-                continue;\n+            case INMEMORY: {\n+                if (latch != null) {\n+                    // for schema change\n+                    for (Pair<Long, Integer> pair: tableIdWithSchemaHash) {\n+                        TTabletMetaInfo metaInfo = new TTabletMetaInfo();\n+                        metaInfo.setTablet_id(pair.first);\n+                        metaInfo.setSchema_hash(pair.second);\n+                        metaInfo.setIs_in_memory(isInMemory);\n+                        metaInfo.setMeta_type(metaType);\n+                        metaInfos.add(metaInfo);\n+                    }\n+                } else {\n+                   // for ReportHandler\n+                    for(Triple<Long, Integer, Boolean> triple: tabletToInMemory) {", "originalCommit": "1c1d00950ac102e00c0e89e6042538f793b28929", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86799297874d1b3ce2aa86e64dd17d541f71e660", "url": "https://github.com/apache/incubator-doris/commit/86799297874d1b3ce2aa86e64dd17d541f71e660", "message": "Doris support in memory olap table", "committedDate": "2020-02-17T13:46:43Z", "type": "commit"}, {"oid": "5c5b48549f31dd6013c5cbe3ffe1aa1a8d3b832a", "url": "https://github.com/apache/incubator-doris/commit/5c5b48549f31dd6013c5cbe3ffe1aa1a8d3b832a", "message": "Fix code style", "committedDate": "2020-02-17T13:48:02Z", "type": "commit"}, {"oid": "5c5b48549f31dd6013c5cbe3ffe1aa1a8d3b832a", "url": "https://github.com/apache/incubator-doris/commit/5c5b48549f31dd6013c5cbe3ffe1aa1a8d3b832a", "message": "Fix code style", "committedDate": "2020-02-17T13:48:02Z", "type": "forcePushed"}]}