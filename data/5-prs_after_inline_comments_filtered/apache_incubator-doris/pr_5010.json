{"pr_number": 5010, "pr_title": "[Rebalancer] support partition rebalancer", "pr_createdAt": "2020-12-02T10:51:26Z", "pr_url": "https://github.com/apache/incubator-doris/pull/5010", "timeline": [{"oid": "ac63a03adb48dff9a7f48d8513c4e5d1e4390a79", "url": "https://github.com/apache/incubator-doris/commit/ac63a03adb48dff9a7f48d8513c4e5d1e4390a79", "message": "[] partition rebalancer", "committedDate": "2020-12-02T10:44:48Z", "type": "commit"}, {"oid": "dc5361dcf71dd423fdfdfaca6dab8bcc98065790", "url": "https://github.com/apache/incubator-doris/commit/dc5361dcf71dd423fdfdfaca6dab8bcc98065790", "message": "[] comments & rename", "committedDate": "2020-12-03T03:22:25Z", "type": "commit"}, {"oid": "f81a67b90ca0c7c341bfa952b9f0e30ab8c9decf", "url": "https://github.com/apache/incubator-doris/commit/f81a67b90ca0c7c341bfa952b9f0e30ab8c9decf", "message": "[] fix config & add docs", "committedDate": "2020-12-03T07:15:52Z", "type": "commit"}, {"oid": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "url": "https://github.com/apache/incubator-doris/commit/700a6069acce1a3bbc3d814f7b1f196a564635b2", "message": "[] comments & logs fix", "committedDate": "2020-12-03T08:52:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NDg0NA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r539064844", "bodyText": "selectAlternativeTabletsForCluster method selects all tablets for maxSkew partition from highload be. If there is no check whether the move will make partition balance better, we may fall into endless loop in such case:\n3 tablets on maxload be\n1 tablet on minload be\nwe move 2 tablets from maxload be to minload be, and maxload be switchs to minload be.", "author": "gengjun-git", "createdAt": "2020-12-09T07:20:13Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyAlgo algo = new TwoDimensionalGreedyAlgo();\n+    protected final MovesInProgressCache movesInProgressCache = new MovesInProgressCache();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesInProgressCache.Cell movesInProgress = movesInProgressCache.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesInProgressMap should have the same entry\");\n+\n+        // iterating through cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<ReplicaMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<ReplicaMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        if (movesInProgressCache.size() > Config.max_balancing_tablets) {\n+            LOG.debug(\"Total in-progress moves > {}\", Config.max_balancing_tablets);\n+            return Lists.newArrayList();\n+        }\n+\n+        NavigableSet<Long> skews = clusterBalanceInfo.partitionInfoBySkew.keySet();\n+        LOG.debug(\"Cluster {}-{}: peek max skew {}, assume {} in-progress moves are succeeded {}\", clusterName, medium,\n+                skews.isEmpty() ? 0 : skews.last(), movesInProgressList.size(), movesInProgressList);\n+\n+        List<TwoDimensionalGreedyAlgo.PartitionReplicaMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.rebalance_max_moves_num_per_selection);\n+\n+        List<TabletSchedCtx> alternativeTablets = Lists.newArrayList();\n+        List<Long> inProgressIds = movesInProgressList.stream().map(m -> m.tabletId).collect(Collectors.toList());\n+        for (TwoDimensionalGreedyAlgo.PartitionReplicaMove move : moves) {\n+            // Find all tablets of the specified partition that would have a replica at the source be,\n+            // but would not have a replica at the destination be. That is to satisfy the restriction\n+            // of having no more than one replica of the same tablet per be.\n+            List<Long> tabletIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.fromBe, medium);\n+            List<Long> invalidIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.toBe, medium);\n+            tabletIds.removeAll(invalidIds);\n+            // In-progress tablets can't be the candidate too.\n+            tabletIds.removeAll(inProgressIds);\n+\n+            Map<Long, TabletMeta> tabletCandidates = Maps.newHashMap();\n+            for (long tabletId : tabletIds) {\n+                TabletMeta tabletMeta = invertedIndex.getTabletMeta(tabletId);\n+                if (tabletMeta != null && tabletMeta.getPartitionId() == move.partitionId\n+                        && tabletMeta.getIndexId() == move.indexId) {\n+                    tabletCandidates.put(tabletId, tabletMeta);\n+                }\n+            }\n+            LOG.debug(\"Find {} candidates for move {}\", tabletCandidates.size(), move);\n+            if (tabletCandidates.isEmpty()) {\n+                continue;\n+            }\n+\n+            // Random pick one candidate to create tabletSchedCtx\n+            Random rand = new Random();\n+            Object[] keys = tabletCandidates.keySet().toArray();\n+            long pickedTabletId = (long) keys[rand.nextInt(keys.length)];\n+            LOG.debug(\"Picked tablet id for move {}: {}\", move, pickedTabletId);\n+\n+            TabletMeta tabletMeta = tabletCandidates.get(pickedTabletId);\n+            TabletSchedCtx tabletCtx = new TabletSchedCtx(TabletSchedCtx.Type.BALANCE, clusterName,\n+                    tabletMeta.getDbId(), tabletMeta.getTableId(), tabletMeta.getPartitionId(),\n+                    tabletMeta.getIndexId(), pickedTabletId, System.currentTimeMillis());\n+            // Balance task's priority is always LOW\n+            tabletCtx.setOrigPriority(TabletSchedCtx.Priority.LOW);\n+            alternativeTablets.add(tabletCtx);\n+            // Pair<Move, ToDeleteReplicaId>, ToDeleteReplicaId should be -1L before scheduled successfully\n+            movesInProgress.get().put(pickedTabletId, new Pair<>(new ReplicaMove(pickedTabletId, move.fromBe, move.toBe), -1L));\n+            counterBalanceMoveCreated.incrementAndGet();\n+            // synchronize with movesInProgress\n+            inProgressIds.add(pickedTabletId);\n+        }\n+\n+        if (moves.isEmpty()) {\n+            // Balanced cluster should not print too much log messages.\n+            LOG.debug(\"Cluster {}-{}: cluster is balanced.\", clusterName, medium);\n+        } else {\n+            LOG.info(\"Cluster {}-{}: get {} moves, actually select {} alternative tablets to move. Tablets detail: {}\",\n+                    clusterName, medium, moves.size(), alternativeTablets.size(),\n+                    alternativeTablets.stream().mapToLong(TabletSchedCtx::getTabletId).toArray());\n+        }\n+        return alternativeTablets;\n+    }\n+\n+    private boolean buildClusterInfo(ClusterLoadStatistic clusterStat, TStorageMedium medium,\n+                                     List<ReplicaMove> movesInProgress, ClusterBalanceInfo info, List<Long> toDeleteKeys) {\n+        Preconditions.checkState(info.beByTotalReplicaCount.isEmpty() && info.partitionInfoBySkew.isEmpty(), \"\");\n+\n+        // If we wanna modify the PartitionBalanceInfo in info.beByTotalReplicaCount, deep-copy it\n+        info.beByTotalReplicaCount.putAll(clusterStat.getBeByTotalReplicaMap(medium));\n+        info.partitionInfoBySkew.putAll(clusterStat.getSkewMap(medium));\n+\n+        // Skip the toDeleteKeys\n+        List<ReplicaMove> filteredMoves = movesInProgress.stream().filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+\n+        for (ReplicaMove move : filteredMoves) {\n+            TabletMeta meta = invertedIndex.getTabletMeta(move.tabletId);\n+            if (meta == null) {\n+                // Move's tablet is invalid, need delete it\n+                toDeleteKeys.add(move.tabletId);\n+                continue;\n+            }\n+\n+            TwoDimensionalGreedyAlgo.PartitionReplicaMove partitionMove = new TwoDimensionalGreedyAlgo.\n+                    PartitionReplicaMove(meta.getPartitionId(), meta.getIndexId(), move.fromBe, move.toBe);\n+            boolean st = TwoDimensionalGreedyAlgo.applyMove(partitionMove, info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (!st) {\n+                // Can't apply this move, mark it failed, continue to apply the next.\n+                toDeleteKeys.add(move.tabletId);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void checkMovesCompleted(List<ReplicaMove> moves, List<Long> toDeleteKeys) {\n+        boolean move_is_complete;\n+        for (ReplicaMove move : moves) {\n+            move_is_complete = checkMoveCompleted(move);\n+            // If the move was completed, remove it\n+            if (move_is_complete) {\n+                toDeleteKeys.add(move.tabletId);\n+                LOG.debug(\"Move {} is completed. The cur dist: {}\", move,\n+                        invertedIndex.getReplicasByTabletId(move.tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList()));\n+                counterBalanceMoveSucceeded.incrementAndGet();\n+            }\n+        }\n+    }\n+\n+    // Move completed: fromBe doesn't have a replica and toBe has a replica\n+    private boolean checkMoveCompleted(ReplicaMove move) {\n+        Long tabletId = move.tabletId;\n+        List<Long> bes = invertedIndex.getReplicasByTabletId(tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList());\n+        return !bes.contains(move.fromBe) && bes.contains(move.toBe);\n+    }\n+\n+    @Override\n+    protected void completeSchedCtx(TabletSchedCtx tabletCtx, Map<Long, TabletScheduler.PathSlot> backendsWorkingSlots)\n+            throws SchedException {\n+        MovesInProgressCache.Cell movesInProgress = movesInProgressCache.getCache(tabletCtx.getCluster(), tabletCtx.getStorageMedium());\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesInProgressMap should have the same entry\");\n+\n+        try {\n+            Pair<ReplicaMove, Long> pair = movesInProgress.get().getIfPresent(tabletCtx.getTabletId());\n+            Preconditions.checkNotNull(pair, \"No cached move for tablet: \" + tabletCtx.getTabletId());\n+\n+            ReplicaMove move = pair.first;\n+            checkMoveValidation(move);\n+\n+            // Check src replica's validation\n+            Replica srcReplica = tabletCtx.getTablet().getReplicaByBackendId(move.fromBe);\n+            Preconditions.checkNotNull(srcReplica);\n+            TabletScheduler.PathSlot slot = backendsWorkingSlots.get(srcReplica.getBackendId());\n+            Preconditions.checkNotNull(slot, \"unable to get fromBe \" + srcReplica.getBackendId() + \" slot\");\n+            if (slot.takeBalanceSlot(srcReplica.getPathHash()) != -1) {\n+                tabletCtx.setSrc(srcReplica);\n+            } else {\n+                throw new SchedException(SchedException.Status.SCHEDULE_FAILED, \"no slot for src replica \" + srcReplica + \", pathHash \" + srcReplica.getPathHash());\n+            }\n+\n+            // Choose a path in destination\n+            ClusterLoadStatistic clusterStat = statisticMap.get(tabletCtx.getCluster());\n+            Preconditions.checkNotNull(clusterStat, \"cluster does not exist: \" + tabletCtx.getCluster());\n+            BackendLoadStatistic beStat = clusterStat.getBackendLoadStatistic(move.toBe);\n+            Preconditions.checkNotNull(beStat);\n+            slot = backendsWorkingSlots.get(move.toBe);\n+            Preconditions.checkNotNull(slot, \"unable to get slot of toBe \" + move.toBe);\n+\n+            List<RootPathLoadStatistic> paths = beStat.getPathStatistics();\n+            Set<Long> availPath = paths.stream().filter(path -> path.getStorageMedium() == tabletCtx.getStorageMedium()\n+                    && path.isFit(tabletCtx.getTabletSize(), false) == BalanceStatus.OK)\n+                    .map(RootPathLoadStatistic::getPathHash).collect(Collectors.toSet());\n+            long pathHash = slot.takeAnAvailBalanceSlotFrom(availPath);\n+            if (pathHash == -1) {\n+                throw new SchedException(SchedException.Status.SCHEDULE_FAILED, \"paths has no available balance slot: \" + availPath);\n+            } else {\n+                tabletCtx.setDest(beStat.getBeId(), pathHash);\n+            }\n+\n+            // ToDeleteReplica is the source replica\n+            pair.second = srcReplica.getId();\n+        } catch (IllegalStateException | NullPointerException e) {\n+            // Problematic move should be invalidated immediately\n+            movesInProgress.get().invalidate(tabletCtx.getTabletId());\n+            throw new SchedException(SchedException.Status.UNRECOVERABLE, e.getMessage());\n+        }\n+    }\n+\n+    // The validation check cannot be accurate, cuz the production of moves do have ordering.\n+    // If some moves failed, the cluster & partition skew is different to the skew when we getNextMove.\n+    // So we can't do skew check.\n+    // Just do some basic checks, e.g. server available.\n+    private void checkMoveValidation(ReplicaMove move) throws IllegalStateException {\n+        boolean fromAvailable = infoService.checkBackendAvailable(move.fromBe);\n+        boolean toAvailable = infoService.checkBackendAvailable(move.toBe);\n+        Preconditions.checkState(fromAvailable && toAvailable, move + \"'s bes are not all available: from \" + fromAvailable + \", to \" + toAvailable);\n+        // To be improved\n+    }", "originalCommit": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE2NTc0NQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r539165745", "bodyText": "Not all, just pick one tablet to generate one move. and apply the move to current balance info, it's in the algo implement.", "author": "vagetablechicken", "createdAt": "2020-12-09T09:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NDg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5OTY2OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r539199668", "bodyText": "OK", "author": "gengjun-git", "createdAt": "2020-12-09T10:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2NDg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjA0MA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r546702040", "bodyText": "tablet_rebalancer_type?", "author": "kangkaisen", "createdAt": "2020-12-21T13:21:37Z", "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -1010,6 +1010,18 @@\n     @ConfField(mutable = true, masterOnly = true)\n     public static int max_balancing_tablets = 100;\n \n+    // Rebalancer type(ignore case): BeLoad, Partition. If type parse failed, use BeLoad as default.\n+    @ConfField(masterOnly = true)\n+    public static String rebalancer_type = \"BeLoad\";", "originalCommit": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMjkwOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547032909", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-22T02:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjYzNg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r546702636", "bodyText": "If only valid for PartitionRebalancer, the name would better add a partition prefix.", "author": "kangkaisen", "createdAt": "2020-12-21T13:23:01Z", "path": "fe/fe-core/src/main/java/org/apache/doris/common/Config.java", "diffHunk": "@@ -1010,6 +1010,18 @@\n     @ConfField(mutable = true, masterOnly = true)\n     public static int max_balancing_tablets = 100;\n \n+    // Rebalancer type(ignore case): BeLoad, Partition. If type parse failed, use BeLoad as default.\n+    @ConfField(masterOnly = true)\n+    public static String rebalancer_type = \"BeLoad\";\n+\n+    // Valid only if use PartitionRebalancer.\n+    @ConfField(mutable = true, masterOnly = true)\n+    public static long rebalance_move_expire_after_access = 600; // 600s", "originalCommit": "700a6069acce1a3bbc3d814f7b1f196a564635b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzAzMzM1OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547033358", "bodyText": "ok", "author": "vagetablechicken", "createdAt": "2020-12-22T02:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjYzNg=="}], "type": "inlineReview"}, {"oid": "db0c06d655f8edd5b5c889768815cc8400b266c2", "url": "https://github.com/apache/incubator-doris/commit/db0c06d655f8edd5b5c889768815cc8400b266c2", "message": "fix by review", "committedDate": "2020-12-22T02:35:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODc1NA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547278754", "bodyText": "Add a comment for cache what?", "author": "kangkaisen", "createdAt": "2020-12-22T13:31:01Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.thrift.TStorageMedium;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+public class MovesInProgressCache {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQyNzE4OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548427188", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-24T07:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547278972", "bodyText": "maybe need a better name", "author": "kangkaisen", "createdAt": "2020-12-22T13:31:29Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/MovesInProgressCache.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.collect.Maps;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.thrift.TStorageMedium;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringJoiner;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+public class MovesInProgressCache {\n+    // cluster -> medium -> moves in progress\n+    private final Map<String, Map<TStorageMedium, Cell>> movesInProgressMap = Maps.newHashMap();\n+\n+    // TabletId -> Pair<Move, ToDeleteReplicaId>, 'ToDeleteReplicaId == -1' means this move haven't been scheduled successfully.\n+    public static class Cell {\n+        Cache<Long, Pair<PartitionRebalancer.ReplicaMove, Long>> cache;\n+\n+        Cell(long duration, TimeUnit unit) {\n+            cache = CacheBuilder.newBuilder().expireAfterAccess(duration, unit).build();\n+        }\n+\n+        public Cache<Long, Pair<PartitionRebalancer.ReplicaMove, Long>> get() {\n+            return cache;\n+        }\n+    }\n+\n+    public void updateCatalog(Map<String, ClusterLoadStatistic> statisticMap, long expireAfterAccessSecond) {\n+        updateCatalog(statisticMap, expireAfterAccessSecond, TimeUnit.SECONDS);\n+    }\n+\n+    public void updateCatalog(Map<String, ClusterLoadStatistic> statisticMap, long duration, TimeUnit unit) {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ0MDcxOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548440719", "bodyText": "how about updateMapping?", "author": "vagetablechicken", "createdAt": "2020-12-24T08:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUzMTg3Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548531872", "bodyText": "\u8fd9\u4e2a\u65b9\u6cd5\u4e0d\u662f\u5728 update cache \u5417\uff1f \u4f60\u7684\u7c7b\u540d\u662fMovesInProgressCache\uff0c \u800c\u4e14\u6709getCache\u3002 \u6240\u4ee5updateCache \u662f\u4e0d\u662f\u66f4\u597d\u7406\u89e3\uff1f", "author": "kangkaisen", "createdAt": "2020-12-24T13:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU0MzM2Nw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548543367", "bodyText": "\u8fd9\u91cc\u662f\u5728\u66f4\u65b0map\u7684\u7ed3\u6784\uff0c\u5e76\u4e0d\u662f\u8981\u5bf9\u5df2\u6709\u7684cache\u505a\u4ec0\u4e48\u66f4\u65b0\u3002", "author": "vagetablechicken", "createdAt": "2020-12-24T14:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc3OTYwOA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548779608", "bodyText": "\u6240\u4ee5\u8fd9\u4e2a\u7c7b\u7684\u8bbe\u8ba1\u662f\u4e0d\u662f\u6709\u4e9b\u95ee\u9898\uff1a\n1 map\u548ccache\u7684\u533a\u522b\u662f\u5565\uff1f\u4e3a\u5565cache \u53ea\u6709get \u65b9\u6cd5\uff0c map\u53ea\u6709update \u65b9\u6cd5\uff1f\n2 \u6211\u770b LoadingCache \u6ca1\u6709\u5b9a\u4e49 load\u65b9\u6cd5\uff0c\u8fd9\u91cccache\u7684\u66f4\u65b0\u662f\u5565\u65f6\u5019\u53d1\u751f\u5462\uff1f", "author": "kangkaisen", "createdAt": "2020-12-25T02:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4NTEwNg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548785106", "bodyText": "\u8fd9\u91cc\u7684\u66f4\u65b0\u662f<cluster, <meduim, cache>\u8fd9\u4e2a\u6620\u5c04\u7684\u66f4\u65b0\uff0c\u4e0d\u662f\u53bb\u66f4\u65b0cache\uff0c\u56e0\u4e3acluster\u76ee\u524d\u8fd8\u662f\u53ef\u4ee5add\u7684\uff0c\u5728\u5468\u671f\u6027update\u5404\u79cd\u4fe1\u606f\u65f6\u987a\u5e26\u628a\u6620\u5c04\u66f4\u65b0\u4e86\uff0c\u4ee5\u514dselectTablet\u65f6\u627e\u4e0d\u5230cache\u3002\ncache\u7528Cell\u7c7b\u88c5\u8d77\u6765\uff0c\u662f\u4e3a\u4e86\u9690\u85cfcache\u7684\u5177\u4f53\u521b\u5efa\uff0c\u9700\u8981\u4fee\u6539\u65f6\u4e5f\u65b9\u4fbf\uff0c\u800c\u4e14Cache\u7684\u540d\u5b57\u592a\u957f\u4e86\u3002\u62ff\u5230cell\u540e\u7528get()\u76f4\u63a5\u64cd\u4f5c\uff0c\u6bd4\u8f83\u65b9\u4fbf\u3002\n\u8fd9\u90e8\u5206\u547d\u540d\u8fd8\u4e0d\u591f\u6e05\u6670\uff0c\u6211\u518d\u6574\u7406\u4e0b", "author": "vagetablechicken", "createdAt": "2020-12-25T02:52:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MDMzMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548790332", "bodyText": "\u597d\u7684\u3002", "author": "kangkaisen", "createdAt": "2020-12-25T03:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI3ODk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYxNzM5Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547617392", "bodyText": "Could copy the description in the doc to this class comment.", "author": "kangkaisen", "createdAt": "2020-12-23T03:18:44Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class PartitionRebalancer extends Rebalancer {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQyMjYyMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548422622", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-24T07:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYxNzM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTU5Ng==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547621596", "bodyText": "\u6211\u89c9\u5f97\u8fd9\u4e2a\u7c7b\u540d\u5e94\u8be5\u4f53\u73b0\u51fa \u8fd9\u662f\u4e00\u4e2a rebalancing \u76f8\u5173\u7684\u7b97\u6cd5\u3002\n\u7136\u540e \u6ce8\u91ca \u6700\u597d\u89e3\u91ca\u4e0b \u4e24\u7ef4 \u662f\u54ea\u4e24\u7ef4\uff1f", "author": "kangkaisen", "createdAt": "2020-12-23T03:37:31Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyAlgo.java", "diffHunk": "@@ -0,0 +1,326 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+// A two-dimensional greedy rebalancing algorithm. From among moves that\n+// decrease the skew of a most skewed partition, it prefers ones that reduce the\n+// skew of the cluster. A cluster is considered balanced when the skew of every\n+// partition is <= 1 and the skew of the cluster is <= 1.\n+//\n+// The skew of the cluster is defined as the difference between the maximum\n+// total replica count over all bes and the minimum total replica\n+// count over all bes.\n+public class TwoDimensionalGreedyAlgo {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjU2MQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547622561", "bodyText": "\u8fd9\u91cc\u53ef\u4ee5\u6ce8\u660e\u662f \u8fd9\u4e2a\u7c7b\u662f  inspire  \u6216\u8005modify from kudu.", "author": "kangkaisen", "createdAt": "2020-12-23T03:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQ0MjY5Ng==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548442696", "bodyText": "fixed", "author": "vagetablechicken", "createdAt": "2020-12-24T08:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r547622309", "bodyText": "\u6211\u4eec\u53ef\u4ee5\u628amove \u8fd9\u4e2a\u6982\u5ff5\u5b8c\u5168\u53bb\u6389\u5417\uff1f \u6539\u6210 balancing \u6216\u8005 balancing_tablets\u3002 \u6211\u4eec\u7cfb\u7edf\u91cc\u9762\u7684\u6982\u5ff5\u5e94\u8be5\u5c3d\u53ef\u80fd\u5c11\uff0c\u4fdd\u6301\u7edf\u4e00\u3002", "author": "kangkaisen", "createdAt": "2020-12-23T03:40:34Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,324 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyAlgo algo = new TwoDimensionalGreedyAlgo();\n+    protected final MovesInProgressCache movesInProgressCache = new MovesInProgressCache();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesInProgressCache.Cell movesInProgress = movesInProgressCache.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesInProgressMap should have the same entry\");\n+\n+        // iterating through cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<ReplicaMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<ReplicaMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        if (movesInProgressCache.size() > Config.max_balancing_tablets) {", "originalCommit": "db0c06d655f8edd5b5c889768815cc8400b266c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODQxODc2OA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548418768", "bodyText": "move\u4e0d\u53ef\u80fd\u53bb\u6389\uff0c\u8c03\u5ea6\u5355\u4f4d\u5c31\u662fReplicaMove\u3002\nmovesInProgressCache.size() > Config.max_balancing_tablets \u8fd9\u4e00\u53e5\u5982\u679c\u89c9\u5f97\u96be\u7406\u89e3\uff0c\u53ef\u4ee5\u52a0\u70b9\u6ce8\u91ca", "author": "vagetablechicken", "createdAt": "2020-12-24T06:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODUzMTQwNQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548531405", "bodyText": "\u4e0d\u662f\u554a\u3002 move \u662f\u4e2a\u5f88\u62bd\u8c61\u7684\u6982\u5ff5\u3002\u6211\u89c9\u5f97\uff0c \u4e00\u4e2a \u7684balance \u7cfb\u7edf\u662f\u6ca1\u5fc5\u8981\u51fa\u73b0\u8fd9\u4e2a\u6982\u5ff5\u7684\uff0c\u4f60\u7684\u4e00\u4e2amove\u5c31\u662f\u4e00\u4e2abalancing\u7684Replica\u3002\n\nmovesInProgressCache.size() > Config.max_balancing_tablets \u8fd9\u4e00\u53e5\u5982\u679c\u89c9\u5f97\u96be\u7406\u89e3\uff0c\u53ef\u4ee5\u52a0\u70b9\u6ce8\u91ca\n\n\u6211\u4e0d\u662f\u7279\u6307\u8fd9\u4e00\u5904\uff0c\u800c\u662f\u8fd9\u4e2aPR\u3002\n\u6240\u6709balancing \u7b97\u6cd5\u7684\u6982\u5ff5\u5e94\u8be5\u662f\u7edf\u4e00\u7684\uff0c\u8fd9\u6837\u5176\u4ed6\u4eba\u53ef\u4ee5\u5feb\u901f\u7406\u89e3\u6bcf\u4e2abalancing\u7b97\u6cd5\u7684\u5f02\u540c\u3002", "author": "kangkaisen", "createdAt": "2020-12-24T13:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODU0NDQ3MA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548544470", "bodyText": "PartitionRebalancer\u5df2\u7ecf\u662f\u4e2a\u5177\u4f53\u7684rebalancer\uff0c\u5b83\u7684\u4efb\u52a1\u5c31\u662f\u4ecealgo\u90a3\u91cc\u62ff\u5230\u9700\u8981\u6267\u884c\u7684moves\uff0c\u7136\u540e\u53bb\u6267\u884cmoves\uff0c\u7ba1\u7406moves\uff0c\u804c\u8d23\u5df2\u7ecf\u5f88\u5c0f\u4e86\uff0c\u4e3a\u4ec0\u4e48\u8fd8\u8981\u53bb\u9690\u85cfmove\u7684\u6982\u5ff5\uff1f", "author": "vagetablechicken", "createdAt": "2020-12-24T14:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc3OTcxOQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548779719", "bodyText": "\u6240\u4ee5\u4f60\u53ef\u4ee5\u7528\u7b80\u5355\u7684\u4e00\u53e5\u8bdd\u6e05\u6670\u5730\u5b9a\u4e49\u5565\u662fmove \u5417\uff1f", "author": "kangkaisen", "createdAt": "2020-12-25T02:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc4NjQwNA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548786404", "bodyText": "move\u5c31\u662f\u4e3a\u5f53\u524dreplica\u5206\u5e03\u5982\u4f55\u8fbe\u5230\u5e73\u8861\u800c\u8ba1\u7b97\u51fa\u6765\u7684\u8fc1\u79fb\u6b65\u9aa4\u3002\nalgo\u7684\u89d2\u5ea6move\u5c31\u662f<partition id, from be, to be>\uff0cpartition rebalancer\u9009\u62e9\u7279\u5b9atablet\u540e\u7684move\u5c31\u662f<tablet id, from be, to be>\u3002", "author": "vagetablechicken", "createdAt": "2020-12-25T03:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5MDc2MQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548790761", "bodyText": "algo\u7684\u89d2\u5ea6move\u5c31\u662f<partition id, from be, to be>\uff0cpartition rebalancer\u9009\u62e9\u7279\u5b9atablet\u540e\u7684move\u5c31\u662f<tablet id, from be, to be>\u3002\n\n\u55ef\uff0c\u8fd9\u4e2a\u662f\u597d\u7406\u89e3\u7684\u3002 \u6240\u4ee5\u6211\u7684\u610f\u601d\u6211\u4eec\u53ef\u4ee5\u547d\u540d\u6210 balancingPartition \u548c balancingTablet\uff1f \u5373\u4f7f\u4e00\u5b9a\u8981\u7528move\u7684\u8bdd\uff0c\u4e5f\u53ef\u4ee5\u6539\u6210 partitionMove \u548c tabletMove ?  \u56e0\u4e3a \u6211\u611f\u89c9 move \u8fd9\u4e2a\u547d\u540d\u592a\u62bd\u8c61\u4e86\u3002", "author": "kangkaisen", "createdAt": "2020-12-25T03:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc5NDYwNQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548794605", "bodyText": "move\u662f\u7b97\u6cd5\u7684\u57fa\u672c\u7ed3\u679c\uff0c\u8fd8\u662f\u4fdd\u7559\u5427\uff0cReplicaMove\u8fd9\u4e2a\u540d\u5b57\u6539\u6210TabletMove, PartitionReplicaMove\u6539\u4e3aPartitionMove\u5427", "author": "vagetablechicken", "createdAt": "2020-12-25T04:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgwMDE3Mw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r548800173", "bodyText": "\u597d\u7684\u3002", "author": "kangkaisen", "createdAt": "2020-12-25T04:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzYyMjMwOQ=="}], "type": "inlineReview"}, {"oid": "6a267bebec5c53fe67fca1853b079538a298728f", "url": "https://github.com/apache/incubator-doris/commit/6a267bebec5c53fe67fca1853b079538a298728f", "message": "[] fixed by review", "committedDate": "2020-12-24T08:20:30Z", "type": "commit"}, {"oid": "d0ee249fc3eb81897b05c2e4e0b55f4640f87886", "url": "https://github.com/apache/incubator-doris/commit/d0ee249fc3eb81897b05c2e4e0b55f4640f87886", "message": "[] fix", "committedDate": "2020-12-24T08:25:17Z", "type": "commit"}, {"oid": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "url": "https://github.com/apache/incubator-doris/commit/5ef852d3a8ba19a2de2819066fb89addca6db4a5", "message": "[] fixed by review", "committedDate": "2020-12-25T10:42:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM2OTMyNA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549369324", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            long min_count = pbi.beByReplicaCount.keySet().first();\n          \n          \n            \n                            long minCount = pbi.beByReplicaCount.keySet().first();", "author": "morningman", "createdAt": "2020-12-28T14:35:31Z", "path": "fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java", "diffHunk": "@@ -602,5 +604,96 @@ public void clear() {\n     public Map<Long, Long> getReplicaToTabletMap() {\n         return replicaToTabletMap;\n     }\n+\n+    // Only build from available bes, exclude colocate tables\n+    public Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> buildPartitionInfoBySkew(List<Long> availableBeIds) {\n+        readLock();\n+\n+        // 1. gen <partitionId-indexId, <beId, replicaCount>>\n+        // for each replica(all tablets):\n+        //      find beId, then replicaCount++\n+        Map<TStorageMedium, Table<Long, Long, Map<Long, Long>>> partitionReplicasInfoMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            partitionReplicasInfoMaps.put(medium, HashBasedTable.create());\n+        }\n+        try {\n+            // Changes to the returned set will update the underlying table\n+            // tablet id -> (backend id -> replica)\n+            Set<Table.Cell<Long, Long, Replica>> cells = replicaMetaTable.cellSet();\n+            for (Table.Cell<Long, Long, Replica> cell : cells) {\n+                Long tabletId = cell.getRowKey();\n+                Long beId = cell.getColumnKey();\n+                try {\n+                    Preconditions.checkState(availableBeIds.contains(beId), \"dead be \" + beId);\n+                    TabletMeta tabletMeta = tabletMetaMap.get(tabletId);\n+                    Preconditions.checkNotNull(tabletMeta, \"invalid tablet \" + tabletId);\n+                    Preconditions.checkState(!Catalog.getCurrentColocateIndex().isColocateTable(tabletMeta.getTableId()),\n+                            \"should not be the colocate table\");\n+\n+                    TStorageMedium medium = tabletMeta.getStorageMedium();\n+                    Table<Long, Long, Map<Long, Long>> partitionReplicasInfo = partitionReplicasInfoMaps.get(medium);\n+                    Map<Long, Long> countMap = partitionReplicasInfo.get(tabletMeta.getPartitionId(), tabletMeta.getIndexId());\n+                    if (countMap == null) {\n+                        // If one be doesn't have any replica of one partition, it should be counted too.\n+                        countMap = availableBeIds.stream().collect(Collectors.toMap(i -> i, i -> 0L));\n+                    }\n+\n+                    Long count = countMap.get(beId);\n+                    countMap.put(beId, count + 1L);\n+                    partitionReplicasInfo.put(tabletMeta.getPartitionId(), tabletMeta.getIndexId(), countMap);\n+                    partitionReplicasInfoMaps.put(medium, partitionReplicasInfo);\n+                } catch (IllegalStateException | NullPointerException e) {\n+                    // If the tablet or be has some problem, don't count in\n+                    LOG.debug(e.getMessage());\n+                }\n+            }\n+        } finally {\n+            readUnlock();\n+        }\n+\n+        // 2. Populate ClusterBalanceInfo::table_info_by_skew\n+        // for each PartitionId-MaterializedIndex:\n+        //      for each beId: record max_count, min_count(replicaCount)\n+        //      put <max_count-min_count, TableBalanceInfo> to table_info_by_skew\n+        Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> skewMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            TreeMultimap<Long, PartitionBalanceInfo> partitionInfoBySkew = TreeMultimap.create(Ordering.natural(), Ordering.arbitrary());\n+            Set<Table.Cell<Long, Long, Map<Long, Long>>> mapCells = partitionReplicasInfoMaps.getOrDefault(medium, HashBasedTable.create()).cellSet();\n+            for (Table.Cell<Long, Long, Map<Long, Long>> cell : mapCells) {\n+                Map<Long, Long> countMap = cell.getValue();\n+                Preconditions.checkNotNull(countMap);\n+                PartitionBalanceInfo pbi = new PartitionBalanceInfo(cell.getRowKey(), cell.getColumnKey());\n+                for (Map.Entry<Long, Long> entry : countMap.entrySet()) {\n+                    Long beID = entry.getKey();\n+                    Long replicaCount = entry.getValue();\n+                    pbi.beByReplicaCount.put(replicaCount, beID);\n+                }\n+                // beByReplicaCount values are natural ordering\n+                long min_count = pbi.beByReplicaCount.keySet().first();", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM2OTQwMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549369402", "bodyText": "maxCount", "author": "morningman", "createdAt": "2020-12-28T14:35:44Z", "path": "fe/fe-core/src/main/java/org/apache/doris/catalog/TabletInvertedIndex.java", "diffHunk": "@@ -602,5 +604,96 @@ public void clear() {\n     public Map<Long, Long> getReplicaToTabletMap() {\n         return replicaToTabletMap;\n     }\n+\n+    // Only build from available bes, exclude colocate tables\n+    public Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> buildPartitionInfoBySkew(List<Long> availableBeIds) {\n+        readLock();\n+\n+        // 1. gen <partitionId-indexId, <beId, replicaCount>>\n+        // for each replica(all tablets):\n+        //      find beId, then replicaCount++\n+        Map<TStorageMedium, Table<Long, Long, Map<Long, Long>>> partitionReplicasInfoMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            partitionReplicasInfoMaps.put(medium, HashBasedTable.create());\n+        }\n+        try {\n+            // Changes to the returned set will update the underlying table\n+            // tablet id -> (backend id -> replica)\n+            Set<Table.Cell<Long, Long, Replica>> cells = replicaMetaTable.cellSet();\n+            for (Table.Cell<Long, Long, Replica> cell : cells) {\n+                Long tabletId = cell.getRowKey();\n+                Long beId = cell.getColumnKey();\n+                try {\n+                    Preconditions.checkState(availableBeIds.contains(beId), \"dead be \" + beId);\n+                    TabletMeta tabletMeta = tabletMetaMap.get(tabletId);\n+                    Preconditions.checkNotNull(tabletMeta, \"invalid tablet \" + tabletId);\n+                    Preconditions.checkState(!Catalog.getCurrentColocateIndex().isColocateTable(tabletMeta.getTableId()),\n+                            \"should not be the colocate table\");\n+\n+                    TStorageMedium medium = tabletMeta.getStorageMedium();\n+                    Table<Long, Long, Map<Long, Long>> partitionReplicasInfo = partitionReplicasInfoMaps.get(medium);\n+                    Map<Long, Long> countMap = partitionReplicasInfo.get(tabletMeta.getPartitionId(), tabletMeta.getIndexId());\n+                    if (countMap == null) {\n+                        // If one be doesn't have any replica of one partition, it should be counted too.\n+                        countMap = availableBeIds.stream().collect(Collectors.toMap(i -> i, i -> 0L));\n+                    }\n+\n+                    Long count = countMap.get(beId);\n+                    countMap.put(beId, count + 1L);\n+                    partitionReplicasInfo.put(tabletMeta.getPartitionId(), tabletMeta.getIndexId(), countMap);\n+                    partitionReplicasInfoMaps.put(medium, partitionReplicasInfo);\n+                } catch (IllegalStateException | NullPointerException e) {\n+                    // If the tablet or be has some problem, don't count in\n+                    LOG.debug(e.getMessage());\n+                }\n+            }\n+        } finally {\n+            readUnlock();\n+        }\n+\n+        // 2. Populate ClusterBalanceInfo::table_info_by_skew\n+        // for each PartitionId-MaterializedIndex:\n+        //      for each beId: record max_count, min_count(replicaCount)\n+        //      put <max_count-min_count, TableBalanceInfo> to table_info_by_skew\n+        Map<TStorageMedium, TreeMultimap<Long, PartitionBalanceInfo>> skewMaps = Maps.newHashMap();\n+        for (TStorageMedium medium : TStorageMedium.values()) {\n+            TreeMultimap<Long, PartitionBalanceInfo> partitionInfoBySkew = TreeMultimap.create(Ordering.natural(), Ordering.arbitrary());\n+            Set<Table.Cell<Long, Long, Map<Long, Long>>> mapCells = partitionReplicasInfoMaps.getOrDefault(medium, HashBasedTable.create()).cellSet();\n+            for (Table.Cell<Long, Long, Map<Long, Long>> cell : mapCells) {\n+                Map<Long, Long> countMap = cell.getValue();\n+                Preconditions.checkNotNull(countMap);\n+                PartitionBalanceInfo pbi = new PartitionBalanceInfo(cell.getRowKey(), cell.getColumnKey());\n+                for (Map.Entry<Long, Long> entry : countMap.entrySet()) {\n+                    Long beID = entry.getKey();\n+                    Long replicaCount = entry.getValue();\n+                    pbi.beByReplicaCount.put(replicaCount, beID);\n+                }\n+                // beByReplicaCount values are natural ordering\n+                long min_count = pbi.beByReplicaCount.keySet().first();\n+                long max_count = pbi.beByReplicaCount.keySet().last();", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM5NTE1Nw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549395157", "bodyText": "Is 1 too strict here?", "author": "morningman", "createdAt": "2020-12-28T15:51:26Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MDIxNA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549560214", "bodyText": "The algo should get accurate calculation results. And I think there is no reason yet to relax the condition.", "author": "vagetablechicken", "createdAt": "2020-12-29T04:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTM5NTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0MzM1Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549543352", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean move_is_complete;\n          \n          \n            \n                    boolean isMoveComplete;", "author": "morningman", "createdAt": "2020-12-29T02:13:29Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,337 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * PartitionRebalancer will decrease the skew of partitions. The skew of the partition is defined as the difference\n+ * between the maximum replica count of the partition over all bes and the minimum replica count over all bes.\n+ * Only consider about the replica count for each partition, never consider the replica size(disk usage).\n+ *\n+ * We use TwoDimensionalGreedyRebalanceAlgo to get partition moves(one PartitionMove is <partition id, from be, to be>).\n+ * It prefers a move that reduce the skew of the cluster when we want to rebalance a max skew partition.\n+ *\n+ * selectAlternativeTabletsForCluster() must set the tablet id, so we need to select tablet for each move in this phase\n+ * (as TabletMove).\n+ */\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyRebalanceAlgo algo = new TwoDimensionalGreedyRebalanceAlgo();\n+\n+    private final MovesCacheMap movesCacheMap = new MovesCacheMap();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesCacheMap.MovesCache movesInProgress = movesCacheMap.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesCacheMap should have the same entry\");\n+\n+        // Iterating through Cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<TabletMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<TabletMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        // The balancing tasks of other cluster or medium might have failed. We use the upper limit value\n+        // `total num of in-progress moves` to avoid useless selections.\n+        if (movesCacheMap.size() > Config.max_balancing_tablets) {\n+            LOG.debug(\"Total in-progress moves > {}\", Config.max_balancing_tablets);\n+            return Lists.newArrayList();\n+        }\n+\n+        NavigableSet<Long> skews = clusterBalanceInfo.partitionInfoBySkew.keySet();\n+        LOG.debug(\"Cluster {}-{}: peek max skew {}, assume {} in-progress moves are succeeded {}\", clusterName, medium,\n+                skews.isEmpty() ? 0 : skews.last(), movesInProgressList.size(), movesInProgressList);\n+\n+        List<TwoDimensionalGreedyRebalanceAlgo.PartitionMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.partition_rebalance_max_moves_num_per_selection);\n+\n+        List<TabletSchedCtx> alternativeTablets = Lists.newArrayList();\n+        List<Long> inProgressIds = movesInProgressList.stream().map(m -> m.tabletId).collect(Collectors.toList());\n+        for (TwoDimensionalGreedyRebalanceAlgo.PartitionMove move : moves) {\n+            // Find all tablets of the specified partition that would have a replica at the source be,\n+            // but would not have a replica at the destination be. That is to satisfy the restriction\n+            // of having no more than one replica of the same tablet per be.\n+            List<Long> tabletIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.fromBe, medium);\n+            List<Long> invalidIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.toBe, medium);\n+            tabletIds.removeAll(invalidIds);\n+            // In-progress tablets can't be the candidate too.\n+            tabletIds.removeAll(inProgressIds);\n+\n+            Map<Long, TabletMeta> tabletCandidates = Maps.newHashMap();\n+            for (long tabletId : tabletIds) {\n+                TabletMeta tabletMeta = invertedIndex.getTabletMeta(tabletId);\n+                if (tabletMeta != null && tabletMeta.getPartitionId() == move.partitionId\n+                        && tabletMeta.getIndexId() == move.indexId) {\n+                    tabletCandidates.put(tabletId, tabletMeta);\n+                }\n+            }\n+            LOG.debug(\"Find {} candidates for move {}\", tabletCandidates.size(), move);\n+            if (tabletCandidates.isEmpty()) {\n+                continue;\n+            }\n+\n+            // Random pick one candidate to create tabletSchedCtx\n+            Random rand = new Random();\n+            Object[] keys = tabletCandidates.keySet().toArray();\n+            long pickedTabletId = (long) keys[rand.nextInt(keys.length)];\n+            LOG.debug(\"Picked tablet id for move {}: {}\", move, pickedTabletId);\n+\n+            TabletMeta tabletMeta = tabletCandidates.get(pickedTabletId);\n+            TabletSchedCtx tabletCtx = new TabletSchedCtx(TabletSchedCtx.Type.BALANCE, clusterName,\n+                    tabletMeta.getDbId(), tabletMeta.getTableId(), tabletMeta.getPartitionId(),\n+                    tabletMeta.getIndexId(), pickedTabletId, System.currentTimeMillis());\n+            // Balance task's priority is always LOW\n+            tabletCtx.setOrigPriority(TabletSchedCtx.Priority.LOW);\n+            alternativeTablets.add(tabletCtx);\n+            // Pair<Move, ToDeleteReplicaId>, ToDeleteReplicaId should be -1L before scheduled successfully\n+            movesInProgress.get().put(pickedTabletId, new Pair<>(new TabletMove(pickedTabletId, move.fromBe, move.toBe), -1L));\n+            counterBalanceMoveCreated.incrementAndGet();\n+            // Synchronize with movesInProgress\n+            inProgressIds.add(pickedTabletId);\n+        }\n+\n+        if (moves.isEmpty()) {\n+            // Balanced cluster should not print too much log messages, so we log it with level debug.\n+            LOG.debug(\"Cluster {}-{}: cluster is balanced.\", clusterName, medium);\n+        } else {\n+            LOG.info(\"Cluster {}-{}: get {} moves, actually select {} alternative tablets to move. Tablets detail: {}\",\n+                    clusterName, medium, moves.size(), alternativeTablets.size(),\n+                    alternativeTablets.stream().mapToLong(TabletSchedCtx::getTabletId).toArray());\n+        }\n+        return alternativeTablets;\n+    }\n+\n+    private boolean buildClusterInfo(ClusterLoadStatistic clusterStat, TStorageMedium medium,\n+                                     List<TabletMove> movesInProgress, ClusterBalanceInfo info, List<Long> toDeleteKeys) {\n+        Preconditions.checkState(info.beByTotalReplicaCount.isEmpty() && info.partitionInfoBySkew.isEmpty(), \"\");\n+\n+        // If we wanna modify the PartitionBalanceInfo in info.beByTotalReplicaCount, deep-copy it\n+        info.beByTotalReplicaCount.putAll(clusterStat.getBeByTotalReplicaMap(medium));\n+        info.partitionInfoBySkew.putAll(clusterStat.getSkewMap(medium));\n+\n+        // Skip the toDeleteKeys\n+        List<TabletMove> filteredMoves = movesInProgress.stream().filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+\n+        for (TabletMove move : filteredMoves) {\n+            TabletMeta meta = invertedIndex.getTabletMeta(move.tabletId);\n+            if (meta == null) {\n+                // Move's tablet is invalid, need delete it\n+                toDeleteKeys.add(move.tabletId);\n+                continue;\n+            }\n+\n+            TwoDimensionalGreedyRebalanceAlgo.PartitionMove partitionMove = new TwoDimensionalGreedyRebalanceAlgo.PartitionMove(meta.getPartitionId(), meta.getIndexId(), move.fromBe, move.toBe);\n+            boolean st = TwoDimensionalGreedyRebalanceAlgo.applyMove(partitionMove, info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (!st) {\n+                // Can't apply this move, mark it failed, continue to apply the next.\n+                toDeleteKeys.add(move.tabletId);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void checkMovesCompleted(List<TabletMove> moves, List<Long> toDeleteKeys) {\n+        boolean move_is_complete;", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NDIyMA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549544220", "bodyText": "The new replica will be added to the tablet at the beginning of clone task with state CLONE.\nAnd the \"fromBE\" replica may be dropped for other reason such as \"data broken on BE\".\nSo are you sure !bes.contains(move.fromBe) && bes.contains(move.toBe) can be treated as move complete?", "author": "morningman", "createdAt": "2020-12-29T02:18:45Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/PartitionRebalancer.java", "diffHunk": "@@ -0,0 +1,337 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Ordering;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.Replica;\n+import org.apache.doris.catalog.TabletInvertedIndex;\n+import org.apache.doris.catalog.TabletMeta;\n+import org.apache.doris.common.Config;\n+import org.apache.doris.common.Pair;\n+import org.apache.doris.system.SystemInfoService;\n+import org.apache.doris.thrift.TStorageMedium;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * PartitionRebalancer will decrease the skew of partitions. The skew of the partition is defined as the difference\n+ * between the maximum replica count of the partition over all bes and the minimum replica count over all bes.\n+ * Only consider about the replica count for each partition, never consider the replica size(disk usage).\n+ *\n+ * We use TwoDimensionalGreedyRebalanceAlgo to get partition moves(one PartitionMove is <partition id, from be, to be>).\n+ * It prefers a move that reduce the skew of the cluster when we want to rebalance a max skew partition.\n+ *\n+ * selectAlternativeTabletsForCluster() must set the tablet id, so we need to select tablet for each move in this phase\n+ * (as TabletMove).\n+ */\n+public class PartitionRebalancer extends Rebalancer {\n+    private static final Logger LOG = LogManager.getLogger(PartitionRebalancer.class);\n+\n+    private final TwoDimensionalGreedyRebalanceAlgo algo = new TwoDimensionalGreedyRebalanceAlgo();\n+\n+    private final MovesCacheMap movesCacheMap = new MovesCacheMap();\n+\n+    private final AtomicLong counterBalanceMoveCreated = new AtomicLong(0);\n+    private final AtomicLong counterBalanceMoveSucceeded = new AtomicLong(0);\n+\n+    public PartitionRebalancer(SystemInfoService infoService, TabletInvertedIndex invertedIndex) {\n+        super(infoService, invertedIndex);\n+    }\n+\n+    @Override\n+    protected List<TabletSchedCtx> selectAlternativeTabletsForCluster(\n+            String clusterName, ClusterLoadStatistic clusterStat, TStorageMedium medium) {\n+        MovesCacheMap.MovesCache movesInProgress = movesCacheMap.getCache(clusterName, medium);\n+        Preconditions.checkNotNull(movesInProgress, \"clusterStat is got from statisticMap, movesCacheMap should have the same entry\");\n+\n+        // Iterating through Cache.asMap().values() does not reset access time for the entries you retrieve.\n+        List<TabletMove> movesInProgressList = movesInProgress.get().asMap().values()\n+                .stream().map(p -> p.first).collect(Collectors.toList());\n+        List<Long> toDeleteKeys = Lists.newArrayList();\n+\n+        // The problematic movements will be found in buildClusterInfo(), so here is a simply move completion check\n+        // of moves which have valid ToDeleteReplica.\n+        List<TabletMove> movesNeedCheck = movesInProgress.get().asMap().values()\n+                .stream().filter(p -> p.second != -1L).map(p -> p.first).collect(Collectors.toList());\n+        checkMovesCompleted(movesNeedCheck, toDeleteKeys);\n+\n+        ClusterBalanceInfo clusterBalanceInfo = new ClusterBalanceInfo();\n+        // We should assume the in-progress moves have been succeeded to avoid producing the same moves.\n+        // Apply in-progress moves to current cluster stats, use TwoDimensionalGreedyAlgo.ApplyMove for simplicity.\n+        if (!buildClusterInfo(clusterStat, medium, movesInProgressList, clusterBalanceInfo, toDeleteKeys)) {\n+            return Lists.newArrayList();\n+        }\n+\n+        // Just delete the completed or problematic moves\n+        if (!toDeleteKeys.isEmpty()) {\n+            movesInProgress.get().invalidateAll(toDeleteKeys);\n+            movesInProgressList = movesInProgressList.stream()\n+                    .filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+        }\n+\n+        // The balancing tasks of other cluster or medium might have failed. We use the upper limit value\n+        // `total num of in-progress moves` to avoid useless selections.\n+        if (movesCacheMap.size() > Config.max_balancing_tablets) {\n+            LOG.debug(\"Total in-progress moves > {}\", Config.max_balancing_tablets);\n+            return Lists.newArrayList();\n+        }\n+\n+        NavigableSet<Long> skews = clusterBalanceInfo.partitionInfoBySkew.keySet();\n+        LOG.debug(\"Cluster {}-{}: peek max skew {}, assume {} in-progress moves are succeeded {}\", clusterName, medium,\n+                skews.isEmpty() ? 0 : skews.last(), movesInProgressList.size(), movesInProgressList);\n+\n+        List<TwoDimensionalGreedyRebalanceAlgo.PartitionMove> moves = algo.getNextMoves(clusterBalanceInfo, Config.partition_rebalance_max_moves_num_per_selection);\n+\n+        List<TabletSchedCtx> alternativeTablets = Lists.newArrayList();\n+        List<Long> inProgressIds = movesInProgressList.stream().map(m -> m.tabletId).collect(Collectors.toList());\n+        for (TwoDimensionalGreedyRebalanceAlgo.PartitionMove move : moves) {\n+            // Find all tablets of the specified partition that would have a replica at the source be,\n+            // but would not have a replica at the destination be. That is to satisfy the restriction\n+            // of having no more than one replica of the same tablet per be.\n+            List<Long> tabletIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.fromBe, medium);\n+            List<Long> invalidIds = invertedIndex.getTabletIdsByBackendIdAndStorageMedium(move.toBe, medium);\n+            tabletIds.removeAll(invalidIds);\n+            // In-progress tablets can't be the candidate too.\n+            tabletIds.removeAll(inProgressIds);\n+\n+            Map<Long, TabletMeta> tabletCandidates = Maps.newHashMap();\n+            for (long tabletId : tabletIds) {\n+                TabletMeta tabletMeta = invertedIndex.getTabletMeta(tabletId);\n+                if (tabletMeta != null && tabletMeta.getPartitionId() == move.partitionId\n+                        && tabletMeta.getIndexId() == move.indexId) {\n+                    tabletCandidates.put(tabletId, tabletMeta);\n+                }\n+            }\n+            LOG.debug(\"Find {} candidates for move {}\", tabletCandidates.size(), move);\n+            if (tabletCandidates.isEmpty()) {\n+                continue;\n+            }\n+\n+            // Random pick one candidate to create tabletSchedCtx\n+            Random rand = new Random();\n+            Object[] keys = tabletCandidates.keySet().toArray();\n+            long pickedTabletId = (long) keys[rand.nextInt(keys.length)];\n+            LOG.debug(\"Picked tablet id for move {}: {}\", move, pickedTabletId);\n+\n+            TabletMeta tabletMeta = tabletCandidates.get(pickedTabletId);\n+            TabletSchedCtx tabletCtx = new TabletSchedCtx(TabletSchedCtx.Type.BALANCE, clusterName,\n+                    tabletMeta.getDbId(), tabletMeta.getTableId(), tabletMeta.getPartitionId(),\n+                    tabletMeta.getIndexId(), pickedTabletId, System.currentTimeMillis());\n+            // Balance task's priority is always LOW\n+            tabletCtx.setOrigPriority(TabletSchedCtx.Priority.LOW);\n+            alternativeTablets.add(tabletCtx);\n+            // Pair<Move, ToDeleteReplicaId>, ToDeleteReplicaId should be -1L before scheduled successfully\n+            movesInProgress.get().put(pickedTabletId, new Pair<>(new TabletMove(pickedTabletId, move.fromBe, move.toBe), -1L));\n+            counterBalanceMoveCreated.incrementAndGet();\n+            // Synchronize with movesInProgress\n+            inProgressIds.add(pickedTabletId);\n+        }\n+\n+        if (moves.isEmpty()) {\n+            // Balanced cluster should not print too much log messages, so we log it with level debug.\n+            LOG.debug(\"Cluster {}-{}: cluster is balanced.\", clusterName, medium);\n+        } else {\n+            LOG.info(\"Cluster {}-{}: get {} moves, actually select {} alternative tablets to move. Tablets detail: {}\",\n+                    clusterName, medium, moves.size(), alternativeTablets.size(),\n+                    alternativeTablets.stream().mapToLong(TabletSchedCtx::getTabletId).toArray());\n+        }\n+        return alternativeTablets;\n+    }\n+\n+    private boolean buildClusterInfo(ClusterLoadStatistic clusterStat, TStorageMedium medium,\n+                                     List<TabletMove> movesInProgress, ClusterBalanceInfo info, List<Long> toDeleteKeys) {\n+        Preconditions.checkState(info.beByTotalReplicaCount.isEmpty() && info.partitionInfoBySkew.isEmpty(), \"\");\n+\n+        // If we wanna modify the PartitionBalanceInfo in info.beByTotalReplicaCount, deep-copy it\n+        info.beByTotalReplicaCount.putAll(clusterStat.getBeByTotalReplicaMap(medium));\n+        info.partitionInfoBySkew.putAll(clusterStat.getSkewMap(medium));\n+\n+        // Skip the toDeleteKeys\n+        List<TabletMove> filteredMoves = movesInProgress.stream().filter(m -> !toDeleteKeys.contains(m.tabletId)).collect(Collectors.toList());\n+\n+        for (TabletMove move : filteredMoves) {\n+            TabletMeta meta = invertedIndex.getTabletMeta(move.tabletId);\n+            if (meta == null) {\n+                // Move's tablet is invalid, need delete it\n+                toDeleteKeys.add(move.tabletId);\n+                continue;\n+            }\n+\n+            TwoDimensionalGreedyRebalanceAlgo.PartitionMove partitionMove = new TwoDimensionalGreedyRebalanceAlgo.PartitionMove(meta.getPartitionId(), meta.getIndexId(), move.fromBe, move.toBe);\n+            boolean st = TwoDimensionalGreedyRebalanceAlgo.applyMove(partitionMove, info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (!st) {\n+                // Can't apply this move, mark it failed, continue to apply the next.\n+                toDeleteKeys.add(move.tabletId);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void checkMovesCompleted(List<TabletMove> moves, List<Long> toDeleteKeys) {\n+        boolean move_is_complete;\n+        for (TabletMove move : moves) {\n+            move_is_complete = checkMoveCompleted(move);\n+            // If the move was completed, remove it\n+            if (move_is_complete) {\n+                toDeleteKeys.add(move.tabletId);\n+                LOG.debug(\"Move {} is completed. The cur dist: {}\", move,\n+                        invertedIndex.getReplicasByTabletId(move.tabletId).stream().map(Replica::getBackendId).collect(Collectors.toList()));\n+                counterBalanceMoveSucceeded.incrementAndGet();\n+            }\n+        }\n+    }\n+\n+    // Move completed: fromBe doesn't have a replica and toBe has a replica\n+    private boolean checkMoveCompleted(TabletMove move) {", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTA5NA==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549561094", "bodyText": "It's hard to define, but when !bes.contains(move.fromBe) && bes.contains(move.toBe), the move is useless. So why not to treat it as completed.", "author": "vagetablechicken", "createdAt": "2020-12-29T04:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0NDIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1Mzk1Nw==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549553957", "bodyText": "debug is better?", "author": "morningman", "createdAt": "2020-12-29T03:21:48Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {\n+            return null;\n+        }\n+\n+        // Among the partitions with maximum skew, attempt to pick a partition where there is\n+        // a move that improves the partition skew and the cluster skew, if possible. If\n+        // not, attempt to pick a move that improves the partition skew. If all partitions\n+        // are balanced, attempt to pick a move that preserves partition balance and\n+        // improves cluster skew.\n+        NavigableSet<PartitionBalanceInfo> maxSet = skewMap.get(maxPartitionSkew);\n+        for (PartitionBalanceInfo pbi : maxSet) {\n+            Preconditions.checkArgument(!pbi.beByReplicaCount.isEmpty(), \"no information on replicas of \" +\n+                    \"partition \" + pbi.partitionId + \"-\" + pbi.indexId);\n+\n+            Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n+            Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n+            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NDIxMg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549554212", "bodyText": "debug", "author": "morningman", "createdAt": "2020-12-29T03:23:40Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {\n+            return null;\n+        }\n+\n+        // Among the partitions with maximum skew, attempt to pick a partition where there is\n+        // a move that improves the partition skew and the cluster skew, if possible. If\n+        // not, attempt to pick a move that improves the partition skew. If all partitions\n+        // are balanced, attempt to pick a move that preserves partition balance and\n+        // improves cluster skew.\n+        NavigableSet<PartitionBalanceInfo> maxSet = skewMap.get(maxPartitionSkew);\n+        for (PartitionBalanceInfo pbi : maxSet) {\n+            Preconditions.checkArgument(!pbi.beByReplicaCount.isEmpty(), \"no information on replicas of \" +\n+                    \"partition \" + pbi.partitionId + \"-\" + pbi.indexId);\n+\n+            Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n+            Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n+            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+                    pbi.partitionId, pbi.indexId, maxPartitionSkew,\n+                    minReplicaCount, maxReplicaCount);\n+\n+            // Compute the intersection of the bes most loaded for the table\n+            // with the bes most loaded overall, and likewise for least loaded.\n+            // These are our ideal candidates for moving from and to, respectively.\n+            IntersectionResult maxLoaded = getIntersection(ExtremumType.MAX, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            IntersectionResult minLoaded = getIntersection(ExtremumType.MIN, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            LOG.info(\"partition-wise: min_count: {}, max_count: {}\", minLoaded.replicaCountPartition, maxLoaded.replicaCountPartition);", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NDgxNQ==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549554815", "bodyText": "If we use PICK_FIRST, in the case of fewer candidate sets, will there be a high probability of the same?", "author": "morningman", "createdAt": "2020-12-29T03:27:17Z", "path": "fe/fe-core/src/main/java/org/apache/doris/clone/TwoDimensionalGreedyRebalanceAlgo.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+package org.apache.doris.clone;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.TreeMultimap;\n+import org.apache.doris.catalog.TabletInvertedIndex.PartitionBalanceInfo;\n+import org.apache.doris.clone.PartitionRebalancer.ClusterBalanceInfo;\n+import org.apache.doris.common.Pair;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.NavigableSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/*\n+ * A two-dimensional greedy rebalancing algorithm. The two dims are cluster and partition. It'll generate multiple `PartitionMove`,\n+ * only decide which partition to move, fromBe, toBe. The next step is to select a tablet to move.\n+ *\n+ * From among moves that decrease the skew of a most skewed partition, it prefers ones that reduce the skew of the cluster.\n+ * A cluster is considered balanced when the skew of every partition is <= 1 and the skew of the cluster is <= 1.\n+ * The skew of the cluster is defined as the difference between the maximum total replica count over all bes and the\n+ * minimum total replica count over all bes.\n+ *\n+ * This class is modified from kudu TwoDimensionalGreedyAlgo.\n+ */\n+public class TwoDimensionalGreedyRebalanceAlgo {\n+    private static final Logger LOG = LogManager.getLogger(TwoDimensionalGreedyRebalanceAlgo.class);\n+\n+    private final EqualSkewOption equalSkewOption;\n+    private static final Random rand = new Random(System.currentTimeMillis());\n+\n+    public static class PartitionMove {\n+        Long partitionId;\n+        Long indexId;\n+        Long fromBe;\n+        Long toBe;\n+\n+        PartitionMove(Long p, Long i, Long f, Long t) {\n+            this.partitionId = p;\n+            this.indexId = i;\n+            this.fromBe = f;\n+            this.toBe = t;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            PartitionMove that = (PartitionMove) o;\n+            return Objects.equal(partitionId, that.partitionId) &&\n+                    Objects.equal(indexId, that.indexId) &&\n+                    Objects.equal(fromBe, that.fromBe) &&\n+                    Objects.equal(toBe, that.toBe);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(partitionId, indexId, fromBe, toBe);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"ReplicaMove{\" +\n+                    \"pid=\" + partitionId + \"-\" + indexId +\n+                    \", from=\" + fromBe +\n+                    \", to=\" + toBe +\n+                    '}';\n+        }\n+    }\n+\n+    public enum EqualSkewOption {\n+        // generally only be used on unit test\n+        PICK_FIRST,\n+        PICK_RANDOM\n+    }\n+\n+    public enum ExtremumType {\n+        MAX,\n+        MIN\n+    }\n+\n+    public static class IntersectionResult {\n+        Long replicaCountPartition;\n+        Long replicaCountTotal;\n+        List<Long> beWithExtremumCount;\n+        List<Long> intersection;\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo() {\n+        this(EqualSkewOption.PICK_RANDOM);\n+    }\n+\n+    TwoDimensionalGreedyRebalanceAlgo(EqualSkewOption equalSkewOption) {\n+        this.equalSkewOption = equalSkewOption;\n+    }\n+\n+    // maxMovesNum: Value of '0' is a shortcut for 'the possible maximum'.\n+    // May modify the ClusterBalanceInfo\n+    public List<PartitionMove> getNextMoves(ClusterBalanceInfo info, int maxMovesNum) {\n+        Preconditions.checkArgument(maxMovesNum >= 0);\n+        if (maxMovesNum == 0) {\n+            maxMovesNum = Integer.MAX_VALUE;\n+        }\n+\n+        if (info.partitionInfoBySkew.isEmpty()) {\n+            // Check for the consistency of the 'ClusterBalanceInfo' parameter: if no information is given on\n+            // the partition skew, partition count for all the be should be 0.\n+            // Keys are ordered by the natural ordering, so we can get the last(max) key to know if all keys are 0.\n+            NavigableSet<Long> keySet = info.beByTotalReplicaCount.keySet();\n+            LOG.debug(keySet);\n+            Preconditions.checkState(keySet.isEmpty() || keySet.last() == 0L,\n+                    \"non-zero replica count on be while no partition skew information in skewMap\");\n+            // Nothing to balance: cluster is empty.\n+            return Lists.newArrayList();\n+        }\n+\n+        List<PartitionMove> moves = Lists.newArrayList();\n+        for (int i = 0; i < maxMovesNum; ++i) {\n+            PartitionMove move = getNextMove(info.beByTotalReplicaCount, info.partitionInfoBySkew);\n+            if (move == null || !(applyMove(move, info.beByTotalReplicaCount, info.partitionInfoBySkew))) {\n+                // 1. No replicas to move.\n+                // 2. Apply to info failed, it's useless to get next move from the same info.\n+                break;\n+            }\n+            moves.add(move);\n+        }\n+\n+        return moves;\n+    }\n+\n+    private PartitionMove getNextMove(TreeMultimap<Long, Long> beByTotalReplicaCount,\n+                                      TreeMultimap<Long, PartitionBalanceInfo> skewMap) {\n+        PartitionMove move = null;\n+        if (skewMap.isEmpty() || beByTotalReplicaCount.isEmpty()) {\n+            return null;\n+        }\n+        long maxPartitionSkew = skewMap.keySet().last();\n+        long maxBeSkew = beByTotalReplicaCount.keySet().last() - beByTotalReplicaCount.keySet().first();\n+\n+        // 1. Every partition is balanced(maxPartitionSkew<=1) and any move will unbalance a partition, so there\n+        // is no potential for the greedy algorithm to balance the cluster.\n+        // 2. Every partition is balanced(maxPartitionSkew<=1) and the cluster as a whole is balanced(maxBeSkew<=1).\n+        if (maxPartitionSkew == 0L || (maxPartitionSkew <= 1L && maxBeSkew <= 1L)) {\n+            return null;\n+        }\n+\n+        // Among the partitions with maximum skew, attempt to pick a partition where there is\n+        // a move that improves the partition skew and the cluster skew, if possible. If\n+        // not, attempt to pick a move that improves the partition skew. If all partitions\n+        // are balanced, attempt to pick a move that preserves partition balance and\n+        // improves cluster skew.\n+        NavigableSet<PartitionBalanceInfo> maxSet = skewMap.get(maxPartitionSkew);\n+        for (PartitionBalanceInfo pbi : maxSet) {\n+            Preconditions.checkArgument(!pbi.beByReplicaCount.isEmpty(), \"no information on replicas of \" +\n+                    \"partition \" + pbi.partitionId + \"-\" + pbi.indexId);\n+\n+            Long minReplicaCount = pbi.beByReplicaCount.keySet().first();\n+            Long maxReplicaCount = pbi.beByReplicaCount.keySet().last();\n+            LOG.info(\"balancing partition {}-{} with replica count skew {} (min_replica_count: {}, max_replica_count: {})\",\n+                    pbi.partitionId, pbi.indexId, maxPartitionSkew,\n+                    minReplicaCount, maxReplicaCount);\n+\n+            // Compute the intersection of the bes most loaded for the table\n+            // with the bes most loaded overall, and likewise for least loaded.\n+            // These are our ideal candidates for moving from and to, respectively.\n+            IntersectionResult maxLoaded = getIntersection(ExtremumType.MAX, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            IntersectionResult minLoaded = getIntersection(ExtremumType.MIN, pbi.beByReplicaCount, beByTotalReplicaCount);\n+            LOG.info(\"partition-wise: min_count: {}, max_count: {}\", minLoaded.replicaCountPartition, maxLoaded.replicaCountPartition);\n+            LOG.info(\"cluster-wise: min_count: {}, max_count: {}\", minLoaded.replicaCountTotal, maxLoaded.replicaCountTotal);\n+            LOG.debug(\"min_loaded_intersection: {}, max_loaded_intersection: {}\", minLoaded.intersection.toString(), maxLoaded.intersection.toString());\n+\n+            // Do not move replicas of a balanced table if the least (most) loaded\n+            // servers overall do not intersect the servers hosting the least (most)\n+            // replicas of the table. Moving a replica in that case might keep the\n+            // cluster skew the same or make it worse while keeping the table balanced.\n+            if ((maxLoaded.replicaCountPartition <= minLoaded.replicaCountPartition + 1)\n+                    && (minLoaded.intersection.isEmpty() || maxLoaded.intersection.isEmpty())) {\n+                continue;\n+            }\n+\n+            Long minLoadedBe, maxLoadedBe;\n+            if (equalSkewOption == EqualSkewOption.PICK_FIRST) {\n+                // beWithExtremumCount lists & intersection lists are natural ordering\n+                minLoadedBe = minLoaded.intersection.isEmpty() ? minLoaded.beWithExtremumCount.get(0) : minLoaded.intersection.get(0);\n+                maxLoadedBe = maxLoaded.intersection.isEmpty() ? maxLoaded.beWithExtremumCount.get(0) : maxLoaded.intersection.get(0);\n+            } else {\n+                minLoadedBe = minLoaded.intersection.isEmpty() ? getRandomListElement(minLoaded.beWithExtremumCount)\n+                        : getRandomListElement(minLoaded.intersection);\n+                maxLoadedBe = maxLoaded.intersection.isEmpty() ? getRandomListElement(maxLoaded.beWithExtremumCount)\n+                        : getRandomListElement(maxLoaded.intersection);\n+            }\n+\n+            LOG.debug(\"min_loaded_be: {}, max_loaded_be: {}\", minLoadedBe, maxLoadedBe);\n+            if (minLoadedBe.equals(maxLoadedBe)) {", "originalCommit": "5ef852d3a8ba19a2de2819066fb89addca6db4a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2MTI4Mg==", "url": "https://github.com/apache/incubator-doris/pull/5010#discussion_r549561282", "bodyText": "Now, we only use PICK_FIRST in UTs, to get the results that can be expected.", "author": "vagetablechicken", "createdAt": "2020-12-29T04:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1NDgxNQ=="}], "type": "inlineReview"}, {"oid": "29e790c06c46566f6c36730f6a536b4d165a07f3", "url": "https://github.com/apache/incubator-doris/commit/29e790c06c46566f6c36730f6a536b4d165a07f3", "message": "[] fix by review", "committedDate": "2020-12-29T04:13:06Z", "type": "commit"}]}