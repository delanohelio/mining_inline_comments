{"pr_number": 6543, "pr_title": "Add Crop functionality", "pr_createdAt": "2020-06-24T00:34:04Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6543", "timeline": [{"oid": "2d87143d313abe52b7efff2cf73c31a4a8ab9cba", "url": "https://github.com/ankidroid/Anki-Android/commit/2d87143d313abe52b7efff2cf73c31a4a8ab9cba", "message": "Prompt user to crop on image edit return if images is large", "committedDate": "2020-06-24T00:42:07Z", "type": "forcePushed"}, {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22", "url": "https://github.com/ankidroid/Anki-Android/commit/a4500eda080fb2956f8c0f17b3548d863496ad22", "message": "Prompt user to crop on image edit return if images is large", "committedDate": "2020-06-24T00:47:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4ODQzNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444588434", "bodyText": "Could you add a comment/reword with the units? Presumably Bytes", "author": "david-allison-1", "createdAt": "2020-06-24T01:06:00Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -65,6 +70,8 @@\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n     private static final int REQUEST_CAMERA_PERMISSION = 1;\n \n+    public static final int sImageLimit = 1024 * 1024;", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTA3OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589078", "bodyText": "Still unresolved in my UI - GitHub lag", "author": "david-allison-1", "createdAt": "2020-06-28T02:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4ODQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MDIzNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444590236", "bodyText": "Maybe go with Formatter.formatShortFileSize.\nYou could bring the format string inside the resource.", "author": "david-allison-1", "createdAt": "2020-06-24T01:13:12Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -379,6 +383,30 @@ public void handleFieldChanged(IField newField) {\n         recreateEditingUi(ChangeUIRequest.fieldChange(newField));\n     }\n \n+    public void showLargeFileCropDialog(float length) {\n+        BasicImageFieldController imageFieldController = (BasicImageFieldController) mFieldController;\n+        File file = new File(mField.getImagePath());\n+        Uri uri = FileProvider.getUriForFile(this, this.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        DecimalFormat decimalFormat = new DecimalFormat(\".00\");\n+        String size = decimalFormat.format(length);\n+        String content = getString(R.string.save_dialog_content, size);", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MjExMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444592112", "bodyText": "Could a sample path be provided here? Probably on me to better understand filepaths.xml", "author": "david-allison-1", "createdAt": "2020-06-24T01:20:48Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -71,16 +78,22 @@\n     @VisibleForTesting\n     static final int ACTIVITY_SELECT_IMAGE = 1;\n     private static final int ACTIVITY_TAKE_PICTURE = 2;\n+    private static final int ACTIVITY_CROP_PICTURE = 3;\n     private static final int IMAGE_SAVE_MAX_WIDTH = 1920;\n \n     private ImageView mImagePreview;\n     private TextView mImageFileSize;\n     private TextView mImageFileSizeWarning;\n \n-    private String mTempCameraImagePath;\n+    private @Nullable String mImagePath;\n+    private @Nullable Uri mImageUri;\n+    private @Nullable String mPreviousImagePath; // save the latest path to prevent from cropping or taking photo action canceled\n+    private @Nullable Uri mPreviousImageUri;\n+    private @Nullable String mAnkiCacheDirectory;", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNDY0NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445924645", "bodyText": "Sure, helps with verification, added this in code but pasting here for memory:                                                   // e.g.  '/self/primary/Android/data/com.ichi2.anki.AnkiDroid/cache/'", "author": "mikehardy", "createdAt": "2020-06-26T01:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MjExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MzI2Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444593267", "bodyText": "(optional) surprised there's not an override for showThemedToast which expects a @StringRes", "author": "david-allison-1", "createdAt": "2020-06-24T01:25:29Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5NDIwNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444594204", "bodyText": "Interesting... looks like it'll also have application in the import screen. Any reference for how this code came to fruition?\nLooks like: https://stackoverflow.com/a/44172185/13121290\nI suspect this may be device manufacturer specific.", "author": "david-allison-1", "createdAt": "2020-06-24T01:29:21Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNDc1MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445924751", "bodyText": "Dealing with camera and gallery storage is super API- and device-specific", "author": "mikehardy", "createdAt": "2020-06-26T01:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5NDIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNDg3OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445924878", "bodyText": "@NightXlt may have more information on where the code came from, I'm not going to touch this part personally", "author": "mikehardy", "createdAt": "2020-06-26T01:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5NDIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODU3Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444598573", "bodyText": "Has this path been exercised on a later API? I know there were changes to the way file:// data could be accessed", "author": "david-allison-1", "createdAt": "2020-06-24T01:46:12Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTE2MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445925161", "bodyText": "Lots of changes - I exercised all the functions on later APIs, but I'm not sure if every case was hit. It should be that on later APIs people are providing files via content provider so this is not actually hit, but I'm not sure?", "author": "mikehardy", "createdAt": "2020-06-26T01:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNzUzOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446127538", "bodyText": "From my understanding: yes and no. they should, but I think a user using an old file browser on a later API can still trigger a crash on this path (or sometimes using the file path in a content provider, but we check this path already).\nMight just be best to confirm that exchanging these paths for a throw will send an exception report and won't crash the app.\nWhere's the can of worms emoji?", "author": "david-allison-1", "createdAt": "2020-06-26T11:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODgxNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444598817", "bodyText": "should be in a finally block", "author": "david-allison-1", "createdAt": "2020-06-24T01:47:18Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();\n+        }\n+\n+        return imagePath;\n     }\n \n+\n+    /**\n+     * Get image path based on uri and selection args\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable String getImagePathFromContentResolver(Context context, Uri uri, String selection) {\n+        Timber.d(\"getImagePathFromContentResolver() %s\", uri);\n+        String[] filePathColumn = { MediaStore.MediaColumns.DATA };\n+        Cursor cursor = context.getContentResolver().query(uri, filePathColumn, selection, null, null);\n+\n+        if (cursor == null) {\n+            Timber.w(\"getImagePathFromUri() cursor was null\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        if (!cursor.moveToFirst()) {\n+            //TODO: #5909, it would be best to instrument this to see if we can fix the failure\n+            Timber.w(\"getImagePathFromUri() cursor had no data\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\n+        String path = cursor.getString(columnIndex);\n+        cursor.close();", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTc3MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445925771", "bodyText": "You would think so, but nothing in there throws, and it was not in finally in your previous method that I extracted :-) \n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java\n    \n    \n         Line 287\n      in\n      747d16e\n    \n    \n    \n    \n\n        \n          \n           cursor.close();", "author": "mikehardy", "createdAt": "2020-06-26T01:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNzk5Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446127996", "bodyText": "I knew my (bad) code when I saw it (thanks!)", "author": "david-allison-1", "createdAt": "2020-06-26T11:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwMzk4NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444603985", "bodyText": "can clipData be used here?", "author": "david-allison-1", "createdAt": "2020-06-24T02:07:34Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();", "originalCommit": "a4500eda080fb2956f8c0f17b3548d863496ad22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNjg1Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445926852", "bodyText": "I don't believe so, and in your previous time through here I don't think you did either - it's only for image picks which don't have anything to do with clipboard\nThe previous incarnation just called getData() and that was it \n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java\n    \n    \n         Line 260\n      in\n      747d16e\n    \n    \n    \n    \n\n        \n          \n           Uri selectedImage = data.getData(); \n        \n    \n  \n\n\nThis incarnation just does a few more things because there is internal state to keep coherent", "author": "mikehardy", "createdAt": "2020-06-26T01:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwMzk4NQ=="}], "type": "inlineReview"}, {"oid": "a0c9f2a00b90e39687703e955c2124842494b689", "url": "https://github.com/ankidroid/Anki-Android/commit/a0c9f2a00b90e39687703e955c2124842494b689", "message": "Image crop feedback: JPG compress, \"No\" in dialogs, add comments", "committedDate": "2020-06-26T03:46:16Z", "type": "forcePushed"}, {"oid": "34982097c48c1c78d495e058cb169534cab124ff", "url": "https://github.com/ankidroid/Anki-Android/commit/34982097c48c1c78d495e058cb169534cab124ff", "message": "NF: remove API15 remnants now that minSdkVersion is 16", "committedDate": "2020-06-26T21:57:50Z", "type": "commit"}, {"oid": "22521e3f79e00bdb4c2755912d4f6eee85216f54", "url": "https://github.com/ankidroid/Anki-Android/commit/22521e3f79e00bdb4c2755912d4f6eee85216f54", "message": "NF: extract saveAndExit from MultimediaEditFieldActivity", "committedDate": "2020-06-26T21:57:50Z", "type": "commit"}, {"oid": "409ee8012cb35157df857665cee68a0bdd97281c", "url": "https://github.com/ankidroid/Anki-Android/commit/409ee8012cb35157df857665cee68a0bdd97281c", "message": "NF: path variables, extract createNewFile/handleTakePictureResult\n\nalso improve error handling in rotateAndCompress\nstart setting up for handling crop results", "committedDate": "2020-06-26T21:57:50Z", "type": "commit"}, {"oid": "44426e5001ae0cfa20115b377212a372bdfff2bf", "url": "https://github.com/ankidroid/Anki-Android/commit/44426e5001ae0cfa20115b377212a372bdfff2bf", "message": "Extract file path / URI conversions, make work across all APIs", "committedDate": "2020-06-26T21:57:51Z", "type": "commit"}, {"oid": "bc4d457e79762ecbe80cce638c596408a91ad4c7", "url": "https://github.com/ankidroid/Anki-Android/commit/bc4d457e79762ecbe80cce638c596408a91ad4c7", "message": "Add ability to crop image on user request and camera result return", "committedDate": "2020-06-26T21:57:51Z", "type": "commit"}, {"oid": "b2dd84d49e03e6edc4424cbb330a411da991a937", "url": "https://github.com/ankidroid/Anki-Android/commit/b2dd84d49e03e6edc4424cbb330a411da991a937", "message": "Prompt user to crop on image edit return if images is large", "committedDate": "2020-06-26T21:57:52Z", "type": "commit"}, {"oid": "e11ce6afbada4f07cbeed00235d080c11a620371", "url": "https://github.com/ankidroid/Anki-Android/commit/e11ce6afbada4f07cbeed00235d080c11a620371", "message": "Image crop feedback: JPG compress, \"No\" in dialogs, add comments", "committedDate": "2020-06-26T21:57:52Z", "type": "commit"}, {"oid": "1f9c811ca8687f2ea8a608230deb6faca05db196", "url": "https://github.com/ankidroid/Anki-Android/commit/1f9c811ca8687f2ea8a608230deb6faca05db196", "message": "Only consider RESULT_OK as a positive image edit result", "committedDate": "2020-06-27T04:11:05Z", "type": "commit"}, {"oid": "a0791bf786653f93450af4728d2ef7fc956b04f8", "url": "https://github.com/ankidroid/Anki-Android/commit/a0791bf786653f93450af4728d2ef7fc956b04f8", "message": "Add Activity restart support to multimedia edit, implement for Image", "committedDate": "2020-06-27T04:11:49Z", "type": "commit"}, {"oid": "a0791bf786653f93450af4728d2ef7fc956b04f8", "url": "https://github.com/ankidroid/Anki-Android/commit/a0791bf786653f93450af4728d2ef7fc956b04f8", "message": "Add Activity restart support to multimedia edit, implement for Image", "committedDate": "2020-06-27T04:11:49Z", "type": "forcePushed"}, {"oid": "2d847f1b4dac8947bb28378d9bd3686f2853bcbe", "url": "https://github.com/ankidroid/Anki-Android/commit/2d847f1b4dac8947bb28378d9bd3686f2853bcbe", "message": "Refactor crop dialog so one definition is reusable", "committedDate": "2020-06-27T23:38:17Z", "type": "commit"}, {"oid": "3586444b0632e039325f261270de690794016b33", "url": "https://github.com/ankidroid/Anki-Android/commit/3586444b0632e039325f261270de690794016b33", "message": "NF: add annotations from super to subclass compat copy methods", "committedDate": "2020-06-27T23:57:49Z", "type": "commit"}, {"oid": "1978f47b29bb15d74ba04bd944abfa743b1c0a61", "url": "https://github.com/ankidroid/Anki-Android/commit/1978f47b29bb15d74ba04bd944abfa743b1c0a61", "message": "Improve messaging on unexpected crop results", "committedDate": "2020-06-28T00:00:16Z", "type": "commit"}, {"oid": "7500e85287bfc50f9181db4dc4998e00e3bbc611", "url": "https://github.com/ankidroid/Anki-Android/commit/7500e85287bfc50f9181db4dc4998e00e3bbc611", "message": "Improve image editor file handling\n\npreviously we would lose track of previous images and not\nclean up after ourselves, plus the temporary images were not\nsegregated from other things", "committedDate": "2020-06-28T00:09:51Z", "type": "commit"}, {"oid": "ba7feb4559cba01c503549c8c5cab84f2160e9ae", "url": "https://github.com/ankidroid/Anki-Android/commit/ba7feb4559cba01c503549c8c5cab84f2160e9ae", "message": "Improve error-handling in image edit on activity starts", "committedDate": "2020-06-28T00:11:20Z", "type": "commit"}, {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619", "url": "https://github.com/ankidroid/Anki-Android/commit/8756fd41ee44b8572d81e1c85851ae9519047619", "message": "Image edit can internalize ephemeral files now\n\nOn picking a file now we get the display name and path from\nthe content resolver\n\nWe use the display name in order to generate an appropriate internal\nfile name, then we internalize the content resolver contents", "committedDate": "2020-06-28T00:13:00Z", "type": "commit"}, {"oid": "b146e9ec31a35849bee24dd88f2f70c4728a2997", "url": "https://github.com/ankidroid/Anki-Android/commit/b146e9ec31a35849bee24dd88f2f70c4728a2997", "message": "Fix incorrect change to URI generation on API<N", "committedDate": "2020-06-28T00:27:59Z", "type": "commit"}, {"oid": "c1c87a6518a88cb3a42f530f57d60a3afad63294", "url": "https://github.com/ankidroid/Anki-Android/commit/c1c87a6518a88cb3a42f530f57d60a3afad63294", "message": "Use FileProvider-correct test for image test", "committedDate": "2020-06-28T00:45:13Z", "type": "commit"}, {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac", "url": "https://github.com/ankidroid/Anki-Android/commit/408192ff445fa2f08a0019df11a2fa7cfd820eac", "message": "Fully restore previous image on unsuccessful image edit\n\nthis prevents the original image from being cleaned up now that\nwe work harder on cleaning up old images", "committedDate": "2020-06-28T01:02:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTE3MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589170", "bodyText": "Consider promoting to Timber.i", "author": "david-allison-1", "createdAt": "2020-06-28T02:03:06Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -80,9 +88,13 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n+        Bundle controllerBundle = null;\n         if (savedInstanceState != null) {\n+            Timber.d(\"onCreate - saved bundle exists\");", "originalCommit": "408192ff445fa2f08a0019df11a2fa7cfd820eac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTM1Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589352", "bodyText": "Likely as the functionality isn't implemented in the controllers", "author": "david-allison-1", "createdAt": "2020-06-28T02:05:33Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -379,22 +393,49 @@ public void handleFieldChanged(IField newField) {\n         recreateEditingUi(ChangeUIRequest.fieldChange(newField));\n     }\n \n+    public void showLargeFileCropDialog(float length) {\n+        BasicImageFieldController imageFieldController = (BasicImageFieldController) mFieldController;\n+        DecimalFormat decimalFormat = new DecimalFormat(\".00\");\n+        String size = decimalFormat.format(length);\n+        String content = getString(R.string.save_dialog_content, size);\n+        imageFieldController.showCropDialog(content, (dialog, which) -> saveAndExit());\n+    }\n+\n+\n+    private void saveAndExit() {\n+        Intent resultData = new Intent();\n+        resultData.putExtra(EXTRA_RESULT_FIELD, mField);\n+        resultData.putExtra(EXTRA_RESULT_FIELD_INDEX, mFieldIndex);\n+        setResult(RESULT_OK, resultData);\n+        finishWithoutAnimation();\n+    }\n \n     @Override\n     protected void onDestroy() {\n-        super.onDestroy();\n-\n         if (mFieldController != null) {\n             mFieldController.onDestroy();\n         }\n-\n+        super.onDestroy();\n     }\n \n \n     @Override\n     protected void onSaveInstanceState(Bundle outState) {\n-        super.onSaveInstanceState(outState);\n+        Timber.d(\"onSaveInstanceState - saving state\");\n+\n+        // This is used to tell the whole activity to shut down if it is restored from Activity restart.\n+        // Why? I am not really sure. Perhaps to avoid terrible bugs due to not implementing things correctly?", "originalCommit": "408192ff445fa2f08a0019df11a2fa7cfd820eac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTUwOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589508", "bodyText": "Could you mention the method which is problematic", "author": "david-allison-1", "createdAt": "2020-06-28T02:07:50Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -91,16 +108,65 @@ private int getMaxImageSize() {\n         return (int) Math.min(height * 0.4, width * 0.6);\n     }\n \n-    // The NewApi deprecation should be removed with API21. UnsupportedChromeOsCameraSystemFeature can be fixed in API16\n-    @SuppressLint( {\"UnsupportedChromeOsCameraSystemFeature\", \"NewApi\"})\n+    public void loadInstanceState(Bundle savedInstanceState) {\n+        if (savedInstanceState == null) {\n+            Timber.d(\"loadInstanceState but null so nothing to load\");\n+            return;\n+        }\n+\n+        Timber.d(\"loadInstanceState loading saved state...\");\n+        mImagePath = savedInstanceState.getString(\"mImagePath\");\n+        mImageUri = savedInstanceState.getParcelable(\"mImageUri\");\n+        mPreviousImagePath = savedInstanceState.getString(\"mPreviousImagePath\");\n+        mPreviousImageUri = savedInstanceState.getParcelable(\"mPreviousImageUri\");\n+    }\n+\n+    public Bundle saveInstanceState() {\n+        Timber.d(\"saveInstanceState\");\n+        Bundle savedInstanceState = new Bundle();\n+        savedInstanceState.putString(\"mImagePath\", mImagePath);\n+        savedInstanceState.putParcelable(\"mImageUri\", mImageUri);\n+        savedInstanceState.putString(\"mPreviousImagePath\", mPreviousImagePath);\n+        savedInstanceState.putParcelable(\"mPreviousImageUri\", mPreviousImageUri);\n+        return savedInstanceState;\n+    }\n+\n+    // The NewApi deprecation should be removed with API21\n+    @SuppressLint(\"NewApi\")", "originalCommit": "408192ff445fa2f08a0019df11a2fa7cfd820eac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2MjIzMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446662233", "bodyText": "I will experiment with getting rid of it, previously the code directly accessed camera API v2 which would cause an Error throw + crash on API<=21 but I moved that into the Compat infrastructure on some previous pass (where it has a NewApi suppress also) and I don't think the suppress is needed here any longer.", "author": "mikehardy", "createdAt": "2020-06-28T15:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MDU4NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446590585", "bodyText": "Use >= here. The pattern is to continually add 1 for different user-defined results.", "author": "david-allison-1", "createdAt": "2020-06-28T02:24:39Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -289,6 +289,11 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {\n                 default:\n                     break;\n             }\n+\n+            // Some apps send this back with app-specific data, direct the user to another app\n+            if (resultCode == Activity.RESULT_FIRST_USER) {", "originalCommit": "1978f47b29bb15d74ba04bd944abfa743b1c0a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2MjY0Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446662647", "bodyText": "Nice, thanks", "author": "mikehardy", "createdAt": "2020-06-28T15:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTA3NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446591075", "bodyText": "(Optional): Might be worth turning the return value into a class. Each time I see the array access, I presume there's a potential indexing bug", "author": "david-allison-1", "createdAt": "2020-06-28T02:32:20Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {", "originalCommit": "8756fd41ee44b8572d81e1c85851ae9519047619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2NDA3OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446664078", "bodyText": "I made it into a @NonNull Pair<String, String> where the strings are explicitly mentioned in javadoc as being potentially null but the Pair will always be non-null, so it's pretty easy to safely work with", "author": "mikehardy", "createdAt": "2020-06-28T15:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTA3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTE1Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446591157", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            imageInfo= getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n          \n          \n            \n                            imageInfo = getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);", "author": "david-allison-1", "createdAt": "2020-06-28T02:33:52Z", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {\n         Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n-        String imagePath = null;\n+        String[] imageInfo = { null, null };\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n             String docId = DocumentsContract.getDocumentId(uri);\n             if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n                 String id = docId.split(\":\")[1];\n                 String selection = MediaStore.Images.Media._ID + \"=\" + id;\n-                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+                imageInfo= getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);", "originalCommit": "8756fd41ee44b8572d81e1c85851ae9519047619", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2NDEzOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446664138", "bodyText": "Yep, there were some unused imports from codacy as well, cleaned those up", "author": "mikehardy", "createdAt": "2020-06-28T15:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTE1Nw=="}], "type": "inlineReview"}, {"oid": "f253f18c726bd0d009558747e0d292d2a4323b90", "url": "https://github.com/ankidroid/Anki-Android/commit/f253f18c726bd0d009558747e0d292d2a4323b90", "message": "NF: image editor re-categorize logging, clean imports, remove @Suppress", "committedDate": "2020-06-28T15:30:54Z", "type": "commit"}, {"oid": "30fa233aef475ef80b82de17bcab5926323bb001", "url": "https://github.com/ankidroid/Anki-Android/commit/30fa233aef475ef80b82de17bcab5926323bb001", "message": "Image controller should treat all errors >= 1 as non-success", "committedDate": "2020-06-28T15:31:46Z", "type": "commit"}, {"oid": "2e1f5eaaa5211ff9cb4ffe69d8b262135da34686", "url": "https://github.com/ankidroid/Anki-Android/commit/2e1f5eaaa5211ff9cb4ffe69d8b262135da34686", "message": "URI path/name resolution typed more strongly\n\nArrays are convenient for the same reason they are dangerous, using\na Pair in place makes it impossible to have anything other than 2\nelements, which was the prior intention", "committedDate": "2020-06-28T15:33:02Z", "type": "commit"}, {"oid": "0281280786fb83f738fd8b06913377c2153a4237", "url": "https://github.com/ankidroid/Anki-Android/commit/0281280786fb83f738fd8b06913377c2153a4237", "message": "NF: extract image revert handling (save, revert, delete) methods", "committedDate": "2020-06-28T16:32:14Z", "type": "commit"}, {"oid": "a4746f0e3db5b1f3f7b260a62e7abdfeeb9fcadb", "url": "https://github.com/ankidroid/Anki-Android/commit/a4746f0e3db5b1f3f7b260a62e7abdfeeb9fcadb", "message": "Image picker should be restricted to images only", "committedDate": "2020-06-28T16:32:48Z", "type": "commit"}, {"oid": "2da041f236e2938d0b9edbabe14f41345391d4f4", "url": "https://github.com/ankidroid/Anki-Android/commit/2da041f236e2938d0b9edbabe14f41345391d4f4", "message": "Image rotate and compress detects bad images, callers handle it\n\nThis is where the Bitmap.decode happens, so it can provide useful signal\nin case something about the image crop or camera selection resulted in\na bad image\n\ncombined with image picker clamped to actual images, we should only\nallow valid images to pass through the controller to NoteEditor for save now", "committedDate": "2020-06-28T16:33:03Z", "type": "commit"}]}