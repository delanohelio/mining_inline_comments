{"pr_number": 6708, "pr_title": "Upstream test", "pr_createdAt": "2020-07-21T08:30:42Z", "pr_url": "https://github.com/ankidroid/Anki-Android/pull/6708", "timeline": [{"oid": "dc650f8688e05460fda671b2c8f2948235d88ba2", "url": "https://github.com/ankidroid/Anki-Android/commit/dc650f8688e05460fda671b2c8f2948235d88ba2", "message": "Split upstream test", "committedDate": "2020-07-21T08:31:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458103580", "bodyText": "Maybe I missed it, but this strong typing would be an easy one to split into a separate PR.\nOverall, it'd be great to get the individual code changes into separate PRs, then this would just contain test changes (which would end up being a simple \"approve\" as long as the tests aren't flaky and look reasonable).", "author": "david-allison-1", "createdAt": "2020-07-21T13:39:12Z", "path": "AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/ContentProviderTest.java", "diffHunk": "@@ -511,7 +513,7 @@ public void testInsertAndUpdateModel() {\n             // Delete the model (this will force a full-sync)\n             col.modSchemaNoCheck();\n             try {\n-                JSONObject model = col.getModels().get(mid);\n+                Model model = col.getModels().get(mid);", "originalCommit": "9d12079cb749bd65f3323e3d99fe3a7e39c69cfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExMjY4Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458112682", "bodyText": "#6689 ?", "author": "Arthur-Milchior", "createdAt": "2020-07-21T13:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExNTEzOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458115139", "bodyText": "I put most changes outside of tests in separate PR already. The few exceptions are the one which makes really little sens, such as utils function which are used only in tests. Adding a util function without using it would made for a strange PR.", "author": "Arthur-Milchior", "createdAt": "2020-07-21T13:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODExNzYyNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458117625", "bodyText": "and look reasonable\n\nAre you really looking forward reading 6000 lines of tests ? I wish you good luck. As you may understand by looking at my commits, I automated most of my changes, I would not have been able to read 6000 lines of code in a week-end ! I fear that you are going to spend far too much time ensuring they all looks reasonable.\nMy suggestion would be to accept them as long as they run, and if at some point we get a problem, check whether it's a unit test error or a code error.", "author": "Arthur-Milchior", "createdAt": "2020-07-21T13:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNzExNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458207117", "bodyText": "#6689 ?\n\nMissed that! That's why a quick breakdown of PRs that we need is a good thing.\nI've done massive PRs before. It's never ideal, but in this case, it won't be too problematic as long as it's confined to a single file.", "author": "david-allison-1", "createdAt": "2020-07-21T15:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMDAwMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458210003", "bodyText": "I am sorry, there are multiple files. I decided to split unit test and follow upstream file. So there are different files for importing, exporting, model, deck, collection, card...\nI still hope that's going to be okay. It's not like splitting the test in multiple PR will help in any way I believe.", "author": "Arthur-Milchior", "createdAt": "2020-07-21T15:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMjE0MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458212140", "bodyText": "Let's see what it's like when we've cut down the big PRs, I'm not expecting that there'll be too much hassle.", "author": "david-allison-1", "createdAt": "2020-07-21T16:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyMDU4Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458220587", "bodyText": "Anyway, if AnkiDroid's team want upstream unit test, I don't even see how I could do anything else than a massive PR. Porting unit test manually from upstream would be a huge work. I can't imagine any way to do it efficiently, in only a week-end, which does not require to do a lot of batch processing.\nthere are 97 new tests, I can't imagine that we would consider doing 97 PRs", "author": "Arthur-Milchior", "createdAt": "2020-07-21T16:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA=="}], "type": "inlineReview"}, {"oid": "61479352011c9504450bae9f74f31a90c9a8da3f", "url": "https://github.com/ankidroid/Anki-Android/commit/61479352011c9504450bae9f74f31a90c9a8da3f", "message": "empty test", "committedDate": "2020-07-22T07:58:56Z", "type": "forcePushed"}, {"oid": "91f17fe1901c34ffbbdcfdf89b5757d6598606f4", "url": "https://github.com/ankidroid/Anki-Android/commit/91f17fe1901c34ffbbdcfdf89b5757d6598606f4", "message": "NF: UnburyType is an enum", "committedDate": "2020-07-22T08:08:30Z", "type": "forcePushed"}, {"oid": "5790f41bd472f2e800f4d9d2bc6293b0018b6130", "url": "https://github.com/ankidroid/Anki-Android/commit/5790f41bd472f2e800f4d9d2bc6293b0018b6130", "message": "NF: UnburyType is an enum", "committedDate": "2020-07-22T08:12:22Z", "type": "forcePushed"}, {"oid": "9156283a8d2872b54c73bfe59031855b15a84430", "url": "https://github.com/ankidroid/Anki-Android/commit/9156283a8d2872b54c73bfe59031855b15a84430", "message": "NF: UnburyType is an enum", "committedDate": "2020-07-22T08:17:55Z", "type": "forcePushed"}, {"oid": "7bb45696cb9df018c1dc385e920f58bf92d81abe", "url": "https://github.com/ankidroid/Anki-Android/commit/7bb45696cb9df018c1dc385e920f58bf92d81abe", "message": "Upstream libanki tests", "committedDate": "2020-07-22T08:20:39Z", "type": "forcePushed"}, {"oid": "03ce3bfcf442c35e2a5c6f30f5da138b688cb0cc", "url": "https://github.com/ankidroid/Anki-Android/commit/03ce3bfcf442c35e2a5c6f30f5da138b688cb0cc", "message": "Upstream libanki tests", "committedDate": "2020-07-22T08:43:05Z", "type": "forcePushed"}, {"oid": "147a0e2bc1dab2bcdd42ab9dd368334e4429e841", "url": "https://github.com/ankidroid/Anki-Android/commit/147a0e2bc1dab2bcdd42ab9dd368334e4429e841", "message": "Upstream libanki tests", "committedDate": "2020-07-22T10:08:23Z", "type": "forcePushed"}, {"oid": "19afe66a863852726d46a1081d38a9f0d254e864", "url": "https://github.com/ankidroid/Anki-Android/commit/19afe66a863852726d46a1081d38a9f0d254e864", "message": "Upstream libanki tests", "committedDate": "2020-07-22T11:12:49Z", "type": "forcePushed"}, {"oid": "24563c2ee75db6b411e4b078b448b0555fd54108", "url": "https://github.com/ankidroid/Anki-Android/commit/24563c2ee75db6b411e4b078b448b0555fd54108", "message": "Upstream libanki tests", "committedDate": "2020-07-23T08:03:28Z", "type": "forcePushed"}, {"oid": "43cab6c262905a54d62c3cf9a813a633e8ff1adb", "url": "https://github.com/ankidroid/Anki-Android/commit/43cab6c262905a54d62c3cf9a813a633e8ff1adb", "message": "Upstream libanki tests", "committedDate": "2020-07-23T14:40:03Z", "type": "forcePushed"}, {"oid": "7bcdee34f532ec41b635cc253bb30523adaf45dc", "url": "https://github.com/ankidroid/Anki-Android/commit/7bcdee34f532ec41b635cc253bb30523adaf45dc", "message": "Upstream libanki tests", "committedDate": "2020-07-23T16:31:08Z", "type": "forcePushed"}, {"oid": "b7752803726920a4f4d0ef384d7250446a9d703e", "url": "https://github.com/ankidroid/Anki-Android/commit/b7752803726920a4f4d0ef384d7250446a9d703e", "message": "Upstream libanki tests", "committedDate": "2020-07-23T17:16:01Z", "type": "forcePushed"}, {"oid": "618ffbf36af7a55ec716378edb675ca8ecba6c5e", "url": "https://github.com/ankidroid/Anki-Android/commit/618ffbf36af7a55ec716378edb675ca8ecba6c5e", "message": "Upstream libanki tests", "committedDate": "2020-07-23T17:17:31Z", "type": "forcePushed"}, {"oid": "05796f89dbd4b7f9a0707bb595a9b6cdb5ad5ac4", "url": "https://github.com/ankidroid/Anki-Android/commit/05796f89dbd4b7f9a0707bb595a9b6cdb5ad5ac4", "message": "Upstream libanki tests", "committedDate": "2020-07-24T06:20:25Z", "type": "forcePushed"}, {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f", "url": "https://github.com/ankidroid/Anki-Android/commit/7fb841064b6dcac188793a341c1188f3fb5f468f", "message": "Upstream libanki tests", "committedDate": "2020-07-24T15:57:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0Mzg5OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460143898", "bodyText": "Could you mark that this throws if empty", "author": "david-allison-1", "createdAt": "2020-07-24T15:59:35Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/CollectionUtils.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.ichi2.libanki;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class CollectionUtils {\n+    public static <T> T getLastListElement(List<T> l) {\n+        return l.get(l.size()-1);", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDEwMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460144102", "bodyText": "We have a few utils packages already, would be better in there", "author": "david-allison-1", "createdAt": "2020-07-24T15:59:56Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/CollectionUtils.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.ichi2.libanki;", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1NDgxNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460154817", "bodyText": "Which one please ? I didn't see one where it makes really sens", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1ODUwMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460158500", "bodyText": "com.ichi2.utils", "author": "david-allison-1", "createdAt": "2020-07-24T16:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDc5Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460144796", "bodyText": "This one might be better as a PR", "author": "david-allison-1", "createdAt": "2020-07-24T16:01:04Z", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractSched.java", "diffHunk": "@@ -145,6 +148,12 @@\n     public abstract void maybeRandomizeDeck();\n     public abstract void maybeRandomizeDeck(Long did);\n     public abstract boolean haveBuried(long did);\n+    public enum UnburyType {\n+        ALL,\n+        MANUAL,\n+        SIBLINGS;\n+    }\n+    public abstract void unburyCardsForDeck(UnburyType type);", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1NDg4OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460154888", "bodyText": "Ok", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2NjA5Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460166096", "bodyText": "#6734", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTEyMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460145122", "bodyText": "Mention that these were autogenerated, and the commit hash", "author": "david-allison-1", "createdAt": "2020-07-24T16:01:36Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CardTest extends RobolectricTest {\n+    /******************\n+     ** Upstream tests*", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1NTAzMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460155030", "bodyText": "I don't understand this remark", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE1OTY1Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460159656", "bodyText": "Something along the lines of: \"autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\"", "author": "david-allison-1", "createdAt": "2020-07-24T16:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2Mjg3MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460162870", "bodyText": "Should I add it to all files ?", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2NDI2OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460164268", "bodyText": "Yeah, it'd be sensible", "author": "david-allison-1", "createdAt": "2020-07-24T16:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNzYyOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460227628", "bodyText": "Done. Note sure about whether \"autogenerated\" is the truth, given the amount of manual work to create the macros doing this change, but I\u00a0guess it's mostly a theoretical question", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTcyMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460145721", "bodyText": "assertThat(d.addNote(f), greaterThan(0))", "author": "david-allison-1", "createdAt": "2020-07-24T16:02:36Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ClozeTest.java", "diffHunk": "@@ -37,7 +38,7 @@ public void testCloze() {\n         }\n         // a cloze model with no clozes is not empty\n         f.setItem(\"Text\", \"nothing\");\n-        assertTrue(d.addNote(f) > 0);\n+        assertNotEquals(0, d.addNote(f));", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MTkxNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460161916", "bodyText": "Thanks. Didn't know that", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzAxMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460147010", "bodyText": "Does this mean it's broken? Could do with elaboration", "author": "david-allison-1", "createdAt": "2020-07-24T16:04:56Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CollectionTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CollectionTest extends RobolectricTest {\n+\n+    /*******************\n+     ** Upstream tests *\n+     *******************/\n+\n+    /*TODO\n+      @Test\n+      public void test_create_open(){\n+      (fd, path) = tempfile.mkstemp(suffix=\".anki2\", prefix=\"test_attachNew\");\n+      try {\n+      os.close(fd);\n+      os.unlink(path);\n+      } catch (OSError) {\n+      }\n+      Collection col = aopen(path);\n+      // for open()\n+      String newPath = col.getPath();\n+      long newMod = col.getMod();\n+      col.close();\n+\n+      // reopen\n+      col = aopen(newPath);\n+      assertEquals(newMod, col.getMod());\n+      col.close();\n+\n+      // non-writeable dir\n+      if (isWin) {\n+      String dir = \"c:\\root.anki2\";\n+      } else {\n+      String dir = \"/attachroot.anki2\";\n+      }\n+      assertException(Exception, lambda: aopen(dir));\n+      // reuse tmp file from before, test non-writeable file\n+      os.chmod(newPath, 0);\n+      assertException(Exception, lambda: aopen(newPath));\n+      os.chmod(newPath, 0o666);\n+      os.unlink(newPath);\n+      } */\n+\n+    @Test\n+    public void test_noteAddDelete(){\n+        Collection col = getCol();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"one\");\n+        note.setItem(\"Back\",\"two\");\n+        int n = col.addNote(note);\n+        assertEquals(1, n);\n+        // test multiple cards - add another template\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m, true); // todo:\u00a0remove true which is not upstream\n+        assertEquals(2, col.cardCount());\n+        // creating new notes should use both cards\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"three\");\n+        note.setItem(\"Back\",\"four\");\n+        n = col.addNote(note);\n+        assertEquals(2, n);\n+        assertEquals(4, col.cardCount());\n+        // check q/a generation\n+        Card c0 = note.cards().get(0);\n+        assertTrue(c0.q().contains(\"three\"));\n+        // it should not be a duplicate\n+        assertEquals(note.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // now let's make a duplicate\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"one\");\n+        note2.setItem(\"Back\",\"\");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // empty first field should not be permitted either\n+        note2.setItem(\"Front\",\" \");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+    }\n+\n+    @Test\n+    @Ignore(\"I don't understand this csum\")", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MTg3Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460161873", "bodyText": "I don't know what it means, so I don't know whether it's broken or what it means. So I left it for later consideration", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNTYzOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460225639", "bodyText": "csum is a hash used to deduplicate notes - maybe on the AnkiWeb side for mass analytics.", "author": "david-allison-1", "createdAt": "2020-07-24T18:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzMyNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460147324", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    note.setItem(\"Front\",\"1\");\n          \n          \n            \n                    note.setItem(\"Front\", \"1\");", "author": "david-allison-1", "createdAt": "2020-07-24T16:05:25Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CardTest extends RobolectricTest {\n+    /******************\n+     ** Upstream tests*\n+     ******************/\n+    \n+    @Test\n+    public void test_delete(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        long cid = note.cards().get(0).getId();\n+        col.reset();\n+        col.getSched().answerCard(col.getSched().getCard(), 2);\n+        col.remCards(Arrays.asList(new Long [] {cid}));\n+        assertEquals(0, col.cardCount());\n+        assertEquals(0, col.noteCount());\n+        assertEquals(0, col.getDb().queryScalar(\"select count() from notes\"));\n+        assertEquals(0, col.getDb().queryScalar(\"select count() from cards\"));\n+        assertEquals(2, col.getDb().queryScalar(\"select count() from graves\"));\n+    }\n+\n+    @Test\n+    public void test_misc_cards(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MTU4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460161580", "bodyText": "Is there a tool to automate our style ?\nI really wish not to re read those 6k lines to check every line's syntax", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2NDYxMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460164613", "bodyText": "I'll be doing it - setItem was the first that I saw\nThere's auto formatting in Android Studio", "author": "david-allison-1", "createdAt": "2020-07-24T16:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTYzMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460231630", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzgwMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460147800", "bodyText": "This is a feature that we need to implement - the new style of media that Rust uses", "author": "david-allison-1", "createdAt": "2020-07-24T16:06:13Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CollectionTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CollectionTest extends RobolectricTest {\n+\n+    /*******************\n+     ** Upstream tests *\n+     *******************/\n+\n+    /*TODO\n+      @Test\n+      public void test_create_open(){\n+      (fd, path) = tempfile.mkstemp(suffix=\".anki2\", prefix=\"test_attachNew\");\n+      try {\n+      os.close(fd);\n+      os.unlink(path);\n+      } catch (OSError) {\n+      }\n+      Collection col = aopen(path);\n+      // for open()\n+      String newPath = col.getPath();\n+      long newMod = col.getMod();\n+      col.close();\n+\n+      // reopen\n+      col = aopen(newPath);\n+      assertEquals(newMod, col.getMod());\n+      col.close();\n+\n+      // non-writeable dir\n+      if (isWin) {\n+      String dir = \"c:\\root.anki2\";\n+      } else {\n+      String dir = \"/attachroot.anki2\";\n+      }\n+      assertException(Exception, lambda: aopen(dir));\n+      // reuse tmp file from before, test non-writeable file\n+      os.chmod(newPath, 0);\n+      assertException(Exception, lambda: aopen(newPath));\n+      os.chmod(newPath, 0o666);\n+      os.unlink(newPath);\n+      } */\n+\n+    @Test\n+    public void test_noteAddDelete(){\n+        Collection col = getCol();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"one\");\n+        note.setItem(\"Back\",\"two\");\n+        int n = col.addNote(note);\n+        assertEquals(1, n);\n+        // test multiple cards - add another template\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m, true); // todo:\u00a0remove true which is not upstream\n+        assertEquals(2, col.cardCount());\n+        // creating new notes should use both cards\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"three\");\n+        note.setItem(\"Back\",\"four\");\n+        n = col.addNote(note);\n+        assertEquals(2, n);\n+        assertEquals(4, col.cardCount());\n+        // check q/a generation\n+        Card c0 = note.cards().get(0);\n+        assertTrue(c0.q().contains(\"three\"));\n+        // it should not be a duplicate\n+        assertEquals(note.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // now let's make a duplicate\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"one\");\n+        note2.setItem(\"Back\",\"\");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // empty first field should not be permitted either\n+        note2.setItem(\"Front\",\" \");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+    }\n+\n+    @Test\n+    @Ignore(\"I don't understand this csum\")\n+    public void test_fieldChecksum(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"new\");\n+        note.setItem(\"Back\",\"new2\");\n+        col.addNote(note);\n+        assertEquals(0xc2a6b03f, col.getDb().queryLongScalar(\"select csum from notes\"));\n+        // changing the val should change the checksum\n+        note.setItem(\"Front\",\"newx\");\n+        note.flush();\n+        assertEquals(0x302811ae, col.getDb().queryLongScalar(\"select csum from notes\"));\n+    }\n+\n+    @Test\n+    public void test_addDelTags(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        col.addNote(note);\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"2\");\n+        col.addNote(note2);\n+        // adding for a given id\n+        col.getTags().bulkAdd(Arrays.asList(new Long[] {note.getId()}), \"foo\");\n+        note.load();\n+        note2.load();\n+        assertTrue(note.getTags().contains(\"foo\"));\n+        assertFalse(note2.getTags().contains(\"foo\"));\n+        // should be canonified\n+        col.getTags().bulkAdd(Arrays.asList(new Long [] {note.getId()}), \"foo aaa\");\n+        note.load();\n+        assertEquals(\"aaa\", note.getTags().get(0));\n+        assertEquals(2, note.getTags().size());\n+    }\n+\n+    @Test\n+    public void test_timestamps(){\n+        Collection col = getCol();\n+        int stdModelSize = StdModels.stdModels.length;\n+        assertEquals(col.getModels().all().size(), stdModelSize);\n+        for (int i = 0; i < 100; i++) {\n+            StdModels.basicModel.add(col);\n+        }\n+        assertEquals(col.getModels().all().size(), 100 + stdModelSize);\n+    }\n+\n+    @Test\n+    @Ignore(\"What is anki:play\")", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2ODE2MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460168160", "bodyText": "What do you want me to do about it right now ?", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNTgzNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460225837", "bodyText": "Just explain what it is, and say that it's pending the rust translation", "author": "david-allison-1", "createdAt": "2020-07-24T18:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTYxMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460231610", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0ODQ2OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460148468", "bodyText": "This can go - we use a different translation mechanism", "author": "david-allison-1", "createdAt": "2020-07-24T16:07:19Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CollectionTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CollectionTest extends RobolectricTest {\n+\n+    /*******************\n+     ** Upstream tests *\n+     *******************/\n+\n+    /*TODO\n+      @Test\n+      public void test_create_open(){\n+      (fd, path) = tempfile.mkstemp(suffix=\".anki2\", prefix=\"test_attachNew\");\n+      try {\n+      os.close(fd);\n+      os.unlink(path);\n+      } catch (OSError) {\n+      }\n+      Collection col = aopen(path);\n+      // for open()\n+      String newPath = col.getPath();\n+      long newMod = col.getMod();\n+      col.close();\n+\n+      // reopen\n+      col = aopen(newPath);\n+      assertEquals(newMod, col.getMod());\n+      col.close();\n+\n+      // non-writeable dir\n+      if (isWin) {\n+      String dir = \"c:\\root.anki2\";\n+      } else {\n+      String dir = \"/attachroot.anki2\";\n+      }\n+      assertException(Exception, lambda: aopen(dir));\n+      // reuse tmp file from before, test non-writeable file\n+      os.chmod(newPath, 0);\n+      assertException(Exception, lambda: aopen(newPath));\n+      os.chmod(newPath, 0o666);\n+      os.unlink(newPath);\n+      } */\n+\n+    @Test\n+    public void test_noteAddDelete(){\n+        Collection col = getCol();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"one\");\n+        note.setItem(\"Back\",\"two\");\n+        int n = col.addNote(note);\n+        assertEquals(1, n);\n+        // test multiple cards - add another template\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m, true); // todo:\u00a0remove true which is not upstream\n+        assertEquals(2, col.cardCount());\n+        // creating new notes should use both cards\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"three\");\n+        note.setItem(\"Back\",\"four\");\n+        n = col.addNote(note);\n+        assertEquals(2, n);\n+        assertEquals(4, col.cardCount());\n+        // check q/a generation\n+        Card c0 = note.cards().get(0);\n+        assertTrue(c0.q().contains(\"three\"));\n+        // it should not be a duplicate\n+        assertEquals(note.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // now let's make a duplicate\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"one\");\n+        note2.setItem(\"Back\",\"\");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // empty first field should not be permitted either\n+        note2.setItem(\"Front\",\" \");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+    }\n+\n+    @Test\n+    @Ignore(\"I don't understand this csum\")\n+    public void test_fieldChecksum(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"new\");\n+        note.setItem(\"Back\",\"new2\");\n+        col.addNote(note);\n+        assertEquals(0xc2a6b03f, col.getDb().queryLongScalar(\"select csum from notes\"));\n+        // changing the val should change the checksum\n+        note.setItem(\"Front\",\"newx\");\n+        note.flush();\n+        assertEquals(0x302811ae, col.getDb().queryLongScalar(\"select csum from notes\"));\n+    }\n+\n+    @Test\n+    public void test_addDelTags(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        col.addNote(note);\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"2\");\n+        col.addNote(note2);\n+        // adding for a given id\n+        col.getTags().bulkAdd(Arrays.asList(new Long[] {note.getId()}), \"foo\");\n+        note.load();\n+        note2.load();\n+        assertTrue(note.getTags().contains(\"foo\"));\n+        assertFalse(note2.getTags().contains(\"foo\"));\n+        // should be canonified\n+        col.getTags().bulkAdd(Arrays.asList(new Long [] {note.getId()}), \"foo aaa\");\n+        note.load();\n+        assertEquals(\"aaa\", note.getTags().get(0));\n+        assertEquals(2, note.getTags().size());\n+    }\n+\n+    @Test\n+    public void test_timestamps(){\n+        Collection col = getCol();\n+        int stdModelSize = StdModels.stdModels.length;\n+        assertEquals(col.getModels().all().size(), stdModelSize);\n+        for (int i = 0; i < 100; i++) {\n+            StdModels.basicModel.add(col);\n+        }\n+        assertEquals(col.getModels().all().size(), 100 + stdModelSize);\n+    }\n+\n+    @Test\n+    @Ignore(\"What is anki:play\")\n+    public void test_furigana(){\n+        Collection col = getCol();\n+        Models mm = col.getModels();\n+        Model m = mm.current();\n+        // filter should work\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{kana:Front}}\");\n+        mm.save(m);\n+        Note n = col.newNote();\n+        n.setItem(\"Front\", \"foo[abc]\");\n+        col.addNote(n);\n+        Card c = n.cards().get(0);\n+        assertTrue(c.q().endsWith(\"abc\"));\n+        // and should avoid sound\n+        n.setItem(\"Front\", \"foo[sound:abc.mp3]\");\n+        n.flush();\n+        String question = c.q(true);\n+        assertTrue(\"Question \u00ab\" + question +\"\u00bb does not contains \u00abanki:play\u00bb.\", question.contains(\"anki:play\"));\n+        // it shouldn't throw an error while people are editing\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{kana:}}\");\n+        mm.save(m);\n+        c.q(true);\n+    }\n+\n+    /*\n+      @Test", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2ODg5OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460168899", "bodyText": "Removed", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0ODQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2ODk4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460168980", "bodyText": "Removed", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0ODQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTE3Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460149172", "bodyText": "let's get rid of this", "author": "david-allison-1", "createdAt": "2020-07-24T16:08:37Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ExportingTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ExportingTest extends RobolectricTest {\n+     /*****************\n+      ** Exporting    *\n+      *****************/\n+    private Collection setup1(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"foo\");\n+        note.setItem(\"Back\",\"bar<br>\");\n+        note.setTagsFromStr(\"tag, tag2\");\n+        col.addNote(note);\n+        // with a different col\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"baz\");\n+        note.setItem(\"Back\",\"qux\");\n+        note.model().put(\"did\", col.getDecks().id(\"new col\"));\n+        col.addNote(note);\n+        return col;\n+    }\n+\n+    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */\n+    @Test\n+    public void empty_test() {\n+    }", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDUxNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460160517", "bodyText": "if there is no test in a file, the test fail. Do you want me to remove the file entirely ? I was expecting that it's still useful to have at least a part of the work done in the repo, even if the test is not running currently", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNTk1Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460225956", "bodyText": "Ah... just a comment should do", "author": "david-allison-1", "createdAt": "2020-07-24T18:41:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyODU2OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460228568", "bodyText": "I added a comment explaining why I added the method. Hope it's okay", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTM1NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460149355", "bodyText": "We should flag this one as one we should get working", "author": "david-allison-1", "createdAt": "2020-07-24T16:08:56Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ExportingTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ExportingTest extends RobolectricTest {\n+     /*****************\n+      ** Exporting    *\n+      *****************/\n+    private Collection setup1(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"foo\");\n+        note.setItem(\"Back\",\"bar<br>\");\n+        note.setTagsFromStr(\"tag, tag2\");\n+        col.addNote(note);\n+        // with a different col\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"baz\");\n+        note.setItem(\"Back\",\"qux\");\n+        note.model().put(\"did\", col.getDecks().id(\"new col\"));\n+        col.addNote(note);\n+        return col;\n+    }\n+\n+    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */\n+    @Test\n+    public void empty_test() {\n+    }\n+\n+\n+    /* TODO\n+       @Test\n+       public void test_export_anki(){", "originalCommit": "7fb841064b6dcac188793a341c1188f3fb5f468f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MDc3NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460160774", "bodyText": "How do I flag something to indicate work should be done ?", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2NjEyNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460166127", "bodyText": "If we're not going to get it done in this PR, then a GitHub issue with a checklist, otherwise it can go in the main post", "author": "david-allison-1", "createdAt": "2020-07-24T16:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2OTQ2NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460169465", "bodyText": "I don't expect to do it in this PR. I would prefer to see it merged; there are already quite enough interesting things in it I believe", "author": "Arthur-Milchior", "createdAt": "2020-07-24T16:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTM1NQ=="}], "type": "inlineReview"}, {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "url": "https://github.com/ankidroid/Anki-Android/commit/a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "message": "Upstream libanki tests", "committedDate": "2020-07-24T16:43:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3OTI0NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460179245", "bodyText": "We can get this one working", "author": "david-allison-1", "createdAt": "2020-07-24T17:05:25Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/MediaTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class MediaTest extends RobolectricTest {\n+    /*****************\n+     ** Media        *\n+     *****************/\n+    // copying files to media folder\n+    \n+    /* TODO: media\n+       @Test\n+       public void test_add(){\n+       Collection col = getCol();\n+       String dir = tempfile.mkdtemp(prefix=\"anki\");\n+       String path = os.path.join(dir, \"foo.jpg\");\n+       with open(path, \"w\") as note:\n+       note.write(\"hello\");\n+       // new file, should preserve name\n+       assertEquals(\"foo.jpg\", col.getMedia().addFile(path));\n+       // adding the same file again should not create a duplicate\n+       assertEquals(\"foo.jpg\", col.getMedia().addFile(path));\n+       // but if it has a different sha1, it should\n+       with open(path, \"w\") as note:\n+       note.write(\"world\");\n+       assertEquals(\"foo-7c211433f02071597741e6ff5a8ea34789abbf43.jpg\", col.getMedia().addFile(path));\n+       } */\n+    \n+    @Test\n+    public void test_strings(){\n+        Collection col = getCol();\n+        long mid = col.getModels().current().getLong(\"id\");\n+        assertEquals(0, col.getMedia().filesInStr(mid, \"aoeu\").size());\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src='foo.jpg'>ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src='foo.jpg' style='test'>ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\", \"bar.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src='foo.jpg'><img src=\\\"bar.jpg\\\">ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src=foo.jpg style=bar>ao\"));\n+        assertEqualsArrayList(new String [] {\"one\", \"two\"}, col.getMedia().filesInStr(mid, \"<img src=one><img src=two>\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src=\\\"foo.jpg\\\">ao\"));\n+        assertEqualsArrayList(new String[] {\"foo.jpg\", \"fo\"},\n+                              col.getMedia().filesInStr(mid, \"aoeu<img src=\\\"foo.jpg\\\"><img class=yo src=fo>ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.mp3\"}, col.getMedia().filesInStr(mid, \"aou[sound:foo.mp3]aou\"));\n+        assertEquals(\"aoeu\", col.getMedia().strip(\"aoeu\"));\n+        assertEquals(\"aoeuaoeu\", col.getMedia().strip(\"aoeu[sound:foo.mp3]aoeu\"));\n+        assertEquals(\"aoeu\", col.getMedia().strip(\"a<img src=yo>oeu\"));\n+        assertEquals(\"aoeu\", col.getMedia().escapeImages(\"aoeu\"));\n+        assertEquals(\"<img src='http://foo.com'>\", col.getMedia().escapeImages(\"<img src='http://foo.com'>\"));\n+        assertEquals(\"<img src=\\\"foo%20bar.jpg\\\">\", col.getMedia().escapeImages(\"<img src=\\\"foo bar.jpg\\\">\"));\n+    }\n+    \n+    /** TODO: file\n+        @Test\n+        public void test_deckIntegration(){", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyMzIxNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460223215", "bodyText": "Probably. I just don't know how to deal with file in AnkiDroid, so I left it for later. I don't expect it to be complex by itself", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3OTI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDExNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460180116", "bodyText": "Should be able to:\nassertThat(note.cards().get(0).q(), containsString(\"class=cloze\"));", "author": "david-allison-1", "createdAt": "2020-07-24T17:07:13Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyMzI5MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460223291", "bodyText": "Done for all string #6736", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDM2MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460180361", "bodyText": "Hamcrest: endsWith", "author": "david-allison-1", "createdAt": "2020-07-24T17:07:49Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(1).q().contains(\"class=cloze\"));\n+        assertFalse(note.cards().get(2).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(3).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(4).q().contains(\"class=cloze\"));\n+        \n+        note = col.newNote();\n+        note.setItem(\"Text\",\"\\\\(a\\\\) {{c1::b}} \\\\[ {{c1::c}} \\\\]\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(1, note.numberOfCards());\n+        String question = note.cards().get(0).q();\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not end correctly\", question.endsWith(\"\\\\(a\\\\) <span class=cloze>[...]</span> \\\\[ [...] \\\\]\"));", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyMzM1Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460223357", "bodyText": "Done for all string #6736", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDY0NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460180645", "bodyText": "If you comment out the assertions, please assume false or ignore the test", "author": "david-allison-1", "createdAt": "2020-07-24T17:08:25Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(1).q().contains(\"class=cloze\"));\n+        assertFalse(note.cards().get(2).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(3).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(4).q().contains(\"class=cloze\"));\n+        \n+        note = col.newNote();\n+        note.setItem(\"Text\",\"\\\\(a\\\\) {{c1::b}} \\\\[ {{c1::c}} \\\\]\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(1, note.numberOfCards());\n+        String question = note.cards().get(0).q();\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not end correctly\", question.endsWith(\"\\\\(a\\\\) <span class=cloze>[...]</span> \\\\[ [...] \\\\]\"));\n+    }\n+    \n+    @Test\n+    public void test_typecloze(){\n+        Collection col = getCol();\n+        Model m = col.getModels().byName(\"Cloze\");\n+        col.getModels().setCurrent(m);\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{cloze:Text}}{{type:cloze:Text}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"[[type:cloze:Text]]\"));\n+    }\n+    \n+    @Test\n+    public void test_chained_mods() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{cloze:text:Text}}\");\n+        t.put(\"afmt\", \"{{cloze:text:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        String q1 = \"<span style=\\\"color:red\\\">phrase</span>\";\n+        String a1 = \"<b>sentence</b>\";\n+        String q2 = \"<span style=\\\"color:red\\\">en chaine</span>\";\n+        String a2 = \"<i>chained</i>\";\n+        note.setItem(\"Text\",\"This {{c1::\"+q1+\"::\"+a1+\"}} demonstrates {{c1::\"+q2+\"::\"+a2+\"}} clozes.\");\n+        assertEquals(1, col.addNote(note));\n+        String question = note.cards().get(0).q();\n+        /* TODO: chained modifier", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNDI5Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460224293", "bodyText": "This seems to make ne sens for me, sorry.\nI don't want to assume that they are false. They should be true. We are not differing from upstream, we should potentially correct it, but anyway it should be true, even if it's false right now.\nI don't want to ignore the test etiher, because the remaining assertion are working, and if at some point they break, I want to see a warning", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4NjM0NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463286345", "bodyText": "I personally treat \"ignore\" as \"inconclusive\", ignoring at a certain point in the test allows it to execute and fail if there are issues, but doesn't signify that everything's perfect. That's a flag to a developer in the future that the test is a work in progress, or waiting for some condition. @mikehardy - do we have/want rules on this?", "author": "david-allison-1", "createdAt": "2020-07-30T21:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTE1Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460181157", "bodyText": "TODO: me - Can be improved by hamcrest", "author": "david-allison-1", "createdAt": "2020-07-24T17:09:26Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(1).q().contains(\"class=cloze\"));\n+        assertFalse(note.cards().get(2).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(3).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(4).q().contains(\"class=cloze\"));\n+        \n+        note = col.newNote();\n+        note.setItem(\"Text\",\"\\\\(a\\\\) {{c1::b}} \\\\[ {{c1::c}} \\\\]\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(1, note.numberOfCards());\n+        String question = note.cards().get(0).q();\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not end correctly\", question.endsWith(\"\\\\(a\\\\) <span class=cloze>[...]</span> \\\\[ [...] \\\\]\"));\n+    }\n+    \n+    @Test\n+    public void test_typecloze(){\n+        Collection col = getCol();\n+        Model m = col.getModels().byName(\"Cloze\");\n+        col.getModels().setCurrent(m);\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{cloze:Text}}{{type:cloze:Text}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"[[type:cloze:Text]]\"));\n+    }\n+    \n+    @Test\n+    public void test_chained_mods() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{cloze:text:Text}}\");\n+        t.put(\"afmt\", \"{{cloze:text:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        String q1 = \"<span style=\\\"color:red\\\">phrase</span>\";\n+        String a1 = \"<b>sentence</b>\";\n+        String q2 = \"<span style=\\\"color:red\\\">en chaine</span>\";\n+        String a2 = \"<i>chained</i>\";\n+        note.setItem(\"Text\",\"This {{c1::\"+q1+\"::\"+a1+\"}} demonstrates {{c1::\"+q2+\"::\"+a2+\"}} clozes.\");\n+        assertEquals(1, col.addNote(note));\n+        String question = note.cards().get(0).q();\n+        /* TODO: chained modifier\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not contain the expected string\", question.contains(\"This <span class=cloze>[sentence]</span> demonstrates <span class=cloze>[chained]</span> clozes.\")\n+                   );\n+        assertTrue(note.cards().get(0).a().contains(\"This <span class=cloze>phrase</span> demonstrates <span class=cloze>en chaine</span> clozes.\"\n+                                                    ));\n+\n+         */\n+    }\n+    \n+    @Test\n+    public void test_modelChange() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model cloze = col.getModels().byName(\"Cloze\");\n+        // enable second template and add a note\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Model basic = m;\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"note\");\n+        note.setItem(\"Back\",\"b123\");\n+        col.addNote(note);\n+        // switch fields\n+        Map<Integer, Integer> map = new HashMap<>();\n+        map.put(0, 1);\n+        map.put(1, 0);\n+        col.getModels().change(basic,new long [] {note.getId()}, basic, map, null);\n+        note.load();\n+        assertEquals(\"b123\", note.getItem(\"Front\"));\n+        assertEquals(\"note\", note.getItem(\"Back\"));\n+        // switch cards\n+        Card c0 = note.cards().get(0);\n+        Card c1 = note.cards().get(1);\n+        assertTrue(c0.q().contains(\"b123\"));\n+        assertTrue(c1.q().contains(\"note\"));\n+        assertEquals(0, c0.getOrd());\n+        assertEquals(1, c1.getOrd());\n+        col.getModels().change(basic,new long []{note.getId()}, basic, null, map);\n+        note.load();\n+        c0.load();\n+        c1.load();\n+        assertTrue(c0.q().contains(\"note\"));\n+        assertTrue(c1.q().contains(\"b123\"));\n+        assertEquals(1, c0.getOrd());\n+        assertEquals(0, c1.getOrd());\n+        // .cards() returns cards in order\n+        assertEquals(c1.getId(), note.cards().get(0).getId());\n+        // delete first card\n+        map = new HashMap<>();\n+        map.put(0, null);\n+        map.put(1, 1);\n+        // if (isWin) {\n+        //     // The low precision timer on Windows reveals a race condition\n+        //     time.sleep(0.05);\n+        // }\n+        col.getModels().change(basic,new long [] {note.getId()}, basic, null, map);\n+        note.load();\n+        c0.load();\n+        // the card was deleted\n+        // but we have two cards, as a new one was generated\n+        assertEquals(2, note.numberOfCards());\n+        // an unmapped field becomes blank\n+        assertEquals(\"b123\", note.getItem(\"Front\"));\n+        assertEquals(\"note\", note.getItem(\"Back\"));\n+        col.getModels().change(basic,new long [] {note.getId()}, basic, map, null);\n+        note.load();\n+        assertEquals(\"\", note.getItem(\"Front\"));\n+        assertEquals(\"note\", note.getItem(\"Back\"));\n+        // another note to try model conversion\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"f2\");\n+        note.setItem(\"Back\",\"b2\");\n+        col.addNote(note);\n+        // counts = col.getModels().all_use_counts();\n+        // Using older version of the test\n+        assertEquals(2, col.getModels().useCount(basic));\n+        assertEquals(0, col.getModels().useCount(cloze));\n+        // Identity map\n+        map = new HashMap<>();\n+        map.put(0, 0);\n+        map.put(1, 1);\n+        col.getModels().change(basic,new long []{note.getId()}, cloze, map, map);\n+        note.load();\n+        assertEquals(\"f2\", note.getItem(\"Text\"));\n+        assertEquals(2, note.numberOfCards());\n+        // back the other way, with deletion of second ord\n+        col.getModels().remTemplate(basic, basic.getJSONArray(\"tmpls\").getJSONObject(1));\n+        assertEquals(2, col.getDb().queryScalar(\"select count() from cards where nid = ?\", note.getId()));\n+        map = new HashMap<>();\n+        map.put(0, 0);\n+        col.getModels().change(cloze,new long []{note.getId()}, basic, map, map);\n+        assertEquals(1, col.getDb().queryScalar(\"select count() from cards where nid = ?\", note.getId()));\n+    }\n+    \n+    \n+    private void reqSize(Model model) {\n+        if (model.getInt(\"type\") == MODEL_CLOZE) {\n+            return;\n+        }\n+        assertEquals(model.getJSONArray(\"req\").length(), model.getJSONArray(\"tmpls\").length());\n+    }\n+    \n+    @Test\n+    public void test_req(){\n+        \n+        Collection col = getCol();\n+        Models mm = col.getModels();\n+        Model basic = mm.byName(\"Basic\");\n+        assertTrue(basic.has(\"req\"));\n+        reqSize(basic);\n+        JSONArray r = basic.getJSONArray(\"req\").getJSONArray(0);\n+        assertEquals(0, r.getInt(0));\n+        assertTrue(Arrays.asList(new String[]{\"any\", \"all\"}).contains(r.getString(1)));", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460181570", "bodyText": "Try to avoid commenting out assertions if the test would still \"pass\"", "author": "david-allison-1", "createdAt": "2020-07-24T17:10:11Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UndoTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.COUNT_REMAINING;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_LRN;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_NEW;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+\n+@RunWith(AndroidJUnit4.class)\n+public class UndoTest extends RobolectricTest {\n+    /*****************\n+     ** Undo         *\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+    @Test\n+    @Ignore(\"We need to figure out how to test save/undo\")\n+    public void test_op() throws Exception {\n+        Collection col = getColV2();\n+        // should have no undo by default\n+        assertNull(col.undoType());\n+        // let's adjust a study option\n+        col.save(\"studyopts\");\n+        col.getConf().put(\"abc\", 5);\n+        // it should be listed as undoable\n+        assertEquals(\"studyopts\", col.undoName(getTargetContext().getResources()));\n+        // with about 5 minutes until it's clobbered\n+        /* lastSave\n+           assertThat(Utils.now() - col._lastSave, lesserThan(1));\n+        */\n+        // undoing should restore the old value\n+        col.undo();\n+        assertEquals(null, col.undoType());\n+        assertFalse(col.getConf().has(\"abc\"));\n+        // an (auto)save will clear the undo\n+        col.save(\"foo\");\n+        assertEquals(\"foo\", col.undoName(getTargetContext().getResources()));\n+        col.save();\n+        assertEquals(\"\", col.undoName(getTargetContext().getResources()));\n+        // and a review will, too\n+        col.save(\"add\");\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        assertEquals(\"add\", col.undoName(getTargetContext().getResources()));\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(\"Review\", col.undoName(getTargetContext().getResources()));\n+    }\n+\n+\n+    @Test\n+    public void test_review() throws Exception {\n+        Collection col = getColV2();\n+        col.getConf().put(\"counts\", COUNT_REMAINING);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        /* TODO:\u00a0 undo after reset ?\n+        assertNotNull(col.undoType());\n+\n+         */\n+        // answer\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        Card c = col.getSched().getCard();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(1001, c.getLeft());\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        // undo\n+        assertNotNull(col.undoType());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertNotEquals(1001, c.getLeft());\n+        assertNull(col.undoType());\n+        // we should be able to undo multiple answers too\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 2, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 1, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        // performing a normal op will clear the review queue\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(Collection.DismissType.REVIEW, col.undoType());\n+        col.save(\"foo\");\n+        /* TODO: save and undo\n+        assertEquals(\"foo\", col.undoName(getTargetContext().getResources()));", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNDc1NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460224754", "bodyText": "The tests fails here. save(\"foo\") does not add an element to the Undo list as it does upstream. So this test fails. I still want to keep the remaining of the test as it works", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNjU1Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460226552", "bodyText": "If you assumeThat(\"Not Implemented\", false), then the test will either fail, or be ignored, is that a reasonable compromise?", "author": "david-allison-1", "createdAt": "2020-07-24T18:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyOTYxNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460229615", "bodyText": "I guess so.", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTAyMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460231023", "bodyText": "I don't understand exactly what I should write here. When I use assumeThat(col.undoName(getTargetContext().getResources()), is(\"foo\")); the test fails.\nWritting literally:\nassumeThat(\"Not Implemented\", false), makes no sens, so I assume you just meant this is the schema of what I was expected to do", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ0MzAwNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460443007", "bodyText": "No, specifically that line - it means the test can either fail, or be ignored (which is better than ignoring the whole test), it also points to a specific line which is the problem\nEDIT: assumeTrue(\"Not Implemented\", false)", "author": "david-allison-1", "createdAt": "2020-07-25T20:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NDgyNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465154827", "bodyText": "Assume used", "author": "Arthur-Milchior", "createdAt": "2020-08-04T15:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTcxMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460181710", "bodyText": "This change seems unnecessary", "author": "david-allison-1", "createdAt": "2020-07-24T17:10:27Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UtilsTest.java", "diffHunk": "@@ -84,4 +86,7 @@ public void testCopyFile() throws Exception {\n         Utils.copyFile(new File(resource.toURI()), copy);\n         Assert.assertEquals(TestUtils.getMD5(resourcePath), TestUtils.getMD5(copy.getCanonicalPath()));\n     }\n+", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjA0Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460182046", "bodyText": "More commented out assertions", "author": "david-allison-1", "createdAt": "2020-07-24T17:11:08Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -126,20 +156,1248 @@ private void selectNewDeck() {\n         getCol().getDecks().select(did);\n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         getCol().getSched().deckDueTree();\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n+        assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n \n     }\n \n \n     private void selectDefaultDeck() {\n         getCol().getDecks().select(Consts.DEFAULT_DECK_ID);\n     }\n-}\n\\ No newline at end of file\n+\n+\n+    /*****************\n+     ** Upstream test*\n+     *****************/\n+    private Collection getColV1() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(1);\n+        return col;\n+    }\n+\n+\n+    public void test_new_v1() throws Exception {\n+        Collection col = getColV1();\n+        col.reset();\n+        assertEquals(0, col.getSched().newDue());\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount); get access of new count\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail", "originalCommit": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyNTg5MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460225891", "bodyText": "It's commented upstream. i am not going to try to correct upstream tests", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIyODAyOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460228029", "bodyText": "Oh... could you mention that, assumed it was commented here.", "author": "david-allison-1", "createdAt": "2020-07-24T18:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIzMTQ1OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460231458", "bodyText": "That's going to take time to find out all tests that are commented and ported as is. I'll try to do it later", "author": "Arthur-Milchior", "createdAt": "2020-07-24T18:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDI0NDYyMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460244623", "bodyText": "I'll flag them as I find them. Enjoy your weekend!", "author": "david-allison-1", "createdAt": "2020-07-24T19:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjA0Ng=="}], "type": "inlineReview"}, {"oid": "7536c16bf956a6c2821814eabd6af5685913774f", "url": "https://github.com/ankidroid/Anki-Android/commit/7536c16bf956a6c2821814eabd6af5685913774f", "message": "Upstream libanki tests", "committedDate": "2020-07-24T18:47:20Z", "type": "forcePushed"}, {"oid": "5402e975c6a82c1902595f1837f06e8abcd75077", "url": "https://github.com/ankidroid/Anki-Android/commit/5402e975c6a82c1902595f1837f06e8abcd75077", "message": "Upstream libanki tests", "committedDate": "2020-07-24T18:52:54Z", "type": "forcePushed"}, {"oid": "59d5761081c79d8aef9b0bd799f664f2e78d15d7", "url": "https://github.com/ankidroid/Anki-Android/commit/59d5761081c79d8aef9b0bd799f664f2e78d15d7", "message": "Upstream libanki tests", "committedDate": "2020-07-24T20:04:25Z", "type": "forcePushed"}, {"oid": "a74f9f92032777f428b26b339caf53bdc302345c", "url": "https://github.com/ankidroid/Anki-Android/commit/a74f9f92032777f428b26b339caf53bdc302345c", "message": "Upstream libanki tests", "committedDate": "2020-07-25T18:12:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzE1OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460433158", "bodyText": "I think we should move this into a separate PR", "author": "david-allison-1", "createdAt": "2020-07-25T18:51:19Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ClozeTest.java", "diffHunk": "@@ -72,7 +69,7 @@ public void testCloze() {\n         int cnt = d.cardCount();\n         f.setItem(\"Text\", \"{{c2::hello}} {{c1::foo}}\");\n         f.flush();\n-        assertEquals(cnt+1, d.cardCount());\n+        assertEquals(cnt + 1, d.cardCount());", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDU4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460434580", "bodyText": "I can hardy agree more. At this point, I believe that you may loose more time showing me the errors than just correcting them directly", "author": "Arthur-Milchior", "createdAt": "2020-07-25T19:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNzEzNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460437136", "bodyText": "IMO, it'll be very useful to have this PR just handle the inclusion of new tests, and not fixing formatting issues in existing tests.", "author": "david-allison-1", "createdAt": "2020-07-25T19:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzQ0OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460433449", "bodyText": "This should probably override setUp and use a local variable - avoids the need to call it on each", "author": "david-allison-1", "createdAt": "2020-07-25T18:54:51Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ExportingTest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ExportingTest extends RobolectricTest {\n+    /*****************\n+     ** Exporting    *\n+     *****************/\n+    private Collection setup1() {", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYxNzA5NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460617094", "bodyText": "I do not see how to \"setup\" and then access the collection. I do not see how it is done in the other classes", "author": "Arthur-Milchior", "createdAt": "2020-07-27T02:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4NzQ4MA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463287480", "bodyText": "Can be done along these lines\n@Override\npublic void setUp() {\n    super.setUp();\n    this.localVariableToBeUsedInTesting = getCol();\n}", "author": "david-allison-1", "createdAt": "2020-07-30T21:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2NDUyNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463964527", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-01T13:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzk1OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460433959", "bodyText": "Could you move this to a separate PR, or remove the change - not relevant to porting", "author": "david-allison-1", "createdAt": "2020-07-25T19:00:35Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/MathJaxClozeTest.java", "diffHunk": "@@ -41,6 +41,7 @@ public void removeFormattingFromMathjax() {\n         assertEquals(escaped_s2, Template.removeFormattingFromMathjax(original_s2, \"1\"));\n     }\n \n+", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2MzcxMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463963710", "bodyText": "done", "author": "Arthur-Milchior", "createdAt": "2020-08-01T13:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDQzMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460434432", "bodyText": "Could you remove this file from the PR?", "author": "david-allison-1", "createdAt": "2020-07-25T19:06:08Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/NoteTest.java", "diffHunk": "@@ -22,6 +22,7 @@ public void noFieldDataReturnsFirstClozeIndex() {\n         assertThat(\"No data should return a cloze index of 1 the next.\", expected, is(1));\n     }\n \n+", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDY0Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460434642", "bodyText": "Again, maybe for another PR", "author": "david-allison-1", "createdAt": "2020-07-25T19:08:48Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UtilsTest.java", "diffHunk": "@@ -43,15 +43,15 @@ public void testZipWithPathTraversal() {\n             Enumeration zipEntries = zipFile.getEntries();\n             while (zipEntries.hasMoreElements()) {\n                 ZipArchiveEntry ze2 = (ZipArchiveEntry) zipEntries.nextElement();\n-                Utils.unzipFiles(zipFile, \"/tmp\", new String[]{ze2.getName()}, null);\n+                Utils.unzipFiles(zipFile, \"/tmp\", new String[] {ze2.getName()}, null);\n             }\n             Assert.fail(\"Expected an IOException\");\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             Assert.assertEquals(\"File is outside extraction target directory.\", e.getMessage());\n         }\n     }\n \n+", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4ODAxNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463288014", "bodyText": "Still outstanding", "author": "david-allison-1", "createdAt": "2020-07-30T21:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDY0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2MzY5Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463963696", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-08-01T13:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTI5OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460435299", "bodyText": "Ignore the test for now", "author": "david-allison-1", "createdAt": "2020-07-25T19:16:19Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -126,20 +158,1248 @@ private void selectNewDeck() {\n         getCol().getDecks().select(did);\n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         getCol().getSched().deckDueTree();\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n+        assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n \n     }\n \n \n     private void selectDefaultDeck() {\n         getCol().getDecks().select(Consts.DEFAULT_DECK_ID);\n     }\n-}\n\\ No newline at end of file\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py*\n+     *****************/\n+    private Collection getColV1() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(1);\n+        return col;\n+    }\n+\n+\n+    public void test_new_v1() throws Exception {\n+        Collection col = getColV1();\n+        col.reset();\n+        assertEquals(0, col.getSched().newDue());\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount); get access of new count\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V1() throws Exception {\n+        Collection col = getColV1();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        Note note;\n+        for (int i = 0; i < 30; i++) {\n+            note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount); TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        //assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v1() throws Exception {\n+        Collection col = getColV1();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV1() throws Exception {\n+        Collection col = getColV1();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 2);\n+        // it should be due in 3 minutes\n+        assertEquals(Math.round(c.getDue() - Utils.now()), 179, 1);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(2, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 2);\n+        // it should be due in 10 minutes\n+        assertEquals(c.getDue() - Utils.now(), 599, 1);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+        // now failed card handling\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        c.setODue(123);\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(123, c.getDue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // we should be able to remove manually, too\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        c.setODue(321);\n+        c.flush();\n+        ((Sched) col.getSched()).removeLrn();\n+        c.load();\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(321, c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV1() throws Exception {\n+        Collection col = getColV1();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 2);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV1() throws Exception {\n+        Collection col = getColV1();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 2);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 2));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 2));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 2);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 2));\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_RELEARNING, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV1() throws Exception {\n+        Collection col = getColV1();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // failing it should put it in the learn queue with the default options\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        // different delay to new\n+        col.reset();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {2, 20}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        // it should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getODue());\n+        assertEquals(1, c.getIvl());\n+        // but because it's in the learn queue, its current due time should be in\n+        // the future\n+        assertTrue(c.getDue() >= Utils.now());\n+        assertTrue((c.getDue() - Utils.now()) > 118);\n+        // factor should have been decremented\n+        assertEquals(2300, c.getFactor());\n+        // check counters\n+        assertEquals(2, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // check ests.\n+\n+        assertEquals(120, col.getSched().nextIvl(c, 1));\n+        assertEquals(20 * 60, col.getSched().nextIvl(c, 2));\n+        // try again with an ease of 2 instead\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100 + 8/4) * 1.2 = 122\n+        assertTrue(checkRevIvl(col, c, 122));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+    }\n+\n+\n+\n+\n+    @Test\n+    public void test_button_spacingV1() throws Exception {\n+        Collection col = getColV1();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+    }\n+\n+\n+    @Test\n+    public void test_overdue_lapseV1() throws Exception {\n+        // disabled in commit anki@3069729776990980f34c25be66410e947e9d51a2", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYxNzU1Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460617557", "bodyText": "@ignore added.\nAs note, it's disabled upstream too", "author": "Arthur-Milchior", "createdAt": "2020-07-27T02:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460435638", "bodyText": "\ud83d\uded1 This will be flaky in CI", "author": "david-allison-1", "createdAt": "2020-07-25T19:20:02Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ0MzE0OA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460443148", "bodyText": "I think we should ignore the class in the setup routine if there's a possibility that it'll all be flaky.", "author": "david-allison-1", "createdAt": "2020-07-25T20:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYxNzY0Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460617643", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-07-27T02:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4OTA1Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463289056", "bodyText": "I don't see the setUp ignore if we're close to the cutoff.\nWe'll want to sort this one out as soon as possible as it means we're not running high-impact tests at a certain time of day - I've made it possible to inject a time dependency into SchedV2, this is one of the ones that I feel might be worth blocking merge over.\n@mikehardy Any thoughts?", "author": "david-allison-1", "createdAt": "2020-07-30T21:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2MzA4NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463963084", "bodyText": "\"blocking merge\" ?\u00a0You mean that you feel that it's worth not merging any of those test because of this condition ?\nBy the way, you added mTime in SchedV2 but it's also sometime used in sched V1. Because sched V1\u00a0inherits from V2, and some methods using mTime are not overriden. Which means that currently, schedv1 potentially uses two distinct timer (even if in practice, they both reflect real time)", "author": "Arthur-Milchior", "createdAt": "2020-08-01T13:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMTE2NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464101165", "bodyText": "We're fine as mTime is just an abstraction used for testing.\nIt does need to be expanded to include SchedV1, but I'd be much more comfortable refactoring while I'm adding tests, rather than refactoring for future testability. I'm not totally comfortable with just the refactoring, as there's nothing checking that all uses of the system clock were caught.\nHaving a class that hasn't been converted leaves an obvious solution the next person coming along writing tests. Having a class with all but one dependency converted (because the conversion missed something, and there wasn't a test) can waste a lot more time.", "author": "david-allison-1", "createdAt": "2020-08-02T17:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMTQyOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464101428", "bodyText": "Say someone submits a PR at the time that these tests are ignored. This PR breaks the tests, but nobody knows.\nTravis goes green, the code gets merged, and the next build for Travis fails due to this. - We've got a flaky build.\nIgnoring tests unconditionally isn't great, but it's better than the alternatives. Ignoring tests conditionally can lead to a flaky build, which is what we want to ignore. I feel this is a candidate for \"get it fixed before it goes in\", especially as this change is a single commit and rollbacks would be tricky.", "author": "david-allison-1", "createdAt": "2020-08-02T17:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwNDg4Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464104886", "bodyText": "I understand that you prefer not to incorporate those tests. I could simply comment them until we have a way to ensure that we always uses a false clock with a specified time. i don't understand why you would want to block the whole merge over it.\n\nI don't see the setUp ignore if we're close to the cutoff.\n\nI'm sorry but on second thought I don't understand what you means here. Are you implying it should obviously be here and you're making a comment about the fact that there is an obvious problem ?\nI may imagine you would want a system similar to the one for the tests on real phone with sched v1/v2; Except that using such a system would be flaky here and so would not be appropriate.\nMore generally, it seems you know what you want here. Aren't you loosing time making such comments instead of doing the change yourself ? It seems to me that, as you know the code and the codebase, it would be quite quicker to do the change than to explain them to a human", "author": "Arthur-Milchior", "createdAt": "2020-08-02T17:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE2MzI0Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464163243", "bodyText": "Blocking the merge until we have a resolution for an issue in the ported code seems sensible - it's temporary, especially as we're dealing with a large commit that wouldn't be easy to revert after time passes.\nI don't know how we want to go about solving it, it's the main thing stopping the tests going in, and it's worth discussing options:\n\nComment out the tests - possible but not ideal, as we lose out on testing the scheduler, which is the most significant benefit of this PR\nFix the time dependency - feasible, but could lower the quality of the tests if we don't understand the implications. Unknown time scale on implementation.\nLeave the tests in as is - nonstarter - flaky\nconvert the exception to an ignore in setUp - some risk of a flaky build - disables the previous tests in the file as well around the cutoff\n\n\\2. seems like the best option to me, but I'm more than open to other suggestions to get this unblocked. If there's any action you'd like me to take to help on this tomorrow, let me know", "author": "david-allison-1", "createdAt": "2020-08-03T02:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MzExOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464493119", "bodyText": "For option 2 - \"inject a controlled testing time into the scheduler\" - I think the fastest solution is for @david-allison-1 to either post almost-working code to do this as testing and that injected time are your strong points, or to pull the branch and actually push a commit that does it (with coordination on the branch from @Arthur-Milchior so you don't conflict on the effort). This may be quick work vs extended comment discussion, and would show exactly how to do it for future\nIf that is not acceptable I am open to 4 - \"if we are near the cutoff when the tests run, ignore this test\", especially in conjunction with a cron run of CI on master that can be configured away from the cutoff (and a comment can be put in the test mentioning that there is a cron job scheduled to run daily that executes at - I think based on the last run - approximately 1900UTC). I believe this is the quick solution if option 2 is intractable", "author": "mikehardy", "createdAt": "2020-08-03T15:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMTcwMw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465011703", "bodyText": "@Arthur-Milchior - Fixed the time dependency in: https://github.com/david-allison-1/Anki-Android/commits/upstream-test\nFeel free to rebase the change into your branch - I'd rather not cause conflicts.", "author": "david-allison-1", "createdAt": "2020-08-04T12:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0ODgzMA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465148830", "bodyText": "thanks a lot for taking care of it.\nDo you know why the different scheds uses different way to get time ?\u00a0It does not seems that switching to mTime in sched V1 seems hard work either", "author": "Arthur-Milchior", "createdAt": "2020-08-04T15:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NzI3NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465187275", "bodyText": "It'll be easy to miss something -  I (or someone else will) get around to it in the future, but I won't be giving it appropriate due care and attention if I'm doing work for SchedV2.", "author": "david-allison-1", "createdAt": "2020-08-04T16:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTkwOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460435909", "bodyText": "ditto - ignore", "author": "david-allison-1", "createdAt": "2020-07-25T19:22:54Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+    }\n+\n+\n+    @Test\n+    public void test_new_v2() throws Exception {\n+        Collection col = getColV2();\n+        col.reset();\n+        // assertEquals(0, col.getSched().newCount);TODO: newCount getter\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount);TODO: newCount getter\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V2() throws Exception {\n+        Collection col = getColV2();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        for (int i = 0; i < 30; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount);TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        // assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 3 minutes\n+        double dueIn = c.getDue() - Utils.now();\n+        assertTrue(178 <= dueIn && dueIn <= 180 * 1.25);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(3, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 10 minutes\n+        dueIn = c.getDue() - Utils.now();\n+        assertTrue(599 <= dueIn && dueIn <= 600 * 1.25);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+    }\n+\n+\n+    @Test\n+    public void test_relearn() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(1, c.getIvl());\n+\n+        // immediately graduate it\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(2, c.getIvl());\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_relearn_no_steps() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV2() throws Exception {\n+        Collection col = getColV2();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 3);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 3);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 3));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // try with an ease of 2\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.reset();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100) * 1.2 = 120\n+        assertTrue(checkRevIvl(col, c, 120));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+        // leech handling\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        DeckConfig conf = col.getDecks().getConf(1);\n+        conf.getJSONObject(\"lapse\").put(\"leechAction\", LEECH_SUSPEND);\n+        col.getDecks().save(conf);\n+        c = cardcopy.clone();\n+        c.setLapses(7);\n+        c.flush();\n+        /* todo hook\n+        // steup hook\n+        hooked = new [] {};\n+        \n+        def onLeech(card):\n+        hooked.append(1);\n+        \n+        hooks.card_did_leech.append(onLeech);\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(hooked);\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        */\n+    }\n+\n+\n+    @Test\n+    public void test_review_limits() throws Exception {\n+        Collection col = getColV2();\n+\n+        Deck parent = col.getDecks().get(col.getDecks().id(\"parent\"));\n+        Deck child = col.getDecks().get(col.getDecks().id(\"parent::child\"));\n+\n+        DeckConfig pconf = col.getDecks().getConf(col.getDecks().confId(\"parentConf\"));\n+        DeckConfig cconf = col.getDecks().getConf(col.getDecks().confId(\"childConf\"));\n+\n+        pconf.getJSONObject(\"rev\").put(\"perDay\", 5);\n+        col.getDecks().updateConf(pconf);\n+        col.getDecks().setConf(parent, pconf.getLong(\"id\"));\n+        cconf.getJSONObject(\"rev\").put(\"perDay\", 10);\n+        col.getDecks().updateConf(cconf);\n+        col.getDecks().setConf(child, cconf.getLong(\"id\"));\n+\n+        Model m = col.getModels().current();\n+        m.put(\"did\", child.getLong(\"id\"));\n+        col.getModels().save(m, false);\n+\n+        // add some cards\n+        for (int i = 0; i < 20; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", \"one\");\n+            note.setItem(\"Back\", \"two\");\n+            col.addNote(note);\n+\n+            // make them reviews\n+            Card c = note.cards().get(0);\n+            c.setQueue(CARD_TYPE_REV);\n+            c.setType(QUEUE_TYPE_REV);\n+            c.setDue(0);\n+            c.flush();\n+        }\n+\n+        // position 0 is default deck. Different from upstream\n+        AbstractSched.DeckDueTreeNode tree = col.getSched().deckDueTree().get(1);\n+        // (('parent', 1514457677462, 5, 0, 0, (('child', 1514457677463, 5, 0, 0, ()),)))\n+        assertEquals(\"parent\", tree.getFullDeckName());\n+        assertEquals(5, tree.getRevCount());  // paren, tree.review_count)t\n+        assertEquals(5, tree.getChildren().get(0).getRevCount());\n+\n+        // .counts() should match\n+        col.getDecks().select(child.getLong(\"id\"));\n+        col.getSched().reset();\n+        assertArrayEquals(new int[] {0, 0, 5}, col.getSched().counts());\n+\n+        // answering a card in the child should decrement parent count\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 0, 4}, col.getSched().counts());\n+\n+        tree = col.getSched().deckDueTree().get(1);\n+        assertEquals(4, tree.getRevCount());\n+        assertEquals(4, tree.getChildren().get(0).getRevCount());\n+    }\n+\n+\n+    @Test\n+    public void test_button_spacingV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+\n+        // if hard factor is <= 1, then hard may not increase\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"rev\").put(\"hardFactor\", 1);\n+        col.getDecks().save(conf);\n+        assertEquals(\"1 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n     }\n \n \n+    @Test\n+    public void test_overdue_lapseV2() throws Exception {\n+        // disabled in commit 3069729776990980f34c25be66410e947e9d51a2", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYxNzczNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460617737", "bodyText": "Done", "author": "Arthur-Milchior", "createdAt": "2020-07-27T02:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460436461", "bodyText": "Let's keep parity with upstream, and ignore the test for now", "author": "david-allison-1", "createdAt": "2020-07-25T19:29:20Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+    }\n+\n+\n+    @Test\n+    public void test_new_v2() throws Exception {\n+        Collection col = getColV2();\n+        col.reset();\n+        // assertEquals(0, col.getSched().newCount);TODO: newCount getter\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount);TODO: newCount getter\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V2() throws Exception {\n+        Collection col = getColV2();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        for (int i = 0; i < 30; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount);TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        // assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 3 minutes\n+        double dueIn = c.getDue() - Utils.now();\n+        assertTrue(178 <= dueIn && dueIn <= 180 * 1.25);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(3, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 10 minutes\n+        dueIn = c.getDue() - Utils.now();\n+        assertTrue(599 <= dueIn && dueIn <= 600 * 1.25);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+    }\n+\n+\n+    @Test\n+    public void test_relearn() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(1, c.getIvl());\n+\n+        // immediately graduate it\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(2, c.getIvl());\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_relearn_no_steps() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV2() throws Exception {\n+        Collection col = getColV2();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 3);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 3);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 3));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // try with an ease of 2\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.reset();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100) * 1.2 = 120\n+        assertTrue(checkRevIvl(col, c, 120));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+        // leech handling\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        DeckConfig conf = col.getDecks().getConf(1);\n+        conf.getJSONObject(\"lapse\").put(\"leechAction\", LEECH_SUSPEND);\n+        col.getDecks().save(conf);\n+        c = cardcopy.clone();\n+        c.setLapses(7);\n+        c.flush();\n+        /* todo hook\n+        // steup hook\n+        hooked = new [] {};\n+        \n+        def onLeech(card):\n+        hooked.append(1);\n+        \n+        hooks.card_did_leech.append(onLeech);\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(hooked);\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        */\n+    }\n+\n+\n+    @Test\n+    public void test_review_limits() throws Exception {\n+        Collection col = getColV2();\n+\n+        Deck parent = col.getDecks().get(col.getDecks().id(\"parent\"));\n+        Deck child = col.getDecks().get(col.getDecks().id(\"parent::child\"));\n+\n+        DeckConfig pconf = col.getDecks().getConf(col.getDecks().confId(\"parentConf\"));\n+        DeckConfig cconf = col.getDecks().getConf(col.getDecks().confId(\"childConf\"));\n+\n+        pconf.getJSONObject(\"rev\").put(\"perDay\", 5);\n+        col.getDecks().updateConf(pconf);\n+        col.getDecks().setConf(parent, pconf.getLong(\"id\"));\n+        cconf.getJSONObject(\"rev\").put(\"perDay\", 10);\n+        col.getDecks().updateConf(cconf);\n+        col.getDecks().setConf(child, cconf.getLong(\"id\"));\n+\n+        Model m = col.getModels().current();\n+        m.put(\"did\", child.getLong(\"id\"));\n+        col.getModels().save(m, false);\n+\n+        // add some cards\n+        for (int i = 0; i < 20; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", \"one\");\n+            note.setItem(\"Back\", \"two\");\n+            col.addNote(note);\n+\n+            // make them reviews\n+            Card c = note.cards().get(0);\n+            c.setQueue(CARD_TYPE_REV);\n+            c.setType(QUEUE_TYPE_REV);\n+            c.setDue(0);\n+            c.flush();\n+        }\n+\n+        // position 0 is default deck. Different from upstream\n+        AbstractSched.DeckDueTreeNode tree = col.getSched().deckDueTree().get(1);\n+        // (('parent', 1514457677462, 5, 0, 0, (('child', 1514457677463, 5, 0, 0, ()),)))\n+        assertEquals(\"parent\", tree.getFullDeckName());\n+        assertEquals(5, tree.getRevCount());  // paren, tree.review_count)t\n+        assertEquals(5, tree.getChildren().get(0).getRevCount());\n+\n+        // .counts() should match\n+        col.getDecks().select(child.getLong(\"id\"));\n+        col.getSched().reset();\n+        assertArrayEquals(new int[] {0, 0, 5}, col.getSched().counts());\n+\n+        // answering a card in the child should decrement parent count\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 0, 4}, col.getSched().counts());\n+\n+        tree = col.getSched().deckDueTree().get(1);\n+        assertEquals(4, tree.getRevCount());\n+        assertEquals(4, tree.getChildren().get(0).getRevCount());\n+    }\n+\n+\n+    @Test\n+    public void test_button_spacingV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+\n+        // if hard factor is <= 1, then hard may not increase\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"rev\").put(\"hardFactor\", 1);\n+        col.getDecks().save(conf);\n+        assertEquals(\"1 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n     }\n \n \n+    @Test\n+    public void test_overdue_lapseV2() throws Exception {\n+        // disabled in commit 3069729776990980f34c25be66410e947e9d51a2\n+        return;\n+        /* Upstream does not execute it\n+           Collection col = getColV2()  // pylint: disable=unreachable\n+           // add a note\n+           Note note = col.newNote();\n+           note.setItem(\"Front\",\"one\");\n+           col.addNote(note);\n+           // simulate a review that was lapsed and is now due for its normal review\n+           Card c = note.cards().get(0);\n+           c.setType(CARD_TYPE_REV);\n+           c.setQueue(QUEUE_TYPE_LRN);\n+           c.setDue(-1);\n+           c.setODue(-1);\n+           c.setFactor(STARTING_FACTOR);\n+           c.setLeft(2002);\n+           c.setIvl(0);\n+           c.flush();\n+           // checkpoint\n+           col.save();\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 2, 0}, col.getSched().counts());\n+           c = col.getSched().getCard();\n+           col.getSched().answerCard(c, 3);\n+           // it should be due tomorrow\n+           assertEquals(col.getSched().getToday()+ 1, c.getDue());\n+           // revert to before\n+           /* todo: rollback\n+           col.rollback();\n+           // with the default settings, the overdue card should be removed from the\n+           // learning queue\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 0, 1}, col.getSched().counts());\n+        */\n+\n+    }\n+\n+\n+    @Test\n+    public void test_finishedV2() throws Exception {\n+        Collection col = getColV2();\n+        // nothing due\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // have a new card\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"new cards available\"));\n+        // turn it into a review\n+        col.reset();\n+        Card c = note.cards().get(0);\n+        c.startTimer();\n+        col.getSched().answerCard(c, 3);\n+        // nothing should be due tomorrow, as it's due in a week\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+    }\n+\n+\n+    @Test\n+    public void test_nextIvlV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1, 5, 9}));\n+        col.getDecks().save(conf);\n+        Card c = col.getSched().getCard();\n+        // new cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 1);\n+        // cards in learning\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((180 + 600) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(600, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        // normal graduation is tomorrow\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        // lapsed cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setType(CARD_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        assertEquals(100 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(101 * 86400, col.getSched().nextIvl(c, 4));\n+        // review cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        // failing it should put it at 60s\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        // or 1 day if relearn is false\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 1));\n+        // (* 100 1.2 86400)10368000.0\n+        assertEquals(10368000, col.getSched().nextIvl(c, 2));\n+        // (* 100 2.5 86400)21600000.0\n+        assertEquals(21600000, col.getSched().nextIvl(c, 3));\n+        // (* 100 2.5 1.3 86400)28080000.0\n+        assertEquals(28080000, col.getSched().nextIvl(c, 4));\n+        // TODO: upstream is 10.8, try to understand the difference\n+        assertEquals(\"10.7 mo\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYxODE5Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460618192", "bodyText": "I don't get it. I mean, if we did ignore the whole tests then if anything break we won't see it. While this contains already a lot of interesting equals that works.\nIn this case, simply commenting this line would make more sens if you care that much.\nSince it's a rounding question anyway, I would not expect it to have any interest here", "author": "Arthur-Milchior", "createdAt": "2020-07-27T02:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4OTU3Ng==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463289576", "bodyText": "True: better as an assume Not Implemented at this location", "author": "david-allison-1", "createdAt": "2020-07-30T21:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2Mjg3MQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463962871", "bodyText": "Sorry, I've no idea what it means. \"assume Not Implemented\" does not seems to be valid code. Android studio autocomplete NotImplemented with Kotlin only, which we don't use.\nAnd, anyway, we are only considering a rounding error here. I believe this test is still useful. Even if upstream round to the nearest value and we floor the value, it does not really matter. What matters is that we have 10.7 or 10.8 and not 2 or 294 mont or 3\u00a0days... if at some point we \"repair\" and uses \"round\" instead of \"floor\" and this test fails, the comment will be enough to understand that it is an acceptable thing to change", "author": "Arthur-Milchior", "createdAt": "2020-08-01T13:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMDQ4NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464100485", "bodyText": "How about:\nassumeThat(without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)), either(is(\"10.7\")).or(is(\"10.8\")));\nassumeTrue(\"Investigate this difference: Anki displays 10.8, we display 10.7\", false);\nThe \"Investigate\" line could even go at the end of the test if the rest of the code works.\nWe lose a lot of value from these tests if we're not matching the API of Anki Desktop", "author": "david-allison-1", "createdAt": "2020-08-02T17:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwNDIxMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464104211", "bodyText": "Tests work on my computer with\nassumeThat(\"Investigate this difference\", col.getSched().nextIvl(c, 3), is(((long)(75 * 2.5)) * 86400));\n\nHowever, on travis, it leads to:\n\n   Caused by:\n   org.junit.AssumptionViolatedException: Investigate this difference: got: <12960000L>, expected: is <16156800L>\n       at org.junit.Assume.assumeThat(Assume.java:129)\n       at com.ichi2.libanki.sched.SchedV2Test.test_filt_reviewing_early_normal(SchedV2Test.java:973)", "author": "Arthur-Milchior", "createdAt": "2020-08-02T17:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTAwNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464581004", "bodyText": "I added the lines you gave. With \"mo\" at the end of the string, otherwise it obviously fails", "author": "Arthur-Milchior", "createdAt": "2020-08-03T18:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTQ3NA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464581474", "bodyText": "I should note that this is seen as a failure on my computer and states the test fails", "author": "Arthur-Milchior", "createdAt": "2020-08-03T18:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkzNjEwNQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464936105", "bodyText": "org.junit.AssumptionViolatedException: Investigate this difference: Anki displays 10.8, we display 10.7\n\nAccording to travis. So I believe the line is not actually what we wanted", "author": "Arthur-Milchior", "createdAt": "2020-08-04T09:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAwODcwMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465008701", "bodyText": "That seems to be a Robolectric problem - add this.advanceRobolectricLooper(); before the assume and the test will be ignored.\nWe likely want to override the method in RobolectricTest", "author": "david-allison-1", "createdAt": "2020-08-04T12:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNzYzNA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465137634", "bodyText": "Done. Seems to work, tanks", "author": "Arthur-Milchior", "createdAt": "2020-08-04T15:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjU2NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460436565", "bodyText": "flagging - might want to ignore here", "author": "david-allison-1", "createdAt": "2020-07-25T19:30:22Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+    }\n+\n+\n+    @Test\n+    public void test_new_v2() throws Exception {\n+        Collection col = getColV2();\n+        col.reset();\n+        // assertEquals(0, col.getSched().newCount);TODO: newCount getter\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount);TODO: newCount getter\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V2() throws Exception {\n+        Collection col = getColV2();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        for (int i = 0; i < 30; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount);TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        // assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 3 minutes\n+        double dueIn = c.getDue() - Utils.now();\n+        assertTrue(178 <= dueIn && dueIn <= 180 * 1.25);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(3, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 10 minutes\n+        dueIn = c.getDue() - Utils.now();\n+        assertTrue(599 <= dueIn && dueIn <= 600 * 1.25);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+    }\n+\n+\n+    @Test\n+    public void test_relearn() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(1, c.getIvl());\n+\n+        // immediately graduate it\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(2, c.getIvl());\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_relearn_no_steps() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV2() throws Exception {\n+        Collection col = getColV2();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 3);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 3);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 3));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // try with an ease of 2\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.reset();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100) * 1.2 = 120\n+        assertTrue(checkRevIvl(col, c, 120));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+        // leech handling\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        DeckConfig conf = col.getDecks().getConf(1);\n+        conf.getJSONObject(\"lapse\").put(\"leechAction\", LEECH_SUSPEND);\n+        col.getDecks().save(conf);\n+        c = cardcopy.clone();\n+        c.setLapses(7);\n+        c.flush();\n+        /* todo hook\n+        // steup hook\n+        hooked = new [] {};\n+        \n+        def onLeech(card):\n+        hooked.append(1);\n+        \n+        hooks.card_did_leech.append(onLeech);\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(hooked);\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        */\n+    }\n+\n+\n+    @Test\n+    public void test_review_limits() throws Exception {\n+        Collection col = getColV2();\n+\n+        Deck parent = col.getDecks().get(col.getDecks().id(\"parent\"));\n+        Deck child = col.getDecks().get(col.getDecks().id(\"parent::child\"));\n+\n+        DeckConfig pconf = col.getDecks().getConf(col.getDecks().confId(\"parentConf\"));\n+        DeckConfig cconf = col.getDecks().getConf(col.getDecks().confId(\"childConf\"));\n+\n+        pconf.getJSONObject(\"rev\").put(\"perDay\", 5);\n+        col.getDecks().updateConf(pconf);\n+        col.getDecks().setConf(parent, pconf.getLong(\"id\"));\n+        cconf.getJSONObject(\"rev\").put(\"perDay\", 10);\n+        col.getDecks().updateConf(cconf);\n+        col.getDecks().setConf(child, cconf.getLong(\"id\"));\n+\n+        Model m = col.getModels().current();\n+        m.put(\"did\", child.getLong(\"id\"));\n+        col.getModels().save(m, false);\n+\n+        // add some cards\n+        for (int i = 0; i < 20; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", \"one\");\n+            note.setItem(\"Back\", \"two\");\n+            col.addNote(note);\n+\n+            // make them reviews\n+            Card c = note.cards().get(0);\n+            c.setQueue(CARD_TYPE_REV);\n+            c.setType(QUEUE_TYPE_REV);\n+            c.setDue(0);\n+            c.flush();\n+        }\n+\n+        // position 0 is default deck. Different from upstream\n+        AbstractSched.DeckDueTreeNode tree = col.getSched().deckDueTree().get(1);\n+        // (('parent', 1514457677462, 5, 0, 0, (('child', 1514457677463, 5, 0, 0, ()),)))\n+        assertEquals(\"parent\", tree.getFullDeckName());\n+        assertEquals(5, tree.getRevCount());  // paren, tree.review_count)t\n+        assertEquals(5, tree.getChildren().get(0).getRevCount());\n+\n+        // .counts() should match\n+        col.getDecks().select(child.getLong(\"id\"));\n+        col.getSched().reset();\n+        assertArrayEquals(new int[] {0, 0, 5}, col.getSched().counts());\n+\n+        // answering a card in the child should decrement parent count\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 0, 4}, col.getSched().counts());\n+\n+        tree = col.getSched().deckDueTree().get(1);\n+        assertEquals(4, tree.getRevCount());\n+        assertEquals(4, tree.getChildren().get(0).getRevCount());\n+    }\n+\n+\n+    @Test\n+    public void test_button_spacingV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+\n+        // if hard factor is <= 1, then hard may not increase\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"rev\").put(\"hardFactor\", 1);\n+        col.getDecks().save(conf);\n+        assertEquals(\"1 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n     }\n \n \n+    @Test\n+    public void test_overdue_lapseV2() throws Exception {\n+        // disabled in commit 3069729776990980f34c25be66410e947e9d51a2\n+        return;\n+        /* Upstream does not execute it\n+           Collection col = getColV2()  // pylint: disable=unreachable\n+           // add a note\n+           Note note = col.newNote();\n+           note.setItem(\"Front\",\"one\");\n+           col.addNote(note);\n+           // simulate a review that was lapsed and is now due for its normal review\n+           Card c = note.cards().get(0);\n+           c.setType(CARD_TYPE_REV);\n+           c.setQueue(QUEUE_TYPE_LRN);\n+           c.setDue(-1);\n+           c.setODue(-1);\n+           c.setFactor(STARTING_FACTOR);\n+           c.setLeft(2002);\n+           c.setIvl(0);\n+           c.flush();\n+           // checkpoint\n+           col.save();\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 2, 0}, col.getSched().counts());\n+           c = col.getSched().getCard();\n+           col.getSched().answerCard(c, 3);\n+           // it should be due tomorrow\n+           assertEquals(col.getSched().getToday()+ 1, c.getDue());\n+           // revert to before\n+           /* todo: rollback\n+           col.rollback();\n+           // with the default settings, the overdue card should be removed from the\n+           // learning queue\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 0, 1}, col.getSched().counts());\n+        */\n+\n+    }\n+\n+\n+    @Test\n+    public void test_finishedV2() throws Exception {\n+        Collection col = getColV2();\n+        // nothing due\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // have a new card\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"new cards available\"));\n+        // turn it into a review\n+        col.reset();\n+        Card c = note.cards().get(0);\n+        c.startTimer();\n+        col.getSched().answerCard(c, 3);\n+        // nothing should be due tomorrow, as it's due in a week\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+    }\n+\n+\n+    @Test\n+    public void test_nextIvlV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1, 5, 9}));\n+        col.getDecks().save(conf);\n+        Card c = col.getSched().getCard();\n+        // new cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 1);\n+        // cards in learning\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((180 + 600) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(600, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        // normal graduation is tomorrow\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        // lapsed cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setType(CARD_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        assertEquals(100 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(101 * 86400, col.getSched().nextIvl(c, 4));\n+        // review cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        // failing it should put it at 60s\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        // or 1 day if relearn is false\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 1));\n+        // (* 100 1.2 86400)10368000.0\n+        assertEquals(10368000, col.getSched().nextIvl(c, 2));\n+        // (* 100 2.5 86400)21600000.0\n+        assertEquals(21600000, col.getSched().nextIvl(c, 3));\n+        // (* 100 2.5 1.3 86400)28080000.0\n+        assertEquals(28080000, col.getSched().nextIvl(c, 4));\n+        // TODO: upstream is 10.8, try to understand the difference\n+        assertEquals(\"10.7 mo\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+    }\n+\n+\n+    @Test\n+    public void test_bury() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"two\");\n+        col.addNote(note);\n+        Card c2 = note.cards().get(0);\n+        // burying\n+        col.getSched().buryCards(new long[] {c.getId()}, true);\n+        c.load();\n+        assertEquals(QUEUE_TYPE_MANUALLY_BURIED, c.getQueue());\n+        col.getSched().buryCards(new long[] {c2.getId()}, false);\n+        c2.load();\n+        assertEquals(QUEUE_TYPE_SIBLING_BURIED, c2.getQueue());\n+\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+\n+        col.getSched().unburyCardsForDeck(AbstractSched.UnburyType.MANUAL);\n+        c.load();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        c2.load();\n+        assertEquals(QUEUE_TYPE_SIBLING_BURIED, c2.getQueue());\n+\n+        col.getSched().unburyCardsForDeck(AbstractSched.UnburyType.SIBLINGS);\n+        c2.load();\n+        assertEquals(QUEUE_TYPE_NEW, c2.getQueue());\n+\n+        col.getSched().buryCards(new long[] {c.getId(), c2.getId()});\n+        col.getSched().unburyCardsForDeck(AbstractSched.UnburyType.ALL);\n+\n+        col.reset();\n+\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_suspendv2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        // suspending\n+        col.reset();\n+        assertNotNull(col.getSched().getCard());\n+        col.getSched().suspendCards(new long[] {c.getId()});\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+        // unsuspending\n+        col.getSched().unsuspendCards(new long[] {c.getId()});\n+        col.reset();\n+        assertNotNull(col.getSched().getCard());\n+        // should cope with rev cards being relearnt\n+        c.setDue(0);\n+        c.setIvl(100);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.flush();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(c.getDue() >= Utils.now());\n+        long due = c.getDue();\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        col.getSched().suspendCards(new long[] {c.getId()});\n+        col.getSched().unsuspendCards(new long[] {c.getId()});\n+        c.load();\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(due, c.getDue());\n+        // should cope with cards in cram decks\n+        c.setDue(1);\n+        c.flush();\n+        col.getDecks().newDyn(\"tmp\");\n+        col.getSched().rebuildDyn();\n+        c.load();\n+        assertNotEquals(1, c.getDue());\n+        assertNotEquals(1, c.getDid());\n+        col.getSched().suspendCards(new long[] {c.getId()});\n+        c.load();\n+        assertNotEquals(1, c.getDue());\n+        assertNotEquals(1, c.getDid());\n+        assertEquals(1, c.getODue());\n+    }\n+\n+\n+    @Test\n+    public void test_filt_reviewing_early_normal() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        // due in 25 days, so it's been waiting 75 days\n+        c.setDue(col.getSched().getToday() + 25);\n+        c.setMod(1);\n+        c.setFactor(STARTING_FACTOR);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+        // create a dynamic deck and refresh it\n+        long did = col.getDecks().newDyn(\"Cram\");\n+        col.getSched().rebuildDyn(did);\n+        col.reset();\n+        // should appear as normal in the deck list\n+        /* todo sort\n+           assertEquals(1, sorted(col.getSched().deckDueTree().getChildren())[0].review_count);\n+        */\n+        // and should appear in the counts\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        // grab it and check estimates\n+        c = col.getSched().getCard();\n+        assertEquals(4, col.getSched().answerButtons(c));\n+        assertEquals(600, col.getSched().nextIvl(c, 1));\n+        assertEquals(Math.round(75 * 1.2) * 86400, col.getSched().nextIvl(c, 2));\n+        /* TODO: Investigate this difference", "originalCommit": "a74f9f92032777f428b26b339caf53bdc302345c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk2MjYxMQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r463962611", "bodyText": "I'm sorry, but I really don't understand what this kind of comments mean. Are you asking me to flag something ?\u00a0Are you taking personal note for later. Are you telling me to ignore the whole test ?", "author": "Arthur-Milchior", "createdAt": "2020-08-01T13:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA5OTA2Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464099067", "bodyText": "I'm flagging that you might want to ignore the test via assumeThat(\"Investigate this difference\", false) so a future reader would know that there is an issue with the test and that all cases didn't pass", "author": "david-allison-1", "createdAt": "2020-08-02T16:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMDE5Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464100192", "bodyText": "Done, I think.\nExcept that assumeThat takes a matcher and not a boolean", "author": "Arthur-Milchior", "createdAt": "2020-08-02T17:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMTU3Mg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464101572", "bodyText": "Ah, yes, apologies. assumeTrue, or assumeThat(\"\", true, is(false))\"", "author": "david-allison-1", "createdAt": "2020-08-02T17:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjU2NQ=="}], "type": "inlineReview"}, {"oid": "84a83e215ae8ec591b110dc0c351543c7c9221eb", "url": "https://github.com/ankidroid/Anki-Android/commit/84a83e215ae8ec591b110dc0c351543c7c9221eb", "message": "Upstream libanki tests", "committedDate": "2020-07-27T02:41:24Z", "type": "forcePushed"}, {"oid": "db23af9deff12e5db3cdc73155ddd6abd52324ba", "url": "https://github.com/ankidroid/Anki-Android/commit/db23af9deff12e5db3cdc73155ddd6abd52324ba", "message": "Upstream libanki tests", "committedDate": "2020-07-28T12:22:11Z", "type": "forcePushed"}, {"oid": "1af03a1a4a0477aa6ab60844846f6a09a264f835", "url": "https://github.com/ankidroid/Anki-Android/commit/1af03a1a4a0477aa6ab60844846f6a09a264f835", "message": "NF: upstream test", "committedDate": "2020-08-01T13:45:32Z", "type": "forcePushed"}, {"oid": "0f3e26eb70edc3c744068f4e34fb261eaab26882", "url": "https://github.com/ankidroid/Anki-Android/commit/0f3e26eb70edc3c744068f4e34fb261eaab26882", "message": "NF: upstream test", "committedDate": "2020-08-01T13:46:50Z", "type": "forcePushed"}, {"oid": "c9e737d047dd18953e580a72bfa261ab64dd34ce", "url": "https://github.com/ankidroid/Anki-Android/commit/c9e737d047dd18953e580a72bfa261ab64dd34ce", "message": "NF: upstream test", "committedDate": "2020-08-01T13:55:47Z", "type": "forcePushed"}, {"oid": "5bc11ccd93bd9da970c3d85b7eb297f1ab600c3e", "url": "https://github.com/ankidroid/Anki-Android/commit/5bc11ccd93bd9da970c3d85b7eb297f1ab600c3e", "message": "NF: upstream test", "committedDate": "2020-08-02T17:04:52Z", "type": "forcePushed"}, {"oid": "327897a0592a09e9258d21338476e5245d29fee0", "url": "https://github.com/ankidroid/Anki-Android/commit/327897a0592a09e9258d21338476e5245d29fee0", "message": "NF: upstream test", "committedDate": "2020-08-03T18:12:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwODUzMg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464908532", "bodyText": "shouldn't this have a getColV2", "author": "david-allison-1", "createdAt": "2020-08-04T09:05:20Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +185,1428 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();", "originalCommit": "327897a0592a09e9258d21338476e5245d29fee0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDk4MjI3OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464982279", "bodyText": "I didn't even know it exists", "author": "Arthur-Milchior", "createdAt": "2020-08-04T11:28:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwODUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTAxMTQ0Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465011447", "bodyText": "It was added by this commit", "author": "david-allison-1", "createdAt": "2020-08-04T12:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwODUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMzQwOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465133409", "bodyText": "I'm feeling silly now", "author": "Arthur-Milchior", "createdAt": "2020-08-04T15:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwODUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0ODU5Mw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465148593", "bodyText": "5000 lines is enough to make anyone forget (especially if it's autogenerated)!", "author": "david-allison-1", "createdAt": "2020-08-04T15:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwODUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1NjczOA==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465156738", "bodyText": "This one probably one of the few no autogenerated line", "author": "Arthur-Milchior", "createdAt": "2020-08-04T15:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwODUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwOTAxOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464909019", "bodyText": "getColV2?", "author": "david-allison-1", "createdAt": "2020-08-04T09:06:12Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +185,1428 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    @Ignore(\"Risks to be flaky in CI\")\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();", "originalCommit": "327897a0592a09e9258d21338476e5245d29fee0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMjUxNw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465132517", "bodyText": "Done. Thanks", "author": "Arthur-Milchior", "createdAt": "2020-08-04T15:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwOTAxOQ=="}], "type": "inlineReview"}, {"oid": "3433e045e0e27402c5056aceeecc069167017514", "url": "https://github.com/ankidroid/Anki-Android/commit/3433e045e0e27402c5056aceeecc069167017514", "message": "Please Squash - fix the clock to avoid the day cutoff", "committedDate": "2020-08-04T15:34:38Z", "type": "forcePushed"}, {"oid": "a8d5f83aaa6d1628d4ca6d7bd3027fcffc5da9fa", "url": "https://github.com/ankidroid/Anki-Android/commit/a8d5f83aaa6d1628d4ca6d7bd3027fcffc5da9fa", "message": "Please Squash - fix the clock to avoid the day cutoff", "committedDate": "2020-08-04T15:43:00Z", "type": "forcePushed"}, {"oid": "4adac09acf50fb7b1d9bab12e070ef4e6bd5390e", "url": "https://github.com/ankidroid/Anki-Android/commit/4adac09acf50fb7b1d9bab12e070ef4e6bd5390e", "message": "Please Squash - fix the clock to avoid the day cutoff", "committedDate": "2020-08-04T15:43:33Z", "type": "forcePushed"}, {"oid": "36e8a2891f99c483c64f9c760c3592ba9423ee6d", "url": "https://github.com/ankidroid/Anki-Android/commit/36e8a2891f99c483c64f9c760c3592ba9423ee6d", "message": "Please Squash - fix the clock to avoid the day cutoff", "committedDate": "2020-08-04T15:54:11Z", "type": "forcePushed"}, {"oid": "55fe489094fb330c234c5b329664220e778d2b49", "url": "https://github.com/ankidroid/Anki-Android/commit/55fe489094fb330c234c5b329664220e778d2b49", "message": "Please Squash - fix the clock to avoid the day cutoff", "committedDate": "2020-08-04T17:02:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNTgzNg==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465205836", "bodyText": "(Optional) It would be helpful to extract assumeThat() and assumeX this code into RobolectricTest so we always get this behaviour.", "author": "david-allison-1", "createdAt": "2020-08-04T17:16:26Z", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UndoTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.COUNT_REMAINING;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_LRN;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_NEW;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assume.assumeThat;\n+\n+\n+@RunWith(AndroidJUnit4.class)\n+public class UndoTest extends RobolectricTest {\n+    /*****************\n+     ** Undo         *\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    @Ignore(\"We need to figure out how to test save/undo\")\n+    public void test_op() throws Exception {\n+        Collection col = getColV2();\n+        // should have no undo by default\n+        assertNull(col.undoType());\n+        // let's adjust a study option\n+        col.save(\"studyopts\");\n+        col.getConf().put(\"abc\", 5);\n+        // it should be listed as undoable\n+        assertEquals(\"studyopts\", col.undoName(getTargetContext().getResources()));\n+        // with about 5 minutes until it's clobbered\n+        /* lastSave\n+           assertThat(Utils.now() - col._lastSave, lesserThan(1));\n+        */\n+        // undoing should restore the old value\n+        col.undo();\n+        assertEquals(null, col.undoType());\n+        assertFalse(col.getConf().has(\"abc\"));\n+        // an (auto)save will clear the undo\n+        col.save(\"foo\");\n+        assertEquals(\"foo\", col.undoName(getTargetContext().getResources()));\n+        col.save();\n+        assertEquals(\"\", col.undoName(getTargetContext().getResources()));\n+        // and a review will, too\n+        col.save(\"add\");\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        assertEquals(\"add\", col.undoName(getTargetContext().getResources()));\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(\"Review\", col.undoName(getTargetContext().getResources()));\n+    }\n+\n+\n+    @Test\n+    public void test_review() throws Exception {\n+        Collection col = getColV2();\n+        col.getConf().put(\"counts\", COUNT_REMAINING);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        /* TODO:\u00a0 undo after reset ?\n+        assertNotNull(col.undoType());\n+\n+         */\n+        // answer\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        Card c = col.getSched().getCard();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(1001, c.getLeft());\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        // undo\n+        assertNotNull(col.undoType());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertNotEquals(1001, c.getLeft());\n+        assertNull(col.undoType());\n+        // we should be able to undo multiple answers too\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 2, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 1, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        // performing a normal op will clear the review queue\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(Collection.DismissType.REVIEW, col.undoType());\n+        col.save(\"foo\");\n+        // Upstream, \"save\" can be undone. This test fails here because it's not the case in AnkiDroid\n+        this.advanceRobolectricLooper();", "originalCommit": "55fe489094fb330c234c5b329664220e778d2b49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMTY1NQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465211655", "bodyText": "Done for the few one I found followed by assume. Not for the one followed by an assert", "author": "Arthur-Milchior", "createdAt": "2020-08-04T17:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNTgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMzI5Nw==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465213297", "bodyText": "Probably should also handle:\nassumeThat(message, x, is(y))\nassumeThat(x, is(y))\nassumeTrue(false)", "author": "david-allison-1", "createdAt": "2020-08-04T17:29:15Z", "path": "AnkiDroid/src/test/java/com/ichi2/anki/RobolectricTest.java", "diffHunk": "@@ -291,4 +295,61 @@ public void onPostExecute(TaskData result) {\n             throw new IllegalStateException(String.format(\"Task %s didn't finish in %d ms\", taskType, timeoutMs));\n         }\n     }\n+    /**\n+     * Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\n+     * If not, the test halts and is ignored.\n+     * Example:\n+     * <pre>:\n+     *   assumeThat(1, is(1)); // passes\n+     *   foo(); // will execute\n+     *   assumeThat(0, is(1)); // assumption failure! test halts\n+     *   int x = 1 / 0; // will never execute\n+     * </pre>\n+     *\n+     * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n+     * @param actual the computed value being compared\n+     * @param matcher an expression, built of {@link Matcher}s, specifying allowed values\n+     * @see org.hamcrest.CoreMatchers\n+     * @see org.junit.matchers.JUnitMatchers\n+     */\n+    public <T> void assumeThat(T actual, Matcher<T> matcher) {\n+        this.advanceRobolectricLooper();\n+        Assume.assumeThat(actual, matcher);\n+    }\n+\n+    /**\n+     * Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\n+     * If not, the test halts and is ignored.\n+     * Example:\n+     * <pre>:\n+     *   assumeThat(\"alwaysPasses\", 1, is(1)); // passes\n+     *   foo(); // will execute\n+     *   assumeThat(\"alwaysFails\", 0, is(1)); // assumption failure! test halts\n+     *   int x = 1 / 0; // will never execute\n+     * </pre>\n+     *\n+     * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n+     * @param actual the computed value being compared\n+     * @param matcher an expression, built of {@link Matcher}s, specifying allowed values\n+     * @see org.hamcrest.CoreMatchers\n+     * @see org.junit.matchers.JUnitMatchers\n+     */\n+    public <T> void assumeThat(String message, T actual, Matcher<T> matcher) {\n+        this.advanceRobolectricLooper();\n+        Assume.assumeThat(message, actual, matcher);\n+    }\n+\n+\n+\n+    /**\n+     * If called with an expression evaluating to {@code false}, the test will halt and be ignored.\n+     *\n+     * @param b If <code>false</code>, the method will attempt to stop the test and ignore it by\n+     * throwing {@link AssumptionViolatedException}.\n+     * @param message A message to pass to {@link AssumptionViolatedException}.\n+     */\n+    public void assumeTrue(String message, boolean b) {", "originalCommit": "94afb42a5b60e76386d5c3a5575798099b3ebfb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxODgzOQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465218839", "bodyText": "I don't understand this message.\nI already added\npublic void assumeTrue(String message, boolean b) {\npublic  void assumeThat(String message, T actual, Matcher matcher) { and\npublic  void assumeThat(T actual, Matcher matcher) {\nSo it seems similar to what you ask. Furthermore, I did remove all advanceRobolectricLooper that I did add in my code", "author": "Arthur-Milchior", "createdAt": "2020-08-04T17:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMzI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzOTY2OQ==", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465239669", "bodyText": "I only saw a single method when I reviewed", "author": "david-allison-1", "createdAt": "2020-08-04T18:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMzI5Nw=="}], "type": "inlineReview"}, {"oid": "210e9a5249c5269dcd4670dfd11fb19480e08aec", "url": "https://github.com/ankidroid/Anki-Android/commit/210e9a5249c5269dcd4670dfd11fb19480e08aec", "message": "NF: upstream test", "committedDate": "2020-08-04T18:36:37Z", "type": "commit"}, {"oid": "210e9a5249c5269dcd4670dfd11fb19480e08aec", "url": "https://github.com/ankidroid/Anki-Android/commit/210e9a5249c5269dcd4670dfd11fb19480e08aec", "message": "NF: upstream test", "committedDate": "2020-08-04T18:36:37Z", "type": "forcePushed"}]}