{"pr_number": 2227, "pr_title": "Making Pub/Sub reactive pull non-blocking", "pr_createdAt": "2020-03-02T10:48:50Z", "pr_url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227", "timeline": [{"oid": "37d8084fdf76c1f12c9a12212e448902e461a4a2", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/37d8084fdf76c1f12c9a12212e448902e461a4a2", "message": "Added a future returning pull method to PubSubSubscriberOperations, and its implementation, allowing for asynchronous and non-blocking pull of messages", "committedDate": "2020-03-02T07:05:45Z", "type": "commit"}, {"oid": "39d6bc68a500e533eecd5fc6f805a24abe475dd2", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/39d6bc68a500e533eecd5fc6f805a24abe475dd2", "message": "Reimplemented the PubSubReactiveFactory to utilize the asynchronous pullFuture method of the PubSubReactiveFactory, making it non-blocking", "committedDate": "2020-03-02T07:07:49Z", "type": "commit"}, {"oid": "bd4247507e38df57128e3974bdb46808b6604e4e", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/bd4247507e38df57128e3974bdb46808b6604e4e", "message": "Added unit test for the pullFuture method of PubSubSubscriberTemplate", "committedDate": "2020-03-02T09:46:58Z", "type": "commit"}, {"oid": "8e7e9d480fc0da1ff0f5f68d13ead378247f07b7", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/8e7e9d480fc0da1ff0f5f68d13ead378247f07b7", "message": "Bumped copyright year to 2020, for those files this change touches", "committedDate": "2020-03-02T09:54:07Z", "type": "commit"}, {"oid": "7c2a162571457c3df186437dff02a3e613d9f9b8", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/7c2a162571457c3df186437dff02a3e613d9f9b8", "message": "Fixed imports according to code style", "committedDate": "2020-03-02T11:02:10Z", "type": "commit"}, {"oid": "f5138fd511f1cd5638bd036b884bc24cd34d73e1", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/f5138fd511f1cd5638bd036b884bc24cd34d73e1", "message": "Merge remote-tracking branch 'upstream/master' into pubsub-nonblocking-pull\n\n# Conflicts:\n#\tspring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java\n#\tspring-cloud-gcp-pubsub/src/test/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactoryTests.java", "committedDate": "2020-03-03T14:10:32Z", "type": "commit"}, {"oid": "12554df1578c3d1433a8b22ba4f620e353570454", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/12554df1578c3d1433a8b22ba4f620e353570454", "message": "Renamed `PubSubSubscriberOperations.pullFuture` to `PubSubSubscriberOperations.pullAsync`", "committedDate": "2020-03-03T14:36:40Z", "type": "commit"}, {"oid": "e43a90a84cccb93bc086fc22f311d24fe85a4a23", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/e43a90a84cccb93bc086fc22f311d24fe85a4a23", "message": "Made the executor for the async pull configurable, and added javadoc to its new setter and the class. Also added some javadoc to other setter methods that had no javadoc yet.", "committedDate": "2020-03-04T07:37:30Z", "type": "commit"}, {"oid": "418b5fc068dd6008e13b5f4de82dda58a349330c", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/418b5fc068dd6008e13b5f4de82dda58a349330c", "message": "Deduplicated code that creates a list of PulledAcknowledgeablePubsubMessage", "committedDate": "2020-03-04T07:38:20Z", "type": "commit"}, {"oid": "a4b9b0707eb5f5e23154cee7d07ed84c5afe1895", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/a4b9b0707eb5f5e23154cee7d07ed84c5afe1895", "message": "Added and implemented PubSubSubscriberOperations.pullAndAckAsync", "committedDate": "2020-03-04T08:14:59Z", "type": "commit"}, {"oid": "c07031ab63e0176a2514d41f42f941c99ce44cb8", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/c07031ab63e0176a2514d41f42f941c99ce44cb8", "message": "Corrected test name after pullFuture changed into pullAsync", "committedDate": "2020-03-04T08:29:23Z", "type": "commit"}, {"oid": "20386a835043cd43ad4526be785cb44ab447231d", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/20386a835043cd43ad4526be785cb44ab447231d", "message": "Added and implemented PubSubSubscriberOperations.pullAndConvertAsync", "committedDate": "2020-03-04T08:31:36Z", "type": "commit"}, {"oid": "92cf4698045903ca6d9e18f8aad24e75c27a5285", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/92cf4698045903ca6d9e18f8aad24e75c27a5285", "message": "Added and implemented PubSubSubscriberOperations.pullNextAsync. Also added tests for PubSubSubscriberOperations.pullNext, because they where missing.", "committedDate": "2020-03-04T09:14:16Z", "type": "commit"}, {"oid": "403fd31c64666a9a365017630d7d90d0a2b96e87", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/403fd31c64666a9a365017630d7d90d0a2b96e87", "message": "Fixed some checkstyle issues", "committedDate": "2020-03-04T09:20:22Z", "type": "commit"}, {"oid": "cd9cc2b9f7b09cd0c0ae3b6d8c897c5ebd6b7ea3", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/cd9cc2b9f7b09cd0c0ae3b6d8c897c5ebd6b7ea3", "message": "Made the `PubSubSubscriberTemplate.asyncPullExecutor` configurable via autoconfiguration", "committedDate": "2020-03-04T09:37:03Z", "type": "commit"}, {"oid": "00acef213acfc84eda947df1af1c95bd191dd16f", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/00acef213acfc84eda947df1af1c95bd191dd16f", "message": "Added information on the scheduler to the PubSubReactiveFactory class javadoc.", "committedDate": "2020-03-04T12:34:50Z", "type": "commit"}, {"oid": "17179edca1018680990ec1d396a55d4c68fa2ac7", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/17179edca1018680990ec1d396a55d4c68fa2ac7", "message": "Refactored the infinite/poll pull method", "committedDate": "2020-03-04T12:35:35Z", "type": "commit"}, {"oid": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "message": "Added my name to the tests that I also significantly extended", "committedDate": "2020-03-04T12:36:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDU1Nw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389870557", "bodyText": "@bsideup What would you recommend here? We need a scheduler for kicking off asynchronous service calls at fixed time intervals. The calls used to be blocking before this PR, so the parallel scheduler was a bad fit then, and we used Schedulers.newElastic at Stephane's advice. Now, though, the calls are asynchronous -- is Schedulers.parallel() appropriate to use now?\nAt minimum using the boundedElastic() instead of elastic makes sense, but I am less confident about using Schedulers.parallel(). I am concerned that using the shared parallel scheduler, if there is a bug, we could use up all N processor-bound threads and it won't be obvious in the client application where the issue came from. With threads from a named scheduler, the culprit code is obvious. Is this valid reasoning or are there better ways to identify bad reactive actors?", "author": "elefeint", "createdAt": "2020-03-09T18:10:16Z", "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubReactiveAutoConfiguration.java", "diffHunk": "@@ -49,30 +47,14 @@\n \t\tmatchIfMissing = true)\n public class GcpPubSubReactiveAutoConfiguration {\n \n-\tprivate Scheduler defaultPubSubReactiveScheduler;\n-\n \t@Bean\n \t@ConditionalOnMissingBean\n \tpublic PubSubReactiveFactory pubSubReactiveFactory(\n \t\t\tPubSubSubscriberTemplate subscriberTemplate,\n \t\t\t@Qualifier(\"pubSubReactiveScheduler\") Optional<Scheduler> userProvidedScheduler) {\n \n-\t\tScheduler scheduler = null;\n-\t\tif (userProvidedScheduler.isPresent()) {\n-\t\t\tscheduler = userProvidedScheduler.get();\n-\t\t}\n-\t\telse {\n-\t\t\tthis.defaultPubSubReactiveScheduler = Schedulers.newElastic(\"pubSubReactiveScheduler\");\n-\t\t\tscheduler = this.defaultPubSubReactiveScheduler;\n-\t\t}\n+\t\tScheduler scheduler = userProvidedScheduler.orElseGet(() -> Schedulers.parallel());", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyNDM4NA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390124384", "bodyText": "The reason why I opted for using Schedulers.parallel() is because it is optimised for non-blocking executions and this new code it is fully non-blocking, as you noted.\nI didn't use a named scheduler because IMHO in a non-blocking reactive environment, it is bad practice to use separate thread pools for separate tasks. Building reactive applications is about getting the most out of system resources. Separate thread pools would go against that. Having many more threads, meant for CPU work, then CPU cores is waste because they aren't doing anything for most of the time. They only cost memory and create more context-switching overhead.\nAt my company we have some applications that have thousands of threads because of the practice of using separate named thread pools for different tasks. Those applications are reaching their limits due to this and it is actually a problem.\nI do understand your concern with regards to trouble shooting the bugs you describe. Without having named thread pools, it sometimes can be really difficult to figure out where the culprit is. But, TBH, in the reactive world dealing with those kind of issues is already especially difficult due to the nature of reactive programming. It would be nice if there was a \"reactor native way\" to dynamically enhance the name of thread, to add troubleshooting meta information...\nThese are just my 2 cents. I am not a specialist and maybe I am wrong about how important it is to do these kinds of optimisations. So, I will defer to your opinion on this. In the end the scheduler is configurable, so users can always optimise this however they want it to be.", "author": "mzeijen", "createdAt": "2020-03-10T07:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDE1NTE2NA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390155164", "bodyText": "Never mind about what I said in the post above, because it isn't that relevant in this case. After look at it again, I noticed that the  Schedulers.parallel() scheduler is only used for doing the interval. It is not being used to handle the future, and the resulting Flux, because that is handled by the PubSub client thread that received the response. The PubSubSubscriberTemplate.asyncPullExecutor can be used to change the thread that handles that.", "author": "mzeijen", "createdAt": "2020-03-10T08:29:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwMzk1Ng==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390803956", "bodyText": "@elefeint if you make it non-blocking then a custom scheduler here does not make sense at all and can be removed (interval will implicitly use Schedulers.parallel()) :)", "author": "bsideup", "createdAt": "2020-03-11T08:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAzOTI0MQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391039241", "bodyText": "Excellent, thank you, this resolves my concern. It seems I have to unlearn the habit of creating a custom scheduler for every dedicated task.\nThe implication of Flux.interval(Duration, Duration) using Schedulers.parallel() by default is that we don't need a custom scheduler in PubSubReactiveFactory at all. On the other hand, it does not hurt anything to have extra flexibility in pubSubReactiveScheduler that the client application could control through overriding beans. Clearly I have not unlearned the habit of custom schedulers yet...\n#2246 to track; this PR is large enough already.", "author": "elefeint", "createdAt": "2020-03-11T15:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MDU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNTA1Ng==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389925056", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * @return the converter to set\n          \n          \n            \n            \t * @return the currently used converter", "author": "elefeint", "createdAt": "2020-03-09T19:53:39Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -100,21 +110,48 @@ public PubSubSubscriberTemplate(SubscriberFactory subscriberFactory) {\n \t\tthis.subscriberStub = this.subscriberFactory.createSubscriberStub();\n \t}\n \n+\t/**\n+\t * Get the converter used to convert a message payload to the desired type.\n+\t *\n+\t * @return the converter to set", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNjI4Nw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389926287", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Sets a custom {@link Executor} can be injected to control the threads that process\n          \n          \n            \n            \t * Set a custom {@link Executor} to control the threads that process", "author": "elefeint", "createdAt": "2020-03-09T19:56:01Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -100,21 +110,48 @@ public PubSubSubscriberTemplate(SubscriberFactory subscriberFactory) {\n \t\tthis.subscriberStub = this.subscriberFactory.createSubscriberStub();\n \t}\n \n+\t/**\n+\t * Get the converter used to convert a message payload to the desired type.\n+\t *\n+\t * @return the converter to set\n+\t */\n \tpublic PubSubMessageConverter getMessageConverter() {\n \t\treturn this.pubSubMessageConverter;\n \t}\n \n+\t/**\n+\t * Set the converter used to convert a message payload to the desired type.\n+\t *\n+\t * @param pubSubMessageConverter the converter to set\n+\t */\n \tpublic void setMessageConverter(PubSubMessageConverter pubSubMessageConverter) {\n \t\tAssert.notNull(pubSubMessageConverter, \"The pubSubMessageConverter can't be null.\");\n \n \t\tthis.pubSubMessageConverter = pubSubMessageConverter;\n \t}\n \n+\t/**\n+\t * Sets the {@link Executor} to control per-subscription batch\n+\t * parallelization in acknowledgement and deadline operations.\n+\t *\n+\t * @param ackExecutor the executor to set\n+\t */\n \tpublic void setAckExecutor(Executor ackExecutor) {\n \t\tAssert.notNull(ackExecutor, \"ackExecutor can't be null.\");\n \t\tthis.ackExecutor = ackExecutor;\n \t}\n \n+\t/**\n+\t * Sets a custom {@link Executor} can be injected to control the threads that process", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyOTc4NA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389929784", "bodyText": "toAcknowledgeablePubsubMessageList can get its own this.subscriberFactory.getProjectId(); it does not need to be a parameter. This will also help get rid of the extra final variable projectId in pullAsync.", "author": "elefeint", "createdAt": "2020-03-09T20:03:07Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -173,13 +210,56 @@ public Subscriber subscribe(String subscription,\n \t\tAssert.notNull(pullRequest, \"The pull request can't be null.\");\n \n \t\tPullResponse pullResponse = this.subscriberStub.pullCallable().call(pullRequest);\n-\t\treturn pullResponse.getReceivedMessagesList().stream()\n-\t\t\t\t\t\t.map((message) -> new PulledAcknowledgeablePubsubMessage(\n-\t\t\t\t\t\t\t\tPubSubSubscriptionUtils.toProjectSubscriptionName(pullRequest.getSubscription(),\n-\t\t\t\t\t\t\t\t\t\tthis.subscriberFactory.getProjectId()),\n-\t\t\t\t\t\t\t\tmessage.getMessage(),\n-\t\t\t\t\t\t\t\tmessage.getAckId()))\n-\t\t\t\t\t\t.collect(Collectors.toList());\n+\t\treturn toAcknowledgeablePubsubMessageList(", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDExNDA4MQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390114081", "bodyText": "Good catch. I applied your suggestion.", "author": "mzeijen", "createdAt": "2020-03-10T06:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyOTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1MDQ2OQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389950469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * created per instance of the {@link PubSubSubscriberOperations}.\n          \n          \n            \n             * created per instance of the {@link PubSubSubscriberTemplate}.", "author": "elefeint", "createdAt": "2020-03-09T20:44:05Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -64,13 +65,20 @@\n  *\n  * A custom {@link Executor} can be injected to control per-subscription batch\n  * parallelization in acknowledgement and deadline operations.\n+ * By default, this is a single thread executor,\n+ * created per instance of the {@link PubSubSubscriberOperations}.", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1MjU0NQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389952545", "bodyText": "Since Runnable::run is already the default async executor in PubSubSubscriberTemplate, this autoconfiguration bean can be removed and the parameter of pubSubSubscriberTemplate() changed to Optional<Executor> asyncPullExecutor.", "author": "elefeint", "createdAt": "2020-03-09T20:48:04Z", "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubAutoConfiguration.java", "diffHunk": "@@ -153,6 +153,12 @@ public PubSubPublisherTemplate pubSubPublisherTemplate(PublisherFactory publishe\n \t\treturn pubSubPublisherTemplate;\n \t}\n \n+\t@Bean\n+\t@ConditionalOnMissingBean(name = \"pubSubAsynchronousPullExecutor\")", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDExNjYyMg==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390116622", "bodyText": "When writing this I was in doubt what to do. Normally I would also use an Optional or ObjectProvider. But somehow I thought that wouldn't be in line with how this autoconfiguration class worked. Looking at it again now, I see many usages of ObjectProvider...\nSo, I applied your suggestion, but instead of using an Optional I used a ObjectProvider, as it is used all over the place, instead of Optional. So, its more in line with the rest of the class.", "author": "mzeijen", "createdAt": "2020-03-10T06:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1MjU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NTQzMg==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r389955432", "bodyText": "The intermediate .build() can be omitted -- proto setter fields have setter overloads that take builders.", "author": "elefeint", "createdAt": "2020-03-09T20:53:42Z", "path": "spring-cloud-gcp-pubsub/src/test/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplateTests.java", "diffHunk": "@@ -158,21 +163,33 @@ public void setUp() {\n \t\twhen(this.subscriberStub.acknowledgeCallable()).thenReturn(this.ackCallable);\n \t\twhen(this.subscriberStub.modifyAckDeadlineCallable()).thenReturn(this.modifyAckDeadlineCallable);\n \n-\t\twhen(this.ackCallable.futureCall(any(AcknowledgeRequest.class))).thenReturn(this.apiFuture);\n+\t\twhen(this.ackCallable.futureCall(any(AcknowledgeRequest.class))).thenReturn(this.ackApiFuture);\n \n-\t\twhen(this.modifyAckDeadlineCallable.futureCall(any(ModifyAckDeadlineRequest.class))).thenReturn(this.apiFuture);\n+\t\twhen(this.modifyAckDeadlineCallable.futureCall(any(ModifyAckDeadlineRequest.class))).thenReturn(this.ackApiFuture);\n \n \t\tdoAnswer((invocation) -> {\n \t\t\tRunnable runnable = invocation.getArgument(0);\n \t\t\trunnable.run();\n \t\t\treturn null;\n-\t\t}).when(this.apiFuture).addListener(any(Runnable.class), any(Executor.class));\n+\t\t}).when(this.ackApiFuture).addListener(any(Runnable.class), any(Executor.class));\n \n-\t\twhen(this.apiFuture.isDone()).thenReturn(true);\n+\t\twhen(this.ackApiFuture.isDone()).thenReturn(true);\n \n \t\tdoNothing().when(this.ackReplyConsumer).ack();\n \t\tdoNothing().when(this.ackReplyConsumer).nack();\n \n+\t\t// for pull future\n+\t\twhen(this.pullCallable.futureCall(any(PullRequest.class))).thenReturn(this.pullApiFuture);\n+\n+\t\tdoAnswer((invocation) -> {\n+\t\t\tRunnable runnable = invocation.getArgument(0);\n+\t\t\trunnable.run();\n+\t\t\treturn null;\n+\t\t}).when(this.pullApiFuture).addListener(any(Runnable.class), any(Executor.class));\n+\t\twhen(this.pullApiFuture.isDone()).thenReturn(true);\n+\t\twhen(this.pullApiFuture.get()).thenReturn(PullResponse.newBuilder()\n+\t\t\t\t.addReceivedMessages(ReceivedMessage.newBuilder().setMessage(this.pubsubMessage).build()).build());", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEzMDYzMw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390130633", "bodyText": "Fixed", "author": "mzeijen", "createdAt": "2020-03-10T07:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1NTQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2NzYxMA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390067610", "bodyText": "Ironically, one of the early versions of what became PubSubReactiveFactory took this recursive-like approach, together with using futureCall. We moved away from it for two reasons:\n\nto avoid too many recursive calls. But now that I think about this again, this is not really a recursive call; by the time the callback is invoked, the original invocation of backpressurePull is long gone.\nI was concerned that multiple subscription.request() calls and each will spawn an asynchronous Pub/Sub pull call with returnImmediately = false, and then once the call returns, an additional asynchronous call will be made for the remaining demand, there will be multiple simultaneous outstanding asynchronous calls pending. But looking at what I ended up doing, it has the same behavior of generating multiple outstanding calls, just with scheduled tasks.\n\n@meltsufin do you have strong opinions either way?", "author": "elefeint", "createdAt": "2020-03-10T02:50:49Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -77,116 +86,62 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n \n \t\treturn Flux.create(sink -> {\n-\n-\t\t\tScheduler.Worker subscriptionWorker = this.scheduler.createWorker();\n-\n \t\t\tsink.onRequest((numRequested) -> {\n \t\t\t\tif (numRequested == Long.MAX_VALUE) {\n-\t\t\t\t\t// unlimited demand\n-\t\t\t\t\tsubscriptionWorker.schedulePeriodically(\n-\t\t\t\t\t\t\tnew NonBlockingUnlimitedDemandPullTask(subscriptionName, sink), 0, pollingPeriodMs, TimeUnit.MILLISECONDS);\n+\t\t\t\t\tpollingPull(subscriptionName, pollingPeriodMs, sink);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tsubscriptionWorker.schedule(new BlockingLimitedDemandPullTask(subscriptionName, numRequested, sink));\n+\t\t\t\t\tbackpressurePull(subscriptionName, numRequested, sink);\n \t\t\t\t}\n \t\t\t});\n-\n-\t\t\tsink.onDispose(subscriptionWorker);\n-\n \t\t});\n \t}\n \n-\tprivate abstract class PubSubPullTask implements Runnable {\n-\n-\t\tprotected final String subscriptionName;\n-\n-\t\tprotected final FluxSink<AcknowledgeablePubsubMessage> sink;\n-\n-\t\tPubSubPullTask(String subscriptionName, FluxSink<AcknowledgeablePubsubMessage> sink) {\n-\t\t\tthis.subscriptionName = subscriptionName;\n-\t\t\tthis.sink = sink;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Retrieve up to a specified number of messages, sending them to the subscription.\n-\t\t * @param demand maximum number of messages to retrieve\n-\t\t * @param block whether to wait for the first message to become available\n-\t\t * @return number of messages retrieved\n-\t\t */\n-\t\tprotected int pullToSink(int demand, boolean block) {\n-\n-\t\t\tList<AcknowledgeablePubsubMessage> messages =\n-\t\t\t\t\tPubSubReactiveFactory.this.subscriberOperations.pull(this.subscriptionName, demand, !block);\n-\n-\t\t\tif (!this.sink.isCancelled()) {\n-\t\t\t\tmessages.forEach(sink::next);\n-\t\t\t}\n-\n-\t\t\treturn messages.size();\n-\t\t}\n+\tprivate void pollingPull(String subscriptionName, long pollingPeriodMs,\n+\t\t\tFluxSink<AcknowledgeablePubsubMessage> sink) {\n+\t\tDisposable disposable = Flux\n+\t\t\t\t.interval(Duration.ZERO, Duration.ofMillis(pollingPeriodMs), scheduler)\n+\t\t\t\t.flatMap(ignore -> pullAll(subscriptionName))\n+\t\t\t\t.subscribe(sink::next, sink::error);\n \n+\t\tsink.onDispose(disposable);\n \t}\n \n-\t/**\n-\t * Runnable task issuing blocking Pub/Sub Pull requests until the specified number of\n-\t * messages has been retrieved.\n-\t */\n-\tprivate class BlockingLimitedDemandPullTask extends PubSubPullTask {\n+\tprivate Flux<AcknowledgeablePubsubMessage> pullAll(String subscriptionName) {\n+\t\tCompletableFuture<List<AcknowledgeablePubsubMessage>> pullResponseFuture = this.subscriberOperations\n+\t\t\t\t.pullAsync(subscriptionName, Integer.MAX_VALUE, true).completable();\n \n-\t\tprivate final long initialDemand;\n-\n-\t\tBlockingLimitedDemandPullTask(String subscriptionName, long initialDemand, FluxSink<AcknowledgeablePubsubMessage> sink) {\n-\t\t\tsuper(subscriptionName, sink);\n-\t\t\tthis.initialDemand = initialDemand;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void run() {\n-\t\t\ttry {\n-\t\t\t\tlong demand = this.initialDemand;\n-\t\t\t\tList<AcknowledgeablePubsubMessage> messages;\n+\t\treturn Mono.fromFuture(pullResponseFuture).flatMapMany(Flux::fromIterable);\n+\t}\n \n-\t\t\t\twhile (demand > 0 && !this.sink.isCancelled()) {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\tint intDemand = demand > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) demand;\n-\t\t\t\t\t\tdemand -= pullToSink(intDemand, true);\n+\tprivate void backpressurePull(String subscriptionName, long numRequested,\n+\t\t\tFluxSink<AcknowledgeablePubsubMessage> sink) {\n+\t\tint intDemand = numRequested > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) numRequested;\n+\t\tthis.subscriberOperations.pullAsync(subscriptionName, intDemand, false).addCallback(\n+\t\t\t\tmessages -> {\n+\t\t\t\t\tif (!sink.isCancelled()) {\n+\t\t\t\t\t\tmessages.forEach(sink::next);\n \t\t\t\t\t}\n-\t\t\t\t\tcatch (DeadlineExceededException e) {\n+\t\t\t\t\tif (!sink.isCancelled()) {\n+\t\t\t\t\t\tlong numToPull = numRequested - messages.size();\n+\t\t\t\t\t\tif (numToPull > 0) {\n+\t\t\t\t\t\t\tbackpressurePull(subscriptionName, numToPull, sink);", "originalCommit": "af10c6ce571a0b65b4022d695b8a7fd49c42f3d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEyOTk2NQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390129965", "bodyText": "Indeed, this method seems to be recursive, but it is not because the method calls itself within the context of a different thread than itself was executed. There is no thread stack build up.\nRegarding your second point: is this actually a problem? PubSub should be able to handle it just fine. It is made for concurrent outstanding calls. It even recommends to do concurrent calls, to be able to get the highest throughput. It's just a bit unpredictable how many outstanding calls there can be at any given time.\nIf this is a problem then I think we can change this so that it is guaranteed that there is only on process retrieving the messages at any give time. When a new request comes in for new messages, it will then pass this on to this process and it will add it to the existing number of other messages that it already tries to pull. There is probably an elegant way of doing this in reactor...\nBut, as you said, the original code already has this problem. Maybe this is a separate issue to solve, if it is even an issue.", "author": "mzeijen", "createdAt": "2020-03-10T07:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2NzYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MTI0OQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390591249", "bodyText": "Looks fine to me. Good point regarding two different threads being involved which avoids the stack buildup.", "author": "meltsufin", "createdAt": "2020-03-10T20:28:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2NzYxMA=="}], "type": "inlineReview"}, {"oid": "dd6d81492b75e809182b916b7df72a1af148e9f3", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/dd6d81492b75e809182b916b7df72a1af148e9f3", "message": "Update spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java\n\nCo-Authored-By: Elena Felder <41136058+elefeint@users.noreply.github.com>", "committedDate": "2020-03-10T06:05:52Z", "type": "commit"}, {"oid": "d250e0b7723c3e22d323270eda481232d04286c4", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/d250e0b7723c3e22d323270eda481232d04286c4", "message": "Update spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java\n\nCo-Authored-By: Elena Felder <41136058+elefeint@users.noreply.github.com>", "committedDate": "2020-03-10T06:06:05Z", "type": "commit"}, {"oid": "0466c780d3d8a16d07acdcd29102ab97382b4378", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/0466c780d3d8a16d07acdcd29102ab97382b4378", "message": "Update spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java\n\nCo-Authored-By: Elena Felder <41136058+elefeint@users.noreply.github.com>", "committedDate": "2020-03-10T06:06:23Z", "type": "commit"}, {"oid": "6996cfc74ec341b3727faabcf858a15ad187da1a", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/6996cfc74ec341b3727faabcf858a15ad187da1a", "message": "Removed passing around projectId to `toAcknowledgeablePubsubMessageList`, as itself can get the project id", "committedDate": "2020-03-10T06:21:33Z", "type": "commit"}, {"oid": "809086c8d3ac4e90e838eaf242533a05051c8368", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/809086c8d3ac4e90e838eaf242533a05051c8368", "message": "Removed the `pubSubAsynchronousPullExecutor` bean in favour of using a ObjectProvider<Executor> for the pubSubSubscriberTemplate bean method", "committedDate": "2020-03-10T06:27:59Z", "type": "commit"}, {"oid": "4f99d11fb2cea76a40f5b385eba160aa66bbd77b", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/4f99d11fb2cea76a40f5b385eba160aa66bbd77b", "message": "Merge remote-tracking branch 'upstream/master' into pubsub-nonblocking-pull", "committedDate": "2020-03-10T06:28:12Z", "type": "commit"}, {"oid": "eea5e531e538bd711eeac930773ac827fa731d00", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/eea5e531e538bd711eeac930773ac827fa731d00", "message": "Removed the intermediate build calls for protobuf objects", "committedDate": "2020-03-10T07:24:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzI0MQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390397241", "bodyText": "If we're using the ObjectProvider for the asyncPullExecutor, why doesn't it apply to ackExecutor?\nBoth approaches might be valid, but we should try to be consistent.", "author": "meltsufin", "createdAt": "2020-03-10T15:23:23Z", "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubAutoConfiguration.java", "diffHunk": "@@ -167,10 +167,12 @@ public Executor pubSubAcknowledgementExecutor() {\n \t@ConditionalOnMissingBean\n \tpublic PubSubSubscriberTemplate pubSubSubscriberTemplate(SubscriberFactory subscriberFactory,\n \t\t\tObjectProvider<PubSubMessageConverter> pubSubMessageConverter,\n-\t\t\t@Qualifier(\"pubSubAcknowledgementExecutor\") Executor executor) {\n+\t\t\t@Qualifier(\"pubSubAsynchronousPullExecutor\") ObjectProvider<Executor> asyncPullExecutor,\n+\t\t\t@Qualifier(\"pubSubAcknowledgementExecutor\") Executor ackExecutor) {", "originalCommit": "eea5e531e538bd711eeac930773ac827fa731d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5ODA0Mw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390798043", "bodyText": "I did not change that into a ObjectProvider because there is always a pubSubAcknowledgementExecutor bean in the spring context (see the pubSubAcknowledgementExecutor() bean definition method above this method). So, having a  ObjectProvider is pointless as it will always have a bean. Agree?\nSide note: you can wonder why we need the pubSubAcknowledgementExecutor bean at all, and why the default ackExecutor, defined in PubSubSubscriberTemplate, doesn't suffice. Currently it is a Executors.newSingleThreadExecutor(), which doesn't scale, I guess, and that is why the pubSubAcknowledgementExecutor bean defines a ThreadPoolTaskExecutor that can have more threads, depending on the ...subscriber.max-acknowledgement-threads property.\nWe could also just change the default Executors.newSingleThreadExecutor() in the PubSubSubscriberTemplate in to  a Runnable::run and the pubSubAcknowledgementExecutor bean could only be created if a specific ...subscriber.max-acknowledgement-threads is defined in the properties (that way we stay somewhat backwards compatible). That way it is  in line with how we do callback processing for both ack responses and message pull responses. I haven't done any such changes though, as that would be a big change in how the PubSubSubscriberTemplate works by default for ack responses. Also it is unrelated to my ticket.", "author": "mzeijen", "createdAt": "2020-03-11T08:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAwNjcyOA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391006728", "bodyText": "I think you're right, this raises more questions about the introduction of the pubSubAcknowledgementExecutor bean rather than the use of the ObjectProvider for asyncPullExecutor. The change was made in #1349 over a year ago and the ...subscriber.max-acknowledgement-threads was never really documented in the refdocs. So, it might be OK to just remove it, and replace with the Runnable::run default in the template itself. However, it looks like there were some performance issues with the direct executor. In any case, like you said, it's irrelevant to your ticket. @elefeint Should we file a separate ticket to investigate the pubSubAcknowledgementExecutor?", "author": "meltsufin", "createdAt": "2020-03-11T14:23:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAxMjAzNA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391012034", "bodyText": "Yes, let's create a different issue, and I agree that using Runnable::run by default is the right thing to do here.", "author": "elefeint", "createdAt": "2020-03-11T14:29:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzI0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTAxNzY5Ng==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391017696", "bodyText": "#2245", "author": "elefeint", "createdAt": "2020-03-11T14:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwMTA5Mw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390401093", "bodyText": "Does our new default Scheduler.parallel() scheduler not need closing anymore?", "author": "meltsufin", "createdAt": "2020-03-10T15:28:10Z", "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/pubsub/GcpPubSubReactiveAutoConfiguration.java", "diffHunk": "@@ -49,30 +47,14 @@\n \t\tmatchIfMissing = true)\n public class GcpPubSubReactiveAutoConfiguration {\n \n-\tprivate Scheduler defaultPubSubReactiveScheduler;\n-\n \t@Bean\n \t@ConditionalOnMissingBean\n \tpublic PubSubReactiveFactory pubSubReactiveFactory(\n \t\t\tPubSubSubscriberTemplate subscriberTemplate,\n \t\t\t@Qualifier(\"pubSubReactiveScheduler\") Optional<Scheduler> userProvidedScheduler) {\n \n-\t\tScheduler scheduler = null;\n-\t\tif (userProvidedScheduler.isPresent()) {\n-\t\t\tscheduler = userProvidedScheduler.get();\n-\t\t}\n-\t\telse {\n-\t\t\tthis.defaultPubSubReactiveScheduler = Schedulers.newElastic(\"pubSubReactiveScheduler\");\n-\t\t\tscheduler = this.defaultPubSubReactiveScheduler;\n-\t\t}\n+\t\tScheduler scheduler = userProvidedScheduler.orElseGet(() -> Schedulers.parallel());\n \t\treturn new PubSubReactiveFactory(subscriberTemplate, scheduler);\n \t}\n \n-\t@PreDestroy\n-\tpublic void closeScheduler() {\n-\t\tif (this.defaultPubSubReactiveScheduler != null) {\n-\t\t\tthis.defaultPubSubReactiveScheduler.dispose();", "originalCommit": "eea5e531e538bd711eeac930773ac827fa731d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwMTczNw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390801737", "bodyText": "The Schedulers.parallel() is a global scheduler from the Reactor library and it has the responsibility to manage its lifecycle and close it when it is appropriate. Or at least something that is managing the Reactor library is responsible for all that.", "author": "mzeijen", "createdAt": "2020-03-11T08:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwMTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwNDY4Ng==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390404686", "bodyText": "All of the code above this line in the method is shared with pullAndAck. Can we try to reduce the code duplication?", "author": "meltsufin", "createdAt": "2020-03-10T15:32:51Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/core/subscriber/PubSubSubscriberTemplate.java", "diffHunk": "@@ -214,19 +314,63 @@ public Subscriber subscribe(String subscription,\n \n \t\tList<AcknowledgeablePubsubMessage> ackableMessages = pull(pullRequest);\n \n-\t\tif (ackableMessages.size() > 0) {\n+\t\tif (!ackableMessages.isEmpty()) {\n \t\t\tack(ackableMessages);\n \t\t}\n \n \t\treturn ackableMessages.stream().map(AcknowledgeablePubsubMessage::getPubsubMessage)\n \t\t\t\t.collect(Collectors.toList());\n \t}\n \n+\t@Override\n+\tpublic ListenableFuture<List<PubsubMessage>> pullAndAckAsync(String subscription, Integer maxMessages,\n+\t\t\tBoolean returnImmediately) {\n+\t\tAssert.hasText(subscription, \"The subscription can't be null or empty.\");\n+\n+\t\tif (maxMessages != null) {\n+\t\t\tAssert.isTrue(maxMessages > 0, \"The maxMessages must be greater than 0.\");\n+\t\t}\n+\n+\t\tPullRequest pullRequest = this.subscriberFactory.createPullRequest(\n+\t\t\t\tsubscription, maxMessages, returnImmediately);\n+\n+\t\tfinal SettableListenableFuture<List<PubsubMessage>> settableFuture = new SettableListenableFuture<>();\n+\n+\t\tthis.pullAsync(pullRequest).addCallback(", "originalCommit": "eea5e531e538bd711eeac930773ac827fa731d00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwODE0MA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390808140", "bodyText": "I moved the validation into the SubscriberFactory.createPullRequest, where the subscription validation also already was done. This removed the duplication.", "author": "mzeijen", "createdAt": "2020-03-11T08:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwNDY4Ng=="}], "type": "inlineReview"}, {"oid": "3ee9f531fab2dedda3869e0648eb71af81e43187", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/3ee9f531fab2dedda3869e0648eb71af81e43187", "message": "Reduced amount of duplicate code in `pullAndAck` and `pullAndAckAsync` by moving the validation into `SubscriberFactory.createPullRequest` (where it partially already was)", "committedDate": "2020-03-11T08:25:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwOTU4Mw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390809583", "bodyText": "Side note: I think it is a mistake that maxMessage can be set to null, because according to the Google PubSub API docs it must always have a positive number (see: https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pullrequest). I believe that if it isn't set, then a default value of 0 is used.\nShall I report it as a bug?", "author": "mzeijen", "createdAt": "2020-03-11T08:30:17Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/support/DefaultSubscriberFactory.java", "diffHunk": "@@ -227,6 +227,8 @@ public PullRequest createPullRequest(String subscriptionName, Integer maxMessage\n \t\t\t\t\t\tPubSubSubscriptionUtils.toProjectSubscriptionName(subscriptionName, this.projectId).toString());\n \n \t\tif (maxMessages != null) {", "originalCommit": "3ee9f531fab2dedda3869e0648eb71af81e43187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNjIxOA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391116218", "bodyText": "Yes, please. Zero is disallowed, too, so we should assert that the parameter is neither null nor zero.", "author": "elefeint", "createdAt": "2020-03-11T16:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwOTU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY5MDg0NQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391690845", "bodyText": "I created the bug #2248", "author": "mzeijen", "createdAt": "2020-03-12T15:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwOTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMTU4NA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r390811584", "bodyText": "side note: use true for the third argument, defines the return_immediately as true. However according to the Google PubSub API docs, this is not recommended and the argument is actually deprecated (see https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#pullrequest).\nWhat to do with it? Separate bug?", "author": "mzeijen", "createdAt": "2020-03-11T08:34:16Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/reactive/PubSubReactiveFactory.java", "diffHunk": "@@ -77,116 +86,62 @@ public PubSubReactiveFactory(PubSubSubscriberOperations subscriberOperations, Sc\n \tpublic Flux<AcknowledgeablePubsubMessage> poll(String subscriptionName, long pollingPeriodMs) {\n \n \t\treturn Flux.create(sink -> {\n-\n-\t\t\tScheduler.Worker subscriptionWorker = this.scheduler.createWorker();\n-\n \t\t\tsink.onRequest((numRequested) -> {\n \t\t\t\tif (numRequested == Long.MAX_VALUE) {\n-\t\t\t\t\t// unlimited demand\n-\t\t\t\t\tsubscriptionWorker.schedulePeriodically(\n-\t\t\t\t\t\t\tnew NonBlockingUnlimitedDemandPullTask(subscriptionName, sink), 0, pollingPeriodMs, TimeUnit.MILLISECONDS);\n+\t\t\t\t\tpollingPull(subscriptionName, pollingPeriodMs, sink);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\tsubscriptionWorker.schedule(new BlockingLimitedDemandPullTask(subscriptionName, numRequested, sink));\n+\t\t\t\t\tbackpressurePull(subscriptionName, numRequested, sink);\n \t\t\t\t}\n \t\t\t});\n-\n-\t\t\tsink.onDispose(subscriptionWorker);\n-\n \t\t});\n \t}\n \n-\tprivate abstract class PubSubPullTask implements Runnable {\n-\n-\t\tprotected final String subscriptionName;\n-\n-\t\tprotected final FluxSink<AcknowledgeablePubsubMessage> sink;\n-\n-\t\tPubSubPullTask(String subscriptionName, FluxSink<AcknowledgeablePubsubMessage> sink) {\n-\t\t\tthis.subscriptionName = subscriptionName;\n-\t\t\tthis.sink = sink;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Retrieve up to a specified number of messages, sending them to the subscription.\n-\t\t * @param demand maximum number of messages to retrieve\n-\t\t * @param block whether to wait for the first message to become available\n-\t\t * @return number of messages retrieved\n-\t\t */\n-\t\tprotected int pullToSink(int demand, boolean block) {\n-\n-\t\t\tList<AcknowledgeablePubsubMessage> messages =\n-\t\t\t\t\tPubSubReactiveFactory.this.subscriberOperations.pull(this.subscriptionName, demand, !block);\n-\n-\t\t\tif (!this.sink.isCancelled()) {\n-\t\t\t\tmessages.forEach(sink::next);\n-\t\t\t}\n-\n-\t\t\treturn messages.size();\n-\t\t}\n+\tprivate void pollingPull(String subscriptionName, long pollingPeriodMs,\n+\t\t\tFluxSink<AcknowledgeablePubsubMessage> sink) {\n+\t\tDisposable disposable = Flux\n+\t\t\t\t.interval(Duration.ZERO, Duration.ofMillis(pollingPeriodMs), scheduler)\n+\t\t\t\t.flatMap(ignore -> pullAll(subscriptionName))\n+\t\t\t\t.subscribe(sink::next, sink::error);\n \n+\t\tsink.onDispose(disposable);\n \t}\n \n-\t/**\n-\t * Runnable task issuing blocking Pub/Sub Pull requests until the specified number of\n-\t * messages has been retrieved.\n-\t */\n-\tprivate class BlockingLimitedDemandPullTask extends PubSubPullTask {\n+\tprivate Flux<AcknowledgeablePubsubMessage> pullAll(String subscriptionName) {\n+\t\tCompletableFuture<List<AcknowledgeablePubsubMessage>> pullResponseFuture = this.subscriberOperations\n+\t\t\t\t.pullAsync(subscriptionName, Integer.MAX_VALUE, true).completable();", "originalCommit": "3ee9f531fab2dedda3869e0648eb71af81e43187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA1ODc5OQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391058799", "bodyText": "Thank you for catching this; we actually did not realize this field recently got deprecated.\nLet's keep the behavior consistent with the past in this PR.\n#2247 to track.", "author": "elefeint", "createdAt": "2020-03-11T15:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxMTU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMTk3Mg==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391121972", "bodyText": "I'd skip the \"can be null\". It's a required field in the proto, so the request will fail. You are right that our validation exempting null is a bug.", "author": "elefeint", "createdAt": "2020-03-11T17:00:09Z", "path": "spring-cloud-gcp-pubsub/src/main/java/org/springframework/cloud/gcp/pubsub/support/SubscriberFactory.java", "diffHunk": "@@ -53,7 +53,8 @@\n \t * Create a {@link PullRequest} for synchronously pulling a number of messages from\n \t * a Google Cloud Pub/Sub subscription.\n \t * @param subscriptionName the name of the subscription\n-\t * @param maxMessages the maximum number of pulled messages\n+\t * @param maxMessages the maximum number of pulled messages,\n+\t * which can be null or must be a positive number", "originalCommit": "3ee9f531fab2dedda3869e0648eb71af81e43187", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY5MTQ2MA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2227#discussion_r391691460", "bodyText": "Ok, I removed it. Bug was created under #2248.", "author": "mzeijen", "createdAt": "2020-03-12T15:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMTk3Mg=="}], "type": "inlineReview"}, {"oid": "ec3d15fb2c62848b07aa65789e4b12eacef43e12", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/ec3d15fb2c62848b07aa65789e4b12eacef43e12", "message": "Removed the javadoc statement that maxMessages can be null", "committedDate": "2020-03-12T15:13:56Z", "type": "commit"}, {"oid": "46a528431661e161e8a1f8457f2f9e9c357c32c4", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/46a528431661e161e8a1f8457f2f9e9c357c32c4", "message": "Correct since javadoc annotation, updated copyright year and added myself as author to all files where I hadn't added myself yet.", "committedDate": "2020-03-12T15:31:19Z", "type": "commit"}]}