{"pr_number": 2157, "pr_title": "Introducing Firebase Authentication module", "pr_createdAt": "2020-01-31T16:29:56Z", "pr_url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157", "timeline": [{"oid": "e4576af6092c8e2c3bddf5c9bdf1418a792bbdc7", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/e4576af6092c8e2c3bddf5c9bdf1418a792bbdc7", "message": "Added base logic for Firebase Token validation\n - Included FirebaseJwtTokenDecoder\n - Stubs for JwtTokenValidator\n - Base tests\n - Utility classes for testing", "committedDate": "2020-01-16T20:36:48Z", "type": "commit"}, {"oid": "333f20dc044141d6cd968290f78569e423d210ed", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/333f20dc044141d6cd968290f78569e423d210ed", "message": "Added more tests, consolidating all validations under FirebaseTokenValidator", "committedDate": "2020-01-18T23:05:23Z", "type": "commit"}, {"oid": "824f56f133eb8662323ddd8636da26de3106648e", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/824f56f133eb8662323ddd8636da26de3106648e", "message": "- Fixed checkstyle errors\n- Added supression for sun.* packages on test classes\n- Removed uncessary Validator", "committedDate": "2020-01-20T22:36:12Z", "type": "commit"}, {"oid": "2c62188ca0f4be7c9ade2c3921ceb2c7e45f3870", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/2c62188ca0f4be7c9ade2c3921ceb2c7e45f3870", "message": "- Added extra validations for token\n- Added extra test cases\n- Improved javadoc", "committedDate": "2020-01-21T01:43:29Z", "type": "commit"}, {"oid": "abea5937393e4ebcb6feaafc656e75088f70e8dc", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/abea5937393e4ebcb6feaafc656e75088f70e8dc", "message": "- Added initial auto configuration tests\n- Fixed year header", "committedDate": "2020-01-21T02:51:09Z", "type": "commit"}, {"oid": "abda968d5512f726529e653c22db843ca538539d", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/abda968d5512f726529e653c22db843ca538539d", "message": "- Removed dependency on ResourceManager, only projectId is needed not project number", "committedDate": "2020-01-21T15:06:52Z", "type": "commit"}, {"oid": "475074c851c55fe8ce62cf95b41d292e6fd69662", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/475074c851c55fe8ce62cf95b41d292e6fd69662", "message": "- Added starter module\n- Skelleton sample app", "committedDate": "2020-01-22T01:25:30Z", "type": "commit"}, {"oid": "9e9e391300239475f92a75987b569664048ccb0a", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/9e9e391300239475f92a75987b569664048ccb0a", "message": "- Started base firebase config for sample application", "committedDate": "2020-01-22T02:55:23Z", "type": "commit"}, {"oid": "e00fe939c9aadc6ed3dacea47f644ea418ba8c94", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/e00fe939c9aadc6ed3dacea47f644ea418ba8c94", "message": " Added more logic to UI", "committedDate": "2020-01-23T01:50:37Z", "type": "commit"}, {"oid": "167c646e92f9f10541658ac50005615d57a7b427", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/167c646e92f9f10541658ac50005615d57a7b427", "message": "improving UI", "committedDate": "2020-01-23T13:23:56Z", "type": "commit"}, {"oid": "27f6e003ede3b758e75f91d051faa7b2a8ff9799", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/27f6e003ede3b758e75f91d051faa7b2a8ff9799", "message": "rounding up js", "committedDate": "2020-01-23T19:10:48Z", "type": "commit"}, {"oid": "baaafd97af04fc8278aaddb0e240675c1f9e98b1", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/baaafd97af04fc8278aaddb0e240675c1f9e98b1", "message": " Replacing angularjs SPA for a simplified jquery + html5 app", "committedDate": "2020-01-23T21:27:39Z", "type": "commit"}, {"oid": "ea1fd84f034b60dbfba0558bb74c63caaff7ee2b", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/ea1fd84f034b60dbfba0558bb74c63caaff7ee2b", "message": "finished docs for sample app", "committedDate": "2020-01-31T16:22:20Z", "type": "commit"}, {"oid": "a18caef20ad725d4b6f4325091356c53d5aaf04b", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/a18caef20ad725d4b6f4325091356c53d5aaf04b", "message": "Fixed checkstyle errors", "committedDate": "2020-01-31T16:42:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3OTIxNQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374179215", "bodyText": "s/Authentiation/Authentication", "author": "elefeint", "createdAt": "2020-02-03T15:47:55Z", "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/security/FirebaseAuthentiationAutoConfiguration.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.autoconfigure.security;\n+\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n+import org.springframework.boot.autoconfigure.AutoConfigureBefore;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration;\n+import org.springframework.boot.context.properties.EnableConfigurationProperties;\n+import org.springframework.cloud.gcp.autoconfigure.core.GcpContextAutoConfiguration;\n+import org.springframework.cloud.gcp.core.GcpProjectIdProvider;\n+import org.springframework.cloud.gcp.security.firebase.FirebaseJwtTokenDecoder;\n+import org.springframework.cloud.gcp.security.firebase.FirebaseTokenValidator;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.http.client.SimpleClientHttpRequestFactory;\n+import org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidator;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtDecoder;\n+import org.springframework.security.oauth2.jwt.JwtIssuerValidator;\n+import org.springframework.security.oauth2.jwt.JwtTimestampValidator;\n+import org.springframework.web.client.RestOperations;\n+import org.springframework.web.client.RestTemplate;\n+\n+/**\n+ *\n+ * @author Vinicius Carvalho\n+ * @since 1.3\n+ */\n+@Configuration\n+@ConditionalOnProperty(value = \"spring.cloud.gcp.security.firebase.enabled\", matchIfMissing = true)\n+@AutoConfigureBefore(OAuth2ResourceServerAutoConfiguration.class)\n+@AutoConfigureAfter(GcpContextAutoConfiguration.class)\n+@EnableConfigurationProperties(FirebaseAuthenticationProperties.class)\n+public class FirebaseAuthentiationAutoConfiguration {", "originalCommit": "a18caef20ad725d4b6f4325091356c53d5aaf04b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE4NzU4NA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374187584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author vinicius\n          \n          \n            \n             * @author Vinicius Carvalho\n          \n          \n            \n             * @since 1.3", "author": "elefeint", "createdAt": "2020-02-03T16:01:18Z", "path": "spring-cloud-gcp-samples/spring-cloud-gcp-security-firebase-sample/src/main/java/com/example/FirebaseConfig.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.example;\n+\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+\n+/**\n+ * @author vinicius", "originalCommit": "a18caef20ad725d4b6f4325091356c53d5aaf04b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE4ODU1MQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374188551", "bodyText": "auth is unused?", "author": "elefeint", "createdAt": "2020-02-03T16:02:49Z", "path": "spring-cloud-gcp-samples/spring-cloud-gcp-security-firebase-sample/src/main/java/com/example/SampleController.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.example;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.core.Authentication;\n+import org.springframework.security.core.context.SecurityContextHolder;\n+import org.springframework.stereotype.Controller;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+@Controller\n+@RequestMapping(\"/answer\")\n+public class SampleController {\n+\t@GetMapping(produces = \"application/json\")\n+\tpublic ResponseEntity<Map<String, String>> hello() {\n+\t\tAuthentication auth = SecurityContextHolder.getContext().getAuthentication();", "originalCommit": "a18caef20ad725d4b6f4325091356c53d5aaf04b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwMDMyMA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374200320", "bodyText": "Nimbus seems to have a utility for parsing an X.509 cert. Would it help?", "author": "elefeint", "createdAt": "2020-02-03T16:23:00Z", "path": "spring-cloud-gcp-security-firebase/src/main/java/org/springframework/cloud/gcp/security/firebase/FirebaseJwtTokenDecoder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.security.firebase;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.nimbusds.jwt.JWT;\n+import com.nimbusds.jwt.JWTParser;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidator;\n+import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtDecoder;\n+import org.springframework.security.oauth2.jwt.JwtException;\n+import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;\n+import org.springframework.web.client.RestOperations;\n+\n+\n+/**\n+ * Decodes a Firebase token into a {@link Jwt} token.\n+ * This decoder downloads public keys from https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com.\n+ * Keys are rotated often, and expiration date is returned as part of a Cache-Control max-age header.\n+ * The keys are cached locally and only refreshed when the expiration time is past.\n+ * Besides using the RSA keys to validate the token signature, this decoder also uses a pre=configured {@link org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator}\n+ * to validate all the claims.\n+ * The following validators are used by this class:\n+ * {@link org.springframework.security.oauth2.jwt.JwtTimestampValidator} - Validates the expiration date of the Token\n+ * {@link org.springframework.security.oauth2.jwt.JwtIssuerValidator} - Validates the iss claim header\n+ * {@link FirebaseTokenValidator} - Validates all other headers according to definition at https://firebase.google.com/docs/auth/admin/verify-id-tokens\n+ * @author Vinicius Carvalho\n+ * @since 1.3\n+ */\n+public class FirebaseJwtTokenDecoder implements JwtDecoder {\n+\tprivate static final String DECODING_ERROR_MESSAGE_TEMPLATE =\n+\t\t\"An error occurred while attempting to decode the Jwt: %s\";\n+\tprivate final RestOperations restClient;\n+\tprivate final String googlePublicKeysEndpoint;\n+\tprivate final OAuth2TokenValidator<Jwt> tokenValidator;\n+\tprivate final Logger logger = LoggerFactory.getLogger(FirebaseJwtTokenDecoder.class);\n+\tprivate Pattern maxAgePattern = Pattern.compile(\"max-age=(\\\\d*)\");\n+\tprivate ReentrantLock keysLock = new ReentrantLock();\n+\tprivate volatile Long expires = 0L;\n+\tprivate Map<String, JwtDecoder> delegates = new ConcurrentHashMap<>();\n+\tpublic FirebaseJwtTokenDecoder(RestOperations restClient, String googlePublicKeysEndpoint, OAuth2TokenValidator<Jwt> tokenValidator) {\n+\t\tthis.restClient = restClient;\n+\t\tthis.googlePublicKeysEndpoint = googlePublicKeysEndpoint;\n+\t\tthis.tokenValidator = tokenValidator;\n+\t}\n+\t@Override\n+\tpublic Jwt decode(String token) throws JwtException {\n+\t\tSignedJWT jwt = parse(token);\n+\t\tif (isExpired()) {\n+\t\t\ttry {\n+\t\t\t\tkeysLock.tryLock();\n+\t\t\t\trefresh();\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tkeysLock.unlock();\n+\t\t\t}\n+\t\t}\n+\t\tJwtDecoder decoder = delegates.get(jwt.getHeader().getKeyID());\n+\t\tif (decoder == null) {\n+\t\t\tthrow new JwtException(\"No certificate found for key: \" + jwt.getHeader().getKeyID());\n+\t\t}\n+\t\treturn decoder.decode(token);\n+\t}\n+\n+\tprivate void refresh() {\n+\t\tif (!isExpired()) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttry {\n+\t\t\tResponseEntity<Map<String, String>> response = restClient.exchange(googlePublicKeysEndpoint, HttpMethod.GET, null, new ParameterizedTypeReference<Map<String, String>>() {\n+\t\t\t});\n+\t\t\tLong expiresAt = parseCacheControlHeaders(response.getHeaders());\n+\t\t\tthis.expires = expiresAt > -1L ? (System.currentTimeMillis() + expiresAt * 1000) : 0L;\n+\t\t\tif (!response.getStatusCode().is2xxSuccessful()) {\n+\t\t\t\tthrow new JwtException(\"Error retrieving public certificates from remote endpoint\");\n+\t\t\t}\n+\t\t\tdelegates.clear();\n+\t\t\tfor (String key : response.getBody().keySet()) {\n+\t\t\t\ttry {\n+\t\t\t\t\tNimbusJwtDecoder nimbusJwtDecoder = NimbusJwtDecoder.withPublicKey((RSAPublicKey) convertToX509Cert(response.getBody().get(key)).getPublicKey())\n+\t\t\t\t\t\t\t.signatureAlgorithm(SignatureAlgorithm.from(\"RS256\"))\n+\t\t\t\t\t\t\t.build();\n+\t\t\t\t\tnimbusJwtDecoder.setJwtValidator(tokenValidator);\n+\t\t\t\t\tdelegates.put(key, nimbusJwtDecoder);\n+\t\t\t\t}\n+\t\t\t\tcatch (CertificateException ce) {\n+\t\t\t\t\tlogger.error(\"Could not read certificate for key {}\", key);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tcatch (Exception e) {\n+\t\t\tthrow new JwtException(\"Error fetching public keys\", e);\n+\t\t}\n+\t}\n+\n+\tprivate SignedJWT parse(String token) {\n+\t\ttry {\n+\t\t\tJWT jwt = JWTParser.parse(token);\n+\t\t\tif (!(jwt instanceof SignedJWT)) {\n+\t\t\t\tthrow new JwtException(\"Unsupported algorithm of \" + jwt.getHeader().getAlgorithm());\n+\t\t\t}\n+\t\t\treturn (SignedJWT) jwt;\n+\t\t}\n+\t\tcatch (Exception ex) {\n+\t\t\tthrow new JwtException(String.format(DECODING_ERROR_MESSAGE_TEMPLATE, ex.getMessage()), ex);\n+\t\t}\n+\t}\n+\n+\tprivate Boolean isExpired() {\n+\t\treturn System.currentTimeMillis() >= this.expires;\n+\t}\n+\n+\tprivate X509Certificate convertToX509Cert(String certificateString) throws CertificateException {", "originalCommit": "a18caef20ad725d4b6f4325091356c53d5aaf04b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2OTczOA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374969738", "bodyText": "Hi @elefeint it did help, I've updated the code to use it instead of using a private method, will commit along with other reviews. Thanks for the tip", "author": "viniciusccarvalho", "createdAt": "2020-02-04T22:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwMDMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxNDQ4NA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374214484", "bodyText": "Is there a brief period when isExpired() is false even though the original certificate did expire?\nServer gives expiration timestamp as SERVER_TIME + expiresAt.\nClient gets a response at SERVER_TIME + LATENCY and sets its this.expires to SERVER_TIME + LATENCY + expiresAt * 1000.\nexpiresAt milliseconds pass; server rotates certificates. Authentication requests fail because of the mismatch, but refresh() bails out immediately because LATENCY has not passed yet, and isExpired() still returns false.\nIn real life it would be a negligibly small time period, but it could be longer if the original certificate fetch stalled.", "author": "elefeint", "createdAt": "2020-02-03T16:46:53Z", "path": "spring-cloud-gcp-security-firebase/src/main/java/org/springframework/cloud/gcp/security/firebase/FirebaseJwtTokenDecoder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.security.firebase;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.nimbusds.jwt.JWT;\n+import com.nimbusds.jwt.JWTParser;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidator;\n+import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtDecoder;\n+import org.springframework.security.oauth2.jwt.JwtException;\n+import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;\n+import org.springframework.web.client.RestOperations;\n+\n+\n+/**\n+ * Decodes a Firebase token into a {@link Jwt} token.\n+ * This decoder downloads public keys from https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com.\n+ * Keys are rotated often, and expiration date is returned as part of a Cache-Control max-age header.\n+ * The keys are cached locally and only refreshed when the expiration time is past.\n+ * Besides using the RSA keys to validate the token signature, this decoder also uses a pre=configured {@link org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator}\n+ * to validate all the claims.\n+ * The following validators are used by this class:\n+ * {@link org.springframework.security.oauth2.jwt.JwtTimestampValidator} - Validates the expiration date of the Token\n+ * {@link org.springframework.security.oauth2.jwt.JwtIssuerValidator} - Validates the iss claim header\n+ * {@link FirebaseTokenValidator} - Validates all other headers according to definition at https://firebase.google.com/docs/auth/admin/verify-id-tokens\n+ * @author Vinicius Carvalho\n+ * @since 1.3\n+ */\n+public class FirebaseJwtTokenDecoder implements JwtDecoder {\n+\tprivate static final String DECODING_ERROR_MESSAGE_TEMPLATE =\n+\t\t\"An error occurred while attempting to decode the Jwt: %s\";\n+\tprivate final RestOperations restClient;\n+\tprivate final String googlePublicKeysEndpoint;\n+\tprivate final OAuth2TokenValidator<Jwt> tokenValidator;\n+\tprivate final Logger logger = LoggerFactory.getLogger(FirebaseJwtTokenDecoder.class);\n+\tprivate Pattern maxAgePattern = Pattern.compile(\"max-age=(\\\\d*)\");\n+\tprivate ReentrantLock keysLock = new ReentrantLock();\n+\tprivate volatile Long expires = 0L;\n+\tprivate Map<String, JwtDecoder> delegates = new ConcurrentHashMap<>();\n+\tpublic FirebaseJwtTokenDecoder(RestOperations restClient, String googlePublicKeysEndpoint, OAuth2TokenValidator<Jwt> tokenValidator) {\n+\t\tthis.restClient = restClient;\n+\t\tthis.googlePublicKeysEndpoint = googlePublicKeysEndpoint;\n+\t\tthis.tokenValidator = tokenValidator;\n+\t}\n+\t@Override\n+\tpublic Jwt decode(String token) throws JwtException {\n+\t\tSignedJWT jwt = parse(token);\n+\t\tif (isExpired()) {\n+\t\t\ttry {\n+\t\t\t\tkeysLock.tryLock();\n+\t\t\t\trefresh();\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tkeysLock.unlock();\n+\t\t\t}\n+\t\t}\n+\t\tJwtDecoder decoder = delegates.get(jwt.getHeader().getKeyID());\n+\t\tif (decoder == null) {\n+\t\t\tthrow new JwtException(\"No certificate found for key: \" + jwt.getHeader().getKeyID());\n+\t\t}\n+\t\treturn decoder.decode(token);\n+\t}\n+\n+\tprivate void refresh() {\n+\t\tif (!isExpired()) {", "originalCommit": "a18caef20ad725d4b6f4325091356c53d5aaf04b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMwOTEzOA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374309138", "bodyText": "From what I could tell, but need to confirm this, during the max-age window we keep the last key valid. So even if we had a stale cache, the very next keys would still contain at least the most recent key we had cached too.", "author": "viniciusccarvalho", "createdAt": "2020-02-03T19:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxNDQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxOTYwOQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374219609", "bodyText": "Could NimbusJwtDecoder be more helpful here? Nimbus has some re-downloading and an expiring cache implementation.", "author": "elefeint", "createdAt": "2020-02-03T16:56:12Z", "path": "spring-cloud-gcp-security-firebase/src/main/java/org/springframework/cloud/gcp/security/firebase/FirebaseJwtTokenDecoder.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.security.firebase;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAPublicKey;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.nimbusds.jwt.JWT;\n+import com.nimbusds.jwt.JWTParser;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidator;\n+import org.springframework.security.oauth2.jose.jws.SignatureAlgorithm;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtDecoder;\n+import org.springframework.security.oauth2.jwt.JwtException;\n+import org.springframework.security.oauth2.jwt.NimbusJwtDecoder;\n+import org.springframework.web.client.RestOperations;\n+\n+\n+/**\n+ * Decodes a Firebase token into a {@link Jwt} token.\n+ * This decoder downloads public keys from https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com.\n+ * Keys are rotated often, and expiration date is returned as part of a Cache-Control max-age header.\n+ * The keys are cached locally and only refreshed when the expiration time is past.\n+ * Besides using the RSA keys to validate the token signature, this decoder also uses a pre=configured {@link org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator}\n+ * to validate all the claims.\n+ * The following validators are used by this class:\n+ * {@link org.springframework.security.oauth2.jwt.JwtTimestampValidator} - Validates the expiration date of the Token\n+ * {@link org.springframework.security.oauth2.jwt.JwtIssuerValidator} - Validates the iss claim header\n+ * {@link FirebaseTokenValidator} - Validates all other headers according to definition at https://firebase.google.com/docs/auth/admin/verify-id-tokens\n+ * @author Vinicius Carvalho\n+ * @since 1.3\n+ */\n+public class FirebaseJwtTokenDecoder implements JwtDecoder {", "originalCommit": "a18caef20ad725d4b6f4325091356c53d5aaf04b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI3ODU1OA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374278558", "bodyText": "It won't work, because that is for JWKSet spec, and Firebase does not follow that json standard. It only outputs a dictionary with the key_id :  PEMString, so the decoder would fail. That's one of the reasons I implemented all from scratch. I have also considered using HttpCachingClient from Apache HttpClient, but it would be able to cache the resource, but the parsing of the certificate would still happen for every token invocation, so I decided to cache the whole operation.", "author": "viniciusccarvalho", "createdAt": "2020-02-03T18:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxOTYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyMDc1OQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374920759", "bodyText": "Right; sorry -- you've explained this before, and I forgot.", "author": "elefeint", "createdAt": "2020-02-04T21:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxOTYwOQ=="}], "type": "inlineReview"}, {"oid": "176c2e250a6f30dd6be83700ac90579bf06ad604", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/176c2e250a6f30dd6be83700ac90579bf06ad604", "message": "PR comments", "committedDate": "2020-02-03T19:00:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkyODEzNQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374928135", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Link to Google's public endpoint containing firebase public keys.\n          \n          \n            \n            \t * Link to Google's public endpoint containing Firebase public keys.", "author": "meltsufin", "createdAt": "2020-02-04T21:18:09Z", "path": "spring-cloud-gcp-autoconfigure/src/main/java/org/springframework/cloud/gcp/autoconfigure/security/FirebaseAuthenticationProperties.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.autoconfigure.security;\n+\n+import org.springframework.boot.context.properties.ConfigurationProperties;\n+\n+/**\n+ * Firebase Authentication application properties.\n+ *\n+ * @author Vinicius Carvalho\n+ * @since 1.3\n+ */\n+@ConfigurationProperties(\"spring.cloud.gcp.security.firebase\")\n+public class FirebaseAuthenticationProperties {\n+\n+\t/**\n+\t * Link to Google's public endpoint containing firebase public keys.", "originalCommit": "176c2e250a6f30dd6be83700ac90579bf06ad604", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzMDUyOQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r374930529", "bodyText": "There's a lot of code duplication across these tests. Can we re-use some of the code?", "author": "meltsufin", "createdAt": "2020-02-04T21:23:14Z", "path": "spring-cloud-gcp-security-firebase/src/test/java/org/springframework/cloud/gcp/security/firebase/FirebaseJwtTokenDecoderTests.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Copyright 2017-2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.cloud.gcp.security.firebase;\n+\n+import java.security.PrivateKey;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.JWSHeader;\n+import com.nimbusds.jose.JWSSigner;\n+import com.nimbusds.jose.crypto.RSASSASigner;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.jwt.PlainJWT;\n+import com.nimbusds.jwt.SignedJWT;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.CacheControl;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.oauth2.core.DelegatingOAuth2TokenValidator;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidator;\n+import org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;\n+import org.springframework.security.oauth2.jwt.Jwt;\n+import org.springframework.security.oauth2.jwt.JwtException;\n+import org.springframework.security.oauth2.jwt.JwtIssuerValidator;\n+import org.springframework.security.oauth2.jwt.JwtTimestampValidator;\n+import org.springframework.web.client.RestClientException;\n+import org.springframework.web.client.RestOperations;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.isNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+/**\n+ * @author Vinicius Carvalho\n+ * @since 1.3\n+ */\n+public class FirebaseJwtTokenDecoderTests {\n+\n+\tprivate static RSAKeyGeneratorUtils keyGeneratorUtils;\n+\n+\t@BeforeClass\n+\tpublic static void setup() throws Exception {\n+\t\tkeyGeneratorUtils = new RSAKeyGeneratorUtils();\n+\t}\n+\n+\t@Test\n+\tpublic void unsignedTokenTests() {\n+\t\tJWTClaimsSet claimsSet = new JWTClaimsSet.Builder()\n+\t\t\t\t.subject(\"test-subject\")\n+\t\t\t\t.expirationTime(Date.from(Instant.now().plusSeconds(60)))\n+\t\t\t\t.build();\n+\t\tPlainJWT plainJWT = new PlainJWT(claimsSet);\n+\n+\t\tFirebaseJwtTokenDecoder decoder = new FirebaseJwtTokenDecoder(mock(RestOperations.class), \"https://spring.local\", mock(OAuth2TokenValidator.class));\n+\t\tassertThatExceptionOfType(JwtException.class)\n+\t\t\t\t.isThrownBy(() -> decoder.decode(plainJWT.serialize()))\n+\t\t\t\t.withMessageStartingWith(\"An error occurred while attempting to decode the Jwt\");\n+\t}\n+\n+\t@Test\n+\tpublic void signedTokenTests() throws Exception {", "originalCommit": "176c2e250a6f30dd6be83700ac90579bf06ad604", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4MzE3MA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2157#discussion_r376083170", "bodyText": "Let's do it in a follow up. #2179.", "author": "elefeint", "createdAt": "2020-02-06T21:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzMDUyOQ=="}], "type": "inlineReview"}, {"oid": "32b9f8e3b9e6820c04e1206c2a46a57552ce1160", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/32b9f8e3b9e6820c04e1206c2a46a57552ce1160", "message": "Fixed PR spelling errors", "committedDate": "2020-02-06T18:28:21Z", "type": "commit"}, {"oid": "dc5769183bad380fa7152a9a0cb5b90dec700181", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/dc5769183bad380fa7152a9a0cb5b90dec700181", "message": "Removed unused imports", "committedDate": "2020-02-06T18:34:46Z", "type": "commit"}]}