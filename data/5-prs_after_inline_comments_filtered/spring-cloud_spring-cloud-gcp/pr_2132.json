{"pr_number": 2132, "pr_title": "optimized eager-loading for interleaved properties", "pr_createdAt": "2020-01-23T21:42:53Z", "pr_url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132", "timeline": [{"oid": "7dc5dba0a62c4c97259f40c3d32b2229449949d0", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/7dc5dba0a62c4c97259f40c3d32b2229449949d0", "message": "optimized eager-loading for interleaved properties", "committedDate": "2020-01-23T21:40:00Z", "type": "commit"}, {"oid": "835a103c051328972e7ba010fc92e363b63e0580", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/835a103c051328972e7ba010fc92e363b63e0580", "message": "readAll test", "committedDate": "2020-01-23T21:56:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDczODg5OQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370738899", "bodyText": "Can omit \"property.isInterleaved() \" condition here, since the previous condition would have caught it.", "author": "elefeint", "createdAt": "2020-01-24T16:58:41Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/mapping/SpannerPersistentEntityImpl.java", "diffHunk": "@@ -157,6 +159,9 @@ public void addPersistentProperty(SpannerPersistentProperty property) {\n \t\telse if (!property.isInterleaved()) {\n \t\t\tthis.columnNames.add(property.getColumnName());\n \t\t}\n+\t\telse if (property.isInterleaved() && !property.isLazyInterleaved()) {", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDczOTc1NQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370739755", "bodyText": "Leave a comment about what should happen if the property is interleaved lazily (that it's skipped and not persistent)?", "author": "elefeint", "createdAt": "2020-01-24T17:00:33Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/mapping/SpannerPersistentEntityImpl.java", "diffHunk": "@@ -157,6 +159,9 @@ public void addPersistentProperty(SpannerPersistentProperty property) {\n \t\telse if (!property.isInterleaved()) {\n \t\t\tthis.columnNames.add(property.getColumnName());\n \t\t}\n+\t\telse if (property.isInterleaved() && !property.isLazyInterleaved()) {\n+\t\t\tthis.hasEagerlyLoadedProperties = true;\n+\t\t}", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MjIzNQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370742235", "bodyText": "I don't think I understand what happens if the number of parent key parts exceeds the number of child key parts. Is that even supposed to happen?", "author": "elefeint", "createdAt": "2020-01-24T17:05:57Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -169,32 +171,63 @@ private SpannerStatementQueryExecutor() {\n \t * @param <T> the type of the child persistent entity\n \t * @param writeConverter a converter to convert key values as needed to bind to the query\n \t *     statement.\n+\t * @param mappingContext mapping context\n \t * @return the Spanner statement to perform the retrieval.\n \t */\n \tpublic static <T> Statement getChildrenRowsQuery(Key parentKey,\n-\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter) {\n-\t\tStringBuilder sb = new StringBuilder(\n-\t\t\t\t\"SELECT \" + getColumnsStringForSelect(childPersistentEntity) + \" FROM \"\n-\t\t\t\t\t\t+ childPersistentEntity.tableName() + \" WHERE \");\n-\t\tStringJoiner sj = new StringJoiner(\" and \");\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\treturn getChildrenRowsQuery(KeySet.singleKey(parentKey), childPersistentEntity, writeConverter, mappingContext);\n+\t}\n+\n+\tpublic static <T> Statement getChildrenRowsQuery(KeySet keySet,\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\tStringJoiner orJoiner = new StringJoiner(\" OR \");\n \t\tList<String> tags = new ArrayList<>();\n \t\tList keyParts = new ArrayList();\n \t\tint tagNum = 0;\n \t\tList<SpannerPersistentProperty> childKeyProperties = childPersistentEntity\n \t\t\t\t.getFlattenedPrimaryKeyProperties();\n-\t\tIterator parentKeyParts = parentKey.getParts().iterator();\n-\t\twhile (parentKeyParts.hasNext()) {\n-\t\t\tSpannerPersistentProperty keyProp = childKeyProperties.get(tagNum);\n-\t\t\tString tagName = \"tag\" + tagNum;\n-\t\t\tsj.add(keyProp.getColumnName() + \" = @\" + tagName);\n-\t\t\ttags.add(tagName);\n-\t\t\tkeyParts.add(parentKeyParts.next());\n-\t\t\ttagNum++;\n+\n+\t\tfor (Key key : keySet.getKeys()) {\n+\t\t\tStringJoiner andJoiner = new StringJoiner(\" AND \", \"(\", \")\");\n+\t\t\tIterator parentKeyParts = key.getParts().iterator();\n+\t\t\twhile (parentKeyParts.hasNext()) {\n+\t\t\t\tSpannerPersistentProperty keyProp = childKeyProperties.get(tagNum % childKeyProperties.size());", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc3ODIwMg==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370778202", "bodyText": "No, it could never happen", "author": "s13o", "createdAt": "2020-01-24T18:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc5Mzk1Mg==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370793952", "bodyText": "Thanks! Then the modulo operation can be removed.", "author": "elefeint", "createdAt": "2020-01-24T19:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgxNDA5NQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370814095", "bodyText": "It is there for a reason. When you have multiple keys in the keySet, you will get more key parts, because you have multiple parents. So wee need to repeat children parts for each parent.", "author": "dmitry-s", "createdAt": "2020-01-24T19:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgyODg0Ng==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370828846", "bodyText": "Would moving int tagNum = 0 to within the for loop scope work? Then it would start at 0 for every parent key.", "author": "elefeint", "createdAt": "2020-01-24T20:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzMDA4MQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370830081", "bodyText": "That's not going to work, because tagNums have to be distinct. They are used for parameters binding.", "author": "dmitry-s", "createdAt": "2020-01-24T20:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0MjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0NDgzMA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370744830", "bodyText": "Let's check if I understand: the \"and\" conditions make sure the parent and child key for a single row match. And the \"or\" conditions match multiple rows' worth of keys?\nI would take my confusion as an opportunity to factor out some logic into helper methods. For example, the while loop could go into a method named \"singleRowKeyMatchCondition)\". Better yet, those could go into a helper class that could be unit tested.\nThe goal of this would be to make it trivial for someone troubleshooting a production issue to look at the code and understand what it's doing.", "author": "elefeint", "createdAt": "2020-01-24T17:11:45Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -169,32 +171,63 @@ private SpannerStatementQueryExecutor() {\n \t * @param <T> the type of the child persistent entity\n \t * @param writeConverter a converter to convert key values as needed to bind to the query\n \t *     statement.\n+\t * @param mappingContext mapping context\n \t * @return the Spanner statement to perform the retrieval.\n \t */\n \tpublic static <T> Statement getChildrenRowsQuery(Key parentKey,\n-\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter) {\n-\t\tStringBuilder sb = new StringBuilder(\n-\t\t\t\t\"SELECT \" + getColumnsStringForSelect(childPersistentEntity) + \" FROM \"\n-\t\t\t\t\t\t+ childPersistentEntity.tableName() + \" WHERE \");\n-\t\tStringJoiner sj = new StringJoiner(\" and \");\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\treturn getChildrenRowsQuery(KeySet.singleKey(parentKey), childPersistentEntity, writeConverter, mappingContext);\n+\t}\n+\n+\tpublic static <T> Statement getChildrenRowsQuery(KeySet keySet,\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\tStringJoiner orJoiner = new StringJoiner(\" OR \");\n \t\tList<String> tags = new ArrayList<>();\n \t\tList keyParts = new ArrayList();\n \t\tint tagNum = 0;\n \t\tList<SpannerPersistentProperty> childKeyProperties = childPersistentEntity\n \t\t\t\t.getFlattenedPrimaryKeyProperties();\n-\t\tIterator parentKeyParts = parentKey.getParts().iterator();\n-\t\twhile (parentKeyParts.hasNext()) {\n-\t\t\tSpannerPersistentProperty keyProp = childKeyProperties.get(tagNum);\n-\t\t\tString tagName = \"tag\" + tagNum;\n-\t\t\tsj.add(keyProp.getColumnName() + \" = @\" + tagName);\n-\t\t\ttags.add(tagName);\n-\t\t\tkeyParts.add(parentKeyParts.next());\n-\t\t\ttagNum++;\n+\n+\t\tfor (Key key : keySet.getKeys()) {\n+\t\t\tStringJoiner andJoiner = new StringJoiner(\" AND \", \"(\", \")\");\n+\t\t\tIterator parentKeyParts = key.getParts().iterator();\n+\t\t\twhile (parentKeyParts.hasNext()) {\n+\t\t\t\tSpannerPersistentProperty keyProp = childKeyProperties.get(tagNum % childKeyProperties.size());\n+\t\t\t\tString tagName = \"tag\" + tagNum;\n+\t\t\t\tandJoiner.add(keyProp.getColumnName() + \" = @\" + tagName);\n+\t\t\t\ttags.add(tagName);\n+\t\t\t\tkeyParts.add(parentKeyParts.next());\n+\t\t\t\ttagNum++;\n+\t\t\t}\n+\t\t\torJoiner.add(andJoiner.toString());", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0NTY3Mg==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r370745672", "bodyText": "I wonder if it makes sense to pass string builders around as the query gets constructed instead of returning strings that have to, in turn, be concatenated. For a high-volume system, all this string concatenation will add up.", "author": "elefeint", "createdAt": "2020-01-24T17:13:48Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -169,32 +171,63 @@ private SpannerStatementQueryExecutor() {\n \t * @param <T> the type of the child persistent entity\n \t * @param writeConverter a converter to convert key values as needed to bind to the query\n \t *     statement.\n+\t * @param mappingContext mapping context\n \t * @return the Spanner statement to perform the retrieval.\n \t */\n \tpublic static <T> Statement getChildrenRowsQuery(Key parentKey,\n-\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter) {\n-\t\tStringBuilder sb = new StringBuilder(\n-\t\t\t\t\"SELECT \" + getColumnsStringForSelect(childPersistentEntity) + \" FROM \"\n-\t\t\t\t\t\t+ childPersistentEntity.tableName() + \" WHERE \");\n-\t\tStringJoiner sj = new StringJoiner(\" and \");\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\treturn getChildrenRowsQuery(KeySet.singleKey(parentKey), childPersistentEntity, writeConverter, mappingContext);\n+\t}\n+\n+\tpublic static <T> Statement getChildrenRowsQuery(KeySet keySet,\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\tStringJoiner orJoiner = new StringJoiner(\" OR \");\n \t\tList<String> tags = new ArrayList<>();\n \t\tList keyParts = new ArrayList();\n \t\tint tagNum = 0;\n \t\tList<SpannerPersistentProperty> childKeyProperties = childPersistentEntity\n \t\t\t\t.getFlattenedPrimaryKeyProperties();\n-\t\tIterator parentKeyParts = parentKey.getParts().iterator();\n-\t\twhile (parentKeyParts.hasNext()) {\n-\t\t\tSpannerPersistentProperty keyProp = childKeyProperties.get(tagNum);\n-\t\t\tString tagName = \"tag\" + tagNum;\n-\t\t\tsj.add(keyProp.getColumnName() + \" = @\" + tagName);\n-\t\t\ttags.add(tagName);\n-\t\t\tkeyParts.add(parentKeyParts.next());\n-\t\t\ttagNum++;\n+\n+\t\tfor (Key key : keySet.getKeys()) {\n+\t\t\tStringJoiner andJoiner = new StringJoiner(\" AND \", \"(\", \")\");\n+\t\t\tIterator parentKeyParts = key.getParts().iterator();\n+\t\t\twhile (parentKeyParts.hasNext()) {\n+\t\t\t\tSpannerPersistentProperty keyProp = childKeyProperties.get(tagNum % childKeyProperties.size());\n+\t\t\t\tString tagName = \"tag\" + tagNum;\n+\t\t\t\tandJoiner.add(keyProp.getColumnName() + \" = @\" + tagName);\n+\t\t\t\ttags.add(tagName);\n+\t\t\t\tkeyParts.add(parentKeyParts.next());\n+\t\t\t\ttagNum++;\n+\t\t\t}\n+\t\t\torJoiner.add(andJoiner.toString());\n \t\t}\n-\t\treturn buildStatementFromSqlWithArgs(sb.toString() + sj.toString(), tags, null, writeConverter,\n+\t\tString cond = orJoiner.toString();\n+\t\tString sb = \"SELECT \" + getColumnsStringForSelect(childPersistentEntity, mappingContext) + \" FROM \"\n+\t\t\t\t+ childPersistentEntity.tableName() + (cond.isEmpty() ? \"\" : \" WHERE \" + cond);\n+\t\treturn buildStatementFromSqlWithArgs(sb, tags, null, writeConverter,\n \t\t\t\tkeyParts.toArray(), null);\n \t}\n \n+\tprivate static <C, P> String getChildrenStructsQuery(\n+\t\t\tSpannerPersistentEntity<C> childPersistentEntity,\n+\t\t\tSpannerPersistentEntity<P> parentPersistentEntity, SpannerMappingContext mappingContext,\n+\t\t\tString columnName) {\n+\t\tString tableName = childPersistentEntity.tableName();\n+\t\tList<SpannerPersistentProperty> parentKeyProperties = parentPersistentEntity\n+\t\t\t\t.getFlattenedPrimaryKeyProperties();\n+\t\tString condition = parentKeyProperties.stream()\n+\t\t\t\t.map(keyProp -> tableName + \".\" + keyProp.getColumnName()\n+\t\t\t\t\t\t+ \" = \"\n+\t\t\t\t\t\t+ parentPersistentEntity.tableName() + \".\" + keyProp.getColumnName())\n+\t\t\t\t.collect(Collectors.joining(\" AND \"));\n+\n+\t\treturn \"ARRAY (SELECT AS STRUCT \" + getColumnsStringForSelect(childPersistentEntity, mappingContext) + \" FROM \"", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1Njk2MA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r371456960", "bodyText": "Comment that when options are there the new strategy is n/a.", "author": "meltsufin", "createdAt": "2020-01-27T20:09:34Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -181,12 +181,20 @@ public long executePartitionedDmlStatement(Statement statement) {\n \t@Override\n \tpublic <T> List<T> read(Class<T> entityClass, KeySet keys,\n \t\t\tSpannerReadOptions options) {\n-\t\tSpannerPersistentEntity<?> persistentEntity = this.mappingContext\n+\t\tSpannerPersistentEntity<T> persistentEntity = (SpannerPersistentEntity<T>) this.mappingContext\n \t\t\t\t.getPersistentEntity(entityClass);\n-\t\tList<T> entities = mapToListAndResolveChildren(executeRead(persistentEntity.tableName(), keys,\n-\t\t\t\tpersistentEntity.columns(), options), entityClass,\n-\t\t\t\t(options != null) ? options.getIncludeProperties() : null,\n-\t\t\t\toptions != null && options.isAllowPartialRead());\n+\t\tList<T> entities;\n+\n+\t\tif (options == null &&", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc3OA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r371461778", "bodyText": "Cast here to List.", "author": "meltsufin", "createdAt": "2020-01-27T20:20:20Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/SpannerTemplate.java", "diffHunk": "@@ -547,14 +563,20 @@ private void resolveChildEntity(Object entity, Set<String> includeProperties) {\n \t\t\t\t\t\t\t.contains(spannerPersistentEntity.getName())) {\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n+\t\t\t\t\tObject propertyValue = accessor.getProperty(spannerPersistentProperty);", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2NzQyNA==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r371467424", "bodyText": "Can you make the for loop and the while loop separate private methods for readability?", "author": "meltsufin", "createdAt": "2020-01-27T20:33:06Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -169,32 +171,63 @@ private SpannerStatementQueryExecutor() {\n \t * @param <T> the type of the child persistent entity\n \t * @param writeConverter a converter to convert key values as needed to bind to the query\n \t *     statement.\n+\t * @param mappingContext mapping context\n \t * @return the Spanner statement to perform the retrieval.\n \t */\n \tpublic static <T> Statement getChildrenRowsQuery(Key parentKey,\n-\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter) {\n-\t\tStringBuilder sb = new StringBuilder(\n-\t\t\t\t\"SELECT \" + getColumnsStringForSelect(childPersistentEntity) + \" FROM \"\n-\t\t\t\t\t\t+ childPersistentEntity.tableName() + \" WHERE \");\n-\t\tStringJoiner sj = new StringJoiner(\" and \");\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\treturn getChildrenRowsQuery(KeySet.singleKey(parentKey), childPersistentEntity, writeConverter, mappingContext);\n+\t}\n+\n+\tpublic static <T> Statement getChildrenRowsQuery(KeySet keySet,\n+\t\t\tSpannerPersistentEntity<T> childPersistentEntity, SpannerCustomConverter writeConverter,\n+\t\t\tSpannerMappingContext mappingContext) {\n+\t\tStringJoiner orJoiner = new StringJoiner(\" OR \");\n \t\tList<String> tags = new ArrayList<>();\n \t\tList keyParts = new ArrayList();\n \t\tint tagNum = 0;\n \t\tList<SpannerPersistentProperty> childKeyProperties = childPersistentEntity\n \t\t\t\t.getFlattenedPrimaryKeyProperties();\n-\t\tIterator parentKeyParts = parentKey.getParts().iterator();\n-\t\twhile (parentKeyParts.hasNext()) {\n-\t\t\tSpannerPersistentProperty keyProp = childKeyProperties.get(tagNum);\n-\t\t\tString tagName = \"tag\" + tagNum;\n-\t\t\tsj.add(keyProp.getColumnName() + \" = @\" + tagName);\n-\t\t\ttags.add(tagName);\n-\t\t\tkeyParts.add(parentKeyParts.next());\n-\t\t\ttagNum++;\n+\n+\t\tfor (Key key : keySet.getKeys()) {", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2ODEzNQ==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r371468135", "bodyText": "isEagerlyInterleaved", "author": "meltsufin", "createdAt": "2020-01-27T20:34:54Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/repository/query/SpannerStatementQueryExecutor.java", "diffHunk": "@@ -260,9 +293,19 @@ private static void bindParameter(ValueBinder<Statement.Builder> bind,\n \t\t}\n \t}\n \n-\tpublic static String getColumnsStringForSelect(\n-\t\t\tSpannerPersistentEntity spannerPersistentEntity) {\n-\t\treturn String.join(\" , \", spannerPersistentEntity.columns());\n+\tpublic static String getColumnsStringForSelect(SpannerPersistentEntity spannerPersistentEntity, SpannerMappingContext mappingContext) {\n+\t\tStringJoiner joiner = new StringJoiner(\", \");\n+\t\tspannerPersistentEntity.doWithInterleavedProperties(persistentProperty -> {\n+\t\t\tSpannerPersistentProperty spannerPersistentProperty = (SpannerPersistentProperty) persistentProperty;\n+\t\t\tif (!spannerPersistentProperty.isLazyInterleaved()) {", "originalCommit": "835a103c051328972e7ba010fc92e363b63e0580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f3cf8019af0b5402d4c1e86493696e826f6eb6a5", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/f3cf8019af0b5402d4c1e86493696e826f6eb6a5", "message": "PR comments", "committedDate": "2020-01-29T19:46:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5NzY1Ng==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r372597656", "bodyText": "Maybe isEagerInterleaved() to be consistent with isLazyInterleaved()?", "author": "meltsufin", "createdAt": "2020-01-29T19:53:34Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/mapping/SpannerPersistentProperty.java", "diffHunk": "@@ -113,4 +113,11 @@\n \t * @return {@code true} if the property is lazily-fetched. {@code false} otherwise.\n \t */\n \tboolean isLazyInterleaved();\n+\n+\t/**\n+\t * Return whether this property is an eagerly-fetched interleaved property.\n+\t * @return {@code true} if the property is eagerly-fetched. {@code false} otherwise.\n+\t */\n+\tboolean isEagerlyInterleaved();", "originalCommit": "f3cf8019af0b5402d4c1e86493696e826f6eb6a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5ODE0Mw==", "url": "https://github.com/spring-cloud/spring-cloud-gcp/pull/2132#discussion_r372598143", "bodyText": "Can you move it closer to isLazyInterleaved definition?", "author": "meltsufin", "createdAt": "2020-01-29T19:54:37Z", "path": "spring-cloud-gcp-data-spanner/src/main/java/org/springframework/cloud/gcp/data/spanner/core/mapping/SpannerPersistentPropertyImpl.java", "diffHunk": "@@ -149,6 +149,12 @@ public boolean isInterleaved() {\n \t\treturn findAnnotation(Interleaved.class) != null;\n \t}\n \n+\t@Override\n+\tpublic boolean isEagerlyInterleaved() {", "originalCommit": "f3cf8019af0b5402d4c1e86493696e826f6eb6a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "801fca999e381690de052581fc0e99430f236393", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/801fca999e381690de052581fc0e99430f236393", "message": "PR comments", "committedDate": "2020-01-29T20:00:52Z", "type": "commit"}, {"oid": "eb24b2a4f95f8552aa621b9d1af4acef57858355", "url": "https://github.com/spring-cloud/spring-cloud-gcp/commit/eb24b2a4f95f8552aa621b9d1af4acef57858355", "message": "PR comments", "committedDate": "2020-01-29T20:32:02Z", "type": "commit"}]}