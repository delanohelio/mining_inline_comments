{"pr_number": 1430, "pr_title": "#1429 rewrite ServiceRegistryJpaImplTest to reduce TravisCI failures", "pr_createdAt": "2020-02-24T19:36:17Z", "pr_url": "https://github.com/opencast/opencast/pull/1430", "timeline": [{"oid": "18b7dceeba21d6268f95f7b60bc152344167a7c3", "url": "https://github.com/opencast/opencast/commit/18b7dceeba21d6268f95f7b60bc152344167a7c3", "message": "1429 rewrite junit to speed tests and avoid race condition collision with Service Registry Dispatch loop (ref #1281)", "committedDate": "2020-02-26T15:19:35Z", "type": "commit"}, {"oid": "18b7dceeba21d6268f95f7b60bc152344167a7c3", "url": "https://github.com/opencast/opencast/commit/18b7dceeba21d6268f95f7b60bc152344167a7c3", "message": "1429 rewrite junit to speed tests and avoid race condition collision with Service Registry Dispatch loop (ref #1281)", "committedDate": "2020-02-26T15:19:35Z", "type": "forcePushed"}, {"oid": "372006da4bd6237b281aca1a831c7e3a8f716989", "url": "https://github.com/opencast/opencast/commit/372006da4bd6237b281aca1a831c7e3a8f716989", "message": "update host fairness test with longer wait and omit creating unneeded heartbeat scheduler", "committedDate": "2020-02-26T15:59:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5NzE4NA==", "url": "https://github.com/opencast/opencast/pull/1430#discussion_r384597184", "bodyText": "Maybe safer and more consistent to use JOB_BARRIER_TIMEOUT here... it'll make the test take longer, but less likely for TravisCI to choke.", "author": "karendolan", "createdAt": "2020-02-26T16:09:54Z", "path": "modules/serviceregistry/src/test/java/org/opencastproject/serviceregistry/impl/ServiceRegistryJpaImplTest.java", "diffHunk": "@@ -252,69 +334,89 @@ public void testCancelUndispatchablesOrphanedByActivatingNode() throws Exception\n \n   @Test\n   public void testHostAddedToPriorityList() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(1, serviceRegistryJpaImpl.dispatchPriorityList.size());\n     }\n   }\n \n   @Test\n   public void testHostAddedToPriorityListExceptWorkflowType() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     serviceRegistryJpaImpl.registerService(TEST_SERVICE_3, TEST_HOST, TEST_PATH_3);\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_3, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(0, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+    } finally {\n+      // extra clean up\n+      serviceRegistryJpaImpl.unRegisterService(TEST_SERVICE_3, TEST_HOST);\n     }\n-\n   }\n \n   @Test\n   public void testHostsBeingRemovedFromPriorityList() throws Exception {\n-    if (serviceRegistryJpaImpl.scheduledExecutor != null)\n-      serviceRegistryJpaImpl.scheduledExecutor.shutdown();\n-    serviceRegistryJpaImpl.scheduledExecutor = Executors.newScheduledThreadPool(1);\n-    serviceRegistryJpaImpl.activate(null);\n-    Hashtable<String, String> properties = new Hashtable<>();\n-    properties.put(\"dispatch.interval\", \"1\");\n-    serviceRegistryJpaImpl.updated(properties);\n-    registerTestHostAndService();\n     serviceRegistryJpaImpl.dispatchPriorityList.put(0L, TEST_HOST);\n     Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_2, TEST_OPERATION, null, null, true, null);\n     JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob);\n+    launchDispatcherOnce(false);\n     try {\n-      barrier.waitForJobs(2000);\n-      Assert.fail();\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n     } catch (Exception e) {\n       Assert.assertEquals(0, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+    } finally {\n+      logger.debug(\"end testHostsBeingRemovedFromPriorityList\");\n+    }\n+  }\n+\n+  @Test\n+  public void testIgnoreHostsInPriorityList() throws Exception {\n+    Job testJob = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE_2, TEST_OPERATION, null, null, true, null);\n+    Job testJob2 = serviceRegistryJpaImpl.createJob(TEST_HOST, TEST_SERVICE, TEST_OPERATION, null, null, true, null);\n+    serviceRegistryJpaImpl.dispatchPriorityList.put(testJob2.getId(), TEST_HOST);\n+    JobBarrier barrier = new JobBarrier(null, serviceRegistryJpaImpl, testJob, testJob2);\n+    launchDispatcherOnce(false);\n+    try {\n+      barrier.waitForJobs(JOB_BARRIER_TIMEOUT);\n+      Assert.fail(\"Did not recieve a timeout exception\");\n+    } catch (Exception e) {\n+      logger.debug(\"job1: '{}'\", serviceRegistryJpaImpl.getJob(testJob.getId()));\n+      logger.debug(\"job2: '{}'\", serviceRegistryJpaImpl.getJob(testJob2.getId()));\n+      for (Long jobId :serviceRegistryJpaImpl.dispatchPriorityList.keySet()) {\n+        logger.debug(\"job in priority queue: {}, {}\", jobId, serviceRegistryJpaImpl.dispatchPriorityList.get(jobId));\n+      }\n+      // Mock http client always returns 503 for this path so it won't be dispatched anyway\n+      testJob = serviceRegistryJpaImpl.getJob(testJob.getId());\n+      Assert.assertTrue(\"First job should not have a processing host\", StringUtils.isBlank(testJob.getProcessingHost()));\n+      Assert.assertEquals(\"First job is queueued\", Job.Status.QUEUED, testJob.getStatus());\n+\n+      // Mock http client always returns 204 for this path, but it should not be dispatched\n+      // because the host is in the dispatchPriorityList\n+      testJob2 = serviceRegistryJpaImpl.getJob(testJob2.getId());\n+      Assert.assertTrue(\"Second job should not have a processing host\", StringUtils.isBlank(testJob2.getProcessingHost()));\n+      Assert.assertEquals(\"Second job is queueued\", Job.Status.QUEUED, testJob2.getStatus());\n+\n+      Assert.assertEquals(1, serviceRegistryJpaImpl.dispatchPriorityList.size());\n+      String blockingHost = serviceRegistryJpaImpl.dispatchPriorityList.get(testJob2.getId());\n+      Assert.assertEquals(TEST_HOST, blockingHost);\n+    } finally {\n+      logger.debug(\"end testIgnoreHostsInPriorityList\");\n     }\n   }\n \n   private void assertHostloads(Job j, Float a, Float b, Float c) throws Exception {\n-    Thread.sleep(1100); //1100 is 100ms more than the minimum job dispatch interval.  Setting this lower causes race conditions.\n+    // launch the  dispatcher and wait a little longer for dispatch to complete before getting job\n+    launchDispatcherOnce(false);\n+    Thread.sleep(3 * DISPATCH_START_DELAY);", "originalCommit": "372006da4bd6237b281aca1a831c7e3a8f716989", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ce29c47fbddcc5e46d37005687d8eb2bc530fa8c", "url": "https://github.com/opencast/opencast/commit/ce29c47fbddcc5e46d37005687d8eb2bc530fa8c", "message": "More consitent use of JOB_BARRIER_TIMEOUT param", "committedDate": "2020-02-26T16:12:24Z", "type": "commit"}]}