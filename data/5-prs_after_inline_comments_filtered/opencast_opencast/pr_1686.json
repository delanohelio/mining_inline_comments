{"pr_number": 1686, "pr_title": "Workflow Operation \"CutMarksToSmil\"", "pr_createdAt": "2020-07-08T06:55:52Z", "pr_url": "https://github.com/opencast/opencast/pull/1686", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwMjMwNA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459502304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      logger.warn(\"Unable to delete element {}: {}\", elem, e);\n          \n          \n            \n                      logger.warn(\"Unable to delete element {}\", elem, e);", "author": "lkiesow", "createdAt": "2020-07-23T14:42:01Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDExNA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459504114", "bodyText": "I tend to think we should rather fail here.\nOtherwise, we might accidentally publish uncut material without anyone notiving", "author": "lkiesow", "createdAt": "2020-07-23T14:44:31Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMTE3Nw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459901177", "bodyText": "The choice to skip instead of fail if no (or too many) catalogs are provided was made to be consistent with the behaviour of the VideoEditor WHO, which also does not fail if no cataloge is provided. Therefore I'd rather not fail here, although maybe it would be better to fail if there >1 cataloges.", "author": "Arnei", "createdAt": "2020-07-24T07:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNDU4Nw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459504587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n          \n          \n            \n                  logger.debug(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);", "author": "lkiesow", "createdAt": "2020-07-23T14:45:08Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwNjg3Nw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459506877", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Done Adding tracks\");\n          \n          \n            \n                  logger.info(\"Done adding tracks\");", "author": "lkiesow", "createdAt": "2020-07-23T14:48:06Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUwODIzNA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459508234", "bodyText": "Maybe use Java's try-with-resources statement", "author": "lkiesow", "createdAt": "2020-07-23T14:49:54Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxMTI4Mg==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459511282", "bodyText": "Why re-define skip as continue? That seems wrong.\nI dont' actually see the purpose of this method at all.", "author": "lkiesow", "createdAt": "2020-07-23T14:53:58Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNDcyMg==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459514722", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } catch (NotFoundException e) {\n          \n          \n            \n                  throw new WorkflowOperationException(\n          \n          \n            \n                          \"Error finding the media file in the workspace\", e);\n          \n          \n            \n                } catch (IOException e) {\n          \n          \n            \n                } catch (NotFoundException | IOException e) {", "author": "lkiesow", "createdAt": "2020-07-23T14:58:21Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }\n+\n+  /**\n+   * @param flavorType\n+   *          either \"presenter\" or \"presentation\", just for error messages\n+   */\n+  private MediaPackageElementFlavor parseTargetFlavor(String flavor, String flavorType)\n+          throws WorkflowOperationException {\n+    final MediaPackageElementFlavor targetFlavor;\n+    try {\n+      targetFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n+      if (\"*\".equals(targetFlavor.getType()) || \"*\".equals(targetFlavor.getSubtype())) {\n+        throw new WorkflowOperationException(format(\n+                \"Target %s flavor must have a type and a subtype, '*' are not allowed!\", flavorType));\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new WorkflowOperationException(format(\"Target %s flavor '%s' is malformed\", flavorType, flavor));\n+    }\n+    return targetFlavor;\n+  }\n+\n+  private String getMediaPackageElementPath(MediaPackageElement mpe) throws WorkflowOperationException {\n+    File mediaFile;\n+    try {\n+      mediaFile = workspace.get(mpe.getURI());\n+    } catch (NotFoundException e) {\n+      throw new WorkflowOperationException(\n+              \"Error finding the media file in the workspace\", e);\n+    } catch (IOException e) {", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNTA4MA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459515080", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String filePath = mediaFile.getAbsolutePath();\n          \n          \n            \n                return filePath;\n          \n          \n            \n                return mediaFile.getAbsolutePath();", "author": "lkiesow", "createdAt": "2020-07-23T14:58:49Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;\n+import static java.lang.String.format;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.composer.api.EncoderException;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.MediaPackageException;\n+import org.opencastproject.mediapackage.MediaPackageSupport;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.serviceregistry.api.ServiceRegistryException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_PRESENTER_FLAVOR = \"source-presenter-flavor\";\n+  private static final String SOURCE_PRESENTATION_FLAVOR = \"source-presentation-flavor\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_PRESENTER_FLAVOR = \"target-presenter-flavor\";\n+  private static final String TARGET_PRESENTATION_FLAVOR = \"target-presentation-flavor\";\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    List<MediaPackageElement> elementsToClean = new ArrayList<MediaPackageElement>();\n+\n+    try {\n+      return cutMarksToSmil(workflowInstance.getMediaPackage(), workflowInstance.getCurrentOperation(), elementsToClean);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(e);\n+    } finally {\n+      for (MediaPackageElement elem : elementsToClean) {\n+        try {\n+          workspace.delete(elem.getURI());\n+        } catch (Exception e) {\n+          logger.warn(\"Unable to delete element {}: {}\", elem, e);\n+        }\n+      }\n+    }\n+  }\n+\n+  private WorkflowOperationResult cutMarksToSmil(MediaPackage src, WorkflowOperationInstance operation,\n+          List<MediaPackageElement> elementsToClean) throws EncoderException, IOException, NotFoundException,\n+          MediaPackageException, WorkflowOperationException, ServiceRegistryException {\n+    final MediaPackage mediaPackage = (MediaPackage) src.clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor presenterFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTER_FLAVOR), \"presenter\");\n+    final MediaPackageElementFlavor presentationFlavor = parseTargetFlavor(\n+            getConfig(operation, SOURCE_PRESENTATION_FLAVOR), \"presentation\");\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return skip(mediaPackage);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    /** Create the new SMIL document **/\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    List<Track> videosPresenter = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presenterFlavor).toFn()).toList();\n+    List<Track> videosPresentation = $(mediaPackage.getTracks()).filter(\n+            MediaPackageSupport.Filters.matchesFlavor(presentationFlavor).toFn()).toList();\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Handle more than exactly one track per flavor\n+    if (videosPresenter.size() != 1 || videosPresentation.size() != 1) {\n+      for (Track track : videosPresenter) {\n+        logger.info(\"VideosPresenter track: {}\", track);\n+      }\n+      for (Track track : videosPresentation) {\n+        logger.info(\"VideosPresentation track: {}\", track);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor must be exactly one.\");\n+    }\n+\n+    Track presenterTrack = videosPresenter.get(0);\n+    Track presentationTrack = videosPresentation.get(0);\n+    logger.info(\"PresenterTrack duration: {}, PresentationTrack duration {}\", presenterTrack.getDuration(),\n+            presentationTrack.getDuration());\n+\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        // add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      Smil smil = smilResponse.getSmil();\n+      logger.info(\"Done Adding tracks\");\n+      InputStream is = null;\n+      try {\n+        // Put new SMIL into workspace and add to mediapackage\n+        is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\");\n+        URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+        MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+        Catalog catalog = (Catalog) mpeBuilder\n+                .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+        catalog.setIdentifier(smil.getId());\n+        mediaPackage.add(catalog);\n+      } finally {\n+        IOUtils.closeQuietly(is);\n+      }\n+    } catch (Exception ex) {\n+      throw new WorkflowOperationException(\n+              format(\"Failed to create SMIL catalog for mediapackage %s\", mediaPackage.getIdentifier().toString()), ex);\n+    }\n+\n+    return skip(mediaPackage);\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.AbstractWorkflowOperationHandler#skip(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  private WorkflowOperationResult skip(MediaPackage mediaPackage) {\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Partial import operation completed\");\n+    return result;\n+  }\n+\n+  /**\n+   * @param flavorType\n+   *          either \"presenter\" or \"presentation\", just for error messages\n+   */\n+  private MediaPackageElementFlavor parseTargetFlavor(String flavor, String flavorType)\n+          throws WorkflowOperationException {\n+    final MediaPackageElementFlavor targetFlavor;\n+    try {\n+      targetFlavor = MediaPackageElementFlavor.parseFlavor(flavor);\n+      if (\"*\".equals(targetFlavor.getType()) || \"*\".equals(targetFlavor.getSubtype())) {\n+        throw new WorkflowOperationException(format(\n+                \"Target %s flavor must have a type and a subtype, '*' are not allowed!\", flavorType));\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new WorkflowOperationException(format(\"Target %s flavor '%s' is malformed\", flavorType, flavor));\n+    }\n+    return targetFlavor;\n+  }\n+\n+  private String getMediaPackageElementPath(MediaPackageElement mpe) throws WorkflowOperationException {\n+    File mediaFile;\n+    try {\n+      mediaFile = workspace.get(mpe.getURI());\n+    } catch (NotFoundException e) {\n+      throw new WorkflowOperationException(\n+              \"Error finding the media file in the workspace\", e);\n+    } catch (IOException e) {\n+      throw new WorkflowOperationException(\n+              \"Error reading the media file in the workspace\", e);\n+    }\n+\n+    String filePath = mediaFile.getAbsolutePath();\n+    return filePath;", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjg0Nw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r459516847", "bodyText": "We passed a rule that we won't accept new code using the Entwine Functional Library unless it really can't be avoided. For this pull request, you can easily use other means to archive the same goal.\nPlease avoid it.", "author": "lkiesow", "createdAt": "2020-07-23T15:01:08Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import static com.entwinemedia.fn.Stream.$;", "originalCommit": "07bf9c8aa7fc1e2c61540dd5afd93c593e99ae51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA2ODYyNw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r460068627", "bodyText": "Understood, thanks for the heads up.", "author": "Arnei", "createdAt": "2020-07-24T13:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDE3Mg==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344172", "bodyText": "Skipping this if there is none may be fine but skipping it if there are multiple catalogs is weird and unexpected. I would expect that they are both converted or that there is an error.", "author": "lkiesow", "createdAt": "2020-09-12T00:37:10Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");", "originalCommit": "05f5b252cb5b2cf4a2b9cb709d849da027dac866", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3ODQ5Nw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487878497", "bodyText": "Right, that makes sense. I'll have it throw an error in that case for now, since processing multiple catalogs seems non-trivial (e.g. what if there are overlapping cutmarks).", "author": "Arnei", "createdAt": "2020-09-14T12:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDM1Ng==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344356", "bodyText": "Use the cause argument of exception constructors:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n          \n          \n            \n                  throw new WorkflowOperationException(\"Could not read JSON\", e);", "author": "lkiesow", "createdAt": "2020-09-12T00:38:47Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);", "originalCommit": "05f5b252cb5b2cf4a2b9cb709d849da027dac866", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDU2MA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344560", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new WorkflowOperationException(\"Times cannot be negative!\");\n          \n          \n            \n                    throw new WorkflowOperationException(\"Times may not be negative.\");", "author": "lkiesow", "createdAt": "2020-09-12T00:40:13Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");", "originalCommit": "05f5b252cb5b2cf4a2b9cb709d849da027dac866", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NDY1OA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487344658", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                logger.info(\"Get Tracks from Mediapackage\");\n          \n          \n            \n                logger.info(\"Get tracks from media package\");", "author": "lkiesow", "createdAt": "2020-09-12T00:40:50Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");", "originalCommit": "05f5b252cb5b2cf4a2b9cb709d849da027dac866", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTEyNw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345127", "bodyText": "A flavor is no collection. It's an attribute:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Track {} in flavor {}\", track, flavor);\n          \n          \n            \n                    logger.info(\"Track {} with flavor {}\", track, flavor);", "author": "lkiesow", "createdAt": "2020-09-12T00:44:19Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);", "originalCommit": "05f5b252cb5b2cf4a2b9cb709d849da027dac866", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345323", "bodyText": "Is there a reason why there can be only one video with a given flavor in this operation?", "author": "lkiesow", "createdAt": "2020-09-12T00:45:27Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");\n+      for (Times mark : cutmarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[tracksFromFlavors.size()]), //new Track[] { presenterTrack, presentationTrack },\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to mediapackage\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private Optional<Track> getTrackFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage)\n+          throws WorkflowOperationException {\n+    Optional<Track> result = Optional.empty();\n+\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<Track>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      }\n+    }\n+\n+    // Check for number of videos to avoid any issues\n+    // Possible TODO: Can we handle more than one track per flavor?\n+    if (videos.isEmpty())\n+      return result;\n+    if (videos.size() > 1) {\n+      for (Track track : videos) {\n+        logger.info(\"Track {} in flavor {}\", track, flavor);\n+      }\n+      throw new WorkflowOperationException(\"The number of videos in each flavor cannot be more than one.\");", "originalCommit": "05f5b252cb5b2cf4a2b9cb709d849da027dac866", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NDQ4NA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487894484", "bodyText": "Iirc the reason for that was that the behaviour for multiple tracks in the same flavor is undefined in the editor. So this basically acts as an early error check.", "author": "Arnei", "createdAt": "2020-09-14T13:03:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE1OTMxNg==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r488159316", "bodyText": "That sounds like a bug in the editor. For some operations, you actually need multiple tracks with identical flavors. Letting it break here and kind of building more bugs doesn't sound right ;-)", "author": "lkiesow", "createdAt": "2020-09-14T19:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjIzNw==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r495936237", "bodyText": "That does make sense. I just did some testing on the matter and having multiple videos in one flavor seems to work just fine. Applied your suggest change with commit 6e9702c .", "author": "Arnei", "createdAt": "2020-09-28T13:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0NTU1OA==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r487345558", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  logger.info(\"Start Adding tracks\");\n          \n          \n            \n                  logger.info(\"Start adding tracks\");", "author": "lkiesow", "createdAt": "2020-09-12T00:47:04Z", "path": "modules/composer-workflowoperation/src/main/java/org/opencastproject/workflow/handler/composer/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.composer;\n+\n+import org.opencastproject.composer.api.ComposerService;\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(PartialImportWorkflowOperationHandler.class);\n+\n+  /** The composer service */\n+  private ComposerService composerService = null;\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for the OSGi declarative services configuration.\n+   *\n+   * @param composerService\n+   *          the local composer service\n+   */\n+  public void setComposerService(ComposerService composerService) {\n+    this.composerService = composerService;\n+  }\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+\n+  /** Stores information read from JSON */\n+  class Times {\n+    private Long begin;\n+    private Long duration;\n+\n+    public Long getStartTime() {\n+      return begin;\n+    }\n+    public void setStartTime(Long startTime) {\n+      this.begin = startTime;\n+    }\n+    public Long getDuration() {\n+      return duration;\n+    }\n+    public void setDuration(Long duration) {\n+      this.duration = duration;\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length != 1) {\n+      logger.warn(\"Number of catalogs in the source flavor does not equal one. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Parse JSON\n+    Times[] cutmarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutmarks = gson.fromJson(bufferedReader, Times[].class);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON: \" + e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutmarks.length < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutmarks) {\n+      logger.info(\"Entry begin {}, Entry duration {}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times cannot be negative!\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get Tracks from Mediapackage\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Track from Flavor {}\", flavor);\n+      Optional<Track> track = getTrackFromFlavor(flavor, mediaPackage);\n+      if (track.isPresent()) {\n+        tracksFromFlavors.add(track.get());\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+      return result;\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start Adding tracks\");", "originalCommit": "05f5b252cb5b2cf4a2b9cb709d849da027dac866", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "46fa471a935f853b73ac3311fa7089c8c6429118", "url": "https://github.com/opencast/opencast/commit/46fa471a935f853b73ac3311fa7089c8c6429118", "message": "Improve Cut Marks to Smil Operation\n\nThis patch fixes and improves the cut-marks to Smil operation. It's\nmainly minor code fixes and a few dependency fixes. This should not have\nchanged the overall functionality.", "committedDate": "2021-01-13T18:28:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r556745501", "bodyText": "I'm wondering if there is a specific reason to require video streams to be present. This would mean that we cannot cut audio and also that we need to make sure that we run inspect on the media package before we run this operation.", "author": "lkiesow", "createdAt": "2021-01-13T18:37:17Z", "path": "modules/smil-workflowoperation/src/main/java/org/opencastproject/workflow/handler/smil/CutMarksToSmilWorkflowOperationHandler.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+package org.opencastproject.workflow.handler.smil;\n+\n+import org.opencastproject.job.api.JobContext;\n+import org.opencastproject.mediapackage.Catalog;\n+import org.opencastproject.mediapackage.MediaPackage;\n+import org.opencastproject.mediapackage.MediaPackageElement;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilder;\n+import org.opencastproject.mediapackage.MediaPackageElementBuilderFactory;\n+import org.opencastproject.mediapackage.MediaPackageElementFlavor;\n+import org.opencastproject.mediapackage.Track;\n+import org.opencastproject.mediapackage.selector.TrackSelector;\n+import org.opencastproject.smil.api.SmilException;\n+import org.opencastproject.smil.api.SmilResponse;\n+import org.opencastproject.smil.api.SmilService;\n+import org.opencastproject.smil.entity.api.Smil;\n+import org.opencastproject.smil.entity.media.container.api.SmilMediaContainer;\n+import org.opencastproject.util.NotFoundException;\n+import org.opencastproject.workflow.api.AbstractWorkflowOperationHandler;\n+import org.opencastproject.workflow.api.WorkflowInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationException;\n+import org.opencastproject.workflow.api.WorkflowOperationInstance;\n+import org.opencastproject.workflow.api.WorkflowOperationResult;\n+import org.opencastproject.workspace.api.Workspace;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.xml.sax.SAXException;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Type;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import javax.xml.bind.JAXBException;\n+\n+/**\n+ * The workflow definition for converting a smil containing cut marks into a legal smil for cutting\n+ */\n+public class CutMarksToSmilWorkflowOperationHandler extends AbstractWorkflowOperationHandler {\n+\n+  /** Workflow configuration keys */\n+  private static final String SOURCE_MEDIA_FLAVORS = \"source-media-flavors\";\n+  private static final String SOURCE_JSON_FLAVOR = \"source-json-flavor\";\n+\n+  private static final String TARGET_SMIL_FLAVOR = \"target-smil-flavor\";\n+  private static final String TARGET_TAGS = \"target-tags\";\n+\n+  private static final String CUTTING_SMIL_NAME = \"prepared_cutting_smil\";\n+\n+  /** The logging facility */\n+  private static final Logger logger = LoggerFactory.getLogger(CutMarksToSmilWorkflowOperationHandler.class);\n+\n+  /** The local workspace */\n+  private Workspace workspace = null;\n+\n+  /**\n+   * Callback for declarative services configuration that will introduce us to the local workspace service.\n+   * Implementation assumes that the reference is configured as being static.\n+   *\n+   * @param workspace\n+   *          an instance of the workspace\n+   */\n+  public void setWorkspace(Workspace workspace) {\n+    this.workspace = workspace;\n+  }\n+\n+  /**\n+   * The SMIL service to modify SMIL files.\n+   */\n+  private SmilService smilService;\n+  public void setSmilService(SmilService smilService) {\n+    this.smilService = smilService;\n+  }\n+\n+  /** JSON Parser */\n+  private static final Gson gson = new Gson();\n+  private static final Type timesListType = new TypeToken<List<Times>>() { }.getType();\n+\n+  /** Stores information read from JSON */\n+  static class Times {\n+    private Long begin;\n+    private Long duration;\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * @see org.opencastproject.workflow.api.WorkflowOperationHandler#start(org.opencastproject.workflow.api.WorkflowInstance,\n+   *      JobContext)\n+   */\n+  @Override\n+  public WorkflowOperationResult start(final WorkflowInstance workflowInstance, JobContext context)\n+          throws WorkflowOperationException {\n+    logger.info(\"Running cut marks to smil workflow operation on workflow {}\", workflowInstance.getId());\n+\n+    WorkflowOperationInstance operation = workflowInstance.getCurrentOperation();\n+    final MediaPackage mediaPackage = (MediaPackage) workflowInstance.getMediaPackage().clone();\n+\n+    // Read config options\n+    final MediaPackageElementFlavor jsonFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, SOURCE_JSON_FLAVOR));\n+    final MediaPackageElementFlavor targetSmilFlavor = MediaPackageElementFlavor.parseFlavor(\n+            getConfig(operation, TARGET_SMIL_FLAVOR));\n+\n+    String flavorNames = operation.getConfiguration(SOURCE_MEDIA_FLAVORS);\n+    final List<MediaPackageElementFlavor> flavors = new ArrayList<MediaPackageElementFlavor>();\n+    for (String flavorName : asList(flavorNames))\n+      flavors.add(MediaPackageElementFlavor.parseFlavor(flavorName));\n+\n+    // Target tags\n+    String targetTagsOption = StringUtils.trimToNull(operation.getConfiguration(TARGET_TAGS));\n+    List<String> targetTags = asList(targetTagsOption);\n+\n+    // Is there a catalog?\n+    Catalog[] catalogs = mediaPackage.getCatalogs(jsonFlavor);\n+    if (catalogs.length < 1) {\n+      logger.warn(\"No catalogs in the source flavor. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    } else if (catalogs.length > 1) {\n+      throw new WorkflowOperationException(\"More than one catalog in the source flavor! Make sure there is only catalog.\");\n+    }\n+\n+    // Parse JSON\n+    List<Times> cutMarks;\n+    Catalog jsonWithTimes = catalogs[0];\n+    try (BufferedReader bufferedReader = new BufferedReader(new FileReader(getMediaPackageElementPath(jsonWithTimes)))) {\n+      cutMarks = gson.fromJson(bufferedReader, timesListType);\n+    } catch (Exception e) {\n+      throw new WorkflowOperationException(\"Could not read JSON\", e);\n+    }\n+\n+    // If the catalog was empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"Source JSON did not contain any timestamps! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check parsing results\n+    for (Times entry : cutMarks) {\n+      logger.debug(\"Entry begin={}, duration={}\", entry.begin, entry.duration);\n+      if (entry.begin < 0 || entry.duration < 0) {\n+        throw new WorkflowOperationException(\"Times may not be negative.\");\n+      }\n+    }\n+\n+    // Get video tracks\n+    logger.info(\"Get tracks from media package\");\n+    ArrayList<Track> tracksFromFlavors = new ArrayList<>();\n+    for (MediaPackageElementFlavor flavor : flavors) {\n+      logger.debug(\"Trying to get Tracks from Flavor {}\", flavor);\n+      List<Track> tracks = getTracksFromFlavor(flavor, mediaPackage);\n+      logger.debug(\"Found {} tracks in flavor {}\", tracks.size(), flavor);\n+      if (tracks.size() > 0) {\n+        tracksFromFlavors.addAll(tracks);\n+      }\n+    }\n+\n+    // Are there actually any tracks?\n+    if (tracksFromFlavors.isEmpty()) {\n+      logger.warn(\"None of the given flavors contained a track. Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Check for cut marks that would lead to errors with the given tracks and remove them\n+    // Possible TODO: Instead of removing, only apply cut marks to tracks with a long enough duration?\n+    // Get the shortest duration of all tracks\n+    long shortestDuration = Long.MAX_VALUE;\n+    for (Track track : tracksFromFlavors) {\n+      if (track.getDuration() < shortestDuration) {\n+        shortestDuration = track.getDuration();\n+      }\n+    }\n+    // Remove all timestamps that begin after the shortest duration\n+    ListIterator<Times> iter = cutMarks.listIterator();\n+    while (iter.hasNext()) {\n+      long begin = iter.next().begin;\n+      if (begin > shortestDuration) {\n+        logger.info(\"Skipped mark with begin: {}, \", begin);\n+        iter.remove();\n+      }\n+    }\n+    // If the timestamp list is now empty, give up\n+    if (cutMarks.size() < 1) {\n+      logger.warn(\"No timestamps are valid for the given tracks! Skipping...\");\n+      return createResult(mediaPackage, WorkflowOperationResult.Action.SKIP);\n+    }\n+\n+    // Create the new SMIL document\n+    Smil smil;\n+    try {\n+      SmilResponse smilResponse = smilService.createNewSmil(mediaPackage);\n+\n+      logger.info(\"Start adding tracks\");\n+      for (Times mark : cutMarks) {\n+        smilResponse = smilService.addParallel(smilResponse.getSmil());\n+        SmilMediaContainer par = (SmilMediaContainer) smilResponse.getEntity();\n+        logger.debug(\"Segment begin: {}; Segment duration: {}\", mark.begin, mark.duration);\n+        // Add tracks (as array) to par\n+        smilResponse = smilService\n+                .addClips(smilResponse.getSmil(),\n+                        par.getId(),\n+                        tracksFromFlavors.toArray(new Track[0]),\n+                        mark.begin,\n+                        mark.duration);\n+      }\n+\n+      smil = smilResponse.getSmil();\n+      logger.info(\"Done adding tracks\");\n+    } catch (SmilException e) {\n+      throw new WorkflowOperationException(\"Failed to create SMIL Catalog\", e);\n+    }\n+\n+    // Put new SMIL into workspace and add it to media package\n+    try (InputStream is = IOUtils.toInputStream(smil.toXML(), \"UTF-8\")) {\n+      URI smilURI = workspace.put(mediaPackage.getIdentifier().toString(), smil.getId(), CUTTING_SMIL_NAME, is);\n+      MediaPackageElementBuilder mpeBuilder = MediaPackageElementBuilderFactory.newInstance().newElementBuilder();\n+      Catalog catalog = (Catalog) mpeBuilder\n+              .elementFromURI(smilURI, MediaPackageElement.Type.Catalog, targetSmilFlavor);\n+      catalog.setIdentifier(smil.getId());\n+      for (String tag : targetTags) {\n+        catalog.addTag(tag);\n+      }\n+      mediaPackage.add(catalog);\n+    } catch (JAXBException | SAXException | IOException e) {\n+      throw new WorkflowOperationException(\"Failed to parse crated SMIL Catalog\", e);\n+    }\n+\n+    final WorkflowOperationResult result = createResult(mediaPackage, WorkflowOperationResult.Action.CONTINUE);\n+    logger.debug(\"Cut marks to smil operation completed\");\n+    return result;\n+  }\n+\n+  private List<Track> getTracksFromFlavor(MediaPackageElementFlavor flavor, MediaPackage mediaPackage) {\n+    // Get tracks from flavor\n+    TrackSelector trackSelector = new TrackSelector();\n+    trackSelector.addFlavor(flavor);\n+    Collection<Track> tracks = trackSelector.select(mediaPackage, false);\n+\n+    // Get only videos\n+    ArrayList<Track> videos = new ArrayList<>();\n+    for (Track video : tracks) {\n+      if (video.hasVideo()) {\n+        videos.add((video));\n+      } else {\n+        logger.debug(\"Skipping track {} since it does not seem to have a vide track.\", video);\n+      }\n+    }", "originalCommit": "46fa471a935f853b73ac3311fa7089c8c6429118", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzI3NTE0Mg==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r557275142", "bodyText": "I honestly do not remember why only video tracks were allowed (should've commented on that, arg). I'll try and see if I can't figure it out.", "author": "Arnei", "createdAt": "2021-01-14T09:59:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzI4NzA5OQ==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r557287099", "bodyText": "Whatever the reason was that I originally implemented this, it seems to have vanished.  So I suppose this code snippet could be removed.", "author": "Arnei", "createdAt": "2021-01-14T10:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA4OTg0MQ==", "url": "https://github.com/opencast/opencast/pull/1686#discussion_r562089841", "bodyText": "Removed the filter. Now it's just the track selector.", "author": "lkiesow", "createdAt": "2021-01-21T18:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0NTUwMQ=="}], "type": "inlineReview"}, {"oid": "db8b9cbde33636112940a66f4d3f181866e09f3e", "url": "https://github.com/opencast/opencast/commit/db8b9cbde33636112940a66f4d3f181866e09f3e", "message": "Cut Marks to Smil Documentation\n\nThis patch adds some additional documentation about the new workflow\noperation handler.", "committedDate": "2021-01-13T20:44:26Z", "type": "forcePushed"}, {"oid": "37d032cfc1af079064dcf7a3f12898dbcbfa7a26", "url": "https://github.com/opencast/opencast/commit/37d032cfc1af079064dcf7a3f12898dbcbfa7a26", "message": "WorkflowOperationHandler \"CutMarksToSmil\"\n\nThis operation parses a JSON containing cut marks into a SMIL that can\nbe used by the VideoEditorWorkflowOperation. It does this by attributing\nthe given times to the tracks in the given presentation and presenter\nflavors. This is useful in case you have cutmarks that need to be\napplied to files that are created during a workflow.\n\nUse-case example: Sending raw recording data from a web-conferencing\napplication to Opencast, where Opencast should first concatenate the\ndata and then cut the concatenated video file by user-defined cut marks.\n\nAlso adds a workflow showcasing the functionality.\n\nCo-authored-by: Lars Kiesow <lkiesow@uos.de>", "committedDate": "2021-01-25T16:24:48Z", "type": "commit"}, {"oid": "8863e6904619f7c506ac7f5aba3af1b166bc3c0b", "url": "https://github.com/opencast/opencast/commit/8863e6904619f7c506ac7f5aba3af1b166bc3c0b", "message": "Improve Cut Marks to Smil Operation\n\nThis patch fixes and improves the cut-marks to Smil operation. It's\nmainly minor code fixes and a few dependency fixes. This should not have\nchanged the overall functionality.", "committedDate": "2021-01-25T16:24:58Z", "type": "commit"}, {"oid": "2f33a33873e0df39d32280d69263bc35677c2a6b", "url": "https://github.com/opencast/opencast/commit/2f33a33873e0df39d32280d69263bc35677c2a6b", "message": "Cut Marks to Smil Documentation\n\nThis patch adds some additional documentation about the new workflow\noperation handler.", "committedDate": "2021-01-25T16:24:58Z", "type": "commit"}, {"oid": "6954fc874503c145c8740c2db762dc44096ccdda", "url": "https://github.com/opencast/opencast/commit/6954fc874503c145c8740c2db762dc44096ccdda", "message": "Apply Review Suggestions\n\nThis patch contains some slight improvements to the `cut-marks-to-smil`\noperation handler.", "committedDate": "2021-01-25T16:29:46Z", "type": "commit"}, {"oid": "6954fc874503c145c8740c2db762dc44096ccdda", "url": "https://github.com/opencast/opencast/commit/6954fc874503c145c8740c2db762dc44096ccdda", "message": "Apply Review Suggestions\n\nThis patch contains some slight improvements to the `cut-marks-to-smil`\noperation handler.", "committedDate": "2021-01-25T16:29:46Z", "type": "forcePushed"}]}