{"pr_number": 1790, "pr_title": "[HADOOP-16818] ABFS: Combine append+flush calls for blockblob & appendblob", "pr_createdAt": "2020-01-03T10:09:54Z", "pr_url": "https://github.com/apache/hadoop/pull/1790", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTUxNg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363151516", "bodyText": "This config value is passed until AbfsOutputStream.java -> writeCurrentBufferToService() as the first argument. but no specific action is seen inside writeCurrentBufferToService() if the value is true or false.\nWhat is intended of this config ? is it required ?", "author": "snvijaya", "createdAt": "2020-01-06T04:00:46Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AbfsConfiguration.java", "diffHunk": "@@ -146,6 +150,10 @@\n       DefaultValue = DEFAULT_ENABLE_FLUSH)\n   private boolean enableFlush;\n \n+  @BooleanConfigurationValidatorAnnotation(ConfigurationKey = FS_AZURE_ENABLE_APPEND_WITH_FLUSH,\n+      DefaultValue = DEFAULT_ENABLE_APPEND_WITH_FLUSH)\n+  private boolean enableAppendWithFlush;", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3MTM3Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365171372", "bodyText": "Last iteration added has bought in the missing code piece.", "author": "snvijaya", "createdAt": "2020-01-10T10:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTY1Mw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363151653", "bodyText": "New configs need documentation. For reference, recent documentation done for flush related config : https://github.com/apache/hadoop/blob/trunk/hadoop-tools/hadoop-azure/src/site/markdown/abfs.md#-flush-options", "author": "snvijaya", "createdAt": "2020-01-06T04:01:45Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AbfsConfiguration.java", "diffHunk": "@@ -130,6 +130,10 @@\n       DefaultValue = DEFAULT_FS_AZURE_ATOMIC_RENAME_DIRECTORIES)\n   private String azureAtomicDirs;\n \n+  @StringConfigurationValidatorAnnotation(ConfigurationKey = FS_AZURE_APPEND_BLOB_KEY,\n+      DefaultValue = DEFAULT_FS_AZURE_APPEND_BLOB_DIRECTORIES)\n+  private String azureAppendBlobDirs;", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwOTA2OA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365109068", "bodyText": "what is the procedure for the documentation edit? who are the owners of this documentation edit? do I need to email someone for this?", "author": "ishaniahuja", "createdAt": "2020-01-10T07:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3MTEyMA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365171120", "bodyText": "Dev introducing new config needs to add the documentation for it. You need to edit the abfs.md file mentioned in above comment. Follow format already present in it.", "author": "snvijaya", "createdAt": "2020-01-10T10:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTczNQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363151735", "bodyText": "Why not return a HashSet as all callers are going to need it so.", "author": "snvijaya", "createdAt": "2020-01-06T04:02:24Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AbfsConfiguration.java", "diffHunk": "@@ -411,6 +419,10 @@ public String getAzureAtomicRenameDirs() {\n     return this.azureAtomicDirs;\n   }\n \n+  public String getAppendBlobDirs() {", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwODQ3Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365108476", "bodyText": "this is just the way it is done for other config parameter for dirs. see: getAzureAtomicRenameDirs", "author": "ishaniahuja", "createdAt": "2020-01-10T07:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTk0Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363151946", "bodyText": "Is this version present on all the production clusters already ? If not, this change should go in only after the support is available.", "author": "snvijaya", "createdAt": "2020-01-06T04:04:03Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsClient.java", "diffHunk": "@@ -55,7 +55,7 @@\n   public static final Logger LOG = LoggerFactory.getLogger(AbfsClient.class);\n   private final URL baseUrl;\n   private final SharedKeyCredentials sharedKeyCredentials;\n-  private final String xMsVersion = \"2018-11-09\";\n+  private final String xMsVersion = \"2019-12-12\";", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwODA5Mw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365108093", "bodyText": "nopes actually. how can we go about using the new version with the new API only? is there a way to do this in the driver?", "author": "ishaniahuja", "createdAt": "2020-01-10T07:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NzAwOQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365177009", "bodyText": "Server behaviour is controlled with this API version. So until server is ready, we can not bump up the api version support in driver.\nThis is not recommended to be a config control either, to prevent clients from changing api versions to any older one.\nAll dev work for new features is done with a feature config control that will turn off the feature. When the api version is incremented, the feature config will be turned on too.", "author": "snvijaya", "createdAt": "2020-01-10T10:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MTk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MjEyMA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363152120", "bodyText": "As mentioned in the comments for AbfsConfiguration.java, dont see flush in use inside the method. Also applies to the new isClose argument.", "author": "snvijaya", "createdAt": "2020-01-06T04:05:35Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsOutputStream.java", "diffHunk": "@@ -257,17 +265,16 @@ public synchronized void close() throws IOException {\n \n   private synchronized void flushInternal(boolean isClose) throws IOException {\n     maybeThrowLastError();\n-    writeCurrentBufferToService();\n-    flushWrittenBytesToService(isClose);\n+    writeAndFlushWrittenBytesToService(isClose);\n   }\n \n   private synchronized void flushInternalAsync() throws IOException {\n     maybeThrowLastError();\n-    writeCurrentBufferToService();\n+    writeCurrentBufferToService(true, false);\n     flushWrittenBytesToServiceAsync();\n   }\n \n-  private synchronized void writeCurrentBufferToService() throws IOException {\n+  private synchronized void writeCurrentBufferToService(final boolean flush, final boolean isClose) throws IOException {", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwNDQ5Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365104492", "bodyText": "it does not call flush. but passes flush and close flag in the append method in AbfsClient.", "author": "ishaniahuja", "createdAt": "2020-01-10T07:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MjEyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3Nzg0Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365177842", "bodyText": "Param passing was missing earlier iteration. Can see in new update.", "author": "snvijaya", "createdAt": "2020-01-10T10:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MjEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MzIwNg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363153206", "bodyText": "AbfsOutputStream.close() call flow is:\nclose() -> flushInternal() -> flushWrittenBytesToService() -> flushWrittenBytesToServiceInternal()\nWithin flushWrittenBytesToServiceInternal() is where service \"Flush\" gets called.\nAbove change removes call to flushWrittenBytesToServiceInternal() and replaces it with shrinkWriteOperationQueue().  This is going to prevent flush for AbfsOutputStream.close() calls.\nThis might be ok for AppendBlob, but BlockBlob behaviour needs to be retained where AbfsClient->Flush() will get triggered.", "author": "snvijaya", "createdAt": "2020-01-06T04:13:41Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsOutputStream.java", "diffHunk": "@@ -309,15 +316,23 @@ private synchronized void flushWrittenBytesToService(boolean isClose) throws IOE\n             throw new FileNotFoundException(ex.getMessage());\n           }\n         }\n-\n         if (ex.getCause() instanceof AzureBlobFileSystemException) {\n           ex = (AzureBlobFileSystemException) ex.getCause();\n         }\n         lastError = new IOException(ex);\n         throw lastError;\n       }\n     }\n-    flushWrittenBytesToServiceInternal(position, false, isClose);\n+    shrinkWriteOperationQueue();", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwMzU5MQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365103591", "bodyText": "as discussed offline, please look at new REST API. the code is same for both the appendBlob and BlockBlob. THe difference at the OutputStream Code is to use a single upload thread for appendBlob and multiple upload threads for block Blob. Its a lot of code rewrite, hence the full file read might be more useful.", "author": "ishaniahuja", "createdAt": "2020-01-10T07:35:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1MzIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1NDE1MQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363154151", "bodyText": "This method is supposed to be called from AbfsOutputStream.java -> writeCurrentBufferToService(), but there is no change for call to this API within that method. How did the compilation pass.\nAnd, (probably a repeat question of config query posted above, still) can you please explain why flush and close needs to be added to Append method.", "author": "snvijaya", "createdAt": "2020-01-06T04:21:40Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsClient.java", "diffHunk": "@@ -278,7 +282,8 @@ public AbfsRestOperation renamePath(final String source, final String destinatio\n   }\n \n   public AbfsRestOperation append(final String path, final long position, final byte[] buffer, final int offset,\n-                                  final int length) throws AzureBlobFileSystemException {\n+                                  final int length, boolean flush, boolean isClose)", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NzI4MA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365177280", "bodyText": "New iteration has the caller updated.", "author": "snvijaya", "createdAt": "2020-01-10T10:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE1NDE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIyMzY4Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363223682", "bodyText": "can the lines 171-185 be made a separate method and reuse in the test methods", "author": "bilaharith", "createdAt": "2020-01-06T09:51:18Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import static org.mockito.Mockito.*;\n+/**\n+ * Test useragent of abfs client.\n+ *\n+ */\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+\n+  @Test\n+  public void verifyShortWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+    out.write(b);\n+    out.hsync();\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    final byte[] b1 = new byte[2*writeSize];\n+    new Random().nextBytes(b1);\n+    out.write(b1);\n+    out.flush();\n+    out.hflush();\n+\n+    out.hsync();\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(writeSize)), acLong.getAllValues());\n+    //flush=true, close=false, flush=true, close=false\n+    Assert.assertEquals(Arrays.asList(true, false, true, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0,writeSize, 0, 2*writeSize), acInt.getAllValues());\n+\n+    verifyNoMoreInteractions(client);\n+\n+  }\n+\n+  @Test\n+  public void verifyWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 5; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize)), acLong.getAllValues());\n+    //flush=false,close=false, flush=true,close=true\n+    Assert.assertEquals(Arrays.asList(false, false, true, true), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, 5*writeSize-bufferSize), acInt.getAllValues());\n+\n+    verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSizeAndClose() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acFlushLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Boolean> acFlushBool = ArgumentCaptor.forClass(Boolean.class);\n+\n+    verify(client, times(1)).flush(acFlushString.capture(), acFlushLong.capture(), acFlushBool.capture(), acFlushBool.capture());\n+    Assert.assertEquals(Arrays.asList(path) , acFlushString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(2*bufferSize)), acFlushLong.getAllValues());\n+    Assert.assertEquals(Arrays.asList(false, true), acFlushBool.getAllValues());\n+\n+    verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSize() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSizeWithAppendBlob() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, true, true);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcyMTg1MA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r371721850", "bodyText": "these are just initializations.", "author": "ishaniahuja", "createdAt": "2020-01-28T10:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIyMzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcyMzMzNw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r371723337", "bodyText": "these are just inits.", "author": "ishaniahuja", "createdAt": "2020-01-28T10:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIyMzY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIyNTE1Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r363225156", "bodyText": "Shall we have these operations as a separate private method and call that from this constructor. This constructor is becoming lengthy.", "author": "bilaharith", "createdAt": "2020-01-06T09:55:05Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java", "diffHunk": "@@ -164,6 +169,23 @@ public AzureBlobFileSystemStore(URI uri, boolean isSecureScheme, Configuration c\n     boolean useHttps = (usingOauth || abfsConfiguration.isHttpsAlwaysUsed()) ? true : isSecureScheme;\n     initializeClient(uri, fileSystemName, accountName, useHttps);\n     this.identityTransformer = new IdentityTransformer(abfsConfiguration.getRawConfiguration());\n+\n+    // Extract the directories that should contain page blobs", "originalCommit": "11e0aac44fc8e8a9dd2745836e127e90cb08326f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTcyMDk1NA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r371720954", "bodyText": "I don't think that should be done as a part of this PR.", "author": "ishaniahuja", "createdAt": "2020-01-28T10:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzIyNTE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NDY1Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365174656", "bodyText": "Is support for AppendBlob over queryparam \"blobtype\" also enabled with new Dec-2019 version ? If yes, add a config control for AppendBlob as well and have the config off, which can be turned on when the API version is upgraded in driver.", "author": "snvijaya", "createdAt": "2020-01-10T10:44:03Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java", "diffHunk": "@@ -344,40 +366,53 @@ public void deleteFilesystem() throws AzureBlobFileSystemException {\n \n   public OutputStream createFile(final Path path, final boolean overwrite, final FsPermission permission,\n                                  final FsPermission umask) throws AzureBlobFileSystemException {\n-    boolean isNamespaceEnabled = getIsNamespaceEnabled();\n-    LOG.debug(\"createFile filesystem: {} path: {} overwrite: {} permission: {} umask: {} isNamespaceEnabled: {}\",\n-            client.getFileSystem(),\n-            path,\n-            overwrite,\n-            permission.toString(),\n-            umask.toString(),\n-            isNamespaceEnabled);\n-\n-    client.createPath(AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path), true, overwrite,\n-        isNamespaceEnabled ? getOctalNotation(permission) : null,\n-        isNamespaceEnabled ? getOctalNotation(umask) : null);\n+    try (AbfsPerfInfo perfInfo = startTracking(\"createFile\", \"createPath\")) {\n+      boolean isNamespaceEnabled = getIsNamespaceEnabled();\n+      LOG.debug(\"createFile filesystem: {} path: {} overwrite: {} permission: {} umask: {} isNamespaceEnabled: {}\",\n+              client.getFileSystem(),\n+              path,\n+              overwrite,\n+              permission.toString(),\n+              umask.toString(),\n+              isNamespaceEnabled);\n+\n+        boolean appendBlob = false;\n+        if (isAppendBlobKey(path.toString())) {\n+          appendBlob = true;\n+        }\n \n-    return new AbfsOutputStream(\n-        client,\n-        AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path),\n-        0,\n-        abfsConfiguration.getWriteBufferSize(),\n-        abfsConfiguration.isFlushEnabled());\n+      client.createPath(AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path), true, overwrite,", "originalCommit": "0c74b1ec54bbbea58fdf75f015d491d4bff221fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MDI2OA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r379260268", "bodyText": "its added.", "author": "ishaniahuja", "createdAt": "2020-02-14T05:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3NDY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTQ0NQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365179445", "bodyText": "Many changes from trunk merge is showing up as new updates even though not added as part of this PR.", "author": "snvijaya", "createdAt": "2020-01-10T10:56:04Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AbfsConfiguration.java", "diffHunk": "@@ -427,6 +443,14 @@ public boolean isFlushEnabled() {\n     return this.enableFlush;\n   }\n \n+  public boolean isAppendWithFlushEnabled() {\n+    return this.enableAppendWithFlush;\n+  }\n+\n+  public boolean isOutputStreamFlushDisabled() {", "originalCommit": "0c74b1ec54bbbea58fdf75f015d491d4bff221fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5NjQ3NQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r365196475", "bodyText": "In the trunk, client calls have AbfsPerfTracker tracking all the calls. Not sure why the PR view is failing to show it as a delta from trunk. But looks like there is some issue here with merge from trunk. Please do a file to file compare from PR branch to trunk.\nexample: from trunk:\n      public Void call() throws Exception { AbfsPerfTracker tracker = client.getAbfsPerfTracker(); try (AbfsPerfInfo perfInfo = new AbfsPerfInfo(tracker, \"writeCurrentBufferToService\", \"append\")) { AbfsRestOperation op = client.append(path, offset, bytes, 0, bytesLength); perfInfo.registerResult(op.getResult()); byteBufferPool.putBuffer(ByteBuffer.wrap(bytes)); perfInfo.registerSuccess(true); return null; }\n(this is not the only delta)", "author": "snvijaya", "createdAt": "2020-01-10T11:42:49Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsOutputStream.java", "diffHunk": "@@ -287,13 +297,13 @@ private synchronized void writeCurrentBufferToService() throws IOException {\n       @Override\n       public Void call() throws Exception {\n         client.append(path, offset, bytes, 0,", "originalCommit": "0c74b1ec54bbbea58fdf75f015d491d4bff221fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NjgzMQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r370476831", "bodyText": "remove the *, import the actual class", "author": "DadanielZ", "createdAt": "2020-01-24T05:16:55Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import static org.mockito.Mockito.*;", "originalCommit": "0c74b1ec54bbbea58fdf75f015d491d4bff221fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NTc3Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r386485772", "bodyText": "ideally, yes, though we are a bit more relaxed about static imports...", "author": "steveloughran", "createdAt": "2020-03-02T16:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3NjgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3ODI2MA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r370478260", "bodyText": "Looks like there are some issue in this PR, this try logic is already in:\n\n  \n    \n      hadoop/hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java\n    \n    \n         Line 423\n      in\n      978c487\n    \n    \n    \n    \n\n        \n          \n           try (AbfsPerfInfo perfInfo = startTracking(\"createDirectory\", \"createPath\")) {", "author": "DadanielZ", "createdAt": "2020-01-24T05:26:02Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java", "diffHunk": "@@ -344,40 +366,53 @@ public void deleteFilesystem() throws AzureBlobFileSystemException {\n \n   public OutputStream createFile(final Path path, final boolean overwrite, final FsPermission permission,\n                                  final FsPermission umask) throws AzureBlobFileSystemException {\n-    boolean isNamespaceEnabled = getIsNamespaceEnabled();\n-    LOG.debug(\"createFile filesystem: {} path: {} overwrite: {} permission: {} umask: {} isNamespaceEnabled: {}\",\n-            client.getFileSystem(),\n-            path,\n-            overwrite,\n-            permission.toString(),\n-            umask.toString(),\n-            isNamespaceEnabled);\n-\n-    client.createPath(AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path), true, overwrite,\n-        isNamespaceEnabled ? getOctalNotation(permission) : null,\n-        isNamespaceEnabled ? getOctalNotation(umask) : null);\n+    try (AbfsPerfInfo perfInfo = startTracking(\"createFile\", \"createPath\")) {\n+      boolean isNamespaceEnabled = getIsNamespaceEnabled();\n+      LOG.debug(\"createFile filesystem: {} path: {} overwrite: {} permission: {} umask: {} isNamespaceEnabled: {}\",\n+              client.getFileSystem(),\n+              path,\n+              overwrite,\n+              permission.toString(),\n+              umask.toString(),\n+              isNamespaceEnabled);\n+\n+        boolean appendBlob = false;\n+        if (isAppendBlobKey(path.toString())) {\n+          appendBlob = true;\n+        }\n \n-    return new AbfsOutputStream(\n-        client,\n-        AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path),\n-        0,\n-        abfsConfiguration.getWriteBufferSize(),\n-        abfsConfiguration.isFlushEnabled());\n+      client.createPath(AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path), true, overwrite,\n+          isNamespaceEnabled ? getOctalNotation(permission) : null,\n+          isNamespaceEnabled ? getOctalNotation(umask) : null,\n+          appendBlob);\n+\n+      return new AbfsOutputStream(\n+          client,\n+          AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path),\n+          0,\n+          abfsConfiguration.getWriteBufferSize(),\n+          abfsConfiguration.isFlushEnabled(),\n+          abfsConfiguration.isAppendWithFlushEnabled(),\n+          appendBlob);\n+    }\n   }\n \n   public void createDirectory(final Path path, final FsPermission permission, final FsPermission umask)\n       throws AzureBlobFileSystemException {\n-    boolean isNamespaceEnabled = getIsNamespaceEnabled();\n-    LOG.debug(\"createDirectory filesystem: {} path: {} permission: {} umask: {} isNamespaceEnabled: {}\",\n-            client.getFileSystem(),\n-            path,\n-            permission,\n-            umask,\n-            isNamespaceEnabled);\n-\n-    client.createPath(AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path), false, true,\n-        isNamespaceEnabled ? getOctalNotation(permission) : null,\n-        isNamespaceEnabled ? getOctalNotation(umask) : null);\n+    try (AbfsPerfInfo perfInfo = startTracking(\"createDirectory\", \"createPath\")) {", "originalCommit": "0c74b1ec54bbbea58fdf75f015d491d4bff221fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3ODY3Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r370478672", "bodyText": "could you elaborate here a little bit more why for appendblob the max concurrent requests is 1?", "author": "DadanielZ", "createdAt": "2020-01-24T05:28:30Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsOutputStream.java", "diffHunk": "@@ -80,20 +82,29 @@ public AbfsOutputStream(\n       final String path,\n       final long position,\n       final int bufferSize,\n-      final boolean supportFlush) {\n+      final boolean supportFlush,\n+      final boolean disableOutputStreamFlush,\n+      final boolean supportAppendWithFlush,\n+      final boolean appendBlob) {\n     this.client = client;\n     this.path = path;\n     this.position = position;\n     this.closed = false;\n+    this.disableOutputStreamFlush = disableOutputStreamFlush;\n     this.supportFlush = supportFlush;\n+    this.supportAppendWithFlush = supportAppendWithFlush;\n     this.lastError = null;\n     this.lastFlushOffset = 0;\n     this.bufferSize = bufferSize;\n     this.buffer = byteBufferPool.getBuffer(false, bufferSize).array();\n     this.bufferIndex = 0;\n     this.writeOperations = new ConcurrentLinkedDeque<>();\n \n-    this.maxConcurrentRequestCount = 4 * Runtime.getRuntime().availableProcessors();\n+    if (appendBlob) {\n+      this.maxConcurrentRequestCount = 1;", "originalCommit": "0c74b1ec54bbbea58fdf75f015d491d4bff221fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTA4MDk5OA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r371080998", "bodyText": "AppendBlob for an HDFS file write should not allow parallel upload because that would lead to random writes in the file.", "author": "ishaniahuja", "createdAt": "2020-01-27T06:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ3ODY3Mg=="}], "type": "inlineReview"}, {"oid": "6cc320349434176cfbf0653a4e04d5ebb7238f2a", "url": "https://github.com/apache/hadoop/commit/6cc320349434176cfbf0653a4e04d5ebb7238f2a", "message": "resolving conflicts\n+ some changes were not checked in with the previous commit and are checked in here.", "committedDate": "2020-01-27T09:25:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4OTQ2MQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r378389461", "bodyText": "Are the trunk merge issues resolved ? This is an existing code in trunk but shown as new change here.", "author": "snvijaya", "createdAt": "2020-02-12T17:07:05Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AbfsConfiguration.java", "diffHunk": "@@ -158,6 +162,14 @@\n       DefaultValue = DEFAULT_DISABLE_OUTPUTSTREAM_FLUSH)\n   private boolean disableOutputStreamFlush;\n \n+  @BooleanConfigurationValidatorAnnotation(ConfigurationKey = FS_AZURE_ENABLE_APPEND_WITH_FLUSH,\n+      DefaultValue = DEFAULT_ENABLE_APPEND_WITH_FLUSH)\n+  private boolean enableAppendWithFlush;\n+\n+  @BooleanConfigurationValidatorAnnotation(ConfigurationKey = FS_AZURE_DISABLE_OUTPUTSTREAM_FLUSH,", "originalCommit": "8590f79e9ed00f055b2fd822c6c964943dddbb91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc2NzI0OQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r378767249", "bodyText": "there was a conflict for which I had to add this.", "author": "ishaniahuja", "createdAt": "2020-02-13T10:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM4OTQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5NDM0Nw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r378394347", "bodyText": "Test the change against an account in prod tenant which still doesnt have Dec-12 bits .", "author": "snvijaya", "createdAt": "2020-02-12T17:15:41Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsClient.java", "diffHunk": "@@ -254,6 +273,9 @@ public AbfsRestOperation createPath(final String path, final boolean isFile, fin\n \n     final AbfsUriQueryBuilder abfsUriQueryBuilder = createDefaultUriQueryBuilder();\n     abfsUriQueryBuilder.addQuery(QUERY_PARAM_RESOURCE, isFile ? FILE : DIRECTORY);\n+    if (appendBlob) {", "originalCommit": "8590f79e9ed00f055b2fd822c6c964943dddbb91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MDM4Nw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r379260387", "bodyText": "tested the changes in a test tenant, with rest version older than Dec 12.", "author": "ishaniahuja", "createdAt": "2020-02-14T05:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5NDM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwMDQ0Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r378400446", "bodyText": "Could you explain the logic here. Please add to code comments.", "author": "snvijaya", "createdAt": "2020-02-12T17:26:17Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsOutputStream.java", "diffHunk": "@@ -307,10 +318,18 @@ public Void call() throws Exception {\n           perfInfo.registerSuccess(true);\n           return null;\n         }\n+        if (flush) {\n+          while(lastTotalAppendOffset <  lastFlushOffset);", "originalCommit": "8590f79e9ed00f055b2fd822c6c964943dddbb91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MDYwMw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r379260603", "bodyText": "I have added comment in the code. This code ensures that the append+flush (new API is called only once all the append and flush have finished and there are no pending appends in the driver.", "author": "ishaniahuja", "createdAt": "2020-02-14T05:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwMDQ0Ng=="}], "type": "inlineReview"}, {"oid": "f3db6b4f0f18cc16ea5cf2544ac42cc598e88b11", "url": "https://github.com/apache/hadoop/commit/f3db6b4f0f18cc16ea5cf2544ac42cc598e88b11", "message": "changes for combined append+flush calls for blockblob(traditionan) and support for appendblob", "committedDate": "2020-03-02T09:15:22Z", "type": "commit"}, {"oid": "3a5a0f7e49aa84c1270062504ce1d62a578455b4", "url": "https://github.com/apache/hadoop/commit/3a5a0f7e49aa84c1270062504ce1d62a578455b4", "message": "resolving conflicts\n+ some changes were not checked in with the previous commit and are checked in here.", "committedDate": "2020-03-02T09:15:22Z", "type": "commit"}, {"oid": "ebfb85f73019032e18a3e1b64c24e75e8fd99f56", "url": "https://github.com/apache/hadoop/commit/ebfb85f73019032e18a3e1b64c24e75e8fd99f56", "message": "added feedbacks", "committedDate": "2020-03-02T09:15:22Z", "type": "commit"}, {"oid": "27dd4a5188955da05357b5e3ed0d7c59a0b76360", "url": "https://github.com/apache/hadoop/commit/27dd4a5188955da05357b5e3ed0d7c59a0b76360", "message": "adding fixes", "committedDate": "2020-03-02T09:15:23Z", "type": "commit"}, {"oid": "6b2fc80189e38c46b51bccb22346834a18af044b", "url": "https://github.com/apache/hadoop/commit/6b2fc80189e38c46b51bccb22346834a18af044b", "message": "made rest version based on config parameter", "committedDate": "2020-03-02T09:24:16Z", "type": "commit"}, {"oid": "a23da93e97ab12df37073445d3692c4e2bd5b623", "url": "https://github.com/apache/hadoop/commit/a23da93e97ab12df37073445d3692c4e2bd5b623", "message": "incorporated feedbacks/comments", "committedDate": "2020-03-02T09:24:17Z", "type": "commit"}, {"oid": "3226c04b2e6354b3767558ad14d2d6394f1322ae", "url": "https://github.com/apache/hadoop/commit/3226c04b2e6354b3767558ad14d2d6394f1322ae", "message": "added appropriate comments", "committedDate": "2020-03-02T09:24:17Z", "type": "commit"}, {"oid": "c233aaee40c4165d9bf7cb888a2899cd71532f98", "url": "https://github.com/apache/hadoop/commit/c233aaee40c4165d9bf7cb888a2899cd71532f98", "message": "compilation error fixes", "committedDate": "2020-03-02T09:25:00Z", "type": "commit"}, {"oid": "c87e041e9f24d39381fadcc9690fc80f1a71da1f", "url": "https://github.com/apache/hadoop/commit/c87e041e9f24d39381fadcc9690fc80f1a71da1f", "message": "fixed UTs", "committedDate": "2020-03-02T09:25:01Z", "type": "commit"}, {"oid": "673369fa7198fa218460f1eec97d01e7f504043e", "url": "https://github.com/apache/hadoop/commit/673369fa7198fa218460f1eec97d01e7f504043e", "message": "fixing mockito errors", "committedDate": "2020-03-02T09:25:01Z", "type": "commit"}, {"oid": "cc053f4303b2092270c4ac0a267d737e24d0a0f0", "url": "https://github.com/apache/hadoop/commit/cc053f4303b2092270c4ac0a267d737e24d0a0f0", "message": "adding right version of mockito", "committedDate": "2020-03-02T09:25:01Z", "type": "commit"}, {"oid": "e88e6ba098bede125637694dc8a0aa8b8a0c2e49", "url": "https://github.com/apache/hadoop/commit/e88e6ba098bede125637694dc8a0aa8b8a0c2e49", "message": "fixed errors", "committedDate": "2020-03-02T09:25:01Z", "type": "commit"}, {"oid": "c03425291599dae085f5368d69d31fb659f68f5a", "url": "https://github.com/apache/hadoop/commit/c03425291599dae085f5368d69d31fb659f68f5a", "message": "fixes in AbfsClient.java", "committedDate": "2020-03-02T09:25:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4MTU4NQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r386481585", "bodyText": "javadocs should be above the new option", "author": "steveloughran", "createdAt": "2020-03-02T15:57:51Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/constants/ConfigurationKeys.java", "diffHunk": "@@ -60,6 +61,12 @@\n    *  documentation does not have such expectations of data being persisted.\n    *  Default value of this config is true. **/\n   public static final String FS_AZURE_DISABLE_OUTPUTSTREAM_FLUSH = \"fs.azure.disable.outputstream.flush\";\n+  public static final String FS_AZURE_ENABLE_APPEND_WITH_FLUSH = \"fs.azure.enable.appendwithflush\";\n+  /** Provides a config control to disable or enable OutputStream Flush API", "originalCommit": "0840c8aa5b2371a79705e8183fe4381aba0d0e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NTM1Mw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r386485353", "bodyText": "org.apache imports need to go into their own block just above any static imports, ordering imports\njava., javax.\n--\nother\n---\norg.apache\n---\nstatic\n\nThis is to try and keep cherry-picking under control.", "author": "steveloughran", "createdAt": "2020-03-02T16:03:27Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;", "originalCommit": "0840c8aa5b2371a79705e8183fe4381aba0d0e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NjY4OQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r386486689", "bodyText": "are these used", "author": "steveloughran", "createdAt": "2020-03-02T16:05:32Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+/**\n+ * Test useragent of abfs client.\n+ *\n+ */\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+  private final String globalKey = \"fs.azure.configuration\";\n+  private final String accountName1 = \"account1\";\n+  private final String accountKey1 = globalKey + \".\" + accountName1;\n+  private final String accountValue1 = \"one\";\n+\n+  @Test\n+  public void verifyShortWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+    out.write(b);\n+    out.hsync();\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    final byte[] b1 = new byte[2*writeSize];\n+    new Random().nextBytes(b1);\n+    out.write(b1);\n+    out.flush();\n+    out.hflush();\n+\n+    out.hsync();\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(writeSize)), acLong.getAllValues());\n+    //flush=true, close=false, flush=true, close=false\n+    Assert.assertEquals(Arrays.asList(true, false, true, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0,writeSize, 0, 2*writeSize), acInt.getAllValues());\n+\n+    //verifyNoMoreInteractions(client);\n+\n+  }\n+\n+  @Test\n+  public void verifyWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 5; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize)), acLong.getAllValues());\n+    //flush=false,close=false, flush=true,close=true\n+    Assert.assertEquals(Arrays.asList(false, false, true, true), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, 5*writeSize-bufferSize), acInt.getAllValues());\n+\n+    //verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSizeAndClose() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+    when(client.flush(anyString(), anyLong(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acFlushLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Boolean> acFlushBool = ArgumentCaptor.forClass(Boolean.class);\n+\n+    verify(client, times(1)).flush(acFlushString.capture(), acFlushLong.capture(), acFlushBool.capture(), acFlushBool.capture());\n+    Assert.assertEquals(Arrays.asList(path) , acFlushString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(2*bufferSize)), acFlushLong.getAllValues());\n+    Assert.assertEquals(Arrays.asList(false, true), acFlushBool.getAllValues());\n+\n+//    verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSize() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+ //   verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSizeWithAppendBlob() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize)), acLong.getAllValues());\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    //verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSizeAndHFlush() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+    when(client.flush(anyString(), anyLong(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.hflush();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acFlushLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Boolean> acFlushBool = ArgumentCaptor.forClass(Boolean.class);\n+\n+    verify(client, times(1)).flush(acFlushString.capture(), acFlushLong.capture(), acFlushBool.capture(), acFlushBool.capture());\n+    Assert.assertEquals(Arrays.asList(path) , acFlushString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(2*bufferSize)), acFlushLong.getAllValues());\n+    Assert.assertEquals(Arrays.asList(false, false), acFlushBool.getAllValues());\n+\n+    //verifyNoMoreInteractions(client);\n+  }\n+\n+  @Test\n+  public void verifyWriteRequestOfBufferSizeAndFlush() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.flush();\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);", "originalCommit": "0840c8aa5b2371a79705e8183fe4381aba0d0e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4ODA1OA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r386488058", "bodyText": "Mockito tests are always a maintenance pain because they are so brittle and sho hard to understand what is going on -for example, here I couldn't really understand any of the tests. Could you add some more detail as a comment for each test -at least to level of what each test case is looking for.", "author": "steveloughran", "createdAt": "2020-03-02T16:07:38Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+/**\n+ * Test useragent of abfs client.\n+ *\n+ */\n+public final class TestAbfsOutputStream {", "originalCommit": "0840c8aa5b2371a79705e8183fe4381aba0d0e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4ODE0OQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r386488149", "bodyText": "check this", "author": "steveloughran", "createdAt": "2020-03-02T16:07:47Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+/**\n+ * Test useragent of abfs client.", "originalCommit": "0840c8aa5b2371a79705e8183fe4381aba0d0e52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "371e5549e30913d25c3d86be64eb074744cddbd8", "url": "https://github.com/apache/hadoop/commit/371e5549e30913d25c3d86be64eb074744cddbd8", "message": "modification to test due to the new call changes in the driver", "committedDate": "2020-03-04T08:39:07Z", "type": "commit"}, {"oid": "371e5549e30913d25c3d86be64eb074744cddbd8", "url": "https://github.com/apache/hadoop/commit/371e5549e30913d25c3d86be64eb074744cddbd8", "message": "modification to test due to the new call changes in the driver", "committedDate": "2020-03-04T08:39:07Z", "type": "forcePushed"}, {"oid": "e5cb3a8214edd5b2326ffd0b48403c01f90e8e94", "url": "https://github.com/apache/hadoop/commit/e5cb3a8214edd5b2326ffd0b48403c01f90e8e94", "message": "whitespace fix", "committedDate": "2020-03-04T12:24:13Z", "type": "commit"}, {"oid": "520f504efa052e72645c36c9f1fde76574dc2bf7", "url": "https://github.com/apache/hadoop/commit/520f504efa052e72645c36c9f1fde76574dc2bf7", "message": "whitespace fix", "committedDate": "2020-03-04T14:25:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyNjU3NA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r387726574", "bodyText": "nit: why not just 0?", "author": "steveloughran", "createdAt": "2020-03-04T15:07:26Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/AzureBlobFileSystemStore.java", "diffHunk": "@@ -404,18 +425,25 @@ public OutputStream createFile(final Path path, final boolean overwrite, final F\n               umask.toString(),\n               isNamespaceEnabled);\n \n-      final AbfsRestOperation op = client.createPath(AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path), true, overwrite,\n-              isNamespaceEnabled ? getOctalNotation(permission) : null,\n-              isNamespaceEnabled ? getOctalNotation(umask) : null);\n-      perfInfo.registerResult(op.getResult()).registerSuccess(true);\n+        boolean appendBlob = false;\n+        if (isAppendBlobKey(path.toString())) {\n+          appendBlob = true;\n+        }\n+\n+      client.createPath(AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path), true, overwrite,\n+          isNamespaceEnabled ? getOctalNotation(permission) : null,\n+          isNamespaceEnabled ? getOctalNotation(umask) : null,\n+          appendBlob);\n \n       return new AbfsOutputStream(\n-              client,\n-              AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path),\n-              0,\n-              abfsConfiguration.getWriteBufferSize(),\n-              abfsConfiguration.isFlushEnabled(),\n-              abfsConfiguration.isOutputStreamFlushDisabled());\n+          client,\n+          AbfsHttpConstants.FORWARD_SLASH + getRelativePath(path),\n+          Long.valueOf(0),", "originalCommit": "520f504efa052e72645c36c9f1fde76574dc2bf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4NTc5Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r388085796", "bodyText": "Could you please point me to the check in close() call that prevents server call ?\nAlso have the tests been run on these different configurations:\n\nWith appenblob feature enabled\n\n\nWith and Without Namespace enabled account : fs.azure.enable.appendwithflush true and false\n\n\nWith appenblob feature disabled\n\n\nWith and Without Namespace enabled account : fs.azure.enable.appendwithflush true and false", "author": "snvijaya", "createdAt": "2020-03-05T05:33:00Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/ITestAzureBlobFileSystemE2E.java", "diffHunk": "@@ -209,9 +209,10 @@ public void testFlushWithFileNotFoundException() throws Exception {\n \n     fs.delete(testFilePath, true);\n     assertFalse(fs.exists(testFilePath));\n+    AbfsConfiguration configuration = this.getConfiguration();\n \n-    intercept(FileNotFoundException.class,\n-            () -> stream.close());\n+    //With the new code, it would not trigger a call to the backend", "originalCommit": "520f504efa052e72645c36c9f1fde76574dc2bf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUyNzE3Nw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r389527177", "bodyText": "I updated the comment with more details. You can also look at the code to understand the behavior. AbfsOutputStream close(). Yes I have tested the different configurations (appendblob, blockblob, append+flush enabled, append+flush disabled, with and without namespace disabled account.", "author": "ishaniahuja", "createdAt": "2020-03-09T08:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4NTc5Ng=="}], "type": "inlineReview"}, {"oid": "bebc0be1f55e354fe113674c838d79cd40826c81", "url": "https://github.com/apache/hadoop/commit/bebc0be1f55e354fe113674c838d79cd40826c81", "message": "fixes for appendblob changes, + added comment to change in the test cases. tested with both namespace enabled and disabled accounts", "committedDate": "2020-03-09T06:46:59Z", "type": "commit"}, {"oid": "a5d7e0a49937cc8b0cc33560c87de89d137499f9", "url": "https://github.com/apache/hadoop/commit/a5d7e0a49937cc8b0cc33560c87de89d137499f9", "message": "incorporated feedbacks/comments", "committedDate": "2020-03-09T09:39:18Z", "type": "commit"}, {"oid": "41bb42fc64078462050fbda881deb7a6a74013eb", "url": "https://github.com/apache/hadoop/commit/41bb42fc64078462050fbda881deb7a6a74013eb", "message": "incoroporated feedbacks in the TestAbfsOutputStream", "committedDate": "2020-03-11T06:14:04Z", "type": "commit"}, {"oid": "be48931febe59c03becc9c8b8505bb41a65d5a68", "url": "https://github.com/apache/hadoop/commit/be48931febe59c03becc9c8b8505bb41a65d5a68", "message": "removed mockito version from the pom file", "committedDate": "2020-03-11T06:15:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDY5Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392654692", "bodyText": "This comment looks misplaced", "author": "bilaharith", "createdAt": "2020-03-15T09:06:36Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/constants/ConfigurationKeys.java", "diffHunk": "@@ -60,6 +61,15 @@\n    *  documentation does not have such expectations of data being persisted.\n    *  Default value of this config is true. **/\n   public static final String FS_AZURE_DISABLE_OUTPUTSTREAM_FLUSH = \"fs.azure.disable.outputstream.flush\";\n+  /** Provides a config control to enable OutputStream AppendWithFlush API\n+   *  operations in AbfsOutputStream.\n+   *  Default value of this config is true. **/\n+  public static final String FS_AZURE_ENABLE_APPEND_WITH_FLUSH = \"fs.azure.enable.appendwithflush\";\n+  /** Provides a config control to disable or enable OutputStream Flush API", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ3NjQ4OA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r393476488", "bodyText": "@snvijaya Doesn't this look misplaced?\n@ishaniahuja Check with @snvijaya and then resolve this one", "author": "bilaharith", "createdAt": "2020-03-17T06:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDkwMg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392654902", "bodyText": "Shouldn't boolean be named with the prefix \"is\"", "author": "bilaharith", "createdAt": "2020-03-15T09:10:16Z", "path": "hadoop-tools/hadoop-azure/src/main/java/org/apache/hadoop/fs/azurebfs/services/AbfsOutputStream.java", "diffHunk": "@@ -55,6 +55,8 @@\n   private boolean closed;\n   private boolean supportFlush;\n   private boolean disableOutputStreamFlush;\n+  private boolean supportAppendWithFlush;\n+  private boolean appendBlob;", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQyMzQ3MA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r393423470", "bodyText": "it is the same as for other booleans in the file.", "author": "ishaniahuja", "createdAt": "2020-03-17T03:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NTE5NQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392655195", "bodyText": "Have the comment above the @test annotation", "author": "bilaharith", "createdAt": "2020-03-15T09:14:05Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+  private final String globalKey = \"fs.azure.configuration\";\n+  private final String accountName1 = \"account1\";\n+  private final String accountKey1 = globalKey + \".\" + accountName1;\n+  private final String accountValue1 = \"one\";\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream shortwrite case(2000bytes write followed by flush, hflush, hsync) is making correct HTTP calls to the server\n+   */\n+  public void verifyShortWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+    out.write(b);\n+    out.hsync();\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    final byte[] b1 = new byte[2*writeSize];\n+    new Random().nextBytes(b1);\n+    out.write(b1);\n+    out.flush();\n+    out.hflush();\n+\n+    out.hsync();\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(writeSize)), acLong.getAllValues());\n+    //flush=true, close=false, flush=true, close=false\n+    Assert.assertEquals(Arrays.asList(true, false, true, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0,writeSize, 0, 2*writeSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of writeSize(1000 bytes) followed by a close is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 5; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize)), acLong.getAllValues());\n+    //flush=false,close=false, flush=true,close=true\n+    Assert.assertEquals(Arrays.asList(false, false, true, true), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, 5*writeSize-bufferSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB) followed by a close is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSizeAndClose() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+    when(client.flush(anyString(), anyLong(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acFlushLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Boolean> acFlushBool = ArgumentCaptor.forClass(Boolean.class);\n+\n+    verify(client, times(1)).flush(acFlushString.capture(), acFlushLong.capture(), acFlushBool.capture(), acFlushBool.capture());\n+    Assert.assertEquals(Arrays.asList(path) , acFlushString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(2*bufferSize)), acFlushLong.getAllValues());\n+    Assert.assertEquals(Arrays.asList(false, true), acFlushBool.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB) is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSize() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB) on a AppendBlob based stream is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSizeWithAppendBlob() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize)), acLong.getAllValues());\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB)  followed by a hflush call is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSizeAndHFlush() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+    when(client.flush(anyString(), anyLong(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.hflush();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acFlushLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Boolean> acFlushBool = ArgumentCaptor.forClass(Boolean.class);\n+\n+    verify(client, times(1)).flush(acFlushString.capture(), acFlushLong.capture(), acFlushBool.capture(), acFlushBool.capture());\n+    Assert.assertEquals(Arrays.asList(path) , acFlushString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(2*bufferSize)), acFlushLong.getAllValues());\n+    Assert.assertEquals(Arrays.asList(false, false), acFlushBool.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NTg1Mg==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392655852", "bodyText": "Pls add new line before the first import", "author": "bilaharith", "createdAt": "2020-03-15T09:23:20Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NTk5Mw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392655993", "bodyText": "Order and group the non-static imports in the order:\njava*\nany non org.apache imports\norg.apache imports", "author": "bilaharith", "createdAt": "2020-03-15T09:25:32Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ5OTc5Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r393499796", "bodyText": "Import order is still not fixed", "author": "bilaharith", "createdAt": "2020-03-17T08:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NTk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NjAxMQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392656011", "bodyText": "Same for static imports", "author": "bilaharith", "createdAt": "2020-03-15T09:25:49Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NjA0NA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392656044", "bodyText": "Keep the comment above the @test annotation for all the tests", "author": "bilaharith", "createdAt": "2020-03-15T09:26:11Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+  private final String globalKey = \"fs.azure.configuration\";\n+  private final String accountName1 = \"account1\";\n+  private final String accountKey1 = globalKey + \".\" + accountName1;\n+  private final String accountValue1 = \"one\";\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream shortwrite case(2000bytes write followed by flush, hflush, hsync) is making correct HTTP calls to the server", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwMDQ4OQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r393500489", "bodyText": "Need to move @test below the comments", "author": "bilaharith", "createdAt": "2020-03-17T08:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NjA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjA5Mw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392936093", "bodyText": "Nit: Remove unused import", "author": "bilaharith", "createdAt": "2020-03-16T10:57:01Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNjQzNA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392936434", "bodyText": "Nit: Using the '.*' form of import should be avoided", "author": "bilaharith", "createdAt": "2020-03-16T10:57:41Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNzQ2Nw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392937467", "bodyText": "Nit: These 2 can also be made constants", "author": "bilaharith", "createdAt": "2020-03-16T10:59:33Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzNzg3NA==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392937874", "bodyText": "Nit: Line is longer than 160 characters\nTake care of the same in the entire file", "author": "bilaharith", "createdAt": "2020-03-16T11:00:19Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+  private final String globalKey = \"fs.azure.configuration\";\n+  private final String accountName1 = \"account1\";\n+  private final String accountKey1 = globalKey + \".\" + accountName1;\n+  private final String accountValue1 = \"one\";\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream shortwrite case(2000bytes write followed by flush, hflush, hsync) is making correct HTTP calls to the server\n+   */\n+  public void verifyShortWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+    out.write(b);\n+    out.hsync();\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    final byte[] b1 = new byte[2*writeSize];\n+    new Random().nextBytes(b1);\n+    out.write(b1);\n+    out.flush();\n+    out.hflush();\n+\n+    out.hsync();\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzODUxNQ==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392938515", "bodyText": "Nit: ',' is preceded with whitespace\nTake care of the same in the entire file", "author": "bilaharith", "createdAt": "2020-03-16T11:01:30Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+  private final String globalKey = \"fs.azure.configuration\";\n+  private final String accountName1 = \"account1\";\n+  private final String accountKey1 = globalKey + \".\" + accountName1;\n+  private final String accountValue1 = \"one\";\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream shortwrite case(2000bytes write followed by flush, hflush, hsync) is making correct HTTP calls to the server\n+   */\n+  public void verifyShortWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+    out.write(b);\n+    out.hsync();\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    final byte[] b1 = new byte[2*writeSize];\n+    new Random().nextBytes(b1);\n+    out.write(b1);\n+    out.flush();\n+    out.hflush();\n+\n+    out.hsync();\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkzODk5Ng==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r392938996", "bodyText": "Nit: ',' is not followed by whitespace. space before and after *\nTake care of the same in the entire file", "author": "bilaharith", "createdAt": "2020-03-16T11:02:18Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+  private final String globalKey = \"fs.azure.configuration\";\n+  private final String accountName1 = \"account1\";\n+  private final String accountKey1 = globalKey + \".\" + accountName1;\n+  private final String accountValue1 = \"one\";\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream shortwrite case(2000bytes write followed by flush, hflush, hsync) is making correct HTTP calls to the server\n+   */\n+  public void verifyShortWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+    out.write(b);\n+    out.hsync();\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    final byte[] b1 = new byte[2*writeSize];\n+    new Random().nextBytes(b1);\n+    out.write(b1);\n+    out.flush();\n+    out.hflush();\n+\n+    out.hsync();\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(writeSize)), acLong.getAllValues());\n+    //flush=true, close=false, flush=true, close=false\n+    Assert.assertEquals(Arrays.asList(true, false, true, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0,writeSize, 0, 2*writeSize), acInt.getAllValues());", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwMjY1Nw==", "url": "https://github.com/apache/hadoop/pull/1790#discussion_r393302657", "bodyText": "Can you look at moving to assertJ here; these declarations are complex enough they need one\nand add error strings via .describedAs()", "author": "steveloughran", "createdAt": "2020-03-16T20:50:37Z", "path": "hadoop-tools/hadoop-azure/src/test/java/org/apache/hadoop/fs/azurebfs/services/TestAbfsOutputStream.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.azurebfs.services;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Random;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.apache.hadoop.fs.azurebfs.AbfsConfiguration;\n+import org.apache.hadoop.conf.Configuration;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.*;\n+\n+public final class TestAbfsOutputStream {\n+\n+  private static int bufferSize = 4096;\n+  private static int writeSize = 1000;\n+  private static String path = \"~/testpath\";\n+  private final String globalKey = \"fs.azure.configuration\";\n+  private final String accountName1 = \"account1\";\n+  private final String accountKey1 = globalKey + \".\" + accountName1;\n+  private final String accountValue1 = \"one\";\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream shortwrite case(2000bytes write followed by flush, hflush, hsync) is making correct HTTP calls to the server\n+   */\n+  public void verifyShortWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+    out.write(b);\n+    out.hsync();\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    final byte[] b1 = new byte[2*writeSize];\n+    new Random().nextBytes(b1);\n+    out.write(b1);\n+    out.flush();\n+    out.hflush();\n+\n+    out.hsync();\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(writeSize)), acLong.getAllValues());\n+    //flush=true, close=false, flush=true, close=false\n+    Assert.assertEquals(Arrays.asList(true, false, true, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0,writeSize, 0, 2*writeSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of writeSize(1000 bytes) followed by a close is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequest() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[writeSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 5; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize)), acLong.getAllValues());\n+    //flush=false,close=false, flush=true,close=true\n+    Assert.assertEquals(Arrays.asList(false, false, true, true), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, 5*writeSize-bufferSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB) followed by a close is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSizeAndClose() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+    when(client.flush(anyString(), anyLong(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.close();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acFlushLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Boolean> acFlushBool = ArgumentCaptor.forClass(Boolean.class);\n+\n+    verify(client, times(1)).flush(acFlushString.capture(), acFlushLong.capture(), acFlushBool.capture(), acFlushBool.capture());\n+    Assert.assertEquals(Arrays.asList(path) , acFlushString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(2*bufferSize)), acFlushLong.getAllValues());\n+    Assert.assertEquals(Arrays.asList(false, true), acFlushBool.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB) is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSize() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB) on a AppendBlob based stream is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSizeWithAppendBlob() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize)), acLong.getAllValues());\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB)  followed by a hflush call is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSizeAndHFlush() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+    when(client.flush(anyString(), anyLong(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.hflush();\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());\n+    Assert.assertEquals(new HashSet<Long>(Arrays.asList(Long.valueOf(0), Long.valueOf(bufferSize))), new HashSet<Long>(acLong.getAllValues()));\n+    //flush=false, close=false, flush=false, close=false\n+    Assert.assertEquals(Arrays.asList(false, false, false, false), acBool.getAllValues());\n+    Assert.assertEquals(Arrays.asList(0, bufferSize, 0, bufferSize), acInt.getAllValues());\n+\n+    ArgumentCaptor<String> acFlushString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acFlushLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Boolean> acFlushBool = ArgumentCaptor.forClass(Boolean.class);\n+\n+    verify(client, times(1)).flush(acFlushString.capture(), acFlushLong.capture(), acFlushBool.capture(), acFlushBool.capture());\n+    Assert.assertEquals(Arrays.asList(path) , acFlushString.getAllValues());\n+    Assert.assertEquals(Arrays.asList(Long.valueOf(2*bufferSize)), acFlushLong.getAllValues());\n+    Assert.assertEquals(Arrays.asList(false, false), acFlushBool.getAllValues());\n+\n+  }\n+\n+  @Test\n+  /**\n+   * The test verifies OutputStream Write of bufferSize(4KB)  followed by a flush call is making correct HTTP calls to the server\n+   */\n+  public void verifyWriteRequestOfBufferSizeAndFlush() throws Exception {\n+\n+    AbfsClient client = mock(AbfsClient.class);\n+    AbfsRestOperation op = mock(AbfsRestOperation.class);\n+    AbfsConfiguration abfsConf;\n+    final Configuration conf = new Configuration();\n+    conf.set(accountKey1, accountValue1);\n+    abfsConf = new AbfsConfiguration(conf, accountName1);\n+    AbfsPerfTracker tracker = new AbfsPerfTracker(\"test\", accountName1, abfsConf);\n+    when(client.getAbfsPerfTracker()).thenReturn(tracker);\n+    when(client.append(anyString(), anyLong(), any(byte[].class), anyInt(), anyInt(), anyBoolean(), anyBoolean())).thenReturn(op);\n+\n+    AbfsOutputStream out = new AbfsOutputStream(client, path, 0, bufferSize, true, false, true, false);\n+    final byte[] b = new byte[bufferSize];\n+    new Random().nextBytes(b);\n+\n+    for (int i = 0; i < 2; i++) {\n+      out.write(b);\n+    }\n+    out.flush();\n+    Thread.sleep(1000);\n+\n+    ArgumentCaptor<String> acString = ArgumentCaptor.forClass(String.class);\n+    ArgumentCaptor<Long> acLong = ArgumentCaptor.forClass(Long.class);\n+    ArgumentCaptor<Integer> acInt = ArgumentCaptor.forClass(Integer.class);\n+    ArgumentCaptor<Boolean> acBool = ArgumentCaptor.forClass(Boolean.class);\n+    ArgumentCaptor<byte[]> acByteArray = ArgumentCaptor.forClass(byte[].class);\n+\n+    verify(client, times(2)).append(acString.capture(), acLong.capture(), acByteArray.capture(), acInt.capture(), acInt.capture(), acBool.capture(), acBool.capture());\n+    Assert.assertEquals(Arrays.asList(path, path) , acString.getAllValues());", "originalCommit": "be48931febe59c03becc9c8b8505bb41a65d5a68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "017f1232bb4aca1abb6e733bb9a751d5c41344cf", "url": "https://github.com/apache/hadoop/commit/017f1232bb4aca1abb6e733bb9a751d5c41344cf", "message": "incorporated feedbacks", "committedDate": "2020-03-17T06:36:53Z", "type": "commit"}, {"oid": "7388a10e54fd8fdff5e9aca3618f244451002b07", "url": "https://github.com/apache/hadoop/commit/7388a10e54fd8fdff5e9aca3618f244451002b07", "message": "incorporated feedbacks", "committedDate": "2020-03-17T12:00:57Z", "type": "commit"}, {"oid": "f9a80c49469e5e55a32eeb8f9786fe14c39b8538", "url": "https://github.com/apache/hadoop/commit/f9a80c49469e5e55a32eeb8f9786fe14c39b8538", "message": "incorporated feedbacks", "committedDate": "2020-03-17T12:09:55Z", "type": "commit"}]}