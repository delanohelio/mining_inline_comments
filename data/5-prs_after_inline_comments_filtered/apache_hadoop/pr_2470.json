{"pr_number": 2470, "pr_title": "HADOOP-16524. Reloading SSL keystore for both DataNode and NameNode", "pr_createdAt": "2020-11-18T04:50:15Z", "pr_url": "https://github.com/apache/hadoop/pull/2470", "timeline": [{"oid": "d36f0543e445af115f5fed3d9f140047b71122f2", "url": "https://github.com/apache/hadoop/commit/d36f0543e445af115f5fed3d9f140047b71122f2", "message": "HADOOP-16524. Reloading SSL keystore for both DataNode and NameNode", "committedDate": "2020-11-18T02:41:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1NjQ4Mw==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534456483", "bodyText": "nit: this.configurationChangeMonitor is already Optional.empty? So, change this to be if (storesReloadInterval > 0) {....}?", "author": "saintstack", "createdAt": "2020-12-02T20:21:35Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0ODg0MA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538848840", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1NjQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1Nzg1NA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534457854", "bodyText": "Keep the style of the backing class... It doesn't do these big right-shifts on parameters that go to the second line. Be careful w/ line lengths too. The backing file seems to do 80 chars.", "author": "saintstack", "createdAt": "2020-12-02T20:24:11Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0\n+          ? Optional.of(this.makeConfigurationChangeMonitor(storesReloadInterval, sslContextFactory))\n+          : Optional.empty();\n+\n       conn.addFirstConnectionFactory(new SslConnectionFactory(sslContextFactory,\n           HttpVersion.HTTP_1_1.asString()));\n \n       return conn;\n     }\n \n+    private java.util.Timer makeConfigurationChangeMonitor(long reloadInterval,\n+                                                           SslContextFactory.Server sslContextFactory) {", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0ODkzNQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538848935", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1Nzg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1ODgzMQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534458831", "bodyText": "nit: See the formatting for catch in the rest of the file. It does not do this.", "author": "saintstack", "createdAt": "2020-12-02T20:25:52Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0\n+          ? Optional.of(this.makeConfigurationChangeMonitor(storesReloadInterval, sslContextFactory))\n+          : Optional.empty();\n+\n       conn.addFirstConnectionFactory(new SslConnectionFactory(sslContextFactory,\n           HttpVersion.HTTP_1_1.asString()));\n \n       return conn;\n     }\n \n+    private java.util.Timer makeConfigurationChangeMonitor(long reloadInterval,\n+                                                           SslContextFactory.Server sslContextFactory) {\n+      java.util.Timer timer = new java.util.Timer(\"SSL Certificates Store Monitor\", true);\n+      //\n+      // The Jetty SSLContextFactory provides a 'reload' method which will reload both\n+      // truststore and keystore certificates.\n+      //\n+      timer.schedule(new FileMonitoringTimerTask(\n+              Paths.get(keyStore),\n+              path -> {\n+                LOG.info(\"Reloading certificates from store keystore \" + keyStore);\n+                try {\n+                  sslContextFactory.reload(factory -> { });\n+                }\n+                catch (Exception ex) {", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0OTAxOA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538849018", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1ODgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1OTc2Mg==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534459762", "bodyText": "Why the full qualification of Timer here and as function return? You have imported java.util.Timer so no need of these 'java.util' prefixes?", "author": "saintstack", "createdAt": "2020-12-02T20:27:25Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0\n+          ? Optional.of(this.makeConfigurationChangeMonitor(storesReloadInterval, sslContextFactory))\n+          : Optional.empty();\n+\n       conn.addFirstConnectionFactory(new SslConnectionFactory(sslContextFactory,\n           HttpVersion.HTTP_1_1.asString()));\n \n       return conn;\n     }\n \n+    private java.util.Timer makeConfigurationChangeMonitor(long reloadInterval,\n+                                                           SslContextFactory.Server sslContextFactory) {\n+      java.util.Timer timer = new java.util.Timer(\"SSL Certificates Store Monitor\", true);", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0OTA3Mg==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538849072", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1OTc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2MTMyOQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534461329", "bodyText": "nit: line lengths", "author": "saintstack", "createdAt": "2020-12-02T20:30:12Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -29,20 +29,20 @@\n import javax.net.ssl.KeyManagerFactory;\n import javax.net.ssl.TrustManager;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.Files;\n import java.nio.file.Paths;\n import java.security.GeneralSecurityException;\n import java.security.KeyStore;\n import java.text.MessageFormat;\n+import java.util.Timer;\n \n /**\n  * {@link KeyStoresFactory} implementation that reads the certificates from\n  * keystore files.\n  * <p>\n- * if the trust certificates keystore file changes, the {@link TrustManager}\n- * is refreshed with the new trust certificate entries (using a\n- * {@link ReloadingX509TrustManager} trustmanager).\n+ * If either the truststore or the keystore certificates file changes, it would be refreshed", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0OTE5Mg==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538849192", "bodyText": "Fixed", "author": "bolerio", "createdAt": "2020-12-08T22:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2MTMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2MjMyMw==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534462323", "bodyText": "This class is audience private so presuming it ok changing this public static's name.", "author": "saintstack", "createdAt": "2020-12-02T20:32:03Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0OTM2NQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538849365", "bodyText": "Ok", "author": "bolerio", "createdAt": "2020-12-08T22:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2MjMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0NjMyNQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535746325", "bodyText": "Does the rest of this class do this extreme rightward shifting of parameters?", "author": "saintstack", "createdAt": "2020-12-04T00:28:31Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2MjIwNg==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535862206", "bodyText": "Hmm... maybe it does. Ignore the above comment then.", "author": "saintstack", "createdAt": "2020-12-04T06:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0NjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1MDA2OA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538850068", "bodyText": "Yeah, but it's true the most of the code base doesn't have it.  Should I change? I don't mind...just inadvertently sneaking in my old habits I suppose....", "author": "bolerio", "createdAt": "2020-12-08T22:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0NjMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4OTY3Ng==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r539789676", "bodyText": "Seems like your code habits align w/ the backing file here. I'd leave it as is.", "author": "saintstack", "createdAt": "2020-12-10T02:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0NjMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1ODI1NA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535858254", "bodyText": "getPassword will never return null?", "author": "saintstack", "createdAt": "2020-12-04T06:06:06Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)\n+      throws IOException, GeneralSecurityException {\n+    String passwordProperty = resolvePropertyName(mode,\n+        SSL_TRUSTSTORE_PASSWORD_TPL_KEY);\n+    String truststorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (truststorePassword.isEmpty()) {\n+      // An empty trust store password is legal; the trust store password\n+      // is only required when writing to a trust store. Otherwise it's\n+      // an optional integrity check.", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1MTAwNA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538851004", "bodyText": "No, it won't, it will return the default passed as parameter if nothing in config, and that is \"\".", "author": "bolerio", "createdAt": "2020-12-08T22:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1ODI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1ODYyMA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535858620", "bodyText": "Log the interval found in config here too?", "author": "saintstack", "createdAt": "2020-12-04T06:07:06Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)\n+      throws IOException, GeneralSecurityException {\n+    String passwordProperty = resolvePropertyName(mode,\n+        SSL_TRUSTSTORE_PASSWORD_TPL_KEY);\n+    String truststorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (truststorePassword.isEmpty()) {\n+      // An empty trust store password is legal; the trust store password\n+      // is only required when writing to a trust store. Otherwise it's\n+      // an optional integrity check.\n+      truststorePassword = null;\n+    }\n+\n+    // Check if obsolete truststore specific reload interval is present for backward compatible\n+    long truststoreReloadInterval =\n+        conf.getLong(\n+            resolvePropertyName(mode, SSL_TRUSTSTORE_RELOAD_INTERVAL_TPL_KEY),\n+            storesReloadInterval);\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(mode.toString() + \" TrustStore: \" + truststoreLocation);", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1MTU1NA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538851554", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1ODYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2MDYyOQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535860629", "bodyText": "Do we have to check isEmpty here too?", "author": "saintstack", "createdAt": "2020-12-04T06:12:46Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)\n+      throws IOException, GeneralSecurityException {\n+    String passwordProperty = resolvePropertyName(mode,\n+        SSL_TRUSTSTORE_PASSWORD_TPL_KEY);\n+    String truststorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (truststorePassword.isEmpty()) {\n+      // An empty trust store password is legal; the trust store password\n+      // is only required when writing to a trust store. Otherwise it's\n+      // an optional integrity check.\n+      truststorePassword = null;\n+    }\n+\n+    // Check if obsolete truststore specific reload interval is present for backward compatible\n+    long truststoreReloadInterval =\n+        conf.getLong(\n+            resolvePropertyName(mode, SSL_TRUSTSTORE_RELOAD_INTERVAL_TPL_KEY),\n+            storesReloadInterval);\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(mode.toString() + \" TrustStore: \" + truststoreLocation);\n+    }\n+\n+    trustManager = new ReloadingX509TrustManager(\n+        truststoreType,\n+        truststoreLocation,\n+        truststorePassword);\n+\n+    if (truststoreReloadInterval > 0) {\n+      fileMonitoringTimer.schedule(\n+          new FileMonitoringTimerTask(\n+              Paths.get(truststoreLocation),\n+              path -> trustManager.loadFrom(path),\n+              exception -> LOG.error(ReloadingX509TrustManager.RELOAD_ERROR_MESSAGE, exception)),\n+          truststoreReloadInterval,\n+          truststoreReloadInterval);\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(mode.toString() + \" Loaded TrustStore: \" + truststoreLocation);\n+    }\n+    trustManagers = new TrustManager[]{trustManager};\n+  }\n+\n+  /**\n+   * Implements logic of initializing the KeyManagers with the options\n+   * to reload keystores.\n+   * @param mode client or server\n+   * @param keystoreType The keystore type.\n+   * @param storesReloadInterval The interval to check if the keystore certificates\n+   *                             file has changed.\n+   */\n+  private void createKeyManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                  String keystoreType, long storesReloadInterval)\n+      throws GeneralSecurityException, IOException {\n+    String locationProperty =\n+        resolvePropertyName(mode, SSL_KEYSTORE_LOCATION_TPL_KEY);\n+    String keystoreLocation = conf.get(locationProperty, \"\");\n+    if (keystoreLocation.isEmpty()) {\n+      throw new GeneralSecurityException(\"The property '\" + locationProperty +\n+          \"' has not been set in the ssl configuration file.\");\n+    }\n+    String passwordProperty =\n+        resolvePropertyName(mode, SSL_KEYSTORE_PASSWORD_TPL_KEY);\n+    String keystorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (keystorePassword.isEmpty()) {\n+      throw new GeneralSecurityException(\"The property '\" + passwordProperty +\n+          \"' has not been set in the ssl configuration file.\");\n+    }\n+    String keyPasswordProperty =\n+        resolvePropertyName(mode, SSL_KEYSTORE_KEYPASSWORD_TPL_KEY);\n+    // Key password defaults to the same value as store password for\n+    // compatibility with legacy configurations that did not use a separate\n+    // configuration property for key password.\n+    String keystoreKeyPassword = getPassword(\n+        conf, keyPasswordProperty, keystorePassword);", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1Mzg3Ng==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538853876", "bodyText": "Not sure: we have already enforced that keystorePassword  not be empty so we'd get empty here only the config explicitly set it to \"\".   I could add the check, but it will break past behavior in case someone is already deploying with and empty password.", "author": "bolerio", "createdAt": "2020-12-08T22:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2MDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2Mjg2NQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535862865", "bodyText": "No need of the  wrappers.", "author": "saintstack", "createdAt": "2020-12-04T06:19:21Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileMonitoringTimerTask.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.file.Path;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+\n+/**\n+ * <p>", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NDM3Mg==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538854372", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2Mjg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2MzcxNA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535863714", "bodyText": "nit: not consistent in where we locate private... sometimes at start (the usual) and other times as second qualifier. (Can we make all these datamembers private?)", "author": "saintstack", "createdAt": "2020-12-04T06:21:29Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileMonitoringTimerTask.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.file.Path;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+\n+/**\n+ * <p>\n+ * Implements basic logic to track when a file changes on disk and call the action\n+ * passed to the constructor when it does. An exception handler can optionally also be specified\n+ * in the constructor, otherwise any exception occurring during process will be logged\n+ * using this class' logger.\n+ * </p>\n+ */\n+@InterfaceAudience.Private\n+public class FileMonitoringTimerTask extends TimerTask {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(FileMonitoringTimerTask.class);\n+\n+    @VisibleForTesting\n+    static final String PROCESS_ERROR_MESSAGE =\n+            \"Could not process file change : \";\n+\n+    final private Path filePath;\n+    final private Consumer<Path> onFileChange;\n+    final Consumer<Throwable> onChangeFailure;\n+    private long lastProcessed;\n+", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDIzMQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864231", "bodyText": "The tab offsets seem to be 4 spaces when should be 2 as it is elsewhere in hadoop.", "author": "saintstack", "createdAt": "2020-12-04T06:22:43Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileMonitoringTimerTask.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.file.Path;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+\n+/**\n+ * <p>\n+ * Implements basic logic to track when a file changes on disk and call the action\n+ * passed to the constructor when it does. An exception handler can optionally also be specified\n+ * in the constructor, otherwise any exception occurring during process will be logged\n+ * using this class' logger.\n+ * </p>\n+ */\n+@InterfaceAudience.Private\n+public class FileMonitoringTimerTask extends TimerTask {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(FileMonitoringTimerTask.class);\n+\n+    @VisibleForTesting\n+    static final String PROCESS_ERROR_MESSAGE =\n+            \"Could not process file change : \";\n+\n+    final private Path filePath;\n+    final private Consumer<Path> onFileChange;\n+    final Consumer<Throwable> onChangeFailure;\n+    private long lastProcessed;\n+\n+    /**\n+     * Create file monitoring task to be scheduled using a standard Java {@link java.util.Timer}\n+     * instance.\n+     *\n+     * @param filePath The path to the file to monitor.\n+     * @param onFileChange The function to call when the file has changed.\n+     * @param onChangeFailure The function to call when an exception is thrown during the\n+     *                       file change processing.\n+     */\n+    public FileMonitoringTimerTask(Path filePath,\n+                                   Consumer<Path> onFileChange,\n+                                   Consumer<Throwable> onChangeFailure) {\n+        Preconditions.checkNotNull(filePath, \"path to monitor disk file is not set\");\n+        Preconditions.checkNotNull(onFileChange, \"action to monitor disk file is not set\");\n+\n+        this.filePath = filePath;\n+        this.lastProcessed = filePath.toFile().lastModified();\n+        this.onFileChange = onFileChange;\n+        this.onChangeFailure = onChangeFailure;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (lastProcessed != filePath.toFile().lastModified()) {\n+            try {\n+                onFileChange.accept(filePath);\n+            } catch (Throwable t) {\n+                if (onChangeFailure  != null) {\n+                    onChangeFailure.accept(t);\n+                } else {\n+                    LOG.error(PROCESS_ERROR_MESSAGE + filePath.toString(), t);\n+                }\n+            }\n+            lastProcessed = filePath.toFile().lastModified();\n+        }\n+    }", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NTA1NA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538855054", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDU4MQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864581", "bodyText": "Yeah, tab seems to be 4 when should be 2 spaces.", "author": "saintstack", "createdAt": "2020-12-04T06:23:54Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;\n+    private AtomicReference<X509ExtendedKeyManager> keyManagerRef;\n+\n+    /**\n+     * Construct a <code>Reloading509KeystoreManager</code>\n+     *\n+     * @param type type of keystore file, typically 'jks'.\n+     * @param location local path to the keystore file.\n+     * @param storePassword password of the keystore file.\n+     * @param keyPassword The password of the key.\n+     * @throws IOException\n+     * @throws GeneralSecurityException\n+     */\n+    public ReloadingX509KeystoreManager(String type, String location,\n+                                        String storePassword, String keyPassword)\n+            throws IOException, GeneralSecurityException {\n+        this.type = type;\n+        this.storePassword = storePassword;\n+        this.keyPassword = keyPassword;\n+        keyManagerRef = new AtomicReference<X509ExtendedKeyManager>();\n+        keyManagerRef.set(loadKeyManager(Paths.get(location)));\n+    }", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NjE5OA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538856198", "bodyText": "Fixed. Also fixed line length issues in this file.", "author": "bolerio", "createdAt": "2020-12-08T22:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDcxNw==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864717", "bodyText": "Can be final?", "author": "saintstack", "createdAt": "2020-12-04T06:24:10Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NjYyMQ==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538856621", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDkxMA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864910", "bodyText": "Line lengths?", "author": "saintstack", "createdAt": "2020-12-04T06:24:44Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;\n+    private AtomicReference<X509ExtendedKeyManager> keyManagerRef;\n+\n+    /**\n+     * Construct a <code>Reloading509KeystoreManager</code>\n+     *\n+     * @param type type of keystore file, typically 'jks'.\n+     * @param location local path to the keystore file.\n+     * @param storePassword password of the keystore file.\n+     * @param keyPassword The password of the key.\n+     * @throws IOException\n+     * @throws GeneralSecurityException\n+     */\n+    public ReloadingX509KeystoreManager(String type, String location,\n+                                        String storePassword, String keyPassword)\n+            throws IOException, GeneralSecurityException {\n+        this.type = type;\n+        this.storePassword = storePassword;\n+        this.keyPassword = keyPassword;\n+        keyManagerRef = new AtomicReference<X509ExtendedKeyManager>();\n+        keyManagerRef.set(loadKeyManager(Paths.get(location)));\n+    }\n+\n+    @Override\n+    public String chooseEngineClientAlias(String[] strings, Principal[] principals, SSLEngine sslEngine) {", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1NjY4MA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538856680", "bodyText": "Fixed.", "author": "bolerio", "createdAt": "2020-12-08T22:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NTUzMA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535865530", "bodyText": "What will happen when this comes out? Where will it be caught? Will it cause damage causing process exit or thread exit?", "author": "saintstack", "createdAt": "2020-12-04T06:26:25Z", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;\n+    private AtomicReference<X509ExtendedKeyManager> keyManagerRef;\n+\n+    /**\n+     * Construct a <code>Reloading509KeystoreManager</code>\n+     *\n+     * @param type type of keystore file, typically 'jks'.\n+     * @param location local path to the keystore file.\n+     * @param storePassword password of the keystore file.\n+     * @param keyPassword The password of the key.\n+     * @throws IOException\n+     * @throws GeneralSecurityException\n+     */\n+    public ReloadingX509KeystoreManager(String type, String location,\n+                                        String storePassword, String keyPassword)\n+            throws IOException, GeneralSecurityException {\n+        this.type = type;\n+        this.storePassword = storePassword;\n+        this.keyPassword = keyPassword;\n+        keyManagerRef = new AtomicReference<X509ExtendedKeyManager>();\n+        keyManagerRef.set(loadKeyManager(Paths.get(location)));\n+    }\n+\n+    @Override\n+    public String chooseEngineClientAlias(String[] strings, Principal[] principals, SSLEngine sslEngine) {\n+        return keyManagerRef.get().chooseEngineClientAlias(strings, principals, sslEngine);\n+    }\n+\n+    @Override\n+    public String chooseEngineServerAlias(String s, Principal[] principals, SSLEngine sslEngine) {\n+        return keyManagerRef.get().chooseEngineServerAlias(s, principals, sslEngine);\n+    }\n+\n+    @Override\n+    public String[] getClientAliases(String s, Principal[] principals) {\n+        return keyManagerRef.get().getClientAliases(s, principals);\n+    }\n+\n+    @Override\n+    public String chooseClientAlias(String[] strings, Principal[] principals, Socket socket) {\n+        return keyManagerRef.get().chooseClientAlias(strings, principals, socket);\n+    }\n+\n+    @Override\n+    public String[] getServerAliases(String s, Principal[] principals) {\n+        return keyManagerRef.get().getServerAliases(s, principals);\n+    }\n+\n+    @Override\n+    public String chooseServerAlias(String s, Principal[] principals, Socket socket) {\n+        return keyManagerRef.get().chooseServerAlias(s, principals, socket);\n+    }\n+\n+    @Override\n+    public X509Certificate[] getCertificateChain(String s) {\n+        return keyManagerRef.get().getCertificateChain(s);\n+    }\n+\n+    @Override\n+    public PrivateKey getPrivateKey(String s) {\n+        return keyManagerRef.get().getPrivateKey(s);\n+    }\n+\n+    public ReloadingX509KeystoreManager loadFrom(Path path) {\n+        try {\n+            this.keyManagerRef.set(loadKeyManager(path));\n+        } catch (Exception ex) {\n+            // The Consumer.accept interface forces us to convert to unchecked\n+            throw new RuntimeException(ex);", "originalCommit": "d36f0543e445af115f5fed3d9f140047b71122f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg1OTQ1MA==", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r538859450", "bodyText": "It gets caught by the FileMonitoringTimerTask and from there it's logged. It won't cause any damage, but it will keep logging the error on every reload interval if it's not resolved, potentially filling the logs and disk space.", "author": "bolerio", "createdAt": "2020-12-08T22:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NTUzMA=="}], "type": "inlineReview"}, {"oid": "be6b9cc7665a0cf1ee565cf35903137e0109c19e", "url": "https://github.com/apache/hadoop/commit/be6b9cc7665a0cf1ee565cf35903137e0109c19e", "message": "addressing PR comments by saintstack", "committedDate": "2020-12-09T02:57:53Z", "type": "commit"}, {"oid": "142740f0f50fdc36ee358726114e10bb4d206e91", "url": "https://github.com/apache/hadoop/commit/142740f0f50fdc36ee358726114e10bb4d206e91", "message": "few more cosmetic fixes", "committedDate": "2020-12-09T03:55:56Z", "type": "commit"}]}