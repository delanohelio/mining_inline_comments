{"pr_number": 2165, "pr_title": "HDFS-15481. Ordered snapshot deletion: garbage collect deleted snapshots", "pr_createdAt": "2020-07-22T08:49:41Z", "pr_url": "https://github.com/apache/hadoop/pull/2165", "timeline": [{"oid": "3525f0837551612acbd0f1c78be48c065e4984c3", "url": "https://github.com/apache/hadoop/commit/3525f0837551612acbd0f1c78be48c065e4984c3", "message": "HDFS-15481", "committedDate": "2020-07-22T23:17:47Z", "type": "forcePushed"}, {"oid": "a01433c454f6ca68f2940464e68cb8112dee01bb", "url": "https://github.com/apache/hadoop/commit/a01433c454f6ca68f2940464e68cb8112dee01bb", "message": "HDFS-15481", "committedDate": "2020-07-23T08:11:47Z", "type": "commit"}, {"oid": "a01433c454f6ca68f2940464e68cb8112dee01bb", "url": "https://github.com/apache/hadoop/commit/a01433c454f6ca68f2940464e68cb8112dee01bb", "message": "HDFS-15481", "committedDate": "2020-07-23T08:11:47Z", "type": "forcePushed"}, {"oid": "16990d25e98d25a2bd93bbf9fdec219b248db1e9", "url": "https://github.com/apache/hadoop/commit/16990d25e98d25a2bd93bbf9fdec219b248db1e9", "message": "Fix checkstyle and move the private confs to SnapshotManager.", "committedDate": "2020-07-23T18:10:48Z", "type": "commit"}, {"oid": "16990d25e98d25a2bd93bbf9fdec219b248db1e9", "url": "https://github.com/apache/hadoop/commit/16990d25e98d25a2bd93bbf9fdec219b248db1e9", "message": "Fix checkstyle and move the private confs to SnapshotManager.", "committedDate": "2020-07-23T18:10:48Z", "type": "forcePushed"}, {"oid": "dc1debd29a01c520fa344ff6a4dc934693c05f8e", "url": "https://github.com/apache/hadoop/commit/dc1debd29a01c520fa344ff6a4dc934693c05f8e", "message": "Rename a test method.", "committedDate": "2020-07-23T18:15:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQyODc5Mg==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r460428792", "bodyText": "Lets move this to a different funcation like chooseSnapshottableDir, as this might be policy controleed later.", "author": "mukul1987", "createdAt": "2020-07-25T17:59:21Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -629,4 +641,36 @@ public void shutdown() {\n         s.getRoot().getLocalName(), s.getRoot().getFullPathName(),\n         s.getRoot().getModificationTime());\n   }\n-}\n+\n+  Snapshot.Root chooseDeletedSnapshot() {\n+    final List<INodeDirectory> dirs = getSnapshottableDirs();\n+    Collections.shuffle(dirs);", "originalCommit": "dc1debd29a01c520fa344ff6a4dc934693c05f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODIyNg==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461248226", "bodyText": "Sure.", "author": "szetszwo", "createdAt": "2020-07-28T00:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQyODc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQyODg3Nw==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r460428877", "bodyText": "Lets add an assert that this is the first snapshot in the snapshottable dir ?", "author": "mukul1987", "createdAt": "2020-07-25T18:00:17Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotDeletionGc.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.apache.hadoop.util.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS;\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT;\n+\n+public class SnapshotDeletionGc {\n+  public static final Logger LOG = LoggerFactory.getLogger(\n+      SnapshotDeletionGc.class);\n+\n+  private final FSNamesystem namesystem;\n+  private final int deletionOrderedGcPeriodMs;\n+  private final AtomicReference<Timer> timer = new AtomicReference<>();\n+\n+  public SnapshotDeletionGc(FSNamesystem namesystem, Configuration conf) {\n+    this.namesystem = namesystem;\n+\n+    this.deletionOrderedGcPeriodMs = conf.getInt(\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT);\n+    LOG.info(\"{} = {}\", DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        deletionOrderedGcPeriodMs);\n+  }\n+\n+  public void schedule() {\n+    if (timer.get() != null) {\n+      return;\n+    }\n+    final Timer t = new Timer(getClass().getSimpleName(), true);\n+    if (timer.compareAndSet(null, t)) {\n+      LOG.info(\"Schedule at fixed rate {}\",\n+          StringUtils.formatTime(deletionOrderedGcPeriodMs));\n+      t.scheduleAtFixedRate(new GcTask(),\n+          deletionOrderedGcPeriodMs, deletionOrderedGcPeriodMs);\n+    }\n+  }\n+\n+  public void cancel() {\n+    final Timer t = timer.getAndSet(null);\n+    if (t != null) {\n+      LOG.info(\"cancel\");\n+      t.cancel();\n+    }\n+  }\n+\n+  private void gcDeletedSnapshot(String name) {\n+    final Snapshot.Root deleted;\n+    namesystem.readLock();", "originalCommit": "dc1debd29a01c520fa344ff6a4dc934693c05f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODE3MQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461248171", "bodyText": "This is a good idea.  Let's add the assertion to all the cases when the SnapshotDeletionOrdered feature is enabled.", "author": "szetszwo", "createdAt": "2020-07-28T00:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQyODg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczNzIzMg==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r460737232", "bodyText": "I think its better to start the gc work in FSNameSystem#startActiveServices() after quota setup and initialization is done\nstartActiveServices()\n``\n// Initialize the quota.\ndir.updateCountForQuota();\n// Enable quota checks.\ndir.enableQuotaChecks();", "author": "bshashikant", "createdAt": "2020-07-27T08:44:20Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "diffHunk": "@@ -1284,6 +1288,7 @@ void startCommonServices(Configuration conf, HAContext haContext) throws IOExcep\n       dir.setINodeAttributeProvider(inodeAttributeProvider);\n     }\n     snapshotManager.registerMXBean();\n+    snapshotDeletionGc.schedule();", "originalCommit": "dc1debd29a01c520fa344ff6a4dc934693c05f8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0OTA5Mw==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461249093", "bodyText": "Sure.  Thanks for the suggestion.", "author": "szetszwo", "createdAt": "2020-07-28T00:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczNzIzMg=="}], "type": "inlineReview"}, {"oid": "99dab64faea4426ad8c82eba6b581c984ac98943", "url": "https://github.com/apache/hadoop/commit/99dab64faea4426ad8c82eba6b581c984ac98943", "message": "Address review comments.", "committedDate": "2020-07-28T00:43:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NjQwMA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461786400", "bodyText": "This assertion should also be inside gcDeletedSnapshot ?", "author": "mukul1987", "createdAt": "2020-07-28T18:28:57Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -382,6 +395,14 @@ public void deleteSnapshot(final INodesInPath iip, final String snapshotName,\n             EnumSet.of(XAttrSetFlag.CREATE, XAttrSetFlag.REPLACE));\n         return;\n       }\n+\n+      // assert if it is deleting the first snapshot\n+      final INodeDirectoryAttributes first = snapshottable.getDiffs().getFirstSnapshotINode();\n+      if (snapshot.getRoot() != first) {\n+        throw new IllegalStateException(\"Failed to delete snapshot \" + snapshotName", "originalCommit": "99dab64faea4426ad8c82eba6b581c984ac98943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxODU2NQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461818565", "bodyText": "No.  gcDeletedSnapshot will end up here.", "author": "szetszwo", "createdAt": "2020-07-28T19:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NjQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNTE2OQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461805169", "bodyText": "Lets assert that xattr is set on the snapshot and this is the first snapshot to be deleted.", "author": "mukul1987", "createdAt": "2020-07-28T19:01:52Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "diffHunk": "@@ -7166,6 +7175,29 @@ void deleteSnapshot(String snapshotRoot, String snapshotName,\n     logAuditEvent(true, operationName, rootPath, null, null);\n   }\n \n+  public void gcDeletedSnapshot(String snapshotRoot, String snapshotName)\n+      throws IOException {\n+    final String operationName = \"gcDeletedSnapshot\";\n+    String rootPath = null;\n+    final INode.BlocksMapUpdateInfo blocksToBeDeleted;\n+\n+    checkOperation(OperationCategory.WRITE);\n+    writeLock();\n+    try {\n+      checkOperation(OperationCategory.WRITE);\n+      rootPath = Snapshot.getSnapshotPath(snapshotRoot, snapshotName);\n+      checkNameNodeSafeMode(\"Cannot gcDeletedSnapshot for \" + rootPath);\n+\n+      final long now = Time.now();", "originalCommit": "99dab64faea4426ad8c82eba6b581c984ac98943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTExMQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461839111", "bodyText": "Let's check if the snapshot isMarkedAsDeleted.  The \"first snapshot\" check is already in the code.", "author": "szetszwo", "createdAt": "2020-07-28T19:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNTE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNjMxOQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461806319", "bodyText": "Lets change this to error and abort and exit from the namenode if the deletion is not possible.\nI feel we should do this earlier to identify issues with snapshot deletion code.", "author": "mukul1987", "createdAt": "2020-07-28T19:04:04Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotDeletionGc.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.apache.hadoop.util.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS;\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT;\n+\n+public class SnapshotDeletionGc {\n+  public static final Logger LOG = LoggerFactory.getLogger(\n+      SnapshotDeletionGc.class);\n+\n+  private final FSNamesystem namesystem;\n+  private final long deletionOrderedGcPeriodMs;\n+  private final AtomicReference<Timer> timer = new AtomicReference<>();\n+\n+  public SnapshotDeletionGc(FSNamesystem namesystem, Configuration conf) {\n+    this.namesystem = namesystem;\n+\n+    this.deletionOrderedGcPeriodMs = conf.getLong(\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT);\n+    LOG.info(\"{} = {}\", DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        deletionOrderedGcPeriodMs);\n+  }\n+\n+  public void schedule() {\n+    if (timer.get() != null) {\n+      return;\n+    }\n+    final Timer t = new Timer(getClass().getSimpleName(), true);\n+    if (timer.compareAndSet(null, t)) {\n+      LOG.info(\"Schedule at fixed rate {}\",\n+          StringUtils.formatTime(deletionOrderedGcPeriodMs));\n+      t.scheduleAtFixedRate(new GcTask(),\n+          deletionOrderedGcPeriodMs, deletionOrderedGcPeriodMs);\n+    }\n+  }\n+\n+  public void cancel() {\n+    final Timer t = timer.getAndSet(null);\n+    if (t != null) {\n+      LOG.info(\"cancel\");\n+      t.cancel();\n+    }\n+  }\n+\n+  private void gcDeletedSnapshot(String name) {\n+    final Snapshot.Root deleted;\n+    namesystem.readLock();\n+    try {\n+      deleted = namesystem.getSnapshotManager().chooseDeletedSnapshot();\n+    } finally {\n+      namesystem.readUnlock();\n+    }\n+    if (deleted == null) {\n+      LOG.trace(\"{}: no snapshots are marked as deleted.\", name);\n+      return;\n+    }\n+\n+    final String snapshotRoot = deleted.getRootFullPathName();\n+    final String snapshotName = deleted.getLocalName();\n+    LOG.info(\"{}: delete snapshot {} from {}\",\n+        name, snapshotName, snapshotRoot);\n+\n+    try {\n+      namesystem.gcDeletedSnapshot(snapshotRoot, snapshotName);\n+    } catch (Throwable e) {\n+      LOG.warn(\"Failed to gcDeletedSnapshot \" + deleted.getFullPathName(), e);", "originalCommit": "99dab64faea4426ad8c82eba6b581c984ac98943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0MTQ5Ng==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461841496", "bodyText": "The user could be also deleting the snapshot since we only have read lock earlier.  The gcDeletedSnapshot here will fail.\nWe cannot kill a production system when a snapshot cannot be deleted.\nI could change the log to error.", "author": "szetszwo", "createdAt": "2020-07-28T19:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzA2MA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461807060", "bodyText": "lets catch Throwable here and log error in case we get an exception here.", "author": "mukul1987", "createdAt": "2020-07-28T19:05:27Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotDeletionGc.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.apache.hadoop.util.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS;\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT;\n+\n+public class SnapshotDeletionGc {\n+  public static final Logger LOG = LoggerFactory.getLogger(\n+      SnapshotDeletionGc.class);\n+\n+  private final FSNamesystem namesystem;\n+  private final long deletionOrderedGcPeriodMs;\n+  private final AtomicReference<Timer> timer = new AtomicReference<>();\n+\n+  public SnapshotDeletionGc(FSNamesystem namesystem, Configuration conf) {\n+    this.namesystem = namesystem;\n+\n+    this.deletionOrderedGcPeriodMs = conf.getLong(\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT);\n+    LOG.info(\"{} = {}\", DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        deletionOrderedGcPeriodMs);\n+  }\n+\n+  public void schedule() {\n+    if (timer.get() != null) {\n+      return;\n+    }\n+    final Timer t = new Timer(getClass().getSimpleName(), true);\n+    if (timer.compareAndSet(null, t)) {\n+      LOG.info(\"Schedule at fixed rate {}\",\n+          StringUtils.formatTime(deletionOrderedGcPeriodMs));\n+      t.scheduleAtFixedRate(new GcTask(),\n+          deletionOrderedGcPeriodMs, deletionOrderedGcPeriodMs);\n+    }\n+  }\n+\n+  public void cancel() {\n+    final Timer t = timer.getAndSet(null);\n+    if (t != null) {\n+      LOG.info(\"cancel\");\n+      t.cancel();\n+    }\n+  }\n+\n+  private void gcDeletedSnapshot(String name) {\n+    final Snapshot.Root deleted;\n+    namesystem.readLock();\n+    try {\n+      deleted = namesystem.getSnapshotManager().chooseDeletedSnapshot();\n+    } finally {", "originalCommit": "99dab64faea4426ad8c82eba6b581c984ac98943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0MzA5NA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461843094", "bodyText": "Sure", "author": "szetszwo", "createdAt": "2020-07-28T20:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNzA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMDMxNw==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461810317", "bodyText": "I feel all the deletion should happen via one code path, i.e. the background thread. some deletion from the user thread and others from background is error prone.", "author": "mukul1987", "createdAt": "2020-07-28T19:11:26Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -382,6 +395,14 @@ public void deleteSnapshot(final INodesInPath iip, final String snapshotName,\n             EnumSet.of(XAttrSetFlag.CREATE, XAttrSetFlag.REPLACE));\n         return;\n       }\n+", "originalCommit": "99dab64faea4426ad8c82eba6b581c984ac98943", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NDE5MA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461844190", "bodyText": "@jnp , what is your thought?", "author": "szetszwo", "createdAt": "2020-07-28T20:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMDMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0NDk5Ng==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461844996", "bodyText": "IMO, if the user is delete the first snapshot.  We should do it right away.  Otherwise, there is no way for the user to free up the resource from the snapshots.", "author": "szetszwo", "createdAt": "2020-07-28T20:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMDMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5NjU2NA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461996564", "bodyText": "I agree with @szetszwo here. If the user follows the order of deletion, it doesn't make sense to delay it further by pushing it to a background thread. Snapshot deletion is still happening by the same code path in SnapshotManager but the triggers are different.\nSnapshotDeletiongc as well as User deleteSnapshotOperation directly calls FsDirSnapshot#deleteSnapshot() which eventually calls SnapshotManger function while Replay of edits will directly call SnapshotManager#deleteSnapshot bypassing all the checks. So, essentially every deletion in the system won't be taking the exact path.", "author": "bshashikant", "createdAt": "2020-07-29T02:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMDMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTYxMw==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461999613", "bodyText": "I agree that code paths are similar. However, just wanted to discuss this once. :) The only thing which might not work is the sleep between every snap deletes here. It may happen that the user operation snap delete and the background thread based snap delete are not time spaced correctly. But that is not a big issue anyways.", "author": "mukul1987", "createdAt": "2020-07-29T02:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMDMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUyMDExMg==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r462520112", "bodyText": "Sure, thanks.", "author": "szetszwo", "createdAt": "2020-07-29T19:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxMDMxNw=="}], "type": "inlineReview"}, {"oid": "032729514c1406f0d329fca1c421bb09f8acf783", "url": "https://github.com/apache/hadoop/commit/032729514c1406f0d329fca1c421bb09f8acf783", "message": "Address Mukul's second set of review comments.", "committedDate": "2020-07-28T20:07:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTkyNQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r461999925", "bodyText": "If the snapshot delete for the same snapname failed multiple times after the namenode came out of safemode. Should we exit the NN process ?", "author": "mukul1987", "createdAt": "2020-07-29T02:25:09Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotDeletionGc.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.apache.hadoop.util.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS;\n+import static org.apache.hadoop.hdfs.server.namenode.snapshot.SnapshotManager.DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT;\n+\n+public class SnapshotDeletionGc {\n+  public static final Logger LOG = LoggerFactory.getLogger(\n+      SnapshotDeletionGc.class);\n+\n+  private final FSNamesystem namesystem;\n+  private final long deletionOrderedGcPeriodMs;\n+  private final AtomicReference<Timer> timer = new AtomicReference<>();\n+\n+  public SnapshotDeletionGc(FSNamesystem namesystem, Configuration conf) {\n+    this.namesystem = namesystem;\n+\n+    this.deletionOrderedGcPeriodMs = conf.getLong(\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS_DEFAULT);\n+    LOG.info(\"{} = {}\", DFS_NAMENODE_SNAPSHOT_DELETION_ORDERED_GC_PERIOD_MS,\n+        deletionOrderedGcPeriodMs);\n+  }\n+\n+  public void schedule() {\n+    if (timer.get() != null) {\n+      return;\n+    }\n+    final Timer t = new Timer(getClass().getSimpleName(), true);\n+    if (timer.compareAndSet(null, t)) {\n+      LOG.info(\"Schedule at fixed rate {}\",\n+          StringUtils.formatTime(deletionOrderedGcPeriodMs));\n+      t.scheduleAtFixedRate(new GcTask(),\n+          deletionOrderedGcPeriodMs, deletionOrderedGcPeriodMs);\n+    }\n+  }\n+\n+  public void cancel() {\n+    final Timer t = timer.getAndSet(null);\n+    if (t != null) {\n+      LOG.info(\"cancel\");\n+      t.cancel();\n+    }\n+  }\n+\n+  private void gcDeletedSnapshot(String name) {\n+    final Snapshot.Root deleted;\n+    namesystem.readLock();\n+    try {\n+      deleted = namesystem.getSnapshotManager().chooseDeletedSnapshot();\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to chooseDeletedSnapshot\", e);\n+      throw e;\n+    } finally {\n+      namesystem.readUnlock();\n+    }\n+    if (deleted == null) {\n+      LOG.trace(\"{}: no snapshots are marked as deleted.\", name);\n+      return;\n+    }\n+\n+    final String snapshotRoot = deleted.getRootFullPathName();\n+    final String snapshotName = deleted.getLocalName();\n+    LOG.info(\"{}: delete snapshot {} from {}\",\n+        name, snapshotName, snapshotRoot);\n+\n+    try {\n+      namesystem.gcDeletedSnapshot(snapshotRoot, snapshotName);\n+    } catch (Throwable e) {\n+      LOG.error(\"Failed to gcDeletedSnapshot \" + deleted.getFullPathName(), e);", "originalCommit": "032729514c1406f0d329fca1c421bb09f8acf783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUxOTIyMw==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r462519223", "bodyText": "The Trash emptier won't kill the NN.  Let's do the same thing here.", "author": "szetszwo", "createdAt": "2020-07-29T18:59:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5OTkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDg3NQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r462000875", "bodyText": "The check here should be !snapshotRoot.isMarkedAsDeleted() ?", "author": "mukul1987", "createdAt": "2020-07-29T02:29:00Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -267,6 +280,20 @@ public INodeDirectory getSnapshottableRoot(final INodesInPath iip)\n     return dir;\n   }\n \n+  public void assertMarkedAsDeleted(INodesInPath iip, String snapshotName)\n+      throws IOException {\n+    final INodeDirectory dir = getSnapshottableRoot(iip);\n+    final Snapshot.Root snapshotRoot = dir.getDirectorySnapshottableFeature()\n+        .getSnapshotByName(dir, snapshotName)\n+        .getRoot();\n+\n+    if (snapshotRoot.isMarkedAsDeleted()) {", "originalCommit": "032729514c1406f0d329fca1c421bb09f8acf783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1MjkwNA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r462452904", "bodyText": "Good catch. Thanks.", "author": "szetszwo", "createdAt": "2020-07-29T17:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMDg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTQ0Mg==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r462001442", "bodyText": "should we also add an assert inside FSDirSnapshotOp.deleteSnapshot, which is common to both the code paths. That with the ordered delete flag set to true. The snapshot being deleted is the first snapshot in the list ?", "author": "mukul1987", "createdAt": "2020-07-29T02:30:54Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "diffHunk": "@@ -7166,6 +7175,30 @@ void deleteSnapshot(String snapshotRoot, String snapshotName,\n     logAuditEvent(true, operationName, rootPath, null, null);\n   }\n \n+  public void gcDeletedSnapshot(String snapshotRoot, String snapshotName)\n+      throws IOException {\n+    final String operationName = \"gcDeletedSnapshot\";\n+    String rootPath = null;\n+    final INode.BlocksMapUpdateInfo blocksToBeDeleted;\n+\n+    checkOperation(OperationCategory.WRITE);\n+    writeLock();\n+    try {\n+      checkOperation(OperationCategory.WRITE);\n+      rootPath = Snapshot.getSnapshotPath(snapshotRoot, snapshotName);\n+      checkNameNodeSafeMode(\"Cannot gcDeletedSnapshot for \" + rootPath);\n+\n+      final long now = Time.now();\n+      final INodesInPath iip = dir.resolvePath(null, snapshotRoot, DirOp.WRITE);\n+      snapshotManager.assertMarkedAsDeleted(iip, snapshotName);\n+      blocksToBeDeleted = FSDirSnapshotOp.deleteSnapshot(", "originalCommit": "032729514c1406f0d329fca1c421bb09f8acf783", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNDQ2NA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r462004464", "bodyText": "It is already inside SnapshotManager#deleteSnapshot", "author": "mukul1987", "createdAt": "2020-07-29T02:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwMTQ0Mg=="}], "type": "inlineReview"}, {"oid": "a16f77f9304e8aa06c62d1837a4b41d3b28cb9c7", "url": "https://github.com/apache/hadoop/commit/a16f77f9304e8aa06c62d1837a4b41d3b28cb9c7", "message": "Do not create SnapshotDeletionGc when the feature is disable, fix a bug and add more assertions.", "committedDate": "2020-07-29T18:52:40Z", "type": "commit"}, {"oid": "68ed1e018ae6cf44dba373fff20951eda9566fa2", "url": "https://github.com/apache/hadoop/commit/68ed1e018ae6cf44dba373fff20951eda9566fa2", "message": "Move FSDirectory.snapshotDeletionOrdered to SnapshotManager.", "committedDate": "2020-07-29T19:32:39Z", "type": "commit"}, {"oid": "6fa88dcf07cbc8305ffaf7a07c89ab7e877d3c42", "url": "https://github.com/apache/hadoop/commit/6fa88dcf07cbc8305ffaf7a07c89ab7e877d3c42", "message": "Some minor changes.", "committedDate": "2020-07-29T19:48:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MDE1OA==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r462750158", "bodyText": "do we need to do a null check here before calling removeBlocks as its done in other code paths where remove blocks is getting called ?\ne.g. FsNamesystem#deleteSnapshot:\n---------// Breaking the pattern as removing blocks have to happen outside of the // global lock if (blocksToBeDeleted != null) { removeBlocks(blocksToBeDeleted); }", "author": "bshashikant", "createdAt": "2020-07-30T05:49:57Z", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "diffHunk": "@@ -7166,6 +7178,30 @@ void deleteSnapshot(String snapshotRoot, String snapshotName,\n     logAuditEvent(true, operationName, rootPath, null, null);\n   }\n \n+  public void gcDeletedSnapshot(String snapshotRoot, String snapshotName)\n+      throws IOException {\n+    final String operationName = \"gcDeletedSnapshot\";\n+    String rootPath = null;\n+    final INode.BlocksMapUpdateInfo blocksToBeDeleted;\n+\n+    checkOperation(OperationCategory.WRITE);\n+    writeLock();\n+    try {\n+      checkOperation(OperationCategory.WRITE);\n+      rootPath = Snapshot.getSnapshotPath(snapshotRoot, snapshotName);\n+      checkNameNodeSafeMode(\"Cannot gcDeletedSnapshot for \" + rootPath);\n+\n+      final long now = Time.now();\n+      final INodesInPath iip = dir.resolvePath(null, snapshotRoot, DirOp.WRITE);\n+      snapshotManager.assertMarkedAsDeleted(iip, snapshotName);\n+      blocksToBeDeleted = FSDirSnapshotOp.deleteSnapshot(\n+          dir, snapshotManager, iip, snapshotName, now);\n+    } finally {\n+      writeUnlock(operationName, getLockReportInfoSupplier(rootPath));\n+    }\n+    removeBlocks(blocksToBeDeleted);", "originalCommit": "6fa88dcf07cbc8305ffaf7a07c89ab7e877d3c42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE0Njc3MQ==", "url": "https://github.com/apache/hadoop/pull/2165#discussion_r463146771", "bodyText": "No.  blocksToBeDeleted is never null.\nThe statement \"if (blocksToBeDeleted != null)\" in FsNamesystem#deleteSnapshot actually generates a warning in IntelIJ saying that \"the condition blocksToBeDeleted != null is always true\".", "author": "szetszwo", "createdAt": "2020-07-30T17:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjc1MDE1OA=="}], "type": "inlineReview"}]}