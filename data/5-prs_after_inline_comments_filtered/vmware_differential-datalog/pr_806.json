{"pr_number": 806, "pr_title": "ddlog-jooq: support inserts and batch queries", "pr_createdAt": "2020-11-10T00:08:51Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/806", "timeline": [{"oid": "a901094cc90a9d1b4a9d0ce6ded2caf83152cf3e", "url": "https://github.com/vmware/differential-datalog/commit/a901094cc90a9d1b4a9d0ce6ded2caf83152cf3e", "message": "Support insert queries\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-09T23:24:54Z", "type": "commit"}, {"oid": "fc9f3db754593e963d126f818e714445c28732be", "url": "https://github.com/vmware/differential-datalog/commit/fc9f3db754593e963d126f818e714445c28732be", "message": "Support batch queries\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-09T23:57:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwMjA3Ng==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520202076", "bodyText": "ideally you should use the presto parser for this too.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T00:11:30Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -49,26 +58,38 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n \n     @Override\n     public MockResult[] execute(final MockExecuteContext ctx) throws SQLException {\n-        final MockResult[] mock = new MockResult[1];\n-        // The execute context contains SQL string(s), bind values, and other meta-data\n-        final String sql = ctx.sql();\n+        final String[] batchSql = ctx.batchSQL();\n+        final MockResult[] mock = new MockResult[batchSql.length];\n+        try {\n+            dDlogAPI.transactionStart();\n+            for (int i = 0; i < batchSql.length; i++) {\n+                mock[i] = execute(batchSql[i]);\n+            }\n+            dDlogAPI.transactionCommit();\n+        } catch (final DDlogException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return mock;\n+    }\n \n+    private MockResult execute(final String sql) throws SQLException {\n         if (sql.toUpperCase().startsWith(\"SELECT\")) {\n-            mock[0] = executeSelectStar(sql);\n+            return executeSelectStar(sql);\n+        } else if (sql.toUpperCase().startsWith(\"INSERT INTO\")) {\n+            return executeInsert(sql);\n         } else {\n             // Exceptions are propagated through the JDBC and jOOQ APIs\n             throw new SQLException(\"Statement not supported: \" + sql);\n         }\n-        return mock;\n     }\n \n     private MockResult executeSelectStar(final String sql) throws SQLException {\n-        final String[] s = sql.toUpperCase().split(\" \");\n-        if (!(s.length == 4 && s[1].equals(\"*\") && s[2].equals(\"FROM\"))) {\n+        final String[] s = sql.split(\"[ \\t\\n]+\");", "originalCommit": "fc9f3db754593e963d126f818e714445c28732be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwOTc0Mg==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520209742", "bodyText": "Yeah, I was thinking the same seeing the other issue with primary keys. I'll refactor that in. I hope it isn't too slow.", "author": "lalithsuresh", "createdAt": "2020-11-10T00:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwMjA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwMzU1MA==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520203550", "bodyText": "maybe it's time to create a helper function to return a relation name from a table name.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T00:16:03Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -89,13 +110,42 @@ private MockResult executeSelectStar(final String sql) throws SQLException {\n         return new MockResult(1, result);\n     }\n \n+    private MockResult executeInsert(final String sql) throws SQLException {\n+        final String[] s = sql.replaceAll(\"[(),]\", \"\")\n+                              .split(\"[ \\t\\n]+\");\n+        if (!(s.length >= 4 && s[1].equalsIgnoreCase(\"INTO\")\n+                && s[3].equalsIgnoreCase(\"VALUES\"))) {\n+            throw new SQLException(\"Statement not supported: \" + sql);\n+        }\n+        final String tableName = s[2];\n+        final int valuesIndex = 4; // the index representing the 1st field of the value being inserted\n+        final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+        if (fields == null) {\n+            throw new SQLException(\"Table cannot be queried: \" + tableName);\n+        }\n+        String[] valuesTuple = Arrays.copyOfRange(s, valuesIndex, s.length);\n+        final DDlogRecord dDlogRecord = toDDlogRecord(tableName, valuesTuple);\n+        final int tableId = dDlogAPI.getTableId(\"R\" + tableName.toLowerCase());", "originalCommit": "fc9f3db754593e963d126f818e714445c28732be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxMTMyOA==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520211328", "bodyText": "Ack. Will do.", "author": "lalithsuresh", "createdAt": "2020-11-10T00:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwMzU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDE1Ng==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520204156", "bodyText": "technically these are two different constructors of the same type, the option type.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T00:17:54Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -22,21 +25,27 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n \n+import static org.jooq.impl.DSL.field;\n+\n public class DDlogJooqProvider implements MockDataProvider {\n     private static final String INTEGER_TYPE = \"java.lang.Integer\";\n     private static final String STRING_TYPE = \"java.lang.String\";\n     private static final String BOOLEAN_TYPE = \"java.lang.Boolean\";\n     private static final String LONG_TYPE = \"java.lang.Long\";\n-\n+    private static final String DDLOG_SOME_TYPE = \"ddlog_std::Some\";", "originalCommit": "fc9f3db754593e963d126f818e714445c28732be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxMTQyMA==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520211420", "bodyText": "So can I use just use ddlog_std::Option instead?", "author": "lalithsuresh", "createdAt": "2020-11-10T00:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxNTUyMg==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520215522", "bodyText": "Your code is correct, it's just that these two are constructors, not types.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T00:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDU1OA==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520204558", "bodyText": "it's handy to output the unexpected string for debugging.\ntrim() is sometimes useful too.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T00:19:08Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -111,4 +161,72 @@ private Object structToValue(final Field<?> field, final DDlogRecord record) {\n                 throw new RuntimeException(\"Unknown datatype %s of field %s in table %s in update received\");\n         }\n     }\n+\n+    private DDlogRecord toDDlogRecord(final String tableName, final String[] args) {\n+        final DDlogRecord[] recordsArray = new DDlogRecord[args.length];\n+        final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+\n+        int fieldIndex = 0;\n+        for (final Field<?> field : fields) {\n+            final Class<?> cls = field.getType();\n+            try {\n+                // Handle nullable columns here\n+                if (args[fieldIndex] == null) {\n+                    recordsArray[fieldIndex] = DDlogRecord.makeStruct(DDLOG_NONE_TYPE, new DDlogRecord[0]);\n+                }\n+                else {\n+                    switch (cls.getName()) {\n+                        case BOOLEAN_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,\n+                                    new DDlogRecord(Boolean.parseBoolean(args[fieldIndex])));\n+                            break;\n+                        case INTEGER_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,\n+                                    new DDlogRecord(Integer.parseInt(args[fieldIndex])));\n+                            break;\n+                        case LONG_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,\n+                                    new DDlogRecord(Long.parseLong(args[fieldIndex])));\n+                            break;\n+                        case STRING_TYPE:\n+                            // Strings have to be escaped by single quotes\n+                            if (args[fieldIndex].startsWith(\"'\") && args[fieldIndex].endsWith(\"'\")) {\n+                                recordsArray[fieldIndex] = maybeOption(field,\n+                                        new DDlogRecord(args[fieldIndex].substring(1, args[fieldIndex].length() - 1)));\n+                            } else {\n+                                throw new RuntimeException(\"Unexpected string\");", "originalCommit": "fc9f3db754593e963d126f818e714445c28732be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDgyNw==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520204827", "bodyText": "there's a bunch of common functionality between all these cases that could be factored out, not sure it's worth.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T00:19:45Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -111,4 +161,72 @@ private Object structToValue(final Field<?> field, final DDlogRecord record) {\n                 throw new RuntimeException(\"Unknown datatype %s of field %s in table %s in update received\");\n         }\n     }\n+\n+    private DDlogRecord toDDlogRecord(final String tableName, final String[] args) {\n+        final DDlogRecord[] recordsArray = new DDlogRecord[args.length];\n+        final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+\n+        int fieldIndex = 0;\n+        for (final Field<?> field : fields) {\n+            final Class<?> cls = field.getType();\n+            try {\n+                // Handle nullable columns here\n+                if (args[fieldIndex] == null) {\n+                    recordsArray[fieldIndex] = DDlogRecord.makeStruct(DDLOG_NONE_TYPE, new DDlogRecord[0]);\n+                }\n+                else {\n+                    switch (cls.getName()) {\n+                        case BOOLEAN_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,", "originalCommit": "fc9f3db754593e963d126f818e714445c28732be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxMTg1OQ==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520211859", "bodyText": "Not sure I can though. There's no way to pattern match on the class names, because I don't know the schema in advance. And the way to parse the supplied SQL is different per type.", "author": "lalithsuresh", "createdAt": "2020-11-10T00:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDgyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxMTk0NQ==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520211945", "bodyText": "Maybe this code will also get simplified if I use the presto parser here.", "author": "lalithsuresh", "createdAt": "2020-11-10T00:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNTI1OQ==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520205259", "bodyText": "you can still make each test a separate function and call it here.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T00:21:12Z", "path": "sql/src/test/java/ddlog/JooqProviderTest.java", "diffHunk": "@@ -27,60 +25,85 @@\n import java.util.ArrayList;\n import java.util.List;\n \n-import static org.junit.Assert.assertArrayEquals;\n-import static org.junit.Assert.assertEquals;\n+import static junit.framework.TestCase.assertFalse;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.jooq.impl.DSL.field;\n \n public class JooqProviderTest {\n \n+    /*\n+     * We can only have one DDlog program loaded in memory at a time. We\n+     * therefore conduct a series of tests within a single method.\n+     */\n     @Test\n-    public void testddlog() throws IOException, DDlogException {\n-        final Translator t = new Translator(null);\n-        final String s1 = \"create table hosts (id integer, capacity integer)\";\n-        final String v2 = \"create view hostsv as select distinct * from hosts\";\n-        final String v1 = \"create view good_hosts as select distinct * from hosts where capacity < 50\";\n-        t.translateSqlStatement(s1);\n-        t.translateSqlStatement(v2);\n-        t.translateSqlStatement(v1);\n-        final DDlogProgram dDlogProgram = t.getDDlogProgram();\n-        writeProgramToFile(dDlogProgram.toString());\n-        DDlogAPI.compileDDlogProgram(\"/tmp/program.dl\", true, \"../lib\", \"./lib\");\n-        DDlogAPI.loadDDlog();\n-\n-        final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n-        final int numInserts = 5;\n-        dDlogAPI.transactionStart();\n-        for (int i = 0; i < numInserts; i++) {\n-            final DDlogRecord rec = new DDlogRecord(i);\n-            final DDlogRecord cap = new DDlogRecord(20);\n-            final DDlogRecord struct = DDlogRecord.makeStruct(\"Thosts\", rec, cap);\n-            final int id = dDlogAPI.getTableId(\"Rhosts\");\n-            final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, id, struct);\n-            dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n-        }\n-        dDlogAPI.transactionCommit();\n-\n-        final List<String> ddl = new ArrayList<>();\n+    public void testInsertAndSelect() throws IOException, DDlogException {\n+        String s1 = \"create table hosts (id varchar(36), capacity integer, up boolean)\";\n+        String v2 = \"create view hostsv as select distinct * from hosts\";\n+        String v1 = \"create view good_hosts as select distinct * from hosts where capacity < 10\";\n+        List<String> ddl = new ArrayList<>();\n         ddl.add(s1);\n         ddl.add(v2);\n         ddl.add(v1);\n+        compileAndLoad(\"testInserts\", ddl);\n+        final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n \n         // Initialise the data provider\n         MockDataProvider provider = new DDlogJooqProvider(dDlogAPI, ddl);\n         MockConnection connection = new MockConnection(provider);\n \n         // Pass the mock connection to a jOOQ DSLContext:\n         DSLContext create = DSL.using(connection);\n-        final Result<Record> fetch = create.fetch(\"select * from hostsv\");\n-        assertEquals(numInserts, fetch.size());\n-        assertArrayEquals(new int[]{0, 1, 2, 3, 4},\n-                          fetch.stream().mapToInt(r -> r.get(0, Integer.class)).toArray());\n+\n+        // Test 1: insert statements.", "originalCommit": "fc9f3db754593e963d126f818e714445c28732be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI0NzA1Nw==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520247057", "bodyText": "For now, these are not independent tests because I can't delete all data from tables yet. I'll refactor that out later.", "author": "lalithsuresh", "createdAt": "2020-11-10T02:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNTI1OQ=="}], "type": "inlineReview"}, {"oid": "7740884fde54820a6f2eb982cce263b24e2a14a2", "url": "https://github.com/vmware/differential-datalog/commit/7740884fde54820a6f2eb982cce263b24e2a14a2", "message": "Use Presto API to parse queries in DdlogJooqProvider\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-10T02:06:51Z", "type": "commit"}, {"oid": "749d6fa1ba08025c6597d620ba78f45cbfa0eb6a", "url": "https://github.com/vmware/differential-datalog/commit/749d6fa1ba08025c6597d620ba78f45cbfa0eb6a", "message": "Add comments to DDlogJooqProvider\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-10T02:32:07Z", "type": "commit"}, {"oid": "6c7dc48662a2db2f9e017b4f2a859b46a0832522", "url": "https://github.com/vmware/differential-datalog/commit/6c7dc48662a2db2f9e017b4f2a859b46a0832522", "message": "Rename DDLOG_{SOME,NONE}_TYPE to DDLOG_{SOME,NONE}\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-10T02:34:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI1MzA4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520253081", "bodyText": "this is a bit inconsistent, sometimes you throw, sometimes you assert.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T02:52:29Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -24,78 +42,226 @@\n import java.util.List;\n import java.util.Map;\n \n+import static org.jooq.impl.DSL.field;\n+\n+\n+/**\n+ * This class provides a restricted mechanism to make a DDlog program appear like an SQL database that can be\n+ * queried over a JDBC connection. To initialize, it requires a set of \"create table\" and \"create view\" statements\n+ * to be supplied during initialization. For example:\n+ *\n+ *         final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n+ *\n+ *         // Initialise the data provider. ddl represents a list of Strings that are SQL DDL statements\n+ *         // like \"create table\" and \"create view\"\n+ *         MockDataProvider provider = new DDlogJooqProvider(dDlogAPI, ddl);\n+ *         MockConnection connection = new MockConnection(provider);\n+ *\n+ *         // Pass the mock connection to a jOOQ DSLContext:\n+ *         DSLContext create = DSL.using(connection);\n+ *\n+ * After that, the connection that is created with this MockProvider can execute a restricted subset of SQL queries.\n+ * We assume these queries are of one of the following forms:\n+ *   A1. \"select * from T\" where T is a table name which corresponds to a ddlog output relation. By definition,\n+ *                        T can therefore only be an SQL view for which there is a corresponding\n+ *                        \"create view T as ...\" that is passed to the  DdlogJooqProvider.\n+ *   A2. \"insert into T values (<row>)\" where T is a base table. That is, there should be a corresponding\n+ *                                     \"create table T...\" DDL statement that is passed to the DDlogJooqProvider.\n+ */\n public class DDlogJooqProvider implements MockDataProvider {\n     private static final String INTEGER_TYPE = \"java.lang.Integer\";\n     private static final String STRING_TYPE = \"java.lang.String\";\n     private static final String BOOLEAN_TYPE = \"java.lang.Boolean\";\n     private static final String LONG_TYPE = \"java.lang.Long\";\n-\n+    private static final String DDLOG_SOME = \"ddlog_std::Some\";\n+    private static final String DDLOG_NONE = \"ddlog_std::None\";\n     private final DDlogAPI dDlogAPI;\n     private final DSLContext dslContext;\n+    private final Field<Integer> updateCountField;\n     private final Map<String, List<Field<?>>> tables = new HashMap<>();\n+    private final SqlParser parser = new SqlParser();\n+    private final ParsingOptions options = ParsingOptions.builder().build();\n+    private final QueryVisitor queryVisitor = new QueryVisitor();\n+    private final ParseLiterals parseLiterals = new ParseLiterals();\n \n     public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatements) {\n         this.dDlogAPI = dDlogAPI;\n-        dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.updateCountField = field(\"UPDATE_COUNT\", Integer.class);\n         for (final String sql : sqlStatements) {\n             dslContext.execute(sql);\n         }\n         for (final Table<?> table: dslContext.meta().getTables()) {\n-            if (table.getSchema().getName().equals(\"PUBLIC\")) {\n+            if (table.getSchema().getName().equals(\"PUBLIC\")) { // H2-specific assumption\n                 tables.put(table.getName(), Arrays.asList(table.fields()));\n             }\n         }\n     }\n \n+    /*\n+     * All executed SQL queries against a JOOQ connection are received here\n+     */\n     @Override\n     public MockResult[] execute(final MockExecuteContext ctx) throws SQLException {\n-        final MockResult[] mock = new MockResult[1];\n-        // The execute context contains SQL string(s), bind values, and other meta-data\n-        final String sql = ctx.sql();\n-\n-        if (sql.toUpperCase().startsWith(\"SELECT\")) {\n-            mock[0] = executeSelectStar(sql);\n-        } else {\n-            // Exceptions are propagated through the JDBC and jOOQ APIs\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+        final String[] batchSql = ctx.batchSQL();\n+        final MockResult[] mock = new MockResult[batchSql.length];\n+        try {\n+            dDlogAPI.transactionStart();\n+            for (int i = 0; i < batchSql.length; i++) {\n+                mock[i] = executeOne(batchSql[i]);\n+            }\n+            dDlogAPI.transactionCommit();\n+        } catch (final DDlogException e) {\n+            throw new RuntimeException(e);\n         }\n         return mock;\n     }\n \n-    private MockResult executeSelectStar(final String sql) throws SQLException {\n-        final String[] s = sql.toUpperCase().split(\" \");\n-        if (!(s.length == 4 && s[1].equals(\"*\") && s[2].equals(\"FROM\"))) {\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+    private MockResult executeOne(final String sql) throws SQLException {\n+        final Statement statement = parser.createStatement(sql, options);\n+        final MockResult result = queryVisitor.process(statement, sql);\n+        if (result == null) {\n+            throw new SQLException(\"Could not execute SQL statement \" + sql);\n         }\n-        final String tableName = s[3];\n-        final List<Field<?>> fields = tables.get(tableName);\n-        if (fields == null) {\n-            throw new SQLException(\"Unknown table: \" + tableName);\n+        return result;\n+    }\n+\n+    /*\n+     * Visits an SQL query and converts into a JOOQ MockResult type.\n+     */\n+    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+        @Override\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final Select select = node.getSelect();\n+            if (!(select.getSelectItems().size() == 1 && select.getSelectItems().get(0) instanceof AllColumns)) {\n+                throw new RuntimeException(\"Statement not supported: \" + sql);\n+            }\n+            assert node.getFrom().isPresent() && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table;", "originalCommit": "6c7dc48662a2db2f9e017b4f2a859b46a0832522", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI3OTYzOQ==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520279639", "bodyText": "Done!", "author": "lalithsuresh", "createdAt": "2020-11-10T04:31:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI1MzA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI1MzU2NA==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520253564", "bodyText": "I have some helper function Linq.map/zip/any that you may want to occasionally use.", "author": "mbudiu-vmw", "createdAt": "2020-11-10T02:54:07Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -24,78 +42,226 @@\n import java.util.List;\n import java.util.Map;\n \n+import static org.jooq.impl.DSL.field;\n+\n+\n+/**\n+ * This class provides a restricted mechanism to make a DDlog program appear like an SQL database that can be\n+ * queried over a JDBC connection. To initialize, it requires a set of \"create table\" and \"create view\" statements\n+ * to be supplied during initialization. For example:\n+ *\n+ *         final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n+ *\n+ *         // Initialise the data provider. ddl represents a list of Strings that are SQL DDL statements\n+ *         // like \"create table\" and \"create view\"\n+ *         MockDataProvider provider = new DDlogJooqProvider(dDlogAPI, ddl);\n+ *         MockConnection connection = new MockConnection(provider);\n+ *\n+ *         // Pass the mock connection to a jOOQ DSLContext:\n+ *         DSLContext create = DSL.using(connection);\n+ *\n+ * After that, the connection that is created with this MockProvider can execute a restricted subset of SQL queries.\n+ * We assume these queries are of one of the following forms:\n+ *   A1. \"select * from T\" where T is a table name which corresponds to a ddlog output relation. By definition,\n+ *                        T can therefore only be an SQL view for which there is a corresponding\n+ *                        \"create view T as ...\" that is passed to the  DdlogJooqProvider.\n+ *   A2. \"insert into T values (<row>)\" where T is a base table. That is, there should be a corresponding\n+ *                                     \"create table T...\" DDL statement that is passed to the DDlogJooqProvider.\n+ */\n public class DDlogJooqProvider implements MockDataProvider {\n     private static final String INTEGER_TYPE = \"java.lang.Integer\";\n     private static final String STRING_TYPE = \"java.lang.String\";\n     private static final String BOOLEAN_TYPE = \"java.lang.Boolean\";\n     private static final String LONG_TYPE = \"java.lang.Long\";\n-\n+    private static final String DDLOG_SOME = \"ddlog_std::Some\";\n+    private static final String DDLOG_NONE = \"ddlog_std::None\";\n     private final DDlogAPI dDlogAPI;\n     private final DSLContext dslContext;\n+    private final Field<Integer> updateCountField;\n     private final Map<String, List<Field<?>>> tables = new HashMap<>();\n+    private final SqlParser parser = new SqlParser();\n+    private final ParsingOptions options = ParsingOptions.builder().build();\n+    private final QueryVisitor queryVisitor = new QueryVisitor();\n+    private final ParseLiterals parseLiterals = new ParseLiterals();\n \n     public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatements) {\n         this.dDlogAPI = dDlogAPI;\n-        dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.updateCountField = field(\"UPDATE_COUNT\", Integer.class);\n         for (final String sql : sqlStatements) {\n             dslContext.execute(sql);\n         }\n         for (final Table<?> table: dslContext.meta().getTables()) {\n-            if (table.getSchema().getName().equals(\"PUBLIC\")) {\n+            if (table.getSchema().getName().equals(\"PUBLIC\")) { // H2-specific assumption\n                 tables.put(table.getName(), Arrays.asList(table.fields()));\n             }\n         }\n     }\n \n+    /*\n+     * All executed SQL queries against a JOOQ connection are received here\n+     */\n     @Override\n     public MockResult[] execute(final MockExecuteContext ctx) throws SQLException {\n-        final MockResult[] mock = new MockResult[1];\n-        // The execute context contains SQL string(s), bind values, and other meta-data\n-        final String sql = ctx.sql();\n-\n-        if (sql.toUpperCase().startsWith(\"SELECT\")) {\n-            mock[0] = executeSelectStar(sql);\n-        } else {\n-            // Exceptions are propagated through the JDBC and jOOQ APIs\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+        final String[] batchSql = ctx.batchSQL();\n+        final MockResult[] mock = new MockResult[batchSql.length];\n+        try {\n+            dDlogAPI.transactionStart();\n+            for (int i = 0; i < batchSql.length; i++) {\n+                mock[i] = executeOne(batchSql[i]);\n+            }\n+            dDlogAPI.transactionCommit();\n+        } catch (final DDlogException e) {\n+            throw new RuntimeException(e);\n         }\n         return mock;\n     }\n \n-    private MockResult executeSelectStar(final String sql) throws SQLException {\n-        final String[] s = sql.toUpperCase().split(\" \");\n-        if (!(s.length == 4 && s[1].equals(\"*\") && s[2].equals(\"FROM\"))) {\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+    private MockResult executeOne(final String sql) throws SQLException {\n+        final Statement statement = parser.createStatement(sql, options);\n+        final MockResult result = queryVisitor.process(statement, sql);\n+        if (result == null) {\n+            throw new SQLException(\"Could not execute SQL statement \" + sql);\n         }\n-        final String tableName = s[3];\n-        final List<Field<?>> fields = tables.get(tableName);\n-        if (fields == null) {\n-            throw new SQLException(\"Unknown table: \" + tableName);\n+        return result;\n+    }\n+\n+    /*\n+     * Visits an SQL query and converts into a JOOQ MockResult type.\n+     */\n+    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+        @Override\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final Select select = node.getSelect();\n+            if (!(select.getSelectItems().size() == 1 && select.getSelectItems().get(0) instanceof AllColumns)) {\n+                throw new RuntimeException(\"Statement not supported: \" + sql);\n+            }\n+            assert node.getFrom().isPresent() && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table;\n+            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n+            final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+            if (fields == null) {\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+            }\n+            final Result<Record> result = dslContext.newResult(fields);\n+            try {\n+                dDlogAPI.dumpTable(ddlogRelationName(tableName), (record, l) -> {\n+                    final Record jooqRecord = dslContext.newRecord(fields);\n+                    final Object[] returnValue = new Object[fields.size()];\n+                    for (int i = 0; i < fields.size(); i++) {\n+                        returnValue[i] = structToValue(fields.get(i), record.getStructField(i));\n+                    }\n+                    jooqRecord.fromArray(returnValue);\n+                    result.add(jooqRecord);\n+                });\n+            } catch (final DDlogException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return new MockResult(1, result);\n         }\n-        final Result<Record> result = dslContext.newResult(fields);\n-        try {\n-            dDlogAPI.dumpTable(\"R\" + tableName.toLowerCase(), (record, l) -> {\n-                final Record jooqRecord = dslContext.newRecord(fields);\n-                final Object[] returnValue = new Object[fields.size()];\n-                for (int i = 0; i < fields.size(); i++) {\n-                    returnValue[i] = structToValue(fields.get(i), record.getStructField(i));\n+\n+        @Override\n+        protected MockResult visitQuery(final Query node, final String context) {\n+            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n+            return visitQuerySpecification(specification, context);\n+        }\n+\n+        @Override\n+        protected MockResult visitInsert(final Insert node, final String sql) {\n+            try {\n+                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n+                assert node.getQuery().getQueryBody() instanceof Values;\n+                final Values values = (Values) node.getQuery().getQueryBody();\n+                final String tableName = node.getTarget().toString();\n+                final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                for (final Expression row: values.getRows()) {\n+                    assert row instanceof Row;\n+                    final List<Expression> items = ((Row) row).getItems();\n+                    assert items.size() == fields.size();\n+                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n+                    for (int i = 0; i < items.size(); i++) {", "originalCommit": "6c7dc48662a2db2f9e017b4f2a859b46a0832522", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI4MDU5MQ==", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520280591", "bodyText": "I could use Java streams too but this looks simple enough.", "author": "lalithsuresh", "createdAt": "2020-11-10T04:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI1MzU2NA=="}], "type": "inlineReview"}, {"oid": "e14018918d3cf9910af05bea51870f2e02d1e51f", "url": "https://github.com/vmware/differential-datalog/commit/e14018918d3cf9910af05bea51870f2e02d1e51f", "message": "Change assertions to throw Exceptions instead\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-10T04:31:04Z", "type": "commit"}]}