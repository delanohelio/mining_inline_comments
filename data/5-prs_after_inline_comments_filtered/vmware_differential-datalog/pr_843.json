{"pr_number": 843, "pr_title": "ddlog-jooq: support UPDATE queries", "pr_createdAt": "2020-12-05T06:58:33Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/843", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MjkyMA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537782920", "bodyText": "so you use two different parsers? Can't you standardize on one?", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:45:16Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -107,6 +103,9 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         // We translate DDL statements from the Presto dialect to H2.\n         // We then execute these statements in a temporary database so that JOOQ can extract useful metadata\n         // that we will use later (for example, the record types for views).\n+        final com.facebook.presto.sql.parser.SqlParser parser = new com.facebook.presto.sql.parser.SqlParser();", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgwODc0OA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537808748", "bodyText": "This has implications for the ddlog-sql compiler. Right now, that code expects DDL in Presto's dialect, which is why I have to convert from Presto's dialect here (and therefore need the Presto parser).", "author": "lalithsuresh", "createdAt": "2020-12-07T20:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MjkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NDYzMQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537784631", "bodyText": "Why not visitSelect((SqlSelect)call)?", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:47:45Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NTc1Nw==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537785757", "bodyText": "This is not checked, but I guess you will get an exception anyway if it's not just a table.", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:49:45Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxMDgxOQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537810819", "bodyText": "Yes, I'm hoping it'll fail anyway.", "author": "lalithsuresh", "createdAt": "2020-12-07T20:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NTc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4Njc4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537786781", "bodyText": "other people put the else on the same line with the }", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:51:25Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NzkwNA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537787904", "bodyText": "\"not supported\" sounds a bit better than \"unsupported\"", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:53:07Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODM3Nw==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537788377", "bodyText": "this line occurs in every function, maybe you can make it a separate method and do some nicer error handling?", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:53:59Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxNDUyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537814521", "bodyText": "getTargetTable() and getFrom() are not abstract methods, so it won't be easy to have a single method to do this. I've added an instanceof check to the beginning of each visit method.", "author": "lalithsuresh", "createdAt": "2020-12-07T20:36:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODk2OQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537788969", "bodyText": "do you want to lift getTargetColumnList out of the loop?", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:54:53Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTYwNQ==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537789605", "bodyText": "This is a linear search. Could become expensive if you have many fields. You could build a hashmap with this information...", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:55:53Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537792052", "bodyText": "what does this do, concatenate the arrays?", "author": "mbudiu-vmw", "createdAt": "2020-12-07T19:59:38Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n \n-        public ParseWhereClauseForDeletes(final String tableName) {\n-            this.tableName = tableName;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n-        }\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n \n-        @Override\n-        protected Void visitLogicalBinaryExpression(final LogicalBinaryExpression node, final QueryContext context) {\n-            if (!node.getOperator().equals(LogicalBinaryExpression.Operator.AND)) {\n-                throw new RuntimeException(\"Only equality-based comparisons on \" +\n-                        \"all (not some) primary-key columns are allowed: \" + node);\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n             }\n-            return super.visitLogicalBinaryExpression(node, context);\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n+    }\n+\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n+\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n+            this.context = context;\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        protected Void visitComparisonExpression(final ComparisonExpression node, final QueryContext context) {\n-            final Expression left = node.getLeft();\n-            final Expression right = node.getRight();\n-            if (context.hasBinding()) {\n-                if (left instanceof Identifier && right instanceof Parameter) {\n-                    setMatchExpression((Identifier) left, context.nextBinding());\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Parameter) {\n-                    setMatchExpression((Identifier) right, context.nextBinding());\n-                    return null;\n-                }\n-            } else {\n-                if (left instanceof Identifier && right instanceof Literal) {\n-                    setMatchExpression((Identifier) left, (Literal) right);\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Literal) {\n-                    setMatchExpression((Identifier) right, (Literal) left);\n-                    return null;\n-                }\n+        public DDlogRecord[] visit(final SqlCall call) {\n+            final SqlBasicCall expr = (SqlBasicCall) call;\n+            switch (expr.getOperator().getKind()) {\n+                case AND:\n+                    return super.visit(call);", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjYyOA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537842628", "bodyText": "It should, it doesn't, and good catch. :) I'll add a test that exercises this case.", "author": "lalithsuresh", "createdAt": "2020-12-07T21:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5OTg4Mg==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537899882", "bodyText": "Actually, now that I look at the code, there's no change necessary. It just returns the matchExpressions[] array, which by the time that call returns, would have traversed every \"EQUALS\" node.\nI still need to add a test for this case. Will do that in the updated PR.", "author": "lalithsuresh", "createdAt": "2020-12-07T23:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjcyOA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537792728", "bodyText": "CHAR is string?", "author": "mbudiu-vmw", "createdAt": "2020-12-07T20:00:47Z", "path": "sql/src/main/java/com/vmware/ddlog/ParseLiterals.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2018-2020 VMware, Inc. All Rights Reserved.\n+ * SPDX-License-Identifier: BSD-2\n+ */\n+\n+package com.vmware.ddlog;\n+\n+import ddlogapi.DDlogException;\n+import ddlogapi.DDlogRecord;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+\n+/*\n+ * Translates literals into corresponding DDlogRecord instances\n+ */\n+class ParseLiterals extends SqlBasicVisitor<DDlogRecord> {\n+\n+    @Override\n+    public DDlogRecord visit(final SqlLiteral sqlLiteral) {\n+        switch (sqlLiteral.getTypeName()) {\n+            case BOOLEAN:\n+                return new DDlogRecord(sqlLiteral.booleanValue());\n+            case DECIMAL:\n+                return new DDlogRecord(sqlLiteral.intValue(false));\n+            case CHAR:", "originalCommit": "39816ed18fbadb211b008dfcca47da8c6c3bae43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0Mjc4NA==", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537842784", "bodyText": "Surprised me too, but yes.", "author": "lalithsuresh", "createdAt": "2020-12-07T21:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjcyOA=="}], "type": "inlineReview"}, {"oid": "c8e7071ca84958a5ed6e25c1590b73f32ce06040", "url": "https://github.com/vmware/differential-datalog/commit/c8e7071ca84958a5ed6e25c1590b73f32ce06040", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-04T21:40:25Z", "type": "forcePushed"}, {"oid": "09f1408d8ad6000b1bb01f3bb238560b51124682", "url": "https://github.com/vmware/differential-datalog/commit/09f1408d8ad6000b1bb01f3bb238560b51124682", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-28T00:07:11Z", "type": "forcePushed"}, {"oid": "be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "url": "https://github.com/vmware/differential-datalog/commit/be85e2363a98dd98b4f63c0b8da9853d3cab2f37", "message": "Migrate to new parsing API\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "41cb5cc105e607b6a7f3a456d936f7211c9008e5", "url": "https://github.com/vmware/differential-datalog/commit/41cb5cc105e607b6a7f3a456d936f7211c9008e5", "message": "Use fully qualified names for Presto parser\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "3baab395a3425791ba9da7b6539a0f8382a579b4", "url": "https://github.com/vmware/differential-datalog/commit/3baab395a3425791ba9da7b6539a0f8382a579b4", "message": "ddlog-jooq: move literal parsing visitor to its own class\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "47b6a589885b6090be50f8cebccd8db3de9be1a9", "url": "https://github.com/vmware/differential-datalog/commit/47b6a589885b6090be50f8cebccd8db3de9be1a9", "message": "ddlog-jooq: use MockResult API to propagate exceptions to callers\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "1b1275648226e7e3ea7d62750145dac195e341f4", "url": "https://github.com/vmware/differential-datalog/commit/1b1275648226e7e3ea7d62750145dac195e341f4", "message": "ddlog-jooq: make WhereClauseToMatchExpression static\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "7e431c4baec6f157e296edaccd55304d14924d7a", "url": "https://github.com/vmware/differential-datalog/commit/7e431c4baec6f157e296edaccd55304d14924d7a", "message": "ddlog-jooq: add an API to fetch results by short-cutting JOOQ\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "3ce804e09c32dda97e3fc2d1bab6f4c91f6a8317", "url": "https://github.com/vmware/differential-datalog/commit/3ce804e09c32dda97e3fc2d1bab6f4c91f6a8317", "message": "ddlog-jooq: add assert condition\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "c7f6b8c72ca02b69a1da31ef36d89d2271419952", "url": "https://github.com/vmware/differential-datalog/commit/c7f6b8c72ca02b69a1da31ef36d89d2271419952", "message": "ddlog-jooq: support update statements with bindings\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "4679477dae4d7dec057eb733edbd3983bb954f8a", "url": "https://github.com/vmware/differential-datalog/commit/4679477dae4d7dec057eb733edbd3983bb954f8a", "message": "ddlog-jooq: add documentation for UPDATE queries. Re-order methods.\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "url": "https://github.com/vmware/differential-datalog/commit/16e81dde1c59f7eead08b7cb755bdad9abe23c82", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "commit"}, {"oid": "16e81dde1c59f7eead08b7cb755bdad9abe23c82", "url": "https://github.com/vmware/differential-datalog/commit/16e81dde1c59f7eead08b7cb755bdad9abe23c82", "message": "ddlog-jooq: address comments from code review\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2021-01-29T02:15:32Z", "type": "forcePushed"}]}