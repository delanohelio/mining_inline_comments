{"pr_number": 699, "pr_title": "Streams and multisets.", "pr_createdAt": "2020-07-09T07:11:09Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/699", "timeline": [{"oid": "914f4a435bdbc4a5e5c2d001219fce638f859bb2", "url": "https://github.com/vmware/differential-datalog/commit/914f4a435bdbc4a5e5c2d001219fce638f859bb2", "message": "Test for #593.\n\nAdded test for #593, which is resolved with the introduction of type inference\nengine.", "committedDate": "2020-07-07T05:48:02Z", "type": "commit"}, {"oid": "ba43e716823139cf30de0fcff8351f1432e776a7", "url": "https://github.com/vmware/differential-datalog/commit/ba43e716823139cf30de0fcff8351f1432e776a7", "message": "Streams and multisets.\n\nSo far, all DDlog relations implemented set semantics.  A set can\ncontain at most one instance of each value.  If the same value is\ninserted in the relation multiple times, all but the last insertion are\nignored (or fail if the relation has a primary key).  Likewise, repeated\ndeletions are ignored or fail.  Similarly, DDlog ensures that output\nrelations behave as sets, e.g., the same value cannot be inserted\nmultiple times, unless it is deleted in between.  While this behavior\nmatches the requirements of most applications, there are cases when\nrelations with non-unit multiplicities are useful.  Consider, for\nexample, an input relation that receives inputs from two sources, that\ncan both produce the same value (at which point its multiplicity is 2).\nThe value should only be removed from the relation once it has been\nremoved from both sources, i.e., its multiplicity drops to 0.  In other\nwords, we would like the relation to have *multiset*, rather than set\nsemantics.\n\nThis commit introduces support for multisets that are declared using the\n`multiset` keyword instead of `relation`:\n\n```\ninput multiset MSetIn(x: u32)\n```\n\nValues in a multiset relation can have both positive and negative\nmultiplicities: deleting a non-existent value introduces the value with\nmultiplicity `-1`.  Therefore, such relations can be more precisely\ndescribed as *generalized*, rather than ordinary *multisets*.  An output\nrelation can also be declared as `multiset`, in which case DDlog can\nderive the same output value multiple times, so that `dump` and `commit\ndump_changes` commands will output records with non-unit multiplicities:\n\n```\noutput multiset MSetOut(x: u32)\nMSetOut(x) :- MSetIn(x).\n```\n\nThe following scenario illustrates the semantics of multisets:\n\n```\n start;\n insert MSetIn(0),\n # appear twice in MSetOut.\n insert MSetIn(1),\n insert MSetIn(1),\n commit dump_changes;\n # expected output:\n # MSetOut:\n # MSetOut{.x = 0}: +1\n # MSetOut{.x = 1}: +2\n start;\n # Add one more instance of the same record.\n insert MSetIn(1), commit dump_changes;\n # expected output:\n # MSetOut:\n # MSetOut{.x = 1}: +1\n start;\n # Delete one instance of the record; we're down to 2.\n delete MSetIn(1),\n commit dump_changes;\n # expected output:\n # MSetOut:\n # MSetOut{.x = 1}: -1\n dump MSetOut;\n # expected output:\n # MSetOut{.x = 0} +1\n # MSetOut{.x = 1} +2\n ```\n\nOutput `multiset`s are more memory-efficient than `relation`s.  DDlog enforces\nset semantics by using the Differential Dataflow `distinct` operator, which\ninternally maintains an indexed representation of the output relation.\nMultisets avoid this overhead.\n\nStreams are yet another new kind of relation that are similar to multisets\nwith one additional optimization.  Normally, DDlog stores a copy of the entire\ncontents of an `input relation` or `input multiset`.  This copy is used to\nimplement the `clear` command, which removes everything from the relation.  In\naddition, it is necessary to enforce the set semantics on `relation`s.  A stream\nis a multiset, whose contents is not cached by DDlog, thus reducing the memory\nfootprint of the program.  As a result, it is illegal to use the `clear` command\non a stream.\n\n```\n// Declare an input stream.\ninput stream StreamIn(x: u32)\n```\n\nThis change affects all language APIs, as all API callbacks (on-commit,\non-commit-dump-changes, relation-dump) can observe records with non-unit\nmultiplicities, so we replace Boolean polarity with weight of type `ssize_t`.", "committedDate": "2020-07-09T06:48:38Z", "type": "commit"}, {"oid": "e164e836b5ed0a8c6027d88b2b7e0af3138df666", "url": "https://github.com/vmware/differential-datalog/commit/e164e836b5ed0a8c6027d88b2b7e0af3138df666", "message": "tutorial.md: Document type inference.\n\n- Added a couple of paragraphs on type inference and type annotations.\n- Added a \"pro tip\" to use `bigint` sparingly, as I keep seeing DDlog\n  code that uses bigint's for no good reason.", "committedDate": "2020-07-09T06:48:38Z", "type": "commit"}, {"oid": "b9b1a3d24ccd6d9514dc9d284caf565c7a29f50b", "url": "https://github.com/vmware/differential-datalog/commit/b9b1a3d24ccd6d9514dc9d284caf565c7a29f50b", "message": "Tutorial section on multisets and streams.", "committedDate": "2020-07-09T06:48:38Z", "type": "commit"}, {"oid": "84d22e271466d221b613c16af8121b3562863798", "url": "https://github.com/vmware/differential-datalog/commit/84d22e271466d221b613c16af8121b3562863798", "message": "Don't run souffle tests in Travis.\n\nThe test no longer works on MacOS, as subversion installation fails in\nTravis.  Since these tests run in gitlab anyway, there is no hard in\ndisabling them.", "committedDate": "2020-07-09T07:05:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NTM3MA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452355370", "bodyText": "Now you wonder why you need two different commands...\nI think that it should be just the opposite: convert Delete to a negative insertion.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:49:53Z", "path": "java/ddlogapi/DDlogAPI.java", "diffHunk": "@@ -359,11 +358,11 @@ public int clearRelation(int relid) throws DDlogException {\n     }\n \n     // Callback invoked from commit_dump_changes.\n-    void onDelta(int tableid, long handle, boolean polarity) {\n+    void onDelta(int tableid, long handle, long weight) {\n         if (this.deltaCallback != null) {\n-            DDlogCommand.Kind kind = polarity ? DDlogCommand.Kind.Insert : DDlogCommand.Kind.DeleteVal;\n+            DDlogCommand.Kind kind = weight > 0 ? DDlogCommand.Kind.Insert : DDlogCommand.Kind.DeleteVal;", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MDgwNQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452440805", "bodyText": "I tried that, but then realized that I still need a way to distinguish DeleteVal and DeleteKey, and potentially other commands in the future, so we need both weight and kind.", "author": "ryzhyk", "createdAt": "2020-07-09T19:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NTYyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452355621", "bodyText": "Is the new Long necesary? I think that boxing will do this for you automatically.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:50:17Z", "path": "java/ddlogapi/DDlogAPI.java", "diffHunk": "@@ -476,10 +475,10 @@ public void dumpIndexToFlatBuf(long idxid, FlatBufDescr resfb) throws DDlogExcep\n     }\n \n     /// Callback invoked from dump.\n-    boolean dumpCallback(long handle) {\n+    boolean dumpCallback(long handle, long weight) {\n         if (this.dumpCallback != null) {\n             DDlogRecord record = DDlogRecord.fromSharedHandle(handle);\n-            this.dumpCallback.accept(record);\n+            this.dumpCallback.accept(record, new Long(weight));", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NjY4Ng==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452356686", "bodyText": "you could also assert that w is 1.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:52:10Z", "path": "java/test/SpanTest.java", "diffHunk": "@@ -403,11 +403,11 @@ void parseLine(String line)\n                     } else {\n                         System.out.println(\"ContainerSpan:\");\n                         this.api.dumpTable(\"ContainerSpan\",\n-                                r -> System.out.println(new ContainerSpan(r)));\n+                                (r, w) -> System.out.println(new ContainerSpan(r)));", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "93c68c0455a6f7ad3ff424765a3823f8a33800ee", "url": "https://github.com/vmware/differential-datalog/commit/93c68c0455a6f7ad3ff424765a3823f8a33800ee", "message": "Address review comments.", "committedDate": "2020-07-09T19:37:55Z", "type": "commit"}]}